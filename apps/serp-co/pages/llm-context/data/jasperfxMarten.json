[
  {
    "owner": "jasperfx",
    "repo": "marten",
    "content": "TITLE: Defining a TripProjection Aggregate - C#\nDESCRIPTION: This code defines a `TripProjection` class that inherits from `SingleStreamProjection<Trip>`. It demonstrates how to define a single stream projection that creates, deletes, and mutates a `Trip` aggregate document based on events in a single stream. It utilizes both lambda expressions and named methods to handle events like `Arrival`, `Travel`, `TripEnded`, and `TripStarted`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/aggregate-projections.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic class TripProjection: SingleStreamProjection<Trip>\n{\n    public TripProjection()\n    {\n        DeleteEvent<TripAborted>();\n\n        DeleteEvent<Breakdown>(x => x.IsCritical);\n\n        DeleteEvent<VacationOver>((trip, _) => trip.Traveled > 1000);\n    }\n\n    // These methods can be either public, internal, or private but there's\n    // a small performance gain to making them public\n    public void Apply(Arrival e, Trip trip) => trip.State = e.State;\n    public void Apply(Travel e, Trip trip) => trip.Traveled += e.TotalDistance();\n\n    public void Apply(TripEnded e, Trip trip)\n    {\n        trip.Active = false;\n        trip.EndedOn = e.Day;\n    }\n\n    public Trip Create(TripStarted started)\n    {\n        return new Trip { StartedOn = started.Day, Active = true };\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Simplifying event stream handling with WriteToAggregate in Marten\nDESCRIPTION: This code demonstrates using the `WriteToAggregate` method to simplify event stream handling in Marten. It takes an `Order` aggregate ID and version, then processes a `MarkItemReady` command. The handler appends events based on the command and the current aggregate state. This method combines fetching, processing, and saving changes into a single, concise operation.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/scenarios/command_handler_workflow.md#_snippet_6\n\nLANGUAGE: cs\nCODE:\n```\npublic Task Handle4(MarkItemReady command, IDocumentSession session)\n{\n    return session.Events.WriteToAggregate<Order>(command.OrderId, command.Version, stream =>\n    {\n        var order = stream.Aggregate;\n\n        if (order.Items.TryGetValue(command.ItemName, out var item))\n        {\n            // Mark that the this item is ready\n            stream.AppendOne(new ItemReady(command.ItemName));\n        }\n        else\n        {\n            // Some crude validation\n            throw new InvalidOperationException($\"Item {command.ItemName} does not exist in this order\");\n        }\n\n        // If the order is ready to ship, also emit an OrderReady event\n        if (order.IsReadyToShip())\n        {\n            stream.AppendOne(new OrderReady());\n        }\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Event Projection with Inline Document Operations (C#)\nDESCRIPTION: Demonstrates how to define an EventProjection in Marten that specifies document operations directly within the event projection class. This example shows creating and deleting documents based on different events, using both synchronous and asynchronous methods, and accessing event metadata. It leverages the `Project<>` methods to define inline document operations based on specific event types.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/event-projections.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic class SampleEventProjection : EventProjection\n{\n    public SampleEventProjection()\n    {\n        // Inline document operations\n        Project<Event1>((e, ops) =>\n        {\n            // I'm creating a single new document, but\n            // I can do as many operations as I want\n            ops.Store(new Document1\n            {\n                Id = e.Id\n            });\n        });\n\n        Project<StopEvent1>((e, ops) =>\n        {\n            ops.Delete<Document1>(e.Id);\n        });\n\n        ProjectAsync<Event3>(async (e, ops) =>\n        {\n            var lookup = await ops.LoadAsync<Lookup>(e.LookupId);\n            // now use the lookup document and the event to carry\n            // out other document operations against the ops parameter\n        });\n    }\n\n    // This is the conventional method equivalents to the inline calls above\n    public Document1 Create(Event1 e) => new Document1 {Id = e.Id};\n\n    // Or with event metadata\n    public Document2 Create(IEvent<Event2> e) => new Document2 { Id = e.Data.Id, Timestamp = e.Timestamp };\n\n    public void Project(StopEvent1 e, IDocumentOperations ops)\n        => ops.Delete<Document1>(e.Id);\n\n    public async Task Project(Event3 e, IDocumentOperations ops)\n    {\n        var lookup = await ops.LoadAsync<Lookup>(e.LookupId);\n        // now use the lookup document and the event to carry\n        // out other document operations against the ops parameter\n    }\n\n    // This will apply to *any* event that implements the ISpecialEvent\n    // interface. Likewise, the pattern matching will also work with\n    // common base classes\n    public void Project(ISpecialEvent e, IDocumentOperations ops)\n    {\n\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Marten in ASP.NET Core Endpoints\nDESCRIPTION: This snippet showcases how to use Marten's `IDocumentStore` and `IDocumentSession` to persist and query documents within ASP.NET Core endpoints. It demonstrates creating, storing, and querying user documents, as well as loading a document by its ID.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/getting-started.md#_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n// You can inject the IDocumentStore and open sessions yourself\napp.MapPost(\"/user\",\n    async (CreateUserRequest create, [FromServices] IDocumentStore store) =>\n{\n    // Open a session for querying, loading, and updating documents\n    await using var session = store.LightweightSession();\n\n    var user = new User {\n        FirstName = create.FirstName,\n        LastName = create.LastName,\n        Internal = create.Internal\n    };\n    session.Store(user);\n\n    await session.SaveChangesAsync();\n});\n\napp.MapGet(\"/users\",\n    async (bool internalOnly, [FromServices] IDocumentStore store, CancellationToken ct) =>\n{\n    // Open a session for querying documents only\n    await using var session = store.QuerySession();\n\n    return await session.Query<User>()\n        .Where(x=> x.Internal == internalOnly)\n        .ToListAsync(ct);\n});\n\n// OR Inject the session directly to skip the management of the session lifetime\napp.MapGet(\"/user/{id:guid}\",\n    async (Guid id, [FromServices] IQuerySession session, CancellationToken ct) =>\n{\n    return await session.LoadAsync<User>(id, ct);\n});\n```\n\n----------------------------------------\n\nTITLE: Get Issue Controller using IQuerySession\nDESCRIPTION: This snippet demonstrates using IQuerySession in an ASP.NET Core MVC controller to retrieve Issue documents by ID using LoadAsync and to write a JSON response using WriteById. It injects IQuerySession via dependency injection.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/sessions.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\npublic class GetIssueController: ControllerBase\n{\n    private readonly IQuerySession _session;\n\n    public GetIssueController(IQuerySession session)\n    {\n        _session = session;\n    }\n\n    [HttpGet(\"/issue/{issueId}\")]\n    public Task<Issue> Get(Guid issueId)\n    {\n        return _session.LoadAsync<Issue>(issueId);\n    }\n\n    [HttpGet(\"/issue/fast/{issueId}\")]\n    public Task GetFast(Guid issueId)\n    {\n        return _session.Json.WriteById<Issue>(issueId, HttpContext);\n    }\n\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a QuestParty Aggregate View - C#\nDESCRIPTION: This code defines a `QuestParty` record that represents an aggregated view of a group of heroes on a quest.  It includes methods to create and update the `QuestParty` based on `MembersJoined`, `MembersDeparted`, `MembersEscaped`, and `QuestStarted` events. It demonstrates how events are applied to update the aggregate's state.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/aggregate-projections.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed record QuestParty(Guid Id, List<string> Members)\n{\n    // These methods take in events and update the QuestParty\n    public static QuestParty Create(QuestStarted started) => new(started.QuestId, []);\n    public static QuestParty Apply(MembersJoined joined, QuestParty party) =>\n        party with\n        {\n            Members = party.Members.Union(joined.Members).ToList()\n        };\n\n    public static QuestParty Apply(MembersDeparted departed, QuestParty party) =>\n        party with\n        {\n            Members = party.Members.Where(x => !departed.Members.Contains(x)).ToList()\n        };\n\n    public static QuestParty Apply(MembersEscaped escaped, QuestParty party) =>\n        party with\n        {\n            Members = party.Members.Where(x => !escaped.Members.Contains(x)).ToList()\n        };\n}\n```\n\n----------------------------------------\n\nTITLE: Using ProjectEvent in Aggregate Projection C#\nDESCRIPTION: This C# code demonstrates using `ProjectEvent` within a `TripProjection` class to define how events modify the `Trip` aggregate. Each `ProjectEvent` call maps a specific event type (`Arrival`, `Travel`, `TripEnded`, `Breakdown`) to an inline lambda expression that updates the `Trip`'s state. The `ProjectEventAsync` shows asynchronous database interaction to enrich aggregate properties, requiring access to `IQuerySession`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/aggregate-projections.md#_snippet_7\n\nLANGUAGE: cs\nCODE:\n```\npublic class TripProjection: SingleStreamProjection<Trip>\n{\n    public TripProjection()\n    {\n        ProjectEvent<Arrival>((trip, e) => trip.State = e.State);\n        ProjectEvent<Travel>((trip, e) => trip.Traveled += e.TotalDistance());\n        ProjectEvent<TripEnded>((trip, e) =>\n        {\n            trip.Active = false;\n            trip.EndedOn = e.Day;\n        });\n\n        ProjectEventAsync<Breakdown>(async (session, trip, e) =>\n        {\n            var repairShop = await session.Query<RepairShop>()\n                .Where(x => x.State == trip.State)\n                .FirstOrDefaultAsync();\n\n            trip.RepairShopId = repairShop?.Id;\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: CashRegisterRepository: Event Aggregation and Storage - C#\nDESCRIPTION: This snippet demonstrates a `CashRegisterRepository` class that handles storing and retrieving `FinancialAccount` snapshots and applying events. The `Store` method stores the account and appends an event to the stream.  The `Get` method loads the latest snapshot of a `FinancialAccount` and then aggregates the remaining events to get the current state. It uses `AggregateStreamAsync` to efficiently rebuild the state.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/live-aggregates.md#_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic class CashRegisterRepository\n{\n    private readonly IDocumentSession session;\n\n    public CashRegisterRepository(IDocumentSession session)\n    {\n        this.session = session;\n    }\n\n    public Task Store(\n        FinancialAccount financialAccount,\n        object @event,\n        CancellationToken ct = default\n    )\n    {\n        if (@event is AccountingMonthOpened)\n        {\n            session.Store(financialAccount);\n        }\n\n        session.Events.Append(financialAccount.Id, @event);\n\n        return session.SaveChangesAsync(ct);\n    }\n\n    public async Task<FinancialAccount?> Get(\n        Guid cashRegisterId,\n        CancellationToken ct = default\n    )\n    {\n        var cashRegister =\n            await session.LoadAsync<FinancialAccount>(cashRegisterId, ct);\n\n        var fromVersion = cashRegister != null\n            ?\n            // incrementing version to not apply the same event twice\n            cashRegister.Version + 1\n            : 0;\n\n        return await session.Events.AggregateStreamAsync(\n            cashRegisterId,\n            state: cashRegister,\n            fromVersion: fromVersion,\n            token: ct\n        );\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Marten Documents Across All Tenants Using AnyTenant (C#)\nDESCRIPTION: This code demonstrates how to query Marten documents across all tenants using the AnyTenant() extension method.  It filters the Target documents to return any document where the `Flag` property is true, irrespective of which tenant the document belongs to.  The results are then ordered by Id and returned as an array of Ids.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/multi-tenancy.md#_snippet_7\n\nLANGUAGE: cs\nCODE:\n```\n// query data across all tenants\nvar actual = query.Query<Target>().Where(x => x.AnyTenant() && x.Flag)\n    .OrderBy(x => x.Id).Select(x => x.Id).ToArray();\n```\n\n----------------------------------------\n\nTITLE: Scoping Marten Session to a Specific Tenant (C#)\nDESCRIPTION: This code demonstrates how to scope a Marten session to a specific tenant and query data within that tenant. It creates a query session for the \"tenant1\" tenant and then queries for User documents. Because the session is scoped to \"tenant1\", the query will only return data associated with that tenant. It relies on DocumentStore.QuerySession(tenantId) to create the scoped session.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/multi-tenancy.md#_snippet_5\n\nLANGUAGE: cs\nCODE:\n```\n// When you query for data from the \"tenant1\" tenant,\n// you only get data for that tenant\nusing (var query = store.QuerySession(\"tenant1\"))\n{\n    query.Query<User>()\n        .Select(x => x.UserName)\n        .ToList()\n        .ShouldHaveTheSameElementsAs(\"Bill\", \"Lindsey\");\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Hotel Room Events and State in C#\nDESCRIPTION: This code defines events related to hotel room availability, including HotelRoomsDefined, RoomBooked, and GuestCheckedOut, along with the RoomsAvailability entity. The Apply methods update the room counts based on the events. This illustrates event sourcing for tracking room availability in a hotel. The RoomType enum defines the different types of rooms.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/live-aggregates.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic enum RoomType\n{\n    Single,\n    Double,\n    King\n}\n\npublic record HotelRoomsDefined(\n    Guid HotelId,\n    Dictionary<RoomType, int> RoomTypeCounts\n);\n\npublic record RoomBooked(\n    Guid HotelId,\n    RoomType RoomType\n);\n\npublic record GuestCheckedOut(\n    Guid HotelId,\n    Guid GuestId,\n    RoomType RoomType\n);\n\npublic class RoomsAvailability\n{\n    public Guid Id { get; private set; }\n\n    public int AvailableSingleRooms => roomTypeCounts[RoomType.Single];\n    public int AvailableDoubleRooms => roomTypeCounts[RoomType.Double];\n    public int AvailableKingRooms => roomTypeCounts[RoomType.King];\n\n    private Dictionary<RoomType, int> roomTypeCounts = new ();\n\n    public void Apply(HotelRoomsDefined @event)\n    {\n        Id = @event.HotelId;\n        roomTypeCounts = @event.RoomTypeCounts;\n    }\n\n    public void Apply(RoomBooked @event)\n    {\n        roomTypeCounts[@event.RoomType] -= 1;\n    }\n\n    public void Apply(GuestCheckedOut @event)\n    {\n        roomTypeCounts[@event.RoomType] += 1;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Application Project Dockerfile - Dockerfile\nDESCRIPTION: This Dockerfile configures the Docker image for the main application. It uses multi-stage builds to compile and publish the application efficiently. It copies the project files, restores dependencies, builds the application, generates code using `dotnet run -- codegen write`, publishes the application, and sets up a non-root user for security. It also defines the entry point to run the application DLL.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/devops/devops.md#_snippet_4\n\nLANGUAGE: Dockerfile\nCODE:\n```\nFROM mcr.microsoft.com/dotnet/sdk:8.0-alpine AS build\nWORKDIR /src\n\nCOPY [\"Application/Application.csproj\", \"Application/\"]\n\n# you might need more projects  depending on your set-up\n# COPY [\"Shared/Shared.csproj\", \"Shared/\"]\n\nCOPY . .\nWORKDIR \"/src/Application\"\n\nRUN dotnet run -- codegen write\nRUN dotnet publish \"Application.csproj\" -c Release -o /app/publish /p:UseAppHost=false\n\nFROM mcr.microsoft.com/dotnet/aspnet:8.0-alpine AS runtime\nENV DOTNET_RUNNING_IN_CONTAINER=1\nENV DOTNET_NOLOGO=1\nENV DOTNET_SKIP_FIRST_TIME_EXPERIENCE=1\nRUN addgroup -g 1001 -S nonroot && adduser -u 1001 -S nonroot -G nonroot\nRUN mkdir /app\nRUN chown nonroot:nonroot /app\nWORKDIR /app\nCOPY --chown=nonroot:nonroot --from=build /app/publish .\n\nFROM runtime\nEXPOSE 5000\nUSER nonroot\nENTRYPOINT [\"dotnet\", \"Application.dll\"]\n```\n\n----------------------------------------\n\nTITLE: Using Stream Aggregation (Marten, C#)\nDESCRIPTION: Demonstrates how to configure and use stream aggregation with Marten.  It shows how to configure Trip as an inline or asynchronous projection using DocumentStore.For().  Then it illustrates how to perform a live aggregation of the Trip stream using IQuerySession.Events.AggregateStreamAsync().\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/aggregate-projections.md#_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\ninternal async Task use_a_stream_aggregation()\n{\n    var store = DocumentStore.For(opts =>\n    {\n        opts.Connection(\"some connection string\");\n\n        // Run the Trip as an inline projection\n        opts.Projections.Snapshot<Trip>(SnapshotLifecycle.Inline);\n\n        // Or run it as an asynchronous projection\n        opts.Projections.Snapshot<Trip>(SnapshotLifecycle.Async);\n    });\n\n    // Or more likely, use it as a live aggregation:\n\n    // Just pretend you already have the id of an existing\n    // trip event stream id here...\n    var tripId = Guid.NewGuid();\n\n    // We'll open a read only query session...\n    await using var session = store.QuerySession();\n\n    // And do a live aggregation of the Trip stream\n    var trip = await session.Events.AggregateStreamAsync<Trip>(tripId);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Marten with Optimized Artifact Workflow (C#)\nDESCRIPTION: This snippet shows how to configure Marten with the `OptimizeArtifactWorkflow()` extension method within a .NET application's service configuration. This feature enhances the development workflow by automatically managing database schema creation/updates and dynamic code generation in development while disabling automatic schema changes in production.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/optimized_artifact_workflow.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .ConfigureServices(services =>\n    {\n        services.AddMarten(\"connection string\")\n\n            // This feature opts into the new\n            // \"Optimized artifact workflow\" for Marten >= V5\n            .OptimizeArtifactWorkflow();\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Handling ShipOrder Command and Emitting Archived Event\nDESCRIPTION: This snippet demonstrates a command handler for a `ShipOrder` command. It fetches the `Order` aggregate for writing using `FetchForWriting`. If the order hasn't already shipped, it appends an `OrderShipped` event and an `Archived` event to the event stream. Finally, it saves the changes to the document session, which will automatically mark the entire event stream as archived due to the presence of the `Archived` event and the inline projection.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/archiving.md#_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\npublic static async Task HandleAsync(ShipOrder command, IDocumentSession session)\n{\n    var stream = await session.Events.FetchForWriting<Order>(command.OrderId);\n    var order = stream.Aggregate;\n\n    if (!order.Shipped.HasValue)\n    {\n        // Mark it as shipped\n        stream.AppendOne(new OrderShipped());\n\n        // But also, the order is done, so let's mark it as archived too!\n        stream.AppendOne(new Archived(\"Shipped\"));\n\n        await session.SaveChangesAsync();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the IEvent Interface in C#\nDESCRIPTION: This code snippet defines the `IEvent` interface, which represents an event within Marten's event sourcing system. It includes properties for the event's ID, version, sequence, data, stream ID/Key, timestamp, tenant ID, event type, causation/correlation IDs, headers, archive status, and aggregate type name. This is a core interface for interacting with events in Marten.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/querying.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IEvent\n{\n    /// <summary>\n    ///     Unique identifier for the event. Uses a sequential Guid\n    /// </summary>\n    Guid Id { get; set; }\n\n    /// <summary>\n    ///     The version of the stream this event reflects. The place in the stream.\n    /// </summary>\n    long Version { get; set; }\n\n    /// <summary>\n    ///     The sequential order of this event in the entire event store\n    /// </summary>\n    long Sequence { get; set; }\n\n    /// <summary>\n    ///     The actual event data body\n    /// </summary>\n    object Data { get; }\n\n    /// <summary>\n    ///     If using Guid's for the stream identity, this will\n    ///     refer to the Stream's Id, otherwise it will always be Guid.Empty\n    /// </summary>\n    Guid StreamId { get; set; }\n\n    /// <summary>\n    ///     If using strings as the stream identifier, this will refer\n    ///     to the containing Stream's Id\n    /// </summary>\n    string? StreamKey { get; set; }\n\n    /// <summary>\n    ///     The UTC time that this event was originally captured\n    /// </summary>\n    DateTimeOffset Timestamp { get; set; }\n\n    /// <summary>\n    ///     If using multi-tenancy by tenant id\n    /// </summary>\n    string TenantId { get; set; }\n\n    /// <summary>\n    ///     The .Net type of the event body\n    /// </summary>\n    Type EventType { get; }\n\n    /// <summary>\n    ///     Marten's type alias string for the Event type\n    /// </summary>\n    string EventTypeName { get; set; }\n\n    /// <summary>\n    ///     Marten's string representation of the event type\n    ///     in assembly qualified name\n    /// </summary>\n    string DotNetTypeName { get; set; }\n\n    /// <summary>\n    ///     Optional metadata describing the causation id\n    /// </summary>\n    string? CausationId { get; set; }\n\n    /// <summary>\n    ///     Optional metadata describing the correlation id\n    /// </summary>\n    string? CorrelationId { get; set; }\n\n    /// <summary>\n    ///     Optional user defined metadata values. This may be null.\n    /// </summary>\n    Dictionary<string, object>? Headers { get; set; }\n\n    /// <summary>\n    ///     Has this event been archived and no longer applicable\n    ///     to projected views\n    /// </summary>\n    bool IsArchived { get; set; }\n\n    /// <summary>\n    ///     Marten's name for the aggregate type that will be persisted\n    ///     to the streams table. This will only be available when running\n    ///     within the Async Daemon\n    /// </summary>\n    public string? AggregateTypeName { get; set; }\n\n    /// <summary>\n    ///     Set an optional user defined metadata value by key\n    /// </summary>\n    /// <param name=\"key\"></param>\n    /// <param name=\"value\"></param>\n    void SetHeader(string key, object value);\n\n    /// <summary>\n    ///     Get an optional user defined metadata value by key\n    /// </summary>\n    /// <param name=\"key\"></param>\n    /// <returns></returns>\n    object? GetHeader(string key);\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Order Aggregate as Inline Projection\nDESCRIPTION: This snippet configures Marten to use an inline snapshot projection for the `Order` aggregate. It registers the `Order` aggregate for snapshotting with `SnapshotLifecycle.Inline`, meaning updates happen within the same transaction as the events being appended.  It also configures Marten to use an identity map for aggregates and disables the identity map tracking overall for performance optimization.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/archiving.md#_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\nbuilder.Services.AddMarten(opts =>\n{\n    opts.Connection(\"some connection string\");\n\n    // The Order aggregate is updated Inline inside the\n    // same transaction as the events being appended\n    opts.Projections.Snapshot<Order>(SnapshotLifecycle.Inline);\n\n    // Opt into an optimization for the inline aggregates\n    // used with FetchForWriting()\n    opts.Projections.UseIdentityMapForAggregates = true;\n})\n\n// This is also a performance optimization in Marten to disable the\n// identity map tracking overall in Marten sessions if you don't\n// need that tracking at runtime\n.UseLightweightSessions();\n```\n\n----------------------------------------\n\nTITLE: Configuring Marten in ASP.NET Core\nDESCRIPTION: This snippet demonstrates how to integrate Marten into an ASP.NET Core application using the `AddMarten` extension method. It configures the connection string, serialization settings, and auto-creation of schema objects during development.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/getting-started.md#_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n// This is the absolute, simplest way to integrate Marten into your\n// .NET application with Marten's default configuration\nbuilder.Services.AddMarten(options =>\n{\n    // Establish the connection string to your Marten database\n    options.Connection(builder.Configuration.GetConnectionString(\"Marten\")!);\n\n    // Specify that we want to use STJ as our serializer\n    options.UseSystemTextJsonForSerialization();\n\n    // If we're running in development mode, let Marten just take care\n    // of all necessary schema building and patching behind the scenes\n    if (builder.Environment.IsDevelopment())\n    {\n        options.AutoCreateSchemaObjects = AutoCreate.All;\n    }\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Marten with Multi-Host NpgsqlDataSource in C#\nDESCRIPTION: This code snippet shows how to configure Marten to use a multi-host NpgsqlDataSource. It adds the Npgsql data source and sets the read session preference to standby nodes, enabling queries to be spread across read replicas. It depends on the `ConnectionSource.ConnectionString` to define the connection string. This allows for read-heavy applications to potentially improve throughput.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/hostbuilder.md#_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nservices.AddMultiHostNpgsqlDataSource(ConnectionSource.ConnectionString);\n\nservices.AddMarten(x =>\n    {\n        // Will prefer standby nodes for querying.\n        x.Advanced.MultiHostSettings.ReadSessionPreference = TargetSessionAttributes.PreferStandby;\n    })\n    .UseLightweightSessions()\n    .UseNpgsqlDataSource();\n```\n\n----------------------------------------\n\nTITLE: Configuring AutoCreate Schema Objects - C#\nDESCRIPTION: This code snippet demonstrates how to configure the `AutoCreateSchemaObjects` setting in Marten. It showcases different modes for creating or updating database schema objects automatically during development, including options for creating missing objects, updating existing tables, and preventing any schema changes.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/schema/migrations.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(opts =>\n{\n    // Marten will create any new objects that are missing,\n    // attempt to update tables if it can, but drop and replace\n    // tables that it cannot patch.\n    opts.AutoCreateSchemaObjects = AutoCreate.All;\n\n    // Marten will create any new objects that are missing or\n    // attempt to update tables if it can. Will *never* drop\n    // any existing objects, so no data loss\n    opts.AutoCreateSchemaObjects = AutoCreate.CreateOrUpdate;\n\n    // Marten will create missing objects on demand, but\n    // will not change any existing schema objects\n    opts.AutoCreateSchemaObjects = AutoCreate.CreateOnly;\n\n    // Marten will not create or update any schema objects\n    // and throws an exception in the case of a schema object\n    // not reflecting the Marten configuration\n    opts.AutoCreateSchemaObjects = AutoCreate.None;\n});\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Aggregation Projection with IoC Dependency (C#)\nDESCRIPTION: This C# code defines a custom aggregation projection, `ProductProjection`, that depends on an `IPriceLookup` service. The `IPriceLookup` service is injected through the constructor, allowing the projection to retrieve price information for product categories during event application. The projection aggregates events of type `ProductRegistered` to create or update `Product` documents.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/ioc.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ProductProjection: CustomProjection<Product, Guid>\n{\n    private readonly IPriceLookup _lookup;\n\n    // The lookup service would be injected by IoC\n    public ProductProjection(IPriceLookup lookup)\n    {\n        _lookup = lookup;\n        AggregateByStream();\n        ProjectionName = \"Product\";\n    }\n\n    public override ValueTask ApplyChangesAsync(\n        DocumentSessionBase session,\n        EventSlice<Product, Guid> slice,\n        CancellationToken cancellation,\n        ProjectionLifecycle lifecycle = ProjectionLifecycle.Inline\n    )\n    {\n        slice.Aggregate ??= new Product { Id = slice.Id };\n\n        foreach (var data in slice.AllData())\n        {\n            if (data is ProductRegistered r)\n            {\n                slice.Aggregate.Price = _lookup.PriceFor(r.Category);\n                slice.Aggregate.Name = r.Name;\n                slice.Aggregate.Category = r.Category;\n            }\n        }\n\n        if (slice.Aggregate != null)\n        {\n            session.Store(slice.Aggregate);\n        }\n\n        return ValueTask.CompletedTask;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Chaining Patch Operations - C#\nDESCRIPTION: This code snippet demonstrates how to chain multiple patch operations together, in this case `Set` and `Increment`.  The operations are executed atomically within a single database transaction.  It uses `SaveChangesAsync()` to commit the changes.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/partial-updates-patching.md#_snippet_17\n\nLANGUAGE: cs\nCODE:\n```\n[Fact]\npublic async Task able_to_chain_patch_operations()\n{\n    var target = Target.Random(true);\n    target.Number = 5;\n\n    theSession.Store(target);\n    await theSession.SaveChangesAsync();\n\n    theSession.Patch<Target>(target.Id)\n        .Set(x => x.Number, 10)\n        .Increment(x => x.Number, 10);\n    await theSession.SaveChangesAsync();\n\n    using (var query = theStore.QuerySession())\n    {\n        query.Load<Target>(target.Id).Number.ShouldBe(20);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Quest Projection After Persisting Events\nDESCRIPTION: Demonstrates how to persist events to a stream and then immediately query the resulting `Quest` state using `session.LoadAsync<Quest>(questId)` and `session.Query<Quest>().Where(x => x.isFinished).ToListAsync()`.  This highlights how inline projections allow querying the projected state directly after event persistence.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/quickstart.md#_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nawait using var session = store.LightweightSession();\n\nvar started = new QuestStarted(questId, \"Destroy the One Ring\");\nvar joined1 = new MembersJoined(questId, 1, \"Hobbiton\", [\"Frodo\", \"Sam\"]);\n\nsession.Events.StartStream(questId, started, joined1);\nawait session.SaveChangesAsync();\n\n// we can now query the quest state like any other Marten document\nvar questState = await session.LoadAsync<Quest>(questId);\n\nvar finishedQuests = await session.Query<Quest>().Where(x => x.isFinished).ToListAsync();\n```\n\n----------------------------------------\n\nTITLE: Define Computed Unique Index (Single Property) via Store Options in Marten C#\nDESCRIPTION: This code snippet demonstrates how to define a computed unique index on a single property using the `StoreOptions` fluent interface in Marten. It configures the document store to enforce uniqueness on the `UserName` property of the `User` document type using a computed index. The code connects to a PostgreSQL database and specifies the database schema name.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/indexing/unique.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n    _.Connection(ConnectionSource.ConnectionString);\n    _.DatabaseSchemaName = \"unique_text\";\n\n    // This creates\n    _.Schema.For<User>().UniqueIndex(UniqueIndexType.Computed, x => x.UserName);\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing New Property in Marten\nDESCRIPTION: This snippet illustrates how to initialize a new property on existing documents using Marten's `Patch` API. It uses a `WhereFragment` to target documents where the `UpdatedAt` property is null and sets it to the current UTC time.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/partial-updates-patching.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nconst string where = \"(data ->> 'UpdatedAt') is null\";\ntheSession.Query<Target>(where).Count.ShouldBe(3);\ntheSession.Patch<Target>(new WhereFragment(where)).Set(\"UpdatedAt\", DateTime.UtcNow);\nawait theSession.SaveChangesAsync();\n\nusing (var query = theStore.QuerySession())\n{\n    query.Query<Target>(where).Count.ShouldBe(0);\n}\n```\n\n----------------------------------------\n\nTITLE: Define Computed Unique Index (Multiple Properties) via Store Options in Marten C#\nDESCRIPTION: This code snippet illustrates how to define a computed unique index on multiple properties using Marten's `StoreOptions`. It enforces uniqueness based on both `FirstName` and `FullName` properties of the `User` document type. The code initializes the document store with a connection string and database schema.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/indexing/unique.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n    _.Connection(ConnectionSource.ConnectionString);\n    _.DatabaseSchemaName = \"unique_text\";\n\n    // This creates\n    _.Schema.For<User>().UniqueIndex(UniqueIndexType.Computed, x => x.FirstName, x => x.FullName);\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing a Document Policy\nDESCRIPTION: This C# code snippet implements a custom document policy (`TenancyPolicy`) that sets the tenancy style of document types implementing `IRequireMultiTenancy` to `TenancyStyle.Conjoined`.  This shows an implementation of the `IDocumentPolicy` interface and its `Apply` method.  The policy checks for the `IRequireMultiTenancy` interface and sets the tenancy style accordingly.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/storeoptions.md#_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IRequireMultiTenancy\n{\n}\n\npublic class TenancyPolicy: IDocumentPolicy\n{\n    public void Apply(DocumentMapping mapping)\n    {\n        if (mapping.DocumentType.GetInterfaces().Any(x => x == typeof(IRequireMultiTenancy)))\n        {\n            mapping.TenancyStyle = TenancyStyle.Conjoined;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Customize Json.NET Serialization with Marten\nDESCRIPTION: This snippet demonstrates how to customize Marten's JsonNetSerializer to modify enum storage and other serialization settings. It shows how to configure `EnumStorage` and `DateTimeZoneHandling` options and then replace the default serializer in `DocumentStore` with the configured instance.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/json.md#_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nvar serializer = new Marten.Services.JsonNetSerializer();\n\n// To change the enum storage policy to store Enum's as strings:\nserializer.EnumStorage = EnumStorage.AsString;\n\n// All other customizations:\nserializer.Configure(_ =>\n{\n    // Code directly against a Newtonsoft.Json JsonSerializer\n    _.DateTimeZoneHandling = DateTimeZoneHandling.RoundtripKind;\n    _.ConstructorHandling = ConstructorHandling.AllowNonPublicDefaultConstructor;\n});\n\nvar store = DocumentStore.For(_ =>\n{\n    // Replace the default JsonNetSerializer with the one we configured\n    // above\n    _.Serializer(serializer);\n});\n```\n\n----------------------------------------\n\nTITLE: Querying with Any() and Contains() in Child Collections (C#)\nDESCRIPTION: Demonstrates querying within child collections using `Any()` and `Contains()` Linq quantifier operations in Marten. It shows how to search within arrays, Lists, and ILists of simple types, as well as how to use `Contains()` on subqueries within `Any()` searches with constant array of String or Guid expressions.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/child-collections.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ClassWithChildCollections\n{\n    public Guid Id;\n\n    public IList<User> Users = new List<User>();\n    public Company[] Companies = new Company[0];\n\n    public string[] Names;\n    public IList<string> NameList;\n    public List<string> NameList2;\n}\n\npublic void searching(IDocumentStore store)\n{\n    using (var session = store.QuerySession())\n    {\n        var searchNames = new string[] { \"Ben\", \"Luke\" };\n\n        session.Query<ClassWithChildCollections>()\n            // Where collections of deep objects\n            .Where(x => x.Companies.Any(_ => _.Name == \"Jeremy\"))\n\n            // Where for Contains() on array of simple types\n            .Where(x => x.Names.Contains(\"Corey\"))\n\n            // Where for Contains() on List<T> of simple types\n            .Where(x => x.NameList.Contains(\"Phillip\"))\n\n            // Where for Contains() on IList<T> of simple types\n            .Where(x => x.NameList2.Contains(\"Jens\"))\n\n            // Where for Any(element == value) on simple types\n            .Where(x => x.Names.Any(_ => _ == \"Phillip\"))\n\n            // The Contains() operator on subqueries within Any() searches\n            // only supports constant array of String or Guid expressions.\n            // Both the property being searched (Names) and the values\n            // being compared (searchNames) need to be arrays.\n            .Where(x => x.Names.Any(_ => searchNames.Contains(_)));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configure Document Hierarchy\nDESCRIPTION: Configures Marten to store `AdminUser` and `SuperUser` as subclasses of `User` within the same database table. It demonstrates adding subclasses to the base class configuration and shows how to query for either the base class or a specific subclass.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/hierarchies.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n    _.Connection(\"connection to your database\");\n\n    _.Schema.For<User>()\n        // generic version\n        .AddSubClass<AdminUser>()\n\n        // By document type object\n        .AddSubClass(typeof(SuperUser));\n});\n\nusing (var session = store.QuerySession())\n{\n    // query for all types of User and User itself\n    session.Query<User>().ToList();\n\n    // query for only SuperUser\n    session.Query<SuperUser>().ToList();\n}\n```\n\n----------------------------------------\n\nTITLE: Querying with IsOneOf and Strong Typed Identifier in C#\nDESCRIPTION: This snippet shows how to load multiple documents using `IsOneOf()` with a strong typed identifier. It creates three `Issue2` objects, stores them in the session, and then queries for them using their IDs. The query verifies that the correct number of documents is returned.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/identity.md#_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic async Task load_many()\n{\n    var issue1 = new Issue2{Name = Guid.NewGuid().ToString()};\n    var issue2 = new Issue2{Name = Guid.NewGuid().ToString()};\n    var issue3 = new Issue2{Name = Guid.NewGuid().ToString()};\ntheSession.Store(issue1, issue2, issue3);\n\n    await theSession.SaveChangesAsync();\n\n    var results = await theSession.Query<Issue2>()\n        .Where(x => x.Id.IsOneOf(issue1.Id, issue2.Id, issue3.Id))\n        .ToListAsync();\n\n    results.Count.ShouldBe(3);\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic async Task load_many()\n{\n    var issue1 = new Issue3{Name = Guid.NewGuid().ToString()};\n    var Issue3 = new Issue3{Name = Guid.NewGuid().ToString()};\n    var issue3 = new Issue3{Name = Guid.NewGuid().ToString()};\ntheSession.Store(issue1, Issue3, issue3);\n\n    await theSession.SaveChangesAsync();\n\n    var results = await theSession.Query<Issue3>()\n        .Where(x => x.Id.IsOneOf(issue1.Id, Issue3.Id, issue3.Id))\n        .ToListAsync();\n\n    results.Count.ShouldBe(3);\n}\n```\n\n----------------------------------------\n\nTITLE: Applying a Transformation as a Projection in C#\nDESCRIPTION: This code snippet shows how to register a new transformation type (`MonsterDefeatedTransform`) as a projection when configuring the document store in Marten. This allows Marten to automatically apply the transformation whenever a `MonsterSlayed` event is appended.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/events/projections/index.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n// SAMPLE: applying-monster-defeated\nusing var host = Host.CreateDefaultBuilder()\n    .ConfigureServices(services =>\n    {\n        services.AddMarten(opts =>\n        {\n            // This applies the transform to any new events\n            // as they are committed to the event store\n            opts.Projections.Add<MonsterDefeatedTransform>();\n        });\n    }).Build();\n// ENDSAMPLE\n```\n\n----------------------------------------\n\nTITLE: Using Numeric Revisioning - Marten C#\nDESCRIPTION: This code snippet illustrates how to use numeric revisioning with Marten's `IDocumentSession` interface. It demonstrates inserting a new document, storing (upserting) a document, updating a document's revision using `UpdateRevision` to enforce optimistic concurrency, and using `TryUpdateRevision` to conditionally update the revision. The session operations are executed when `SaveChangesAsync()` is called.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/concurrency.md#_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic static async Task try_revisioning(IDocumentSession session, Reservation reservation)\n{\n    // This will create a new document with Version = 1\n    session.Insert(reservation);\n\n    // \"Store\" is an upsert, but if the revisioned document\n    // is all new, the Version = 1 after changes are committed\n    session.Store(reservation);\n\n    // If Store() is called on an existing document\n    // this will just assign the next revision\n    session.Store(reservation);\n\n    // *This* operation will enforce the optimistic concurrency\n    // The supplied revision number should be the *new* revision number,\n    // but will be rejected with a ConcurrencyException when SaveChanges() is\n    // called if the version\n    // in the database is equal or greater than the supplied revision\n    session.UpdateRevision(reservation, 3);\n\n    // This operation will update the document if the supplied revision\n    // number is greater than the known database version when\n    // SaveChanges() is called, but will do nothing if the known database\n    // version is equal to or greater than the supplied revision\n    session.TryUpdateRevision(reservation, 3);\n\n    // Any checks happen only here\n    await session.SaveChangesAsync();\n}\n```\n\n----------------------------------------\n\nTITLE: Multiple Full Text Indexes on Properties - Marten C#\nDESCRIPTION: Defines full text indexes on multiple properties (`Heading` and `Text`) of the `Article` class, each using the default 'english' configuration. Each property gets its own index. Requires the Marten library.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/full-text.md#_snippet_9\n\nLANGUAGE: cs\nCODE:\n```\npublic class Article\n{\n    public Guid Id { get; set; }\n\n    [FullTextIndex] public string Heading { get; set; }\n\n    [FullTextIndex] public string Text { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Invoice Aggregate (C#)\nDESCRIPTION: This class represents the Invoice aggregate, inheriting from `AggregateBase`. It demonstrates how to apply events to mutate the state of the aggregate. The constructor creates an `InvoiceCreated` event and adds it to the uncommitted events. The `AddLine` method creates a `LineItemAdded` event and adds it to the uncommitted events. The `Apply` methods handle the application of each event, mutating the state accordingly. It also defines `Total` property and overrides the `ToString()` method.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/scenarios/aggregates-events-repositories.md#_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\npublic sealed class Invoice: AggregateBase\n{\n    public Invoice(int invoiceNumber)\n    {\n        if (invoiceNumber <= 0)\n        {\n            throw new ArgumentException(\"Invoice number needs to be positive\", nameof(invoiceNumber));\n        }\n\n        // Instantiation creates our initial event, capturing the invoice number\n        var @event = new InvoiceCreated(invoiceNumber);\n\n        // Call Apply to mutate state of aggregate based on event\n        Apply(@event);\n\n        // Add the event to uncommitted events to use it while persisting the events to Marten events store\n        AddUncommittedEvent(@event);\n    }\n\n    private Invoice()\n    {\n    }\n\n    // Enforce any contracts on input, then raise event capturing the data\n    public void AddLine(decimal price, decimal vat, string description)\n    {\n        if (string.IsNullOrEmpty(description))\n        {\n            throw new ArgumentException(\"Description cannot be empty\", nameof(description));\n        }\n\n        var @event = new LineItemAdded(price, vat, description);\n\n        // Call Apply to mutate state of aggregate based on event\n        Apply(@event);\n\n        // Add the event to uncommitted events to use it while persisting the events to Marten events store\n        AddUncommittedEvent(@event);\n    }\n\n    public override string ToString()\n    {\n        var lineItems = string.Join(Environment.NewLine, lines.Select(x => $\"{x.Item1}: {x.Item2} ({x.Item3}% VAT)\"));\n        return $\"{lineItems}{Environment.NewLine}Total: {Total}\";\n    }\n\n    public decimal Total { get; private set; }\n\n    private readonly List<Tuple<string, decimal, decimal>> lines = new List<Tuple<string, decimal, decimal>>();\n\n    // Apply the deltas to mutate our state\n    private void Apply(InvoiceCreated @event)\n    {\n        Id = @event.InvoiceNumber.ToString(CultureInfo.InvariantCulture);\n\n        // Ensure to update version on every Apply method.\n        Version++;\n    }\n\n    // Apply the deltas to mutate our state\n    private void Apply(LineItemAdded @event)\n    {\n        var price = @event.Price * (1 + @event.Vat / 100);\n        Total += price;\n        lines.Add(Tuple.Create(@event.Description, price, @event.Vat));\n\n        // Ensure to update version on every Apply method.\n        Version++;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Kafka Subscription in C#\nDESCRIPTION: This code snippet implements a more complex `KafkaSubscription` that publishes events to a configured Kafka topic. It inherits from `SubscriptionBase` and requires a `KafkaProducerConfig` injected through its constructor. It demonstrates filtering event types, configuring batch size, and publishing events to Kafka using the `kafkaProducer.ProduceAsync` method. This implementation uses `JsonConvert.SerializeObject` to serialize events to JSON for publishing.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/subscriptions.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic class KafkaSubscription: SubscriptionBase\n{\n    private readonly KafkaProducerConfig _config;\n\n    public KafkaSubscription(KafkaProducerConfig config)\n    {\n        _config = config;\n\n        SubscriptionName = \"Kafka\";\n\n        // Access to any or all filtering rules\n        IncludeType<InvoiceApproved>();\n\n        // Fine grained control over how the subscription runs\n        // in the async daemon\n        Options.BatchSize = 1000;\n        Options.MaximumHopperSize = 10000;\n\n        // Effectively run as a hot observable\n        Options.SubscribeFromPresent();\n    }\n\n    // The daemon will \"push\" a page of events at a time to this subscription\n    public override async Task<IChangeListener> ProcessEventsAsync(\n        EventRange page,\n        ISubscriptionController controller,\n        IDocumentOperations operations,\n        CancellationToken cancellationToken)\n    {\n        using var kafkaProducer =\n            new ProducerBuilder<string, string>(_config.ProducerConfig).Build();\n\n        foreach (var @event in page.Events)\n        {\n            await kafkaProducer.ProduceAsync(_config.Topic,\n                new Message<string, string>\n                {\n                    // store event type name in message Key\n                    Key = @event.Data.GetType().Name,\n                    // serialize event to message Value\n                    Value = JsonConvert.SerializeObject(@event.Data)\n                }, cancellationToken);\n\n        }\n\n        // We don't need any kind of callback, so the nullo is fine\n        return NullChangeListener.Instance;\n    }\n\n}\n\n// Just assume this is registered in your IoC container\npublic class KafkaProducerConfig\n{\n    public ProducerConfig? ProducerConfig { get; set; }\n    public string? Topic { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Writing Database Migration File - C#\nDESCRIPTION: This snippet shows how to programmatically write a database migration file using Marten.  The `WriteMigrationFileAsync` method generates a SQL script that updates the database schema to match the current Marten configuration.  This requires an `IDocumentStore` instance connected to the target database.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/schema/migrations.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n// All migration code is async now!\nawait store.Storage.Database.WriteMigrationFileAsync(\"1.initial.sql\");\n```\n\n----------------------------------------\n\nTITLE: Remove Complex Element from Collection in Marten (C#)\nDESCRIPTION: Demonstrates removing a complex element from a child collection using `Patch.Remove()`. The example generates a target object with a `Children` array, selects a random child, and then removes it. The assertion checks that the child is removed. Dependencies: Marten, Xunit, Shouldly.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/partial-updates-patching.md#_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic async Task remove_complex_element()\n{\n    var target = Target.Random(true);\n    var initialCount = target.Children.Length;\n\n    var random = new Random();\n    var child = target.Children[random.Next(0, initialCount)];\n\n    theSession.Store(target);\n    await theSession.SaveChangesAsync();\n\n    theSession.Patch<Target>(target.Id).Remove(x => x.Children, child);\n    await theSession.SaveChangesAsync();\n\n    using (var query = theStore.QuerySession())\n    {\n        var target2 = query.Load<Target>(target.Id);\n        target2.Children.Length.ShouldBe(initialCount - 1);\n\n        target2.Children.ShouldNotContain(t => t.Id == child.Id);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Storing Mixed Document Types with Store() in Marten\nDESCRIPTION: This snippet demonstrates how to store multiple documents of different types using `IDocumentSession.Store<object>()` or `IDocumentSession.StoreObjects()` in Marten. It handles storing instances of `User`, `Issue`, and `Company` classes in a single session. It requires a configured `DocumentStore` and the aforementioned classes.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/storing.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nusing var store = DocumentStore.For(\"some connection string\");\nvar user1 = new User();\nvar user2 = new User();\nvar issue1 = new Issue();\nvar issue2 = new Issue();\nvar company1 = new Company();\nvar company2 = new Company();\n\nawait using var session = store.LightweightSession();\n\nsession.Store<object>(user1, user2, issue1, issue2, company1, company2);\nawait session.SaveChangesAsync();\n\n// Or this usage:\nvar documents = new object[] {user1, user2, issue1, issue2, company1, company2};\n\n// The argument here is any kind of IEnumerable<object>\nsession.StoreObjects(documents);\nawait session.SaveChangesAsync();\n```\n\n----------------------------------------\n\nTITLE: Include Multiple Document Types with Marten in C#\nDESCRIPTION: This code snippet illustrates how to include multiple related document types when querying with Marten. It fetches an `Issue` along with its assigned `User` (assignee) and reporting `User` (reporter). Multiple `Include()` calls are chained together, each specifying a different related document type and the corresponding join condition.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/include.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic async Task multiple_includes()\n{\n    var assignee = new User{FirstName = \"Assignee\"};\n    var reporter = new User{FirstName = \"Reporter\"};\n\n    var issue1 = new Issue { AssigneeId = assignee.Id, ReporterId = reporter.Id, Title = \"Garage Door is busted\" };\n\n    using var session = theStore.IdentitySession();\n    session.Store(assignee, reporter);\n    session.Store(issue1);\n    await session.SaveChangesAsync();\n\n    using var query = theStore.QuerySession();\n    User assignee2 = null;\n    User reporter2 = null;\n\n    query.Logger = new TestOutputMartenLogger(_output);\n    query\n        .Query<Issue>()\n        .Include<User>(x => assignee2 = x).On(x => x.AssigneeId)\n        .Include<User>(x => reporter2 = x).On(x => x.ReporterId)\n        .Single()\n        .ShouldNotBeNull();\n\n    assignee2.Id.ShouldBe(assignee.Id);\n    reporter2.Id.ShouldBe(reporter.Id);\n}\n```\n\n----------------------------------------\n\nTITLE: Using Sticky Connection Lifetimes in Marten (C#)\nDESCRIPTION: Shows how to configure Marten to use \"sticky\" connection handling, reverting to the V6 and earlier behavior. This involves setting the UseStickyConnectionLifetimes property to true within the DocumentStore configuration. With this setting, Marten uses a single connection per session, which remains open until the session is disposed. Requires Npgsql connection string.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/sessions.md#_snippet_8\n\nLANGUAGE: cs\nCODE:\n```\nusing var store = DocumentStore.For(opts =>\n{\n    opts.Connection(\"some connection string\");\n\n    // Opt into V6 and earlier \"sticky\" connection\n    // handling\n    opts.UseStickyConnectionLifetimes = true;\n});\n```\n\n----------------------------------------\n\nTITLE: Incrementing with Explicit Increment in Marten\nDESCRIPTION: This snippet shows how to increment an integer value by a specific amount using the `Patch` and `Increment` methods with an explicit increment value. It retrieves a `Target` document, increments its `Number` by 3, and verifies the change.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/partial-updates-patching.md#_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic async Task increment_for_int_with_explicit_increment()\n{\n    var target = Target.Random();\n    target.Number = 6;\n\n    theSession.Store(target);\n    await theSession.SaveChangesAsync();\n\n    theSession.Patch<Target>(target.Id).Increment(x => x.Number, 3);\n    await theSession.SaveChangesAsync();\n\n    using (var query = theStore.QuerySession())\n    {\n        query.Load<Target>(target.Id).Number.ShouldBe(9);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Passing Existing Connections/Transactions\nDESCRIPTION: This code snippet demonstrates how to pass existing database connections and transactions into a Marten IDocumentSession. This allows you to control the transaction boundaries externally, overriding the default behavior of SaveChanges/SaveChangesAsync. The session will use the provided connection/transaction instead of creating its own.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/advanced/existing_transactions.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:passing-in-existing-connections-and-transactions]>\n```\n\n----------------------------------------\n\nTITLE: Example of Querying for Event Data in Marten (C#)\nDESCRIPTION: Illustrates how to query the raw event data with Marten's full Linq support.  This allows querying by any property of the `IEvent` interface.  It is recommended to use event projection views over querying within the raw event table for routine application support.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/events/streams.md#_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:example_of_querying_for_event_data]>\n```\n\n----------------------------------------\n\nTITLE: Versioned Reservation IRevisioned - Marten C#\nDESCRIPTION: This code snippet demonstrates how to implement the `IRevisioned` interface in a document class to enable numeric revisioning. The `Reservation` class implements `IRevisioned` and includes an integer `Version` property, indicating that Marten should use numeric revisioning for this document type and automatically track the version number in the `Version` property.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/concurrency.md#_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\n// By implementing the IRevisioned\n// interface, we're telling Marten to\n// use numeric revisioning with this\n// document type and keep the version number\n// on the Version property\npublic class Reservation: IRevisioned\n{\n    public Guid Id { get; set; }\n\n    // other properties\n\n    public int Version { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Bulk Insert with Ignore Duplicates (C#)\nDESCRIPTION: Shows how to use bulk insert while ignoring duplicate IDs. It inserts new documents and discards changes to existing documents. Marten creates a temporary table, inserts the new values, and then filters out matching IDs when copying to the real table.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/basics/bulk_insert.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:bulk_insert_with_IgnoreDuplicates]>\n```\n\n----------------------------------------\n\nTITLE: TripProjection Aggregate Creation and Application C#\nDESCRIPTION: This C# code shows a `TripProjection` class that extends `SingleStreamProjection<Trip>`.  It configures deletion events based on criteria. It defines `Apply` methods to modify the `Trip` aggregate based on `Arrival`, `Travel`, and `TripEnded` events. Critically, it includes a `Create` method that handles initial aggregate creation from a `TripStarted` event, returning a new `Trip` instance with initial state. These methods can be public, internal, or private.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/aggregate-projections.md#_snippet_6\n\nLANGUAGE: cs\nCODE:\n```\npublic class TripProjection: SingleStreamProjection<Trip>\n{\n    public TripProjection()\n    {\n        DeleteEvent<TripAborted>();\n\n        DeleteEvent<Breakdown>(x => x.IsCritical);\n\n        DeleteEvent<VacationOver>((trip, _) => trip.Traveled > 1000);\n    }\n\n    // These methods can be either public, internal, or private but there's\n    // a small performance gain to making them public\n    public void Apply(Arrival e, Trip trip) => trip.State = e.State;\n    public void Apply(Travel e, Trip trip) => trip.Traveled += e.TotalDistance();\n\n    public void Apply(TripEnded e, Trip trip)\n    {\n        trip.Active = false;\n        trip.EndedOn = e.Day;\n    }\n\n    public Trip Create(TripStarted started)\n    {\n        return new Trip { StartedOn = started.Day, Active = true };\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Include in Batched Query - C#\nDESCRIPTION: This code snippet demonstrates the use of `Include` within a batched query. It efficiently retrieves both `Issue` documents and the related `User` documents (Assignee) in a single database round trip via the batched query functionality.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/include.md#_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvar assignee = default(User);\n\nvar batch = session.CreateBatchQuery();\nvar issues = batch.Query<Issue>().Include(x => x.AssigneeId, x => assignee = x).Where(x => x.Title.Contains(\"foo\")).ToList();\nawait batch.Execute();\n```\n\n----------------------------------------\n\nTITLE: Defining Invoice Aggregate and Events (C#)\nDESCRIPTION: Defines the `Invoice` aggregate class along with associated event records (`InvoiceCreated`, `InvoiceApproved`, `InvoiceCancelled`, `InvoicePaid`, `InvoiceRejected`). It demonstrates how events are applied to update the aggregate state, including handling event metadata (timestamp).\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/read-aggregates.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic record InvoiceCreated(string Description, decimal Amount);\n\npublic record InvoiceApproved;\npublic record InvoiceCancelled;\npublic record InvoicePaid;\npublic record InvoiceRejected;\n\npublic class Invoice\n{\n    public Invoice()\n    {\n    }\n\n    public static Invoice Create(IEvent<InvoiceCreated> created)\n    {\n        return new Invoice\n        {\n            Amount = created.Data.Amount,\n            Description = created.Data.Description,\n\n            // Capture the timestamp from the event\n            // metadata captured by Marten\n            Created = created.Timestamp,\n            Status = InvoiceStatus.Created\n        };\n    }\n\n    public int Version { get; set; }\n\n    public decimal Amount { get; set; }\n    public string Description { get; set; }\n    public Guid Id { get; set; }\n    public DateTimeOffset Created { get; set; }\n    public InvoiceStatus Status { get; set; }\n\n    public void Apply(InvoiceCancelled _) => Status = InvoiceStatus.Cancelled;\n    public void Apply(InvoiceRejected _) => Status = InvoiceStatus.Rejected;\n    public void Apply(InvoicePaid _) => Status = InvoiceStatus.Paid;\n    public void Apply(InvoiceApproved _) => Status = InvoiceStatus.Approved;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing IMethodCallParser for Custom Linq Parsing in C#\nDESCRIPTION: This C# code snippet demonstrates the implementation of the `IMethodCallParser` interface for custom Linq parsing. It includes methods for matching method call expressions and parsing them into Postgresql \"where\" clauses, using the example of parsing a custom `IsBlue()` method call on a `ColorTarget` object.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/extending.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic class IsBlue: IMethodCallParser\n{\n    private static readonly PropertyInfo _property = ReflectionHelper.GetProperty<ColorTarget>(x => x.Color);\n\n    public bool Matches(MethodCallExpression expression)\n    {\n        return expression.Method.Name == nameof(CustomExtensions.IsBlue);\n    }\n\n    public ISqlFragment Parse(IQueryableMemberCollection memberCollection, IReadOnlyStoreOptions options,\n        MethodCallExpression expression)\n    {\n        var locator = memberCollection.MemberFor(expression).TypedLocator;\n\n        return new WhereFragment($\"{locator} = 'Blue'\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Partitioning with Policies in Marten\nDESCRIPTION: This snippet demonstrates how to configure table partitioning based on tenant id for all document types using `storeOptions.Policies.AllDocumentsAreMultiTenantedWithPartitioning`. It shows examples of using LIST, HASH, and RANGE partitioning, as well as externally managed partitions. This is used to improve performance with conjoined multi-tenancy.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/multi-tenancy.md#_snippet_8\n\nLANGUAGE: cs\nCODE:\n```\nstoreOptions.Policies.AllDocumentsAreMultiTenantedWithPartitioning(x =>\n{\n    // Selectively by LIST partitioning\n    x.ByList()\n        // Adding explicit table partitions for specific tenant ids\n        .AddPartition(\"t1\", \"T1\")\n        .AddPartition(\"t2\", \"T2\");\n\n    // OR Use LIST partitioning, but allow the partition tables to be\n    // controlled outside of Marten by something like pg_partman\n    // https://github.com/pgpartman/pg_partman\n    x.ByExternallyManagedListPartitions();\n\n    // OR Just spread out the tenant data by tenant id through\n    // HASH partitioning\n    // This is using three different partitions with the supplied\n    // suffix names\n    x.ByHash(\"one\", \"two\", \"three\");\n\n    // OR Partition by tenant id based on ranges of tenant id values\n    x.ByRange()\n        .AddRange(\"north_america\", \"na\", \"nazzzzzzzzzz\")\n        .AddRange(\"asia\", \"a\", \"azzzzzzzz\");\n\n    // OR use RANGE partitioning with the actual partitions managed\n    // externally\n    x.ByExternallyManagedRangePartitions();\n});\n```\n\n----------------------------------------\n\nTITLE: Handling exclusive concurrency with FetchForExclusiveWriting in Marten\nDESCRIPTION: This snippet shows how to implement exclusive concurrency using `FetchForExclusiveWriting` in Marten. It retrieves an `Order` aggregate using an exclusive lock, processes a `MarkItemReady` command, appends events based on the command, and saves changes. If a lock cannot be obtained in a timely manner, a `StreamLockedException` is thrown. Requires Marten and PostgreSQL with row-level locking support.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/scenarios/command_handler_workflow.md#_snippet_5\n\nLANGUAGE: cs\nCODE:\n```\npublic async Task Handle3(MarkItemReady command, IDocumentSession session)\n{\n    // Fetch the current value of the Order aggregate\n    var stream = await session\n        .Events\n\n        // Explicitly tell Marten the exptected, starting version of the\n        // event stream\n        .FetchForExclusiveWriting<Order>(command.OrderId);\n\n    var order = stream.Aggregate;\n\n    if (order.Items.TryGetValue(command.ItemName, out var item))\n    {\n        // Mark that the this item is ready\n        stream.AppendOne(new ItemReady(command.ItemName));\n    }\n    else\n    {\n        // Some crude validation\n        throw new InvalidOperationException($\"Item {command.ItemName} does not exist in this order\");\n    }\n\n    // If the order is ready to ship, also emit an OrderReady event\n    if (order.IsReadyToShip())\n    {\n        stream.AppendOne(new OrderReady());\n    }\n\n    await session.SaveChangesAsync();\n}\n```\n\n----------------------------------------\n\nTITLE: Configure DDL Template By Fluent Interface - C#\nDESCRIPTION: This code snippet shows how to configure the DDL template on a document by document type basis using the fluent interface configuration. This allows you to overwrite the default template for specific document types.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/schema/authorization.md#_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:configure_ddl_template_by_fi]>\n```\n\n----------------------------------------\n\nTITLE: Using Bulk Insert in Marten (C#)\nDESCRIPTION: Demonstrates the basic usage of the `IDocumentStore.BulkInsert()` method to insert a collection of documents efficiently. This method leverages Postgresql's COPY functionality for speed. The operation is performed within a single transaction.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/basics/bulk_insert.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:using_bulk_insert]>\n```\n\n----------------------------------------\n\nTITLE: Registering Marten Projection with IoC Services (C#)\nDESCRIPTION: This C# code demonstrates how to register a Marten projection, `ProductProjection`, with its IoC dependencies using the `AddProjectionWithServices<T>()` extension method. It configures the IoC container with a singleton `IPriceLookup` implementation and registers the `ProductProjection` as an inline projection with a singleton service lifetime.  The configuration uses `Host.CreateDefaultBuilder()` to create a minimal host for service configuration.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/ioc.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .ConfigureServices(services =>\n    {\n        services.AddSingleton<IPriceLookup, PriceLookup>();\n\n        services.AddMarten(opts =>\n            {\n                opts.Connection(ConnectionSource.ConnectionString);\n                opts.DatabaseSchemaName = \"ioc\";\n                opts.ApplyChangesLockId = opts.ApplyChangesLockId + 2;\n            })\n            // Note that this is chained after the call to AddMarten()\n            .AddProjectionWithServices<ProductProjection>(\n                ProjectionLifecycle.Inline,\n                ServiceLifetime.Singleton\n            );\n    })\n    .StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Defining a Live Stream Aggregation (QuestParty)\nDESCRIPTION: Defines a `QuestParty` record and associated static methods for `Create` and `Apply` that handle events like `MembersJoined`, `MembersDeparted`, and `MembersEscaped` to update the state of the `QuestParty`. This represents a live stream aggregation that dynamically updates based on incoming events.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/quickstart.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed record QuestParty(Guid Id, List<string> Members)\n{\n    // These methods take in events and update the QuestParty\n    public static QuestParty Create(QuestStarted started) => new(started.QuestId, []);\n    public static QuestParty Apply(MembersJoined joined, QuestParty party) =>\n        party with\n        {\n            Members = party.Members.Union(joined.Members).ToList()\n        };\n\n    public static QuestParty Apply(MembersDeparted departed, QuestParty party) =>\n        party with\n        {\n            Members = party.Members.Where(x => !departed.Members.Contains(x)).ToList()\n        };\n\n    public static QuestParty Apply(MembersEscaped escaped, QuestParty party) =>\n        party with\n        {\n            Members = party.Members.Where(x => !escaped.Members.Contains(x)).ToList()\n        };\n}\n```\n\n----------------------------------------\n\nTITLE: Writing Custom Session Listener - C#\nDESCRIPTION: This code shows how to create a custom `IDocumentSessionListener` to intercept and react to persistence events within a Marten session. It demonstrates how to access pending changes before a commit and the changeset after a commit to inspect inserted, updated, and deleted documents. It inherits from `DocumentSessionListenerBase` which provides empty implementations of the interface methods.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/diagnostics.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\n// DocumentSessionListenerBase is a helper abstract class in Marten\n// with empty implementations of each method you may find helpful\npublic class SimpleSessionListener: DocumentSessionListenerBase\n{\n    public override void BeforeSaveChanges(IDocumentSession session)\n    {\n        // Use pending changes to preview what is about to be\n        // persisted\n        var pending = session.PendingChanges;\n\n        // Careful here, Marten can only sort documents into \"inserts\" or \"updates\" based\n        // on whether or not Marten had to assign a new Id to that document upon DocumentStore()\n        pending.InsertsFor<User>()\n            .Each(user => Debug.WriteLine($\"New user: {user.UserName}\"));\n\n        pending.UpdatesFor<User>()\n            .Each(user => Debug.WriteLine($\"Updated user {user.UserName}\"));\n\n        pending.DeletionsFor<User>()\n            .Each(d => Debug.WriteLine(d));\n\n        // This is a convenience method to find all the pending events\n        // organized into streams that will be appended to the event store\n        pending.Streams()\n            .Each(s => Debug.WriteLine(s));\n    }\n\n    public override void AfterCommit(IDocumentSession session, IChangeSet commit)\n    {\n        // See what was just persisted, and possibly carry out post\n        // commit actions\n\n        var last = commit;\n\n        last.Updated.Each(x => Debug.WriteLine($\"{x} was updated\"));\n        last.Deleted.Each(x => Debug.WriteLine($\"{x} was deleted\"));\n        last.Inserted.Each(x => Debug.WriteLine($\"{x} was inserted\"));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: ConfigureMarten Method (Generic) - C#\nDESCRIPTION: Demonstrates how a document type can customize its storage by defining a `public static ConfigureMarten()` method. This method is invoked by Marten to allow the document type to directly configure its `DocumentMapping`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/index.md#_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic class MyDocument\n{\n    public Guid Id { get; set; }\n\n    public static void ConfigureMarten(DocumentMapping mapping)\n    {\n        mapping.Metadata.IsSoftDeleted = true;\n        mapping.UseOptimisticConcurrency(true);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Opening a Read Only Query Session\nDESCRIPTION: This snippet shows how to open a read-only IQuerySession from an IDocumentStore to query for Issue documents with specific tags using Linq and ToListAsync. It uses DocumentStore.For to configure the store with a connection string.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/sessions.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\nusing var store = DocumentStore.For(opts =>\n{\n    opts.Connection(\"some connection string\");\n});\n\nawait using var session = store.QuerySession();\n\nvar badIssues = await session.Query<Issue>()\n    .Where(x => x.Tags.Contains(\"bad\"))\n    .ToListAsync();\n```\n\n----------------------------------------\n\nTITLE: Dynamically Applying Changes to a Single Tenant Database (C#)\nDESCRIPTION: This code snippet demonstrates how to dynamically apply all configured changes to a single tenant database in Marten. It retrieves a tenant using `GetTenantAsync` and then calls `ApplyAllConfiguredChangesToDatabaseAsync` on the tenant's database. This is useful when you don't know the tenant upfront or want to apply changes outside of the application startup process. Requires a reference to the Marten `IStore` instance.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/multitenancy.md#_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nvar tenant = await theStore.Tenancy.GetTenantAsync(tenantId);\nawait tenant.Database.ApplyAllConfiguredChangesToDatabaseAsync();\n```\n\n----------------------------------------\n\nTITLE: Apply All Configured Schema Changes to Database with Marten (C#)\nDESCRIPTION: Demonstrates how to programmatically apply all detectable schema changes upfront when an application is first bootstrapped. This ensures that the database schema is up to date with the Marten configuration upon startup.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/schema/migrations.md#_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n[sample:ApplyAllConfiguredChangesToDatabase]\n```\n\n----------------------------------------\n\nTITLE: Cleaning Marten Documents using IDocumentCleaner\nDESCRIPTION: Demonstrates various methods of the IDocumentCleaner service for removing persisted document state and tearing down document storage.  The examples include completely removing schema objects, deleting all documents and event data, and deleting documents by type or excluding specific types. Requires an IDocumentStore instance.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/schema/cleaning.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic async Task clean_out_documents(IDocumentStore store)\n{\n    // Completely remove all the database schema objects related\n    // to the User document type\n    await store.Advanced.Clean.CompletelyRemoveAsync(typeof(User));\n\n    // Tear down and remove all Marten related database schema objects\n    await store.Advanced.Clean.CompletelyRemoveAllAsync();\n\n    // Deletes all the documents stored in a Marten database\n    await store.Advanced.Clean.DeleteAllDocumentsAsync();\n\n    // Deletes all the event data stored in a Marten database\n    await store.Advanced.Clean.DeleteAllEventDataAsync();\n\n    // Deletes all of the persisted User documents\n    await store.Advanced.Clean.DeleteDocumentsByTypeAsync(typeof(User));\n\n    // For cases where you may want to keep some document types,\n    // but eliminate everything else. This is here specifically to support\n    // automated testing scenarios where you have some static data that can\n    // be safely reused across tests\n    await store.Advanced.Clean.DeleteDocumentsExceptAsync(typeof(Company), typeof(User));\n}\n```\n\n----------------------------------------\n\nTITLE: Error Handling in Marten Subscriptions (C#)\nDESCRIPTION: This snippet demonstrates error handling within a Marten subscription by using `ISubscriptionController` to report critical failures or record dead letter events. It catches exceptions during event processing and either stops the subscription with `ReportCriticalFailureAsync` or skips the event with `RecordDeadLetterEventAsync`, depending on the type of exception.  The `Callback` class implements `IChangeListener` to be notified before and after document session commits.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/subscriptions.md#_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ErrorHandlingSubscription: SubscriptionBase\n{\n    public override async Task<IChangeListener> ProcessEventsAsync(\n        // The current \"page\" of events in strict sequential order\n        // If using conjoined tenancy, this will be a mix of tenants!\n        EventRange page,\n        ISubscriptionController controller,\n\n        // This gives you access to make \"writes\" to the\n        // underlying Marten store\n        IDocumentOperations operations,\n        CancellationToken cancellationToken)\n    {\n\n        long lastProcessed = page.SequenceFloor;\n\n        // Do any processing of events you want here\n        foreach (var e in page.Events)\n        {\n            Console.WriteLine($\"Got event of type {e.Data.GetType().NameInCode()} from stream {e.StreamId}\");\n\n            try\n            {\n                await handleEvent(e);\n                lastProcessed = e.Sequence;\n            }\n            catch (ReallyBadException ex)\n            {\n                // We've detected some kind of critical exception that makes us\n                // want to stop all further processing\n                await controller.ReportCriticalFailureAsync(ex, lastProcessed);\n            }\n            catch (Exception ex)\n            {\n                // Not great, but hey, we can skip this and keep going!\n                await controller.RecordDeadLetterEventAsync(e, ex);\n            }\n        }\n\n        // This is a mechanism for subscriptions to \"know\" when the progress for a page of events and any\n        // pending writes to the Marten store are about to be committed or have just been committed\n        // This was added specifically to enable Wolverine integration with its transactional outbox\n        return new Callback();\n    }\n\n    private async Task handleEvent(IEvent @event)\n    {\n        // do some custom work on this event\n    }\n\n    // This is a mechanism to allow the subscription to \"know\" when Marten is about to persist\n    internal class Callback: IChangeListener\n    {\n        public Task AfterCommitAsync(IDocumentSession session, IChangeSet commit, CancellationToken token)\n        {\n            Console.WriteLine(\"Marten is about to make a commit for any changes\");\n            return Task.CompletedTask;\n        }\n\n        public Task BeforeCommitAsync(IDocumentSession session, IChangeSet commit, CancellationToken token)\n        {\n            Console.WriteLine(\"Marten just made a commit for any changes\");\n            return Task.CompletedTask;\n        }\n    }\n}\n\npublic class ReallyBadException: Exception\n{\n    public ReallyBadException(string message) : base(message)\n    {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Ejecting Pending Document Changes in Marten (C#)\nDESCRIPTION: Demonstrates how to remove all queued document changes and event operations from a Marten IDocumentSession using the EjectAllPendingChanges() method. This operation does not affect the document store's identity map. It asserts that pending changes exist before and do not exist after calling EjectAllPendingChanges().\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/sessions.md#_snippet_5\n\nLANGUAGE: cs\nCODE:\n```\ntheSession.Store(Target.Random());\ntheSession.Insert(Target.Random());\ntheSession.Update(Target.Random());\n\ntheSession.PendingChanges.Operations().Any().ShouldBeTrue();\n\ntheSession.EjectAllPendingChanges();\n\ntheSession.PendingChanges.Operations().Any().ShouldBeFalse();\n```\n\n----------------------------------------\n\nTITLE: Day Projection with Event Fan Out in Marten (C#)\nDESCRIPTION: This C# code snippet demonstrates how to use Marten's `MultiStreamProjection` to create a `DayProjection` that utilizes the event \"fan out\" feature. It groups events by `Day` and processes `Travel.Movements` and `Travel.Stops` as if they were separate events. The `FanOut` methods specify how to extract child events from the `Travel` event. The Apply methods update the `Day` aggregate based on the events processed (TripStarted, TripEnded, Movement, and Stop). The example also includes configuration for caching and batch size to optimize performance.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/multi-stream-projections.md#_snippet_12\n\nLANGUAGE: cs\nCODE:\n```\npublic class DayProjection: MultiStreamProjection<Day, int>\n{\n    public DayProjection()\n    {\n        // Tell the projection how to group the events\n        // by Day document\n        Identity<IDayEvent>(x => x.Day);\n\n        // This just lets the projection work independently\n        // on each Movement child of the Travel event\n        // as if it were its own event\n        FanOut<Travel, Movement>(x => x.Movements);\n\n        // You can also access Event data\n        FanOut<Travel, Stop>(x => x.Data.Stops);\n\n        ProjectionName = \"Day\";\n\n        // Opt into 2nd level caching of up to 100\n        // most recently encountered aggregates as a\n        // performance optimization\n        CacheLimitPerTenant = 1000;\n\n        // With large event stores of relatively small\n        // event objects, moving this number up from the\n        // default can greatly improve throughput and especially\n        // improve projection rebuild times\n        Options.BatchSize = 5000;\n    }\n\n    public void Apply(Day day, TripStarted e) => day.Started++;\n    public void Apply(Day day, TripEnded e) => day.Ended++;\n\n    public void Apply(Day day, Movement e)\n    {\n        switch (e.Direction)\n        {\n            case Direction.East:\n                day.East += e.Distance;\n                break;\n            case Direction.North:\n                day.North += e.Distance;\n                break;\n            case Direction.South:\n                day.South += e.Distance;\n                break;\n            case Direction.West:\n                day.West += e.Distance;\n                break;\n\n            default:\n                throw new ArgumentOutOfRangeException();\n        }\n    }\n\n    public void Apply(Day day, Stop e) => day.Stops++;\n}\n```\n\n----------------------------------------\n\nTITLE: Subscription Starting Position\nDESCRIPTION: This code demonstrates how to specify the starting position of a subscription in Marten. Options include subscribing from the present, from a specific sequence number, or from a specific timestamp. The example shows how these options can be applied globally or to specific databases when using multi-tenancy.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/subscriptions.md#_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\nbuilder.Services.AddMarten(opts =>\n    {\n        opts.Connection(builder.Configuration.GetConnectionString(\"marten\"));\n    })\n    // Marten also supports a Scoped lifecycle, and quietly forward Transient\n    // to Scoped\n    .AddSubscriptionWithServices<KafkaSubscription>(ServiceLifetime.Singleton, o =>\n    {\n        // Start the subscription at the most current \"high water mark\" of the\n        // event store. This effectively makes the subscription a \"hot\"\n        // observable that only sees events when the subscription is active\n        o.Options.SubscribeFromPresent();\n\n        // Only process events in the store from a specified event sequence number\n        o.Options.SubscribeFromSequence(1000);\n\n        // Only process events in the store by determining the floor by the event\n        // timestamp information\n        o.Options.SubscribeFromTime(new DateTimeOffset(2024, 4, 1, 0, 0, 0, 0.Seconds()));\n\n        // All of these options can be explicitly applied to only a single\n        // named database when using multi-tenancy through separate databases\n        o.Options.SubscribeFromPresent(\"Database1\");\n        o.Options.SubscribeFromSequence(2000, \"Database2\");\n    })\n    .AddAsyncDaemon(DaemonMode.HotCold);\n\nusing var host = builder.Build();\nawait host.StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Upserting Documents with Store() in Marten\nDESCRIPTION: This snippet demonstrates how to use `IDocumentSession.Store()` to either insert a new document or update an existing document in Marten. It utilizes the PostgreSQL \"upsert\" capability for efficient storage.  The code stores a new `User` object and updates an existing one, then saves the changes to the database.  It requires a configured `DocumentStore` and a `User` class.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/storing.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nusing var store = DocumentStore.For(\"some connection string\");\n\nawait using var session = store.LightweightSession();\n\nvar newUser = new User\n{\n    UserName = \"travis.kelce\"\n};\n\nvar existingUser = await session.Query<User>()\n    .SingleAsync(x => x.UserName == \"patrick.mahomes\");\n\nexistingUser.Roles = new[] {\"admin\"};\n\n// We're storing one brand new document, and one\n// existing document that will just be replaced\n// upon SaveChangesAsync()\nsession.Store(newUser, existingUser);\n\nawait session.SaveChangesAsync();\n```\n\n----------------------------------------\n\nTITLE: Starting and Appending Events to a Stream\nDESCRIPTION: Demonstrates how to start a new event stream and append events to it using Marten's event store.  It initializes a `DocumentStore`, creates a new `QuestStarted` and `MembersJoined` event, starts a new stream with these events, appends more `MembersJoined` and `ArrivedAtLocation` events, and finally saves the changes to the database using `SaveChangesAsync()`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/quickstart.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n    _.Connection(ConnectionSource.ConnectionString);\n});\n\nvar questId = Guid.NewGuid();\n\nawait using var session = store.LightweightSession();\nvar started = new QuestStarted(questId, \"Destroy the One Ring\");\nvar joined1 = new MembersJoined(questId,1, \"Hobbiton\", [\"Frodo\", \"Sam\"]);\n\n// Start a brand new stream and commit the new events as\n// part of a transaction\nsession.Events.StartStream(questId, started, joined1);\n\n// Append more events to the same stream\nvar joined2 = new MembersJoined(questId,3, \"Buckland\", [\"Merry\", \"Pippen\"]);\nvar joined3 = new MembersJoined(questId,10, \"Bree\", [\"Aragorn\"]);\nvar arrived = new ArrivedAtLocation(questId, 15, \"Rivendell\");\nsession.Events.Append(questId, joined2, joined3, arrived);\n\n// Save the pending changes to db\nawait session.SaveChangesAsync();\n```\n\n----------------------------------------\n\nTITLE: Configuring Foreign Key to User in Marten\nDESCRIPTION: This C# code configures a Marten document store with a foreign key constraint from the `Issue` document to the `User` document via the `AssigneeId` property.  This enforces referential integrity between `Issue` and `User` documents. It requires Marten and a database connection string. The configuration uses the fluent API to define the foreign key relationship.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/indexing/foreign-keys.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore\n    .For(_ =>\n    {\n        _.Connection(\"some database connection\");\n\n        // In the following line of code, I'm setting\n        // up a foreign key relationship to the User document\n        _.Schema.For<Issue>().ForeignKey<User>(x => x.AssigneeId);\n    });\n```\n\n----------------------------------------\n\nTITLE: Querying Maybe Soft Deleted Documents\nDESCRIPTION: This C# code snippet demonstrates how to include soft-deleted documents in Linq queries using the `MaybeDeleted()` method. It creates user documents, soft-deletes some, and then queries all documents, including the deleted ones.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/deletes.md#_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic async Task query_maybe_soft_deleted_docs()\n{\n    var user1 = new User { UserName = \"foo\" };\n    var user2 = new User { UserName = \"bar\" };\n    var user3 = new User { UserName = \"baz\" };\n    var user4 = new User { UserName = \"jack\" };\n\n    using var session = theStore.LightweightSession();\n    session.Store(user1, user2, user3, user4);\n    await session.SaveChangesAsync();\n\n    session.DeleteWhere<User>(x => x.UserName.StartsWith(\"b\"));\n    await session.SaveChangesAsync();\n\n    // no where clause, all documents are returned\n    session.Query<User>().Where(x => x.MaybeDeleted()).OrderBy(x => x.UserName).Select(x => x.UserName)\n        .ToList().ShouldHaveTheSameElementsAs(\"bar\", \"baz\", \"foo\", \"jack\");\n\n    // with a where clause, all documents are returned\n    session.Query<User>().Where(x => x.UserName != \"jack\" && x.MaybeDeleted())\n        .OrderBy(x => x.UserName)\n        .ToList()\n        .Select(x => x.UserName)\n        .ShouldHaveTheSameElementsAs(\"bar\", \"baz\", \"foo\");\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Multiple Full Text Indexes with Different Languages (C#)\nDESCRIPTION: This code snippet demonstrates how to create multiple full-text indexes for the same document (`User`) with different language configurations (`RegConfig`) in Marten using the fluent interface of `StoreOptions`. It creates one index for `FirstName` with the default 'english' configuration and another for `LastName` with the 'italian' configuration.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/full-text.md#_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n    _.Connection(ConnectionSource.ConnectionString);\n\n    // This creates\n    _.Schema.For<User>()\n        .FullTextIndex(d => d.FirstName) //by default it will use \"english\"\n        .FullTextIndex(\"italian\", d => d.LastName);\n});\n```\n\n----------------------------------------\n\nTITLE: Starting a New Event Stream with Guid Identifier (C#)\nDESCRIPTION: This code shows different ways to start a new event stream in Marten, including options for specifying the stream ID (either letting Marten generate it or providing a user-defined Guid), associating the stream with an aggregate type (Quest in this case), and optionally omitting the aggregate type altogether. It uses `session.Events.StartStream()` and saves changes using `session.SaveChangesAsync()`.  The events `MembersJoined` and `MembersDeparted` are appended to the stream.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/appending.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic async Task start_stream_with_guid_stream_identifiers(IDocumentSession session)\n{\n    var joined = new MembersJoined { Members = new[] { \"Rand\", \"Matt\", \"Perrin\", \"Thom\" } };\n    var departed = new MembersDeparted { Members = new[] { \"Thom\" } };\n\n    // Let Marten assign a new Stream Id, and mark the stream with an aggregate type\n    // 'Quest'\n    var streamId1 = session.Events.StartStream<Quest>(joined, departed).Id;\n\n    // Or pass the aggregate type in without generics\n    var streamId2 = session.Events.StartStream(typeof(Quest), joined, departed);\n\n    // Or instead, you tell Marten what the stream id should be\n    var userDefinedStreamId = Guid.NewGuid();\n    session.Events.StartStream<Quest>(userDefinedStreamId, joined, departed);\n\n    // Or pass the aggregate type in without generics\n    session.Events.StartStream(typeof(Quest), userDefinedStreamId, joined, departed);\n\n    // Or forget about the aggregate type whatsoever\n    var streamId4 = session.Events.StartStream(joined, departed);\n\n    // Or start with a known stream id and no aggregate type\n    session.Events.StartStream(userDefinedStreamId, joined, departed);\n\n    // And persist the new stream of course\n    await session.SaveChangesAsync();\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Pre-Build Types in Marten\nDESCRIPTION: This C# code snippet demonstrates how to configure Marten to use pre-generated code. It includes registering document types, compiled query types, and event store projections. It also sets the `GeneratedCodeMode` to `TypeLoadMode.Auto` to enable the usage of pre-generated code at runtime.  The code also shows registering a multi-tenanted store.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/prebuilding.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic static class Program\n{\n    public static Task<int> Main(string[] args)\n    {\n        return CreateHostBuilder(args).RunOaktonCommands(args);\n    }\n\n    public static IHostBuilder CreateHostBuilder(string[] args)\n    {\n        return Host.CreateDefaultBuilder(args)\n            .ConfigureServices((hostContext, services) =>\n            {\n                services.AddMartenStore<IOtherStore>(opts =>\n                {\n                    opts.Connection(ConnectionSource.ConnectionString);\n                    opts.RegisterDocumentType<Target>();\n                    opts.GeneratedCodeMode = TypeLoadMode.Auto;\n                });\n\n                services.AddMarten(opts =>\n                {\n                    opts.AutoCreateSchemaObjects = AutoCreate.All;\n                    opts.DatabaseSchemaName = \"cli\";\n                    opts.DisableNpgsqlLogging = true;\n\n                    opts.Events.UseOptimizedProjectionRebuilds = true;\n\n                    opts.MultiTenantedWithSingleServer(\n                        ConnectionSource.ConnectionString,\n                        t => t.WithTenants(\"tenant1\", \"tenant2\", \"tenant3\")\n                    );\n\n                    // This is important, setting this option tells Marten to\n                    // *try* to use pre-generated code at runtime\n                    opts.GeneratedCodeMode = TypeLoadMode.Auto;\n\n                    //opts.Schema.For<Activity>().AddSubClass<DaemonTests.TestingSupport.Trip>();\n\n                    // You have to register all persisted document types ahead of time\n                    // RegisterDocumentType<T>() is the equivalent of saying Schema.For<T>()\n                    // just to let Marten know that document type exists\n                    opts.RegisterDocumentType<Target>();\n                    opts.RegisterDocumentType<User>();\n\n                    // If you use compiled queries, you will need to register the\n                    // compiled query types with Marten ahead of time\n                    opts.RegisterCompiledQueryType(typeof(FindUserByAllTheThings));\n\n                    // Register all event store projections ahead of time\n                    opts.Projections\n                        .Add(new TripProjectionWithCustomName(), ProjectionLifecycle.Async);\n\n                    opts.Projections\n                        .Add(new DayProjection(), ProjectionLifecycle.Async);\n\n                    opts.Projections\n                        .Add(new DistanceProjection(), ProjectionLifecycle.Async);\n\n                    opts.Projections\n                        .Add(new SimpleProjection(), ProjectionLifecycle.Inline);\n\n                    // This is actually important to register \"live\" aggregations too for the code generation\n                    //opts.Projections.LiveStreamAggregation<Trip>();\n                }).AddAsyncDaemon(DaemonMode.Solo);\n            });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Batch Include Query with Marten in C#\nDESCRIPTION: This C# code demonstrates how to perform a batch query with an Include operation using Marten.  It creates a batch query, includes related User data based on AssigneeId, filters based on the issue title, and retrieves a single Issue object. The `included` variable captures the included User object.  This snippet uses `CreateBatchQuery()`, `Include()`, `On()`, `Where()`, and `Single()` methods.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/include.md#_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nvar batch = query.CreateBatchQuery();\n\nvar found = batch.Query<Issue>()\n    .Include<User>(x => included = x).On(x => x.AssigneeId)\n    .Where(x => x.Title == issue1.Title)\n    .Single();\n```\n\n----------------------------------------\n\nTITLE: Trip Stream Aggregation Example C#\nDESCRIPTION: This C# code snippet shows a sample `Trip` class that serves as an aggregate in a Marten stream aggregation scenario. It demonstrates how to define a no-argument constructor and a constructor that takes a `TripStarted` event to initialize the aggregate.  The snippet also includes `Apply` methods that mutate the aggregate state based on different event types (`Arrival`, `Travel`, `TripEnded`) and `ShouldDelete` methods that determine when to delete the aggregate based on certain events.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/aggregate-projections.md#_snippet_5\n\nLANGUAGE: cs\nCODE:\n```\npublic class Trip\n{\n    // Probably safest to have an empty, default\n    // constructor unless you can guarantee that\n    // a certain event type will always be first in\n    // the event stream\n    public Trip()\n    {\n    }\n\n    // Create a new aggregate based on the initial\n    // event type\n    internal Trip(TripStarted started)\n    {\n        StartedOn = started.Day;\n        Active = true;\n    }\n\n    public Guid Id { get; set; }\n    public int EndedOn { get; set; }\n\n    public double Traveled { get; set; }\n\n    public string State { get; set; }\n\n    public bool Active { get; set; }\n\n    public int StartedOn { get; set; }\n    public Guid? RepairShopId { get; set; }\n\n    // The Apply() methods would mutate the aggregate state\n    internal void Apply(Arrival e) => State = e.State;\n    internal void Apply(Travel e) => Traveled += e.TotalDistance();\n\n    internal void Apply(TripEnded e)\n    {\n        Active = false;\n        EndedOn = e.Day;\n    }\n\n    // We think stream aggregation is mostly useful for live aggregations,\n    // but hey, if you want to use a aggregation as an asynchronous projection,\n    // you can also specify when the aggregate document should be deleted\n    internal bool ShouldDelete(TripAborted e) => true;\n    internal bool ShouldDelete(Breakdown e) => e.IsCritical;\n    internal bool ShouldDelete(VacationOver e) => Traveled > 1000;\n}\n```\n\n----------------------------------------\n\nTITLE: Create Full Text Index for Multiple Properties with Custom Settings (C#)\nDESCRIPTION: This code snippet demonstrates how to create a full text index for multiple properties with custom settings using the StoreOptions fluent interface in Marten. It indexes both 'FirstName' and 'LastName' properties of the 'MyDocument' document and configures the language to 'spanish'. Requires Marten and PostgreSQL version 10.0 or above.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/full_text.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nusing var store = DocumentStore.For(_ =>\n{\n    _.Connection(\"your_postgres_connection_string\");\n    _.Schema.For<MyDocument>().Searchable(new string[] {\"FirstName\", \"LastName\"}, regConfig: \"spanish\");\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing a Compiled Query with FindByFirstName\nDESCRIPTION: This class implements the `ICompiledQuery` interface to find a user by their first name. It includes a `FirstName` property for filtering and a `QueryIs()` method that defines the LINQ query to execute. The query uses `FirstOrDefault` to retrieve a single matching user.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/compiled-queries.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic class FindByFirstName: ICompiledQuery<User, User>\n{\n    public string FirstName { get; set; }\n\n    public Expression<Func<IMartenQueryable<User>, User>> QueryIs()\n    {\n        return q => q.FirstOrDefault(x => x.FirstName == FirstName);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Querying with Select() for one property in Marten (C#)\nDESCRIPTION: This snippet demonstrates how to use the `Select()` operator in a Marten query to retrieve a single property (FirstName) from the `User` document. The retrieved values are then asserted to match the expected results. It requires `theSession` (an `IDocumentSession`) to be initialized and populated with `User` documents.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/projections.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic async Task use_select_in_query_for_one_field()\n{\n    theSession.Store(new User { FirstName = \"Hank\" });\n    theSession.Store(new User { FirstName = \"Bill\" });\n    theSession.Store(new User { FirstName = \"Sam\" });\n    theSession.Store(new User { FirstName = \"Tom\" });\n\n    await theSession.SaveChangesAsync();\n\n    theSession.Query<User>().OrderBy(x => x.FirstName).Select(x => x.FirstName)\n        .ShouldHaveTheSameElementsAs(\"Bill\", \"Hank\", \"Sam\", \"Tom\");\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Name Data Length\nDESCRIPTION: This C# code snippet demonstrates how to set the `NameDataLength` property in Marten to account for Postgresql's limits on database object names when the default has been overridden.  If a Postgresql database's NAMEDATALEN property has been modified, Marten needs to be informed. The snippet sets the `NameDataLength` property to match the custom value set in Postgresql.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/storeoptions.md#_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n    // If you have overridden NAMEDATALEN in your\n    // Postgresql database to 100\n    _.NameDataLength = 100;\n});\n```\n\n----------------------------------------\n\nTITLE: Simple Explicit Code for Live Aggregation (C#)\nDESCRIPTION: This code shows how to use the `CustomProjection` base class for live aggregations by overriding only the `Apply()` method. It iterates through events and updates the aggregate document based on the event type, demonstrating a simple aggregation workflow. The `Apply` method is responsible for returning the new value of the aggregated document.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/custom-aggregates.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic class ExplicitCounter: CustomProjection<SimpleAggregate, Guid>\n{\n    public override SimpleAggregate Apply(SimpleAggregate snapshot, IReadOnlyList<IEvent> events)\n    {\n        snapshot ??= new SimpleAggregate();\n        foreach (var e in events.Select(x => x.Data))\n        {\n            if (e is AEvent) snapshot.ACount++;\n            if (e is BEvent) snapshot.BCount++;\n            if (e is CEvent) snapshot.CCount++;\n            if (e is DEvent) snapshot.DCount++;\n        }\n\n        // You have to explicitly return the new value\n        // of the aggregated document no matter what!\n        return snapshot;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Manual Change Tracking with Marten LightweightSession\nDESCRIPTION: Explains how to use Marten's `LightweightSession` for manual change tracking.  The code demonstrates adding a new user, marking an existing user as changed, and deleting another user, followed by persisting the changes to the database using `SaveChangesAsync`. It highlights that `Store()` performs upserts and mentions the auto-assignment policy for document ids.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/sessions.md#_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nawait using var session = store.LightweightSession();\nvar user = new User { FirstName = \"Jeremy\", LastName = \"Miller\" };\n\n// Manually adding the new user to the session\nsession.Store(user);\n\nvar existing = session.Query<User>().Single(x => x.FirstName == \"Max\");\nexisting.Internal = false;\n\n// Manually marking an existing user as changed\nsession.Store(existing);\n\n// Marking another existing User document as deleted\nsession.Delete<User>(Guid.NewGuid());\n\n// Persisting the changes to the database\nawait session.SaveChangesAsync();\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom ID Generation in Marten\nDESCRIPTION: This snippet shows how to implement a custom ID generation strategy in Marten. The custom ID generator should implement the `IIdGeneration` interface and provide custom logic for generating IDs. It provides an example showing how to define a custom id generation.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/identity.md#_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\npublic class CustomIdGeneration : IIdGeneration\n{\n    public IEnumerable<Type> KeyTypes { get; } = new Type[] {typeof(string)};\n\n    public bool RequiresSequences { get; } = false;\n    public void GenerateCode(GeneratedMethod assign, DocumentMapping mapping)\n    {\n        var document = new Use(mapping.DocumentType);\n        assign.Frames.Code($\"_setter({{0}}, \\\"newId\\\");\", document);\n        assign.Frames.Code($\"return {{0}}.{mapping.CodeGen.AccessId};\", document);\n    }\n\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Per-Tenant Unique Index (C#)\nDESCRIPTION: This code snippet illustrates how to define per-tenant unique indexes in Marten for multi-tenanted documents. It shows how to create unique indexes on duplicated fields and computed fields, specifying the `TenancyScope.PerTenant` and providing an index name.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/indexing/unique.md#_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n    _.Connection(ConnectionSource.ConnectionString);\n    _.DatabaseSchemaName = \"unique_text\";\n\n    // This creates a duplicated field unique index on firstname, lastname and tenant_id\n    _.Schema.For<User>().MultiTenanted().UniqueIndex(UniqueIndexType.DuplicatedField, \"index_name\", TenancyScope.PerTenant, x => x.FirstName, x => x.LastName);\n\n    // This creates a computed unique index on client name and tenant_id\n    _.Schema.For<Client>().MultiTenanted().UniqueIndex(UniqueIndexType.Computed, \"index_name\", TenancyScope.PerTenant, x => x.Name);\n});\n```\n\n----------------------------------------\n\nTITLE: Querying with MatchesSql and MatchesJsonPath in Marten (C#)\nDESCRIPTION: This snippet illustrates using `MatchesSql` with a custom placeholder character ('^') for JSONPath expressions and showcases the older `MatchesJsonPath` method. Both methods are used to query the `Target` document based on a JSONPath condition applied to the `data` field.  The snippet requires Marten and assumes the `Target` class and `theSession` object are defined elsewhere.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/sql.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvar results2 = await theSession\n    .Query<Target>().Where(x => x.MatchesSql('^', \"d.data @? '$ ? (@.Children[*] == null || @.Children[*].size() == 0)'\"))\n    .ToListAsync();\n\n// older approach that only supports the ^ placeholder\nvar results3 = await theSession\n    .Query<Target>().Where(x => x.MatchesJsonPath(\"d.data @? '$ ? (@.Children[*] == null || @.Children[*].size() == 0)'\"))\n    .ToListAsync();\n```\n\n----------------------------------------\n\nTITLE: Applying Database Changes on Startup - C#\nDESCRIPTION: This code shows how to configure Marten to apply all outstanding database changes on application startup. The `ApplyAllDatabaseChangesOnStartup` extension method registers an `IHostedService` that automatically applies schema updates.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/schema/migrations.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\n// The normal Marten configuration\nservices.AddMarten(opts =>\n    {\n        // This helps isolate a test, not something you need to do\n        // in normal usage\n        opts.ApplyChangesLockId += 18;\n\n        opts.Connection(ConnectionSource.ConnectionString);\n        opts.DatabaseSchemaName = \"apply_changes\";\n        opts.RegisterDocumentType<User>();\n    })\n\n    // Direct the application to apply all outstanding\n    // database changes on application startup\n    .ApplyAllDatabaseChangesOnStartup();\n```\n\n----------------------------------------\n\nTITLE: Configuring Mapping-Specific Custom ID Generation in Marten\nDESCRIPTION: This snippet illustrates how to define a custom ID generation algorithm for a specific document type in Marten. The code configures the document store to use a custom ID generation strategy for the `UserWithString` document type.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/identity.md#_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\noptions.Schema.For<UserWithString>().IdStrategy(new CustomIdGeneration());\n```\n\n----------------------------------------\n\nTITLE: Handling Concurrency Conflicts - Marten C#\nDESCRIPTION: This snippet shows how Marten handles concurrency conflicts when storing aggregates. It attempts to store two invoices with the same identity. The second attempt to store the invoice results in an `EventStreamUnexpectedMaxEventIdException`, preventing a conflicted state.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/scenarios/aggregates-events-repositories.md#_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nvar invoice = CreateInvoice();\nvar invoiceWithSameIdentity = CreateInvoice();\n\nawait repository.StoreAsync(invoice);\n\nawait Assert.ThrowsAsync<EventStreamUnexpectedMaxEventIdException>(() =>\n    repository.StoreAsync(invoiceWithSameIdentity)\n);\n```\n\n----------------------------------------\n\nTITLE: Persisting and Querying with Mixed Tenancy in Marten (C#)\nDESCRIPTION: This code demonstrates how to persist and query documents with mixed tenancy (tenanted, non-tenanted, and default tenant) using Marten. It configures a DocumentStore with multi-tenancy enabled for Target and Issue documents, and non-tenancy for User documents. Then, it inserts documents into different tenants (Green, Red, default), and queries them back using sessions scoped to specific tenants and the default tenant. It makes use of BulkInsert for data seeding, and QuerySession for data retrieval. The use of TenantIsOneOf() is also shown when querying for documents outside of the current session's tenant.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/multi-tenancy.md#_snippet_4\n\nLANGUAGE: cs\nCODE:\n```\nusing var store = DocumentStore.For(opts =>\n{\n    opts.DatabaseSchemaName = \"mixed_multi_tenants\";\n    opts.Connection(ConnectionSource.ConnectionString);\n    opts.Schema.For<Target>().MultiTenanted(); // tenanted\n    opts.Schema.For<User>(); // non-tenanted\n    opts.Schema.For<Issue>().MultiTenanted(); // tenanted\n});\n\nstore.Advanced.Clean.DeleteAllDocuments();\n\n// Add documents to tenant Green\nvar greens = Target.GenerateRandomData(10).ToArray();\nstore.BulkInsert(\"Green\", greens);\n\n// Add documents to tenant Red\nvar reds = Target.GenerateRandomData(11).ToArray();\nstore.BulkInsert(\"Red\", reds);\n\n// Add non-tenanted documents\n// User is non-tenanted in schema\nvar user1 = new User { UserName = \"Frank\" };\nvar user2 = new User { UserName = \"Bill\" };\nstore.BulkInsert(new[] { user1, user2 });\n\n// Add documents to default tenant\n// Note that schema for Issue is multi-tenanted hence documents will get added\n// to default tenant if tenant is not passed in the bulk insert operation\nvar issue1 = new Issue { Title = \"Test issue1\" };\nvar issue2 = new Issue { Title = \"Test issue2\" };\nstore.BulkInsert(new[] { issue1, issue2 });\n\n// Create a session with tenant Green\nusing (var session = store.QuerySession(\"Green\"))\n{\n    // Query tenanted document as the tenant passed in session\n    session.Query<Target>().Count().ShouldBe(10);\n\n    // Query non-tenanted documents\n    session.Query<User>().Count().ShouldBe(2);\n\n    // Query documents in default tenant from a session using tenant Green\n    session.Query<Issue>().Count(x => x.TenantIsOneOf(Tenancy.DefaultTenantId)).ShouldBe(2);\n\n    // Query documents from tenant Red from a session using tenant Green\n    session.Query<Target>().Count(x => x.TenantIsOneOf(\"Red\")).ShouldBe(11);\n}\n\n// create a session without passing any tenant, session will use default tenant\nusing (var session = store.QuerySession())\n{\n    // Query non-tenanted documents\n    session.Query<User>().Count().ShouldBe(2);\n\n    // Query documents in default tenant\n    // Note that session is using default tenant\n    session.Query<Issue>().Count().ShouldBe(2);\n\n    // Query documents on tenant Green\n    session.Query<Target>().Count(x => x.TenantIsOneOf(\"Green\")).ShouldBe(10);\n\n    // Query documents on tenant Red\n    session.Query<Target>().Count(x => x.TenantIsOneOf(\"Red\")).ShouldBe(11);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Marten to use Noda Time\nDESCRIPTION: This code snippet demonstrates how to configure a Marten `DocumentStore` to use Noda Time.  Calling the `UseNodaTime()` extension method registers the necessary serializers and configurations for Noda Time types. This sets up default JSON serialization options provided by `JsonNetSerializer`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/noda_time.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:noda_time_default_setup]>\n```\n\n----------------------------------------\n\nTITLE: Custom Grouper with Transformation Projection (C#)\nDESCRIPTION: This C# code snippet defines a `MonthlyAllocationProjection` that uses a custom grouper (`MonthlyAllocationGrouper`) to transform and aggregate `EmployeeAllocated` events into monthly summaries.  The `CustomGrouping` method specifies the custom grouper to use.  `TransformsEvent<EmployeeAllocated>()` indicates that events of this type will be considered even if there are no direct handlers for them in the projection. The Apply method consumes EmployeeAllocatedInMonth events produced by the custom grouper.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/multi-stream-projections.md#_snippet_13\n\nLANGUAGE: cs\nCODE:\n```\npublic class MonthlyAllocationProjection: MultiStreamProjection<MonthlyAllocation, string>\n{\n    public MonthlyAllocationProjection()\n    {\n        CustomGrouping(new MonthlyAllocationGrouper());\n        TransformsEvent<EmployeeAllocated>();\n    }\n\n    public void Apply(MonthlyAllocation allocation, EmployeeAllocatedInMonth @event)\n    {\n        allocation.EmployeeId = @event.EmployeeId;\n        allocation.Month = @event.Month;\n\n        var hours = @event\n            .Allocations\n            .Sum(x => x.Hours);\n\n        allocation.Hours += hours;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Event Store Schema\nDESCRIPTION: This code snippet demonstrates how to configure Marten to use a specific database schema for the event store objects. It uses the `DatabaseSchemaName` property to specify the schema name, ensuring that all event store-related tables and functions are created within that schema. The connection string needs to be provided.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/storage.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n    _.Connection(\"some connection string\");\n\n    // Places all the Event Store schema objects\n    // into the \"events\" schema\n    _.Events.DatabaseSchemaName = \"events\";\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling Global Projections - Marten - C#\nDESCRIPTION: This snippet shows how to enable global projections for conjoined tenancy in Marten.  This option allows you to define projections that apply across all tenants in a multi-tenant system. Enabling this setting bypasses validation and exception throwing for tenancy mismatches, so proceed with caution.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/configuration.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nopts.Events.EnableGlobalProjectionsForConjoinedTenancy = true;\n```\n\n----------------------------------------\n\nTITLE: Adding Marten Services to .NET Core Startup - C#\nDESCRIPTION: This snippet demonstrates how to add Marten services to the IoC container in a .NET Core application's `Startup.ConfigureServices()` method using the `AddMarten()` extension method. It registers `IDocumentStore` as a Singleton, `IDocumentSession` as Scoped with identity map behavior, and `IQuerySession` as Scoped. No external dependencies are shown in this snippet.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/integration.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:StartupConfigureServices]>\n```\n\n----------------------------------------\n\nTITLE: Creating a Multi-Property Calculated Index (Marten)\nDESCRIPTION: This C# code snippet demonstrates how to create a calculated index spanning multiple properties (`FirstName`, `LastName`) of a `User` document type. This allows for optimizing queries based on combinations of properties.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/computed_index.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic class User\n{\n    public Guid Id { get; set; }\n    public string FirstName { get; set; }\n    public string LastName { get; set; }\n}\n\npublic class UserConfiguration : Marten.Mapping.DocumentMapping<User>\n{\n    public UserConfiguration()\n    {\n        Index(x => new { x.FirstName, x.LastName });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Projecting properties and transforming to a type, C#\nDESCRIPTION: This code snippet demonstrates how to retrieve specific document properties and transform them into another type using the `Select()` method in Marten. It creates a new object of the specified type using the selected properties. The code leverages linq's `IQueryable.Select()` method.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/projections.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:other_type_projection]>\n```\n\n----------------------------------------\n\nTITLE: Configuring Optimistic Concurrency - C#\nDESCRIPTION: This snippet demonstrates how to enable optimistic concurrency for a document type using Marten's configuration API. The code configures a `DocumentStore` and uses the `UseOptimisticConcurrency(true)` method to enable optimistic concurrency for the `Issue` document type. This ensures that updates to `Issue` documents are only allowed if they have not been modified since they were loaded.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/concurrency.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n    // Adds optimistic concurrency checking to Issue\n    _.Schema.For<Issue>().UseOptimisticConcurrency(true);\n});\n```\n\n----------------------------------------\n\nTITLE: Writing Documents with Tenant Scoped Session in Marten (C#)\nDESCRIPTION: This code snippet demonstrates how to write User documents to a specific tenant using Marten's LightweightSession.  The session is scoped to the tenant \"tenant1\", and the Store method is used to persist the User objects.  The SaveChangesAsync method persists the changes to the database.  Requires Marten document store instance.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/multi-tenancy.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n// Write some User documents to tenant \"tenant1\"\nusing (var session = theStore.LightweightSession(\"tenant1\"))\n{\n    session.Store(new User { Id = \"u1\", UserName = \"Bill\", Roles = new[] { \"admin\" } });\n    session.Store(new User { Id = \"u2\", UserName = \"Lindsey\", Roles = new string[0] });\n    await session.SaveChangesAsync();\n}\n```\n\n----------------------------------------\n\nTITLE: Adding a Gin Index with Custom Attribute - C#\nDESCRIPTION: This snippet provides a specific example of a custom MartenAttribute, GinIndexedAttribute, used to add a GIN index to the JSONB storage for efficient adhoc querying.  It overrides the Modify method to call AddGinIndexToData() on the DocumentMapping.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/storeoptions.md#_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\n[AttributeUsage(AttributeTargets.Class)]\npublic class GinIndexedAttribute: MartenAttribute\n{\n    public override void Modify(DocumentMapping mapping)\n    {\n        mapping.AddGinIndexToData();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Remove Repeated Primitives from Collection in Marten (C#)\nDESCRIPTION: This snippet shows removing all occurrences of a primitive element from a collection using `Patch.Remove()` with `RemoveAction.RemoveAll`. The test sets up a target with a `NumberArray`, ensures there are duplicate elements, and then removes all of them.  Dependencies: Marten, Xunit, Shouldly.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/partial-updates-patching.md#_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic async Task remove_repeated_primitive_elements()\n{\n    var random = new Random();\n    var target = Target.Random();\n    target.NumberArray = new[] { random.Next(0, 10), random.Next(0, 10), random.Next(0, 10) };\n    target.NumberArray = target.NumberArray.Distinct().ToArray();\n\n    var initialCount = target.NumberArray.Length;\n\n    var child = target.NumberArray[random.Next(0, initialCount)];\n    var occurances = target.NumberArray.Count(e => e == child);\n    if (occurances < 2)\n    {\n        target.NumberArray = target.NumberArray.Concat(new[] { child }).ToArray();\n        ++occurances;\n        ++initialCount;\n    }\n\n    theSession.Store(target);\n    await theSession.SaveChangesAsync();\n\n    theSession.Patch<Target>(target.Id).Remove(x => x.NumberArray, child, RemoveAction.RemoveAll);\n    await theSession.SaveChangesAsync();\n\n    using (var query = theStore.QuerySession())\n    {\n        var target2 = query.Load<Target>(target.Id);\n        target2.NumberArray.Length.ShouldBe(initialCount - occurances);\n\n        target2.NumberArray.ShouldHaveTheSameElementsAs(target.NumberArray.Except(new[] { child }));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Advanced JSON Serializer Configuration (C#)\nDESCRIPTION: This snippet shows how to completely override serializer settings for both Newtonsoft.Json and System.Text.Json. It uses the `configure` parameter to access and modify the serializer settings directly. Dependencies: Marten DocumentStore, Newtonsoft.Json, System.Text.Json.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/json.md#_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n    _.UseNewtonsoftForSerialization( // [!code focus:14]\n        enumStorage: EnumStorage.AsString,\n        configure: settings =>\n        {\n            settings.DateTimeZoneHandling = DateTimeZoneHandling.RoundtripKind;\n            settings.ConstructorHandling = ConstructorHandling.AllowNonPublicDefaultConstructor;\n        });\n\n    _.UseSystemTextJsonForSerialization(\n        enumStorage: EnumStorage.AsString,\n        configure: settings =>\n        {\n            settings.MaxDepth = 100;\n        });\n});\n```\n\n----------------------------------------\n\nTITLE: Synchronous Loading by Id with Marten (C#)\nDESCRIPTION: This snippet demonstrates synchronous loading of documents by Id using the Marten `IDocumentSession`. It covers loading single documents identified by Guid, integer, and string Ids, as well as loading multiple documents by passing a variable number of Guid Ids or an array of Guid Ids to the `LoadMany` method.  The loaded objects are of types `User`, `IntDoc`, and `StringDoc` which are assumed to be document types registered with Marten.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/byid.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic void LoadById(IDocumentSession session)\n{\n    var userId = Guid.NewGuid();\n\n    // Load a single document identified by a Guid\n    var user = session.Load<User>(userId);\n\n    // There's an overload of Load for integers and longs\n    var doc = session.Load<IntDoc>(15);\n\n    // Another overload for documents identified by strings\n    var doc2 = session.Load<StringDoc>(\"Hank\");\n\n    // Load multiple documents by a group of id's\n    var users = session.LoadMany<User>(Guid.NewGuid(), Guid.NewGuid(), Guid.NewGuid());\n\n    var ids = new Guid[] { Guid.NewGuid(), Guid.NewGuid(), Guid.NewGuid() };\n\n    // If you already have an array of id values\n    var users2 = session.LoadMany<User>(ids);\n}\n```\n\n----------------------------------------\n\nTITLE: Applying a Custom Tenancy Model in Marten (C#)\nDESCRIPTION: This code shows how to configure Marten to use a custom `ITenancy` implementation.  It creates a `DocumentStore` and sets the `Tenancy` property in the `opts` configuration to an instance of the `MySpecialTenancy` class. Requires Marten package and a valid connection string.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/multitenancy.md#_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(opts =>\n{\n    opts.Connection(\"connection string\");\n\n    // Apply custom tenancy model\n    opts.Tenancy = new MySpecialTenancy();\n});\n```\n\n----------------------------------------\n\nTITLE: Soft Delete Attribute - Marten - C#\nDESCRIPTION: Shows how to mark a document type for soft deletion using the [SoftDeleted] attribute. Documents of this type will be marked as deleted rather than being physically removed from the database. This requires the Marten library and appropriate configuration.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/deletes.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\n[SoftDeleted]\npublic class SoftDeletedDoc\n{\n    public Guid Id;\n}\n```\n\n----------------------------------------\n\nTITLE: Define Computed Unique Index (Multiple Properties) via Attribute in Marten C#\nDESCRIPTION: This code defines a computed unique index spanning multiple properties using the `UniqueIndex` attribute in Marten.  It applies the `[UniqueIndex]` attribute to both the `Street` and `Number` properties of the `Address` class, using the same `IndexName` to group them into a single index. This enforces uniqueness based on the combination of these properties.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/indexing/unique.md#_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic class Address\n{\n    private const string UniqueIndexName = \"sample_uidx_person\";\n\n    public Guid Id { get; set; }\n\n    [UniqueIndex(IndexType = UniqueIndexType.Computed, IndexName = UniqueIndexName)]\n    public string Street { get; set; }\n\n    [UniqueIndex(IndexType = UniqueIndexType.Computed, IndexName = UniqueIndexName)]\n    public string Number { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Verbose Level of Marten Connection Tracking\nDESCRIPTION: This snippet shows how to enable verbose connection tracking in Marten using the `TrackLevel.Verbose` setting.  It configures a `DocumentStore` with a connection string and sets the `TrackConnections` option to `Verbose` within the `OpenTelemetry` configuration. In addition to normal connection tracking, this setting also tags Open Telemetry activity events for all Marten operations (storing, appending, etc.) after a successful database transaction.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/otel.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nusing var store = DocumentStore.For(opts =>\n{\n    opts.Connection(\"some connection string\");\n\n    // Track Marten connection usage *and* all the \"write\" operations\n    // that Marten does with that connection\n    opts.OpenTelemetry.TrackConnections = TrackLevel.Verbose;\n});\n```\n\n----------------------------------------\n\nTITLE: Registering Inline Projection with Marten in C#\nDESCRIPTION: This code snippet shows how to register an inline projection for the `QuestParty` aggregate with Marten. By registering the aggregate as a snapshot with `SnapshotLifecycle.Inline`, Marten will automatically update the projected document inline with the events being appended.  This means the `QuestParty` document will be updated in the same database transaction when an event is appended. The example also shows configuration for multi-tenancy.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/index.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n    _.Connection(ConnectionSource.ConnectionString);\n    _.Events.TenancyStyle = tenancyStyle;\n    _.DatabaseSchemaName = \"quest_sample\";\n    if (tenancyStyle == TenancyStyle.Conjoined)\n    {\n        _.Schema.For<QuestParty>().MultiTenanted();\n    }\n\n    // This is all you need to create the QuestParty projected\n    // view\n    _.Projections.Snapshot<QuestParty>(SnapshotLifecycle.Inline);\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Full Text Index on Property - Marten C#\nDESCRIPTION: Defines a full text index for a single property (`Information`) within the `UserProfile` class using the `[FullTextIndex]` attribute. This indexes only the specified property with the default 'english' configuration. Requires the Marten library.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/full-text.md#_snippet_7\n\nLANGUAGE: cs\nCODE:\n```\npublic class UserProfile\n{\n    public Guid Id { get; set; }\n\n    [FullTextIndex] public string Information { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Storing Multiple Documents with IDocumentSession.Store() (C#)\nDESCRIPTION: This code snippet demonstrates how to use the `IDocumentSession.Store()` method to store multiple documents at once. It showcases the usage with a params array of documents. The method performs either insertion or update based on the existence of the document.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/basics/persisting.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing Marten;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class Target\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n}\n\npublic class UsingStoreWithMultipleDocs\n{\n    public async Task Using_Store_With_Multiple_Docs(IDocumentStore store)\n    {\n        using (var session = store.OpenSession())\n        {\n            var targets = new Target[]\n            {\n                new Target { Name = \"Target 1\" },\n                new Target { Name = \"Target 2\" },\n                new Target { Name = \"Target 3\" }\n            };\n\n            session.Store(targets);\n\n            await session.SaveChangesAsync();\n\n            // Or...\n\n            session.Store(new Target { Name = \"Another Target\" }, new Target { Name = \"Yet Another Target\" });\n\n            await session.SaveChangesAsync();\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Including a Single Reference with Strong Identifier in C#\nDESCRIPTION: This snippet demonstrates how to use `Include()` with a strong typed identifier to load a related document. It creates a `Teacher` and a `Class`, associates them via the `TeacherId` property (which is a strong typed identifier), and then queries for the `Class` while including the related `Teacher` in a separate list. The test verifies that both documents are loaded correctly.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/identity.md#_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic async Task include_a_single_reference()\n{\n    var teacher = new Teacher();\n    var c = new Class();\n\ntheSession.Store(teacher);\n\n    c.TeacherId = teacher.Id;\ntheSession.Store(c);\n\n    await theSession.SaveChangesAsync();\n\ntheSession.Logger = new TestOutputMartenLogger(_output);\n\n    var list = new List<Teacher>();\n\n    var loaded = await theSession\n        .Query<Class>()\n        .Include<Teacher>(c => c.TeacherId, list)\n        .Where(x => x.Id == c.Id)\n        .FirstOrDefaultAsync();\n\n    loaded.Id.ShouldBe(c.Id);\n    list.Single().Id.ShouldBe(teacher.Id);\n}\n```\n\n----------------------------------------\n\nTITLE: Using Environment Check in Hosted Service (C#)\nDESCRIPTION: This code snippet demonstrates how to use Marten's environment check within a hosted service to assert that the actual Marten database matches the configured state on startup.  It configures the `HostOptions` to stop the host on background service exceptions and registers Marten with a connection string, then calls `AssertDatabaseMatchesConfigurationOnStartup()` to perform the check. Requires Microsoft.Extensions.Hosting and Marten NuGet packages.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/environment-checks.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic static async Task use_environment_check()\n{\n    using var host = await Host.CreateDefaultBuilder()\n        .ConfigureServices(services =>\n        {\n            // Do this, or your environment check assertion failures below\n            // is just swallowed and logged on startup\n            services.Configure<HostOptions>(options =>\n            {\n                options.BackgroundServiceExceptionBehavior = BackgroundServiceExceptionBehavior.StopHost;\n            });\n\n            services.AddMarten(\"connection string\")\n                .AssertDatabaseMatchesConfigurationOnStartup();\n        })\n        .StartAsync();\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Event to Multiple Views with MultiStreamProjection (C#)\nDESCRIPTION: This snippet demonstrates how to apply the `MultipleUsersAssignedToGroup` event to multiple `UserGroupsAssignment` projected documents using the `Identities()` method. It defines a `UserGroupsAssignmentProjection` that inherits from `MultiStreamProjection` and specifies how to handle `UserRegistered` and `MultipleUsersAssignedToGroup` events. It shows how to define identities based on event data and apply event data to the view.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/multi-stream-projections.md#_snippet_4\n\nLANGUAGE: cs\nCODE:\n```\npublic class UserGroupsAssignmentProjection: MultiStreamProjection<UserGroupsAssignment, Guid>\n{\n    public UserGroupsAssignmentProjection()\n    {\n        Identity<UserRegistered>(x => x.UserId);\n\n        // You can now use IEvent<T> as well as declaring this against the core event type\n        Identities<IEvent<MultipleUsersAssignedToGroup>>(x => x.Data.UserIds);\n    }\n\n    public void Apply(UserRegistered @event, UserGroupsAssignment view)\n    {\n        view.Id = @event.UserId;\n    }\n\n    public void Apply(MultipleUsersAssignedToGroup @event, UserGroupsAssignment view)\n    {\n        view.Groups.Add(@event.GroupId);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Computed Unique Index with Store Options (Single Property) - C#\nDESCRIPTION: This code snippet demonstrates how to define a unique computed index on a single property using the `StoreOptions` fluent interface in Marten. This method adds an index to the database based on the computed value of a property. The absence of the `IndexType` parameter defaults to a computed index.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/unique.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:using_a_single_property_computed_unique_index_through_store_options]>\n```\n\n----------------------------------------\n\nTITLE: Registering an Aggregation Type for Inline Projections in C#\nDESCRIPTION: This code shows how to register an aggregation type (`QuestParty`) in the `StoreOptions` to enable inline projections. When registered, Marten will automatically update the aggregate document inline with the events being appended.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/events/projections/index.md#_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\n// SAMPLE: registering-quest-party\nusing var host = Host.CreateDefaultBuilder()\n    .ConfigureServices(services =>\n    {\n        services.AddMarten(opts =>\n        {\n            opts.Projections.SelfAggregate<QuestParty>(ProjectionLifecycle.Inline);\n        });\n    }).Build();\n// ENDSAMPLE\n```\n\n----------------------------------------\n\nTITLE: Overriding Schema Name per Table in Marten (C#)\nDESCRIPTION: This code snippet shows how to assign specific document tables to different schemas, allowing for a more granular control over schema organization.  This is achieved through the `SchemaName` configuration within the document mapping configuration, allowing placing certain document types in specific schemas. When a specified schema doesn't exist, it will be created in the database.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/schema/index.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nopts.SchemaName = \"overriden\";\n```\n\nLANGUAGE: C#\nCODE:\n```\nopts.SchemaName = \"other\";\n```\n\n----------------------------------------\n\nTITLE: Fetching Events for a Stream with Marten in C#\nDESCRIPTION: This code snippet demonstrates how to retrieve events for a specific stream using the `IEventStore.FetchStream()` and `IEventStore.FetchStreamAsync()` methods in Marten. It showcases fetching all events, fetching events up to a specific version, and fetching events up to a specific timestamp. It requires a document session and a stream ID.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/querying.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic void load_event_stream(IDocumentSession session, Guid streamId)\n{\n    // Fetch *all* of the events for this stream\n    var events1 = session.Events.FetchStream(streamId);\n\n    // Fetch the events for this stream up to and including version 5\n    var events2 = session.Events.FetchStream(streamId, 5);\n\n    // Fetch the events for this stream at this time yesterday\n    var events3 = session.Events\n        .FetchStream(streamId, timestamp: DateTime.UtcNow.AddDays(-1));\n}\n\npublic async Task load_event_stream_async(IDocumentSession session, Guid streamId)\n{\n    // Fetch *all* of the events for this stream\n    var events1 = await session.Events.FetchStreamAsync(streamId);\n\n    // Fetch the events for this stream up to and including version 5\n    var events2 = await session.Events.FetchStreamAsync(streamId, 5);\n\n    // Fetch the events for this stream at this time yesterday\n    var events3 = await session.Events\n        .FetchStreamAsync(streamId, timestamp: DateTime.UtcNow.AddDays(-1));\n}\n```\n\n----------------------------------------\n\nTITLE: Using Inline Projection in Marten Document Store (C#)\nDESCRIPTION: This code demonstrates how to configure and use an inline projection in a Marten document store. It sets up a document store, adds the `MonsterDefeatedTransform` projection with `ProjectionLifecycle.Inline`, starts an event stream, and then calls `SaveChangesAsync()` which applies the projection and updates the database in the same transaction. Requires Marten and a connection string.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/inline.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(opts =>\n{\n    opts.Connection(\"some connection string\");\n\n    opts.Projections.Add(new MonsterDefeatedTransform(),\n        ProjectionLifecycle.Inline);\n});\n\nawait using var session = store.LightweightSession();\n\nvar streamId = session.Events\n    .StartStream<QuestParty>(started, joined, slayed1, slayed2, joined2).Id;\n\n// The projection is going to be applied right here during\n// the call to SaveChangesAsync() and the resulting document update\n// of the new MonsterDefeated document will happen in the same database\n// transaction\nawait theSession.SaveChangesAsync();\n```\n\n----------------------------------------\n\nTITLE: Configuring AutoCreateSchemaObjects in Marten (C#)\nDESCRIPTION: This code snippet demonstrates how to configure the `AutoCreateSchemaObjects` option in Marten to control the automatic generation and updates of schema objects. It shows different modes: `AutoCreate.All`, `AutoCreate.CreateOrUpdate`, `AutoCreate.CreateOnly`, and `AutoCreate.None`.  The `StoreOptions` are configured to define how Marten handles schema changes.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/schema/index.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\nvar store = DocumentStore.For(opts =>\n{\n    // Marten will create any new objects that are missing,\n    // attempt to update tables if it can, but drop and replace\n    // tables that it cannot patch.\n    opts.AutoCreateSchemaObjects = AutoCreate.All;\n\n    // Marten will create any new objects that are missing or\n    // attempt to update tables if it can. Will *never* drop\n    // any existing objects, so no data loss\n    opts.AutoCreateSchemaObjects = AutoCreate.CreateOrUpdate;\n\n    // Marten will create missing objects on demand, but\n    // will not change any existing schema objects\n    opts.AutoCreateSchemaObjects = AutoCreate.CreateOnly;\n\n    // Marten will not create or update any schema objects\n    // and throws an exception in the case of a schema object\n    // not reflecting the Marten configuration\n    opts.AutoCreateSchemaObjects = AutoCreate.None;\n});\n```\n\n----------------------------------------\n\nTITLE: Incrementing Integer Value in Marten\nDESCRIPTION: This code snippet shows how to increment an integer value in a persisted document using the `Patch` and `Increment` methods.  By default, it increments the value by 1.  It retrieves a `Target` document, increments its `Number` by one, and verifies the change.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/partial-updates-patching.md#_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic async Task increment_for_int()\n{\n    var target = Target.Random();\n    target.Number = 6;\n\n    theSession.Store(target);\n    await theSession.SaveChangesAsync();\n\n    theSession.Patch<Target>(target.Id).Increment(x => x.Number);\n    await theSession.SaveChangesAsync();\n\n    using (var query = theStore.QuerySession())\n    {\n        query.Load<Target>(target.Id).Number.ShouldBe(7);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Marten by Nested Closure\nDESCRIPTION: This snippet demonstrates registering Marten by supplying a nested closure to configure Marten inline.  It configures the connection and optimizes artifact workflow. It requires `Microsoft.Extensions.DependencyInjection` and `Microsoft.Extensions.Configuration`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/hostbuilder.md#_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\nvar connectionString = Configuration.GetConnectionString(\"postgres\");\n\nservices.AddMarten(opts =>\n    {\n        opts.Connection(connectionString);\n    })\n    // Using the \"Optimized artifact workflow\" for Marten >= V5\n    // sets up your Marten configuration based on your environment\n    // See https://martendb.io/configuration/optimized_artifact_workflow.html\n    .OptimizeArtifactWorkflow();\n```\n\n----------------------------------------\n\nTITLE: Configuring Marten with DocumentMapping<T> (Specific)\nDESCRIPTION: This C# code snippet demonstrates configuring Marten using a static `ConfigureMarten` method that accepts a `DocumentMapping<T>` for the specific document type. This enables access to convenience methods for indexing or duplicating fields using .Net Expressions. In this example, it duplicates the `Name` field. The document type contains an Id and Name field. The configuration method duplicates the name field in the document mapping.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/storeoptions.md#_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic class ConfiguresItselfSpecifically\n{\n    public Guid Id;\n    public string Name;\n\n    public static void ConfigureMarten(DocumentMapping<ConfiguresItselfSpecifically> mapping)\n    {\n        mapping.Duplicate(x => x.Name);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Invoice Entity and Apply Methods in C#\nDESCRIPTION: This code defines the Invoice entity class and its corresponding Apply methods for each of the Invoice events. The Apply methods update the state of the Invoice object based on the event data. This pattern is crucial for event sourcing, where the current state of an entity is derived by applying all relevant events in order. The InvoiceStatus enum tracks the state of the invoice.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/live-aggregates.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic class Invoice\n{\n    public Guid Id { get; private set; }\n    public double Amount { get; private set; }\n    public string Number { get; private set; } = default!;\n\n    public InvoiceStatus Status { get; private set; }\n\n    public Person IssuedTo { get; private set; } = default!;\n    public DateTime InitiatedAt { get; private set; }\n\n    public string? IssuedBy { get; private set; }\n    public DateTime IssuedAt { get; private set; }\n\n    public InvoiceSendMethod SentVia { get; private set; }\n    public DateTime SentAt { get; private set; }\n\n    public void Apply(InvoiceInitiated @event)\n    {\n        Id = @event.InvoiceId;\n        Amount = @event.Amount;\n        Number = @event.Number;\n        IssuedTo = @event.IssuedTo;\n        InitiatedAt = @event.InitiatedAt;\n        Status = InvoiceStatus.Initiated;\n    }\n\n    public void Apply(InvoiceIssued @event)\n    {\n        IssuedBy = @event.IssuedBy;\n        IssuedAt = @event.IssuedAt;\n        Status = InvoiceStatus.Issued;\n    }\n\n    public void Apply(InvoiceSent @event)\n    {\n        SentVia = @event.SentVia;\n        SentAt = @event.SentAt;\n        Status = InvoiceStatus.Sent;\n    }\n}\n\npublic enum InvoiceStatus\n{\n    Initiated = 1,\n    Issued = 2,\n    Sent = 3\n}\n```\n\n----------------------------------------\n\nTITLE: Waiting for Non-Stale Projection Data\nDESCRIPTION: Illustrates how to use `IDocumentStore.WaitForNonStaleProjectionDataAsync()` to ensure asynchronous projections have caught up with the latest events before performing assertions in tests. Requires Marten to be configured with asynchronous projections and the daemon to be running.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/async-daemon.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic async Task run_simultaneously()\n{\n    StoreOptions(x => x.Projections.Add(new DistanceProjection(), ProjectionLifecycle.Async));\n\n    NumberOfStreams = 10;\n\n    var agent = await StartDaemon();\n\n    // This method publishes a random number of events\n    await PublishSingleThreaded();\n\n    // Wait for all projections to reach the highest event sequence point\n    // as of the time this method is called\n    await theStore.WaitForNonStaleProjectionDataAsync(15.Seconds());\n\n    await CheckExpectedResults();\n}\n```\n\n----------------------------------------\n\nTITLE: Query with AND/OR Operators using Linq in Marten (C#)\nDESCRIPTION: Illustrates how to combine multiple conditions in a Linq query using both `&&` (AND) and `||` (OR) operators.  This allows for more complex filtering logic when querying documents.  The example assumes the presence of `Number` and `String` properties on the document type.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/linq.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nvar andOr = session.Query<Target>()\n    .Where(x => x.Number == 3 && (x.String == \"foo\" || x.String == \"bar\"))\n    .ToList();\n```\n\n----------------------------------------\n\nTITLE: Custom Grouper for Event Transformation (C#)\nDESCRIPTION: This C# code snippet defines a custom grouper `MonthlyAllocationGrouper` that implements the `IAggregateGrouper<string>` interface. It transforms `EmployeeAllocated` events into `EmployeeAllocatedInMonth` events, grouping them by employee ID and month. The `Group` method extracts allocation data from the events, groups it by employee and month, and creates new `EmployeeAllocatedInMonth` events. These new events are then added to the grouping for projection.  This enables the projection to work against data reshaped by the custom grouper.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/multi-stream-projections.md#_snippet_14\n\nLANGUAGE: cs\nCODE:\n```\npublic class MonthlyAllocationGrouper: IAggregateGrouper<string>\n{\n    public Task Group(\n        IQuerySession session,\n        IEnumerable<IEvent> events,\n        ITenantSliceGroup<string> grouping\n    )\n    {\n        var allocations = events\n            .OfType<IEvent<EmployeeAllocated>>();\n\n        var monthlyAllocations = allocations\n            .SelectMany(@event =>\n                @event.Data.Allocations.Select(\n                    allocation => new\n                    {\n                        @event.Data.EmployeeId,\n                        Allocation = allocation,\n                        Month = allocation.Day.ToStartOfMonth(),\n                        Source = @event\n                    }\n                )\n            )\n            .GroupBy(allocation =>\n                new { allocation.EmployeeId, allocation.Month, allocation.Source }\n            )\n            .Select(monthlyAllocation =>\n                new\n                {\n\n                    Key = $\"{monthlyAllocation.Key.EmployeeId}|{monthlyAllocation.Key.Month:yyyy-MM-dd}\",\n                    Event = monthlyAllocation.Key.Source.WithData(\n                        new EmployeeAllocatedInMonth(\n                            monthlyAllocation.Key.EmployeeId,\n                            monthlyAllocation.Key.Month,\n                            monthlyAllocation.Select(a => a.Allocation).ToList())\n                    )\n\n                }\n            );\n\n        foreach (var monthlyAllocation in monthlyAllocations)\n        {\n            grouping.AddEvents(\n                monthlyAllocation.Key,\n                new[] { monthlyAllocation.Event }\n            );\n        }\n\n        return Task.CompletedTask;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Value Types with Marten StoreOptions\nDESCRIPTION: This snippet shows how to register value types with Marten's `StoreOptions`.  This registration is crucial for Marten to correctly understand and use these types within LINQ queries.  `opts` is assumed to be an instance of `StoreOptions` configured during Marten's initialization. This allows Marten to treat the value types as primitives when constructing SQL queries.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/identity.md#_snippet_23\n\nLANGUAGE: cs\nCODE:\n```\n// opts is a StoreOptions just like you'd have in\n// AddMarten() calls\nopts.RegisterValueType(typeof(UpperLimit));\nopts.RegisterValueType(typeof(LowerLimit));\n```\n\n----------------------------------------\n\nTITLE: Adding a User Module with ConfigureMarten in C#\nDESCRIPTION: This code shows how to add a user module to a Marten configuration using the `ConfigureMarten` extension method. It registers the `User` document type within the main Marten document store. This approach is useful for segregating Marten configuration into separate assemblies or subsystems, promoting modularity and testability.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/hostbuilder.md#_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\npublic static IServiceCollection AddUserModule(this IServiceCollection services)\n{\n    // This applies additional configuration to the main Marten DocumentStore\n    // that is configured elsewhere\n    services.ConfigureMarten(opts =>\n    {\n        opts.RegisterDocumentType<User>();\n    });\n\n    // Other service registrations specific to the User submodule\n    // within the bigger system\n\n    return services;\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching Stream State with Marten in C#\nDESCRIPTION: This code snippet demonstrates how to fetch the state of an event stream, including its version and aggregate type, using `IEventStore.FetchStreamState()`, `IEventStore.FetchStreamStateAsync()`, and `IBatchQuery.Events.FetchStreamState()` in Marten.  It also showcases usage within a batch query.  Requires a document session and a stream ID.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/querying.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic class fetching_stream_state: IntegrationContext\n{\n    private Guid theStreamId;\n\n    public fetching_stream_state(DefaultStoreFixture fixture) : base(fixture)\n    {\n\n    }\n\n    protected override Task fixtureSetup()\n    {\n        var joined = new MembersJoined { Members = new[] { \"Rand\", \"Matt\", \"Perrin\", \"Thom\" } };\n        var departed = new MembersDeparted { Members = new[] { \"Thom\" } };\n\n        theStreamId = theSession.Events.StartStream<Quest>(joined, departed).Id;\n        return theSession.SaveChangesAsync();\n    }\n\n    [Fact]\n    public void can_fetch_the_stream_version_and_aggregate_type()\n    {\n        var state = theSession.Events.FetchStreamState(theStreamId);\n\n        state.ShouldNotBeNull();\n        state.Id.ShouldBe(theStreamId);\n        state.Version.ShouldBe(2);\n        state.AggregateType.ShouldBe(typeof(Quest));\n        state.LastTimestamp.ShouldNotBe(DateTimeOffset.MinValue);\n        state.Created.ShouldNotBe(DateTimeOffset.MinValue);\n    }\n\n    [Fact]\n    public async Task can_fetch_the_stream_version_and_aggregate_type_async()\n    {\n        var state = await theSession.Events.FetchStreamStateAsync(theStreamId);\n\n        state.ShouldNotBeNull();\n        state.Id.ShouldBe(theStreamId);\n        state.Version.ShouldBe(2);\n        state.AggregateType.ShouldBe(typeof(Quest));\n        state.LastTimestamp.ShouldNotBe(DateTimeOffset.MinValue);\n        state.Created.ShouldNotBe(DateTimeOffset.MinValue);\n    }\n\n    [Fact]\n    public async Task can_fetch_the_stream_version_through_batch_query()\n    {\n        var batch = theSession.CreateBatchQuery();\n\n        var stateTask = batch.Events.FetchStreamState(theStreamId);\n\n        await batch.Execute();\n\n        var state = await stateTask;\n\n        state.Id.ShouldBe(theStreamId);\n        state.Version.ShouldBe(2);\n        state.AggregateType.ShouldBe(typeof(Quest));\n        state.LastTimestamp.ShouldNotBe(DateTimeOffset.MinValue);\n    }\n\n    [Fact]\n    public async Task can_fetch_the_stream_events_through_batch_query()\n    {\n        var batch = theSession.CreateBatchQuery();\n\n        var eventsTask = batch.Events.FetchStream(theStreamId);\n\n        await batch.Execute();\n\n        var events = await eventsTask;\n\n        events.Count.ShouldBe(2);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing DocumentStore with Connection String (C#)\nDESCRIPTION: This snippet demonstrates how to initialize a `DocumentStore` using a connection string. It sets up document storage against a PostgreSQL database. Marten automatically creates database tables and functions for new document types if they don't exist.  This uses the default auto-creation behavior.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/index.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:start_a_store]>\n```\n\n----------------------------------------\n\nTITLE: Defining ISubscription Interface in Marten C#\nDESCRIPTION: This code snippet defines the `ISubscription` interface in Marten, which serves as the base abstraction for custom subscriptions to Marten events through the async daemon.  It includes the `ProcessEventsAsync` method, which processes a page of events at a time, allowing custom processing against an ordered stream of events.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/subscriptions.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n/// <summary>\n/// Basic abstraction for custom subscriptions to Marten events through the async daemon. Use this in\n/// order to do custom processing against an ordered stream of the events\n/// </summary>\npublic interface ISubscription : IAsyncDisposable\n{\n    /// <summary>\n    /// Processes a page of events at a time\n    /// </summary>\n    /// <param name=\"page\"></param>\n    /// <param name=\"controller\">Use to log dead letter events that are skipped or to stop the subscription from processing based on an exception</param>\n    /// <param name=\"operations\">Access to Marten queries and writes that will be committed with the progress update for this subscription</param>\n    /// <param name=\"cancellationToken\"></param>\n    /// <returns></returns>\n    Task<IChangeListener> ProcessEventsAsync(EventRange page, ISubscriptionController controller,\n        IDocumentOperations operations,\n        CancellationToken cancellationToken);\n}\n```\n\n----------------------------------------\n\nTITLE: Multiple Includes - C#\nDESCRIPTION: This example shows how to chain multiple `Include()` calls to fetch multiple related document types. It retrieves an `Issue`, its assigned `User` (Assignee), and the `User` who reported the `Issue` (Reporter) in a single query.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/include.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvar assignee = default(User);\nvar reporter = default(User);\n\nvar issue = await session.Query<Issue>()\n    .Include(x => x.AssigneeId, x => assignee = x)\n    .Include(x => x.ReporterId, x => reporter = x)\n    .FirstOrDefaultAsync(x => x.Title == \"Include Test\");\n```\n\n----------------------------------------\n\nTITLE: Defining MultiStreamProjection with Caching in C#\nDESCRIPTION: This code defines a `MultiStreamProjection` subclass (`DayProjection`) in Marten, showcasing fan-out rules, projection name setting, and crucially, enabling 2nd level caching with `CacheLimitPerTenant`. This caching mechanism improves performance during asynchronous projection building by storing frequently accessed aggregated documents in memory.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/optimizing.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\npublic class DayProjection: MultiStreamProjection<Day, int>\n{\n    public DayProjection()\n    {\n        // Tell the projection how to group the events\n        // by Day document\n        Identity<IDayEvent>(x => x.Day);\n\n        // This just lets the projection work independently\n        // on each Movement child of the Travel event\n        // as if it were its own event\n        FanOut<Travel, Movement>(x => x.Movements);\n\n        // You can also access Event data\n        FanOut<Travel, Stop>(x => x.Data.Stops);\n\n        ProjectionName = \"Day\";\n\n        // Opt into 2nd level caching of up to 100\n        // most recently encountered aggregates as a\n        // performance optimization\n        CacheLimitPerTenant = 1000;\n\n        // With large event stores of relatively small\n        // event objects, moving this number up from the\n        // default can greatly improve throughput and especially\n        // improve projection rebuild times\n        Options.BatchSize = 5000;\n    }\n\n    public void Apply(Day day, TripStarted e) => day.Started++;\n    public void Apply(Day day, TripEnded e) => day.Ended++;\n\n    public void Apply(Day day, Movement e)\n    {\n        switch (e.Direction)\n        {\n            case Direction.East:\n                day.East += e.Distance;\n                break;\n            case Direction.North:\n                day.North += e.Distance;\n                break;\n            case Direction.South:\n                day.South += e.Distance;\n                break;\n            case Direction.West:\n                day.West += e.Distance;\n                break;\n\n            default:\n                throw new ArgumentOutOfRangeException();\n        }\n    }\n\n    public void Apply(Day day, Stop e) => day.Stops++;\n}\n```\n\n----------------------------------------\n\nTITLE: Using a Simple Calculated Index (Marten)\nDESCRIPTION: This C# code snippet demonstrates how to create a simple calculated index on the `UserName` property of a `User` document type using Marten's configuration API. It shows how to configure the document mapping to include the calculated index.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/computed_index.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic class User\n{\n    public Guid Id { get; set; }\n    public string UserName { get; set; }\n}\n\npublic class UserConfiguration : Marten.Mapping.DocumentMapping<User>\n{\n    public UserConfiguration()\n    {\n        Index(x => x.UserName);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Marten by StoreOptions Object\nDESCRIPTION: This snippet demonstrates registering Marten by passing a `StoreOptions` object to `AddMarten()`.  It builds the `StoreOptions` object yourself and configures the connection.  It relies on `Microsoft.Extensions.DependencyInjection` and `Microsoft.Extensions.Configuration`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/hostbuilder.md#_snippet_3\n\nLANGUAGE: cs\nCODE:\n```\nvar connectionString = Configuration.GetConnectionString(\"postgres\");\n\n// Build a StoreOptions object yourself\nvar options = new StoreOptions();\noptions.Connection(connectionString);\n\nservices.AddMarten(options)\n    // Using the \"Optimized artifact workflow\" for Marten >= V5\n    // sets up your Marten configuration based on your environment\n    // See https://martendb.io/configuration/optimized_artifact_workflow.html\n    .OptimizeArtifactWorkflow();\n```\n\n----------------------------------------\n\nTITLE: Setting the Database Schema Name\nDESCRIPTION: This C# code snippet demonstrates how to set the default database schema name for Marten using `StoreOptions.DatabaseSchemaName`.  It initializes the document store and configures the default database schema name. All document types will be placed into the specified schema unless overridden.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/storeoptions.md#_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(opts =>\n{\n    opts.Connection(\"some connection string\");\n    opts.DatabaseSchemaName = \"other\";\n});\n```\n\n----------------------------------------\n\nTITLE: Using Strong Typed Identifier for Aggregate Projections - C#\nDESCRIPTION: This code demonstrates the use of a strongly-typed identifier (`PaymentId`) for aggregate projections in Marten. It shows how to define a `PaymentId` struct with the `StronglyTypedId` attribute and use it as the document identity for a `Payment` class. It includes methods to create and apply events to the `Payment` aggregate.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/aggregate-projections.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n[StronglyTypedId(Template.Guid)]\npublic readonly partial struct PaymentId;\n\npublic class Payment\n{\n    [JsonInclude] public PaymentId? Id { get; private set; }\n\n    [JsonInclude] public DateTimeOffset CreatedAt { get; private set; }\n\n    [JsonInclude] public PaymentState State { get; private set; }\n\n    public static Payment Create(IEvent<PaymentCreated> @event)\n    {\n        return new Payment\n        {\n            Id = new PaymentId(@event.StreamId), CreatedAt = @event.Data.CreatedAt, State = PaymentState.Created\n        };\n    }\n\n    public void Apply(PaymentCanceled @event)\n    {\n        State = PaymentState.Canceled;\n    }\n\n    public void Apply(PaymentVerified @event)\n    {\n        State = PaymentState.Verified;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Applying a Custom Document Policy\nDESCRIPTION: This C# code snippet demonstrates how to apply a custom document policy to the Marten document store.  It showcases the usage of `StoreOptions.Policies.OnDocuments<TPolicy>()` to apply a policy. This configures the document store by adding a custom policy that will be applied to all documents.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/storeoptions.md#_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(storeOptions =>\n{\n    // Apply custom policy\n    storeOptions.Policies.OnDocuments<TenancyPolicy>();\n```\n\n----------------------------------------\n\nTITLE: Configure Foreign Key Relationship - C#\nDESCRIPTION: Demonstrates how to configure a foreign key relationship between an Issue document and User documents in Marten using the fluent interface. This configuration will create an `assignee_id` field in the `mt_doc_issue` table and a foreign key constraint referencing the `mt_doc_user` table.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/foreign_keys.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:configure-foreign-key]>\n```\n\n----------------------------------------\n\nTITLE: Deleting Existing Property with Patch - C#\nDESCRIPTION: This code snippet demonstrates how to delete an existing property from a persisted document using `Patch.Delete()`.  It uses a lambda expression to directly target the property to be removed.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/partial-updates-patching.md#_snippet_15\n\nLANGUAGE: cs\nCODE:\n```\ntheSession.Patch<Target>(target.Id).Delete(t => t.Inner);\n```\n\n----------------------------------------\n\nTITLE: Turning on Optimized Projection Rebuilds in Marten (C#)\nDESCRIPTION: This code snippet demonstrates how to enable optimized projection rebuilds in Marten for single stream projections. It modifies the Marten configuration within the `AddMarten` extension method to set `opts.Events.UseOptimizedProjectionRebuilds` to true.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/rebuilding.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nbuilder.Services.AddMarten(opts =>\n{\n    opts.Connection(\"some connection string\");\n\n    // Opts into a mode where Marten is able to rebuild single // [!code ++]\n    // stream projections faster by building one stream at a time // [!code ++]\n    // Does require new table migrations for Marten 7 users though // [!code ++]\n    opts.Events.UseOptimizedProjectionRebuilds = true; // [!code ++]\n});\n```\n\n----------------------------------------\n\nTITLE: Mutation Extensions for Invoice - C#\nDESCRIPTION: This code defines an extension method `MutateInvoice` on `IDocumentSession` to encapsulate the process of fetching an invoice for writing, appending new events based on a decision function, persisting the changes, and then fetching the latest state of the invoice. It takes an invoice ID and a decider function as input, persists the changes using `SaveChangesAsync`, and retrieves the latest invoice state using `FetchLatest`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/read-aggregates.md#_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic static class MutationExtensions\n{\n    public static async Task<Projections.Invoice> MutateInvoice(this IDocumentSession session, Guid id, Func<Projections.Invoice, IEnumerable<object>> decider,\n        CancellationToken token = default)\n    {\n        var stream = await session.Events.FetchForWriting<Projections.Invoice>(id, token);\n\n        // Decide what new events should be appended based on the current\n        // state of the aggregate and application logic\n        var events = decider(stream.Aggregate);\n        stream.AppendMany(events);\n\n        // Persist any new events\n        await session.SaveChangesAsync(token);\n\n        return await session.Events.FetchLatest<Projections.Invoice>(id, token);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting a Header on a Marten Session (C#)\nDESCRIPTION: This code snippet demonstrates how to set a header key/value pair on a Marten `IDocumentSession`. The `SetHeader` method accepts a session and a `sagaId` string, then calls `session.SetHeader` to add the \"saga-id\" header with the given value. These headers will be persisted alongside the document when changes are saved.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/metadata.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic void SetHeader(IDocumentSession session, string sagaId)\n{\n    session.SetHeader(\"saga-id\", sagaId);\n}\n```\n\n----------------------------------------\n\nTITLE: Configure Multi-Tenancy through Policies in Marten\nDESCRIPTION: This snippet configures multi-tenancy for all documents through Document Policies using `storeOptions.Policies.AllDocumentsAreMultiTenanted()`, which sets the tenancy style to `TenancyStyle.Conjoined` by default. This is the store level configuration, and affects all document types, unless overridden.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/multi-tenancy.md#_snippet_11\n\nLANGUAGE: cs\nCODE:\n```\nstoreOptions.Policies.AllDocumentsAreMultiTenanted();\n// Shorthand for\n// storeOptions.Policies.ForAllDocuments(_ => _.TenancyStyle = TenancyStyle.Conjoined);\n```\n\n----------------------------------------\n\nTITLE: Custom Full Text Index on Property - Marten C#\nDESCRIPTION: Defines a full text index for the `Details` property of the `UserDetails` class with custom settings, including an explicit index name and a specific language configuration ('italian').  Requires the Marten library.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/full-text.md#_snippet_8\n\nLANGUAGE: cs\nCODE:\n```\npublic class UserDetails\n{\n    private const string FullTextIndexName = \"mt_custom_user_details_fts_idx\";\n\n    public Guid Id { get; set; }\n\n    [FullTextIndex(IndexName = FullTextIndexName, RegConfig = \"italian\")]\n    public string Details { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Bulk Inserting and Querying Dynamic Data with Marten - C#\nDESCRIPTION: This snippet demonstrates how to bulk insert `TemperatureData` documents into Marten and subsequently query them based on the 'sensor' or 'detector' property within the dynamic `Values` property.  It uses the non-generic `Query` extension method with a raw SQL predicate to handle the non-uniform structure.  It then calculates the average temperature from the retrieved records.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/scenarios/dynamic-data.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvar docs = records.Select(x => new TemperatureData {Values = x}).ToArray();\n\n// Persist our records\ntheStore.BulkInsertDocuments(docs);\n\nusing var session = theStore.QuerySession();\n// Read back the data for \"aisle-1\"\ndynamic[] tempsFromDb = session.Query(typeof(TemperatureData),\n    \"where data->'Values'->>'detector' = :sensor OR data->'Values'->>'sensor' = :sensor\",\n    new {sensor = \"aisle-1\"}).ToArray();\n\nvar temperatures = tempsFromDb.Select(x => (decimal)x.Values.temperature);\n\nAssert.Equal(15.675m, temperatures.Average());\nAssert.Equal(4, tempsFromDb.Length);\n```\n\n----------------------------------------\n\nTITLE: Appending Events Exclusively to a Stream in Marten (C#)\nDESCRIPTION: This example demonstrates how to append events exclusively to a stream in Marten using `AppendExclusive()`, which reserves a database lock on the stream until the session is saved or disposed. It requires an `IDocumentSession` and a `streamId`. This serializes access to a single event stream.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/appending.md#_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic async Task append_exclusive(IDocumentSession session, Guid streamId)\n{\n    // You *could* pass in events here too, but doing this establishes a transaction\n    // lock on the stream.\n    await session.Events.AppendExclusive(streamId);\n\n    var events = determineNewEvents(streamId);\n\n    // The next call can just be Append()\n    session.Events.Append(streamId, events);\n\n    // This will commit the unit of work and release the\n    // lock on the event stream\n    await session.SaveChangesAsync();\n}\n```\n\n----------------------------------------\n\nTITLE: Appending Events Optimistically to a Stream in Marten (C#)\nDESCRIPTION: This snippet shows how to append events optimistically to an event stream in Marten, using the `AppendOptimistic()` method for concurrency control. It requires an `IDocumentSession`, a `streamId`, and an array of `events`.  It detects changes between calling `AppendOptimistic()` and `SaveChangesAsync()`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/appending.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic async Task append_optimistic(IDocumentSession session, Guid streamId, object[] events)\n{\n    // This is doing data access, so it's an async method\n    await session.Events.AppendOptimistic(streamId, events);\n\n    // Assume that there is other work happening right here...\n\n    await session.SaveChangesAsync();\n}\n```\n\n----------------------------------------\n\nTITLE: Bootstrapping Async Daemon in HotCold Mode (C#)\nDESCRIPTION: This code snippet shows how to bootstrap the Marten Async Daemon in 'HotCold' mode.  It configures the service collection to use Marten, registers a projection to run asynchronously, and activates the daemon in HotCold mode, which uses leader election. Requires Marten and Microsoft.Extensions.Hosting NuGet packages.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/async-daemon.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvar host = await Host.CreateDefaultBuilder()\n    .ConfigureServices(services =>\n    {\n        services.AddMarten(opts =>\n            {\n                opts.Connection(\"some connection string\");\n\n                // Register any projections you need to run asynchronously\n                opts.Projections.Add<TripProjectionWithCustomName>(ProjectionLifecycle.Async);\n            })\n            // Turn on the async daemon in \"HotCold\" mode\n            // with built in leader election\n            .AddAsyncDaemon(DaemonMode.HotCold);\n    })\n    .StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Async Upcasting with Event Type Name in Marten\nDESCRIPTION: This code snippet demonstrates how to register an asynchronous upcaster lambda with a specific event type name in Marten. It converts a ShoppingCartOpened event to a ShoppingCartOpenedWithStatus event, retrieving client data asynchronously and explicitly specifying the event type name to upcast.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/versioning.md#_snippet_26\n\nLANGUAGE: cs\nCODE:\n```\noptions.Events\n    .Upcast<ShoppingCartOpened, ShoppingCartOpenedWithStatus>(\n        \"shopping_cart_opened\",\n        async (oldEvent, ct) =>\n        {\n            // WARNING: UpcastAsync method is called each time old event\n            // is read from database and deserialized.\n            // We discourage to run resource consuming methods here.\n            // It might end up with N+1 problem.\n            var clientName = await clientRepository.GetClientName(oldEvent.ClientId, ct);\n\n            return new ShoppingCartOpenedWithStatus(\n                oldEvent.ShoppingCartId,\n                new Client(oldEvent.ClientId, clientName),\n                ShoppingCartStatus.Opened\n            );\n        }\n    );\n```\n\n----------------------------------------\n\nTITLE: Multi-Tenancy Partitioning Policy in Marten\nDESCRIPTION: This snippet demonstrates how to apply table partitioning to multiple tenanted document types while also supporting global (single-tenanted) document types. It uses `opts.Policies.PartitionMultiTenantedDocuments` to apply a partitioning scheme to all conjoined multi-tenanted documents. The connection string must be provided.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/multi-tenancy.md#_snippet_10\n\nLANGUAGE: cs\nCODE:\n```\nvar store = DocumentStore.For(opts =>\n{\n    opts.Connection(\"some connection string\");\n\n    // This document type is global, so no tenancy\n    opts.Schema.For<Region>().SingleTenanted();\n\n    // We want these document types to be tenanted\n    opts.Schema.For<Invoice>().MultiTenanted();\n    opts.Schema.For<User>().MultiTenanted();\n\n    // Apply table partitioning by tenant id to each document type\n    // that is using conjoined multi-tenancy\n    opts.Policies.PartitionMultiTenantedDocuments(x =>\n    {\n        x.ByExternallyManagedListPartitions();\n    });\n});\n```\n\n----------------------------------------\n\nTITLE: Loading a Single Event by ID in Marten (C#)\nDESCRIPTION: Explains how to fetch information for a single event by its ID, including its version number within the stream, using `IEventStore.Load()`. Requires the event ID as input.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/events/streams.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:load-a-single-event]>\n```\n\n----------------------------------------\n\nTITLE: Initializing Full Text Index for Whole Document with Store Options (C#)\nDESCRIPTION: This code snippet demonstrates how to create a full-text index for an entire document in Marten using the fluent interface of `StoreOptions`. It indexes all properties of the `User` document. The index is created with the default 'english' language configuration if not specified.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/full-text.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n    _.Connection(ConnectionSource.ConnectionString);\n\n    // This creates\n    _.Schema.For<User>().FullTextIndex();\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Duplicated Fields using Attributes - C#\nDESCRIPTION: Demonstrates how to define duplicated fields in a Marten document using the `DuplicateField` attribute. It showcases overriding the Postgresql type for the duplicated column and defining a not null constraint. This approach modifies the database schema.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/indexing/duplicated-fields.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[PropertySearching(PropertySearching.ContainmentOperator)]\npublic class Employee\n{\n    public int Id;\n\n    // You can optionally override the Postgresql\n    // type for the duplicated column in the document\n    // storage table\n    [DuplicateField(PgType = \"text\")]\n    public string Category;\n\n    // Defining a duplicate column with not null constraint\n    [DuplicateField(PgType = \"text\", NotNull = true)]\n    public string Department;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom ITenancy Model in Marten (C#)\nDESCRIPTION: This code snippet demonstrates how to create a custom class, `MySpecialTenancy`, that implements the `ITenancy` interface for Marten's multi-tenancy feature. It's essential to implement the `Dispose()` method to properly dispose of all `MartenDatabase` objects to prevent resource leaks.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/multitenancy.md#_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\n// Make sure you implement the Dispose() method and\n// dispose all MartenDatabase objects\npublic class MySpecialTenancy: ITenancy\n```\n\n----------------------------------------\n\nTITLE: Implementing Compiled List Query\nDESCRIPTION: This class implements `ICompiledListQuery<User>` to retrieve a list of `User` documents based on the `FirstName` property. The `QueryIs()` method defines the LINQ expression to filter users by their first name, which will be used by Marten to generate the query.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/compiled-queries.md#_snippet_6\n\nLANGUAGE: cs\nCODE:\n```\npublic class UsersByFirstName: ICompiledListQuery<User>\n{\n    public static int Count;\n    public string FirstName { get; set; }\n\n    public Expression<Func<IMartenQueryable<User>, IEnumerable<User>>> QueryIs()\n    {\n        return query => query.Where(x => x.FirstName == FirstName);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: FindUserByAllTheThings Compiled Query C#\nDESCRIPTION: This code demonstrates a compiled query `FindUserByAllTheThings` in C# that retrieves a single user document based on multiple criteria. This demonstrates a query that directly implements ICompiledQuery<User>. The `QueryIs` method defines the Linq query with multiple `Where` clauses.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/compiled_queries.md#_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\npublic class FindUserByAllTheThings : ICompiledQuery<User>\n{\n    public string Username { get; set; }\n    public string FirstName { get; set; }\n    public string LastName { get; set; }\n\n    public Expression<Func<IQueryable<User>, User>> QueryIs()\n    {\n        return query => query.Where(x => x.UserName == Username)\n            .Where(x => x.FirstName == FirstName)\n            .FirstOrDefault(x => x.LastName == LastName);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configure Newtonsoft.Json Non-Public Setters (C#)\nDESCRIPTION: This snippet shows how to allow Newtonsoft.Json to deserialize properties with non-public setters. This is done by configuring the `NonPublicMembersStorage` option. Dependencies: Marten DocumentStore, Newtonsoft.Json.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/json.md#_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n     // Allow the JsonNetSerializer to also deserialize using non-public setters // [!code focus:2]\n    _.UseNewtonsoftForSerialization(nonPublicMembersStorage: NonPublicMembersStorage.NonPublicSetters);\n});\n```\n\n----------------------------------------\n\nTITLE: Customize Newtonsoft.Json SnakeCase Casing\nDESCRIPTION: Shows how to automatically format field names to `snake_case` by changing the serialization settings in the `DocumentStore` options. This affects how field names are stored in the database.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/json/newtonsoft.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:customize_json_net_snakecase_casing_serialization]>\n```\n\n----------------------------------------\n\nTITLE: Defining Masking Rules in Marten (C#)\nDESCRIPTION: This snippet demonstrates how to define data masking rules for specific event types within a Marten configuration. It uses the `AddMarten` extension to configure the document store and the `AddMaskingRuleForProtectedInformation` method to specify masking rules for `AccountChanged`, `IAccountEvent`, and `MembersJoined` event types. The example shows how to mask properties by assigning fixed values or iterating over collections.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/protection.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\nbuilder.Services.AddMarten(opts =>\n{\n    opts.Connection(builder.Configuration.GetConnectionString(\"marten\"));\n\n    // By a single, concrete type\n    opts.Events.AddMaskingRuleForProtectedInformation<AccountChanged>(x =>\n    {\n        // I'm only masking a single property here, but you could do as much as you want\n        x.Name = \"****\";\n    });\n\n    // Maybe you have an interface that multiple event types implement that would help\n    // make these rules easier by applying to any event type that implements this interface\n    opts.Events.AddMaskingRuleForProtectedInformation<IAccountEvent>(x => x.Name = \"****\");\n\n    // Little fancier\n    opts.Events.AddMaskingRuleForProtectedInformation<MembersJoined>(x =>\n    {\n        for (int i = 0; i < x.Members.Length; i++)\n        {\n            x.Members[i] = \"*****\";\n        }\n    });\n});\n```\n\n----------------------------------------\n\nTITLE: Chaining Linq Methods after Select(), C#\nDESCRIPTION: This code snippet showcases how to chain other Linq methods such as `First()`, `FirstOrDefault()`, `Single()` and so on after calling `Select()` in Marten. It extends the projection queries with additional filtering or retrieval logic. The code uses a combination of linq `IQueryable.Select()` and other Linq methods.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/projections.md#_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:get_first_projection]>\n```\n\n----------------------------------------\n\nTITLE: Override Tenancy at Document Level in Marten\nDESCRIPTION: This snippet demonstrates how to override store-level tenancy configurations for specific document types. It sets the default tenancy to `TenancyStyle.Single` using `storeOptions.Policies.ForAllDocuments`, then overrides it to `TenancyStyle.Conjoined` for the `Target` document type using `storeOptions.Schema.For<Target>().MultiTenanted()`. \nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/multi-tenancy.md#_snippet_12\n\nLANGUAGE: cs\nCODE:\n```\nstoreOptions.Policies.ForAllDocuments(x => x.TenancyStyle = TenancyStyle.Single);\nstoreOptions.Schema.For<Target>().MultiTenanted();\n```\n\n----------------------------------------\n\nTITLE: Soft Delete Attribute Configuration - C#\nDESCRIPTION: This snippet demonstrates how to configure a document type for soft deletes by using the `SoftDeletedAttribute`. This attribute marks the class for soft deletion, meaning documents will be marked as deleted rather than physically removed from the database.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/advanced/soft_deletes.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, AllowMultiple = false)]\npublic class SoftDeletedAttribute : MartenAttribute\n{\n    public override void Modify(DocumentMapping mapping)\n    {\n        mapping.DeleteStyle = DeleteStyle.SoftDelete;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Database Role in Marten (C#)\nDESCRIPTION: This code snippet demonstrates how to configure a specific Postgresql role to be used when Marten generates DDL scripts. The `Role` property of the `Advanced.Migrator` configuration is set to the desired role name. This ensures that all DDL scripts generated or exported by Marten are wrapped with `SET ROLE` and `RESET ROLE` statements to execute under the specified role.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/schema/authorization.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n    _.Advanced.Migrator.Role = \"ROLE1\";\n});\n```\n\n----------------------------------------\n\nTITLE: Bulk Inserting Documents in Marten\nDESCRIPTION: This snippet demonstrates how to use `IDocumentStore.BulkInsert()` to efficiently insert a large number of documents using PostgreSQL's `COPY` functionality.  It generates random `Target` data, then uses `BulkInsert` to load the data into the database. It verifies that the data is present by querying the `Target` documents. It requires a configured `DocumentStore` and a `Target` class with a `GenerateRandomData` method.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/storing.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n// This is just creating some randomized\n// document data\nvar data = Target.GenerateRandomData(100).ToArray();\n\n// Load all of these into a Marten-ized database\ntheStore.BulkInsert(data, batchSize: 500);\n\n// And just checking that the data is actually there;)\ntheSession.Query<Target>().Count().ShouldBe(data.Length);\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Loading by Id with Marten (C#)\nDESCRIPTION: This snippet demonstrates asynchronous loading of documents by Id using Marten's `IQuerySession` interface. It showcases loading single documents identified by Guid, integer, and string, as well as loading multiple documents by passing Ids as arguments or an array of Ids to the `LoadManyAsync` method. A `CancellationToken` is used to enable cancellation of the asynchronous operation. The function returns a `Task`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/byid.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic async Task LoadByIdAsync(IQuerySession session, CancellationToken token = default (CancellationToken))\n{\n    var userId = Guid.NewGuid();\n\n    // Load a single document identified by a Guid\n    var user = await session.LoadAsync<User>(userId, token);\n\n    // There's an overload of Load for integers and longs\n    var doc = await session.LoadAsync<IntDoc>(15, token);\n\n    // Another overload for documents identified by strings\n    var doc2 = await session.LoadAsync<StringDoc>(\"Hank\", token);\n\n    // Load multiple documents by a group of ids\n    var users = await session.LoadManyAsync<User>(token, Guid.NewGuid(), Guid.NewGuid(), Guid.NewGuid());\n\n    var ids = new Guid[] { Guid.NewGuid(), Guid.NewGuid(), Guid.NewGuid() };\n\n    // If you already have an array of id values\n    var users2 = await session.LoadManyAsync<User>(token, ids);\n}\n```\n\n----------------------------------------\n\nTITLE: Bulk Inserting Documents Asynchronously in Marten\nDESCRIPTION: This snippet demonstrates how to use `IDocumentStore.BulkInsertAsync()` to efficiently and asynchronously insert a large number of documents.  Similar to the synchronous version, it generates random `Target` data, but uses the asynchronous method for insertion. It requires a configured `DocumentStore` and a `Target` class with a `GenerateRandomData` method.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/storing.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\n// This is just creating some randomized\n// document data\nvar data = Target.GenerateRandomData(100).ToArray();\n\n// Load all of these into a Marten-ized database\nawait theStore.BulkInsertAsync(data, batchSize: 500);\n\n// And just checking that the data is actually there;)\ntheSession.Query<Target>().Count().ShouldBe(data.Length);\n```\n\n----------------------------------------\n\nTITLE: Configuring Foreign Key to External Table\nDESCRIPTION: This C# code configures a Marten document store with a foreign key constraint from the `Issue` document to an external table named `bugs` in the `bugtracker` schema via the `BugId` property. This allows creating foreign key relationships to tables not managed by Marten.  It requires Marten, a database connection string, and the existence of the external table.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/indexing/foreign-keys.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore\n    .For(_ =>\n    {\n        _.Connection(\"some database connection\");\n\n        // Here we create a foreign key to table that is not\n        // created or managed by marten\n        _.Schema.For<Issue>().ForeignKey(i => i.BugId, \"bugtracker\", \"bugs\", \"id\");\n    });\n```\n\n----------------------------------------\n\nTITLE: Rewinding Marten Subscriptions (C#)\nDESCRIPTION: This snippet shows how to rewind and restart a Marten subscription using the `IProjectionCoordinator` service. It demonstrates rewinding to sequence 0, a specific sequence number (2000), and to a timestamp. It depends on the existence of a named subscription (e.g., \"Kafka\") and a running Marten async daemon.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/subscriptions.md#_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\n// IProjectionCoordinator is a service from Marten that's added to your IoC\n// container and gives you access to the running async daemon instance in\n// your process\npublic static async Task rewinding_subscription(IProjectionCoordinator coordinator)\n{\n    var daemon = coordinator.DaemonForMainDatabase();\n\n    // Rewind and restart the named subscription at sequence 0\n    await daemon.RewindSubscriptionAsync(\"Kafka\",  CancellationToken.None);\n\n    // Rewind and restart the named subscription at sequence 2000\n    await daemon.RewindSubscriptionAsync(\"Kafka\",  CancellationToken.None, sequenceFloor:2000);\n\n    // Rewind and restart the named subscription for the events after a certain time\n    await daemon.RewindSubscriptionAsync(\"Kafka\",  CancellationToken.None, timestamp:DateTimeOffset.UtcNow.Subtract(1.Days()));\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Auto Create Schema Objects in Marten (C#)\nDESCRIPTION: This code snippet shows how to configure the `AutoCreateSchemaObjects` property within `StoreOptions` to control Marten's automatic schema creation and update behavior. This setting determines whether Marten creates, updates, or does nothing with the Postgresql schema objects based on the document store configuration. The available options are All, None, CreateOnly, and CreateOrUpdate.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/schema/index.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nstoreOptions.AutoCreateSchemaObjects = AutoCreate.CreateOrUpdate;\n\n```\n\n----------------------------------------\n\nTITLE: Appending Events to an Existing Stream (C#)\nDESCRIPTION: This snippet demonstrates how to append events to an existing stream in Marten. It retrieves a stream by its ID and then uses `session.Events.Append()` to add new events (`MembersJoined` and `MembersDeparted`). The changes are persisted using `session.SaveChangesAsync()`. If the stream doesn't exist, it will create a new one.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/appending.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nvar joined = new MembersJoined { Members = new[] { \"Rand\", \"Matt\", \"Perrin\", \"Thom\" } };\nvar departed = new MembersDeparted { Members = new[] { \"Thom\" } };\n\nsession.Events.Append(id, joined, departed);\n\nawait session.SaveChangesAsync();\n```\n\n----------------------------------------\n\nTITLE: Adding Marten with Lightweight Sessions (C#)\nDESCRIPTION: This code demonstrates how to configure Marten to use lightweight sessions instead of the default sessions with an identity map. It utilizes the `UseLightweightSessions()` extension method chained after adding Marten to the `IServiceCollection`. Requires `Configuration` to retrieve connection string.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/hostbuilder.md#_snippet_15\n\nLANGUAGE: cs\nCODE:\n```\nvar connectionString = Configuration.GetConnectionString(\"postgres\");\n\nservices.AddMarten(opts =>\n    {\n        opts.Connection(connectionString);\n    })\n\n    // Chained helper to replace the built in\n    // session factory behavior\n    .UseLightweightSessions();\n```\n\n----------------------------------------\n\nTITLE: Implementing a Transformation with ITransform in C#\nDESCRIPTION: This sample demonstrates how to implement the `ITransform` interface to project from one event type to one document type. It showcases the basic structure and implementation required for creating a simple transformation in Marten.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/events/projections/index.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic interface ITransform<TEvent, TView>\n{\n    TView Create(TEvent input);\n}\n\n// SAMPLE: ITransform\npublic record MonsterSlayed(string Name, string Slayer);\n\npublic record MonsterDefeated(string Name, string Slayer, DateTime Time);\n\npublic class MonsterDefeatedTransform : ITransform<MonsterSlayed, MonsterDefeated>\n{\n    public MonsterDefeated Create(MonsterSlayed input)\n    {\n        return new MonsterDefeated(input.Name, input.Slayer, DateTime.UtcNow);\n    }\n}\n// ENDSAMPLE\n```\n\n----------------------------------------\n\nTITLE: Using Vogen for Invoice Identifier in C#\nDESCRIPTION: This snippet shows how to define an `InvoiceId` using the Vogen library, which wraps a `Guid`.  The `[ValueObject<Guid>]` attribute is used to generate the value object.  The `Invoice` class then uses this `InvoiceId` as its identifier.  Marten will use the `Id` property for document identification.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/identity.md#_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\n[ValueObject<Guid>]\npublic partial struct InvoiceId;\n\npublic class Invoice\n{\n    // Marten will use this for the identifier\n    // of the Invoice document\n    public InvoiceId? Id { get; set; }\n    public string Name { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Full Text Index for Multiple Properties (C#)\nDESCRIPTION: This code snippet demonstrates how to create a full-text index for multiple properties (`FirstName`, `LastName`) of the `User` document in Marten using the fluent interface of `StoreOptions`. It indexes the specified properties. The index is created with the default 'english' language configuration if not specified.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/full-text.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n    _.Connection(ConnectionSource.ConnectionString);\n\n    // This creates\n    _.Schema.For<User>().FullTextIndex(d => d.FirstName, d => d.LastName);\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Repository for Event Stream Persistence in C#\nDESCRIPTION: This snippet implements a repository to persist the deltas of an object to an event stream, indexed by the object's ID.  It pushes changes to the database and enables replaying the object's state from persisted data using Marten.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/scenarios/aggregates_events_repositories.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:scenario-aggregate-repository]>\n```\n\n----------------------------------------\n\nTITLE: Patching with Where Clause in Marten\nDESCRIPTION: This code snippet shows how to use the `Patch` API with a `Where` clause to update documents that match a specific criteria. It updates all `Target` documents where the `Color` property is `Blue` and sets the `Number` property to 2.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/partial-updates-patching.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n// Change every Target document where the Color is Blue\ntheSession.Patch<Target>(x => x.Color == Colors.Blue).Set(x => x.Number, 2);\n```\n\n----------------------------------------\n\nTITLE: Configuring Marten with Static Multi-Tenant Databases (C#)\nDESCRIPTION: This code snippet demonstrates how to configure Marten to use a separate database for each tenant using a static mapping of tenant IDs to database connection strings. It uses the `MultiTenantedDatabases()` method to specify the database connection strings for different tenants, and also registers document types and applies all database changes on startup. This requires prior creation of tenant databases.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/multitenancy.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n_host = await Host.CreateDefaultBuilder()\n    .ConfigureServices(services =>\n    {\n        services.AddMarten(opts =>\n            {\n                // Explicitly map tenant ids to database connection strings\n                opts.MultiTenantedDatabases(x =>\n                {\n                    // Map multiple tenant ids to a single named database\n                    x.AddMultipleTenantDatabase(db1ConnectionString, \"database1\")\n                        .ForTenants(\"tenant1\", \"tenant2\");\n\n                    // Map a single tenant id to a database, which uses the tenant id as well for the database identifier\n                    x.AddSingleTenantDatabase(tenant3ConnectionString, \"tenant3\");\n                    x.AddSingleTenantDatabase(tenant4ConnectionString, \"tenant4\");\n                });\n\n                opts.RegisterDocumentType<User>();\n                opts.RegisterDocumentType<Target>();\n            })\n\n            // All detected changes will be applied to all\n            // the configured tenant databases on startup\n            .ApplyAllDatabaseChangesOnStartup();\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Update with Stale Version - C#\nDESCRIPTION: This C# code snippet demonstrates the failure case when attempting to update a document with a stale version while optimistic concurrency is enabled. An `AggregateException` containing `ConcurrencyException` exceptions will be thrown when `SaveChanges()` or `SaveChangesAsync()` are called.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/advanced/optimistic_concurrency.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:update_with_stale_version_standard]>\n```\n\n----------------------------------------\n\nTITLE: Adding a Schema Feature to Marten (C#)\nDESCRIPTION: This snippet shows how to add a custom schema feature to a Marten `DocumentStore` using the `Storage.Add<T>()` method or by passing an instance of the feature to the `Storage.Add()` method. This enables Marten to manage the schema objects defined in the custom feature.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/schema/extensions.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n    // Creates a new instance of FakeStorage and\n    // passes along the current StoreOptions\n    _.Storage.Add<FakeStorage>();\n\n    // or\n\n    _.Storage.Add(new FakeStorage(_));\n});\n```\n\n----------------------------------------\n\nTITLE: Using Event<T> Metadata in Aggregations in C#\nDESCRIPTION: This code demonstrates how to access event metadata using `Event<T>` within `Apply` methods in an aggregate class. This allows you to access properties like `Timestamp` or `Version` of the event when updating the aggregate.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/events/projections/index.md#_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\n// SAMPLE: QuestPartyWithEvents\nusing Marten.Events; // Don't forget this import!\n\npublic class QuestPartyWithEvents\n{\n    public Guid Id { get; set; }\n\n    public string Name { get; set; }\n\n    public DateTime Started { get; set; }\n\n    public string[] Members { get; set; }\n\n    public void Apply(Event<QuestStarted> started)\n    {\n        Id = started.Data.QuestId;\n        Name = started.Data.Name;\n        Started = started.Data.Started;\n\n        // You can access the event metadata\n        // within the Apply() method\n        Console.WriteLine(started.Timestamp);\n    }\n\n    public void Apply(Event<MembersJoined> joined)\n    {\n        Members = joined.Data.Members;\n    }\n}\n// ENDSAMPLE\n```\n\n----------------------------------------\n\nTITLE: Include Document Using Custom Mapping with Marten in C#\nDESCRIPTION: This code snippet demonstrates how to include related documents using a custom mapping instead of the default `Id` property. It fetches a `SchoolUser` and includes the related `Classroom` based on matching `HomeRoom` and `RoomCode` properties. The `On()` method takes two expressions, one for the property on the main document and another for the property on the included document.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/include.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic async Task include_using_custom_map()\n{\n    var classroom = new Classroom(Id: Guid.NewGuid(), RoomCode: \"Classroom-1A\");\n    var user = new SchoolUser(Id: Guid.NewGuid(), Name: \"Student #1\", HomeRoom: \"Classroom-1A\");\n\n    using var session = theStore.IdentitySession();\n    session.Store<object>(classroom, user);\n    await session.SaveChangesAsync();\n\n    using var query = theStore.QuerySession();\n    Classroom? included = null;\n\n    var user2 = query\n        .Query<SchoolUser>()\n        .Include<Classroom>(c => included = c).On(u => u.HomeRoom, c => c.RoomCode)\n        .Single(u => u.Name == \"Student #1\");\n\n    included.ShouldNotBeNull();\n    included.Id.ShouldBe(classroom.Id);\n    user2.ShouldNotBeNull();\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Document Tracking in Event Projection Registration (C#)\nDESCRIPTION: Demonstrates how to enable document tracking by identity within an asynchronous event projection. This is achieved by setting the `EnableDocumentTrackingByIdentity` property to true within the async options when registering the projection with the DocumentStore. This feature is useful when you need to reuse or modify the same document within the same batch of events.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/event-projections.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(opts =>\n{\n    opts.Connection(\"some connection string\");\n\n    opts.Projections.Add(\n        new TrackedEventProjection(),\n        // Register projection to run it asynchronously\n        ProjectionLifecycle.Async,\n        // enable document tracking using identity map\n        asyncOptions => asyncOptions.EnableDocumentTrackingByIdentity = true\n    );\n});\n```\n\n----------------------------------------\n\nTITLE: Saving a Single User Document in Marten (C#)\nDESCRIPTION: This snippet demonstrates saving a `User` document to the Marten database using a lightweight session. It initializes a session, creates a new `User` object, stores it in the session, and then saves the changes to the database. This assumes that the `User` class is defined and that the Marten document store has been properly configured. This showcases basic CRUD operation using Marten.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/prebuilding.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nawait using var session = store.LightweightSession();\nvar user = new User { UserName = \"admin\" };\nsession.Store(user);\nawait session.SaveChangesAsync();\n```\n\n----------------------------------------\n\nTITLE: Defining Document with Value Types in Marten\nDESCRIPTION: This code snippet defines a document `LimitedDoc` with properties that are value types (`UpperLimit` and `LowerLimit`).  The `[ValueObject<int>]` attribute indicates that these structs are value objects wrapping an integer. This is necessary for Marten to correctly handle these types in LINQ queries. The document includes a Guid Id property.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/identity.md#_snippet_21\n\nLANGUAGE: cs\nCODE:\n```\n[ValueObject<int>]\npublic partial struct UpperLimit;\n\n[ValueObject<int>]\npublic partial struct LowerLimit;\n\npublic class LimitedDoc\n{\n    public Guid Id { get; set; }\n    public UpperLimit Upper { get; set; }\n    public LowerLimit Lower { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Marten Documents Using TenantIsOneOf (C#)\nDESCRIPTION: This code snippet demonstrates how to query Marten documents across a selected list of tenants using the TenantIsOneOf() extension method. It filters Target documents based on whether their tenant ID is either \"Green\" or \"Red\", and if their Flag property is true. This allows retrieving data from multiple specific tenants in a single query.  This snippet also uses OrderBy() and Select() LINQ methods.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/multi-tenancy.md#_snippet_6\n\nLANGUAGE: cs\nCODE:\n```\n// query data for a selected list of tenants\nvar actual = await query.Query<Target>().Where(x => x.TenantIsOneOf(\"Green\", \"Red\") && x.Flag)\n    .OrderBy(x => x.Id).Select(x => x.Id).ToListAsync();\n```\n\n----------------------------------------\n\nTITLE: Defining Computed Unique Index with Store Options (Multiple Properties) - C#\nDESCRIPTION: This code snippet demonstrates how to define a unique computed index on multiple properties using the `StoreOptions` fluent interface in Marten. This enforces uniqueness across a combination of properties. The absence of the `IndexType` parameter defaults to a computed index.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/unique.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:using_a_multiple_properties_computed_unique_index_through_store_options]>\n```\n\n----------------------------------------\n\nTITLE: Configure Command Timeout\nDESCRIPTION: This code snippet demonstrates how to configure a custom command timeout for a Marten session. This allows overriding the default timeout specified in the Npgsql connection string. The sample name is ConfigureCommandTimeout.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/command-timeouts.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:ConfigureCommandTimeout]>\n```\n\n----------------------------------------\n\nTITLE: Defining Kafka Subscription with SubscriptionBase (C#)\nDESCRIPTION: This snippet demonstrates how to define a Marten subscription using the `SubscriptionBase` class. It configures the subscription name, includes event types, sets batching options, and overrides the `ProcessEventsAsync` method to process events and publish them to a Kafka topic.  It depends on KafkaProducerConfig.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/subscriptions.md#_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\npublic class KafkaSubscription: SubscriptionBase\n{\n    private readonly KafkaProducerConfig _config;\n\n    public KafkaSubscription(KafkaProducerConfig config)\n    {\n        _config = config;\n\n        SubscriptionName = \"Kafka\";\n\n        // Access to any or all filtering rules\n        IncludeType<InvoiceApproved>();\n\n        // Fine grained control over how the subscription runs\n        // in the async daemon\n        Options.BatchSize = 1000;\n        Options.MaximumHopperSize = 10000;\n\n        // Effectively run as a hot observable\n        Options.SubscribeFromPresent();\n    }\n\n    // The daemon will \"push\" a page of events at a time to this subscription\n    public override async Task<IChangeListener> ProcessEventsAsync(\n        EventRange page,\n        ISubscriptionController controller,\n        IDocumentOperations operations,\n        CancellationToken cancellationToken)\n    {\n        using var kafkaProducer =\n            new ProducerBuilder<string, string>(_config.ProducerConfig).Build();\n\n        foreach (var @event in page.Events)\n        {\n            await kafkaProducer.ProduceAsync(_config.Topic,\n                new Message<string, string>\n                {\n                    // store event type name in message Key\n                    Key = @event.Data.GetType().Name,\n                    // serialize event to message Value\n                    Value = JsonConvert.SerializeObject(@event.Data)\n                }, cancellationToken);\n\n        }\n\n        // We don't need any kind of callback, so the nullo is fine\n        return NullChangeListener.Instance;\n    }\n\n}\n\n// Just assume this is registered in your IoC container\npublic class KafkaProducerConfig\n{\n    public ProducerConfig? ProducerConfig { get; set; }\n    public string? Topic { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Event Store for Projection\nDESCRIPTION: Configures the Event Store to use the newly introduced `CandleProjection`. This ensures that the projection is active and processes events of the specified type.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/events/projections/projectionbyeventtype.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:sample-project-by-event-type]>\n```\n\n----------------------------------------\n\nTITLE: Configuring Specific Sequential Guid\nDESCRIPTION: This code shows how to configure the document store to use a sequential (Comb) Guid generation strategy for a specific document type. It configures the `IdStrategy` for `UserWithGuid` to use `CombGuidIdGeneration`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/identity.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\noptions.Schema.For<UserWithGuid>().IdStrategy(new CombGuidIdGeneration());\n```\n\n----------------------------------------\n\nTITLE: Configuring Marten with Single Instance Multi-Tenancy (C#)\nDESCRIPTION: This code snippet shows how to configure Marten to use a separate named database in the same database instance for each tenant. It uses `MultiTenantedWithSingleServer()` and allows Marten to dynamically provision new tenant databases when a new tenant ID is encountered, assuming the application has the necessary permissions. Connection string for administration with rights to provision new databases is required.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/multitenancy.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n_host = await Host.CreateDefaultBuilder()\n    .ConfigureServices(services =>\n    {\n        services.AddMarten(opts =>\n        {\n            opts\n                // You have to specify a connection string for \"administration\"\n                // with rights to provision new databases on the fly\n                .MultiTenantedWithSingleServer(\n                    ConnectionSource.ConnectionString,\n                    t => t\n                        // You can map multiple tenant ids to a single named database\n                        .WithTenants(\"tenant1\", \"tenant2\").InDatabaseNamed(\"database1\")\n\n                        // Just declaring that there are additional tenant ids that should\n                        // have their own database\n                        .WithTenants(\"tenant3\", \"tenant4\") // own database\n                );\n\n            opts.RegisterDocumentType<User>();\n            opts.RegisterDocumentType<Target>();\n        }).ApplyAllDatabaseChangesOnStartup();\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Rollup Projection by Tenant Id in Marten (C#)\nDESCRIPTION: This C# code snippet demonstrates how to create a rollup projection by tenant ID using Marten's `MultiStreamProjection`. It groups events by tenant and aggregates them into a `Rollup` document. The `RollUpByTenant()` method configures the projection to use the event's tenant ID as the identity of the projected document. It also showcases the `Apply` methods, which update the rollup state based on events `AEvent` and `BEvent`. The `Rollup` class defines the structure of the projected document, including the `TenantId` as the identity and counters for different event types.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/multi-stream-projections.md#_snippet_9\n\nLANGUAGE: cs\nCODE:\n```\npublic class RollupProjection: MultiStreamProjection<Rollup, string>\n{\n    public RollupProjection()\n    {\n        // This opts into doing the event slicing by tenant id\n        RollUpByTenant();\n    }\n\n    public void Apply(Rollup state, AEvent e) => state.ACount++;\n    public void Apply(Rollup state, BEvent e) => state.BCount++;\n}\n\npublic class Rollup\n{\n    [Identity]\n    public string TenantId { get; set; }\n    public int ACount { get; set; }\n    public int BCount { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Soft Deleted Since - C#\nDESCRIPTION: This snippet demonstrates how to query for documents deleted before or after a specific `DateTimeOffset` using `DeletedBefore()` and `DeletedSince()`. These methods allow filtering documents based on their deletion timestamp.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/advanced/soft_deletes.md#_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nvar since = now.AddDays(-1);\n\nawait session.Query<User>().Where(x => x.DeletedSince(since)).ToListAsync();\nawait session.Query<User>().Where(x => x.DeletedBefore(since)).ToListAsync();\n```\n\n----------------------------------------\n\nTITLE: Simple SelectMany against Simple Array (C#)\nDESCRIPTION: Marten 1.2 adds the ability to use the `SelectMany()` operator to issue queries against child collections. You can use `SelectMany()` against primitive collections like so:\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/linq.md#_snippet_22\n\nLANGUAGE: C#\nCODE:\n```\npublic class Target\n{\n    public Guid Id { get; set; }\n    public string[] Tags { get; set; }\n    public List<string> ListTags {get; set;}\n    public List<int> Numbers { get; set; }\n\n}\n\nvar targets = session.Query<Target>().SelectMany(x => x.Tags).Where(x => x == \"foo\").ToList();\n```\n\n----------------------------------------\n\nTITLE: Include Documents into Dictionary List with Marten in C#\nDESCRIPTION: This code snippet showcases how to include a one-to-many relationship into a dictionary of lists when querying with Marten. It fetches `Classroom` documents and includes related `SchoolUser` documents, storing them in a `Dictionary<string, IList<SchoolUser>>` where the key is the `RoomCode` and the value is a list of users in that classroom. The `On()` method uses custom mapping based on `RoomCode` and `HomeRoom`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/include.md#_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic async Task include_to_dictionary_list()\n{\n    var class1 = new Classroom(Id: Guid.NewGuid(), RoomCode: \"Classroom-1A\");\n    var class2 = new Classroom(Id: Guid.NewGuid(), RoomCode: \"Classroom-2B\");\n\n    var user1 = new SchoolUser(Id: Guid.NewGuid(), Name: \"Student #1\", HomeRoom: \"Classroom-1A\");\n    var user2 = new SchoolUser(Id: Guid.NewGuid(), Name: \"Student #2\", HomeRoom: \"Classroom-2B\");\n    var user3 = new SchoolUser(Id: Guid.NewGuid(), Name: \"Student #3\", HomeRoom: \"Classroom-2B\");\n\n    using var session = theStore.IdentitySession();\n    session.Store(class1, class2);\n    session.Store(user1, user2, user3);\n    await session.SaveChangesAsync();\n\n    using var query = theStore.QuerySession();\n    var dict = new Dictionary<string, IList<SchoolUser>>();\n\n    var classes = query\n        .Query<Classroom>()\n        .Include(dict).On(c => c.RoomCode, u => u.HomeRoom)\n        .ToArray();\n\n    classes.Length.ShouldBe(2);\n    dict.Count.ShouldBe(2);\n    dict.ContainsKey(class1.RoomCode).ShouldBeTrue();\n    dict.ContainsKey(class2.RoomCode).ShouldBeTrue();\n    dict[class1.RoomCode].Count.ShouldBe(1);\n    dict[class2.RoomCode].Count.ShouldBe(2);\n}\n```\n\n----------------------------------------\n\nTITLE: Indexing Last Modified via Fluent Interface in Marten (C#)\nDESCRIPTION: This code snippet shows how to create an index on the `mt_last_modified` metadata column using the fluent interface. This is an alternative to using the `IndexedLastModifiedAttribute`. It's particularly useful when configuring document mapping programmatically. This optimizes `ModifiedSince(DateTimeOffset)` or `ModifiedBefore(DateTimeOffset)` queries.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/metadata_index.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:index-last-modified-via-fi]>\n```\n\n----------------------------------------\n\nTITLE: Configuring Code Generation Modes in Marten (C#)\nDESCRIPTION: This snippet demonstrates the different code generation modes available in Marten: Dynamic, Static, and Auto. The Dynamic mode generates code at runtime. The Static mode only uses types compiled into the application assembly. The Auto mode automatically generates code at runtime if the required types are not found in the application assembly, and persists the generated code for future use.  It shows how to set the `GeneratedCodeMode` property within the `DocumentStore.For` configuration.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/prebuilding.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nusing var store = DocumentStore.For(opts =>\n{\n    opts.Connection(\"some connection string\");\n\n    // This is the default. Marten will always generate\n    // code dynamically at runtime\n    opts.GeneratedCodeMode = TypeLoadMode.Dynamic;\n\n    // Marten will only use types that are compiled into\n    // the application assembly ahead of time. This is the\n    // \"pre-built\" model\n    opts.GeneratedCodeMode = TypeLoadMode.Static;\n\n    // Explained Below :)\n    opts.GeneratedCodeMode = TypeLoadMode.Auto;\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Flat Table Projection with FlatTableProjection (C#)\nDESCRIPTION: Creates a Marten FlatTableProjection to project events into a flat table using a more declarative approach.  The `FlatImportProjection` class inherits from `FlatTableProjection` and configures the table schema, column mappings, and data transformations. The `Project<T>(lambda)` methods define how to map event properties to table columns and set default values. This approach leverages Marten's code generation for upsert commands.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/flat.md#_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\npublic class FlatImportProjection: FlatTableProjection\n{\n    // I'm telling Marten to use the same database schema as the events from\n    // the Marten configuration in this application\n    public FlatImportProjection() : base(\"import_history\", SchemaNameSource.EventSchema)\n    {\n        // We need to explicitly add a primary key\n        Table.AddColumn<Guid>(\"id\").AsPrimaryKey();\n\n        TeardownDataOnRebuild = true;\n\n        Project<ImportStarted>(map =>\n        {\n            // Set values in the table from the event\n            map.Map(x => x.ActivityType);\n            map.Map(x => x.CustomerId);\n            map.Map(x => x.PlannedSteps, \"total_steps\")\n                .DefaultValue(0);\n\n            map.Map(x => x.Started);\n\n            // Initial values\n            map.SetValue(\"status\", \"started\");\n            map.SetValue(\"step_number\", 0);\n            map.SetValue(\"records\", 0);\n        });\n\n        Project<ImportProgress>(map =>\n        {\n            // Add 1 to this column when this event is encountered\n            map.Increment(\"step_number\");\n\n            // Update a running sum of records progressed\n            // by the number of records on this event\n            map.Increment(x => x.Records);\n\n            map.SetValue(\"status\", \"working\");\n        });\n\n        Project<ImportFinished>(map =>\n        {\n            map.Map(x => x.Finished);\n            map.SetValue(\"status\", \"completed\");\n        });\n\n        // Just gonna delete the record of any failures\n        Delete<ImportFailed>();\n\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Querying with Count() or Length in Marten (C#)\nDESCRIPTION: Shows how to query against the `Count()` or `Length` of a child collection using comparison operators in Marten. The example creates documents with lists of integers and queries for documents where the list count matches a specific number.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/child-collections.md#_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n[Fact]\npublic async Task query_against_number_list_with_count_method()\n{\n    var doc1 = new DocWithLists { Numbers = new List<int> { 1, 2, 3 } };\n    var doc2 = new DocWithLists { Numbers = new List<int> { 3, 4, 5 } };\n    var doc3 = new DocWithLists { Numbers = new List<int> { 5, 6, 7, 8 } };\n\n    theSession.Store(doc1);\n    theSession.Store(doc2);\n    theSession.Store(doc3);\n\n    await theSession.SaveChangesAsync();\n\n    theSession.Logger = new TestOutputMartenLogger(_output);\n\n    theSession.Query<DocWithLists>()\n        .Single(x => x.Numbers.Count() == 4).Id.ShouldBe(doc3.Id);\n}\n```\n\n----------------------------------------\n\nTITLE: FindJsonOrderedUsersByUsername Compiled Query C#\nDESCRIPTION: This code demonstrates a compiled query that retrieves a JSON array of users ordered by username. It demonstrates combining ordering, filtering, and JSON serialization. The `QueryIs` method defines the Linq query used to filter, order, and then serialize to JSON.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/compiled_queries.md#_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\npublic class FindJsonOrderedUsersByUsername : ICompiledQuery<User, string>\n{\n    public string StartsWith { get; set; }\n\n    public Expression<Func<IQueryable<User>, string>> QueryIs()\n    {\n        return query => query.Where(x => x.UserName.StartsWith(StartsWith)).OrderBy(x => x.UserName).ToJsonArray();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing IInitialData for Marten\nDESCRIPTION: This code snippet demonstrates how to implement the `IInitialData` interface to seed a Marten database with initial data. It defines an `InitialData` class that takes an array of objects and stores them in the Marten document store within the `Populate` method using a lightweight session and UPSERT logic. Dependencies include Marten's `IDocumentStore` and `IInitialData`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/initial-data.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic class InitialData: IInitialData\n{\n    private readonly object[] _initialData;\n\n    public InitialData(params object[] initialData)\n    {\n        _initialData = initialData;\n    }\n\n    public async Task Populate(IDocumentStore store, CancellationToken cancellation)\n    {\n        await using var session = store.LightweightSession();\n        // Marten UPSERT will cater for existing records\n        session.Store(_initialData);\n        await session.SaveChangesAsync();\n    }\n}\n\npublic static class InitialDatasets\n{\n    public static readonly Company[] Companies =\n    {\n        new Company { Id = Guid.Parse(\"2219b6f7-7883-4629-95d5-1a8a6c74b244\"), Name = \"Netram Ltd.\" },\n        new Company { Id = Guid.Parse(\"642a3e95-5875-498e-8ca0-93639ddfebcd\"), Name = \"Acme Inc.\" }\n    };\n\n    public static readonly User[] Users =\n    {\n        new User { Id = Guid.Parse(\"331c15b4-b7bd-44d6-a804-b6879f99a65f\"),FirstName = \"Danger\" , LastName = \"Mouse\" },\n        new User { Id = Guid.Parse(\"9d8ef25a-de9a-41e5-b72b-13f24b735883\"), FirstName = \"Speedy\" , LastName = \"Gonzales\" }\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled Query with Include for Single Document\nDESCRIPTION: This snippet demonstrates how to use compiled queries with the `Include()` method to fetch related documents. The `IssueByTitleWithAssignee` class implements `ICompiledQuery<Issue>` and includes a `User` document (the assignee) based on the `AssigneeId` property of the `Issue` document.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/compiled-queries.md#_snippet_9\n\nLANGUAGE: cs\nCODE:\n```\n[Fact]\npublic async Task simple_compiled_include_for_a_single_document()\n{\n    var user = new User();\n    var issue = new Issue { AssigneeId = user.Id, Title = \"Garage Door is busted\" };\n\n    using var session = theStore.IdentitySession();\n    session.Store<object>(user, issue);\n    await session.SaveChangesAsync();\n\n    using var query = theStore.QuerySession();\n    var issueQuery = new IssueByTitleWithAssignee { Title = issue.Title };\n    var issue2 = query.Query(issueQuery);\n\n    issueQuery.Included.ShouldNotBeNull();\n    issueQuery.Included.Single().Id.ShouldBe(user.Id);\n\n    issue2.ShouldNotBeNull();\n}\n\npublic class IssueByTitleWithAssignee: ICompiledQuery<Issue>\n{\n    public string Title { get; set; }\n    public IList<User> Included { get; private set; } = new List<User>();\n\n    public Expression<Func<IMartenQueryable<Issue>, Issue>> QueryIs()\n    {\n        return query => query\n            .Include(x => x.AssigneeId, Included)\n            .Single(x => x.Title == Title);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Indexing Last Modified Property via Attribute in Marten (C#)\nDESCRIPTION: This code snippet demonstrates how to create an index on the document's `mt_last_modified` metadata column using the `IndexedLastModifiedAttribute`. This is beneficial when using the `ModifiedSince(DateTimeOffset)` or `ModifiedBefore(DateTimeOffset)` query methods. The attribute is applied directly to the document class.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/indexing/metadata-indexes.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[IndexedLastModified]\npublic class Customer\n{\n    public Guid Id { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Mapping Old Event Type Name to New Class C#\nDESCRIPTION: This code snippet demonstrates how to configure Marten to map the old event type name (`order_status_changed`) to the new `ConfirmedOrderStatusChanged` event class in the `NewEventNamespace`. It uses the `Events.MapEventType` method to explicitly define the mapping between the old event type name and the new CLR type, ensuring seamless migration when the event class name has changed.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/versioning.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nvar options = new StoreOptions();\n\noptions.Events\n    .MapEventType<NewEventNamespace.ConfirmedOrderStatusChanged>(\"order_status_changed\");\n\nvar store = new DocumentStore(options);\n```\n\n----------------------------------------\n\nTITLE: Capturing Timestamp from Event Metadata in Invoice (C#)\nDESCRIPTION: This code snippet demonstrates how to capture the timestamp from the Marten event metadata within an `Invoice` document. The timestamp is extracted from the `IEvent<InvoiceCreated>` object's `Timestamp` property and assigned to the `Created` property of the `Invoice` object. This allows for tracking when the invoice was created based on the event timestamp.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/testing.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic static Invoice Create(IEvent<InvoiceCreated> created)\n{\n    return new Invoice\n    {\n        Amount = created.Data.Amount,\n        Description = created.Data.Description,\n\n        // Capture the timestamp from the event\n        // metadata captured by Marten\n        Created = created.Timestamp,\n        Status = InvoiceStatus.Created\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up AppFixture with Alba and Marten\nDESCRIPTION: Configures the `AppFixture` class to set up the Alba host and integrate with Marten. It bootstraps the application, configures services, and sets the Marten schema name. The `InitializeAsync` method starts the host, and the `DisposeAsync` method disposes of it. It depends on the `AlbaHost` and `MartenSettings`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/testing/integration.md#_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic class AppFixture: IAsyncLifetime\n{\n    private string SchemaName { get; } = \"sch\" + Guid.NewGuid().ToString().Replace(\"-\", string.Empty);\n    public IAlbaHost Host { get; private set; }\n\n    public async Task InitializeAsync()\n    {\n        // This is bootstrapping the actual application using\n        // its implied Program.Main() set up\n        Host = await AlbaHost.For<Program>(b =>\n        {\n            b.ConfigureServices((context, services) =>\n            {\n                services.Configure<MartenSettings>(s =>\n                {\n                    s.SchemaName = SchemaName;\n                });\n            });\n        });\n    }\n\n    public async Task DisposeAsync()\n        {\n            await Host.DisposeAsync();\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: Configuring Global Custom ID Generation C#\nDESCRIPTION: This code snippet shows how to configure a custom ID generation strategy globally for all document types within a Marten document store.  This is done when configuring the document store. It requires referencing the Marten library.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/identity/custom.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n    _.Connection(\"some connection string\");\n    _.Policies.IdGeneration(new MyCustomIdGeneration());\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Marten-Managed Tenant Partitioning in C#\nDESCRIPTION: This code snippet shows how to configure Marten to use managed tenant partitioning. It sets up connection, multi-tenancy policy, and partition management. This configuration is necessary for Marten to automatically create the appropriate table partitions for each known tenant ID.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/multi-tenancy.md#_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\nbuilder.Services.AddMarten(opts =>\n{\n    opts.Connection(builder.Configuration.GetConnectionString(\"marten\"));\n\n    // Make all document types use \"conjoined\" multi-tenancy -- unless explicitly marked with\n    // [SingleTenanted] or explicitly configured via the fluent interfce\n    // to be single-tenanted\n    opts.Policies.AllDocumentsAreMultiTenanted();\n\n    // It's required to explicitly tell Marten which database schema to put\n    // the mt_tenant_partitions table\n    opts.Policies.PartitionMultiTenantedDocumentsUsingMartenManagement(\"tenants\");\n});\n```\n\n----------------------------------------\n\nTITLE: IMethodCallParser Interface C#\nDESCRIPTION: This snippet showcases the `IMethodCallParser` interface, which is crucial for creating custom Linq parsers in Marten. Implementations of this interface are responsible for identifying specific method expressions and transforming them into corresponding Postgresql \"where\" clause fragments.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/advanced/customizing_linq.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n <[sample:IMethodCallParser]>\n```\n\n----------------------------------------\n\nTITLE: Adding Marten Async Daemon Health Check\nDESCRIPTION: This code snippet demonstrates how to add a Marten async daemon health check to an ASP.NET Core application using `AddHealthChecks` and `AddMartenAsyncDaemonHealthCheck`. It sets the `maxEventLag` parameter to 500, which defines the maximum allowable lag between a projection's progress and the HighWaterMark.  It also maps the health check endpoint to `/health`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/healthchecks.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// Add HealthCheck\nServices.AddHealthChecks().AddMartenAsyncDaemonHealthCheck(maxEventLag: 500);\n\n// Map HealthCheck Endpoint\napp.MapHealthChecks(\"/health\");\n```\n\n----------------------------------------\n\nTITLE: Implementing a Query Plan for Target Documents - C#\nDESCRIPTION: This code snippet demonstrates how to implement a simple query plan using `QueryListPlan<Target>` to retrieve a list of `Target` documents based on their color. It showcases the `Query` method, which defines the actual query logic using `IQuerySession` to filter and order the results. The example also includes a longer form implementation of the same query plan.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/compiled-queries.md#_snippet_19\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ColorTargets: QueryListPlan<Target>\n{\n    public Colors Color { get; }\n\n    public ColorTargets(Colors color)\n    {\n        Color = color;\n    }\n\n    // All we're doing here is just turning around and querying against the session\n    // All the same though, this approach lets you do much more runtime logic\n    // than a compiled query can\n    public override IQueryable<Target> Query(IQuerySession session)\n    {\n        return session.Query<Target>().Where(x => x.Color == Color).OrderBy(x => x.Number);\n    }\n}\n\n// The above is short hand for:\n\npublic class LonghandColorTargets: IQueryPlan<IReadOnlyList<Target>>, IBatchQueryPlan<IReadOnlyList<Target>>\n{\n    public Colors Color { get; }\n\n    public LonghandColorTargets(Colors color)\n    {\n        Color = color;\n    }\n\n    public Task<IReadOnlyList<Target>> Fetch(IQuerySession session, CancellationToken token)\n    {\n        return session\n            .Query<Target>()\n            .Where(x => x.Color == Color)\n            .OrderBy(x => x.Number)\n            .ToListAsync(token: token);\n    }\n\n    public Task<IReadOnlyList<Target>> Fetch(IBatchedQuery batch)\n    {\n        return batch\n            .Query<Target>()\n            .Where(x => x.Color == Color)\n            .OrderBy(x => x.Number)\n            .ToList();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Simple Calculated Index SQL (Postgresql)\nDESCRIPTION: Shows the SQL generated by Marten for creating a simple calculated index on the `UserName` property of the `User` document.  This SQL creates an index on the JSON data.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/indexing/computed-indexes.md#_snippet_1\n\nLANGUAGE: SQL\nCODE:\n```\nCREATE INDEX mt_doc_user_idx_user_name ON public.mt_doc_user ((data ->> 'UserName'));\n```\n\n----------------------------------------\n\nTITLE: Upcaster Class with CLR Types and Explicit Type Name\nDESCRIPTION: This snippet demonstrates how to upcast an event using a class that inherits from `EventUpcaster` and specifies an explicit event type name. It transforms a `ShoppingCartOpened` event into a `ShoppingCartOpenedWithStatus` event. An explicit event name is useful if the default event type name has changed.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/versioning.md#_snippet_19\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ShoppingCartOpenedUpcaster:\n    EventUpcaster<ShoppingCartOpened, ShoppingCartOpenedWithStatus>\n{\n    // Explicit event type name mapping may be useful if you used other than default event type name\n    // for old event type.\n    public override string EventTypeName => \"shopping_cart_opened\";\n\n    protected override ShoppingCartOpenedWithStatus Upcast(ShoppingCartOpened oldEvent) =>\n        new ShoppingCartOpenedWithStatus(\n            oldEvent.ShoppingCartId,\n            new Client(oldEvent.ClientId),\n            ShoppingCartStatus.Opened\n        );\n}\n```\n\n----------------------------------------\n\nTITLE: Soft Deleting all Document Types in Marten\nDESCRIPTION: This code snippet configures Marten to soft delete all document types by default using `opts.Policies.AllDocumentsSoftDeleted()`. It requires a connection string to the database.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/deletes.md#_snippet_15\n\nLANGUAGE: cs\nCODE:\n```\ninternal void AllDocumentTypesShouldBeSoftDeleted()\n{\n    using var store = DocumentStore.For(opts =>\n    {\n        opts.Connection(\"some connection string\");\n        opts.Policies.AllDocumentsSoftDeleted();\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: ToListAsync Usage in Marten\nDESCRIPTION: Demonstrates the use of `ToListAsync()` for asynchronous retrieval of data from Marten. This extension method operates on an `IQueryable` and returns a `Task<List<T>>`, allowing for non-blocking data fetching. It requires Marten to be properly configured.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/async.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:using-to-list-async]>\n```\n\n----------------------------------------\n\nTITLE: MultiStreamProjection: Simple Event to Single Cross-Stream Projection\nDESCRIPTION: This example demonstrates a simple MultiStreamProjection that aggregates events based on a user ID. It defines a UserGroupsAssignmentProjection that inherits from MultiStreamProjection<UserGroupsAssignment, Guid>.  The Identity<TEvent>(x => x.UserId) method is used to specify how events are grouped into aggregates based on the UserId property.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/multi-stream-projections.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic class UserGroupsAssignmentProjection: MultiStreamProjection<UserGroupsAssignment, Guid>\n{\n    public UserGroupsAssignmentProjection()\n    {\n        // This is just specifying the aggregate document id\n        // per event type. This assumes that each event\n        // applies to only one aggregated view document\n        Identity<UserRegistered>(x => x.UserId);\n        Identity<SingleUserAssignedToGroup>(x => x.UserId);\n    }\n\n    public void Apply(UserRegistered @event, UserGroupsAssignment view)\n        => view.Id = @event.UserId;\n\n    public void Apply(SingleUserAssignedToGroup @event, UserGroupsAssignment view)\n        => view.Groups.Add(@event.GroupId);\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Asynchronously with SQL in Marten (C#)\nDESCRIPTION: This code snippet shows how to asynchronously query for `User` documents in Marten using raw SQL and parameters. The `QueryAsync<User>()` method is used to execute the query, which returns a collection of `User` objects. It relies on an `IQuerySession` instance to interact with the Marten database. The code assumes that the `session` variable is of type `IQuerySession`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/sql.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nvar millers = await session\n    .QueryAsync<User>(\"where data ->> 'LastName' = ?\", \"Miller\");\n```\n\n----------------------------------------\n\nTITLE: Executing Wolverine Endpoints\nDESCRIPTION: Demonstrates how to execute Wolverine endpoints using the TrackedHttpCall helper method. It sends a JSON POST request to an HTTP endpoint and asserts the HTTP status code. It also verifies that an expected message was published as a result of the endpoint execution.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/testing/integration.md#_snippet_14\n\nLANGUAGE: cs\nCODE:\n```\nvar (tracked, _) = await TrackedHttpCall(x =>\n{\n    // Send a JSON post with the DebitAccount command through the HTTP endpoint\n    // BUT, it's all running in process\n    x.Post.Json(new WithdrawFromAccount(account.Id, 1300)).ToUrl(\"/accounts/debit\");\n\n    // This is the default behavior anyway, but still good to show it here\n    x.StatusCodeShouldBeOk();\n});\n\n// And also assert that an AccountUpdated message was published as well\nvar updated = tracked.Sent.SingleMessage<AccountUpdated>();\nupdated.AccountId.ShouldBe(account.Id);\nupdated.Balance.ShouldBe(1300);\n```\n\n----------------------------------------\n\nTITLE: Configuring Cascading Deletes\nDESCRIPTION: This C# code configures a Marten document store to enable cascading deletes on the foreign key constraint from the `Issue` document to the `User` document via the `AssigneeId` property. When a `User` document is deleted, any related `Issue` documents will also be deleted due to the `CascadeAction.Cascade` setting.  It requires Marten and a database connection string.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/indexing/foreign-keys.md#_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore\n    .For(_ =>\n    {\n        _.Connection(\"some database connection\");\n\n        _.Schema.For<Issue>().ForeignKey<User>(x => x.AssigneeId, fkd => fkd.OnDelete = CascadeAction.Cascade);\n    });\n```\n\n----------------------------------------\n\nTITLE: Querying and Casting JSONB Properties in Marten (C#)\nDESCRIPTION: This example demonstrates how to query single JSONB properties and cast them to a primitive/value type in Marten. It uses the `QueryAsync<DateTimeOffset>()` method to retrieve the `ModifiedAt` property from the `mt_doc_user` table and casts it to a `DateTimeOffset` type. It's crucial to cast the value to the correct Postgres type for proper data conversion. The code assumes that the `session` variable is of type `IQuerySession`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/sql.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nvar times = await session.QueryAsync<DateTimeOffset>(\n    \"SELECT (data ->> 'ModifiedAt')::timestamptz from mt_doc_user\");\n```\n\n----------------------------------------\n\nTITLE: Custom Session Factory by Scope - C#\nDESCRIPTION: This snippet demonstrates building a custom session factory that attaches a correlated Marten logger to sessions resolved from the IoC container, enabling request-specific logging. Leverages dependency injection to retrieve the correlation ID.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/integration.md#_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:CustomSessionFactoryByScope]>\n```\n\n----------------------------------------\n\nTITLE: Renaming Property using System.Text.Json\nDESCRIPTION: This snippet demonstrates renaming a property (`CartId` instead of `ShoppingCartId`) using the `JsonPropertyName` attribute from System.Text.Json. This enables compatibility with older events while utilizing the new property name in the codebase.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/versioning.md#_snippet_9\n\nLANGUAGE: cs\nCODE:\n```\npublic class ShoppingCartOpened\n{\n    [JsonPropertyName(\"ShoppingCartId\")]\n    public Guid CartId { get; }\n    public Guid ClientId { get; }\n\n    public ShoppingCartOpened(\n        Guid cartId,\n        Guid clientId\n    )\n    {\n        CartId = cartId;\n        ClientId = clientId;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Use Numeric Revisions Fluent Interface - Marten C#\nDESCRIPTION: This code snippet shows how to enable numeric document revisioning for a specific document type using the fluent interface. It configures the Marten schema options to use numeric revisions for the `Incident` document type. A connection string is also configured for the DocumentStore.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/concurrency.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nusing var store = DocumentStore.For(opts =>\n{\n    opts.Connection(\"some connection string\");\n\n    // Enable numeric document revisioning through the\n    // fluent interface\n    opts.Schema.For<Incident>().UseNumericRevisions(true);\n});\n```\n\n----------------------------------------\n\nTITLE: Aggregate Functions in Marten Linq using C#\nDESCRIPTION: Shows how to use aggregate functions such as `Count()`, `Min()`, `Max()`, `Sum()`, and `Average()` in Marten Linq queries.  Demonstrates both synchronous and asynchronous versions. It uses `IQuerySession` to query the `Target` document type and applies aggregate functions on the `Number` property.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/operators.md#_snippet_6\n\nLANGUAGE: cs\nCODE:\n```\npublic async Task sample_aggregation_operations(IQuerySession session)\n{\n    var count = session.Query<Target>().Count();\n    var count2 = await session.Query<Target>().CountAsync();\n    var count3 = session.Query<Target>().LongCount();\n    var count4 = await session.Query<Target>().LongCountAsync();\n\n    var min = await session.Query<Target>().MinAsync(x => x.Number);\n    var max = await session.Query<Target>().MaxAsync(x => x.Number);\n    var sum = await session.Query<Target>().SumAsync(x => x.Number);\n    var average = await session.Query<Target>().AverageAsync(x => x.Number);\n}\n```\n\n----------------------------------------\n\nTITLE: Including a Custom MartenRegistry - C#\nDESCRIPTION: This snippet demonstrates how to include a custom MartenRegistry during DocumentStore initialization. It shows how to apply configurations defined in the registry and explicitly define configurations using the Schema property. This allows for organized and reusable configuration management.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/storeoptions.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(opts =>\n{\n    opts.Schema.For<Organization>().Duplicate(x => x.Name);\n    opts.Schema.Include<OrganizationRegistry>();\n    opts.Connection(ConnectionSource.ConnectionString);\n});\n```\n\n----------------------------------------\n\nTITLE: Flat Table Projection for User-Project Mapping (C#)\nDESCRIPTION: This snippet showcases a `FlatTableProjection` used to store the mapping between `UserId` and `ProjectId` in a table named `user_project_mapping`. This enables resolution of the `ProjectId` dynamically when later events only contain the `UserId`. It creates a table with columns for `user_id` and `project_id`, and projects data from the `UserJoinedProject` event.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/multi-stream-projections.md#_snippet_6\n\nLANGUAGE: cs\nCODE:\n```\npublic class UserProjectFlatTableProjection : FlatTableProjection\n{\n    public UserProjectFlatTableProjection() : base(\"user_project_mapping\", SchemaNameSource.EventSchema)\n    {\n        Table.AddColumn<Guid>(\"user_id\").AsPrimaryKey();\n        Table.AddColumn<Guid>(\"project_id\").NotNull();\n\n        TeardownDataOnRebuild = true;\n\n        Project<UserJoinedProject>(map =>\n        {\n            map.Map(x => x.UserId);\n            map.Map(x => x.ProjectId);\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Resetting Marten Data using IDocumentStore\nDESCRIPTION: Demonstrates resetting all Marten data using IDocumentStore.Advanced.ResetAllData().  This deletes all current document, event data, and then reapplies the configured initial data.  Requires adding initial data to IDocumentStore.Advanced.InitialDataCollection.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/schema/cleaning.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\ntheStore.Advanced.InitialDataCollection.Add(new Users());\n\nawait theStore.Advanced.ResetAllData();\n```\n\n----------------------------------------\n\nTITLE: Using DDL Templates in Marten (C#)\nDESCRIPTION: This code snippet shows how to configure Marten to read and apply DDL templates from a specified directory. The `ReadTemplatesAsync` method of the `Advanced.Migrator` configuration is used to load the template files.  The template files can be used to add custom GRANTs or other permissions to the database objects generated by Marten. This method only performs a shallow search, meaning it doesn't look into child directories for template files.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/schema/authorization.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n    // let's say that you have template files in a\n    // \"templates\" directory under the root of your\n    // application\n    _.Advanced.Migrator.ReadTemplatesAsync(\"templates\");\n\n});\n```\n\n----------------------------------------\n\nTITLE: Create Full Text Index for Whole Document via StoreOptions (C#)\nDESCRIPTION: This code snippet demonstrates how to create a full text index for the entire document using the StoreOptions fluent interface in Marten. All document properties values will be indexed. The index will be created with the default 'english' language configuration if no language is specified. Requires Marten and PostgreSQL version 10.0 or above.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/full_text.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nusing var store = DocumentStore.For(_ =>\n{\n    _.Connection(\"your_postgres_connection_string\");\n    _.Schema.For<MyDocument>().Searchable();\n});\n```\n\n----------------------------------------\n\nTITLE: Registering Console Subscription with Marten C#\nDESCRIPTION: This code snippet demonstrates how to register the `ConsoleSubscription` with the Marten store using the `AddMarten` extension method. It showcases two ways to register the subscription: directly with `new ConsoleSubscription()` and with additional configuration to customize the subscription name, version, and event type allow list. It also configures the async daemon.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/subscriptions.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\nbuilder.Services.AddMarten(opts =>\n    {\n        opts.Connection(builder.Configuration.GetConnectionString(\"marten\"));\n\n        // Because this subscription has no service dependencies, we\n        // can use this simple mechanism\n        opts.Events.Subscribe(new ConsoleSubscription());\n\n        // Or with additional configuration like:\n        opts.Events.Subscribe(new ConsoleSubscription(), s =>\n        {\n            s.SubscriptionName = \"Console\"; // Override Marten's naming\n            s.SubscriptionVersion = 2; // Potentially version as an all new subscription\n\n            // Optionally create an allow list of\n            // event types to subscribe to\n            s.IncludeType<InvoiceApproved>();\n            s.IncludeType<InvoiceCreated>();\n\n            // Only subscribe to new events, and don't try\n            // to apply this subscription to existing events\n            s.Options.SubscribeFromPresent();\n        });\n    })\n    .AddAsyncDaemon(DaemonMode.HotCold);\n\nusing var host = builder.Build();\nawait host.StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Paging with ToPagedListAsync (C#)\nDESCRIPTION: Demonstrates asynchronous data paging using Marten's `ToPagedListAsync` extension method. It retrieves a paged list of `Target` objects asynchronously, specifying the page number and page size. Dependencies include Marten, Linq, and async/await.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/paging.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvar pagedList = await query.ToPagedListAsync(2, 10);\n```\n\n----------------------------------------\n\nTITLE: Registering Marten by Connection String\nDESCRIPTION: This snippet demonstrates registering Marten by providing only a connection string.  It assumes you are using Marten completely out of the box with no customizations beyond attributes on your documents. It uses `Microsoft.Extensions.DependencyInjection` and `Microsoft.Extensions.Configuration`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/hostbuilder.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\nvar connectionString = Configuration.GetConnectionString(\"postgres\");\n\n// By only the connection string\nservices.AddMarten(connectionString);\n```\n\n----------------------------------------\n\nTITLE: Enabling Open Telemetry Exporting from Marten (Aspire)\nDESCRIPTION: This code snippet configures Open Telemetry exporting within a .NET application, specifically for Project Aspire.  It retrieves the OTEL endpoint from configuration, adds OpenTelemetry services, configures tracing for the 'Marten' source, and configures metrics for the 'Marten' meter.  It requires the `OpenTelemetry.Extensions.Hosting` NuGet package.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/otel.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n// This is passed in by Project Aspire. The exporter usage is a little\n// different for other tools like Prometheus or SigNoz\nvar endpointUri = builder.Configuration[\"OTEL_EXPORTER_OTLP_ENDPOINT\"];\nConsole.WriteLine(\"OLTP endpoint: \" + endpointUri);\n\nbuilder.Services.AddOpenTelemetry().UseOtlpExporter();\n\nbuilder.Services.AddOpenTelemetry()\n    .WithTracing(tracing =>\n    {\n        tracing.AddSource(\"Marten\");\n    })\n    .WithMetrics(metrics =>\n    {\n        metrics.AddMeter(\"Marten\");\n    });\n```\n\n----------------------------------------\n\nTITLE: Plugging In Marten Logger to StoreOptions\nDESCRIPTION: This C# snippet demonstrates how to configure Marten to use a custom `IMartenLogger` implementation (in this case, `ConsoleMartenLogger`).  The `Logger()` method is used within the `StoreOptions` to register the custom logger.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/diagnostics.md#_snippet_8\n\nLANGUAGE: cs\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n    _.Logger(new ConsoleMartenLogger());\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing Full Text Index for Single Property with Store Options (C#)\nDESCRIPTION: This code snippet demonstrates how to create a full-text index for a specific property (`FirstName`) of the `User` document in Marten using the fluent interface of `StoreOptions`. It indexes only the specified property. The index is created with the default 'english' language configuration if not specified.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/full-text.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n    _.Connection(ConnectionSource.ConnectionString);\n\n    // This creates\n    _.Schema.For<User>().FullTextIndex(d => d.FirstName);\n});\n```\n\n----------------------------------------\n\nTITLE: Writing Multiple Documents to HttpContext (Marten)\nDESCRIPTION: This C# code snippet demonstrates writing an array of documents to the HTTP response using the `WriteArray` extension method on a Linq query.  It retrieves all open `Issue` documents and streams them as a JSON array to the `HttpContext.Response.Body`. The `onFoundStatus` parameter can be used to customize the HTTP status code. Dependency: `IQuerySession`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/aspnetcore.md#_snippet_3\n\nLANGUAGE: cs\nCODE:\n```\n[HttpGet(\"/issue/open\")]\npublic Task OpenIssues([FromServices] IQuerySession session, [FromQuery] string? sc = null)\n{\n    // This \"streams\" the raw JSON to the HttpResponse\n    // w/o ever having to read the full JSON string or\n    // deserialize/serialize within the HTTP request\n    return sc is null\n        ? session.Query<Issue>().Where(x => x.Open)\n            .WriteArray(HttpContext)\n        : session.Query<Issue>().Where(x => x.Open)\n            .WriteArray(HttpContext, onFoundStatus: int.Parse(sc));\n}\n```\n\n----------------------------------------\n\nTITLE: Configure & Override Tenancy at Document Level (C#)\nDESCRIPTION: This sample demonstrates configuring tenancy at the document level through document mappings and overriding store-level configurations applied via Document Policies. It sets the tenancy for the `Target` document to `TenancyStyle.Conjoined`, overriding the default policy of `TenancyStyle.Single`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/tenancy/configuring.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:tenancy-configure-override]>\n```\n\n----------------------------------------\n\nTITLE: Adding Quest Projection to Document Store\nDESCRIPTION: Demonstrates how to register the `QuestProjection` with the `DocumentStore` and sets its lifecycle to `Inline`. This ensures that the projection is applied automatically as events are persisted.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/quickstart.md#_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n    _.Connection(ConnectionSource.ConnectionString);\n    _.Projections.Add<QuestProjection>(ProjectionLifecycle.Inline); // [!code ++]\n});\n```\n\n----------------------------------------\n\nTITLE: Overriding Document Alias via MartenRegistry - C#\nDESCRIPTION: This snippet shows how to override the default document alias using the MartenRegistry. This allows disambiguation of table storage for documents with same type name by setting the `DocumentAlias` for specific document type.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/storage.md#_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n    _.Connection(ConnectionSource.ConnectionString);\n\n    _.Schema.For<User>().DocumentAlias(\"folks\");\n});\n```\n\n----------------------------------------\n\nTITLE: Overriding Schema per Table (C#)\nDESCRIPTION: This example demonstrates how to assign specific document tables to different schemas within the PostgreSQL database.  The `StoreOptions.Schema.For<T>().DatabaseSchemaName()` method allows you to configure the schema on a per-document-type basis, overriding the default schema setting.  The example shows setting schema names for `User` and `Issue` document types.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/schema/index.md#_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\nStoreOptions.Schema.For<User>().DatabaseSchemaName(\"other\");\n```\n\n----------------------------------------\n\nTITLE: Configure Aggregate with Optimizations - C#\nDESCRIPTION: This snippet shows how to configure Marten to use identity map optimizations for aggregates, which improves the performance of `FetchForWriting` and `FetchLatest` operations. It configures Marten within a .NET application's service collection, enabling identity map usage and setting snapshot lifecycle to inline.  This requires the `Host.CreateApplicationBuilder()` and connection string configuration.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/read-aggregates.md#_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\nbuilder.Services.AddMarten(opts =>\n{\n    opts.Connection(builder.Configuration.GetConnectionString(\"marten\"));\n\n    // This opts Marten into a pretty big optimization\n    // for how FetchForWriting and/or FetchLatest work internally\n    opts.Events.UseIdentityMapForAggregates = true;\n    opts.Projections.Snapshot<Projections.Invoice>(SnapshotLifecycle.Inline);\n});\n```\n\n----------------------------------------\n\nTITLE: Query Document Subclass Hierarchy\nDESCRIPTION: Demonstrates various ways to query a document subclass hierarchy in Marten.  It showcases retrieving all subclasses of a given type, including filtering with `where` clauses and using camel casing. It also shows querying based on an interface.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/hierarchies.md#_snippet_4\n\nLANGUAGE: cs\nCODE:\n```\n[Fact]\npublic async Task get_all_subclasses_of_a_subclass()\n{\n    var smurf = new Smurf {Ability = \"Follow the herd\"};\n    var papa = new PapaSmurf {Ability = \"Lead\"};\n    var brainy = new BrainySmurf {Ability = \"Invent\"};\n    theSession.Store(smurf, papa, brainy);\n\n    await theSession.SaveChangesAsync();\n\n    theSession.Query<Smurf>().Count().ShouldBe(3);\n}\n\n[Fact]\npublic async Task get_all_subclasses_of_a_subclass2()\n{\n    var smurf = new Smurf {Ability = \"Follow the herd\"};\n    var papa = new PapaSmurf {Ability = \"Lead\"};\n    var brainy = new BrainySmurf {Ability = \"Invent\"};\n    theSession.Store(smurf, papa, brainy);\n\n    await theSession.SaveChangesAsync();\n\n    theSession.Logger = new TestOutputMartenLogger(_output);\n\n    theSession.Query<PapaSmurf>().Count().ShouldBe(2);\n}\n\n[Fact]\npublic async Task get_all_subclasses_of_a_subclass_with_where()\n{\n    var smurf = new Smurf {Ability = \"Follow the herd\"};\n    var papa = new PapaSmurf {Ability = \"Lead\"};\n    var brainy = new BrainySmurf {Ability = \"Invent\"};\n    theSession.Store(smurf, papa, brainy);\n\n    await theSession.SaveChangesAsync();\n\n    theSession.Query<PapaSmurf>().Count(s => s.Ability == \"Invent\").ShouldBe(1);\n}\n\n[Fact]\npublic async Task get_all_subclasses_of_a_subclass_with_where_with_camel_casing()\n{\n    StoreOptions(_ =>\n    {\n        _.Schema.For<ISmurf>()\n            .AddSubClassHierarchy(typeof(Smurf), typeof(PapaSmurf), typeof(PapySmurf), typeof(IPapaSmurf),\n                typeof(BrainySmurf));\n\n        // Alternatively, you can use the following:\n        // _.Schema.For<ISmurf>().AddSubClassHierarchy();\n        // this, however, will use the assembly\n        // of type ISmurf to get all its' subclasses/implementations.\n        // In projects with many types, this approach will be undvisable.\n\n        _.UseDefaultSerialization(EnumStorage.AsString, Casing.CamelCase);\n\n        _.Connection(ConnectionSource.ConnectionString);\n        _.AutoCreateSchemaObjects = AutoCreate.All;\n\n        _.Schema.For<ISmurf>().GinIndexJsonData();\n    });\n\n    var smurf = new Smurf {Ability = \"Follow the herd\"};\n    var papa = new PapaSmurf {Ability = \"Lead\"};\n    var brainy = new BrainySmurf {Ability = \"Invent\"};\n    theSession.Store(smurf, papa, brainy);\n\n    await theSession.SaveChangesAsync();\n\n    theSession.Query<PapaSmurf>().Count(s => s.Ability == \"Invent\").ShouldBe(1);\n}\n\n[Fact]\npublic async Task get_all_subclasses_of_an_interface()\n{\n    var smurf = new Smurf {Ability = \"Follow the herd\"};\n    var papa = new PapaSmurf {Ability = \"Lead\"};\n    var papy = new PapySmurf {Ability = \"Lead\"};\n    var brainy = new BrainySmurf {Ability = \"Invent\"};\n    theSession.Store(smurf, papa, brainy, papy);\n\n    await theSession.SaveChangesAsync();\n\n    theSession.Query<IPapaSmurf>().Count().ShouldBe(3);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Optimistic Concurrency - C#\nDESCRIPTION: This C# code snippet shows how to enable optimistic concurrency for a document type programmatically using Marten's configuration API. This provides an alternative to using the `UseOptimisticConcurrency` attribute and is helpful when configuring document storage through code.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/advanced/optimistic_concurrency.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:configuring-optimistic-concurrency]>\n```\n\n----------------------------------------\n\nTITLE: Querying String Arrays in Marten (C#)\nDESCRIPTION: Shows how to perform \"contains\" searches within arrays of primitive values like strings in Marten.  The example creates documents with string arrays and then queries for documents containing a specific string within their arrays.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/child-collections.md#_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic async Task query_against_string_array()\n{\n    var doc1 = new DocWithArrays { Strings = new[] { \"a\", \"b\", \"c\" } };\n    var doc2 = new DocWithArrays { Strings = new[] { \"c\", \"d\", \"e\" } };\n    var doc3 = new DocWithArrays { Strings = new[] { \"d\", \"e\", \"f\" } };\n\n    theSession.Store(doc1);\n    theSession.Store(doc2);\n    theSession.Store(doc3);\n\n    await theSession.SaveChangesAsync();\n\n    theSession.Query<DocWithArrays>().Where(x => x.Strings.Contains(\"c\")).ToArray()\n        .Select(x => x.Id).ShouldHaveTheSameElementsAs(doc1.Id, doc2.Id);\n}\n```\n\n----------------------------------------\n\nTITLE: Upcasting with System.Text.Json in Marten\nDESCRIPTION: Demonstrates how to configure Marten to use System.Text.Json for serialization and define an upcast using a lambda expression that transforms a raw JSON document. It uses `AsyncOnlyUpcast` for asynchronous transformation and retrieves data from the JSON using `JsonDocument` and its `RootElement` property. Be aware of the potential N+1 problem when performing resource-intensive operations within the upcast lambda.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/versioning.md#_snippet_30\n\nLANGUAGE: cs\nCODE:\n```\noptions.UseSystemTextJsonForSerialization();\n\noptions.Events\n    .Upcast<ShoppingCartOpenedWithStatus>(\n        \"shopping_cart_opened\",\n        AsyncOnlyUpcast(async (oldEventJson, ct) =>\n        {\n            var oldEvent = oldEventJson.RootElement;\n\n            var clientId = oldEvent.GetProperty(\"ClientId\").GetGuid();\n\n            // WARNING: UpcastAsync method is called each time\n            // old event is read from database and deserialized.\n            // We discourage to run resource consuming methods here.\n            // It might end up with N+1 problem.\n            var clientName = await clientRepository.GetClientName(clientId, ct);\n\n            return new ShoppingCartOpenedWithStatus(\n                oldEvent.GetProperty(\"ShoppingCartId\").GetGuid(),\n                new Client(clientId, clientName),\n                ShoppingCartStatus.Opened\n            );\n        })\n    );\n```\n\n----------------------------------------\n\nTITLE: Multiple Full Text Indexes with Custom Settings - Marten C#\nDESCRIPTION: Demonstrates using `[FullTextIndex]` to create multiple indexes on different properties of the `BlogPost` class, each with its own language configuration (`EnglishText` defaults to english, `ItalianText` uses italian, and `FrenchText` uses french).  Requires the Marten library.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/full-text.md#_snippet_10\n\nLANGUAGE: cs\nCODE:\n```\npublic class BlogPost\n{\n    public Guid Id { get; set; }\n\n    public string Category { get; set; }\n\n    [FullTextIndex] public string EnglishText { get; set; }\n\n    [FullTextIndex(RegConfig = \"italian\")] public string ItalianText { get; set; }\n\n    [FullTextIndex(RegConfig = \"french\")] public string FrenchText { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Scoping Session to Tenant for Writes in Marten\nDESCRIPTION: This snippet demonstrates how to scope a document session to a specific tenant identified as 'tenant1'. When multi-tenancy is enabled, the persisted `User` objects are associated with the tenancy of the session. It uses `IDocumentSession` to store a `User` object within the specified tenant's scope. This ensures that data is correctly associated with the intended tenant during write operations.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/tenancy/basicoperations.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:tenancy-scoping-session-write]>\n```\n\n----------------------------------------\n\nTITLE: Using Parameterized SQL\nDESCRIPTION: Illustrates how to use parameterized SQL in Marten queries.  This helps prevent SQL injection and improves query performance.  The parameter values are automatically handled by Marten. The parameters are denoted by the `?` character.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/sql.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nvar firstName = \"Jeremy\";\nvar users = session.Query<User>(\"where data ->> 'FirstName' = ?\", firstName).ToList();\n```\n\n----------------------------------------\n\nTITLE: Configuring Marten with DocumentMapping (Generic)\nDESCRIPTION: This C# code snippet demonstrates how to configure Marten using a static `ConfigureMarten` method within a document type. It shows how to set the document alias within the `DocumentMapping` object. This allows for customizing storage for a specific document type. The document type contains an Id field, and the configuration method sets an alias for the document mapping.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/storeoptions.md#_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic class ConfiguresItself\n{\n    public Guid Id;\n\n    public static void ConfigureMarten(DocumentMapping mapping)\n    {\n        mapping.Alias = \"different\";\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Soft Delete Configuration - Marten - C#\nDESCRIPTION: Configures soft deletes for a document type using the fluent interface provided by StoreOptions.  This method allows you to specify that a document type should be soft-deleted through code rather than using an attribute. This requires Marten and a configured DocumentStore.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/deletes.md#_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n    _.Schema.For<User>().SoftDeleted();\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Event Store with Projection (C#)\nDESCRIPTION: Configures the Marten `DocumentStore` to include the `CandleProjection`. This registers the projection with the Event Store so it can be used to project events.  Requires `using Marten;` and `using Marten.Events.Projections;`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/projection-by-event-type.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nusing Marten;\nusing Marten.Events.Projections;\n\npublic class ConfigureMarten\n{\n    public void ConfigureEventStore()\n    {\n        var store = DocumentStore.For(_ =>\n        {\n            _.Connection(\"your connection string here\");\n\n            // All the normal Marten configuration\n\n            _.Projections.Add<CandleProjection>(ProjectionLifecycle.Inline);\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Query with MatchesSql\nDESCRIPTION: Explains how to combine custom SQL queries with other Linq operations using the `MatchesSql` method. This allows for more complex query logic that leverages both Linq and SQL.  The custom SQL is integrated within the broader Linq expression.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/sql.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nvar firstName = \"Jeremy\";\nvar users = session.Query<User>().Where(x => x.LastName == \"Miller\").MatchesSql(\"where data ->> 'FirstName' = ?\", firstName).ToList();\n```\n\n----------------------------------------\n\nTITLE: Defining Aggregate with Version Property C#\nDESCRIPTION: Defines an `OrderAggregate` class with an integer `Version` property. Marten automatically sets this property to the latest event version within the stream if used as the target of a `SingleStreamAggregation`. The version member can be either a field or a property, the getter can be internal or private, and the version member can be either an `int` (Int32) or `long` (Int64).\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/aggregate-projections.md#_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\npublic class OrderAggregate\n{\n    // This is most likely the stream id\n    public Guid Id { get; set; }\n\n    // This would be set automatically by Marten if\n    // used as the target of a SingleStreamAggregation\n    public int Version { get; set; }\n\n    public void Apply(OrderShipped shipped) => HasShipped = true;\n    public bool HasShipped { get; private set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Initial Data Implementation Example (IInitialData)\nDESCRIPTION: This code snippet demonstrates how to implement the `IInitialData` interface to seed data into a Marten database. The `Populate` method is executed during document store initialization and takes an `IDocumentStore` as a parameter, allowing you to insert data. This depends on the Marten library.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/basics/initial_data.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic class InitialData : IInitialData\n{\n    public async Task Populate(IDocumentStore store, CancellationToken token = default)\n    {\n        await using var session = store.LightweightSession();\n\n        session.Store(new User { FirstName = \"Jeremy\", LastName = \"Miller\" });\n        session.Store(new User { FirstName = \"Max\", LastName = \"Levchin\" });\n\n        await session.SaveChangesAsync(token);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Async Daemon Error Policies (C#)\nDESCRIPTION: This code snippet demonstrates how to configure error handling policies for the Marten Async Daemon.  It shows how to set options for skipping apply errors, serialization errors, and unknown events during both continuous daemon processing and projection rebuilds. Requires Marten and Microsoft.Extensions.Hosting NuGet packages.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/async-daemon.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .ConfigureServices(services =>\n    {\n        services.AddMarten(opts =>\n            {\n                // connection information...\n\n                opts.Projections.Errors.SkipApplyErrors = true;\n                opts.Projections.Errors.SkipSerializationErrors = true;\n                opts.Projections.Errors.SkipUnknownEvents = true;\n\n                opts.Projections.RebuildErrors.SkipApplyErrors = false;\n                opts.Projections.RebuildErrors.SkipSerializationErrors = false;\n                opts.Projections.RebuildErrors.SkipUnknownEvents = false;\n            })\n            .AddAsyncDaemon(DaemonMode.HotCold);\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom Session Factory (C#)\nDESCRIPTION: This example demonstrates how to create a custom session factory by implementing the `ISessionFactory` interface. The custom factory allows you to control the creation of `IDocumentSession` and `IQuerySession` instances, including specifying the session type (e.g., lightweight) and transaction isolation level. It requires an `IDocumentStore` instance.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/hostbuilder.md#_snippet_16\n\nLANGUAGE: cs\nCODE:\n```\npublic class CustomSessionFactory: ISessionFactory\n{\n    private readonly IDocumentStore _store;\n\n    // This is important! You will need to use the\n    // IDocumentStore to open sessions\n    public CustomSessionFactory(IDocumentStore store)\n    {\n        _store = store;\n    }\n\n    public IQuerySession QuerySession()\n    {\n        return _store.QuerySession();\n    }\n\n    public IDocumentSession OpenSession()\n    {\n        // Opting for the \"lightweight\" session\n        // option with no identity map tracking\n        // and choosing to use Serializable transactions\n        // just to be different\n        return _store.LightweightSession(IsolationLevel.Serializable);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Delete Documents by Criteria - Marten - C#\nDESCRIPTION: Deletes documents based on a LINQ expression using the DeleteWhere method of the IDocumentSession. The actual deletion occurs when SaveChangesAsync() is called, as part of a batched SQL command and transaction.  Requires an active IDocumentSession and a LINQ expression defining the deletion criteria.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/deletes.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\ntheSession.DeleteWhere<Target>(x => x.Double == 578);\n\nawait theSession.SaveChangesAsync();\n```\n\n----------------------------------------\n\nTITLE: Transforming Event with WithData() in Marten (C#)\nDESCRIPTION: This code snippet demonstrates how to use the `WithData()` extension method in Marten to transform an event while preserving data from the original event. This is used within a custom grouping implementation for creating specialized event projections. The code creates a new `EmployeeAllocatedInMonth` event, inheriting data from the `monthlyAllocation` key's `Source` event.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/multi-stream-projections.md#_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\nKey = $\"{monthlyAllocation.Key.EmployeeId}|{monthlyAllocation.Key.Month:yyyy-MM-dd}\",\nEvent = monthlyAllocation.Key.Source.WithData(\n    new EmployeeAllocatedInMonth(\n        monthlyAllocation.Key.EmployeeId,\n        monthlyAllocation.Key.Month,\n        monthlyAllocation.Select(a => a.Allocation).ToList())\n)\n```\n\n----------------------------------------\n\nTITLE: Executing Custom SQL Commands with QueueSqlCommand - C#\nDESCRIPTION: This snippet shows how to use `QueueSqlCommand` to execute arbitrary SQL commands as part of a Marten session's unit of work. It demonstrates inserting data into a `names` table, storing `Target` objects, and inserting JSON data with type casting. The snippet also shows how to use an alternative character, '^', as the parameter placeholder instead of '?'.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/execute-custom-sql.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\ntheSession.QueueSqlCommand(\"insert into names (name) values ('Jeremy')\");\ntheSession.QueueSqlCommand(\"insert into names (name) values ('Babu')\");\ntheSession.Store(Target.Random());\ntheSession.QueueSqlCommand(\"insert into names (name) values ('Oskar')\");\ntheSession.Store(Target.Random());\nvar json = \"{ \\\"answer\\\": 42 }\";\ntheSession.QueueSqlCommand(\"insert into data (raw_value) values (?::jsonb)\", json);\n// Use ^ as the parameter placeholder\ntheSession.QueueSqlCommand('^', \"insert into data (raw_value) values (^::jsonb)\", json);\n```\n\n----------------------------------------\n\nTITLE: Create Full Text Index for Single Property via Attribute (C#)\nDESCRIPTION: This code snippet demonstrates how to create a full text index for a single property by using the `[FullTextIndex]` attribute on a property. It indexes the 'FirstName' property. The index will be created with the default 'english' language configuration if no language is specified. Requires Marten and PostgreSQL version 10.0 or above.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/full_text.md#_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic class MyDocument\n{\n    public Guid Id { get; set; }\n\n    [FullTextIndex]\n    public string FirstName { get; set; }\n\n    public string LastName { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Marten Optimizations in C#\nDESCRIPTION: This code snippet demonstrates how to configure various performance optimizations within Marten, including archived stream partitioning, quick event append mode, identity map usage for aggregates, and optimized projection rebuilds. These optimizations aim to improve the performance and scalability of event sourcing applications.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/optimizing.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\nbuilder.Services.AddMarten(opts =>\n{\n    opts.Connection(\"some connection string\");\n\n    // Turn on the PostgreSQL table partitioning for\n    // hot/cold storage on archived events\n    opts.Events.UseArchivedStreamPartitioning = true;\n\n    // Use the *much* faster workflow for appending events\n    // at the cost of *some* loss of metadata usage for\n    // inline projections\n    opts.Events.AppendMode = EventAppendMode.Quick;\n\n    // Little more involved, but this can reduce the number\n    // of database queries necessary to process projections\n    // during CQRS command handling with certain workflows\n    opts.Events.UseIdentityMapForAggregates = true;\n\n    // Opts into a mode where Marten is able to rebuild single\n    // stream projections faster by building one stream at a time\n    // Does require new table migrations for Marten 7 users though\n    opts.Events.UseOptimizedProjectionRebuilds = true;\n});\n```\n\n----------------------------------------\n\nTITLE: Deleting Documents with Linq Queries in Marten\nDESCRIPTION: Demonstrates how to delete documents of a specific type that match a LINQ expression using `IDocumentSession.DeleteWhere<T>()`. The SQL command is not executed until `IDocumentSession.SaveChanges()` is called, and runs in the same batched SQL command and transaction as other updates or deletes.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/basics/deleting.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:DeleteWhere]>\n```\n\n----------------------------------------\n\nTITLE: Configuring Tenant ID Case Sensitivity in Marten (C#)\nDESCRIPTION: This code snippet demonstrates how to configure Marten to handle tenant IDs with specific case sensitivity rules. It shows how to force tenant IDs to be either lower case or upper case, or to maintain the original case sensitivity.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/multitenancy.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(opts =>\n{\n    // This is the default\n    opts.TenantIdStyle = TenantIdStyle.CaseSensitive;\n\n    // Or opt into this behavior:\n    opts.TenantIdStyle = TenantIdStyle.ForceLowerCase;\n\n    // Or force all tenant ids to be converted to upper case internally\n    opts.TenantIdStyle = TenantIdStyle.ForceUpperCase;\n});\n```\n\n----------------------------------------\n\nTITLE: Registering Kafka Subscription\nDESCRIPTION: This code snippet demonstrates how to register a Kafka subscription in Marten using `AddSubscriptionWithServices`. It configures the subscription with options such as including archived events, filtering events based on stream type (Invoice), and setting a batch size for event processing. The subscription is registered as a Singleton service and the daemon is added in HotCold mode.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/subscriptions.md#_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\nbuilder.Services.AddMarten(opts =>\n    {\n        opts.Connection(builder.Configuration.GetConnectionString(\"marten\"));\n    })\n    // Marten also supports a Scoped lifecycle, and quietly forward Transient\n    // to Scoped\n    .AddSubscriptionWithServices<KafkaSubscription>(ServiceLifetime.Singleton, o =>\n    {\n        // This is a default, but just showing what's possible\n        o.IncludeArchivedEvents = false;\n\n        o.FilterIncomingEventsOnStreamType(typeof(Invoice));\n\n        // Process no more than 10 events at a time\n        o.Options.BatchSize = 10;\n    })\n    .AddAsyncDaemon(DaemonMode.HotCold);\n\nusing var host = builder.Build();\nawait host.StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Configure Schema by Document Type\nDESCRIPTION: This C# code snippet demonstrates how to configure the database schema name for a specific document type, overriding the default `StoreOptions.DatabaseSchemaName`. This allows putting different document types into separate schemas. The configuration sets a default schema and then overrides it for the User document type.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/storeoptions.md#_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(opts =>\n{\n    opts.Connection(\"some connection string\");\n    opts.DatabaseSchemaName = \"other\";\n\n    // This would take precedence for the\n    // User document type storage\n    opts.Schema.For<User>()\n        .DatabaseSchemaName(\"users\");\n});\n```\n\n----------------------------------------\n\nTITLE: Define Computed Unique Index (Single Property) via Attribute in Marten C#\nDESCRIPTION: This code shows how to define a computed unique index on a single property using the `UniqueIndex` attribute in Marten. It applies the `[UniqueIndex]` attribute to the `Number` property of the `Account` class, specifying `UniqueIndexType.Computed`. This enforces uniqueness at the database level.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/indexing/unique.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic class Account\n{\n    public Guid Id { get; set; }\n\n    [UniqueIndex(IndexType = UniqueIndexType.Computed)]\n    public string Number { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Configure Tenancy Through Policy (C#)\nDESCRIPTION: This code snippet demonstrates how to configure the default tenancy style for all documents using Document Policies in Marten. It accesses the `StoreOptions.Policies` and sets the default tenancy to `TenancyStyle.Conjoined`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/tenancy/configuring.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:tenancy-configure-through-policy]>\n```\n\n----------------------------------------\n\nTITLE: Configuring Command Timeout in Marten (C#)\nDESCRIPTION: Demonstrates how to configure the command timeout for a Marten session using SessionOptions. The example sets the timeout to 60 seconds. This overrides the default timeout from the Npgsql connection string for the specific session.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/sessions.md#_snippet_9\n\nLANGUAGE: cs\nCODE:\n```\npublic void ConfigureCommandTimeout(IDocumentStore store)\n{\n    // Sets the command timeout for this session to 60 seconds\n    // The default is 30\n    using (var session = store.LightweightSession(new SessionOptions { Timeout = 60 }))\n    {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Marten by Nullable Types and NULL Values in C#\nDESCRIPTION: This C# code snippet demonstrates how to query Marten documents based on nullable properties and NULL values. It shows how to use `Nullable<T>.HasValue` to check if a nullable property has a value, and also demonstrates querying for records where a property is directly equal to NULL. This example requires an `IDocumentSession` and a `Target` document type.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/nulls.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic void query_by_nullable_type_nulls(IDocumentSession session)\n{\n    // You can use Nullable<T>.HasValue in Linq queries\n    session.Query<Target>().Where(x => !x.NullableNumber.HasValue).ToArray();\n    session.Query<Target>().Where(x => x.NullableNumber.HasValue).ToArray();\n\n    // You can always search by field is NULL\n    session.Query<Target>().Where(x => x.Inner == null);\n}\n```\n\n----------------------------------------\n\nTITLE: Using Multiple Value Types in Marten LINQ Queries with OrderBy\nDESCRIPTION: This code demonstrates the usage of different value types (int, long, string, and Guid) with `OrderBy` in Marten LINQ queries. The snippet stores `LimitedDoc` instances with value type properties and then queries them, ordering by each value type property. Assertions ensure that the query results are correctly ordered for each value type, showcasing Marten's capability to handle different types seamlessly in LINQ expressions.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/identity.md#_snippet_26\n\nLANGUAGE: cs\nCODE:\n```\n[Fact]\npublic async Task store_several_and_use_in_LINQ_order_by()\n{\n    var commonParentId = GuidId.From(Guid.NewGuid());\n    var doc1 = new LimitedDoc { ParentId = commonParentId, Lower = LowerLimit.From(1), Upper = UpperLimit.From(20), Description = Description.From(\"desc1\") };\n    var doc2 = new LimitedDoc { Lower = LowerLimit.From(5), Upper = UpperLimit.From(25), Description = Description.From(\"desc3\") };\n    var doc3 = new LimitedDoc { Lower = LowerLimit.From(4), Upper = UpperLimit.From(15), Description = Description.From(\"desc2\") };\n    var doc4 = new LimitedDoc { ParentId = commonParentId, Lower = LowerLimit.From(3), Upper = UpperLimit.From(10), Description = Description.From(\"desc4\") };\n\n    theSession.Store(doc1, doc2, doc3, doc4);\n    await theSession.SaveChangesAsync();\n\n    var orderedByIntBased = await theSession\n        .Query<LimitedDoc>()\n        .OrderBy(x => x.Lower)\n        .Select(x => x.Id)\n        .ToListAsync();\n\n    orderedByIntBased.ShouldHaveTheSameElementsAs(doc1.Id, doc4.Id, doc3.Id, doc2.Id);\n\n    var orderedByLongBased = await theSession\n        .Query<LimitedDoc>()\n        .OrderBy(x => x.Upper)\n        .Select(x => x.Id)\n        .ToListAsync();\n\n    orderedByLongBased.ShouldHaveTheSameElementsAs(doc4.Id, doc3.Id, doc1.Id, doc2.Id);\n\n    var orderedByStringBased = await theSession\n        .Query<LimitedDoc>()\n        .OrderBy(x => x.Description)\n        .Select(x => x.Id)\n        .ToListAsync();\n\n    orderedByStringBased.ShouldHaveTheSameElementsAs(doc1.Id, doc3.Id, doc2.Id, doc4.Id);\n\n    var orderedByGuidBased = await theSession\n        .Query<LimitedDoc>()\n        .OrderBy(x => x.ParentId)\n        .Select(x => x.Id)\n        .ToListAsync();\n\n    orderedByGuidBased.ShouldHaveTheSameElementsAs(doc1.Id, doc4.Id, doc2.Id, doc3.Id);\n}\n```\n\n----------------------------------------\n\nTITLE: Event Metadata - C#\nDESCRIPTION: This code snippet shows how event metadata is accessed through the `IEvent` interface in Marten. This provides access to information such as event ID, stream ID, version, and timestamp. It enables querying and inspecting event details after committing a transaction.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/events/schema.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n// Nothing to see here, see sample Marten.Examples.EventStore.EventMetadataSample\n```\n\n----------------------------------------\n\nTITLE: Add Subclass Hierarchy with Aliases\nDESCRIPTION: Demonstrates adding subclasses to a Marten document hierarchy with custom aliases for specific types using `MappedType`. This allows for more control over how the types are stored and queried within Marten.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/hierarchies.md#_snippet_3\n\nLANGUAGE: cs\nCODE:\n```\n_.Schema.For<ISmurf>()\n    .AddSubClassHierarchy(\n        typeof(Smurf),\n        new MappedType(typeof(PapaSmurf), \"papa\"),\n        typeof(PapySmurf),\n        typeof(IPapaSmurf),\n        typeof(BrainySmurf)\n    );\n```\n\n----------------------------------------\n\nTITLE: Bootstrapping Async Daemon in Solo Mode (C#)\nDESCRIPTION: This code snippet shows how to bootstrap the Marten Async Daemon in 'Solo' mode.  It configures the service collection to use Marten, registers a projection to run asynchronously, and then activates the daemon in Solo mode. Requires Marten and Microsoft.Extensions.Hosting NuGet packages.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/async-daemon.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvar host = await Host.CreateDefaultBuilder()\n    .ConfigureServices(services =>\n    {\n        services.AddMarten(opts =>\n            {\n                opts.Connection(\"some connection string\");\n\n                // Register any projections you need to run asynchronously\n                opts.Projections.Add<TripProjectionWithCustomName>(ProjectionLifecycle.Async);\n            })\n            // Turn on the async daemon in \"Solo\" mode\n            .AddAsyncDaemon(DaemonMode.Solo);\n    })\n    .StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Ejecting a Document from Session\nDESCRIPTION: This snippet illustrates how to remove a document from the identity map and unit of work tracking within a session using IDocumentSession.Eject. It stores two Target documents, ejects one, and verifies that the ejected document is no longer in the identity map or persisted after SaveChangesAsync.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/sessions.md#_snippet_4\n\nLANGUAGE: cs\nCODE:\n```\nvar target1 = Target.Random();\nvar target2 = Target.Random();\n\nusing (var session = theStore.IdentitySession())\n{\n    session.Store(target1, target2);\n\n    // Both documents are in the identity map\n    session.Load<Target>(target1.Id).ShouldBeSameAs(target1);\n    session.Load<Target>(target2.Id).ShouldBeSameAs(target2);\n\n    // Eject the 2nd document\n    session.Eject(target2);\n\n    // Now that 2nd document is no longer in the identity map\n    session.Load<Target>(target2.Id).ShouldBeNull();\n\n    await session.SaveChangesAsync();\n}\n\nusing (var session = theStore.QuerySession())\n{\n    // The 2nd document was ejected before the session\n    // was saved, so it was never persisted\n    session.Load<Target>(target2.Id).ShouldBeNull();\n}\n```\n\n----------------------------------------\n\nTITLE: Rebuilding a Single Projection in Marten (C#)\nDESCRIPTION: This code snippet illustrates how to rebuild a single projection in Marten using the async daemon. It first configures the document store to add a `DistanceProjection` with an `Async` lifecycle. Then, it starts the daemon, publishes test data, and finally rebuilds the \"Distance\" projection asynchronously.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/rebuilding.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nStoreOptions(x => x.Projections.Add(new DistanceProjection(), ProjectionLifecycle.Async));\n\nvar agent = await StartDaemon();\n\n// setup test data\nawait PublishSingleThreaded();\n\n// rebuild projection `Distance`\nawait agent.RebuildProjectionAsync(\"Distance\", CancellationToken.None);\n```\n\n----------------------------------------\n\nTITLE: Using ApplyMetadata in Projection C#\nDESCRIPTION: Demonstrates how to override `ApplyMetadata` in a `SingleStreamProjection` to manually map event metadata to an aggregate. This allows customizing how metadata like timestamps and custom headers are applied to the aggregate based on the last event encountered.  The `LastModifiedBy` and `LastModified` properties of the `Item` aggregate are updated using the last event's timestamp and a custom header value.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/aggregate-projections.md#_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\npublic class Item\n{\n    public Guid Id { get; set; }\n    public string Description { get; set; }\n    public bool Started { get; set; }\n    public DateTimeOffset WorkedOn { get; set; }\n    public bool Completed { get; set; }\n    public string LastModifiedBy { get; set; }\n    public DateTimeOffset? LastModified { get; set; }\n\n    public int Version { get; set; }\n}\n\npublic record ItemStarted(string Description);\n\npublic record ItemWorked;\n\npublic record ItemFinished;\n\npublic class ItemProjection: SingleStreamProjection<Item>\n{\n    public void Apply(Item item, ItemStarted started)\n    {\n        item.Started = true;\n        item.Description = started.Description;\n    }\n\n    public void Apply(Item item, IEvent<ItemWorked> worked)\n    {\n        // Nothing, I know, this is weird\n    }\n\n    public void Apply(Item item, ItemFinished finished)\n    {\n        item.Completed = true;\n    }\n\n    public override Item ApplyMetadata(Item aggregate, IEvent lastEvent)\n    {\n        // Apply the last timestamp\n        aggregate.LastModified = lastEvent.Timestamp;\n\n        var person = lastEvent.GetHeader(\"last-modified-by\");\n\n        aggregate.LastModifiedBy = person?.ToString() ?? \"System\";\n\n        return aggregate;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Event Types in Marten (C#)\nDESCRIPTION: This code snippet demonstrates how to register event types with Marten's event store. It initializes a DocumentStore, configures the database schema, connection string, and schema creation behavior.  Then, it registers the `QuestStarted` and `MonsterSlayed` event types, which Marten needs to deserialize events from JSON.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/index.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar store2 = DocumentStore.For(_ =>\n{\n    _.DatabaseSchemaName = \"samples\";\n    _.Connection(ConnectionSource.ConnectionString);\n    _.AutoCreateSchemaObjects = AutoCreate.None;\n\n    _.Events.AddEventType(typeof(QuestStarted));\n    _.Events.AddEventType(typeof(MonsterSlayed));\n});\n```\n\n----------------------------------------\n\nTITLE: Indexing Soft Deleted Documents via Fluent Interface in Marten (C#)\nDESCRIPTION: This code snippet demonstrates configuring a partial index on soft-deleted documents via the fluent interface. This index improves the performance of queries using `IsDeleted()`, `DeletedSince(DateTimeOffset)`, and `DeletedBefore(DateTimeOffset)`. The partial index only includes deleted documents (`mt_deleted = true`).\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/metadata_index.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:soft-delete-with-index-configuration-via-fi]>\n```\n\n----------------------------------------\n\nTITLE: Indexing Last Modified via Attribute in Marten (C#)\nDESCRIPTION: This code snippet demonstrates how to create an index on the `mt_last_modified` metadata column using the `IndexedLastModifiedAttribute`. This enhances the performance of queries using `ModifiedSince(DateTimeOffset)` or `ModifiedBefore(DateTimeOffset)`. The attribute is applied to the document type.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/metadata_index.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:index-last-modified-via-attribute]>\n```\n\n----------------------------------------\n\nTITLE: Registering Console Subscription\nDESCRIPTION: This snippet illustrates how to register a stateless subscription (`ConsoleSubscription`) in Marten. It demonstrates configuring the subscription with a name, version, including specific event types (`InvoiceApproved`, `InvoiceCreated`), and subscribing from the present. The Marten connection string is retrieved from the configuration.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/subscriptions.md#_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\nbuilder.Services.AddMarten(opts =>\n    {\n        opts.Connection(builder.Configuration.GetConnectionString(\"marten\"));\n\n        // Because this subscription has no service dependencies, we\n        // can use this simple mechanism\n        opts.Events.Subscribe(new ConsoleSubscription());\n\n        // Or with additional configuration like:\n        opts.Events.Subscribe(new ConsoleSubscription(), s =>\n        {\n            s.SubscriptionName = \"Console\"; // Override Marten's naming\n            s.SubscriptionVersion = 2; // Potentially version as an all new subscription\n\n            // Optionally create an allow list of\n            // event types to subscribe to\n            s.IncludeType<InvoiceApproved>();\n            s.IncludeType<InvoiceCreated>();\n\n            // Only subscribe to new events, and don't try\n            // to apply this subscription to existing events\n            s.Options.SubscribeFromPresent();\n        });\n    })\n    .AddAsyncDaemon(DaemonMode.HotCold);\n\nusing var host = builder.Build();\nawait host.StartAsync();\n```\n\n----------------------------------------\n\nTITLE: ICompiledListQuery Interface (No Select) C#\nDESCRIPTION: This code snippet defines the `ICompiledListQuery` interface for queries that return a list of documents without any `Select()` transform. It provides a way to define compiled queries that directly return a collection of document objects.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/compiled_queries.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic interface ICompiledListQuery<TDoc> : ICompiledQuery<TDoc, IEnumerable<TDoc>>\n```\n\n----------------------------------------\n\nTITLE: Deserialize Non-Public Members\nDESCRIPTION: Shows how to allow deserialization of properties with non-public setters by changing the serialization settings in the `DocumentStore` options.  By default, `Newtonsoft.Json` only deserializes properties with public setters.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/json/newtonsoft.md#_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:customize_json_net_snakecase_nonpublicmembersstorage_nonpublicsetters]>\n```\n\n----------------------------------------\n\nTITLE: Auto Create Schema Objects in Marten (C#)\nDESCRIPTION: This snippet demonstrates how to configure Marten to automatically create schema objects in the Postgresql database. This is useful during development to avoid manual schema management. The auto creation mode is set in the StoreOptions. \nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/schema/migrations.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[sample:AutoCreateSchemaObjects]\n```\n\n----------------------------------------\n\nTITLE: Event Projection with Document Tracking using Immutable Types (C#)\nDESCRIPTION: Illustrates how to use document tracking in an EventProjection that potentially makes several changes to the same document. It leverages immutable types to avoid direct mutation of the tracked object. The example updates a `BaseballGame` document based on `Run` events, using a `TrackedEventProjection` to project the events and ensuring that changes are applied correctly when processing event batches.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/event-projections.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic enum Team\n{\n    VisitingTeam,\n    HomeTeam\n}\n\npublic record Run(Guid GameId, Team Team, string Player);\n\npublic record BaseballGame\n{\n    public Guid Id { get; init; }\n    public int HomeRuns { get; init; }\n    public int VisitorRuns { get; init; }\n\n    public int Outs { get; init; }\n    public ImmutableHashSet<string> PlayersWithRuns { get; init; }\n}\n\npublic class TrackedEventProjection: EventProjection\n{\n    public TrackedEventProjection()\n    {\n        ProjectAsync<Run>(async (run, ops) =>\n        {\n            var game = await ops.LoadAsync<BaseballGame>(run.GameId);\n\n            var updatedGame = run.Team switch\n            {\n                Team.HomeTeam => game with\n                {\n                    HomeRuns = game.HomeRuns + 1,\n                    PlayersWithRuns = game.PlayersWithRuns.Add(run.Player)\n                },\n                Team.VisitingTeam => game with\n                {\n                    VisitorRuns = game.VisitorRuns + 1,\n                    PlayersWithRuns = game.PlayersWithRuns.Add(run.Player)\n                },\n            };\n\n            ops.Store(updatedGame);\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Inline Marten Projection Aggregation in C#\nDESCRIPTION: This snippet shows how to test an inline Marten projection. It configures Marten with inline snapshotting, creates an event stream, appends events, and then loads the projected `Invoice` document directly from the document store using `LoadAsync<Invoice>(invoiceId)`. Assertions are then made against the loaded document to verify the projection's behavior.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/testing.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic async Task test_inline_aggregation()\n{\n    using var store = DocumentStore.For(opts =>\n    {\n        opts.Connection(\n            \"Host=localhost;Port=5432;Database=marten_testing;Username=postgres;password=postgres;Command Timeout=5\");\n        opts.DatabaseSchemaName = \"incidents\";\n\n        // Notice that the \"snapshot\" is running inline\n        opts.Projections.Snapshot<Invoice>(SnapshotLifecycle.Inline);\n    });\n\n    var invoiceId = Guid.NewGuid();\n\n    // Pump in events\n    using (var session = store.LightweightSession())\n    {\n\n        session.Events.StartStream<Invoice>(invoiceId, new InvoiceCreated(\"Blue Shoes\", 112.24m));\n        await session.SaveChangesAsync();\n\n        session.Events.Append(invoiceId,new InvoiceApproved());\n        session.Events.Append(invoiceId,new InvoicePaid());\n        await session.SaveChangesAsync();\n    }\n\n    await using var query = store.QuerySession();\n\n    // Load the document that was \"projected\" from the events above\n    // and immediately persisted to the document store\n    var invoice = await query.LoadAsync<Invoice>(invoiceId);\n\n    // Run assertions\n    invoice.Description.ShouldBe(\"Blue Shoes\");\n    invoice.Status.ShouldBe(InvoiceStatus.Paid);\n}\n```\n\n----------------------------------------\n\nTITLE: Query All Documents with Linq in Marten (C#)\nDESCRIPTION: Demonstrates querying for all documents of a specific type using the `Query<T>()` method. This method returns an `IQueryable` object that can be used to further filter and manipulate the results.  This operation might be inefficient for large datasets without additional filtering.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/linq.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvar all = session.Query<Target>().ToList();\n```\n\n----------------------------------------\n\nTITLE: Using a Compiled Query to Fetch a User\nDESCRIPTION: This code demonstrates how to use the `FindByFirstName` compiled query to retrieve user documents. It shows both synchronous and asynchronous querying using `session.Query()` and `session.QueryAsync()`. It initializes a new instance of the compiled query class, setting the `FirstName` property.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/compiled-queries.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvar justin = session.Query(new FindByFirstName { FirstName = \"Justin\" });\n\nvar tamba = await session.QueryAsync(new FindByFirstName { FirstName = \"Tamba\" });\n```\n\n----------------------------------------\n\nTITLE: Enabling Causation Fields in Marten (C#)\nDESCRIPTION: This code snippet demonstrates how to enable correlation ID, causation ID, and headers metadata columns for a specific document type or globally for all document types using Marten's configuration options. It utilizes the `DocumentStore.For` method to configure the document store and sets the `Enabled` property to `true` for the desired metadata fields.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/metadata.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(opts =>\n{\n    opts.Connection(\"some connection string\");\n\n    // Optionally turn on metadata columns by document type\n    opts.Schema.For<User>().Metadata(x =>\n    {\n        x.CorrelationId.Enabled = true;\n        x.CausationId.Enabled = true;\n        x.Headers.Enabled = true;\n\n    });\n\n    // Or just globally turn on columns for all document\n    // types in one fell swoop\n    opts.Policies.ForAllDocuments(x =>\n    {\n        x.Metadata.CausationId.Enabled = true;\n        x.Metadata.CorrelationId.Enabled = true;\n        x.Metadata.Headers.Enabled = true;\n\n        // This column is \"opt in\"\n        x.Metadata.CreatedAt.Enabled = true;\n    });\n});\n```\n\n----------------------------------------\n\nTITLE: Explicit Transactions in Marten (C#)\nDESCRIPTION: Demonstrates how to start explicit transactions within a Marten IDocumentSession. The example shows both synchronous and asynchronous ways to begin a transaction using BeginTransaction() and BeginTransactionAsync() methods respectively. Using explicit transaction boundaries requires disposing the session to release the \"sticky\" connection.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/sessions.md#_snippet_7\n\nLANGUAGE: cs\nCODE:\n```\npublic static async Task explicit_transactions(IDocumentSession session)\n{\n    // If in synchronous code, but don't mix this in real async code!!!!\n    session.BeginTransaction();\n\n    // Favor this within async code\n    await session.BeginTransactionAsync(CancellationToken.None);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Unique Index per Tenant - C#\nDESCRIPTION: This code snippet demonstrates how to define a unique index that is scoped per tenant in a multi-tenant Marten application. This ensures uniqueness within each tenant's data.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/unique.md#_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:per-tenant-unique-index]>\n```\n\n----------------------------------------\n\nTITLE: Querying for Related Documents and Scalar in Marten using AdvancedSql\nDESCRIPTION: This snippet shows how to query for multiple related documents (`DocWithMeta`, `DocDetailsWithMeta`) along with a scalar value (total results) using `session.AdvancedSql.QueryAsync<T1, T2, T3>()`.  It retrieves data from two tables joined by a common ID, and uses `count(*) over()` to get the total count for paging purposes. The SQL query returns a tuple of document types and scalar value.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/advanced-sql.md#_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nsession.Store(new DocWithMeta { Id = 1, Name = \"Max\" });\nsession.Store(new DocDetailsWithMeta { Id = 1, Detail = \"Likes bees\" });\nsession.Store(new DocWithMeta { Id = 2, Name = \"Michael\" });\nsession.Store(new DocDetailsWithMeta { Id = 2, Detail = \"Is a good chess player\" });\nsession.Store(new DocWithMeta { Id = 3, Name = \"Anne\" });\nsession.Store(new DocDetailsWithMeta { Id = 3, Detail = \"Hates soap operas\" });\nsession.Store(new DocWithMeta { Id = 4, Name = \"Beatrix\" });\nsession.Store(new DocDetailsWithMeta { Id = 4, Detail = \"Likes to cook\" });\nawait session.SaveChangesAsync();\n\nvar schema = session.DocumentStore.Options.Schema;\nIReadOnlyList<(DocWithMeta doc, DocDetailsWithMeta detail, long totalResults)> results =\n    await session.AdvancedSql.QueryAsync<DocWithMeta, DocDetailsWithMeta, long>(\n        $\"\"\"\n        select\n          row(a.id, a.data, a.mt_version),\n          row(b.id, b.data, b.mt_version),\n          row(count(*) over())\n        from\n          {schema.For<DocWithMeta>()} a\n        left join\n          {schema.For<DocDetailsWithMeta>()} b on a.id = b.id\n        where\n          (a.data ->> 'Id')::int > 1\n        order by\n          a.data ->> 'Name'\n        limit 2\n        \"\"\",\n        CancellationToken.None);\n\nresults.Count.ShouldBe(2);\nresults[0].totalResults.ShouldBe(3);\nresults[0].doc.Name.ShouldBe(\"Anne\");\nresults[0].detail.Detail.ShouldBe(\"Hates soap operas\");\nresults[1].doc.Name.ShouldBe(\"Beatrix\");\nresults[1].detail.Detail.ShouldBe(\"Likes to cook\");\n```\n\n----------------------------------------\n\nTITLE: Undoing Soft Deletion in Marten\nDESCRIPTION: This code snippet demonstrates how to undo a soft delete using Marten's `UndoDeleteWhere<User>()` method. It requires an `IDocumentSession` and a `userId` to identify the document to undelete.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/deletes.md#_snippet_16\n\nLANGUAGE: cs\nCODE:\n```\ninternal Task UndoDeletion(IDocumentSession session, Guid userId)\n{\n    // Tell Marten the type and identity of a document to\n    // delete\n    session.UndoDeleteWhere<User>(x => x.Id == userId);\n\n    return session.SaveChangesAsync();\n}\n```\n\n----------------------------------------\n\nTITLE: Custom StoreOptions Implementation - C#\nDESCRIPTION: This snippet showcases how to create a custom subclass of StoreOptions to encapsulate specific configurations. It includes setting the connection string, configuring the serializer, and defining an index for a document type.  This allows for reusable and shareable Marten configurations.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/storeoptions.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic class MyStoreOptions: StoreOptions\n{\n    public static IDocumentStore ToStore()\n    {\n        return new DocumentStore(new MyStoreOptions());\n    }\n\n    public MyStoreOptions()\n    {\n        Connection(ConnectionSource.ConnectionString);\n\n        Serializer(new JsonNetSerializer { EnumStorage = EnumStorage.AsString });\n\n        Schema.For<User>().Index(x => x.UserName);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Querying for a Single Scalar Value in Marten using AdvancedSql\nDESCRIPTION: This snippet demonstrates how to use `session.AdvancedSql.QueryAsync<T>()` to query for a single scalar value from a Postgresql database. It retrieves the 'Name' field from the JSON data of a document of type `DocWithMeta`. It depends on Marten's `IDocumentSession` and `DocumentStore`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/advanced-sql.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvar schema = session.DocumentStore.Options.Schema;\nvar name = (await session.AdvancedSql.QueryAsync<string>(\n    $\"select data ->> 'Name' from {schema.For<DocWithMeta>()} limit 1\",\n    CancellationToken.None)).First();\n```\n\n----------------------------------------\n\nTITLE: Configuring Partitioning for a Single Table in Marten\nDESCRIPTION: This snippet shows how to configure table partitioning for a specific document type (e.g., `User`) using `opts.Schema.For<User>().MultiTenantedWithPartitioning`. It uses externally managed list partitions, allowing for external control over partition tables.  The code snippet requires a connection string.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/multi-tenancy.md#_snippet_9\n\nLANGUAGE: cs\nCODE:\n```\nvar store = DocumentStore.For(opts =>\n{\n    opts.Connection(\"some connection string\");\n\n    opts.Schema.For<User>().MultiTenantedWithPartitioning(x =>\n    {\n        x.ByExternallyManagedListPartitions();\n    });\n});\n```\n\n----------------------------------------\n\nTITLE: Defining IDocumentSessionListener Interface - C#\nDESCRIPTION: This code defines the `IDocumentSessionListener` interface in Marten, allowing developers to listen to and intercept operations within an `IDocumentSession.SaveChanges()` or `SaveChangesAsync()` operation.  The interface includes methods that are called before and after commits, after documents are loaded or added for storage. It also shows the `IChangeListener` interface to carry out actions on projected documents during the execution of async projections.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/diagnostics.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IChangeListener\n{\n    /// <summary>\n    /// Used to carry out actions on potentially changed projected documents generated and updated\n    /// during the execution of asynchronous projections. This will give you \"at most once\" delivery guarantees\n    /// </summary>\n    /// <param name=\"session\"></param>\n    /// <param name=\"commit\"></param>\n    /// <param name=\"token\"></param>\n    /// <returns></returns>\n    Task AfterCommitAsync(IDocumentSession session, IChangeSet commit, CancellationToken token);\n\n    /// <summary>\n    /// Used to carry out actions on potentially changed projected documents generated and updated\n    /// during the execution of asynchronous projections. This will execute *before* database changes\n    /// are committed. Use this for \"at least once\" delivery guarantees.\n    /// </summary>\n    /// <param name=\"session\"></param>\n    /// <param name=\"commit\"></param>\n    /// <param name=\"token\"></param>\n    /// <returns></returns>\n    Task BeforeCommitAsync(IDocumentSession session, IChangeSet commit, CancellationToken token);\n}\n\n/// <summary>\n///     Used to listen to and intercept operations within an IDocumentSession.SaveChanges()/SaveChangesAsync()\n///     operation\n/// </summary>\npublic interface IDocumentSessionListener\n{\n    /// <summary>\n    ///     After an IDocumentSession is committed\n    /// </summary>\n    /// <param name=\"session\"></param>\n    /// <param name=\"commit\"></param>\n    /// <param name=\"token\"></param>\n    /// <returns></returns>\n    Task AfterCommitAsync(IDocumentSession session, IChangeSet commit, CancellationToken token);\n\n    /// <summary>\n    ///     Called just after IDocumentSession.SaveChanges() is called, but before\n    ///     any database calls are made\n    /// </summary>\n    /// <param name=\"session\"></param>\n    void BeforeSaveChanges(IDocumentSession session);\n\n    /// <summary>\n    ///     Called just after IDocumentSession.SaveChanges() is called,\n    ///     but before any database calls are made\n    /// </summary>\n    /// <param name=\"session\"></param>\n    /// <param name=\"token\"></param>\n    /// <returns></returns>\n    Task BeforeSaveChangesAsync(IDocumentSession session, CancellationToken token);\n\n    /// <summary>\n    ///     After an IDocumentSession is committed\n    /// </summary>\n    /// <param name=\"session\"></param>\n    /// <param name=\"commit\"></param>\n    void AfterCommit(IDocumentSession session, IChangeSet commit);\n\n    /// <summary>\n    ///     Called after a document is loaded\n    /// </summary>\n    void DocumentLoaded(object id, object document);\n\n    /// <summary>\n    ///     Called after a document is explicitly added to a session\n    ///     as a staged insert or update\n    /// </summary>\n    void DocumentAddedForStorage(object id, object document);\n}\n```\n\n----------------------------------------\n\nTITLE: Registering IDocumentSessionListener in Marten (C#)\nDESCRIPTION: This snippet shows how to register a custom `IDocumentSessionListener` with the `DocumentStore` using the `StoreOptions` object.  The listener is added to the `Listeners` collection within the `StoreOptions`, making it available for handling document session events. This registration occurs during the configuration of the `DocumentStore`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/diagnostics.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n    _.Connection(\"some connection string\");\n\n    // Add your custom listener\n    _.Listeners.Add(new MyDocumentSessionListener());\n});\n```\n\n----------------------------------------\n\nTITLE: Registering Inline Aggregates with Identity Map in Marten\nDESCRIPTION: This snippet shows how to register an `Order` aggregate as `Inline` in Marten and enable the `UseIdentityMapForAggregates` flag for performance optimization. This optimization ensures that the aggregate document fetched by `FetchForWriting()` is used as the starting point for updating the aggregate in its `Inline` projection. The Host and ServiceCollection are components of ASP.NET Core's dependency injection framework.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/scenarios/command_handler_workflow.md#_snippet_7\n\nLANGUAGE: cs\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\nbuilder.Services.AddMarten(opts =>\n{\n    opts.Connection(\"some connection string\");\n\n    // The Order aggregate is updated Inline inside the\n    // same transaction as the events being appended\n    opts.Projections.Snapshot<Order>(SnapshotLifecycle.Inline);\n\n    // Opt into an optimization for the inline aggregates\n    // used with FetchForWriting()\n    opts.Projections.UseIdentityMapForAggregates = true;\n})\n\n// This is also a performance optimization in Marten to disable the\n// identity map tracking overall in Marten sessions if you don't\n// need that tracking at runtime\n.UseLightweightSessions();\n```\n\n----------------------------------------\n\nTITLE: Implementing ISoftDeleted Interface in Marten\nDESCRIPTION: This code snippet demonstrates how to implement the `ISoftDeleted` interface in a document class for Marten. This interface exposes metadata about whether a document is deleted and when it was deleted. The `Deleted` and `DeletedAt` properties will be automatically managed by Marten.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/deletes.md#_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\npublic class MySoftDeletedDoc: ISoftDeleted\n{\n    // Always have to have an identity of some sort\n    public Guid Id { get; set; }\n\n    // Is the document deleted? From ISoftDeleted\n    public bool Deleted { get; set; }\n\n    // When was the document deleted? From ISoftDeleted\n    public DateTimeOffset? DeletedAt { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Compiled Query for Open Issues (Marten)\nDESCRIPTION: This C# code defines a compiled query (`OpenIssues`) that retrieves all open `Issue` documents. Compiled queries improve performance by caching the parsed Linq expression. This query implements `ICompiledListQuery<Issue>`. It retrieves a list of `Issue` objects where `x.Open` is true.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/aspnetcore.md#_snippet_4\n\nLANGUAGE: cs\nCODE:\n```\npublic class OpenIssues: ICompiledListQuery<Issue>\n{\n    public Expression<Func<IMartenQueryable<Issue>, IEnumerable<Issue>>> QueryIs()\n    {\n        return q => q.Where(x => x.Open);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Value Types in Marten LINQ Queries with OrderBy\nDESCRIPTION: This code snippet demonstrates how to use value types within Marten LINQ queries, specifically with `OrderBy`. It creates several `LimitedDoc` instances, stores them in the database, and then queries them, ordering by the `Lower` value type property.  The test asserts that the returned IDs are in the correct order based on the `Lower` value.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/identity.md#_snippet_25\n\nLANGUAGE: cs\nCODE:\n```\n[Fact]\npublic async Task store_several_and_order_by()\n{\n    var doc1 = new LimitedDoc { Lower = LowerLimit.From(1), Upper = UpperLimit.From(20) };\n    var doc2 = new LimitedDoc { Lower = LowerLimit.From(5), Upper = UpperLimit.From(25) };\n    var doc3 = new LimitedDoc { Lower = LowerLimit.From(4), Upper = UpperLimit.From(15) };\n    var doc4 = new LimitedDoc { Lower = LowerLimit.From(3), Upper = UpperLimit.From(10) };\n\n    theSession.Store(doc1, doc2, doc3, doc4);\n    await theSession.SaveChangesAsync();\n\n    var ordered = await theSession\n        .Query<LimitedDoc>()\n        .OrderBy(x => x.Lower)\n        .Select(x => x.Id)\n        .ToListAsync();\n\n    ordered.ShouldHaveTheSameElementsAs(doc1.Id, doc4.Id, doc3.Id, doc2.Id);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Aggregate Events (C#)\nDESCRIPTION: This code defines a set of simple event types (Start, End, Restart, Increment) that will be used in the custom aggregate projection to modify the state of the aggregate document. These events are essential for tracking the state changes within the event stream.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/custom-aggregates.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic class Start\n{\n}\n\npublic class End\n{\n}\n\npublic class Restart\n{\n}\n\npublic class Increment\n{\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Marten Async Daemon Health Check with Time Toleration\nDESCRIPTION: This code snippet shows how to configure a Marten async daemon health check with a time tolerance. The `maxEventLag` parameter is set to 500, and `maxSameLagTime` is set to 30 seconds using `TimeSpan.FromSeconds(30)`. This means a projection must lag behind the `HighWaterMark` by more than `maxEventLag` for at least `maxSameLagTime` before being considered unhealthy. It also maps the health check endpoint to `/health`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/healthchecks.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n// Add HealthCheck\nServices.AddHealthChecks().AddMartenAsyncDaemonHealthCheck(maxEventLag: 500, maxSameLagTime: TimeSpan.FromSeconds(30));\n\n// Map HealthCheck Endpoint\napp.MapHealthChecks(\"/health\");\n```\n\n----------------------------------------\n\nTITLE: Configuring Initial Data with DocumentStore\nDESCRIPTION: This code snippet shows how to configure initial data seeding as part of the Marten document store configuration. The `initialData.Add()` method is used to register `IInitialData` implementations. The order in which they are added determines the order in which they are executed during document store initialization. This requires a Marten `DocumentStoreOptions` object.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/basics/initial_data.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n    // Other Marten configuration here...\n\n    _.initialData.Add(new InitialData());\n});\n```\n\n----------------------------------------\n\nTITLE: Deleting Aggregate by Event and Condition (Marten, C#)\nDESCRIPTION: Illustrates how to delete a Trip aggregate based on a condition involving the event and/or the current aggregate state within a Marten projection.  It uses the DeleteEvent<TEvent>(Func<TEvent, bool> filter) and DeleteEvent<TEvent>(Func<TAggregate, TEvent, bool> filter) overloads. Also shows async deletion using DeleteEventAsync and session query.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/aggregate-projections.md#_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\npublic class TripProjection: SingleStreamProjection<Trip>\n{\n    public TripProjection()\n    {\n        // The current Trip aggregate would be deleted if\n        // the Breakdown event is \"critical\"\n        DeleteEvent<Breakdown>(x => x.IsCritical);\n\n        // Alternatively, delete the aggregate if the trip\n        // is currently in New Mexico and the breakdown is critical\n        DeleteEvent<Breakdown>((trip, e) => e.IsCritical && trip.State == \"New Mexico\");\n\n        DeleteEventAsync<Breakdown>(async (session, trip, e) =>\n        {\n            var anyRepairShopsInState = await session.Query<RepairShop>()\n                .Where(x => x.State == trip.State)\n                .AnyAsync();\n\n            // Delete the trip if there are no repair shops in\n            // the current state\n            return !anyRepairShopsInState;\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Exempting Document Types with DoNotPartition Attribute in C#\nDESCRIPTION: This code snippet shows how to exempt a document type from table partitioning using the `[DoNotPartition]` attribute. This can be useful for tables that are expected to be small, where partitioning may not provide any benefits. Applying this attribute prevents Marten from creating partitions for this document type.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/multi-tenancy.md#_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\n[DoNotPartition]\npublic class DocThatShouldBeExempted1\n{\n    public Guid Id { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Identity Attribute\nDESCRIPTION: This code sample demonstrates how to use the `[Identity]` attribute to explicitly specify a property or field as the identifier for a Marten document. This is useful when the identifier doesn't follow the default naming convention (Id, id, ID).\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/identity/index.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n// SAMPLE: IdentityAttribute\nusing Marten.Schema;\n\npublic class DocWithAlternateId\n{\n    [Identity]\n    public Guid AlternateId { get; set; }\n}\n// ENDSAMPLE\n```\n\n----------------------------------------\n\nTITLE: Enabling Stream Archival Partitioning in C#\nDESCRIPTION: This snippet shows how to enable PostgreSQL table partitioning for hot/cold storage of archived events in Marten.  It configures Marten to use separate partition tables for active and archived events, improving performance.  Requires setting the `UseArchivedStreamPartitioning` option to `true` during Marten configuration.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/archiving.md#_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\nbuilder.Services.AddMarten(opts =>\n{\n    opts.Connection(\"some connection string\");\n\n    // Turn on the PostgreSQL table partitioning for\n    // hot/cold storage on archived events\n    opts.Events.UseArchivedStreamPartitioning = true;\n});\n```\n\n----------------------------------------\n\nTITLE: Duplicating to Multiple Fields in Marten\nDESCRIPTION: This snippet extends the previous example by showing how to duplicate an existing field's value to multiple new fields.  It copies the value from `t.String` to `t.StringField`, `t.Inner.String`, and `t.Inner.AnotherString` for a `Target` document.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/partial-updates-patching.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\ntheSession.Patch<Target>(target.Id).Duplicate(t => t.String,\n    t => t.StringField,\n    t => t.Inner.String,\n    t => t.Inner.AnotherString);\n```\n\n----------------------------------------\n\nTITLE: Generating a Database Patch - Bash\nDESCRIPTION: This bash command demonstrates how to create a database patch using the Marten command-line interface. The 'db-patch' command creates a SQL script containing the changes needed to update the database schema.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/schema/migrations.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ndotnet run -- db-patch [filename]\n```\n\n----------------------------------------\n\nTITLE: Loading Javascript Transformation Files in Marten (C#)\nDESCRIPTION: This C# code demonstrates how to load a Javascript transformation file into a Marten `IDocumentStore` during bootstrapping.  It configures the document store by adding a Javascript transformation function named 'get_fullname.js'. Marten then creates a `TransformFunction` object in the document store, which manages the construction and updates of a PLV8 function that wraps the Javascript to expose it to Postgresql.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/advanced/javascript_transformations.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nstoreOptions.Transforms.LoadFile(\"get_fullname.js\");\n```\n\n----------------------------------------\n\nTITLE: Delete Document by Id - Marten - C#\nDESCRIPTION: Deletes a single document from the Marten database by specifying its type and ID. This operation queues a pending deletion to the current IDocumentSession, which is executed when SaveChangesAsync() is called.  It requires an active IDocumentSession and the document's Guid identifier.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/deletes.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\ninternal Task DeleteByDocumentId(IDocumentSession session, Guid userId)\n{\n    // Tell Marten the type and identity of a document to\n    // delete\n    session.Delete<User>(userId);\n\n    return session.SaveChangesAsync();\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Marten with Nested Closure - C#\nDESCRIPTION: This snippet demonstrates how to add Marten to an `IServiceCollection` using a nested closure to configure Marten inline. It allows for more customization options directly within the service registration. The closure allows modifications to the `StoreOptions` object.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/integration.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:AddMartenByNestedClosure]>\n```\n\n----------------------------------------\n\nTITLE: Using Session Connection Directly in Marten (C#)\nDESCRIPTION: Illustrates how to access the underlying database connection within a Marten IQuerySession. Accessing the Connection property opens a \"sticky\" connection. The example shows how to execute a custom SQL query using the session's connection, leveraging a Weasel extension method for command creation and execution.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/sessions.md#_snippet_6\n\nLANGUAGE: cs\nCODE:\n```\npublic static async Task using_session_connection(IQuerySession session)\n{\n    // Accessing the session.Connection object will quietly open\n    // a \"sticky\" connection for the session\n    var openCount = await session.Connection\n\n        // This is using a helper extension method from Weasel\n        .CreateCommand(\"select count(*) from tasks where status = 'open'\")\n        .ExecuteScalarAsync();\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Postgresql Sequence with Marten (C#)\nDESCRIPTION: This C# code snippet shows how to manage Postgresql sequences within Marten. It defines a sequence named `version` within the `other` schema (if configured) and specifies the minimum value, maximum value, and starting value for the sequence.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/advanced/extensions.md#_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(_ =>\\n{\\n    _.DatabaseSchemaName = \"other\";\\n    _.Schema.Sequences.Definition(\"version\", \"other\").Min(5).Max(11).Start(7);\\n});\n```\n\n----------------------------------------\n\nTITLE: Time Travelling: Aggregate Stream at Point in Time in C#\nDESCRIPTION: This code snippet retrieves the state of the RoomsAvailability entity at a specific point in time using Marten's AggregateStreamAsync method. It uses the `timestamp` parameter to specify the point in time for the aggregation. It depends on the Marten event store being configured and a session (`theSession`) being available to interact with the event store.  It is essential to pass a valid `hotelId` and `pointOfTime` for retrieving the correct state.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/live-aggregates.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nvar roomsAvailabilityAtPointOfTime =\n    await theSession.Events\n        .AggregateStreamAsync<RoomsAvailability>(hotelId, timestamp: pointOfTime);\n```\n\n----------------------------------------\n\nTITLE: Upcasting Event using System.Text.Json in Marten\nDESCRIPTION: This snippet demonstrates how to implement an event upcaster using System.Text.Json to transform an old event (represented as a JsonDocument) into a new event type (ShoppingCartOpenedWithStatus).  It defines the EventTypeName and provides an Upcast method to perform the transformation by extracting properties from the old event JSON.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/versioning.md#_snippet_22\n\nLANGUAGE: cs\nCODE:\n```\npublic class ShoppingCartOpenedUpcaster:\n    EventUpcaster<ShoppingCartOpenedWithStatus>\n{\n    public override string EventTypeName => \"shopping_cart_opened\";\n\n    protected override ShoppingCartOpenedWithStatus Upcast(JsonDocument oldEventJson)\n    {\n        var oldEvent = oldEventJson.RootElement;\n\n        return new ShoppingCartOpenedWithStatus(\n            oldEvent.GetProperty(\"ShoppingCartId\").GetGuid(),\n            new Client(\n                oldEvent.GetProperty(\"ClientId\").GetGuid()\n            ),\n            ShoppingCartStatus.Opened\n        );\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Event Types in Marten (C#)\nDESCRIPTION: This snippet demonstrates how to explicitly register event types with Marten. This is necessary for deserializing event data from JSON when querying events before any have been appended. It is recommended for production environments where event queries might precede event appending.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/events/appending.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n// Establish the document store\nusing var store = DocumentStore.For(_ =>\n{\n    // Register the event type\n    _.Events.RegisterEventType<QuestStarted>();\n\n    // You can also register multiple event types at once\n    _.Events.RegisterEventTypes(typeof(MembersJoined), typeof(MembersDeparted));\n});\n```\n\n----------------------------------------\n\nTITLE: Subscribing an Inline Projection to Async at Highest Sequence\nDESCRIPTION: This snippet shows how to configure a Marten projection to start asynchronously at the highest event sequence number if no previous async daemon progress exists. It is used when migrating projections from inline to async without rebuilding.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/async-daemon.md#_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nopts\n    .Projections\n    .Snapshot<SimpleAggregate>(SnapshotLifecycle.Async, o =>\n    {\n        // This option tells Marten to start the async projection at the highest\n        // event sequence assigned as the processing floor if there is no previous\n        // async daemon progress for this projection\n        o.SubscribeAsInlineToAsync();\n    });\n```\n\n----------------------------------------\n\nTITLE: Live Aggregation via .Net in C#\nDESCRIPTION: This example illustrates how to fetch a stream of events and build an aggregate object completely live from the current event data using the `AggregateStream()` method. This retrieves the current state of the aggregate based on all events in the stream.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/events/projections/index.md#_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\n// SAMPLE: events-aggregate-on-the-fly\nusing var host = Host.CreateDefaultBuilder()\n    .ConfigureServices(services =>\n    {\n        services.AddMarten(opts =>\n        {\n            opts.Projections.SelfAggregate<QuestParty>();\n        });\n    }).Build();\n\nawait using (var scope = host.Services.CreateScope())\n{\n    var store = scope.ServiceProvider.GetRequiredService<IEventStore>();\n\n    var streamId = Guid.NewGuid();\n\n    await using (var session = store.OpenSession())\n    {\n        session.Events.Append(streamId,\n            new QuestStarted(streamId, \"Find the Orb of Power\", DateTime.Today),\n            new MembersJoined(new string[] { \"Legolas\", \"Gimli\", \"Gandalf\" }));\n\n        await session.SaveChangesAsync();\n    }\n\n    await using (var querySession = store.QuerySession())\n    {\n        // Go get the live aggregate\n        var party = await querySession.Events.AggregateStreamAsync<QuestParty>(streamId);\n    }\n}\n// ENDSAMPLE\n```\n\n----------------------------------------\n\nTITLE: Simple Compiled Query Example: FindByFirstName C#\nDESCRIPTION: This code snippet demonstrates a simple compiled query `FindByFirstName` in C# that retrieves the first user document with a matching first name. It uses a property `FirstName` to parameterize the query. The `QueryIs` method defines the Linq query used to filter the documents.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/compiled_queries.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic class FindByFirstName : ICompiledQuery<User, User>\n{\n    public string FirstName { get; set; }\n\n    public Expression<Func<IQueryable<User>, User>> QueryIs()\n    {\n        return query => query.FirstOrDefault(x => x.FirstName == FirstName);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Time Travelling: Aggregate Stream at Specific Version in C#\nDESCRIPTION: This code demonstrates retrieving the RoomsAvailability state at a specific version using AggregateStreamAsync. It uses the `version` parameter to specify which stream version to aggregate up to.  The code depends on a configured Marten event store and an active session (`theSession`). It's crucial to provide a valid `hotelId` and `specificVersion` for the aggregation.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/live-aggregates.md#_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nvar roomsAvailabilityAtVersion =\n    await theSession.Events\n        .AggregateStreamAsync<RoomsAvailability>(hotelId, version: specificVersion);\n```\n\n----------------------------------------\n\nTITLE: Customize Newtonsoft.Json CamelCase Casing\nDESCRIPTION: Demonstrates how to automatically format field names to `CamelCase` by changing the serialization settings in the `DocumentStore` options. This affects how field names are stored in the database.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/json/newtonsoft.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:customize_json_net_camelcase_casing_serialization]>\n```\n\n----------------------------------------\n\nTITLE: Configuring Event Stream Identity with Strings - C#\nDESCRIPTION: This code snippet demonstrates how to configure Marten's Event Store to use strings as the stream identity. It uses the `StoreOptions.Events.StreamIdentity` property to set the identity to `StreamIdentity.AsString`. This configuration is done once per store, and different identity types cannot be mixed.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/events/identity.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic class ConfigureStreamIdentity:\n    IDocumentConfiguration\n{\n    public void Configure(IDocumentStore store)\n    {\n        store.Options.Events.StreamIdentity = StreamIdentity.AsString;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using DefaultRetryPolicy in StoreOptions (C#)\nDESCRIPTION: This code snippet illustrates how to use the built-in `DefaultRetryPolicy` in Marten. It provides sane defaults for transient error handling and is plugged into the `StoreOptions` using the `RetryPolicy` method, similar to custom policies.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/advanced/retrypolicy.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n    _.Connection(\"your connection string\");\n    _.RetryPolicy<DefaultRetryPolicy>();\n});\n```\n\n----------------------------------------\n\nTITLE: Custom Aggregate Projection with Start and Stop (C#)\nDESCRIPTION: This code demonstrates a custom aggregate projection `StartAndStopProjection` that inherits from `CustomProjection<StartAndStopAggregate, Guid>`. It specifies how to apply events to the aggregate, including handling soft deletes and restarts. The `ApplyChangesAsync` method processes the events and updates the aggregate document state, including managing soft deletes and undoing them.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/custom-aggregates.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic class StartAndStopProjection: CustomProjection<StartAndStopAggregate, Guid>\n{\n    public StartAndStopProjection()\n    {\n        // I'm telling Marten that events are assigned to the aggregate\n        // document by the stream id\n        AggregateByStream();\n\n        // This is an optional, but potentially important optimization\n        // for the async daemon so that it sets up an allow list\n        // of the event types that will be run through this projection\n        IncludeType<Start>();\n        IncludeType<End>();\n        IncludeType<Restart>();\n        IncludeType<Increment>();\n    }\n\n    public override ValueTask ApplyChangesAsync(DocumentSessionBase session,\n        EventSlice<StartAndStopAggregate, Guid> slice, CancellationToken cancellation,\n        ProjectionLifecycle lifecycle = ProjectionLifecycle.Inline)\n    {\n        var aggregate = slice.Aggregate;\n\n        foreach (var data in slice.AllData())\n        {\n            switch (data)\n            {\n                case Start:\n                    aggregate = new StartAndStopAggregate\n                    {\n                        // Have to assign the identity ourselves\n                        Id = slice.Id\n                    };\n                    break;\n                case Increment when aggregate is { Deleted: false }:\n                    // Use explicit code to only apply this event\n                    // if the aggregate already exists\n                    aggregate.Increment();\n                    break;\n                case End when aggregate is { Deleted: false }:\n                    // This will be a \"soft delete\" because the aggregate type\n                    // implements the IDeleted interface\n                    session.Delete(aggregate);\n                    aggregate.Deleted = true; // Got to help Marten out a little bit here\n                    break;\n                case Restart when aggregate == null || aggregate.Deleted:\n                    // Got to \"undo\" the soft delete status\n                    session\n                        .UndoDeleteWhere<StartAndStopAggregate>(x => x.Id == slice.Id);\n                    break;\n            }\n        }\n\n        // THIS IS IMPORTANT. *IF* you want to use a CustomProjection with\n        // AggregateStreamAsync(), you must make this call\n        // FetchLatest() will work w/o any other changes though\n        slice.Aggregate = aggregate;\n\n        // Apply any updates!\n        if (aggregate != null)\n        {\n            session.Store(aggregate);\n        }\n\n        // We didn't do anything that required an asynchronous call\n        return new ValueTask();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing IMartenLogger and IMartenSessionLogger\nDESCRIPTION: This C# snippet provides a concrete implementation of both `IMartenLogger` and `IMartenSessionLogger` as `ConsoleMartenLogger`. It logs database commands and schema changes to the console, tracking successful commands, failures, and saved changes, including performance timing.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/diagnostics.md#_snippet_10\n\nLANGUAGE: cs\nCODE:\n```\npublic class ConsoleMartenLogger: IMartenLogger, IMartenSessionLogger\n{\n    private Stopwatch? _stopwatch;\n\n    public IMartenSessionLogger StartSession(IQuerySession session)\n    {\n        return this;\n    }\n\n    public void SchemaChange(string sql)\n    {\n        Console.WriteLine(\"Executing DDL change:\");\n        Console.WriteLine(sql);\n        Console.WriteLine();\n    }\n\n    public void LogSuccess(NpgsqlCommand command)\n    {\n        Console.WriteLine(command.CommandText);\n        foreach (var p in command.Parameters.OfType<NpgsqlParameter>())\n            Console.WriteLine($\"  {p.ParameterName}: {GetParameterValue(p)}\");\n    }\n\n    public void LogSuccess(NpgsqlBatch batch)\n    {\n        foreach (var command in batch.BatchCommands)\n        {\n            Console.WriteLine(command.CommandText);\n            foreach (var p in command.Parameters.OfType<NpgsqlParameter>())\n                Console.WriteLine($\"  {p.ParameterName}: {GetParameterValue(p)}\");\n        }\n    }\n\n    private static object? GetParameterValue(NpgsqlParameter p)\n    {\n        if (p.Value is IList enumerable)\n        {\n            var result = \"\";\n            for (var i = 0; i < Math.Min(enumerable.Count, 5); i++)\n            {\n                result += $\"[{i}] {enumerable[i]}; \";\n            }\n            if (enumerable.Count > 5) result += $\" + {enumerable.Count - 5} more\";\n            return result;\n        }\n        return p.Value;\n    }\n\n    public void LogFailure(NpgsqlCommand command, Exception ex)\n    {\n        Console.WriteLine(\"Postgresql command failed!\");\n        Console.WriteLine(command.CommandText);\n        foreach (var p in command.Parameters.OfType<NpgsqlParameter>())\n            Console.WriteLine($\"  {p.ParameterName}: {p.Value}\");\n        Console.WriteLine(ex);\n    }\n\n    public void LogFailure(NpgsqlBatch batch, Exception ex)\n    {\n        Console.WriteLine(\"Postgresql command failed!\");\n        foreach (var command in batch.BatchCommands)\n        {\n            Console.WriteLine(command.CommandText);\n            foreach (var p in command.Parameters.OfType<NpgsqlParameter>())\n                Console.WriteLine($\"  {p.ParameterName}: {p.Value}\");\n        }\n\n        Console.WriteLine(ex);\n    }\n\n    public void LogFailure(Exception ex, string message)\n    {\n        Console.WriteLine(\"Failure: \" + message);\n        Console.WriteLine(ex.ToString());\n    }\n\n    public void RecordSavedChanges(IDocumentSession session, IChangeSet commit)\n    {\n        _stopwatch?.Stop();\n\n        var lastCommit = commit;\n        Console.WriteLine(\n            $\"Persisted {lastCommit.Updated.Count()} updates in {_stopwatch?.ElapsedMilliseconds ?? 0} ms, {lastCommit.Inserted.Count()} inserts, and {lastCommit.Deleted.Count()} deletions\");\n    }\n\n    public void OnBeforeExecute(NpgsqlCommand command)\n    {\n        _stopwatch = new Stopwatch();\n        _stopwatch.Start();\n    }\n\n    public void OnBeforeExecute(NpgsqlBatch batch)\n    {\n        _stopwatch = new Stopwatch();\n        _stopwatch.Start();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Duplicated Enum Field Storage as Varchar in Marten\nDESCRIPTION: This code snippet demonstrates how to configure Marten to store duplicated enum fields as varchar. This is useful for maintaining compatibility with previous versions or specific data models where enum values are represented as strings in duplicated fields. By setting `DuplicatedFieldEnumStorage` to `EnumStorage.AsString`, Marten will persist enum values as strings in the database.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/migration_guide.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nDuplicatedFieldEnumStorage = EnumStorage.AsString;\n```\n\n----------------------------------------\n\nTITLE: Defining ICompiledQuery Interface in Marten\nDESCRIPTION: This interface defines the structure for compiled queries in Marten.  It specifies a method `QueryIs()` that returns an Expression representing a LINQ query. TDoc represents the document type, and TOut represents the query result type.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/compiled-queries.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface ICompiledQuery<TDoc, TOut> : ICompiledQueryMarker where TDoc: notnull\n{\n    Expression<Func<IMartenQueryable<TDoc>, TOut>> QueryIs();\n}\n```\n\n----------------------------------------\n\nTITLE: Filtering Events by Type with Marten (C#)\nDESCRIPTION: This snippet demonstrates how to filter raw events by event type using the `EventTypesAre()` extension method within a `Where()` clause. It allows limiting the types of events returned by the LINQ query. The example shows filtering for events of type `CEvent` and `DEvent` using `ToListAsync()`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/querying.md#_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nvar raw = await theSession.Events.QueryAllRawEvents()\n    .Where(x => x.EventTypesAre(typeof(CEvent), typeof(DEvent)))\n    .ToListAsync();\n```\n\n----------------------------------------\n\nTITLE: Configure Hierarchy of Types - C#\nDESCRIPTION: This snippet demonstrates how to configure Marten to store subclasses (SuperUser and AdminUser) as subclasses of a base class (User).  It uses the DocumentStore.For() configuration to specify the subclasses that belong to the User document type. This allows querying by User to retrieve instances of User, SuperUser, and AdminUser.  Dependencies: Marten library.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/advanced/hierarchies.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:configure-hierarchy-of-types]>\n```\n\n----------------------------------------\n\nTITLE: Integrate Custom Serializer with Marten\nDESCRIPTION: This snippet demonstrates how to integrate a custom serializer (`JilSerializer`) with Marten by implementing the `ISerializer` interface. It shows how to implement the required `ToJson` and `FromJson` methods for serialization and deserialization using a third-party library (`Jil`).\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/json.md#_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\npublic class JilSerializer : ISerializer\n{\n    private readonly Options _options\n        = new(dateFormat: DateTimeFormat.ISO8601, includeInherited:true);\n\n    public ValueCasting ValueCasting { get; } = ValueCasting.Strict;\n\n    public string ToJson(object? document)\n    {\n        return JSON.Serialize(document, _options);\n    }\n\n    public T FromJson<T>(Stream stream)\n    {\n        return JSON.Deserialize<T>(stream.GetStreamReader(), _options);\n    }\n\n    public T FromJson<T>(DbDataReader reader, int index)\n    {\n        var stream = reader.GetStream(index);\n        return FromJson<T>(stream);\n    }\n\n    public ValueTask<T> FromJsonAsync<T>(Stream stream, CancellationToken cancellationToken = default)\n    {\n        return new(FromJson<T>(stream));\n    }\n\n    public ValueTask<T> FromJsonAsync<T>(DbDataReader reader, int index, CancellationToken cancellationToken = default)\n    {\n        return new (FromJson<T>(reader, index));\n    }\n\n    public object FromJson(Type type, Stream stream)\n    {\n        return JSON.Deserialize(stream.GetStreamReader(), type, _options);\n    }\n\n    public object FromJson(Type type, DbDataReader reader, int index)\n    {\n        var stream = reader.GetStream(index);\n        return FromJson(type, stream);\n    }\n\n    public ValueTask<object> FromJsonAsync(Type type, Stream stream, CancellationToken cancellationToken = default)\n    {\n        return new (FromJson(type, stream));\n    }\n\n    public ValueTask<object> FromJsonAsync(Type type, DbDataReader reader, int index, CancellationToken cancellationToken = default)\n    {\n        return new (FromJson(type, reader, index));\n    }\n\n    public string ToCleanJson(object? document)\n    {\n        return ToJson(document);\n    }\n\n    public EnumStorage EnumStorage => EnumStorage.AsString;\n    public Casing Casing => Casing.Default;\n    public string ToJsonWithTypes(object document)\n    {\n        throw new NotSupportedException();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Indexing Duplicated Fields using Fluent Interface - C#\nDESCRIPTION: Illustrates how to define and customize duplicated fields and their indexes in Marten using the fluent interface off of `StoreOptions`. It includes examples of adding a gin index, setting Postgresql database types, adding not null constraints, customizing index names, setting index methods, defining unique indexes, and setting sort order. This approach configures how Marten interacts with the database schema.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/indexing/duplicated-fields.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(options =>\n{\n    // Add a gin index to the User document type\n    options.Schema.For<User>().GinIndexJsonData();\n\n    // Adds a basic btree index to the duplicated\n    // field for this property that also overrides\n    // the Postgresql database type for the column\n    options.Schema.For<User>().Duplicate(x => x.FirstName, pgType: \"varchar(50)\");\n\n    // Defining a duplicate column with not null constraint\n    options.Schema.For<User>().Duplicate(x => x.Department, pgType: \"varchar(50)\", notNull: true);\n\n    // Customize the index on the duplicated field\n    // for FirstName\n    options.Schema.For<User>().Duplicate(x => x.FirstName, configure: idx =>\n    {\n        idx.Name = \"idx_special\";\n        idx.Method = IndexMethod.hash;\n    });\n\n    // Customize the index on the duplicated field\n    // for UserName to be unique\n    options.Schema.For<User>().Duplicate(x => x.UserName, configure: idx =>\n    {\n        idx.IsUnique = true;\n    });\n\n    // Customize the index on the duplicated field\n    // for LastName to be in descending order\n    options.Schema.For<User>().Duplicate(x => x.LastName, configure: idx =>\n    {\n        idx.SortOrder = SortOrder.Desc;\n    });\n});\n```\n\n----------------------------------------\n\nTITLE: Modulo Query with Marten (C#)\nDESCRIPTION: This code snippet demonstrates how to use the modulo operator (`%`) in a Marten Linq query. It stores several `Target` objects with different `Number` and `Color` values, then queries for `Target` objects where the `Number` property modulo 2 is equal to 0 and the `Color` is less than `Colors.Green`.  The results are asserted to contain the expected `Number` values. It depends on xUnit for testing and Shouldly for assertions.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/operators.md#_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic async Task use_modulo()\n{\n    theSession.Store(new Target{Color = Colors.Blue, Number = 1});\n    theSession.Store(new Target{Color = Colors.Blue, Number = 2});\n    theSession.Store(new Target{Color = Colors.Blue, Number = 3});\n    theSession.Store(new Target{Color = Colors.Blue, Number = 4});\n    theSession.Store(new Target{Color = Colors.Blue, Number = 5});\n    theSession.Store(new Target{Color = Colors.Green, Number = 6});\n\n    await theSession.SaveChangesAsync();\n\n    theSession.Query<Target>().Where(x => x.Number % 2 == 0 && x.Color < Colors.Green).ToArray()\n        .Select(x => x.Number)\n        .ShouldHaveTheSameElementsAs(2, 4);\n}\n```\n\n----------------------------------------\n\nTITLE: Registering an Aggregate Projection - C#\nDESCRIPTION: This code demonstrates how to register a `TripProjection` with the Marten `DocumentStore`.  It shows how to register the projection to run either inline (synchronously) or asynchronously using `ProjectionLifecycle.Inline` and `ProjectionLifecycle.Async` respectively. It requires a connection string to the Marten database.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/aggregate-projections.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(opts =>\n{\n    opts.Connection(\"some connection string\");\n\n    // Register as inline\n    opts.Projections.Add<TripProjection>(ProjectionLifecycle.Inline);\n\n    // Or instead, register to run asynchronously\n    opts.Projections.Add<TripProjection>(ProjectionLifecycle.Async);\n});\n```\n\n----------------------------------------\n\nTITLE: Configure Marten Events for Multi-Tenancy in C#\nDESCRIPTION: This snippet configures a Marten DocumentStore to support multi-tenancy for event storage. It sets the TenancyStyle to Conjoined, which means that events are stored alongside each other but are differentiated by tenant. It requires a connection string to the database.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/multitenancy.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(opts =>\n{\n    opts.Connection(\"some connection string\");\n\n    // And that's all it takes, the events are now multi-tenanted\n    opts.Events.TenancyStyle = TenancyStyle.Conjoined;\n});\n```\n\n----------------------------------------\n\nTITLE: Registering Upcaster Class in Marten\nDESCRIPTION: This snippet demonstrates how to register an event upcaster with Marten's event store options.  The `options.Events.Upcast<ShoppingCartOpenedUpcaster>()` line adds the ShoppingCartOpenedUpcaster to the list of upcasters that Marten will use when deserializing events.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/versioning.md#_snippet_24\n\nLANGUAGE: cs\nCODE:\n```\noptions.Events.Upcast<ShoppingCartOpenedUpcaster>();\n```\n\n----------------------------------------\n\nTITLE: Searching String Fields in Marten with Linq\nDESCRIPTION: Demonstrates how to search string fields using Marten's Linq support with `StartsWith`, `EndsWith`, `Contains`, and `Equals` methods. Requires an `IDocumentSession` and a document type with a string property.  These queries are case-sensitive.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/strings.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic void string_fields(IDocumentSession session)\n{\n    session.Query<Target>().Where(x => x.String.StartsWith(\"A\"));\n    session.Query<Target>().Where(x => x.String.EndsWith(\"Suffix\"));\n\n    session.Query<Target>().Where(x => x.String.Contains(\"something\"));\n    session.Query<Target>().Where(x => x.String.Equals(\"The same thing\"));\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring GIN and BTree Indexes for Marten Documents (C#)\nDESCRIPTION: This code snippet demonstrates how to configure GIN indexes on the User document's JSON data, create basic BTree indexes on duplicated fields, define duplicated columns with NOT NULL constraints, and customize indexes using IndexMethod and SortOrder within a Marten DocumentStore configuration. The code utilizes the Marten API to specify index types and constraints for document properties.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/indexing/gin-gist-indexes.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar store = DocumentStore.For(options =>\n{\n    // Add a gin index to the User document type\n    options.Schema.For<User>().GinIndexJsonData();\n\n    // Adds a basic btree index to the duplicated\n    // field for this property that also overrides\n    // the Postgresql database type for the column\n    options.Schema.For<User>().Duplicate(x => x.FirstName, pgType: \"varchar(50)\");\n\n    // Defining a duplicate column with not null constraint\n    options.Schema.For<User>().Duplicate(x => x.Department, pgType: \"varchar(50)\", notNull: true);\n\n    // Customize the index on the duplicated field\n    // for FirstName\n    options.Schema.For<User>().Duplicate(x => x.FirstName, configure: idx =>\n    {\n        idx.Name = \"idx_special\";\n        idx.Method = IndexMethod.hash;\n    });\n\n    // Customize the index on the duplicated field\n    // for UserName to be unique\n    options.Schema.For<User>().Duplicate(x => x.UserName, configure: idx =>\n    {\n        idx.IsUnique = true;\n    });\n\n    // Customize the index on the duplicated field\n    // for LastName to be in descending order\n    options.Schema.For<User>().Duplicate(x => x.LastName, configure: idx =>\n    {\n        idx.SortOrder = SortOrder.Desc;\n    });\n});\n```\n\n----------------------------------------\n\nTITLE: Getting PostgreSQL Version (C#)\nDESCRIPTION: This code snippet demonstrates how to fetch the PostgreSQL server version using `IDocumentStore.Diagnostics.GetPostgresVersion()`.  This is helpful for enabling feature toggles based on PostgreSQL version features or performing diagnostics.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/diagnostics.md#_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\nusing var store = DocumentStore.For(_ =>\n{\n    _.Connection(\"some connection string\");\n});\n\nvar pgVersion = await store.Diagnostics.GetPostgresVersion();\nConsole.WriteLine(pgVersion);\n```\n\n----------------------------------------\n\nTITLE: Configuring Polly in Marten (C#)\nDESCRIPTION: This snippet demonstrates how to replace the default Polly configuration in Marten. It configures a new retry policy that handles NpgsqlException and MartenCommandException with a maximum of 10 retry attempts and a linear backoff strategy.  It requires a connection string to the database.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/retries.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nusing var store = DocumentStore.For(opts =>\n{\n    opts.Connection(\"some connection string\");\n\n    opts.ConfigurePolly(builder =>\n    {\n        builder.AddRetry(new()\n        {\n            ShouldHandle = new PredicateBuilder().Handle<NpgsqlException>().Handle<MartenCommandException>(),\n            MaxRetryAttempts = 10, // this is excessive, but just wanted to show something different\n            Delay = TimeSpan.FromMilliseconds(50),\n            BackoffType = DelayBackoffType.Linear\n        });\n    });\n});\n```\n\n----------------------------------------\n\nTITLE: Upcasting Event with Json.NET JObject\nDESCRIPTION: This snippet demonstrates raw JSON transformation using Json.NET's `JObject`. It upcasts an event by accessing the old event data as a `JObject` and mapping its properties to the new event type. `options.UseNewtonsoftForSerialization()` must be called before configuring the upcast.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/versioning.md#_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\noptions.UseNewtonsoftForSerialization();\n\noptions.Events\n    .Upcast<ShoppingCartOpenedWithStatus>(\n        \"shopping_cart_opened\",\n        Upcast(oldEvent =>\n            new ShoppingCartOpenedWithStatus(\n                (Guid)oldEvent[\"ShoppingCartId\"]!,\n                new Client(\n                    (Guid)oldEvent[\"ClientId\"]!\n                ),\n                ShoppingCartStatus.Opened\n            )\n        )\n    );\n```\n\n----------------------------------------\n\nTITLE: Fetching Events for a Stream in Marten (C#)\nDESCRIPTION: Demonstrates how to retrieve events for a single stream using the `IEventStore.FetchStream()` method in Marten. The returned data is a list of `IEvent` objects, where each is a strongly-typed `Event<T>` object.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/events/streams.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:using-fetch-stream]>\n```\n\n----------------------------------------\n\nTITLE: Creating Distance Projection with Travel Event in Marten (C#)\nDESCRIPTION: This code snippet demonstrates how to create a new `Distance` document within a Marten event projection based on a `Travel` event. It defines a `DistanceProjection` class inheriting from `EventProjection` and implements the `Create` method to generate a `Distance` object using data from the `Travel` event and the event metadata.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/rebuilding.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic class DistanceProjection: EventProjection\n{\n    public DistanceProjection()\n    {\n        ProjectionName = \"Distance\";\n    }\n\n    // Create a new Distance document based on a Travel event\n    public Distance Create(Travel travel, IEvent e)\n    {\n        return new Distance {Id = e.Id, Day = travel.Day, Total = travel.TotalDistance()};\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Schema Function in Marten (C#)\nDESCRIPTION: This snippet shows how to create a custom Postgresql function using `Weasel.Postgresql.Functions.Function` and add it to Marten's extended schema objects. It defines a function named 'iif' that acts as a ternary operator and applies the configuration changes to the database.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/schema/extensions.md#_snippet_3\n\nLANGUAGE: cs\nCODE:\n```\nStoreOptions(opts =>\n{\n    opts.RegisterDocumentType<Target>();\n\n    // Create a user defined function to act as a ternary operator similar to SQL Server\n    var function = new Function(new PostgresqlObjectName(\"public\", \"iif\"), @\"\ncreate or replace function iif(\ncondition boolean,       -- if condition\ntrue_result anyelement,  -- then\nfalse_result anyelement  -- else\n) returns anyelement as $f$\nselect case when condition then true_result else false_result end\n$f$  language sql immutable;\n\");\n\n    opts.Storage.ExtendedSchemaObjects.Add(function);\n});\n\nawait theStore.Storage.ApplyAllConfiguredChangesToDatabaseAsync();\n```\n\n----------------------------------------\n\nTITLE: Waiting for Non-Stale Projection Data from IHost\nDESCRIPTION: Shows how to access and use the `WaitForNonStaleProjectionDataAsync()` extension method on an `IHost` instance in integration tests to wait for async projections to catch up.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/async-daemon.md#_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic async Task run_simultaneously()\n{\n    var host = await StartDaemonInHotColdMode();\n\n    StoreOptions(x => x.Projections.Add(new DistanceProjection(), ProjectionLifecycle.Async));\n\n    NumberOfStreams = 10;\n\n    var agent = await StartDaemon();\n\n    // This method publishes a random number of events\n    await PublishSingleThreaded();\n\n    // Wait for all projections to reach the highest event sequence point\n    // as of the time this method is called\n    await host.WaitForNonStaleProjectionDataAsync(15.Seconds());\n\n    await CheckExpectedResults();\n}\n```\n\n----------------------------------------\n\nTITLE: Synchronous Batch Query with Compiled Queries in Marten (C#)\nDESCRIPTION: Demonstrates synchronous execution of a batch query in Marten using the `ExecuteSynchronously()` method. The mechanics are identical to the asynchronous version except for the execution method.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/batched_queries.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic void batch_query_with_compiled_queries_synchronously(IDocumentStore store)\n{\n    using (var session = store.OpenSession())\n    {\n        var user1 = new User { FirstName = \"Jeremy\", LastName = \"Miller\" };\n        var user2 = new User { FirstName = \"Max\", LastName = \"Lewandowski\" };\n        var user3 = new User { FirstName = \"Jeremy\", LastName = \"D\" };\n\n        session.Store(user1);\n        session.Store(user2);\n        session.Store(user3);\n\n        session.SaveChanges();\n    }\n\n    using (var session = store.OpenSession())\n    {\n        var batch = session.CreateBatchQuery();\n\n        // Issue a couple different queries within the batch\n        var jeremysTodos = batch.Query<User>(new FindByFirstName(\"Jeremy\"));\n\n        // This *starts* the execution of the batched query\n        batch.ExecuteSynchronously();\n\n        // All results are available immediately\n        var user = jeremysTodos.Result;\n\n        Debug.WriteLine(user.FirstName);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Marten to use New Event Namespace C#\nDESCRIPTION: This code snippet demonstrates how to configure Marten to use the `OrderStatusChanged` event class from the `NewEventNamespace` when persisting events. It creates a `StoreOptions` instance and uses the `Events.AddEventType` method to register the new event type. This configuration allows Marten to correctly map events to the new namespace without manual type mapping.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/versioning.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nvar options = new StoreOptions();\n\noptions.Events.AddEventType<NewEventNamespace.OrderStatusChanged>();\n\nvar store = new DocumentStore(options);\n```\n\n----------------------------------------\n\nTITLE: Initializing DocumentStore with Configuration (C#)\nDESCRIPTION: This snippet demonstrates how to initialize a `DocumentStore` with a custom configuration using `StoreOptions`.  This allows for overriding default JSON serialization, tweaking document storage performance, and opting into Postgresql 9.5's \"upsert\" capability. It allows for more control over the database schema creation.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/index.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:start_a_complex_store]>\n```\n\n----------------------------------------\n\nTITLE: Initializing Marten DocumentStore Eagerly in C#\nDESCRIPTION: This code snippet shows how to force Marten to initialize the `DocumentStore` eagerly during application startup. It configures Marten using the connection string, enables the optimized artifact workflow, and calls `InitializeWith()` to initialize the `DocumentStore` immediately.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/hostbuilder.md#_snippet_22\n\nLANGUAGE: cs\nCODE:\n```\nvar connectionString = Configuration.GetConnectionString(\"postgres\");\n\n// By only the connection string\nservices.AddMarten(connectionString)\n    // Using the \"Optimized artifact workflow\" for Marten >= V5\n    // sets up your Marten configuration based on your environment\n    // See https://martendb.io/configuration/optimized_artifact_workflow.html\n    .OptimizeArtifactWorkflow()\n    // Spin up the DocumentStore right this second!\n    .InitializeWith();\n```\n\n----------------------------------------\n\nTITLE: Customize JSON Field Name Casing (C#)\nDESCRIPTION: This snippet demonstrates how to customize the casing of field names in the JSON output. It shows how to configure both Newtonsoft.Json and System.Text.Json to use CamelCase instead of the default PascalCase. Dependencies: Marten DocumentStore.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/json.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n    // Newtonsoft // [!code focus:5]\n    _.UseNewtonsoftForSerialization(casing: Casing.CamelCase);\n\n    // STJ\n    _.UseSystemTextJsonForSerialization(casing: Casing.CamelCase);\n});\n```\n\n----------------------------------------\n\nTITLE: Assert Database Matches Marten Configuration (C#)\nDESCRIPTION: Demonstrates how to perform a complete check of Marten's configuration against the active Postgresql database. This validates the configuration and throws an exception if any differences are found. This is useful for environment tests.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/schema/migrations.md#_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n[sample:AssertDatabaseMatchesConfiguration]\n```\n\n----------------------------------------\n\nTITLE: Streaming Related Documents and Scalar Data in Marten using AdvancedSql\nDESCRIPTION: This snippet shows how to efficiently stream large datasets of related documents and scalar data using `session.AdvancedSql.StreamAsync<T1, T2, T3>()`. It constructs an `IAsyncEnumerable` to iterate over the results, avoiding loading the entire dataset into memory at once.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/advanced-sql.md#_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nsession.Store(new DocWithMeta { Id = 1, Name = \"Max\" });\nsession.Store(new DocDetailsWithMeta { Id = 1, Detail = \"Likes bees\" });\nsession.Store(new DocWithMeta { Id = 2, Name = \"Michael\" });\nsession.Store(new DocDetailsWithMeta { Id = 2, Detail = \"Is a good chess player\" });\nsession.Store(new DocWithMeta { Id = 3, Name = \"Anne\" });\nsession.Store(new DocDetailsWithMeta { Id = 3, Detail = \"Hates soap operas\" });\nsession.Store(new DocWithMeta { Id = 4, Name = \"Beatrix\" });\nsession.Store(new DocDetailsWithMeta { Id = 4, Detail = \"Likes to cook\" });\nawait session.SaveChangesAsync();\n\nvar schema = session.DocumentStore.Options.Schema;\n\nvar asyncEnumerable = session.AdvancedSql.StreamAsync<DocWithMeta, DocDetailsWithMeta, long>(\n        $\"\"\"\n        select\n          row(a.id, a.data, a.mt_version),\n          row(b.id, b.data, b.mt_version),\n          row(count(*) over())\n        from\n          {schema.For<DocWithMeta>()} a\n        left join\n          {schema.For<DocDetailsWithMeta>()} b on a.id = b.id\n        where\n          (a.data ->> 'Id')::int > 1\n        order by\n          a.data ->> 'Name'\n        \"\"\");\n```\n\n----------------------------------------\n\nTITLE: Querying with Structural Typing in C#\nDESCRIPTION: This example demonstrates how to query the database to retrieve `Area2.Product` objects from the storage of `Area1.Product` documents, utilizing the structural typing configuration.  It shows how Marten can fetch the subset of data based on the `Area2.Product` structure.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/advanced/structural_typing.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic async Task can_select_from_the_same_table()\n{\n    await using var session = theStore.LightweightSession();\n\n    var product1 = new Area1.Product { Id = Guid.NewGuid(), Name = \"Hammer\", Description = \"A useful tool\", Cost = 20 };\n    var product2 = new Area1.Product { Id = Guid.NewGuid(), Name = \"Saw\", Description = \"Another useful tool\", Cost = 30 };\n\n    session.Store(product1, product2);\n    await session.SaveChangesAsync();\n\n    var results = await session.Query<Area2.Product>().ToListAsync();\n\n    results.Count.ShouldBe(2);\n    results.Any(x => x.Name == \"Hammer\").ShouldBeTrue();\n    results.Any(x => x.Name == \"Saw\").ShouldBeTrue();\n}\n```\n\n----------------------------------------\n\nTITLE: Resetting HiLo Sequence Floor in Marten\nDESCRIPTION: This code snippet shows how to reset the HiLo sequence floor for a specific document type in Marten. This is useful when importing data from an existing data source and needing to ensure that newly assigned IDs are higher than a certain value.  The snippet requires a database connection string and the document type for which to reset the sequence.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/identity.md#_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(opts =>\n{\n    opts.Connection(ConnectionSource.ConnectionString);\n    opts.DatabaseSchemaName = \"sequences\";\n});\n\n// Resets the minimum Id number for the IntDoc document\n// type to 2500\nawait store.Tenancy.Default.Database.ResetHiloSequenceFloor<IntDoc>(2500);\n```\n\n----------------------------------------\n\nTITLE: Configure Cascading Deletes with Configuration Function - C#\nDESCRIPTION: Demonstrates how to enable cascading deletes on a foreign key relationship in Marten using a configuration function.  When cascading deletes are enabled, deleting a parent record will automatically delete related child records.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/foreign_keys.md#_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:cascade_deletes_with_config_func]>\n```\n\n----------------------------------------\n\nTITLE: Querying for Multiple Results as JSON Array - C#\nDESCRIPTION: This C# code demonstrates how to create a compiled query (`FindJsonOrderedUsersByUsername`) that returns multiple user results as a JSON array. It implements `ICompiledListQuery<User>` and defines the `QueryIs()` method to filter users by `FirstName` and order them by `UserName`.  The implicit `ToJsonArray()` call is not present in this snippet but is part of how this compiled query is used.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/compiled-queries.md#_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\npublic class FindJsonOrderedUsersByUsername: ICompiledListQuery<User>\n{\n    public string FirstName { get; set; }\n\n    Expression<Func<IMartenQueryable<User>, IEnumerable<User>>> ICompiledQuery<User, IEnumerable<User>>.QueryIs()\n    {\n        return query =>\n            query.Where(x => FirstName == x.FirstName)\n                .OrderBy(x => x.UserName);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Combined Text and Linq Query - Marten C#\nDESCRIPTION: Combines a phrase search with another Linq query (filtering by `Category`). This example demonstrates how text search can be integrated with other query constraints. Requires the Marten library.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/full-text.md#_snippet_15\n\nLANGUAGE: cs\nCODE:\n```\nvar posts = session.Query<BlogPost>()\n    .Where(x => x.Category == \"LifeStyle\")\n    .Where(x => x.PhraseSearch(\"somefilter\"))\n    .ToList();\n```\n\n----------------------------------------\n\nTITLE: Add Subclass Hierarchy with Aliases - C#\nDESCRIPTION: This snippet demonstrates how to configure document type hierarchies with aliases in Marten. It shows how to map subclasses with custom aliases to the base class. It takes `MappedType` as parameters, which contains both the type and alias. This allows querying against the base class and retrieving the subclass documents with the specific aliases. Dependencies: Marten library.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/advanced/hierarchies.md#_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:add-subclass-hierarchy-with-aliases]>\n```\n\n----------------------------------------\n\nTITLE: Defining Event Types for Flat Table Projection (C#)\nDESCRIPTION: Defines the C# record types representing the events that will be projected into the flat table.  These records include `ImportStarted`, `ImportProgress`, `ImportFinished`, and `ImportFailed`.  They represent different stages of a file import process and contain relevant data for each stage. These records are used by both SQL and FlatTableProjection examples.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/flat.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\npublic record ImportStarted(\n    DateTimeOffset Started,\n    string ActivityType,\n    string CustomerId,\n    int PlannedSteps);\n\npublic record ImportProgress(\n    string StepName,\n    int Records,\n    int Invalids);\n\npublic record ImportFinished(DateTimeOffset Finished);\n\npublic record ImportFailed;\n```\n\n----------------------------------------\n\nTITLE: Implementing IDocumentSessionListener in Marten (C#)\nDESCRIPTION: This snippet demonstrates how to implement the `IDocumentSessionListener` interface in Marten to listen for and intercept document persistence events.  This allows for modification of the `IDocumentSession` and its related unit of work before persisting data to the database. The interface includes methods for actions before and after commits, and on document inserts, updates, and deletions.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/diagnostics.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IDocumentSessionListener\n{\n    // Called *before* calling SaveChanges/SaveChangesAsync\n    void BeforeSaveChanges(IDocumentSession session);\n\n    // Called *after* a successful SaveChanges/SaveChangesAsync\n    // invocation\n    void AfterCommit(IDocumentSession session);\n\n    // Called *after* a failed SaveChanges/SaveChangesAsync\n    // invocation\n    void AfterRollback(IDocumentSession session, Exception ex);\n\n    // Called *before* a document is inserted\n    void DocumentInserted<T>(IDocumentSession session, T document);\n\n    // Called *before* a document is updated\n    void DocumentUpdated<T>(IDocumentSession session, T document);\n\n    // Called *before* a document is deleted\n    void DocumentDeleted<T>(IDocumentSession session, T document);\n\n    // Called *before* a document is soft-deleted\n    void DocumentSoftDeleted<T>(IDocumentSession session, T document);\n}\n```\n\n----------------------------------------\n\nTITLE: Using Compiled Query with JSON Streaming (Marten)\nDESCRIPTION: This C# code demonstrates how to use a compiled query (`OpenIssues`) to write an array of documents to the HTTP response using `session.WriteArray`.  It streams the results of the compiled query as a JSON array to `HttpContext.Response.Body`.  Dependency: `IQuerySession` and `OpenIssues` compiled query.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/aspnetcore.md#_snippet_5\n\nLANGUAGE: cs\nCODE:\n```\n[HttpGet(\"/issue2/open\")]\npublic Task OpenIssues2([FromServices] IQuerySession session, [FromQuery] string? sc = null)\n{\n    return sc is null\n        ? session.WriteArray(new OpenIssues(), HttpContext)\n        : session.WriteArray(new OpenIssues(), HttpContext, onFoundStatus: int.Parse(sc));\n}\n```\n\n----------------------------------------\n\nTITLE: Update with Stale Version - C#\nDESCRIPTION: This code snippet demonstrates a concurrency conflict using optimistic concurrency. It simulates two sessions loading the same document, modifying it in each session, and then attempting to save the changes.  The first session to save succeeds, while the second session throws a `ConcurrencyException` because its version is stale. The exception message confirms the failure is due to optimistic concurrency. It requires `theStore` which is a Marten `DocumentStore` instance and the `CoffeeShop` document type configured for optimistic concurrency.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/concurrency.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic async Task update_with_stale_version_standard()\n{\n    var doc1 = new CoffeeShop();\n    using (var session = theStore.LightweightSession())\n    {\n        session.Store(doc1);\n        await session.SaveChangesAsync();\n    }\n\n    var session1 = theStore.DirtyTrackedSession();\n    var session2 = theStore.DirtyTrackedSession();\n\n    var session1Copy = session1.Load<CoffeeShop>(doc1.Id);\n    var session2Copy = session2.Load<CoffeeShop>(doc1.Id);\n\n    try\n    {\n        session1Copy.Name = \"Mozart's\";\n        session2Copy.Name = \"Dominican Joe's\";\n\n        // Should go through just fine\n        await session2.SaveChangesAsync();\n\n        var ex = await Should.ThrowAsync<ConcurrencyException>(async () =>\n        {\n            await session1.SaveChangesAsync();\n        });\n\n        ex.Message.ShouldBe($\"Optimistic concurrency check failed for {typeof(Shop).FullName} #{doc1.Id}\");\n    }\n    finally\n    {\n        session1.Dispose();\n        session2.Dispose();\n    }\n\n    await using var query = theStore.QuerySession();\n    query.Load<CoffeeShop>(doc1.Id).Name.ShouldBe(\"Dominican Joe's\");\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Schema Table in Marten (C#)\nDESCRIPTION: This snippet shows how to create a custom table using `Weasel.Postgresql.Tables.Table` and add it to Marten's extended schema objects.  It registers a document type and defines a table with a string column as primary key, and applies the configuration changes to the database.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/schema/extensions.md#_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\nStoreOptions(opts =>\n{\n    opts.RegisterDocumentType<Target>();\n\n    var table = new Table(\"adding_custom_schema_objects.names\");\n    table.AddColumn<string>(\"name\").AsPrimaryKey();\n\n    opts.Storage.ExtendedSchemaObjects.Add(table);\n});\n\nawait theStore.Storage.ApplyAllConfiguredChangesToDatabaseAsync();\n```\n\n----------------------------------------\n\nTITLE: Previewing LINQ Command (C#)\nDESCRIPTION: This snippet demonstrates how to preview the SQL query that Marten will build for a LINQ query using the `IDocumentStore.Diagnostics.Explain` method.  It queries for every `Trade` document with a `Value` over 2,000 and retrieves the generated SQL command text.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/diagnostics.md#_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nusing var store = DocumentStore.For(_ =>\n{\n    _.Connection(\"some connection string\");\n});\n\nusing var session = store.OpenSession();\nvar command = store.Diagnostics.Explain(() =>\n{\n    return session.Query<Trade>().Where(x => x.Value > 2000).ToList();\n});\n\nDebug.WriteLine(command.CommandText);\n```\n\n----------------------------------------\n\nTITLE: Financial Account Event Definitions - C#\nDESCRIPTION: This snippet defines several event records related to a financial account, including `AccountingMonthOpened`, `InflowRecorded`, `CashWithdrawnFromATM`, and `AccountingMonthClosed`. It also defines the `FinancialAccount` class, which has an `Apply` method for each event type to update the account's state. The Version property is incremented in each apply method.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/live-aggregates.md#_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic record AccountingMonthOpened(\n    Guid FinancialAccountId,\n    int Month,\n    int Year,\n    decimal StartingBalance\n);\n\npublic record InflowRecorded(\n    Guid FinancialAccountId,\n    decimal TransactionAmount\n);\n\npublic record CashWithdrawnFromATM(\n    Guid FinancialAccountId,\n    decimal CashAmount\n);\n\npublic record AccountingMonthClosed(\n    Guid FinancialAccountId,\n    int Month,\n    int Year,\n    decimal FinalBalance\n);\n\npublic class FinancialAccount\n{\n    public Guid Id { get; private set; }\n    public int CurrentMonth { get; private set; }\n    public int CurrentYear { get; private set; }\n    public bool IsOpened { get; private set; }\n    public decimal Balance { get; private set; }\n    public int Version { get; private set; }\n\n    public void Apply(AccountingMonthOpened @event)\n    {\n        Id = @event.FinancialAccountId;\n        CurrentMonth = @event.Month;\n        CurrentYear = @event.Year;\n        Balance = @event.StartingBalance;\n        IsOpened = true;\n        Version++;\n    }\n\n    public void Apply(InflowRecorded @event)\n    {\n        Balance += @event.TransactionAmount;\n\n        Version++;\n    }\n\n    public void Apply(CashWithdrawnFromATM @event)\n    {\n        Balance -= @event.CashAmount;\n        Version++;\n    }\n\n    public void Apply(AccountingMonthClosed @event)\n    {\n        IsOpened = false;\n        Version++;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Storing Mixed Type Documents with IDocumentSession.StoreObjects() (C#)\nDESCRIPTION: This code snippet demonstrates storing a mixed array of different types using `IDocumentSession.StoreObjects()` or `IDocumentSession.Store<object>(object[])`. It highlights the capability to persist heterogeneous collections of objects within a single session.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/basics/persisting.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nusing Marten;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class Company\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n}\n\npublic class Person\n{\n    public int Id { get; set; }\n    public string FirstName { get; set; }\n    public string LastName { get; set; }\n}\n\npublic class MixedDocsToStore\n{\n    public async Task Mixed_Docs_To_Store(IDocumentStore store)\n    {\n        using (var session = store.OpenSession())\n        {\n            var docs = new object[]\n            {\n                new Company { Name = \"Acme Corp\" },\n                new Person { FirstName = \"John\", LastName = \"Doe\" }\n            };\n\n            session.StoreObjects(docs);\n            // Or...\n            //session.Store<object>(docs);\n\n            await session.SaveChangesAsync();\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Flat Table Projection with SQL (C#)\nDESCRIPTION: Creates a Marten EventProjection to project events into a flat table using explicit SQL commands. The `ImportSqlProjection` class defines the table schema, registers the table with Marten's schema management, and uses `QueueSqlCommand` to execute SQL commands within a transaction to insert, update, and delete records based on the incoming events. This method requires manual management of SQL commands.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/flat.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\npublic class ImportSqlProjection: EventProjection\n{\n    public ImportSqlProjection()\n    {\n        // Define the table structure here so that\n        // Marten can manage this for us in its schema\n        // management\n        var table = new Table(\"import_history\");\n        table.AddColumn<Guid>(\"id\").AsPrimaryKey();\n        table.AddColumn<string>(\"activity_type\").NotNull();\n        table.AddColumn<DateTimeOffset>(\"started\").NotNull();\n        table.AddColumn<DateTimeOffset>(\"finished\");\n\n        SchemaObjects.Add(table);\n\n        // Telling Marten to delete the table data as the\n        // first step in rebuilding this projection\n        Options.DeleteDataInTableOnTeardown(table.Identifier);\n    }\n\n    public void Project(IEvent<ImportStarted> e, IDocumentOperations ops)\n    {\n        ops.QueueSqlCommand(\"insert into import_history (id, activity_type, started) values (?, ?, ?)\",\n            e.StreamId, e.Data.ActivityType, e.Data.Started\n        );\n    }\n\n    public void Project(IEvent<ImportFinished> e, IDocumentOperations ops)\n    {\n        ops.QueueSqlCommand(\"update import_history set finished = ? where id = ?\",\n            e.Data.Finished, e.StreamId\n        );\n    }\n\n    public void Project(IEvent<ImportFailed> e, IDocumentOperations ops)\n    {\n        ops.QueueSqlCommand(\"delete from import_history where id = ?\", e.StreamId);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Versioned Order Attribute - Marten C#\nDESCRIPTION: This code snippet shows how to use the `[Version]` attribute on a property of a document class to enable numeric revisioning. The `Order` class has an integer `Version` property decorated with the `[Version]` attribute, which tells Marten to use numeric revisioning for this document type and track the version number in the decorated property.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/concurrency.md#_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic class Order\n{\n    public Guid Id { get; set; }\n\n    // Marking an integer as the \"version\"\n    // of the document, and making Marten\n    // opt this document into the numeric revisioning\n    [Version]\n    public int Version { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Sequence in PostgreSQL\nDESCRIPTION: This code snippet shows how to create a sequence with a custom name in PostgreSQL.  This allows more control over sequence naming and configuration, separate from the default sequence naming used by `serial`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/postgres/types.md#_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\ncreate sequence my_own_named_sequence\n```\n\n----------------------------------------\n\nTITLE: Writing Documents with Tenant Scoped Session in Marten (C#)\nDESCRIPTION: This code snippet demonstrates how to write User documents to a specific tenant using Marten's LightweightSession.  The session is scoped to the tenant \"tenant1\", and the Store method is used to persist the User objects.  The SaveChangesAsync method persists the changes to the database. Requires Marten document store instance.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/multi-tenancy.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n// Write some User documents to tenant \"tenant1\"\nusing (var session = store.LightweightSession(\"tenant1\"))\n{\n    session.Store(new User { UserName = \"Bill\" });\n    session.Store(new User { UserName = \"Lindsey\" });\n    await session.SaveChangesAsync();\n}\n```\n\n----------------------------------------\n\nTITLE: Trip Stream Aggregation (Marten, C#)\nDESCRIPTION: Shows a Trip class designed for stream aggregation in Marten. It includes constructors, properties, and Apply() methods for state mutation based on events like Arrival, Travel, and TripEnded. The ShouldDelete methods specify conditions under which the Trip aggregate should be deleted based on events like TripAborted, Breakdown and VacationOver.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/aggregate-projections.md#_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Trip\n{\n    // Probably safest to have an empty, default\n    // constructor unless you can guarantee that\n    // a certain event type will always be first in\n    // the event stream\n    public Trip()\n    {\n    }\n\n    // Create a new aggregate based on the initial\n    // event type\n    internal Trip(TripStarted started)\n    {\n        StartedOn = started.Day;\n        Active = true;\n    }\n\n    public Guid Id { get; set; }\n    public int EndedOn { get; set; }\n\n    public double Traveled { get; set; }\n\n    public string State { get; set; }\n\n    public bool Active { get; set; }\n\n    public int StartedOn { get; set; }\n    public Guid? RepairShopId { get; set; }\n\n    // The Apply() methods would mutate the aggregate state\n    internal void Apply(Arrival e) => State = e.State;\n    internal void Apply(Travel e) => Traveled += e.TotalDistance();\n\n    internal void Apply(TripEnded e)\n    {\n        Active = false;\n        EndedOn = e.Day;\n    }\n\n    // We think stream aggregation is mostly useful for live aggregations,\n    // but hey, if you want to use a aggregation as an asynchronous projection,\n    // you can also specify when the aggregate document should be deleted\n    internal bool ShouldDelete(TripAborted e) => true;\n    internal bool ShouldDelete(Breakdown e) => e.IsCritical;\n    internal bool ShouldDelete(VacationOver e) => Traveled > 1000;\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Current State with Repository - C#\nDESCRIPTION: This snippet demonstrates how to retrieve the current state of a `FinancialAccount` using the `CashRegisterRepository.Get` method. This retrieves the most recent snapshot, if one exists, and then aggregates any subsequent events to produce the current state of the aggregate.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/live-aggregates.md#_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nvar currentState = await repository.Get(financialAccountId);\n```\n\n----------------------------------------\n\nTITLE: Tracking Wolverine Messages\nDESCRIPTION: Helper method to track Wolverine messages within Alba integration tests. It executes HTTP calls using Alba's Scenario method within Wolverine's ExecuteAndWaitAsync method, ensuring all cascaded work spawned by the initial command completes before returning. Returns a tuple containing the ITrackedSession and IScenarioResult.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/testing/integration.md#_snippet_13\n\nLANGUAGE: cs\nCODE:\n```\n// This method allows us to make HTTP calls into our system\n// in memory with Alba, but do so within Wolverine's test support\n// for message tracking to both record outgoing messages and to ensure\n// that any cascaded work spawned by the initial command is completed\n// before passing control back to the calling test\nprotected async Task<(ITrackedSession, IScenarioResult)> TrackedHttpCall(Action<Scenario> configuration)\n{\n    IScenarioResult result = null;\n     \n    // The outer part is tying into Wolverine's test support\n    // to \"wait\" for all detected message activity to complete\n    var tracked = await Host.ExecuteAndWaitAsync(async () =>\n    {\n        // The inner part here is actually making an HTTP request\n        // to the system under test with Alba\n        result = await Host.Scenario(configuration);\n    });\n \n    return (tracked, result);\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Metadata on a Marten Session (C#)\nDESCRIPTION: This code snippet shows how to set the correlation ID and causation ID at the document session level in Marten. These values will be persisted with any document changes made during the session when `SaveChanges()` is called. The snippet defines a `SettingMetadata` method that accepts an `IDocumentSession`, a correlation ID string, and a causation ID string, assigning them to the respective properties of the session.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/metadata.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic void SettingMetadata(IDocumentSession session, string correlationId, string causationId)\n{\n    // These values will be persisted to any document changed\n    // by the session when SaveChanges() is called\n    session.CorrelationId = correlationId;\n    session.CausationId = causationId;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Async Daemon from DocumentStore\nDESCRIPTION: Demonstrates how to directly manage the Marten async daemon using an `IDocumentStore` instance, including starting, stopping, rebuilding projections, and waiting for non-stale data.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/async-daemon.md#_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic static async Task UseAsyncDaemon(IDocumentStore store, CancellationToken cancellation)\n{\n    using var daemon = await store.BuildProjectionDaemonAsync();\n\n    // Fire up everything!\n    await daemon.StartAllAsync();\n\n    // or instead, rebuild a single projection\n    await daemon.RebuildProjectionAsync(\"a projection name\", 5.Minutes(), cancellation);\n\n    // or a single projection by its type\n    await daemon.RebuildProjectionAsync<TripProjectionWithCustomName>(5.Minutes(), cancellation);\n\n    // Be careful with this. Wait until the async daemon has completely\n    // caught up with the currently known high water mark\n    await daemon.WaitForNonStaleData(5.Minutes());\n\n    // Start a single projection shard\n    await daemon.StartAgentAsync(\"shard name\", cancellation);\n\n    // Or change your mind and stop the shard you just started\n    await daemon.StopAgentAsync(\"shard name\");\n\n    // No, shut them all down!\n    await daemon.StopAllAsync();\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Document with String Identity in Marten\nDESCRIPTION: This code defines a document type with a string identity property. When using a string identity, you are responsible for supplying the identity value to Marten when storing new documents. Marten requires the `Id` property to be present in the class definition.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/identity.md#_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\npublic class DocumentWithStringId\n{\n    public string Id { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Event Stream with Marten C#\nDESCRIPTION: This snippet demonstrates how to start an event stream in Marten using the `StartStream` method and persisting the changes using `SaveChangesAsync`. It sets up an initial event stream with `QuestStarted`, `MembersJoined`, and `MonsterSlayed` events, associating them with a specific quest name. The code utilizes `theStore.LightweightSession()` to create a session for interacting with Marten. Requires Marten and related event classes to be defined.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/scenarios/copy-and-transform-stream.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\nvar started = new QuestStarted { Name = \"Find the Orb\" };\nvar joined = new MembersJoined { Day = 2, Location = \"Faldor's Farm\", Members = new[] { \"Garion\", \"Polgara\", \"Belgarath\" } };\nvar slayed1 = new MonsterSlayed { Name = \"Troll\" };\nvar slayed2 = new MonsterSlayed { Name = \"Dragon\" };\n\nusing (var session = theStore.LightweightSession())\n{\n    session.Events.StartStream<Quest>(started.Name,started, joined, slayed1, slayed2);\n    await session.SaveChangesAsync();\n}\n```\n\n----------------------------------------\n\nTITLE: Opening Accounting Month and Storing Snapshot - C#\nDESCRIPTION: This snippet shows how to open an accounting month for a `FinancialAccount`, apply the opening event to the account, and then store the account and event using the `CashRegisterRepository`. It first aggregates the stream to get the closed cash register state, opens a new accounting month, and then stores the updated state and new event.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/live-aggregates.md#_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\n(FinancialAccount, AccountingMonthOpened) OpenAccountingMonth(\n    FinancialAccount cashRegister)\n{\n    var @event = new AccountingMonthOpened(\n        cashRegister.Id, 11, 2021, 300);\n\n    cashRegister.Apply(@event);\n    return (cashRegister, @event);\n}\n\nvar closedCashierShift =\n    await theSession.Events.AggregateStreamAsync<FinancialAccount>(\n        financialAccountId\n    );\n\nvar (openedCashierShift, cashierShiftOpened) =\n    OpenAccountingMonth(closedCashierShift!);\n\nvar repository = new CashRegisterRepository(theSession);\n\nawait repository.Store(openedCashierShift, cashierShiftOpened);\n```\n\n----------------------------------------\n\nTITLE: Configuring Global Hilo Defaults - C#\nDESCRIPTION: This code snippet demonstrates how to configure global Hilo sequence defaults using the `StoreOptions.HiloSequenceDefaults` property.  It sets the increment to 5 and the maximum lo to 20.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/identity/sequential.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:configuring-global-hilo-defaults]>\n```\n\n----------------------------------------\n\nTITLE: Querying Is Soft Deleted Documents - C#\nDESCRIPTION: This snippet demonstrates how to query specifically for documents that have been soft-deleted using the `IsDeleted()` method. This allows you to retrieve only the documents that have been marked as deleted.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/advanced/soft_deletes.md#_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nvar deleted = await session.Query<User>().Where(x => x.IsDeleted()).ToListAsync();\ndeleted.Count.ShouldBe(1);\n```\n\n----------------------------------------\n\nTITLE: Wrapping DDL with SET ROLE and RESET ROLE (SQL)\nDESCRIPTION: This SQL snippet demonstrates how Marten wraps generated or exported DDL scripts when a database role is configured. The `SET ROLE` statement sets the active role for the session, and the `RESET ROLE` statement reverts to the original role. [ROLE_NAME] will be replaced by the configured role name.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/schema/authorization.md#_snippet_7\n\nLANGUAGE: SQL\nCODE:\n```\nSET ROLE [ROLE_NAME];\n\n-- the body of the DDL\n\nRESET ROLE;\n```\n\n----------------------------------------\n\nTITLE: Exporting DDL from IDocumentStore - C#\nDESCRIPTION: This C# code snippet shows how to export the schema definition (DDL) for all known document types from an IDocumentStore. It uses the DocumentStore.Storage.AllObjectsSql() method to retrieve the SQL script as a single string. No specific dependencies are required beyond the Marten library itself. The output is a string containing the complete SQL script for creating the necessary database objects.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/schema/exporting.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:export-ddl]>\n```\n\n----------------------------------------\n\nTITLE: Using a Compiled Query in a Batched Query\nDESCRIPTION: This code demonstrates using the `FindByFirstName` compiled query within a batched query. It uses `session.CreateBatchQuery()` to create a batch, adds two queries using `batch.Query()`, executes the batch with `batch.Execute()`, and then asserts the results. This approach optimizes performance by executing multiple queries in a single database round trip.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/compiled-queries.md#_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvar batch = session.CreateBatchQuery();\n\nvar justin = batch.Query(new FindByFirstName { FirstName = \"Justin\" });\nvar tamba = batch.Query(new FindByFirstName { FirstName = \"Tamba\" });\n\nawait batch.Execute();\n\n(await justin).Id.ShouldBe(user1.Id);\n(await tamba).Id.ShouldBe(user2.Id);\n```\n\n----------------------------------------\n\nTITLE: Defining Valid Strong Typed Identifiers in C#\nDESCRIPTION: This snippet demonstrates two valid patterns for defining strong typed identifiers in C# that Marten can automatically recognize.  One pattern uses a constructor for the inner value and exposes it with a public property getter. The other pairs a public property getter for the inner value with a public static method that takes the inner value. The type name must be suffixed with \"Id\" and be an immutable `struct`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/identity.md#_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\n// Use a constructor for the inner value,\n// and expose the inner value in a *public*\n// property getter\npublic record struct TaskId(Guid Value);\n\n/// <summary>\n/// Pair a public property getter for the inner value\n/// with a public static method that takes in the\n/// inner value\n/// </summary>\npublic struct Task2Id\n{\n    private Task2Id(Guid value) => Value = value;\n\n    public Guid Value { get; }\n\n    public static Task2Id From(Guid value) => new Task2Id(value);\n}\n```\n\n----------------------------------------\n\nTITLE: Registering IAsyncConfigureMarten with Services (C#)\nDESCRIPTION: This snippet shows how to register an implementation of `IAsyncConfigureMarten` with the `IServiceCollection`. The `ConfigureMartenWithServices` extension method registers the specified type as a service that will be used to configure Marten asynchronously. The `FeatureManagementUsingExtension` will be resolved via IoC.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/hostbuilder.md#_snippet_14\n\nLANGUAGE: cs\nCODE:\n```\nservices.ConfigureMartenWithServices<FeatureManagementUsingExtension>();\n```\n\n----------------------------------------\n\nTITLE: Defining Full Text Index on Class - Marten C#\nDESCRIPTION: Defines a full text index for the entire `Book` document by applying the `[FullTextIndex]` attribute to the class. This indexes all properties of the class with the default 'english' configuration. Requires the Marten library.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/full-text.md#_snippet_6\n\nLANGUAGE: cs\nCODE:\n```\n[FullTextIndex]\npublic class Book\n{\n    public Guid Id { get; set; }\n\n    public string Title { get; set; }\n\n    public string Author { get; set; }\n\n    public string Information { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Using DocumentAlias Attribute - C#\nDESCRIPTION: This snippet demonstrates how to define a document alias using the `DocumentAlias` attribute on the document class. This allows customizing table and function names in database.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/storage.md#_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n[DocumentAlias(\"johndeere\")]\npublic class Tractor\n{\n    public string id;\n}\n```\n\n----------------------------------------\n\nTITLE: Automatic Dirty Checking with Marten DirtyTrackedSession\nDESCRIPTION: Illustrates how to use Marten's `DirtyTrackedSession` for automatic dirty checking. The code shows adding a new user, modifying an existing user, and deleting another user.  The session automatically detects changes to documents loaded by the session by comparing the original JSON with the current state.  The cost in memory and runtime performance should be considered.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/sessions.md#_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\nawait using var session = store.DirtyTrackedSession();\nvar user = new User { FirstName = \"Jeremy\", LastName = \"Miller\" };\n\n// Manually adding the new user to the session\nsession.Store(user);\n\nvar existing = session.Query<User>().Single(x => x.FirstName == \"Max\");\nexisting.Internal = false;\n\n// Marking another existing User document as deleted\nsession.Delete<User>(Guid.NewGuid());\n\n// Persisting the changes to the database\nawait session.SaveChangesAsync();\n```\n\n----------------------------------------\n\nTITLE: Asserting Database - Bash\nDESCRIPTION: This bash command demonstrates how to verify that the database schema matches the Marten configuration using the command line. The 'db-assert' command throws an exception if discrepancies are found.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/schema/migrations.md#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\ndotnet run -- db-assert\n```\n\n----------------------------------------\n\nTITLE: Using Injected Marten Store (C#, .NET)\nDESCRIPTION: Illustrates how to inject and use the custom `IInvoicingStore` within a service (`InvoicingService`).  It shows how the store can be injected via constructor injection and used to open a lightweight session for database operations, emphasizing the importance of disposing of the session when finished.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/hostbuilder.md#_snippet_25\n\nLANGUAGE: C#\nCODE:\n```\npublic class InvoicingService\n{\n    private readonly IInvoicingStore _store;\n\n    // IInvoicingStore can be injected like any other\n    // service in your IoC container\n    public InvoicingService(IInvoicingStore store)\n    {\n        _store = store;\n    }\n\n    public async Task DoSomethingWithInvoices()\n    {\n        // Important to dispose the session when you're done\n        // with it\n        await using var session = _store.LightweightSession();\n\n        // do stuff with the session you just opened\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Upcasting Event with CLR Types and Explicit Type Name\nDESCRIPTION: This snippet shows how to upcast an event using a lambda expression, CLR types, and an explicit event type name. It transforms a `ShoppingCartOpened` event into a `ShoppingCartOpenedWithStatus` event. The explicit type name is useful when the old CLR class doesn't represent the initial event type name.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/versioning.md#_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\noptions.Events\n    .Upcast<ShoppingCartOpened, ShoppingCartOpenedWithStatus>(\n        \"shopping_cart_opened\",\n        oldEvent =>\n            new ShoppingCartOpenedWithStatus(\n                oldEvent.ShoppingCartId,\n                new Client(oldEvent.ClientId),\n                ShoppingCartStatus.Opened\n            )\n    );\n```\n\n----------------------------------------\n\nTITLE: Creating a Standalone Document Store\nDESCRIPTION: This snippet shows how to create a `DocumentStore` instance outside the context of an ASP.NET Core application. It uses the `DocumentStore.For` method and provides a connection string to the PostgreSQL database.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/getting-started.md#_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nvar store = DocumentStore\n    .For(\"host=localhost;database=marten_testing;password=mypassword;username=someuser\");\n```\n\n----------------------------------------\n\nTITLE: Simple Include Query with Join - C#\nDESCRIPTION: This code snippet demonstrates a simple include query in Marten. It fetches an `Issue` document along with the related `User` document based on the `AssigneeId` property, using an inner join by default. The fetched `User` is assigned to the `included` variable.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/include.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar included = default(User);\n\nvar issue = await session.Query<Issue>()\n    .Include(x => x.AssigneeId, x => included = x)\n    .FirstOrDefaultAsync(x => x.Title == \"Include Test\");\n```\n\n----------------------------------------\n\nTITLE: Custom Grouper with QuerySession in View Projection (C#)\nDESCRIPTION: This snippet shows how to use a custom `IAggregateGrouper` to group events to aggregate documents based on a custom logic. It defines a `LicenseFeatureToggledEventGrouper` that implements `IAggregateGrouper<Guid>` and groups `LicenseFeatureToggled` events based on their `LicenseId`. It then defines a `UserFeatureTogglesProjection` which inherits from `MultiStreamProjection` and applies events, registering the custom grouper.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/multi-stream-projections.md#_snippet_5\n\nLANGUAGE: cs\nCODE:\n```\npublic class LicenseFeatureToggledEventGrouper: IAggregateGrouper<Guid>\n{\n    public async Task Group(IQuerySession session, IEnumerable<IEvent> events, ITenantSliceGroup<Guid> grouping)\n    {\n        var licenseFeatureTogglesEvents = events\n            .OfType<IEvent<LicenseFeatureToggled>>()\n            .ToList();\n\n        if (!licenseFeatureTogglesEvents.Any())\n        {\n            return;\n        }\n\n        // TODO -- let's build more samples first, but see if there's a useful\n        // pattern for the next 3/4 operations later\n        var licenseIds = licenseFeatureTogglesEvents\n            .Select(e => e.Data.LicenseId)\n            .ToList();\n\n        var result = await session.Query<UserFeatureToggles>()\n            .Where(x => licenseIds.Contains(x.LicenseId))\n            .Select(x => new {x.Id, x.LicenseId})\n            .ToListAsync();\n\n        var streamIds = (IDictionary<Guid, List<Guid>>)result.GroupBy(ks => ks.LicenseId, vs => vs.Id)\n            .ToDictionary(ks => ks.Key, vs => vs.ToList());\n\n        grouping.AddEvents<LicenseFeatureToggled>(e => streamIds[e.LicenseId], licenseFeatureTogglesEvents);\n    }\n}\n\n// projection with documentsession\npublic class UserFeatureTogglesProjection: MultiStreamProjection<UserFeatureToggles, Guid>\n{\n    public UserFeatureTogglesProjection()\n    {\n        Identity<UserRegistered>(@event => @event.UserId);\n        Identity<UserLicenseAssigned>(@event => @event.UserId);\n\n        CustomGrouping(new LicenseFeatureToggledEventGrouper());\n    }\n\n    public void Apply(UserRegistered @event, UserFeatureToggles view)\n    {\n        view.Id = @event.UserId;\n    }\n\n    public void Apply(UserLicenseAssigned @event, UserFeatureToggles view)\n    {\n        view.LicenseId = @event.LicenseId;\n    }\n\n    public void Apply(LicenseFeatureToggled @event, UserFeatureToggles view)\n    {\n        view.FeatureToggles.Add(@event.FeatureToggleName);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Exporting Marten DDL\nDESCRIPTION: This C# code snippet demonstrates how to export the DDL (Data Definition Language) for Marten document types to a SQL file or retrieve it as a string. It initializes a `DocumentStore`, registers document types, and uses the `Storage` property to write the creation script to a file or retrieve it as a string.  Dependencies include the Marten library and PostgreSQL.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/schema/exporting.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic async Task export_ddl()\n{\n    var store = DocumentStore.For(_ =>\n    {\n        _.Connection(\"some connection string\");\n\n        // If you are depending upon attributes for customization,\n        // you have to help DocumentStore \"know\" what the document types\n        // are\n        _.Schema.For<User>();\n        _.Schema.For<Company>();\n        _.Schema.For<Issue>();\n    });\n\n    // Export the SQL to a file\n    await store.Storage.WriteCreationScriptToFile(\"my_database.sql\");\n\n    // Or instead, write a separate sql script\n    // to the named directory\n    // for each type of document\n    await store.Storage.WriteScriptsByType(\"sql\");\n\n    // or just see it\n    var sql = store.Storage.ToDatabaseScript();\n    Debug.WriteLine(sql);\n}\n```\n\n----------------------------------------\n\nTITLE: Manually Mapping Soft Delete Metadata in Marten\nDESCRIPTION: This code snippet shows how to manually map the `IsDeleted` and `DeletedWhen` properties of a document type to Marten's soft deletion metadata. This allows Marten to track soft deletions without requiring the document type to implement the `ISoftDeleted` interface. Requires a connection string.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/deletes.md#_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\nusing var store = DocumentStore.For(opts =>\n{\n    opts.Connection(\"some connection string\");\n\n    opts.Schema.For<ASoftDeletedDoc>().Metadata(m =>\n    {\n        m.IsSoftDeleted.MapTo(x => x.IsDeleted);\n        m.SoftDeletedAt.MapTo(x => x.DeletedWhen);\n    });\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Document Mapping with a Policy (C#)\nDESCRIPTION: Demonstrates how to configure document mapping within a document policy using the `Policies.ForAllDocuments` method. This allows applying configurations to all document types in the Marten store.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/document_policies.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n// SAMPLE: sample-policy-configure\nusing Marten;\nusing Marten.Mapping;\n\npublic class SamplePolicy : IDocumentPolicy\n{\n    public void Apply(DocumentMapping document, IReadOnlyStoreOptions options)\n    {\n        if (document.DocumentType.Name.StartsWith(\"My\"))\n        {\n            // This is just an example, you'd\n            // do something more useful here!\n            document.DatabaseSchemaName = \"other\";\n        }\n    }\n}\n\npublic static class ConfigureStore\n{\n    public static DocumentStore the_store = DocumentStore.For(_ =>\n    {\n        _.Policies.ForAllDocuments(x =>\n        {\n            // You can also apply customizations inline\n            if (x.DocumentType.Name.StartsWith(\"My\"))\n            {\n                x.DatabaseSchemaName = \"extra\";\n            }\n\n\n        });\n    });\n}\n// ENDSAMPLE\n```\n\n----------------------------------------\n\nTITLE: Projecting a single document field with Select(), C#\nDESCRIPTION: This code snippet demonstrates how to retrieve an IEnumerable of a single document property using the `Select()` method in Marten. It fetches only the specified field from the documents. The code uses linq `IQueryable.Select()` method for this functionality.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/projections.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:one_field_projection]>\n```\n\n----------------------------------------\n\nTITLE: Transforming Event Stream in Marten C#\nDESCRIPTION: This snippet demonstrates how to copy and transform an existing event stream to a new stream in Marten. It fetches the events from the existing stream using `FetchStream`, transforms them using `SelectMany` to filter out 'Troll' `MonsterSlayed` events and expand `MembersJoined` events into multiple `MemberJoined` events. It then creates a new stream with the transformed events using `StartStream` and marks the old stream as moved by appending a `StreamMovedTo` event. Finally, it persists all changes transactionally using `SaveChangesAsync`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/scenarios/copy-and-transform-stream.md#_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\nusing (var session = theStore.LightweightSession())\n{\n    var events = session.Events.FetchStream(started.Name);\n\n    var transformedEvents = events.SelectMany(x =>\n    {\n        switch (x.Data)\n        {\n            case MonsterSlayed monster:\n            {\n                // Trolls we remove from our transformed stream\n                return monster.Name.Equals(\"Troll\") ? new object[] { } : new[] { monster };\n            }\n            case MembersJoined members:\n            {\n                // MembersJoined events we transform into a series of events\n                return MemberJoined.From(members);\n            }\n        }\n\n        return new[] { x.Data };\n    }).Where(x => x != null).ToArray();\n\n    var moveTo = $\"{started.Name} without Trolls\";\n    // We copy the transformed events to a new stream\n    session.Events.StartStream<Quest>(moveTo, transformedEvents);\n    // And additionally mark the old stream as moved. Furthermore, we assert on the new expected stream version to guard against any racing updates\n    session.Events.Append(started.Name, events.Count + 1, new StreamMovedTo\n    {\n        To = moveTo\n    });\n\n    // Transactionally update the streams.\n    await session.SaveChangesAsync();\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Event Metadata in Marten (C#)\nDESCRIPTION: This snippet demonstrates how to configure Marten to enable additional metadata tracking for events, including headers, causation IDs, and correlation IDs. It uses the `DocumentStore.For` method to configure Marten's options. The configuration options are set within the `opts.Events.MetadataConfig` property.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/metadata.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(opts =>\n{\n    opts.Connection(\"connection string\");\n\n    // This adds additional metadata tracking to the\n    // event store tables\n    opts.Events.MetadataConfig.HeadersEnabled = true;\n    opts.Events.MetadataConfig.CausationIdEnabled = true;\n    opts.Events.MetadataConfig.CorrelationIdEnabled = true;\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Event Transformation Projection in Marten (C#)\nDESCRIPTION: This code defines an inline event projection named `MonsterDefeatedTransform` that transforms `MonsterSlayed` events into `MonsterDefeated` documents. The `Create` method takes an `IEvent<MonsterSlayed>` as input and returns a new `MonsterDefeated` document, extracting the monster's name from the event data.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/inline.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic class MonsterDefeatedTransform: EventProjection\n{\n    public MonsterDefeated Create(IEvent<MonsterSlayed> input)\n    {\n        return new MonsterDefeated { Id = input.Id, Monster = input.Data.Name };\n    }\n}\n\npublic class MonsterDefeated\n{\n    public Guid Id { get; set; }\n    public string Monster { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled Query with Include C#\nDESCRIPTION: This code demonstrates a compiled query with an `Include` to fetch related documents in a single query.  Specifically, it retrieves `Issue` documents and includes the associated `User` document as the `Assignee`. The `QueryIs` method contains the Linq expression that includes the `Assignee`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/compiled_queries.md#_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic class IssueByTitleWithAssignee : ICompiledQuery<Issue, IssueByTitleWithAssignee>\n{\n    public string TitleSearch { get; set; }\n\n    public JoinType JoinType { get; set; } = JoinType.Inner;\n\n    public User Included { get; set; }\n\n    public Expression<Func<IQueryable<Issue>, IssueByTitleWithAssignee>> QueryIs()\n    {\n        return query => query\n            .Include(JoinType, x => x.AssigneeId, x => Included)\n            .FirstOrDefault(x => x.Title.Contains(TitleSearch));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Max() with Linq in Marten (C#)\nDESCRIPTION: Shows how to use the `IQueryable.Max()` method to find the maximum value of a specific property across all matching documents. This example finds the maximum value of the `Number` property.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/linq.md#_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nvar max = session.Query<Target>().Max(x => x.Number);\n```\n\n----------------------------------------\n\nTITLE: Querying with `IsSupersetOf` Operator - Marten - C#\nDESCRIPTION: This code snippet demonstrates how to use the `IsSupersetOf()` extension method in Marten to query for documents where an array property contains all of the provided values. It uses `theSession.Query<Post>()` to query the `Post` documents, checking if `Tags` contains \"c#\", \"json\", and \"postgres\".\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/child-collections.md#_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\n// Finds all Posts whose Tags is superset of\n// c#, json, or postgres\nvar posts = theSession.Query<Post>()\n    .Where(x => x.Tags.IsSupersetOf(\"c#\", \"json\", \"postgres\"));\n```\n\n----------------------------------------\n\nTITLE: Installing Marten.AspNetCore NuGet Package\nDESCRIPTION: This command installs the Marten.AspNetCore NuGet package, providing extension methods for integrating Marten with ASP.Net Core for efficient JSON streaming to HTTP responses.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/aspnetcore.md#_snippet_0\n\nLANGUAGE: powershell\nCODE:\n```\nPM> Install-Package Marten.AspNetCore\n```\n\n----------------------------------------\n\nTITLE: Marten Async Daemon Diagnostics\nDESCRIPTION: Presents code for retrieving and displaying diagnostics information about the Marten async daemon, including projection progress, event store statistics, and the daemon's high water mark.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/async-daemon.md#_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic static async Task ShowDaemonDiagnostics(IDocumentStore store)\n{\n    // This will tell you the current progress of each known projection shard\n    // according to the latest recorded mark in the database\n    var allProgress = await store.Advanced.AllProjectionProgress();\n    foreach (var state in allProgress)\n    {\n        Console.WriteLine($\"{state.ShardName} is at {state.Sequence}\");\n    }\n\n    // This will allow you to retrieve some basic statistics about the event store\n    var stats = await store.Advanced.FetchEventStoreStatistics();\n    Console.WriteLine($\"The event store highest sequence is {stats.EventSequenceNumber}\");\n\n    // This will let you fetch the current shard state of a single projection shard,\n    // but in this case we're looking for the daemon high water mark\n    var daemonHighWaterMark = await store.Advanced.ProjectionProgressFor(new ShardName(ShardState.HighWaterMark));\n    Console.WriteLine($\"The daemon high water sequence mark is {daemonHighWaterMark}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Marking the original stream as moved - C#\nDESCRIPTION: This code snippet demonstrates how to mark the original event stream as moved after copying and transforming it. This is done by introducing an event dictating that the stream has been copied. It also ensures that the original stream hasn't changed during the copy process.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/scenarios/copyandtransformstream.md#_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:scenario-copyandtransformstream-streammoved]>\n```\n\n----------------------------------------\n\nTITLE: Customizing Calculated Index in Marten (C#)\nDESCRIPTION: This code snippet demonstrates how to customize a calculated index in Marten using the `Index()` method. It shows how to set properties like index method, casing, name, concurrency, uniqueness, tenancy scope, and predicate. It also shows how to change the sort order for B-tree indexes.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/indexing/unique.md#_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n    _.Connection(ConnectionSource.ConnectionString);\n\n    // The second, optional argument to Index()\n    // allows you to customize the calculated index\n    _.Schema.For<Target>().Index(x => x.Number, x =>\n    {\n        // Change the index method to \"brin\"\n        x.Method = IndexMethod.brin;\n\n        // Force the index to be generated with casing rules\n        x.Casing = ComputedIndex.Casings.Lower;\n\n        // Override the index name if you want\n        x.Name = \"mt_my_name\";\n\n        // Toggle whether or not the index is concurrent\n        // Default is false\n        x.IsConcurrent = true;\n\n        // Toggle whether or not the index is a UNIQUE\n        // index\n        x.IsUnique = true;\n\n        // Toggle whether index value will be constrained unique in scope of whole document table (Global)\n        // or in a scope of a single tenant (PerTenant)\n        // Default is Global\n        x.TenancyScope = Marten.Schema.Indexing.Unique.TenancyScope.PerTenant;\n\n        // Partial index by supplying a condition\n        x.Predicate = \"(data ->> 'Number')::int > 10\";\n    });\n\n    // For B-tree indexes, it's also possible to change\n    // the sort order from the default of \"ascending\"\n    _.Schema.For<User>().Index(x => x.LastName, x =>\n    {\n        // Change the index method to \"brin\"\n        x.SortOrder = SortOrder.Desc;\n    });\n});\n```\n\n----------------------------------------\n\nTITLE: All Documents Soft Deleted - Marten - C#\nDESCRIPTION: Demonstrates configuring Marten to soft delete all document types by default.  This can be overridden for specific document types using other configuration methods.  Requires Marten library and a valid database connection string.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/deletes.md#_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\ninternal void AllDocumentTypesShouldBeSoftDeleted()\n{\n    using var store = DocumentStore.For(opts =>\n    {\n        opts.Connection(\"some connection string\");\n        opts.Policies.AllDocumentsSoftDeleted();\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Custom Linq Parser C#\nDESCRIPTION: This snippet shows how to register the custom Linq parser within Marten's `StoreOptions`. This ensures that Marten utilizes the custom parser when processing Linq queries that involve the targeted method.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/advanced/customizing_linq.md#_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:using_custom_linq_parser]>\n```\n\n----------------------------------------\n\nTITLE: Compiled Query with List Include C#\nDESCRIPTION: This code demonstrates a compiled query that includes a list of related documents using the `Include` method. It retrieves a list of `Issue` documents and includes a list of associated `User` documents as the `Assignees`. The `QueryIs` method uses the Linq `Include` method to join the documents.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/compiled_queries.md#_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic class IssuesByTitleWithAssignees : ICompiledListQuery<Issue, IssuesByTitleWithAssignees>\n{\n    public string TitleSearch { get; set; }\n\n    public List<User> Included { get; set; } = new List<User>();\n\n    public Expression<Func<IQueryable<Issue>, IEnumerable<IssuesByTitleWithAssignees>>> QueryIs()\n    {\n        return query => query\n            .Include(x => x.AssigneeId, x => Included)\n            .Where(x => x.Title.Contains(TitleSearch))\n            .AsEnumerable();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Marten with Custom Session Factory (C#)\nDESCRIPTION: This snippet shows how to register Marten with a custom session factory.  It uses the `BuildSessionsWith<CustomSessionFactory>()` extension method chained after adding Marten to the `IServiceCollection`. Requires `Configuration` to retrieve connection string. It also uses `OptimizeArtifactWorkflow()` which sets up Marten configuration based on the environment.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/hostbuilder.md#_snippet_17\n\nLANGUAGE: cs\nCODE:\n```\nvar connectionString = Configuration.GetConnectionString(\"postgres\");\n\nservices.AddMarten(opts =>\n    {\n        opts.Connection(connectionString);\n    })\n    // Using the \"Optimized artifact workflow\" for Marten >= V5\n    // sets up your Marten configuration based on your environment\n    // See https://martendb.io/configuration/optimized_artifact_workflow.html\n    .OptimizeArtifactWorkflow()\n    // Chained helper to replace the built in\n    // session factory behavior\n    .BuildSessionsWith<CustomSessionFactory>();\n```\n\n----------------------------------------\n\nTITLE: Implementing Marten's ITracked Interface (C#)\nDESCRIPTION: This code snippet shows how to implement Marten's `ITracked` interface for a document type.  Implementing this interface automatically enables correlation and causation tracking, setting values for correlation, causation, and last modified data on documents when they are loaded or persisted by Marten.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/metadata.md#_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic class MyTrackedDoc: ITracked\n{\n    public Guid Id { get; set; }\n    public string CorrelationId { get; set; }\n    public string CausationId { get; set; }\n    public string LastModifiedBy { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Sum() with Linq in Marten (C#)\nDESCRIPTION: Shows how to use the `IQueryable.Sum()` method to calculate the sum of a specific property across all matching documents.  This example calculates the sum of the `Number` property.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/linq.md#_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\nvar sum = session.Query<Target>().Sum(x => x.Number);\n```\n\n----------------------------------------\n\nTITLE: Using Optimistic Concurrency Attribute - C#\nDESCRIPTION: This snippet demonstrates how to enable optimistic concurrency for a document type using the `[UseOptimisticConcurrency]` attribute. Applying this attribute to a document class will ensure that updates to instances of this class will only be allowed if the document has not been changed in the database since it was initially loaded. The code shows the `CoffeeShop` class with the `UseOptimisticConcurrency` attribute applied.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/concurrency.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[UseOptimisticConcurrency]\npublic class CoffeeShop: Shop\n{\n    // Guess where I'm at as I code this?\n    public string Name { get; set; } = \"Starbucks\";\n\n    public ICollection<Guid> Employees { get; set; } = new List<Guid>();\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Marten with Default Configuration\nDESCRIPTION: This snippet demonstrates the simplest way to integrate Marten into a .NET application. It establishes a connection string, specifies STJ for serialization, and configures schema creation in development mode.  It relies on the `Microsoft.Extensions.DependencyInjection` and `Microsoft.Extensions.Configuration` namespaces.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/hostbuilder.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\n// This is the absolute, simplest way to integrate Marten into your\n// .NET application with Marten's default configuration\nbuilder.Services.AddMarten(options =>\n{\n    // Establish the connection string to your Marten database\n    options.Connection(builder.Configuration.GetConnectionString(\"Marten\")!);\n\n    // Specify that we want to use STJ as our serializer\n    options.UseSystemTextJsonForSerialization();\n\n    // If we're running in development mode, let Marten just take care\n    // of all necessary schema building and patching behind the scenes\n    if (builder.Environment.IsDevelopment())\n    {\n        options.AutoCreateSchemaObjects = AutoCreate.All;\n    }\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Marten Store for Immutable Projections (C#)\nDESCRIPTION: Configures the Marten store to use aggregators that look for private Apply([Event Type]) methods and configures document deserialization to look for private property setters, enabling hydration of projected objects from the database.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/scenarios/immutable_projections_readmodel.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nstoreOptions.Projections.AggregatorLookup = AggregatorLookup.PrivateApply;\nstoreOptions.Serializer(new SerializerContract());\n```\n\n----------------------------------------\n\nTITLE: Using [DuplicateField] Attribute - C#\nDESCRIPTION: Demonstrates how to use the `[DuplicateField]` attribute to duplicate a property within a Marten document.  This results in an additional column in the database table that mirrors the JSONB property, allowing for faster querying against that duplicated data. The duplicate column is created with a NULL constraint by default.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/duplicated_fields.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:using_attributes_on_document]>\n```\n\n----------------------------------------\n\nTITLE: Subscription Filters\nDESCRIPTION: This example demonstrates how to filter events for a Marten subscription. It covers including archived events, filtering based on stream type (Invoice), and including specific event types (InvoiceCreated, InvoiceApproved). It registers the subscription with `AddSubscriptionWithServices` and configures the daemon in HotCold mode.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/subscriptions.md#_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\nbuilder.Services.AddMarten(opts =>\n    {\n        opts.Connection(builder.Configuration.GetConnectionString(\"marten\"));\n    })\n    // Marten also supports a Scoped lifecycle, and quietly forward Transient\n    // to Scoped\n    .AddSubscriptionWithServices<KafkaSubscription>(ServiceLifetime.Singleton, o =>\n    {\n        // Archived events are ignored by default, but you can override that here\n        o.IncludeArchivedEvents = true;\n\n        // If you use more than one type of stream type marker, it might\n        // be quick step to just include any events from a stream marked\n        // as the \"Invoice\" type\n        o.FilterIncomingEventsOnStreamType(typeof(Invoice));\n\n        // Or be explicit about the specific event types\n        // NOTE: you need to use concrete types here\n        o.IncludeType<InvoiceCreated>();\n        o.IncludeType<InvoiceApproved>();\n    })\n    .AddAsyncDaemon(DaemonMode.HotCold);\n\nusing var host = builder.Build();\nawait host.StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Using a Simple Calculated Index (Marten, C#)\nDESCRIPTION: Demonstrates how to create a simple calculated index on a document's property using Marten's fluent interface. This allows Postgresql to use the index for queries on that property.  Requires Marten and Postgresql. Expects a `User` document type with a `UserName` property.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/indexing/computed-indexes.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n    _.Connection(ConnectionSource.ConnectionString);\n\n    _.DatabaseSchemaName = \"examples\";\n\n    // This creates\n    _.Schema.For<User>().Index(x => x.UserName);\n});\n\nusing (var session = store.QuerySession())\n{\n    // Postgresql will be able to use the computed\n    // index generated from above\n    var somebody = session\n        .Query<User>()\n        .FirstOrDefault(x => x.UserName == \"somebody\");\n}\n```\n\n----------------------------------------\n\nTITLE: Customize Newtonsoft.Json Enum Storage\nDESCRIPTION: Shows how to customize the way enum values are stored in Marten by changing the serialization settings in the `DocumentStore` options. This allows you to store enum values as strings instead of integers.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/json/newtonsoft.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:customize_json_net_enum_storage_serialization]>\n```\n\n----------------------------------------\n\nTITLE: Unit Test for ApplyMetadata C#\nDESCRIPTION: This is a unit test showing the usage of the `ItemProjection` with `ApplyMetadata`.  It sets a custom header value on the session (`last-modified-by`), starts a stream, appends events, and then loads the aggregate to verify that the metadata has been applied correctly.  The test also verifies that aggregate versioning works as expected.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/aggregate-projections.md#_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic async Task apply_metadata()\n{\n    StoreOptions(opts =>\n    {\n        opts.Projections.Add<ItemProjection>(ProjectionLifecycle.Inline);\n\n        // THIS IS NECESSARY FOR THIS SAMPLE!\n        opts.Events.MetadataConfig.HeadersEnabled = true;\n    });\n\n    // Setting a header value on the session, which will get tagged on each\n    // event captured by the current session\n    theSession.SetHeader(\"last-modified-by\", \"Glenn Frey\");\n\n    var id = theSession.Events.StartStream<Item>(new ItemStarted(\"Blue item\")).Id;\n    await theSession.SaveChangesAsync();\n\n    theSession.Events.Append(id, new ItemWorked(), new ItemWorked(), new ItemFinished());\n    await theSession.SaveChangesAsync();\n\n    var item = await theSession.LoadAsync<Item>(id);\n\n    // RIP Glenn Frey, take it easy!\n    item.LastModifiedBy.ShouldBe(\"Glenn Frey\");\n    item.Version.ShouldBe(4);\n}\n```\n\n----------------------------------------\n\nTITLE: Async Upcasting with System.Text.Json JsonDocument\nDESCRIPTION: Demonstrates how to upcast events using System.Text.Json's `JsonDocument` for raw JSON transformation. It accesses properties using `GetProperty()` and performs type conversions. An `IClientRepository` dependency is used.  The example advises caution regarding N+1 problems if `UpcastAsync` involves resource-intensive operations during deserialization.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/versioning.md#_snippet_36\n\nLANGUAGE: cs\nCODE:\n```\npublic class ShoppingCartOpenedAsyncOnlyUpcaster:\n    AsyncOnlyEventUpcaster<ShoppingCartOpenedWithStatus>\n{\n    private readonly IClientRepository _clientRepository;\n\n    public ShoppingCartOpenedAsyncOnlyUpcaster(IClientRepository clientRepository) =>\n        _clientRepository = clientRepository;\n\n    public override string EventTypeName => \"shopping_cart_opened\";\n\n    protected override async Task<ShoppingCartOpenedWithStatus> UpcastAsync(\n        JsonDocument oldEventJson, CancellationToken ct\n    )\n    {\n        var oldEvent = oldEventJson.RootElement;\n\n        var clientId = oldEvent.GetProperty(\"ClientId\").GetGuid();\n\n        // WARNING: UpcastAsync method is called each time old event\n        // is read from database and deserialized.\n        // We discourage to run resource consuming methods here.\n        // It might end up with N+1 problem.\n        var clientName = await _clientRepository.GetClientName(clientId, ct);\n\n        return new ShoppingCartOpenedWithStatus(\n            oldEvent.GetProperty(\"ShoppingCartId\").GetGuid(),\n            new Client(clientId, clientName),\n            ShoppingCartStatus.Opened\n        );\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Querying with SQL and Parameters in Marten (C#)\nDESCRIPTION: This example demonstrates querying for `User` documents in Marten using parameterized SQL to avoid SQL injection vulnerabilities. It shows two methods: one using the default parameter placeholder and another with a custom placeholder ('$'). The code uses the `Query<User>()` and `QueryAsync<User>()` methods of the `IQuerySession` interface. The code assumes that the `session` variable is of type `IQuerySession`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/sql.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvar millers = session\n    .Query<User>(\"where data ->> 'LastName' = ?\", \"Miller\");\n\n// custom placeholder parameter\nvar millers2 = await session\n    .QueryAsync<User>('$', \"where data ->> 'LastName' = $\", \"Miller\");\n```\n\n----------------------------------------\n\nTITLE: Accessing Marten Projection Coordinator\nDESCRIPTION: Demonstrates accessing the `IProjectionCoordinator` service to manage the Marten async daemon for single or multi-tenant databases. It shows how to stop specific projection agents or all agents.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/async-daemon.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic static async Task accessing_the_daemon(IHost host)\n{\n    // This is a new service introduced by Marten 7.0 that\n    // is automatically registered as a singleton in your\n    // application by IServiceCollection.AddMarten()\n\n    var coordinator = host.Services.GetRequiredService<IProjectionCoordinator>();\n\n    // If targeting only a single database with Marten\n    var daemon = coordinator.DaemonForMainDatabase();\n    await daemon.StopAgentAsync(\"Trip:All\");\n\n    // If targeting multiple databases for multi-tenancy\n    var daemon2 = await coordinator.DaemonForDatabase(\"tenant1\");\n    await daemon.StopAllAsync();\n}\n```\n\n----------------------------------------\n\nTITLE: Querying for Non-Stale Data with Asynchronous Projections\nDESCRIPTION: This snippet demonstrates how to query for non-stale data in Marten using asynchronous projections. It configures Marten with an asynchronous projection and uses the QueryForNonStaleData method to ensure the projection is up-to-date before querying.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/async-daemon.md#_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\nbuilder.Services.AddMarten(opts =>\n{\n    opts.Connection(builder.Configuration.GetConnectionString(\"marten\"));\n    opts.Projections.Add<TripProjection>(ProjectionLifecycle.Async);\n}).AddAsyncDaemon(DaemonMode.HotCold);\n\nusing var host = builder.Build();\nawait host.StartAsync();\n\n// DocumentStore() is an extension method in Marten just\n// as a convenience method for test automation\nawait using var session = host.DocumentStore().LightweightSession();\n\n// This query operation will first \"wait\" for the asynchronous projection building the\n// Trip aggregate document to catch up to at least the highest event sequence number assigned\n// at the time this method is called\nvar latest = await session.QueryForNonStaleData<Trip>(5.Seconds())\n    .OrderByDescending(x => x.Started)\n    .Take(10)\n    .ToListAsync();\n```\n\n----------------------------------------\n\nTITLE: Filtering Documents with Basic Operators in Marten Linq using C#\nDESCRIPTION: Illustrates how to filter documents in a Marten database using basic operators in Linq.  Shows examples of using `Where()` with operators like `==`, `!=`, `>`, `>=`, `<`, and `<=`. It uses `IDocumentSession` to query the `Target` document type based on specified conditions and returns the results as a list asynchronously.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/operators.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\npublic async Task basic_operators(IDocumentSession session)\n{\n    // Field equals a value\n    await session.Query<Target>().Where(x => x.Number == 5).ToListAsync();\n\n    // Field does not equal a value\n    await session.Query<Target>().Where(x => x.Number != 5).ToListAsync();\n\n    // Field compared to values\n    await session.Query<Target>().Where(x => x.Number > 5).ToListAsync();\n    await session.Query<Target>().Where(x => x.Number >= 5).ToListAsync();\n    await session.Query<Target>().Where(x => x.Number < 5).ToListAsync();\n    await session.Query<Target>().Where(x => x.Number <= 5).ToListAsync();\n}\n```\n\n----------------------------------------\n\nTITLE: Aggregating Stream Into State with AggregateStreamAsync - C#\nDESCRIPTION: This snippet demonstrates how to aggregate a stream of events into an existing state using the `AggregateStreamAsync` method in Marten. It takes a `streamId`, a `baseState` object, and a `baseStateVersion` as input. This is useful for applying events to an object and updating its state.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/live-aggregates.md#_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nawait theSession.Events.AggregateStreamAsync(\n    streamId,\n    state: baseState,\n    fromVersion: baseStateVersion\n);\n```\n\n----------------------------------------\n\nTITLE: MyVersionedDoc Implementation - C#\nDESCRIPTION: This snippet demonstrates how to implement the `IVersioned` interface in a document type. Implementing `IVersioned` allows Marten to automatically manage the version of the document and apply optimistic concurrency checks. The `Version` property is automatically updated by Marten when the document is modified or loaded. Requires `Guid` namespace.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/concurrency.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic class MyVersionedDoc: IVersioned\n{\n    public Guid Id { get; set; }\n    public Guid Version { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Inserting and Loading Document by Strong Typed Id in C#\nDESCRIPTION: This snippet shows how to insert an `Invoice` document with a Vogen-generated `InvoiceId` and then load it using the `LoadAsync` method with the strong typed identifier. Marten automatically assigns an identity if none is provided during insertion. The loaded document is verified to ensure the data is loaded correctly.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/identity.md#_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic async Task update_a_document_smoke_test()\n{\n    var invoice = new Invoice();\n\n    // Just like you're used to with other identity\n    // strategies, Marten is able to assign an identity\n    // if none is provided\n    theSession.Insert(invoice);\n    await theSession.SaveChangesAsync();\n\n    invoice.Name = \"updated\";\n    await theSession.SaveChangesAsync();\n\n    // This is a new overload\n    var loaded = await theSession.LoadAsync<Invoice>(invoice.Id);\n    loaded.Name.ShouldBeNull(\"updated\");\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Deep Calculated Index (Marten)\nDESCRIPTION: This C# code snippet demonstrates how to create a calculated index for a nested property (`Inner.Color`) of a `Target` document type.  It showcases how to access deeply nested JSON properties within Marten's index configuration.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/computed_index.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic class Target\n{\n    public Guid Id { get; set; }\n    public Inner Inner { get; set; }\n}\n\npublic class Inner\n{\n    public string Color { get; set; }\n}\n\npublic class TargetConfiguration : Marten.Mapping.DocumentMapping<Target>\n{\n    public TargetConfiguration()\n    {\n        Index(x => x.Inner.Color);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Schema Extension in Marten (C#)\nDESCRIPTION: This snippet shows how to enable a Postgresql extension using `Weasel.Postgresql.Extension` and add it to Marten's extended schema objects. It enables the 'unaccent' extension which removes diacritic signs from strings, and applies the configuration changes to the database.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/schema/extensions.md#_snippet_5\n\nLANGUAGE: cs\nCODE:\n```\nStoreOptions(opts =>\n{\n    opts.RegisterDocumentType<Target>();\n\n    // Unaccent is an extension ships with postgresql\n    // and removes accents (diacritic signs) from strings\n    var extension = new Extension(\"unaccent\");\n\n    opts.Storage.ExtendedSchemaObjects.Add(extension);\n});\n\nawait theStore.Storage.ApplyAllConfiguredChangesToDatabaseAsync();\n```\n\n----------------------------------------\n\nTITLE: Querying Child Collections with Multiple Conditions (C#)\nDESCRIPTION: Demonstrates querying child collections with multiple conditions using the `&&` operator within the `Any()` method in Marten. This allows for searching based on the equality of multiple fields or properties within the child collection.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/child-collections.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar results = theSession\n    .Query<Target>()\n    .Where(x => x.Children.Any(_ => _.Number == 6 && _.Double == -1))\n    .ToArray();\n```\n\n----------------------------------------\n\nTITLE: Get Raw JSON Async Marten C#\nDESCRIPTION: This asynchronous version of the previous snippet demonstrates retrieving raw JSON from a Marten query. It stores an `Issue` document and then retrieves its JSON representation using asynchronous versions of the methods such as `ToJsonArray`, `ToJsonFirst`, `ToJsonFirstOrDefault`, `ToJsonSingle`, and `ToJsonSingleOrDefault` after applying a `Where` clause. It provides asynchronous alternatives for fetching raw JSON based on query results.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/query-json.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic async Task when_get_json_then_raw_json_should_be_returned_async()\n{\n    var issue = new Issue { Title = \"Issue 1\" };\n\n    theSession.Store(issue);\n    await theSession.SaveChangesAsync();\n    var json = await theSession.Query<Issue>().Where(x => x.Title == \"Issue 1\").ToJsonArray();\n    json.ShouldNotBeNull();\n\n    json = await theSession.Query<Issue>().ToJsonFirst();\n    json = await theSession.Query<Issue>().ToJsonFirstOrDefault();\n    json = await theSession.Query<Issue>().ToJsonSingle();\n    json = await theSession.Query<Issue>().ToJsonSingleOrDefault();\n}\n```\n\n----------------------------------------\n\nTITLE: Deleting Property from Multiple Documents with Patch - C#\nDESCRIPTION: This code snippet demonstrates how to delete a property from multiple documents based on a `Where` expression. It uses `Patch.Delete()` in conjunction with `WhereFragment` to target specific documents and remove the specified property. It also asserts the count before and after the operation.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/partial-updates-patching.md#_snippet_16\n\nLANGUAGE: cs\nCODE:\n```\nconst string where = \"(data ->> 'String') is not null\";\ntheSession.Query<Target>(where).Count.ShouldBe(15);\ntheSession.Patch<Target>(new WhereFragment(where)).Delete(\"String\");\nawait theSession.SaveChangesAsync();\n\nusing (var query = theStore.QuerySession())\n{\n    query.Query<Target>(where).Count(t => t.String != null).ShouldBe(0);\n}\n```\n\n----------------------------------------\n\nTITLE: Aggregation Using Event Metadata C#\nDESCRIPTION: This snippet demonstrates accessing event metadata (timestamps, correlation id, custom headers) during aggregation within a Marten projection. The `Create` method accesses metadata through `IEvent<T>`, and the `Apply` method accesses it through `IEvent`. This enables capturing event-specific information and associating it with the aggregate.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/aggregate-projections.md#_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\npublic class TripProjection: SingleStreamProjection<Trip>\n{\n    // Access event metadata through IEvent<T>\n    public Trip Create(IEvent<TripStarted> @event)\n    {\n        var trip = new Trip\n        {\n            Id = @event.StreamId, // Marten does this for you anyway\n            Started = @event.Timestamp,\n            CorrelationId = @event.Timestamp, // Open telemetry type tracing\n            Description = @event.Data.Description // Still access to the event body\n        };\n\n        // Use a custom header\n        if (@event.Headers.TryGetValue(\"customer\", out var customerId))\n        {\n            trip.CustomerId = (string)customerId;\n        }\n\n        return trip;\n    }\n\n    public void Apply(TripEnded ended, Trip trip, IEvent @event)\n    {\n        trip.Ended = @event.Timestamp;\n    }\n\n    // Other Apply/ShouldDelete methods\n\n    public override ValueTask RaiseSideEffects(IDocumentOperations operations, IEventSlice<Trip> slice)\n    {\n        // Emit other events or messages during asynchronous projection\n        // processing\n\n        // Access to the current state as of the projection\n        // event page being processed *right* now\n        var currentTrip = slice.Aggregate;\n\n        if (currentTrip.TotalMiles > 1000)\n        {\n            // Append a new event to this stream\n            slice.AppendEvent(new PassedThousandMiles());\n\n            // Append a new event to a different event stream by\n            // first specifying a different stream id\n            slice.AppendEvent(currentTrip.InsuranceCompanyId, new IncrementThousandMileTrips());\n\n            // \"Publish\" outgoing messages when the event page is successfully committed\n            slice.PublishMessage(new SendCongratulationsOnLongTrip(currentTrip.Id));\n\n            // And yep, you can make additional changes to Marten\n            operations.Store(new CompletelyDifferentDocument\n            {\n                Name = \"New Trip Segment\",\n                OriginalTripId = currentTrip.Id\n            });\n        }\n\n        // This usage has to be async in case you're\n        // doing any additional data access with the\n        // Marten operations\n        return new ValueTask();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Live Marten Projection Aggregation in C#\nDESCRIPTION: This snippet demonstrates how to test a live (Async lifecycle) Marten projection.  It sets up an in-memory Marten document store, starts an event stream, appends events to the stream, and then uses `AggregateStreamAsync()` to project the events into an `Invoice` document. The test asserts that the `Invoice` document's properties have the expected values based on the events.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/testing.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic async Task test_live_aggregation()\n{\n    using var store = DocumentStore.For(opts =>\n    {\n        opts.Connection(\n            \"Host=localhost;Port=5432;Database=marten_testing;Username=postgres;password=postgres;Command Timeout=5\");\n        opts.DatabaseSchemaName = \"incidents\";\n    });\n\n    var invoiceId = Guid.NewGuid();\n\n    // Pump in events\n    using (var session = store.LightweightSession())\n    {\n\n        session.Events.StartStream<Invoice>(invoiceId, new InvoiceCreated(\"Blue Shoes\", 112.24m));\n        await session.SaveChangesAsync();\n\n        session.Events.Append(invoiceId,new InvoiceApproved());\n        session.Events.Append(invoiceId,new InvoicePaid());\n        await session.SaveChangesAsync();\n    }\n\n    await using var query = store.QuerySession();\n\n    var invoice = await query.Events.AggregateStreamAsync<Invoice>(invoiceId);\n    invoice.Description.ShouldBe(\"Blue Shoes\");\n    invoice.Status.ShouldBe(InvoiceStatus.Paid);\n}\n```\n\n----------------------------------------\n\nTITLE: Delete Mixed Document Types - Marten - C#\nDESCRIPTION: Demonstrates deleting a mix of different document types using the DeleteObjects method. It first stores different document types and then deletes specified instances. Requires an active IDocumentSession and an IEnumerable<object> containing the document instances to delete.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/deletes.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n// Store a mix of different document types\nvar user1 = new User { FirstName = \"Jamie\", LastName = \"Vaughan\" };\nvar issue1 = new Issue { Title = \"Running low on coffee\" };\nvar company1 = new Company { Name = \"ECorp\" };\n\nsession.StoreObjects(new object[] { user1, issue1, company1 });\n\nawait session.SaveChangesAsync();\n\n// Delete a mix of documents types\nusing (var documentSession = theStore.LightweightSession())\n{\n    documentSession.DeleteObjects(new object[] { user1, company1 });\n\n    await documentSession.SaveChangesAsync();\n}\n```\n\n----------------------------------------\n\nTITLE: Opening a Document Session\nDESCRIPTION: This code snippet shows how to open a document session using `IDocumentStore`. It also shows how to load a document by its ID.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/getting_started.md#_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\n// Options +=> GettingStarted/opening_sessions.cs\nusing System;\nusing Marten;\n\npublic class opening_sessions\n{\n    public void opening_sessions_sample()\n    {\n        using (var store = DocumentStore.For(\"host=localhost;database=marten;username=postgres;password=YOUR_PASSWORD\"))\n        {\n            // Opening a new session to work with Marten\n            using (var session = store.OpenSession())\n            {\n                var user = new User { FirstName = \"Jeremy\", LastName = \"Miller\" };\n\n                session.Store(user);\n\n                // Marten is smart enough to update the user.Id\n                // *after* the document has been assigned an Id\n                Console.WriteLine(\"Just stored user.Id = \" + user.Id);\n\n                session.SaveChanges();\n            }\n\n            using (var session = store.OpenSession())\n            {\n                // Look up that user by the document id\n                var jeremy = session.Load<User>(Guid.NewGuid());\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Writing Single Document from Linq Query to HttpContext (Marten)\nDESCRIPTION: This C# code demonstrates writing a single document to the HTTP response using a Linq query with the `WriteSingle` extension method.  It finds the first document matching the specified `issueId` and streams its raw JSON to the `HttpContext.Response.Body`. The `onFoundStatus` parameter customizes the HTTP status code when a document is located. Dependency: `IQuerySession`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/aspnetcore.md#_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\n[HttpGet(\"/issue2/{issueId}\")]\npublic Task Get2(Guid issueId, [FromServices] IQuerySession session, [FromQuery] string? sc = null)\n{\n    return sc is null\n        ? session.Query<Issue>().Where(x => x.Id == issueId)\n            .WriteSingle(HttpContext)\n        : session.Query<Issue>().Where(x => x.Id == issueId)\n            .WriteSingle(HttpContext, onFoundStatus: int.Parse(sc));\n}\n```\n\n----------------------------------------\n\nTITLE: Find JSON by Id Async Marten C#\nDESCRIPTION: This asynchronous code snippet demonstrates how to retrieve a JSON representation of a document from a Marten database using the `FindByIdAsync` method. Similar to the synchronous version, it stores an `Issue` document and then retrieves its JSON representation. It uses `await theSession.Json.FindByIdAsync<Issue>(issue.Id)` to asynchronously fetch the JSON.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/query-json.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic async Task when_find_then_a_json_should_be_returned()\n{\n    var issue = new Issue { Title = \"Issue 2\" };\n\n    theSession.Store(issue);\n    await theSession.SaveChangesAsync();\n\n    var json = await theSession.Json.FindByIdAsync<Issue>(issue.Id);\n    json.ShouldBe(${{\"Id\": \"{{issue.Id}}\", \"Tags\": null, \"BugId\": null, \"Title\": \"Issue 2\", \"Number\": 0, \"Status\": null, \"AssigneeId\": null, \"ReporterId\": null}});\n}\n```\n\n----------------------------------------\n\nTITLE: Soft Delete with Index Fluent Interface Configuration in Marten (C#)\nDESCRIPTION: This code snippet demonstrates configuring soft deletes with an index using the fluent interface. It utilizes the `SoftDeletedWithIndex()` method within the `DocumentStore.For()` configuration to define the schema behavior. This provides an alternative to the attribute-based approach. This will create a partial index that only indexes documents when they are marked as deleted, optimizing queries that use `IsDeleted()`, `DeletedSince(DateTimeOffset)` and `DeletedBefore(DateTimeOffset)`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/indexing/metadata-indexes.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nDocumentStore.For(_ =>\n{\n    _.Schema.For<User>().SoftDeletedWithIndex();\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Global Hilo Defaults\nDESCRIPTION: This snippet demonstrates how to set global defaults for Hilo sequence generation. It customizes the `MaxLo` property and establishes the database connection.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/identity.md#_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n    _.Advanced.HiloSequenceDefaults.MaxLo = 55;\n    _.Connection(ConnectionSource.ConnectionString);\n    _.DatabaseSchemaName = \"sequences\";\n});\n```\n\n----------------------------------------\n\nTITLE: Paging with ToPagedList in Marten (C#)\nDESCRIPTION: This code snippet demonstrates how to use the `ToPagedList` extension method in Marten for retrieving paged data from a database. It showcases how to specify the page number and page size, and then accesses various properties related to pagination, such as total item count, page count, and flags indicating first/last page status. The `theSession` object is assumed to be an active Marten session.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/paging.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvar pageNumber = 2;\nvar pageSize = 10;\n\nvar pagedList = theSession.Query<Target>().ToPagedList(pageNumber, pageSize);\n\n// paged list also provides a list of helper properties to deal with pagination aspects\nvar totalItems = pagedList.TotalItemCount; // get total number records\nvar pageCount = pagedList.PageCount; // get number of pages\nvar isFirstPage = pagedList.IsFirstPage; // check if current page is first page\nvar isLastPages = pagedList.IsLastPage; // check if current page is last page\nvar hasNextPage = pagedList.HasNextPage; // check if there is next page\nvar hasPrevPage = pagedList.HasPreviousPage; // check if there is previous page\nvar firstItemOnPage = pagedList.FirstItemOnPage; // one-based index of first item in current page\nvar lastItemOnPage = pagedList.LastItemOnPage; // one-based index of last item in current page\n```\n\n----------------------------------------\n\nTITLE: Configuring Master Table Multi-Tenancy in Marten (C#)\nDESCRIPTION: This code snippet demonstrates how to configure Marten to use a master database table for multi-tenancy, enabling runtime discovery of tenant databases. It uses the `MultiTenantedDatabasesWithMasterDatabaseTable` method to specify the connection string, schema name, and database registration. It also showcases the `ApplyAllDatabaseChangesOnStartup` method to ensure all configured changes are applied to all tenant databases upon application startup. Requires Marten V7 or later.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/multitenancy.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .ConfigureServices(services =>\n    {\n        services.AddMarten(sp =>\n            {\n                var configuration = sp.GetRequiredService<IConfiguration>();\n                var masterConnection = configuration.GetConnectionString(\"master\");\n                var options = new StoreOptions();\n\n                // This is opting into a multi-tenancy model where a database table in the\n                // master database holds information about all the possible tenants and their database connection\n                // strings\n                options.MultiTenantedDatabasesWithMasterDatabaseTable(x =>\n                {\n                    x.ConnectionString = masterConnection;\n\n                    // You can optionally configure the schema name for where the mt_tenants\n                    // table is stored\n                    x.SchemaName = \"tenants\";\n\n                    // If set, this will override the database schema rules for\n                    // only the master tenant table from the parent StoreOptions\n                    x.AutoCreate = AutoCreate.CreateOrUpdate;\n\n                    // Optionally seed rows in the master table. This may be very helpful for\n                    // testing or local development scenarios\n                    // This operation is an \"upsert\" upon application startup\n                    x.RegisterDatabase(\"tenant1\", configuration.GetConnectionString(\"tenant1\"));\n                    x.RegisterDatabase(\"tenant2\", configuration.GetConnectionString(\"tenant2\"));\n                    x.RegisterDatabase(\"tenant3\", configuration.GetConnectionString(\"tenant3\"));\n\n                    // Tags the application name to all the used connection strings as a diagnostic\n                    // Default is the name of the entry assembly for the application or \"Marten\" if\n                    // .NET cannot determine the entry assembly for some reason\n                    x.ApplicationName = \"MyApplication\";\n                });\n\n                // Other Marten configuration\n\n                return options;\n            })\n            // All detected changes will be applied to all\n            // the configured tenant databases on startup\n            .ApplyAllDatabaseChangesOnStartup();;\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Previewing LINQ Explain Plan\nDESCRIPTION: Illustrates how to retrieve and display the PostgreSQL EXPLAIN plan for a LINQ query.  It uses the `Explain()` extension method and then prints various properties of the resulting plan.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/diagnostics.md#_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\n// Explain() is an extension method off of IQueryable<T>\nvar plan = queryable.Explain();\nConsole.WriteLine($\"NodeType: {plan.NodeType}\");\nConsole.WriteLine($\"RelationName: {plan.RelationName}\");\nConsole.WriteLine($\"Alias: {plan.Alias}\");\nConsole.WriteLine($\"StartupCost: {plan.StartupCost}\");\nConsole.WriteLine($\"TotalCost: {plan.TotalCost}\");\nConsole.WriteLine($\"PlanRows: {plan.PlanRows}\");\nConsole.WriteLine($\"PlanWidth: {plan.PlanWidth}\");\n```\n\n----------------------------------------\n\nTITLE: Testing Generated Code with Marten CLI\nDESCRIPTION: This Bash command uses the Marten command-line interface (CLI) to test the validity of the generated code, ensuring that the code generation process is working correctly.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/prebuilding.md#_snippet_8\n\nLANGUAGE: Bash\nCODE:\n```\ndotnet run -- codegen test\n```\n\n----------------------------------------\n\nTITLE: Querying Soft Deleted Documents SQL - SQL\nDESCRIPTION: This snippet shows the SQL generated by Marten when querying for non-deleted documents.  The `mt_deleted = False` clause is automatically added to filter out deleted records. This SQL is executed when using `Query<User>()` by default.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/advanced/soft_deletes.md#_snippet_3\n\nLANGUAGE: SQL\nCODE:\n```\nselect d.data ->> 'UserName' from public.mt_doc_user as d where mt_deleted = False order by d.data ->> 'UserName'\n```\n\n----------------------------------------\n\nTITLE: Overriding Hilo with Attribute\nDESCRIPTION: This snippet demonstrates how to override the Hilo configuration for a specific document type using the `[HiloSequence]` attribute. It sets the `MaxLo` and `SequenceName` properties for the `OverriddenHiloDoc` class.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/identity.md#_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\n[HiloSequence(MaxLo = 66, SequenceName = \"Entity\")]\npublic class OverriddenHiloDoc\n{\n    public int Id { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Ordering Results with Linq in Marten (C#)\nDESCRIPTION: Illustrates how to order the results of a Linq query in both ascending (`OrderBy()`) and descending (`OrderByDescending()`) order.  The example orders the documents by the `Number` property.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/linq.md#_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\nvar ordered = session.Query<Target>().OrderBy(x => x.Number).ToList();\nvar descending = session.Query<Target>().OrderByDescending(x => x.Number).ToList();\n```\n\n----------------------------------------\n\nTITLE: Defining Event and View Classes\nDESCRIPTION: This snippet defines a set of event and view classes used in the MultiStreamProjection examples. It includes events for license management (LicenseCreated, LicenseFeatureToggled, LicenseFeatureToggledOff), user group management (UserGroupCreated, SingleUserAssignedToGroup, MultipleUsersAssignedToGroup), and user management (UserRegistered, UserLicenseAssigned).  It also defines the views UserFeatureToggles and UserGroupsAssignment.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/multi-stream-projections.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IUserEvent\n{\n    Guid UserId { get; }\n}\n\n// License events\npublic class LicenseCreated\n{\n    public Guid LicenseId { get; }\n\n    public string Name { get; }\n\n    public LicenseCreated(Guid licenseId, string name)\n    {\n        LicenseId = licenseId;\n        Name = name;\n    }\n}\n\npublic class LicenseFeatureToggled\n{\n    public Guid LicenseId { get; }\n\n    public string FeatureToggleName { get; }\n\n    public LicenseFeatureToggled(Guid licenseId, string featureToggleName)\n    {\n        LicenseId = licenseId;\n        FeatureToggleName = featureToggleName;\n    }\n}\n\npublic class LicenseFeatureToggledOff\n{\n    public Guid LicenseId { get; }\n\n    public string FeatureToggleName { get; }\n\n    public LicenseFeatureToggledOff(Guid licenseId, string featureToggleName)\n    {\n        LicenseId = licenseId;\n        FeatureToggleName = featureToggleName;\n    }\n}\n\n// User Groups events\n\npublic class UserGroupCreated\n{\n    public Guid GroupId { get; }\n\n    public string Name { get; }\n\n    public UserGroupCreated(Guid groupId, string name)\n    {\n        GroupId = groupId;\n        Name = name;\n    }\n}\n\npublic class SingleUserAssignedToGroup : IUserEvent\n{\n    public Guid GroupId { get; }\n\n    public Guid UserId { get; }\n\n    public SingleUserAssignedToGroup(Guid groupId, Guid userId)\n    {\n        GroupId = groupId;\n        UserId = userId;\n    }\n}\n\npublic class MultipleUsersAssignedToGroup\n{\n    public Guid GroupId { get; }\n\n    public List<Guid> UserIds { get; }\n\n    public MultipleUsersAssignedToGroup(Guid groupId, List<Guid> userIds)\n    {\n        GroupId = groupId;\n        UserIds = userIds;\n    }\n}\n\n// User Events\npublic class UserRegistered : IUserEvent\n{\n    public Guid UserId { get; }\n\n    public string Email { get; }\n\n    public UserRegistered(Guid userId, string email)\n    {\n        UserId = userId;\n        Email = email;\n    }\n}\n\npublic class UserLicenseAssigned\n{\n    public Guid UserId { get; }\n\n    public Guid LicenseId { get; }\n\n    public UserLicenseAssigned(Guid userId, Guid licenseId)\n    {\n        UserId = userId;\n        LicenseId = licenseId;\n    }\n}\n\npublic class UserFeatureToggles\n{\n    public Guid Id { get; set; }\n\n    public Guid LicenseId { get; set; }\n\n    public List<string> FeatureToggles { get; set; } = new();\n}\n\npublic class UserGroupsAssignment\n{\n    public Guid Id { get; set; }\n\n    public List<Guid> Groups { get; set; } = new();\n}\n```\n\n----------------------------------------\n\nTITLE: Async Upcasting Event with CLR types in Marten\nDESCRIPTION: This code snippet shows how to configure an asynchronous upcaster lambda expression with Marten.  It converts a ShoppingCartOpened event to a ShoppingCartOpenedWithStatus event by retrieving the client's name asynchronously from a client repository.  This example highlights potential N+1 performance issues when using asynchronous upcasters.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/versioning.md#_snippet_25\n\nLANGUAGE: cs\nCODE:\n```\noptions.Events\n    .Upcast<ShoppingCartOpened, ShoppingCartOpenedWithStatus>(\n        async (oldEvent, ct) =>\n        {\n            // WARNING: UpcastAsync method is called each time old event\n            // is read from database and deserialized.\n            // We discourage to run resource consuming methods here.\n            // It might end up with N+1 problem.\n            var clientName = await clientRepository.GetClientName(oldEvent.ClientId, ct);\n\n            return new ShoppingCartOpenedWithStatus(\n                oldEvent.ShoppingCartId,\n                new Client(oldEvent.ClientId, clientName),\n                ShoppingCartStatus.Opened\n            );\n        }\n    );\n```\n\n----------------------------------------\n\nTITLE: Find JSON by Id Marten C#\nDESCRIPTION: This code snippet demonstrates how to retrieve a JSON representation of a document from a Marten database using the `FindById` method. It first stores an `Issue` document and then retrieves its JSON representation using its Id. It uses `theSession.Json.FindById<Issue>(issue.Id)` to fetch the JSON.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/query-json.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic async Task when_find_then_a_json_should_be_returned()\n{\n    var issue = new Issue { Title = \"Issue 2\" };\n\n    theSession.Store(issue);\n    await theSession.SaveChangesAsync();\n\n    var json = theSession.Json.FindById<Issue>(issue.Id);\n    json.ShouldBe(${{\"Id\": \"{{issue.Id}}\", \"Tags\": null, \"BugId\": null, \"Title\": \"Issue 2\", \"Number\": 0, \"Status\": null, \"AssigneeId\": null, \"ReporterId\": null}});\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Document Session Listener - C#\nDESCRIPTION: This snippet demonstrates how to register a custom `IDocumentSessionListener` with the Marten `DocumentStore`. It instantiates a listener and then adds it to the `Listeners` collection within the `StoreOptions` configuration.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/diagnostics.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nvar stub1 = new StubDocumentSessionListener();\nvar stub2 = new StubDocumentSessionListener();\n\nusing (var store = SeparateStore(_ =>\n       {\n           _.Connection(ConnectionSource.ConnectionString);\n           _.AutoCreateSchemaObjects = AutoCreate.All;\n\n           _.Listeners.Add(stub1);\n           _.Listeners.Add(stub2);\n       }))\n```\n\n----------------------------------------\n\nTITLE: Distinct Numbers Query with Marten (C#)\nDESCRIPTION: This code snippet shows how to use the `Distinct()` operator with a `Select()` transform to retrieve distinct combinations of `Number` and `Decimal` properties from the `Target` document in Marten.  It stores `Target` objects with different combinations of `Number` and `Decimal` values, then queries for distinct combinations using `Select()` and `Distinct()` and asserts that the correct number of distinct combinations are returned.  It depends on xUnit for testing and Shouldly for assertions. The SerializerTypeTargetedFact attribute specifies that this test should run for the Newtonsoft serializer.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/operators.md#_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\n[SerializerTypeTargetedFact(RunFor = SerializerType.Newtonsoft)]\npublic async Task get_distinct_numbers()\n{\n    theSession.Store(new Target {Number = 1, Decimal = 1.0M});\n    theSession.Store(new Target {Number = 1, Decimal = 2.0M});\n    theSession.Store(new Target {Number = 1, Decimal = 2.0M});\n    theSession.Store(new Target {Number = 2, Decimal = 1.0M});\n    theSession.Store(new Target {Number = 2, Decimal = 2.0M});\n    theSession.Store(new Target {Number = 2, Decimal = 1.0M});\n\n    await theSession.SaveChangesAsync();\n\n    var queryable = theSession.Query<Target>().Select(x => new\n    {\n        x.Number,\n        x.Decimal\n    }).Distinct();\n\n    queryable.ToList().Count.ShouldBe(4);\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Session Factory Implementation - C#\nDESCRIPTION: This snippet shows how to create a custom implementation of the `ISessionFactory` interface. This allows overriding the default session creation behavior, such as setting different transaction isolation levels or adding custom session listeners. Requires implementing the `ISessionFactory` interface.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/integration.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:CustomSessionFactory]>\n```\n\n----------------------------------------\n\nTITLE: Querying with Select() for deep properties in Marten (C#)\nDESCRIPTION: This snippet shows how to project deep, nested properties. Specifically, it retrieves `Inner.Number` from the `Target` document where `Number` matches a certain value, and then asserts that the retrieved values are as expected. Requires `theStore` to be an initialized `IDocumentStore` with bulk inserted `Target` documents.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/projections.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic void transform_with_deep_properties()\n{\n    var targets = Target.GenerateRandomData(100).ToArray();\n\n    theStore.BulkInsert(targets);\n\n    var actual = theSession.Query<Target>().Where(x => x.Number == targets[0].Number).Select(x => x.Inner.Number).ToList().Distinct();\n\n    var expected = targets.Where(x => x.Number == targets[0].Number).Select(x => x.Inner.Number).Distinct();\n\n    actual.ShouldHaveTheSameElementsAs(expected);\n}\n```\n\n----------------------------------------\n\nTITLE: Include Single Document with Marten in C#\nDESCRIPTION: This code snippet demonstrates how to include a single related document when querying with Marten. It fetches an `Issue` along with its assigned `User` in a single database trip. The `Include()` method is used with an expression to assign the fetched `User` to a variable, and `On()` specifies the join condition based on `AssigneeId`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/include.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic async Task simple_include_for_a_single_document()\n{\n    var user = new User();\n    var issue = new Issue { AssigneeId = user.Id, Title = \"Garage Door is busted\" };\n\n    using var session = theStore.IdentitySession();\n    session.Store<object>(user, issue);\n    await session.SaveChangesAsync();\n\n    using var query = theStore.QuerySession();\n    query.Logger = new TestOutputMartenLogger(_output);\n\n    User included = null;\n    var issue2 = query\n        .Query<Issue>()\n        .Include<User>(x => included = x).On(x => x.AssigneeId)\n        .Single(x => x.Title == issue.Title);\n\n    included.ShouldNotBeNull();\n    included.Id.ShouldBe(user.Id);\n\n    issue2.ShouldNotBeNull();\n}\n```\n\n----------------------------------------\n\nTITLE: Querying with Select() for anonymous type in Marten (C#)\nDESCRIPTION: This example demonstrates projecting data into an anonymous type using `Select()`. It retrieves the `FirstName` property from the `User` document and projects it into a new anonymous type with a `Name` property. It then asserts that the projected names match the expected values. Requires `theSession` to be an initialized `IDocumentSession` with `User` documents stored.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/projections.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic async Task use_select_to_transform_to_an_anonymous_type()\n{\n    theSession.Store(new User { FirstName = \"Hank\" });\n    theSession.Store(new User { FirstName = \"Bill\" });\n    theSession.Store(new User { FirstName = \"Sam\" });\n    theSession.Store(new User { FirstName = \"Tom\" });\n\n    await theSession.SaveChangesAsync();\n\n    theSession.Query<User>().OrderBy(x => x.FirstName).Select(x => new { Name = x.FirstName })\n        .ToArray()\n        .Select(x => x.Name)\n        .ShouldHaveTheSameElementsAs(\"Bill\", \"Hank\", \"Sam\", \"Tom\");\n}\n```\n\n----------------------------------------\n\nTITLE: Starting a New Stream with Aggregate Type (C#)\nDESCRIPTION: This snippet shows how to start a new event stream in Marten, associating it with an aggregate type (Quest in this case). Marten assigns a new Guid ID to the stream.  Currently, the aggregate type is only metadata and isn't used for any processing, though future versions will potentially use it for projections or versioned snapshots.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/events/appending.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nusing var store = DocumentStore.Empty();\n\n// Starting a brand new stream\nvar quest = new QuestStarted { Name = \"Find the Orb\" };\n\nusing var session = store.OpenSession();\n\n// Use StartStream() to start a new event stream\nvar stream = session.Events.StartStream(quest);\n\nConsole.WriteLine($\"New stream id => {stream.Id}\");\n\nsession.SaveChanges();\n```\n\n----------------------------------------\n\nTITLE: Case-Insensitive String Matching with EqualsIgnoreCase (C#)\nDESCRIPTION: Demonstrates case-insensitive string matching using the `EqualsIgnoreCase()` extension method from the *Baseline* library. This provides a shorthand for `String.Equals` with `StringComparison.CurrentCultureIgnoreCase`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/linq.md#_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\npublic static class StringExtensions\n{\n    public static bool EqualsIgnoreCase(this string target, string other)\n    {\n        return string.Equals(target, other, StringComparison.CurrentCultureIgnoreCase);\n    }\n}\n\n\nvar targets = session.Query<Target>()\n    .Where(x => x.String.EqualsIgnoreCase(\"foo\")).ToList();\n```\n\n----------------------------------------\n\nTITLE: Serializable Saga Transaction with Marten\nDESCRIPTION: Illustrates how to open a serializable transaction within a Marten session for use cases like the Saga pattern.  This ensures serialized message handling for a single saga by using a serializable transaction. The code defines a saga state class and an async method that opens a serializable session, loads saga state, performs work, and saves changes.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/sessions.md#_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\npublic class MySagaState\n{\n    public Guid Id { get; set; }\n}\n\npublic async Task execute_saga_serializable(IDocumentStore store, Guid sagaId, CancellationToken ct)\n{\n    // The session below will open its connection and start a\n    // serializable transaction avoiding blocking calls\n    await using var session = await store.LightweightSerializableSessionAsync(ct);\n    var state = await session.LoadAsync<MySagaState>(sagaId, ct);\n\n    // do some work against the saga\n\n    await session.SaveChangesAsync(ct);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Transformation Class and Read-Side Document in C#\nDESCRIPTION: This code demonstrates the creation of a transformation class (`MonsterDefeatedTransform`) that implements the `ITransform` interface, along with a corresponding read-side document (`MonsterDefeated`). This class transforms `MonsterSlayed` events into `MonsterDefeated` documents, capturing the time of the event.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/events/projections/index.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic record MonsterSlayed(string Name, string Slayer);\n\npublic record MonsterDefeated(string Name, string Slayer, DateTime Time);\n\npublic class MonsterDefeatedTransform : ITransform<MonsterSlayed, MonsterDefeated>\n{\n    public MonsterDefeated Create(MonsterSlayed input)\n    {\n        return new MonsterDefeated(input.Name, input.Slayer, DateTime.UtcNow);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Default Schema Name in Marten (C#)\nDESCRIPTION: This code snippet demonstrates how to override the default `public` schema for Marten's document tables and functions using `StoreOptions.DatabaseSchemaName`.  By setting this property, all Marten-created tables and functions will be placed in the specified schema. This setting affects the Hilo sequence table as well.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/schema/index.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nstoreOptions.DatabaseSchemaName = \"other\";\n```\n\n----------------------------------------\n\nTITLE: Configuring Mapping-Specific Custom ID Generation C#\nDESCRIPTION: This code snippet demonstrates how to define a custom ID generation algorithm for a specific document type in Marten. It configures the ID strategy within the document mapping configuration.  It requires referencing the Marten library.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/identity/custom.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n    _.Connection(\"some connection string\");\n    _.Schema.For<User>().IdStrategy(new MyCustomIdGeneration());\n});\n```\n\n----------------------------------------\n\nTITLE: Creating an Invoice Instance in C#\nDESCRIPTION: This snippet shows how to create an instance of the `Invoice` aggregate. This invoice will subsequently be persisted and rehydrated from the event stream.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/scenarios/aggregates_events_repositories.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:scenario-aggregate-createinvoice]>\n```\n\n----------------------------------------\n\nTITLE: Creating Integration Context Base Class\nDESCRIPTION: Creates an abstract base class `IntegrationContext` for integration tests. It initializes the Alba host and the Marten document store and provides a method to reset the database state before each test. It depends on `IAlbaHost`, `IDocumentStore`, and `AppFixture`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/testing/integration.md#_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\npublic abstract class IntegrationContext : IAsyncLifetime\n{\n    protected IntegrationContext(AppFixture fixture)\n    {\n        Host = fixture.Host;\n        Store = Host.Services.GetRequiredService<IDocumentStore>();\n    }\n     \n    public IAlbaHost Host { get; }\n    public IDocumentStore Store { get; }\n     \n    public async Task InitializeAsync()\n    {\n        // Using Marten, wipe out all data and reset the state\n        await Store.Advanced.ResetAllData();\n    }\n \n    // This is required because of the IAsyncLifetime \n    // interface. Note that I do *not* tear down database\n    // state after the test. That's purposeful\n    public Task DisposeAsync()\n    {\n        return Task.CompletedTask;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Loading a Single Event with Marten in C#\nDESCRIPTION: This code snippet demonstrates how to load a single event by its ID using `IEventStore.Load()` and `IEventStore.LoadAsync()` methods in Marten. It provides examples for loading the event with a known event type and with an unknown event type. Requires a document session and an event ID.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/querying.md#_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic void load_a_single_event_synchronously(IDocumentSession session, Guid eventId)\n{\n    // If you know what the event type is already\n    var event1 = session.Events.Load<MembersJoined>(eventId);\n\n    // If you do not know what the event type is\n    var event2 = session.Events.Load(eventId);\n}\n\npublic async Task load_a_single_event_asynchronously(IDocumentSession session, Guid eventId)\n{\n    // If you know what the event type is already\n    var event1 = await session.Events.LoadAsync<MembersJoined>(eventId);\n\n    // If you do not know what the event type is\n    var event2 = await session.Events.LoadAsync(eventId);\n}\n```\n\n----------------------------------------\n\nTITLE: Trade Document Type (C#)\nDESCRIPTION: This snippet shows a simple document type called `Trade` with properties `Id` and `Value`.  The `[DuplicateField]` attribute on the `Value` property directs Marten to duplicate the value into a separate database field for more efficient querying.  `[DuplicateField]` is used for optimizing query performance.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/diagnostics.md#_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Trade\n{\n    public Guid Id { get; set; }\n\n    [DuplicateField]\n    public decimal Value { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Hilo Sequence Name\nDESCRIPTION: This code demonstrates how to set a global default sequence name for Hilo sequence generation. This configuration allows multiple document types to share the same Hilo sequence, incrementing a shared counter.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/identity.md#_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n    _.Advanced.HiloSequenceDefaults.SequenceName = \"Entity\";\n    _.Connection(ConnectionSource.ConnectionString);\n\n    _.DatabaseSchemaName = \"sequences\";\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Nullable Property\nDESCRIPTION: This snippet demonstrates adding a new, non-required property (`OpenedAt`) to the `ShoppingCartOpened` event using a nullable `DateTime?` type. This allows older events without this property to still be deserialized without errors.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/versioning.md#_snippet_6\n\nLANGUAGE: cs\nCODE:\n```\npublic record ShoppingCartOpened(\n    Guid ShoppingCartId,\n    Guid ClientId,\n    // Adding new not required property as nullable\n    DateTime? OpenedAt\n);\n```\n\n----------------------------------------\n\nTITLE: Searching within String Fields using Linq in Marten (C#)\nDESCRIPTION: Demonstrates how to use `String.StartsWith()`, `String.EndsWith()`, and `String.Contains()` to perform substring searches on string fields. These methods allow for flexible pattern matching within string properties.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/linq.md#_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic class Target\n{\n    public Guid Id { get; set; }\n    public string[] Tags { get; set; }\n    public Inner[] Children { get; set; }\n    public int? NullableNumber { get; set; }\n    public Outer Outer { get; set; }\n    public string String { get; set; }\n\n}\n\npublic class Inner\n{\n    public string Name { get; set; }\n    public int Age { get; set; }\n}\n\npublic class Outer\n{\n    public Middle Middle { get; set; }\n}\n\npublic class Middle\n{\n    public string Name { get; set; }\n}\n\nvar targets = session.Query<Target>()\n    .Where(x => x.String.StartsWith(\"foo\"))\n    .Where(x => x.String.EndsWith(\"bar\"))\n    .Where(x => x.String.Contains(\"baz\")).ToList();\n```\n\n----------------------------------------\n\nTITLE: Querying Soft Deleted Documents - C#\nDESCRIPTION: This snippet demonstrates how Marten automatically filters out soft-deleted documents from Linq queries. By default, queries will only return documents that have not been marked as deleted, providing a convenient way to exclude deleted documents from search results.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/advanced/soft_deletes.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nvar users = await session.Query<User>().OrderBy(x => x.UserName).ToListAsync();\nusers.Each(x => x.Deleted).ShouldAllBe(false);\n\nvar notDeleted = await session.Query<User>().Where(x => !x.Deleted).ToListAsync();\nnotDeleted.Count.ShouldBe(users.Count);\n\nvar stillNotDeleted = await session.Query<User>().Where(x => x.Deleted == false).ToListAsync();\nstillNotDeleted.Count.ShouldBe(users.Count);\n```\n\n----------------------------------------\n\nTITLE: Batch Query with Compiled Queries in Marten (C#)\nDESCRIPTION: Illustrates how to use a compiled query within a batch query in Marten. This involves creating an instance of the compiled query and passing it to the `IBatchedQuery.Query(ICompiledQuery)` method.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/batched_queries.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic async Task batch_query_with_compiled_queries(IDocumentStore store)\n{\n    using (var session = store.OpenSession())\n    {\n        var user1 = new User { FirstName = \"Jeremy\", LastName = \"Miller\" };\n        var user2 = new User { FirstName = \"Max\", LastName = \"Lewandowski\" };\n        var user3 = new User { FirstName = \"Jeremy\", LastName = \"D\" };\n\n        session.Store(user1);\n        session.Store(user2);\n        session.Store(user3);\n\n        await session.SaveChangesAsync();\n    }\n\n    using (var session = store.OpenSession())\n    {\n        var batch = session.CreateBatchQuery();\n\n        // Issue a couple different queries within the batch\n        var jeremysTodos = batch.Query<User>(new FindByFirstName(\"Jeremy\"));\n\n        // This *starts* the execution of the batched query\n        await batch.Execute();\n\n        // All results are available immediately\n        var user = jeremysTodos.Result;\n\n        Debug.WriteLine(user.FirstName);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Querying with Select() for multiple properties in Marten (C#)\nDESCRIPTION: This snippet shows how to use the `Select()` operator to project multiple properties (FirstName and LastName) from the `User` document into a new `User2` type. It verifies the count and the non-null values of the projected properties. Requires `theSession` (an `IDocumentSession`) to be initialized, populated, and configured to use Newtonsoft serialization.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/projections.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n[SerializerTypeTargetedFact(RunFor = SerializerType.Newtonsoft)]\npublic async Task use_select_with_multiple_fields_to_other_type()\n{\n    theSession.Store(new User { FirstName = \"Hank\", LastName = \"Aaron\" });\n    theSession.Store(new User { FirstName = \"Bill\", LastName = \"Laimbeer\" });\n    theSession.Store(new User { FirstName = \"Sam\", LastName = \"Mitchell\" });\n    theSession.Store(new User { FirstName = \"Tom\", LastName = \"Chambers\" });\n\n    await theSession.SaveChangesAsync();\n\n    var users = theSession.Query<User>().Select(x => new User2 { First = x.FirstName, Last = x.LastName }).ToList();\n\n    users.Count.ShouldBe(4);\n\n    users.Each(x =>\n    {\n        x.First.ShouldNotBeNull();\n        x.Last.ShouldNotBeNull();\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Noda Time Default Setup with Marten\nDESCRIPTION: Configures Marten to use Noda Time by calling the `UseNodaTime()` extension method. This setup also configures the JsonNetSerializer or SystemTextJsonSerializer options for Noda Time serialization. Requires a connection string.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/noda-time.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n    _.Connection(ConnectionSource.ConnectionString);\n\n    // sets up NodaTime handling\n    _.UseNodaTime();\n});\n```\n\n----------------------------------------\n\nTITLE: Custom Event Slicer with MultiStreamProjection (C#)\nDESCRIPTION: This snippet shows how to implement a custom `IEventSlicer` for more complex event aggregation scenarios. It defines a `CustomSlicer` that implements `IEventSlicer<UserGroupsAssignment, Guid>` and splits and assigns events to aggregated document views.  The implementation defines logic to handle both inline and asynchronous event processing.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/multi-stream-projections.md#_snippet_8\n\nLANGUAGE: cs\nCODE:\n```\npublic class UserGroupsAssignmentProjection: MultiStreamProjection<UserGroupsAssignment, Guid>\n{\n    public class CustomSlicer: IEventSlicer<UserGroupsAssignment, Guid>\n    {\n        public ValueTask<IReadOnlyList<EventSlice<UserGroupsAssignment, Guid>>> SliceInlineActions(\n            IQuerySession querySession, IEnumerable<StreamAction> streams)\n        {\n            var allEvents = streams.SelectMany(x => x.Events).ToList();\n            var group = new TenantSliceGroup<UserGroupsAssignment, Guid>(Tenant.ForDatabase(querySession.Database));\n            group.AddEvents<UserRegistered>(@event => @event.UserId, allEvents);\n            group.AddEvents<MultipleUsersAssignedToGroup>(@event => @event.UserIds, allEvents);\n\n            return new(group.Slices.ToList());\n        }\n\n        public ValueTask<IReadOnlyList<TenantSliceGroup<UserGroupsAssignment, Guid>>> SliceAsyncEvents(\n            IQuerySession querySession, List<IEvent> events)\n        {\n            var group = new TenantSliceGroup<UserGroupsAssignment, Guid>(Tenant.ForDatabase(querySession.Database));\n            group.AddEvents<UserRegistered>(@event => @event.UserId, events);\n            group.AddEvents<MultipleUsersAssignedToGroup>(@event => @event.UserIds, events);\n\n            return new(new List<TenantSliceGroup<UserGroupsAssignment, Guid>>{group});\n        }\n    }\n\n    public UserGroupsAssignmentProjection()\n    {\n        CustomGrouping(new CustomSlicer());\n    }\n\n    public void Apply(UserRegistered @event, UserGroupsAssignment view)\n    {\n        view.Id = @event.UserId;\n    }\n\n    public void Apply(MultipleUsersAssignedToGroup @event, UserGroupsAssignment view)\n    {\n        view.Groups.Add(@event.GroupId);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Ejecting a Document from Marten Session\nDESCRIPTION: This code snippet demonstrates how to use `IDocumentSession.Eject<T>(T document)` to remove a document from a Marten session's identity map and unit of work tracking. This is useful when you need to completely remove a document from the session.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/advanced/eject.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:ejecting_a_document]>\n```\n\n----------------------------------------\n\nTITLE: Defining IProjection Interface in Marten (C#)\nDESCRIPTION: This code snippet defines the `IProjection` interface in Marten, which serves as the base interface for all event projections. It declares methods for applying projections during both synchronous and asynchronous operations, utilizing `IDocumentOperations` and `StreamAction`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/custom.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n/// <summary>\n///     Interface for all event projections\n///     IProjection implementations define the projection type and handle its projection document lifecycle\n///     Optimized for inline usage\n/// </summary>\npublic interface IProjection\n{\n    /// <summary>\n    ///     Apply inline projections during synchronous operations\n    /// </summary>\n    /// <param name=\"operations\"></param>\n    /// <param name=\"streams\"></param>\n    void Apply(IDocumentOperations operations, IReadOnlyList<StreamAction> streams);\n\n    /// <summary>\n    ///     Apply inline projections during asynchronous operations\n    /// </summary>\n    /// <param name=\"operations\"></param>\n    /// <param name=\"streams\"></param>\n    /// <param name=\"cancellation\"></param>\n    /// <returns></returns>\n    Task ApplyAsync(IDocumentOperations operations, IReadOnlyList<StreamAction> streams,\n        CancellationToken cancellation);\n}\n```\n\n----------------------------------------\n\nTITLE: Web-Style Text Search Query - Marten C#\nDESCRIPTION: Executes a web-style text search query using the `WebStyleSearch()` extension method on a Marten `IQueryable`. It searches the indexed text fields for the term 'somefilter' using websearch_to_tsquery. Requires the Marten library and Postgres 11 or higher.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/full-text.md#_snippet_14\n\nLANGUAGE: cs\nCODE:\n```\nvar posts = session.Query<BlogPost>()\n    .Where(x => x.WebStyleSearch(\"somefilter\"))\n    .ToList();\n```\n\n----------------------------------------\n\nTITLE: Querying with Negated Contains() in Child Collections (C#)\nDESCRIPTION: Demonstrates querying child collections to find documents where the child collection does *not* contain a specific value. Uses the negation operator `!` in conjunction with `Contains()` to exclude documents based on child collection contents.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/child-collections.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\ntheSession.Query<DocWithArrays>().Count(x => !x.Strings.Contains(\"c\"))\n    .ShouldBe(2);\n```\n\nLANGUAGE: csharp\nCODE:\n```\ntheSession.Query<DocWithArrays>().Count(x => !x.Strings.Contains(\"c\"))\n    .ShouldBe(2);\n```\n\n----------------------------------------\n\nTITLE: Applying Masking with Stream Filter (C#)\nDESCRIPTION: This snippet demonstrates how to apply event data masking to a single event stream, but only to specific events within that stream. It uses the `ApplyEventDataMasking` method with an event filter (`Func<IEvent, bool>`) to include only events of type `MembersJoined` or `MembersDeparted` in the masking operation. It also shows how to add or modify event metadata headers.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/protection.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic static Task apply_masking_to_streams_and_filter(IDocumentStore store, Guid streamId, CancellationToken token)\n{\n    return store\n        .Advanced\n        .ApplyEventDataMasking(x =>\n        {\n            // Mask selected events within a single stream by a user defined criteria\n            x.IncludeStream(streamId, e => e.EventTypesAre(typeof(MembersJoined), typeof(MembersDeparted)));\n\n            // You can add or modify event metadata headers as well\n            // BUT, you'll of course need event header tracking to be enabled\n            x.AddHeader(\"masked\", DateTimeOffset.UtcNow);\n        }, token);\n}\n```\n\n----------------------------------------\n\nTITLE: Transforming to Another Type with Javascript (C#)\nDESCRIPTION: This C# code shows how to use a Javascript transformation named \"get_fullname\" and deserialize the results to another .Net type within a Linq query. The `TransformTo<T>(transformName)` method applies the Javascript transformation and maps the result to the specified type, `FullName`. This assumes that the \"get_fullname\" transform produces JSON that can be deserialized into the `FullName` class.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/advanced/javascript_transformations.md#_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic class FullName\n{\n    public string Fullname { get; set; }\n}\n\n\nvar fullNames = session.Query<User>()\n    .Where(x => x.FirstName == \"Jeremy\")\n    .TransformTo<FullName>(\"get_fullname\")\n    .ToList();\n```\n\n----------------------------------------\n\nTITLE: Opening Document Sessions (C#)\nDESCRIPTION: This snippet demonstrates different ways to open an `IDocumentSession` from the `IDocumentStore`. The `IDocumentSession` provides the same query and loading functions as the read-only `IQuerySession` and is used for persisting data.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/index.md#_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:opening_sessions]>\n```\n\n----------------------------------------\n\nTITLE: Configure Document Types Upfront for Marten (C#)\nDESCRIPTION: Demonstrates configuring all document types and event store usage upfront, enabling Marten to accurately compare against the database schema for patching. This ensures all necessary schema changes are included in the generated SQL patch. Marten needs to 'know' how to make the full comparison.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/schema/migrations.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[sample:configure-document-types-upfront]\n```\n\n----------------------------------------\n\nTITLE: Configuring Global SequentialGuid in Marten\nDESCRIPTION: This code snippet demonstrates how to configure the document store to use the CombGuid generation strategy globally. This means that all document types will use this strategy for generating Guids, improving insert performance into the underlying document tables.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/identity/guid.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:configuring-global-sequentialguid]>\n```\n\n----------------------------------------\n\nTITLE: Defining Duplicated Field Unique Index with Store Options (Multiple Properties) - C#\nDESCRIPTION: This code snippet demonstrates how to define a unique index on multiple duplicated fields using the `StoreOptions` fluent interface. This ensures uniqueness across the combination of duplicated properties. Using duplicated fields can improve query performance.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/unique.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:using_a_multiple_properties_duplicate_field_unique_index_through_store_options]>\n```\n\n----------------------------------------\n\nTITLE: Deep Nested Properties Query using Linq in Marten (C#)\nDESCRIPTION: Illustrates how to perform deep searches on properties of properties (or fields) using Linq. The example queries based on a property nested several levels deep within the document structure. This requires a properly nested document structure\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/linq.md#_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic class Target\n{\n    public Guid Id { get; set; }\n    public string[] Tags { get; set; }\n    public Inner[] Children { get; set; }\n    public int? NullableNumber { get; set; }\n    public Outer Outer { get; set; }\n\n}\n\npublic class Inner\n{\n    public string Name { get; set; }\n    public int Age { get; set; }\n}\n\npublic class Outer\n{\n    public Middle Middle { get; set; }\n}\n\npublic class Middle\n{\n    public string Name { get; set; }\n}\n\n\nvar list = session.Query<Target>().Where(x => x.Outer.Middle.Name == \"something\").ToList();\n```\n\n----------------------------------------\n\nTITLE: Applying Masking to a Single Stream (C#)\nDESCRIPTION: This snippet demonstrates how to apply event data masking to a single event stream in Marten. It uses the `ApplyEventDataMasking` method on the `IDocumentStore.Advanced` interface to include the specified stream (`streamId`) in the masking operation. It also shows how to add or modify event metadata headers (requires event header tracking to be enabled).\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/protection.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic static Task apply_masking_to_streams(IDocumentStore store, Guid streamId, CancellationToken token)\n{\n    return store\n        .Advanced\n        .ApplyEventDataMasking(x =>\n        {\n            x.IncludeStream(streamId);\n\n            // You can add or modify event metadata headers as well\n            // BUT, you'll of course need event header tracking to be enabled\n            x.AddHeader(\"masked\", DateTimeOffset.UtcNow);\n        }, token);\n}\n```\n\n----------------------------------------\n\nTITLE: Appending Events to an Existing Stream (C#)\nDESCRIPTION: Demonstrates how to append events to an existing event stream in Marten. This involves using `IEventStore.Append()` to add new events to the stream. The events are appended within the same Marten transaction as any other document updates or deletions.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/events/appending.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nusing var store = DocumentStore.Empty();\n\nvar questId = Guid.NewGuid();\n\n// Starting a brand new stream with a user-supplied stream id\nvar joined = new MembersJoined { Members = new[] { \"Bilbo\", \"Frodo\" } };\nvar departed = new MembersDeparted { Members = new[] { \"Frodo\" } };\n\nusing var session = store.OpenSession();\n\n// Append events to existing stream\nsession.Events.Append(questId, joined, departed);\n\nsession.SaveChanges();\n```\n\n----------------------------------------\n\nTITLE: Resetting Specific Marten Database with IHost\nDESCRIPTION: Demonstrates resetting Marten data in a specific database using the IHost extension method ResetAllMartenDataAsync<TStore>().  This allows resetting data in a specific Marten database when working with multiple databases. Requires an IHost instance, the specific DocumentStore type, and configuration for initial data.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/schema/cleaning.md#_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .ConfigureServices(\n        services =>\n        {\n            services.AddMartenStore<IInvoicingStore>(\n                    opts =>\n                    {\n                        opts.Connection(ConnectionSource.ConnectionString);\n                        opts.Logger(new TestOutputMartenLogger(_output));\n                    }\n                )\n                .InitializeWith(new Users());\n        }\n    )\n    .StartAsync();\n\nawait host.ResetAllMartenDataAsync<IInvoicingStore>();\n```\n\n----------------------------------------\n\nTITLE: Using Batch Query with Marten (Async)\nDESCRIPTION: Demonstrates how to use Marten's `IBatchedQuery` to execute multiple queries in a single database round trip.  It shows how to create a batch query, load documents by ID, execute user-supplied SQL, use LINQ queries, and handle Any(), Count(), and First() selectors.  The `Execute()` method kicks off the batch query asynchronously and returns Task objects that can be awaited to retrieve results.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/batched-queries.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n// Start a new IBatchQuery from an active session\nvar batch = session.CreateBatchQuery();\n\n// Fetch a single document by its Id\nvar user1 = batch.Load<User>(\"username\");\n\n// Fetch multiple documents by their id's\nvar admins = batch.LoadMany<User>().ById(\"user2\", \"user3\");\n\n// User-supplied sql\nvar toms = batch.Query<User>(\"where first_name == ?\", \"Tom\");\n\n// Where with Linq\nvar jills = batch.Query<User>().Where(x => x.FirstName == \"Jill\").ToList();\n\n// Any() queries\nvar anyBills = batch.Query<User>().Any(x => x.FirstName == \"Bill\");\n\n// Count() queries\nvar countJims = batch.Query<User>().Count(x => x.FirstName == \"Jim\");\n\n// The Batch querying supports First/FirstOrDefault/Single/SingleOrDefault() selectors:\nvar firstInternal = batch.Query<User>().OrderBy(x => x.LastName).First(x => x.Internal);\n\n// Kick off the batch query\nawait batch.Execute();\n\n// All of the query mechanisms of the BatchQuery return\n// Task's that are completed by the Execute() method above\nvar internalUser = await firstInternal;\nDebug.WriteLine($\"The first internal user is {internalUser.FirstName} {internalUser.LastName}\");\n```\n\n----------------------------------------\n\nTITLE: Get Distinct Numbers (C#)\nDESCRIPTION: Do note that the `Distinct()` keyword can be used with `Select()` transforms as well:\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/linq.md#_snippet_25\n\nLANGUAGE: C#\nCODE:\n```\npublic class Target\n{\n    public Guid Id { get; set; }\n    public string[] Tags { get; set; }\n    public List<string> ListTags {get; set;}\n    public List<int> Numbers { get; set; }\n    public IList<Child> Children { get; set; }\n    public string String { get; set; }\n\n}\n\npublic class Child\n{\n    public string Name { get; set; }\n    public int Age { get; set; }\n}\n\nvar targets = session.Query<Target>().Select(x => x.Numbers.Count).Distinct().ToList();\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Marten Logger in C#\nDESCRIPTION: This snippet shows the implementation of a custom `IMartenSessionLogger` called `CorrelatedMartenLogger`. It takes an `ILogger<IDocumentSession>` and an `ISession` as dependencies. The logger is designed to add the correlation identifier from the `ISession` to log outputs related to Marten operations. The methods include logging success and failure for NpgsqlCommands, NpgsqlBatches, and saved changes.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/hostbuilder.md#_snippet_19\n\nLANGUAGE: cs\nCODE:\n```\npublic class CorrelatedMartenLogger: IMartenSessionLogger\n{\n    private readonly ILogger<IDocumentSession> _logger;\n    private readonly ISession _session;\n\n    public CorrelatedMartenLogger(ILogger<IDocumentSession> logger, ISession session)\n    {\n        _logger = logger;\n        _session = session;\n    }\n\n    public void LogSuccess(NpgsqlCommand command)\n    {\n        // Do some kind of logging using the correlation id of the ISession\n    }\n\n    public void LogFailure(NpgsqlCommand command, Exception ex)\n    {\n        // Do some kind of logging using the correlation id of the ISession\n    }\n\n    public void LogSuccess(NpgsqlBatch batch)\n    {\n        // Do some kind of logging using the correlation id of the ISession\n    }\n\n    public void LogFailure(NpgsqlBatch batch, Exception ex)\n    {\n        // Do some kind of logging using the correlation id of the ISession\n    }\n\n    public void RecordSavedChanges(IDocumentSession session, IChangeSet commit)\n    {\n        // Do some kind of logging using the correlation id of the ISession\n    }\n\n    public void OnBeforeExecute(NpgsqlCommand command)\n    {\n\n    }\n\n    public void LogFailure(Exception ex, string message)\n    {\n\n    }\n\n    public void OnBeforeExecute(NpgsqlBatch batch)\n    {\n\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Delete Document by Instance - Marten - C#\nDESCRIPTION: Deletes a document directly by passing the document object to the Delete method of the IDocumentSession. The passed document will be marked for deletion.  Requires an active IDocumentSession and the document to be deleted.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/deletes.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic Task DeleteByDocument(IDocumentSession session, User user)\n{\n    session.Delete(user);\n    return session.SaveChangesAsync();\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Live Stream Aggregation for Invoice (C#)\nDESCRIPTION: Configures Marten to use live aggregation for the `Invoice` aggregate. This registers the `Invoice` aggregate with Marten, enabling live stream projections.  It uses `Projections.LiveStreamAggregation<Projections.Invoice>()` to set up the live aggregation.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/read-aggregates.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\nbuilder.Services.AddMarten(opts =>\n{\n    opts.Connection(builder.Configuration.GetConnectionString(\"marten\"));\n\n    // Just telling Marten upfront that we will use\n    // live aggregation for the Invoice aggregate\n    // This would be the default anyway if you didn't explicitly\n    // register Invoice this way, but doing so let's\n    // Marten \"know\" about Invoice for code generation\n    opts.Projections.LiveStreamAggregation<Projections.Invoice>();\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Duplicated Field Unique Index with Attribute (Multiple Properties) - C#\nDESCRIPTION: This code snippet demonstrates how to define a unique index on multiple duplicated fields using the `[UniqueIndex]` attribute. This ensures uniqueness across the combination of duplicated properties. The `IndexName` parameter is used to group multiple properties into a single index.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/unique.md#_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:using_a_multiple_properties_duplicate_field_unique_index_through_attribute]>\n```\n\n----------------------------------------\n\nTITLE: Using DatabaseSchemaName Attribute - C#\nDESCRIPTION: This snippet demonstrates how to specify the database schema name for a document type using the `DatabaseSchemaName` attribute. This attribute allows you to configure the schema directly on the document class itself.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/storage.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n[DatabaseSchemaName(\"organization\")]\npublic class Customer\n{\n    [Identity] public string Name { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Full Text Index for Multiple Properties with Custom Settings (C#)\nDESCRIPTION: This code snippet demonstrates how to create a full-text index for multiple properties (`FirstName`, `LastName`) with custom settings such as index name and language configuration (`RegConfig`) in Marten using the fluent interface of `StoreOptions`. It indexes the specified properties with the provided custom settings.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/full-text.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n    _.Connection(ConnectionSource.ConnectionString);\n\n    // This creates\n    _.Schema.For<User>().FullTextIndex(\n        index =>\n        {\n            index.Name = \"mt_custom_italian_user_fts_idx\";\n            index.RegConfig = \"italian\";\n        },\n        d => d.FirstName, d => d.LastName);\n});\n```\n\n----------------------------------------\n\nTITLE: Querying with Modulo (C#)\nDESCRIPTION: Marten has the ability to use the modulo operator in Linq queries:\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/linq.md#_snippet_36\n\nLANGUAGE: C#\nCODE:\n```\nvar targets = session.Query<Target>().Where(x => x.Number % 2 == 0).ToList();\n```\n\n----------------------------------------\n\nTITLE: Querying with `In` Operator using String Array - Marten - C#\nDESCRIPTION: This code snippet demonstrates how to use the `In()` extension method in Marten to query for documents where an array property contains one of several provided values. It uses `session.Query<UserWithNicknames>()` to query the `UserWithNicknames` documents, checking if `Nicknames` contains \"Melinder\" or \"Norrland\".\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/child-collections.md#_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\n// Finds all UserWithNicknames's whose nicknames matches either \"Melinder\" or \"Norrland\"\n\nvar nickNames = new[] {\"Melinder\", \"Norrland\"};\n\nvar users = session.Query<UserWithNicknames>()\n    .Where(x => x.Nicknames.In(nickNames));\n```\n\n----------------------------------------\n\nTITLE: Conditional Schema Creation using IF NOT EXISTS\nDESCRIPTION: This code snippet demonstrates creating a new schema named 'inventory' only if it does not already exist. It uses an IF NOT EXISTS statement within a PL/pgSQL block to check for the schema's existence in the information_schema.schemata view before executing the CREATE SCHEMA statement. This prevents errors if the schema already exists.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/postgres/if_statements.md#_snippet_2\n\nLANGUAGE: PL/pgSQL\nCODE:\n```\nDO $$\nBEGIN\n    IF NOT EXISTS(\n        SELECT schema_name\n          FROM information_schema.schemata\n          WHERE schema_name = 'inventory'\n      )\n    THEN\n      EXECUTE 'CREATE SCHEMA inventory';\n    END IF;\nEND\n$$;\n```\n\n----------------------------------------\n\nTITLE: Bulk Insert & Querying Dynamic Records (Marten)\nDESCRIPTION: Demonstrates how to read and serialize records into the intermediate type (containing the dynamic property) and persist an array of its instances via Marten's `BulkInsert`.  It then shows how to read back the records using the non-generic `Query` extension method, passing in predicates that take into account the non-uniform fields of the source documents. The example calculates the average temperature for 'sensor-1' after querying.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/scenarios/dynamicdata.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:sample-scenarios-dynamic-insertandquery]>\n```\n\n----------------------------------------\n\nTITLE: Configuring Document Types Upfront - C#\nDESCRIPTION: This code snippet demonstrates how to configure Marten with the document types that will be persisted and the event types that will be used in the event store.  This upfront configuration helps Marten understand the required database schema and facilitates accurate schema comparisons and migrations.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/schema/migrations.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nusing var store = DocumentStore.For(_ =>\n{\n    // This is enough to tell Marten that the User\n    // document is persisted and needs schema objects\n    _.Schema.For<User>();\n\n    // Lets Marten know that the event store is active\n    _.Events.AddEventType(typeof(MembersJoined));\n});\n```\n\n----------------------------------------\n\nTITLE: Administering Multiple Databases in Marten (C#)\nDESCRIPTION: This code demonstrates how to administer multiple databases in Marten, including applying configuration changes to all or specific databases, finding or creating databases for tenants, completely removing all data from a database, fetching event store statistics, and applying pending database changes.  This utilizes the `IDocumentStore.Storage` interface to interact with individual databases.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/multitenancy.md#_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\n// Apply all detected changes in every known database\nawait store.Storage.ApplyAllConfiguredChangesToDatabaseAsync();\n\n// Only apply to the default database if not using multi-tenancy per\n// database\nawait store.Storage.Database.ApplyAllConfiguredChangesToDatabaseAsync();\n\n// Find a specific database\nvar database = await store.Storage.FindOrCreateDatabase(\"tenant1\");\n\n// Tear down everything\nawait database.CompletelyRemoveAllAsync();\n\n// Check out the projection state in just this database\nvar state = await database.FetchEventStoreStatistics();\n\n// Apply all outstanding database changes in just this database\nawait database.ApplyAllConfiguredChangesToDatabaseAsync();\n```\n\n----------------------------------------\n\nTITLE: Using Feature Management with IAsyncConfigureMarten (C#)\nDESCRIPTION: This example demonstrates how to use the `IFeatureManager` from Microsoft's Feature Management library to conditionally configure Marten. The `FeatureManagementUsingExtension` class implements `IAsyncConfigureMarten` and uses `IFeatureManager` to check if a feature is enabled before mapping an event type to Marten. It depends on the `IFeatureManager` service.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/hostbuilder.md#_snippet_13\n\nLANGUAGE: cs\nCODE:\n```\npublic class FeatureManagementUsingExtension: IAsyncConfigureMarten\n{\n    private readonly IFeatureManager _manager;\n\n    public FeatureManagementUsingExtension(IFeatureManager manager)\n    {\n        _manager = manager;\n    }\n\n    public async ValueTask Configure(StoreOptions options, CancellationToken cancellationToken)\n    {\n        if (await _manager.IsEnabledAsync(\"Module1\"))\n        {\n            options.Events.MapEventType<Module1Event>(\"module1:event\");\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Schema by Document Type - C#\nDESCRIPTION: This snippet demonstrates how to override the default database schema name for a specific document type using the MartenRegistry fluent interface.  It sets the DatabaseSchemaName for a specific document type, which takes precedence over the global setting.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/storage.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar store = DocumentStore.For(opts =>\n{\n    opts.Connection(\"some connection string\");\n    opts.DatabaseSchemaName = \"other\";\n\n    // This would take precedence for the\n    // User document type storage\n    opts.Schema.For<User>()\n        .DatabaseSchemaName(\"users\");\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Property by ID in Marten\nDESCRIPTION: This code snippet demonstrates how to update a specific property of a document by its ID using the `Patch` and `Set` methods. It first stores a `Target` document, then updates its `Number` property to 10 using the `Patch` API and verifies the change.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/partial-updates-patching.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic async Task set_an_immediate_property_by_id()\n{\n    var target = Target.Random(true);\n    target.Number = 5;\n\n    theSession.Store(target);\n    await theSession.SaveChangesAsync();\n\n    theSession.Patch<Target>(target.Id).Set(x => x.Number, 10);\n    await theSession.SaveChangesAsync();\n\n    using (var query = theStore.QuerySession())\n    {\n        query.Load<Target>(target.Id).Number.ShouldBe(10);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Live Aggregation with AggregateToAsync and Linq - C#\nDESCRIPTION: This snippet demonstrates the usage of the `AggregateToAsync` method as a Linq operator within Marten for live aggregation. It queries all raw events and aggregates them into a `QuestParty` object.  Additional Linq operators can be chained to filter and sort the events before aggregation.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/live-aggregates.md#_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nvar questParty = await theSession.Events\n    .QueryAllRawEvents()\n\n    // You could of course chain all the Linq\n    // Where()/OrderBy()/Take()/Skip() operators\n    // you need here\n\n    .AggregateToAsync<QuestParty>();\n```\n\n----------------------------------------\n\nTITLE: Event Namespace Migration Options\nDESCRIPTION: This snippet demonstrates how to register the new event type after a namespace migration in Marten. By using `Events.AddEventTypes`, Marten automatically performs matching based on the event type name, resolving the namespace difference.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/events/versioning/index.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nstoreOptions.Events.AddEventTypes(new[] { typeof(MyApp.NewNamespace.OrderStatusChanged) });\n```\n\n----------------------------------------\n\nTITLE: Querying with MatchesSql in Marten (C#)\nDESCRIPTION: This snippet demonstrates how to use the `MatchesSql` method to combine Linq queries with raw SQL in Marten. It queries the `User` document type based on a raw SQL condition applied to the `FirstName` property.  It stores a user, then queries for that user using raw SQL. Depends on Marten and NUnit.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/sql.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic async Task query_with_matches_sql()\n{\n    using var session = theStore.LightweightSession();\n    var u = new User { FirstName = \"Eric\", LastName = \"Smith\" };\n    session.Store(u);\n    await session.SaveChangesAsync();\n\n    var user = session.Query<User>().Where(x => x.MatchesSql(\"data->> 'FirstName' = ?\", \"Eric\")).Single();\n    user.LastName.ShouldBe(\"Smith\");\n    user.Id.ShouldBe(u.Id);\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Marten Services in Lamar\nDESCRIPTION: This code snippet demonstrates how to register Marten's `IDocumentStore`, `IDocumentSession`, and `IQuerySession` interfaces with Lamar's `ServiceRegistry`. It configures the `IDocumentStore` as a singleton and `IDocumentSession` and `IQuerySession` as scoped, ensuring proper object lifetime management.  The DocumentStore is configured with a connection string and auto schema creation options.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/ioc.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic class MartenServices : ServiceRegistry\n{\n    public MartenServices() \n    {\n        ForSingletonOf<IDocumentStore>().Use(c =>\n        {\n            return DocumentStore.For(options =>\n            {\n                options.Connection(\"your connection string\");\n                options.AutoCreateSchemaObjects = AutoCreate.None;\n\n                // other Marten configuration options\n            });\n        });\n\n        // Register IDocumentSession as Scoped\n        For<IDocumentSession()>\n            .Use(c => c.GetInstance<IDocumentStore>().LightweightSession())\n            .Scoped();\n\n        // Register IQuerySession as Scoped\n        For<IQuerySession()>\n            .Use(c => c.GetInstance<IDocumentStore>().QuerySession())\n            .Scoped();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Marten.CommandLine to Program.Main() - C#\nDESCRIPTION: This code snippet demonstrates how to add a reference to the Marten.CommandLine NuGet package and modify the Program.Main() entry point to use the expanded command line options within a .Net Core application bootstrapped by IHostBuilder. This setup allows the application to utilize the Marten command-line tools.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/cli.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:SampleConsoleApp]>\n```\n\n----------------------------------------\n\nTITLE: Defining Computed Unique Index with Attribute (Multiple Properties) - C#\nDESCRIPTION: This code snippet shows how to define a unique computed index on multiple properties using the `[UniqueIndex]` attribute. This enforces uniqueness across a combination of properties. The absence of the `IndexType` parameter defaults to a computed index.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/unique.md#_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:using_a_multiple_properties_computed_unique_index_through_store_attribute]>\n```\n\n----------------------------------------\n\nTITLE: Phrase Text Search Query - Marten C#\nDESCRIPTION: Executes a phrase search query using the `PhraseSearch()` extension method on a Marten `IQueryable`. It searches the indexed text fields for the phrase 'somefilter' using phraseto_tsquery. Requires the Marten library.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/full-text.md#_snippet_13\n\nLANGUAGE: cs\nCODE:\n```\nvar posts = session.Query<BlogPost>()\n    .Where(x => x.PhraseSearch(\"somefilter\"))\n    .ToList();\n```\n\n----------------------------------------\n\nTITLE: Configuring Identity Map for Inline Aggregates in C#\nDESCRIPTION: This code snippet demonstrates how to configure Marten to use the identity map for inline aggregates when using `FetchForWriting`. This optimization avoids an extra database fetch, improving performance when the same data is already fetched by `FetchForWriting` and is needed during `SaveChanges`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/scenarios/command_handler_workflow.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\nbuilder.Services.AddMarten(opts =>\n    {\n        opts.Connection(\"some connection string\");\n\n        // Force Marten to use the identity map for only the aggregate type\n        // that is the targeted \"T\" in FetchForWriting<T>() when using\n        // an Inline projection for the \"T\". Saves on Marten doing an extra\n        // database fetch of the same data you already fetched from FetchForWriting()\n        // when Marten needs to apply the Inline projection as part of SaveChanges()\n        opts.Events.UseIdentityMapForAggregates = true;\n    })\n    // This is non-trivial performance optimization if you never\n    // need identity map mechanics in your commands or query handlers\n    .UseLightweightSessions();\n```\n\n----------------------------------------\n\nTITLE: Using Optimistic Concurrency Attribute - C#\nDESCRIPTION: This C# code snippet demonstrates how to enable optimistic concurrency for a document type using the `UseOptimisticConcurrency` attribute.  This attribute is placed directly on the document class. When enabled, Marten will check for changes to the document since it was last loaded before allowing updates.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/advanced/optimistic_concurrency.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:UseOptimisticConcurrencyAttribute]>\n```\n\n----------------------------------------\n\nTITLE: Using Identity Key Strategy in Marten\nDESCRIPTION: This code demonstrates how to use the identity key strategy for string identity generation in Marten.  The identity key generates string values in the format '[type alias]/[sequence]'. The document alias can be overridden to customize the generated key. Requires a database connection string.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/identity.md#_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(opts =>\n{\n    opts.Connection(\"some connection string\");\n    opts.Schema.For<DocumentWithStringId>()\n        .UseIdentityKey()\n        .DocumentAlias(\"doc\");\n});\n```\n\n----------------------------------------\n\nTITLE: Multi-Property Calculated Index SQL Representation\nDESCRIPTION: This SQL code snippet represents the database index generated by Marten for a multi-property calculated index on `FirstName` and `LastName`. It creates a B-tree index using both properties.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/computed_index.md#_snippet_5\n\nLANGUAGE: SQL\nCODE:\n```\nCREATE INDEX mt_doc_user_idx_first_namelast_name ON public.mt_doc_user USING btree (((data ->> 'FirstName'::text)), ((data ->> 'LastName'::text)))\n```\n\n----------------------------------------\n\nTITLE: Overriding Id Property Fluent\nDESCRIPTION: This snippet shows how to override the Id property using the fluent configuration API within `StoreOptions`.  It allows specifying a different property to be used as the document's identity.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/identity.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nstoreOptions.Schema.For<OverriddenIdDoc>().Identity(x => x.Name);\n```\n\n----------------------------------------\n\nTITLE: Overriding Hilo with Marten Registry - C#\nDESCRIPTION: This code snippet demonstrates how to override the Hilo configuration for a document type using the `MartenRegistry` fluent interface. This approach offers an alternative to using the `[HiloSequence]` attribute for configuring Hilo settings.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/identity/sequential.md#_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:overriding-hilo-with-marten-registry]>\n```\n\n----------------------------------------\n\nTITLE: Compiled Query with Include for Multiple Documents (List)\nDESCRIPTION: This snippet demonstrates how to use compiled queries with the `Include()` method to fetch multiple related `User` documents into a `List<User>`. The `IssueWithUsers` class implements `ICompiledListQuery<Issue>` and fetches related users based on the `AssigneeId` property of each `Issue` document. The `Users` property is populated with the retrieved users.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/compiled-queries.md#_snippet_10\n\nLANGUAGE: cs\nCODE:\n```\npublic class IssueWithUsers: ICompiledListQuery<Issue>\n{\n    public List<User> Users { get; set; } = new List<User>();\n    // Can also work like that:\n    //public List<User> Users => new List<User>();\n\n    public Expression<Func<IMartenQueryable<Issue>, IEnumerable<Issue>>> QueryIs()\n    {\n        return query => query.Include(x => x.AssigneeId, Users);\n    }\n}\n\n[Fact]\npublic async Task compiled_include_to_list()\n{\n    var user1 = new User();\n    var user2 = new User();\n\n    var issue1 = new Issue { AssigneeId = user1.Id, Title = \"Garage Door is busted\" };\n    var issue2 = new Issue { AssigneeId = user2.Id, Title = \"Garage Door is busted\" };\n    var issue3 = new Issue { AssigneeId = user2.Id, Title = \"Garage Door is busted\" };\n\n    using var session = theStore.IdentitySession();\n    session.Store(user1, user2);\n    session.Store(issue1, issue2, issue3);\n    await session.SaveChangesAsync();\n\n    using var querySession = theStore.QuerySession();\n    var compiledQuery = new IssueWithUsers();\n\n    querySession.Logger = new TestOutputMartenLogger(_output);\n    var issues = querySession.Query(compiledQuery).ToArray();\n\n    compiledQuery.Users.Count.ShouldBe(2);\n    issues.Count().ShouldBe(3);\n\n    compiledQuery.Users.Any(x => x.Id == user1.Id);\n    compiledQuery.Users.Any(x => x.Id == user2.Id);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Sample Events\nDESCRIPTION: Defines sample event records related to a quest, such as `ArrivedAtLocation`, `MembersJoined`, `QuestStarted`, `QuestEnded`, `MembersDeparted`, and `MembersEscaped`. These records are used to represent state changes within the event store.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/quickstart.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed record ArrivedAtLocation(Guid QuestId, int Day, string Location);\n\npublic sealed record MembersJoined(Guid QuestId, int Day, string Location, string[] Members);\n\npublic sealed record QuestStarted(Guid QuestId, string Name);\n\npublic sealed record QuestEnded(Guid QuestId, string Name);\n\npublic sealed record MembersDeparted(Guid QuestId, int Day, string Location, string[] Members);\n\npublic sealed record MembersEscaped(Guid QuestId, string Location, string[] Members);\n```\n\n----------------------------------------\n\nTITLE: GitHub Actions Build and Test Job - YAML\nDESCRIPTION: This YAML snippet defines a GitHub Actions job that builds and tests a .NET application. It specifies the runner type, sets up a PostgreSQL service for testing, checks out the code, sets up the .NET environment, restores dependencies, builds the application, and runs tests. The PostgreSQL service configuration includes environment variables for the user and password, and defines options for health checks.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/devops/devops.md#_snippet_10\n\nLANGUAGE: YAML\nCODE:\n```\njobs:\n  build-test:\n    runs-on: ubuntu-latest\n    services:\n      postgres:\n        image: postgres:16\n        env:\n          POSTGRES_USER: user\n          POSTGRES_PASSWORD: password\n        options: --health-cmd pg_isready --health-interval 10s --health-timeout 5s --health-retries 5\n        ports:\n          - 5432:5432\n\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v4\n\n      - name: Setup .NET\n        uses: actions/setup-dotnet@v3\n        with:\n          dotnet-version: ${{ env.DOTNET_VERSION }}\n\n      - name: Dotnet restore\n        run: dotnet restore ${{ env.SOLUTION }}.sln -verbosity:quiet\n\n      - name: Build ${{ env.PROJECT }}\n        run: dotnet build ${{ env.SOLUTION }}.sln -c ${{ env.BUILD_CONFIGURATION }} --no-restore\n\n      - name: Test ${{ env.PROJECT }}\n        run: dotnet test ${{ env.SOLUTION }}.sln -c ${{ env.BUILD_CONFIGURATION }} --no-restore --no-build --results-directory reports --logger \"trx;\" --nologo\n```\n\n----------------------------------------\n\nTITLE: Define Duplicated Field Unique Index (Single Property) via Store Options in Marten C#\nDESCRIPTION: This snippet demonstrates defining a unique index as a duplicated field for a single property using Marten's `StoreOptions`. It configures a unique index on the `UserName` property of the `User` document, utilizing a duplicated field. The store is set up with a database connection and schema.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/indexing/unique.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n    _.Connection(ConnectionSource.ConnectionString);\n    _.DatabaseSchemaName = \"unique_text\";\n\n    // This creates\n    _.Schema.For<User>().UniqueIndex(UniqueIndexType.DuplicatedField, x => x.UserName);\n});\n```\n\n----------------------------------------\n\nTITLE: Automatic Dirty Tracking with IDocumentSession (C#)\nDESCRIPTION: This code demonstrates how to use an `IDocumentSession` with dirty checking enabled. The session automatically detects changes to loaded documents by comparing their JSON representations before and after changes.  This approach simplifies change tracking but introduces performance overhead.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/basics/persisting.md#_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nusing Marten;\nusing System.Threading.Tasks;\n\npublic class TrackingDocumentSessionUow\n{\n    public async Task Tracking_document_session_uow(IDocumentStore store)\n    {\n        using (var session = store.OpenSession(SessionOptions.ForDirtyChecking()))\n        {\n            var target = new Target { Name = \"Initial Name\" };\n            session.Store(target);\n            await session.SaveChangesAsync();\n\n            // Later...\n\n            var loaded = await session.LoadAsync<Target>(target.Id);\n\n            loaded.Name = \"Updated Name\";\n\n            // No need to call Update() because the session\n            // will automatically detect the change\n\n            await session.SaveChangesAsync();\n        }\n    }\n\n    public class Target\n    {\n        public int Id { get; set; }\n        public string Name { get; set; }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Migration Execution Script - Batch\nDESCRIPTION: This Batch script is used to run the application with specific arguments related to migrations. The arguments will be forwarded as-is using the %* syntax.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/devops/devops.md#_snippet_5\n\nLANGUAGE: Batch\nCODE:\n```\ndotnet run --project src/Application %*\n```\n\n----------------------------------------\n\nTITLE: Register Custom ISerializer with DocumentStore\nDESCRIPTION: This snippet demonstrates how to register a custom `ISerializer` implementation with the `DocumentStore` during bootstrapping. The `Serializer<T>()` method is used to replace the default serializer with a custom one.  In this specific example, it replaces the default `ISerializer` with `TestsSerializer`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/json.md#_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n    _.Connection(\"the connection string\");\n\n    // Replace the ISerializer w/ the TestsSerializer\n    _.Serializer<TestsSerializer>();\n});\n```\n\n----------------------------------------\n\nTITLE: Registering Async Upcaster Class in Marten\nDESCRIPTION: This code snippet demonstrates how to register an asynchronous upcaster class in Marten. The `Upcast` method is called on the `Events` configuration to register a new `ShoppingCartOpenedAsyncOnlyUpcaster` instance with a `clientRepository` dependency. This enables Marten to automatically upcast older event versions to the latest version during event sourcing.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/versioning.md#_snippet_38\n\nLANGUAGE: cs\nCODE:\n```\noptions.Events.Upcast(new ShoppingCartOpenedAsyncOnlyUpcaster(clientRepository));\n```\n\n----------------------------------------\n\nTITLE: Use all your own SQL\nDESCRIPTION: Shows how to provide the complete SQL statement for querying documents, including the SELECT, FROM, and WHERE clauses.  This approach gives you full control over the SQL execution.  The user needs to know the default table name, which follows the convention of 'mt_doc_[name of the class]'.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/sql.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvar users = session.Query<User>(\"select data from mt_doc_User where data ->> 'FirstName' = 'Jeremy'\").ToList();\n```\n\n----------------------------------------\n\nTITLE: Compiled Query with Dictionary Include C#\nDESCRIPTION: This code shows how to use a compiled query with an `Include` that returns a dictionary of related documents. It queries `Issue` documents and populates a dictionary of `User` documents, keyed by the `AssigneeId`. The dictionary is populated via the `Include` extension method within the `QueryIs` method.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/compiled_queries.md#_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\npublic class IssuesByTitleWithAssigneesDictionary : ICompiledListQuery<Issue, IssuesByTitleWithAssigneesDictionary>\n{\n    public string TitleSearch { get; set; }\n\n    public Dictionary<Guid, User> Included { get; set; } = new Dictionary<Guid, User>();\n\n    public Expression<Func<IQueryable<Issue>, IEnumerable<IssuesByTitleWithAssigneesDictionary>>> QueryIs()\n    {\n        return query => query\n            .Include(x => x.AssigneeId, x => Included)\n            .Where(x => x.Title.Contains(TitleSearch))\n            .AsEnumerable();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Javascript Transform in Linq Queries (C#)\nDESCRIPTION: This C# code demonstrates how to use a Javascript transformation named \"get_fullname\" within a Linq query against a Marten `IDocumentSession`. The `TransformToJson()` method applies the Javascript transformation to the matching documents, returning the transformed JSON data.  The session is assumed to have been initialized with a Marten document store that has the JS transform function loaded.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/advanced/javascript_transformations.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvar json = session.Query<User>()\n    .Where(x => x.FirstName == \"Jeremy\")\n    .TransformToJson(\"get_fullname\")\n    .ToList();\n```\n\n----------------------------------------\n\nTITLE: Query with MatchesSql(sql) (C#)\nDESCRIPTION: Combine your Linq queries with raw SQL using the `MatchesSql(sql)` method like so:\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/linq.md#_snippet_27\n\nLANGUAGE: C#\nCODE:\n```\nvar targets = session.Query<Target>().Where(x => x.String.StartsWith(\"foo\") && MatchesSql(\"data #>> '{Inner, Name}' = ?\", \"Jeremy\")).ToList();\n```\n\n----------------------------------------\n\nTITLE: Querying with IsOneOf() for Arrays in Marten (C#)\nDESCRIPTION: Demonstrates using the `IsOneOf()` extension to query for documents where array property matches one of the supplied values from a string array. This example queries for UserWithNicknames documents whose nicknames match either \"Melinder\" or \"Norrland\".\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/child-collections.md#_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\n// Finds all UserWithNicknames's whose nicknames matches either \"Melinder\" or \"Norrland\"\n\nvar nickNames = new[] {\"Melinder\", \"Norrland\"};\n\nvar users = session.Query<UserWithNicknames>()\n    .Where(x => x.Nicknames.IsOneOf(nickNames));\n```\n\n----------------------------------------\n\nTITLE: Initializing DocumentStore with StoreOptions - C#\nDESCRIPTION: This snippet demonstrates how to initialize a DocumentStore by creating a StoreOptions object and configuring it with a provided action. It showcases the use of the DocumentStore.For method, which serves as syntactic sugar for building a StoreOptions object.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/storeoptions.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic static DocumentStore For(Action<StoreOptions> configure)\n{\n    var options = new StoreOptions();\n    configure(options);\n\n    return new DocumentStore(options);\n}\n```\n\n----------------------------------------\n\nTITLE: Archiving a Stream with Marten in C#\nDESCRIPTION: This snippet demonstrates how to archive an event stream using Marten's `IDocumentSession`. It archives a stream based on its stream ID and then saves the changes to the database. Requires an active `IDocumentSession` and the stream ID to be archived. After this operation, the stream and its events will be marked as archived in the database.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/archiving.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic async Task SampleArchive(IDocumentSession session, string streamId)\n{\n    session.Events.ArchiveStream(streamId);\n    await session.SaveChangesAsync();\n}\n```\n\n----------------------------------------\n\nTITLE: Plugging in Session Logger (C#)\nDESCRIPTION: This snippet demonstrates how to directly apply a session logger to any `IQuerySession` or `IDocumentSession`. This allows for session-specific logging that is independent of the default logger configured on the `DocumentStore`. This provides granular control over logging for specific sessions.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/diagnostics.md#_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nusing var session = store.OpenSession();\nsession.Logger = new MyDocumentSessionLogger();\n```\n\n----------------------------------------\n\nTITLE: Create Full Text Index for Single Property via StoreOptions (C#)\nDESCRIPTION: This code snippet demonstrates how to create a full text index for a single property using the StoreOptions fluent interface in Marten. It indexes the 'FirstName' property of the 'MyDocument' document. The index will be created with the default 'english' language configuration if no language is specified. Requires Marten and PostgreSQL version 10.0 or above.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/full_text.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nusing var store = DocumentStore.For(_ =>\n{\n    _.Connection(\"your_postgres_connection_string\");\n    _.Schema.For<MyDocument>().Searchable(x => x.FirstName);\n});\n```\n\n----------------------------------------\n\nTITLE: Using Identity Map Session\nDESCRIPTION: This snippet demonstrates the use of the Identity Map pattern within a Marten session. It inserts a User document, opens a session with Identity Map enabled, and then loads the same document twice by ID, asserting that the two instances are the same object.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/sessions.md#_snippet_3\n\nLANGUAGE: cs\nCODE:\n```\nvar user = new User { FirstName = \"Tamba\", LastName = \"Hali\" };\ntheStore.BulkInsert(new[] { user });\n\n// Open a document session with the identity map\nusing var session = theStore.IdentitySession();\nsession.Load<User>(user.Id)\n    .ShouldBeSameAs(session.Load<User>(user.Id));\n```\n\n----------------------------------------\n\nTITLE: Implementing IChangeListener for Async Daemon Events\nDESCRIPTION: This C# snippet demonstrates how to implement the `IChangeListener` interface to create a listener that is invoked during asynchronous daemon updates in Marten. The `BeforeCommitAsync` and `AfterCommitAsync` methods are implemented to perform actions before and after a commit, respectively.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/diagnostics.md#_snippet_5\n\nLANGUAGE: cs\nCODE:\n```\npublic class FakeListener: IChangeListener\n{\n    public List<IChangeSet> Befores = new();\n    public IList<IChangeSet> Changes = new List<IChangeSet>();\n\n    public Task AfterCommitAsync(IDocumentSession session, IChangeSet commit, CancellationToken token)\n    {\n        session.ShouldNotBeNull();\n        Changes.Add(commit);\n        return Task.CompletedTask;\n    }\n\n    public Task BeforeCommitAsync(IDocumentSession session, IChangeSet commit, CancellationToken token)\n    {\n        session.ShouldNotBeNull();\n        Befores.Add(commit);\n\n        Changes.Count.ShouldBeLessThan(Befores.Count);\n\n        return Task.CompletedTask;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Marten with Static TypeLoadMode (C#)\nDESCRIPTION: This snippet demonstrates configuring Marten with `OptimizeArtifactWorkflow` and specifying `TypeLoadMode.Static`.  This setting tells Marten to strictly use pre-built types and to *not* generate any dynamic code at runtime.  It assumes that all required types have been pre-compiled.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/optimized_artifact_workflow.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .ConfigureServices(services =>\n    {\n        services.AddMarten(\"connection string\")\n\n            // This feature opts into the new\n            // \"Optimized artifact workflow\" for Marten >= V5\n            .OptimizeArtifactWorkflow(TypeLoadMode.Static);\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Filter Included Documents with Marten in C#\nDESCRIPTION: This code snippet demonstrates how to filter the included documents when querying with Marten. It fetches `TargetHolder` documents and includes related `Target` documents, filtering the `Target` documents based on their `Color` property. The `Include()` method takes an additional filter argument (a lambda expression) that acts as a `Where()` clause on the included documents.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/include.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic async Task filter_included_documents_to_lambda()\n{\n    var list = new List<Target>();\n\n    var holders = await theSession.Query<TargetHolder>()\n        .Include(list).On(x => x.TargetId, t => t.Color == Colors.Blue)\n        .ToListAsync();\n\n    list.Select(x => x.Color).Distinct()\n        .Single().ShouldBe(Colors.Blue);\n\n    list.Count.ShouldBe(Data.Count(x => x.Color == Colors.Blue));\n}\n```\n\n----------------------------------------\n\nTITLE: Integration Test Example with Alba and Marten\nDESCRIPTION: An example xUnit integration test that uses the `IntegrationContext` and `AppFixture`. It stores a document in the database, then uses Alba to make an HTTP request to retrieve the document. It verifies the response status code, content type, and the content of the retrieved document. It depends on `IAlbaHost`, `IDocumentStore`, `Issue`, and `AppFixture`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/testing/integration.md#_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\n[Collection(\"integration\")]\npublic class web_service_streaming_example: IntegrationContext\n{\n    private readonly IAlbaHost theHost;\n\n    public web_service_streaming_example(AppFixture fixture) : base(fixture)\n    {\n        theHost = fixture.Host;\n    }\n\n    [Fact]\n    public async Task stream_a_single_document_hit()\n    {\n        var issue = new Issue {Description = \"It's bad\"};\n\n        await using (var session = Store.LightweightSession())\n        {\n            session.Store(issue);\n            await session.SaveChangesAsync();\n        }\n\n        var result = await theHost.Scenario(s =>\n        {\n            s.Get.Url($\"/issue/{issue.Id}\");\n\n            s.StatusCodeShouldBe(200);\n            s.ContentTypeShouldBe(\"application/json\");\n        });\n\n        var read = result.ReadAsJson<Issue>();\n\n        read.Description.ShouldBe(issue.Description);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Foreign Key with Attribute\nDESCRIPTION: This C# code defines an `Issue` document with a `UserId` property that is marked with the `[ForeignKey]` attribute, specifying that it's a foreign key to the `User` document.  This is an alternative way to configure foreign key relationships. The `Issue` class also contains `Id` property and `OtherUserId` property, which is nullable.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/indexing/foreign-keys.md#_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic class Issue\n{\n    public Issue()\n    {\n        Id = Guid.NewGuid();\n    }\n\n    public Guid Id { get; set; }\n\n    [ForeignKey(typeof(User))]\n    public Guid UserId { get; set; }\n\n    public Guid? OtherUserId { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Configure Marten to create Databases\nDESCRIPTION: This demonstrates how Marten can be configured to create databases (or drop & create) if they do not exist. This is enabled using `StoreOptions.CreateDatabasesForTenants`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/getting_started.md#_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\n// Options +=> GettingStarted/marten_create_database.cs\nusing System;\nusing Marten;\n\npublic class marten_create_database\n{\n    public void configure_database_creation(StoreOptions options)\n    {\n        options.CreateDatabasesForTenants(c =>\n        {\n            // Only do this in development or test!\n            c.MaintenanceDatabaseName = \"postgres\";\n            c.SuperuserConnectionString = \"Host=localhost;Port=5400;Username=postgres;Password=ADMIN\";\n\n            // This is for creating the database if it doesn't exist\n            c.CreateIfDoesNotExist = true;\n\n            // This is the actual connection string for the tenant's database\n            c.ConnectionString(ConnectionString);\n        });\n    }\n\n    public string ConnectionString { get; set; } = \"Host=localhost;Port=5400;Database=SomeDatabase;Username=someuser;Password=somepassword\";\n}\n```\n\n----------------------------------------\n\nTITLE: Writing a Custom Document Session Listener in Marten (C#)\nDESCRIPTION: This snippet illustrates how to create a custom `IDocumentSessionListener` to query pending changes before a transactional commit and also query what was done after a commit is made.  The listener implements the `BeforeSaveChanges` and `AfterCommit` methods to access the pending changes and committed documents, respectively. This allows for custom logic to be executed based on the session events.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/diagnostics.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic class SampleSessionListener : IDocumentSessionListener\n{\n    public void BeforeSaveChanges(IDocumentSession session)\n    {\n        // Look at all the pending changes\n        var pending = session.PendingChanges;\n\n        // Examine all the document deletes\n        var deletes = pending.DeletesFor<Target>();\n\n        // Examine all the document updates\n        var updates = pending.UpdatesFor<Target>();\n\n        // Examine all the document inserts\n        var inserts = pending.InsertsFor<Target>();\n    }\n\n    public void AfterCommit(IDocumentSession session)\n    {\n        // See what the actual database changes were\n        var changes = session.ChangeTracker.ToSnapshot();\n\n        // see what documents were updated\n        var updated = changes.Updated;        \n    }\n\n    public void AfterRollback(IDocumentSession session, Exception ex)\n    {\n        // Nothing\n    }\n\n    public void DocumentInserted<T>(IDocumentSession session, T document)\n    {\n        // Nothing\n    }\n\n    public void DocumentUpdated<T>(IDocumentSession session, T document)\n    {\n        // Nothing\n    }\n\n    public void DocumentDeleted<T>(IDocumentSession session, T document)\n    {\n        // Nothing\n    }\n\n    public void DocumentSoftDeleted<T>(IDocumentSession session, T document)\n    {\n        // Nothing\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Querying for Whole Document by WHERE Clause in Marten (C#)\nDESCRIPTION: This code snippet demonstrates querying for `User` documents in Marten using a raw SQL `WHERE` clause. It uses the `Query<User>()` method on an `IQuerySession` object to retrieve documents based on a condition applied to the `LastName` property within the JSON data. The code assumes that the `session` variable is of type `IQuerySession`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/sql.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvar millers = session\n    .Query<User>(\"where data ->> 'LastName' = 'Miller'\");\n```\n\n----------------------------------------\n\nTITLE: Docker Compose Configuration for PostgreSQL\nDESCRIPTION: Sets up a PostgreSQL database within a Docker container for integration testing. The configuration defines the image, ports, and environment variables for the database, including the database name, user, and password.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/testing/integration.md#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nversion: '3'\nservices:\n  postgresql:\n    image: \"postgres:latest\"\n    ports:\n     - \"5433:5432\"\n    environment:\n      - POSTGRES_DATABASE=postgres\n      - POSTGRES_USER=postgres\n      - POSTGRES_PASSWORD=postgres\n```\n\n----------------------------------------\n\nTITLE: Using NpgsqlDataSource with Marten\nDESCRIPTION: This snippet shows how to use `NpgsqlDataSource` to configure Marten connection settings. It adds the Npgsql data source and then configures Marten to use it. This example shows lightweight sessions.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/hostbuilder.md#_snippet_4\n\nLANGUAGE: cs\nCODE:\n```\nservices.AddNpgsqlDataSource(ConnectionSource.ConnectionString);\n\nservices.AddMarten()\n    .UseLightweightSessions()\n    .UseNpgsqlDataSource();\n```\n\n----------------------------------------\n\nTITLE: Soft Delete Fluent Interface Configuration - C#\nDESCRIPTION: This snippet demonstrates how to configure a document type for soft deletes using the fluent interface of `StoreOptions`. This approach allows configuration of soft deletes directly through the store options, offering an alternative to the attribute-based approach.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/advanced/soft_deletes.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nstoreOptions.Schema.For<User>().SoftDeleted();\nstoreOptions.Schema.For<Company>().DeleteStyle(DeleteStyle.SoftDelete);\n```\n\n----------------------------------------\n\nTITLE: Mermaid Class Diagram - Projection Class Diagram\nDESCRIPTION: This Mermaid diagram visually represents the class relationships within the Marten V4 event store architecture, specifically focusing on the projection mechanisms. It shows the interactions between interfaces like `IProjectionAgent`, `IInlineProjection`, `IAsyncProjection` and concrete classes such as `AggregateProjection`, `EventProjection`, `ViewProjection` and `InlineProjectionAsyncRunner`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/diagrams/v4eventstore.md#_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\nclassDiagram\n\nclass IProjectionAgent {\n    <<interface>> IProjectionAgent\n    ProjectionName\n    ShardName\n    Start() Task\n    Stop() Task\n}\n\nclass InlineProjectionAsyncRunner\n\nInlineProjectionAsyncRunner ..|> IProjectionAgent\nInlineProjectionAsyncRunner --> IInlineProjection : Adapts\n\n\n\nclass AggregateProjection\n\nclass IAsyncProjection {\n    <<interface>>\n    Name\n\n}\n\nIAsyncProjection ..> IProjectionAgent: 1..*\n\nAggregateProjection ..|> IAsyncProjection\nAggregateProjection --> IInlineProjection : Builds\n\n\n\nclass AggregateProjectionAgent {\n    <<abstract>>\n}\n\nAggregateProjection --> AggregateProjectionAgent: Builds\nAggregateProjectionAgent ..|> IProjectionAgent\n\nclass AggregatePage {\n    StartLoadingEvents(floor, ceiling, events)\n}\n\nAggregateProjectAgent --> AggregatePage : Uses\n\n\nclass ILiveAggregator {\n    <<interface>>\n}\n\nAggregateProjection --> ILiveAggregator : Builds\n\nclass EventProjection {\n    <<abstract>>\n}\n\nEventProjection --> IInlineProjection: Builds\n\nclass ViewProjection {\n    <<abstract>>\n}\n\nViewProjection --> IInlineProjection : Builds\n\nclass IInlineProjection {\n    <<interface>> IInlineProjection\n}\n\n\n\n```\n\n----------------------------------------\n\nTITLE: Using Javascript Transform in Compiled Query (C#)\nDESCRIPTION: This C# code showcases how to use `TransformToJson()` inside of a compiled query. This demonstrates the usage of a Javascript transform within a pre-compiled and optimized query in Marten.  The `TransformToJson()` method applies the specified JavaScript transformation to the selected documents within the compiled query, returning the transformed JSON results.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/advanced/javascript_transformations.md#_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\npublic class GetUserNames: ICompiledQuery<User, string>\n{\n    public string Execute(IQueryable<User> query)\n    {\n        return query.Where(x => x.FirstName == \"Jeremy\").TransformToJson(\"get_fullname\").FirstOrDefault();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Database Schema Name - C#\nDESCRIPTION: This snippet shows how to globally override the default database schema name for all document type tables within a Marten DocumentStore. It sets the DatabaseSchemaName property within the DocumentStore configuration.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/storage.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar store = DocumentStore.For(opts =>\n{\n    opts.Connection(\"some connection string\");\n    opts.DatabaseSchemaName = \"other\";\n});\n```\n\n----------------------------------------\n\nTITLE: Querying for Documents with Metadata in Marten using AdvancedSql\nDESCRIPTION: This snippet demonstrates querying for documents of type `DocWithMeta` including metadata using `session.AdvancedSql.QueryAsync<T>()`. It retrieves the 'id', 'data', and 'mt_version' columns from the document's table, ensuring the correct order for Marten to map the result correctly.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/advanced-sql.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nvar schema = session.DocumentStore.Options.Schema;\nvar doc = (await session.AdvancedSql.QueryAsync<DocWithMeta>(\n    $\"select id, data, mt_version from {schema.For<DocWithMeta>()} where data ->> 'Name' = 'Max'\",\n    CancellationToken.None)).First();\n```\n\n----------------------------------------\n\nTITLE: Create Full Text Index for Multiple Properties via StoreOptions (C#)\nDESCRIPTION: This code snippet demonstrates how to create a full text index for multiple properties using the StoreOptions fluent interface in Marten. It indexes both 'FirstName' and 'LastName' properties of the 'MyDocument' document. The index will be created with the default 'english' language configuration if no language is specified. Requires Marten and PostgreSQL version 10.0 or above.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/full_text.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nusing var store = DocumentStore.For(_ =>\n{\n    _.Connection(\"your_postgres_connection_string\");\n    _.Schema.For<MyDocument>().Searchable(x => x.FirstName, x => x.LastName);\n});\n```\n\n----------------------------------------\n\nTITLE: Console Marten Logger Implementation (C#)\nDESCRIPTION: This snippet shows a sample implementation of the `IMartenLogger` interface that writes log messages to the console. It defines inner classes for `ConsoleQuerySessionLogger` and `ConsoleDocumentSessionLogger` to handle query and document session logging, respectively. The `LogCommand` method writes the SQL command text to the console.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/diagnostics.md#_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nusing Microsoft.Extensions.Logging;\n\npublic class ConsoleMartenLogger : IMartenLogger\n{\n    private readonly ILogger<ConsoleMartenLogger> _logger;\n\n    public ConsoleMartenLogger(ILogger<ConsoleMartenLogger> logger)\n    {\n        _logger = logger;\n    }\n\n    public IQuerySessionLogger StartSession(IQuerySession session)\n    {\n        return new ConsoleQuerySessionLogger(_logger);\n    }\n\n    public IDocumentSessionLogger StartSession(IDocumentSession session)\n    {\n        return new ConsoleDocumentSessionLogger(_logger);\n    }\n\n    internal class ConsoleQuerySessionLogger : IQuerySessionLogger\n    {\n        private readonly ILogger _logger;\n\n        public ConsoleQuerySessionLogger(ILogger logger)\n        {\n            _logger = logger;\n        }\n\n        public void LogCommand(NpgsqlCommand command)\n        {\n            _logger.LogInformation(command.CommandText);\n        }\n\n        public void LogSuccess(NpgsqlCommand command, IReadOnlyList<object> ids)\n        {\n            // Nothing\n        }\n\n        public void LogFailure(NpgsqlCommand command, Exception ex)\n        {\n            // Nothing\n        }\n    }\n\n    internal class ConsoleDocumentSessionLogger : IDocumentSessionLogger\n    {\n        private readonly ILogger _logger;\n\n        public ConsoleDocumentSessionLogger(ILogger logger)\n        {\n            _logger = logger;\n        }\n\n        public void LogCommand(NpgsqlCommand command)\n        {\n            _logger.LogInformation(command.CommandText);\n        }\n\n        public void LogSuccess(NpgsqlCommand command, int identity)\n        {\n            // Nothing\n        }\n\n        public void LogFailure(NpgsqlCommand command, Exception ex)\n        {\n            // Nothing\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Inserting Documents Only with Insert() in Marten\nDESCRIPTION: This snippet demonstrates how to use `IDocumentSession.Insert()` to insert a new document only if it doesn't already exist. If a document with the same ID already exists, a `DocumentAlreadyExistsException` will be thrown. It requires a configured `DocumentStore` and a `target` object to be inserted.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/storing.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nusing (var session = theStore.LightweightSession())\n{\n    session.Insert(target);\n    await session.SaveChangesAsync();\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Invoice Events for Event Sourcing in C#\nDESCRIPTION: This code defines a set of events related to an Invoice, including InvoiceInitiated, InvoiceIssued, and InvoiceSent, along with a Person record. These events will be used to represent changes to an Invoice entity over time. The InvoiceSendMethod enum specifies the method used to send an invoice. Each record represents a specific event in the invoice lifecycle.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/live-aggregates.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic record InvoiceInitiated(\n    Guid InvoiceId,\n    double Amount,\n    string Number,\n    Person IssuedTo,\n    DateTime InitiatedAt\n);\n\npublic record Person(\n    string Name,\n    string Address\n);\n\npublic record InvoiceIssued(\n    Guid InvoiceId,\n    string IssuedBy,\n    DateTime IssuedAt\n);\n\npublic enum InvoiceSendMethod\n{\n    Email,\n    Post\n}\n\npublic record InvoiceSent(\n    Guid InvoiceId,\n    InvoiceSendMethod SentVia,\n    DateTime SentAt\n);\n```\n\n----------------------------------------\n\nTITLE: Implementing Compiled List Query with Select Transform\nDESCRIPTION: This class implements `ICompiledListQuery<User, string>` to retrieve a list of user names based on the `FirstName` property. The `QueryIs()` method defines the LINQ expression to filter users by their first name and then select their `UserName` property.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/compiled-queries.md#_snippet_8\n\nLANGUAGE: cs\nCODE:\n```\npublic class UserNamesForFirstName: ICompiledListQuery<User, string>\n{\n    public Expression<Func<IMartenQueryable<User>, IEnumerable<string>>> QueryIs()\n    {\n        return q => q\n            .Where(x => x.FirstName == FirstName)\n            .Select(x => x.UserName);\n    }\n\n    public string FirstName { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Any Tenant (C#)\nDESCRIPTION: Query data from all tenants using `AnyTenant` method.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/linq.md#_snippet_37\n\nLANGUAGE: C#\nCODE:\n```\nvar targets = session.Query<Target>().AnyTenant().ToList();\n```\n\n----------------------------------------\n\nTITLE: Text Search Combined with Other Query Sample (C#)\nDESCRIPTION: \nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/linq.md#_snippet_43\n\nLANGUAGE: C#\nCODE:\n```\nvar targets = session.Query<Target>().Where(x => x.String.Search(\"token\") && x.Number > 5).ToList();\n```\n\n----------------------------------------\n\nTITLE: Implementing Event Aggregation with Apply Methods in C#\nDESCRIPTION: This code shows how to define an aggregate class (`QuestParty`) with `Apply` methods for specific event types. These methods are used to incrementally update the aggregate object based on the events in the stream.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/events/projections/index.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\n// SAMPLE: QuestParty\npublic class QuestParty\n{\n    public Guid Id { get; set; }\n\n    public string Name { get; set; }\n\n    public DateTime Started { get; set; }\n\n    public string[] Members { get; set; }\n\n    public void Apply(QuestStarted started)\n    {\n        Id = started.QuestId;\n        Name = started.Name;\n        Started = started.Started;\n    }\n\n    public void Apply(MembersJoined joined)\n    {\n        Members = joined.Members;\n    }\n}\n\npublic record QuestStarted(Guid QuestId, string Name, DateTime Started);\n\npublic record MembersJoined(string[] Members);\n// ENDSAMPLE\n```\n\n----------------------------------------\n\nTITLE: Customizing Upsert Rights in Marten (C#)\nDESCRIPTION: This code snippet shows how to configure the upsert function permissions in Marten using the `UpsertRights` property. It allows you to choose between `SecurityRights.Definer`, which executes the function under the privileges of the function creator, and `SecurityRights.Invoker` (the default), which executes the function under the privileges of the current user. This configuration affects the security context in which Marten's upsert functions are executed.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/schema/authorization.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n    // Opt into SECURITY DEFINER permissions\n    _.Advanced.Migrator.UpsertRights = SecurityRights.Definer;\n\n    // The default SECURITY INVOKER permissions\n    _.Advanced.Migrator.UpsertRights = SecurityRights.Invoker;\n});\n```\n\n----------------------------------------\n\nTITLE: Marten ISerializer Interface Definition\nDESCRIPTION: This snippet shows the `ISerializer` interface that Marten uses for JSON serialization. It defines methods for serializing and deserializing objects to and from JSON, as well as properties for controlling enum storage, casing, and value casting. This interface allows developers to integrate custom serialization libraries with Marten.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/json.md#_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\n/// <summary>\n///     When selecting data through Linq Select() transforms,\n///     should the data elements returned from Postgresql be\n///     cast to their raw types or simple strings\n/// </summary>\npublic enum ValueCasting\n{\n    /// <summary>\n    ///     Json fields will be returned with their values cast to\n    ///     the proper type. I.e., {\"number\": 1}\n    /// </summary>\n    Strict,\n\n    /// <summary>\n    ///     Json fields will be returned with their values in simple\n    ///     string values. I.e., {\"number\": \"1\"}\n    /// </summary>\n    Relaxed\n}\n\npublic interface ISerializer\n{\n    /// <summary>\n    ///     Just gotta tell Marten if enum's are stored\n    ///     as int's or string's in the JSON\n    /// </summary>\n    EnumStorage EnumStorage { get; }\n\n    /// <summary>\n    ///     Specify whether properties in the JSON document should use Camel or Pascal casing.\n    /// </summary>\n    Casing Casing { get; }\n\n    /// <summary>\n    ///     Controls how the Linq Select() behavior needs to work in the database\n    /// </summary>\n    ValueCasting ValueCasting { get; }\n\n    /// <summary>\n    ///     Serialize the document object into a JSON string\n    /// </summary>\n    /// <param name=\"document\"></param>\n    /// <returns></returns>\n    string ToJson(object? document);\n\n    /// <summary>\n    ///     Deserialize a JSON string stream into an object of type T\n    /// </summary>\n    T FromJson<T>(Stream stream);\n\n    /// <summary>\n    ///     Deserialize a JSON string into an object of type T\n    /// </summary>\n    T FromJson<T>(DbDataReader reader, int index);\n\n    /// <summary>\n    ///     Deserialize a JSON string stream into an object of type T\n    /// </summary>\n    ValueTask<T> FromJsonAsync<T>(Stream stream, CancellationToken cancellationToken = default);\n\n    /// <summary>\n    ///     Deserialize a JSON string into an object of type T\n    /// </summary>\n    ValueTask<T> FromJsonAsync<T>(DbDataReader reader, int index, CancellationToken cancellationToken = default);\n\n    /// <summary>\n    ///     Deserialize a JSON string stream into an object of type T\n    /// </summary>\n    object FromJson(Type type, Stream stream);\n\n    /// <summary>\n    ///     Deserialize a JSON string into the supplied Type\n    /// </summary>\n    object FromJson(Type type, DbDataReader reader, int index);\n\n    /// <summary>\n    ///     Deserialize a JSON string stream into an object of type T\n    /// </summary>\n    ValueTask<object> FromJsonAsync(Type type, Stream stream, CancellationToken cancellationToken = default);\n\n    /// <summary>\n    ///     Deserialize a JSON string into the supplied Type\n    /// </summary>\n    ValueTask<object> FromJsonAsync(Type type, DbDataReader reader, int index,\n        CancellationToken cancellationToken = default);\n\n    /// <summary>\n    ///     Serialize a document without any extra\n    ///     type handling metadata\n    /// </summary>\n    /// <param name=\"document\"></param>\n    /// <returns></returns>\n    string ToCleanJson(object? document);\n\n    /// <summary>\n    ///     Write the JSON for a document with embedded\n    ///     type information. This is used inside the patching API\n    ///     to handle polymorphic collections\n    /// </summary>\n    /// <param name=\"document\"></param>\n    /// <returns></returns>\n    string ToJsonWithTypes(object document);\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Table Creation Style in Marten (C#)\nDESCRIPTION: This code snippet demonstrates how to customize the table creation style in Marten using the `CreationStyle` enum. It shows how to configure the document store to either create tables with a `CREATE TABLE IF NOT EXISTS` statement or the default `DROP TABLE` followed by `CREATE TABLE` statement. The `TableCreation` property of the `Advanced.Migrator` configuration is used to set the desired creation style.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/schema/authorization.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n    _.Advanced.Migrator.TableCreation = CreationStyle.CreateIfNotExists;\n\n    // or the default\n\n    _.Advanced.Migrator.TableCreation = CreationStyle.DropThenCreate;\n});\n```\n\n----------------------------------------\n\nTITLE: Multi-Property Calculated Index (Marten, C#)\nDESCRIPTION: Demonstrates creating a calculated index that includes multiple properties of a document. Requires Marten and Postgresql. Uses an array of expressions to define the properties to include in the index. Assumes a `User` document type with `FirstName` and `LastName` properties.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/indexing/computed-indexes.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n    var columns = new Expression<Func<User, object>>[]\n    {\n        x => x.FirstName,\n        x => x.LastName\n    };\n    _.Schema.For<User>().Index(columns);\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Mapping Specific SequentialGuid in Marten\nDESCRIPTION: This code snippet shows how to configure a specific document type to use the SequentialGuid id generation algorithm. This allows you to apply the CombGuid strategy only to certain document types within your Marten database.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/identity/guid.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:configuring-mapping-specific-sequentialguid]>\n```\n\n----------------------------------------\n\nTITLE: Define Multi-Level Document Hierarchy\nDESCRIPTION: Defines a multi-level document hierarchy with interfaces and classes (`ISmurf`, `Smurf`, `IPapaSmurf`, `PapaSmurf`, `PapySmurf`, `BrainySmurf`). Demonstrates the relationships between the types in the hierarchy.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/hierarchies.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\npublic interface ISmurf\n{\n    string Ability { get; set; }\n    Guid Id { get; set; }\n}\n\npublic class Smurf: ISmurf\n{\n    public string Ability { get; set; }\n    public Guid Id { get; set; }\n}\n\npublic interface IPapaSmurf: ISmurf\n{\n}\n\npublic class PapaSmurf: Smurf, IPapaSmurf\n{\n}\n\npublic class PapySmurf: Smurf, IPapaSmurf\n{\n}\n\npublic class BrainySmurf: PapaSmurf\n{\n}\n```\n\n----------------------------------------\n\nTITLE: Adding a Custom Schema Feature to Marten (C#)\nDESCRIPTION: This C# code demonstrates how to add a custom schema feature to a Marten application using the `Add<T>()` method within the `StoreOptions` configuration. It highlights the syntax for incorporating custom schema features into the Marten configuration. Marten passes the current `StoreOptions` to the constructor if there is one with that signature.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/advanced/extensions.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(_ =>\\n{\\n    _.DatabaseSchemaName = \"other\";\\n    _.Schema.Include<FakeSchemaFeature>();\\n});\n```\n\n----------------------------------------\n\nTITLE: Extending Polly Configuration in Marten (C#)\nDESCRIPTION: This snippet shows how to extend the default Polly configuration in Marten with custom policies. It adds a retry policy that handles ApplicationException with a maximum of 3 retry attempts and a linear backoff strategy. User-supplied policies take precedence over default Marten policies. Requires a connection string.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/retries.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nusing var store = DocumentStore.For(opts =>\n{\n    opts.Connection(\"some connection string\");\n\n    opts.ExtendPolly(builder =>\n    {\n        // custom policies are configured before marten default policies\n        builder.AddRetry(new()\n        {\n            // retry on your custom exceptions (ApplicationException as an example)\n            ShouldHandle = new PredicateBuilder().Handle<ApplicationException>(),\n            MaxRetryAttempts = 3,\n            Delay = TimeSpan.FromMilliseconds(50),\n            BackoffType = DelayBackoffType.Linear\n        });\n    });\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Marten with Connection String - C#\nDESCRIPTION: This snippet shows how to add Marten to an `IServiceCollection` by providing a connection string to the PostgreSQL database. It assumes that Marten is being used with default settings and requires a valid connection string for the database.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/integration.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:AddMartenByConnectionString]>\n```\n\n----------------------------------------\n\nTITLE: Using ConfigureMarten within application bootstrapping in C#\nDESCRIPTION: This snippet illustrates how to use `ConfigureMarten` within an application's bootstrapping process. It shows the initial Marten configuration along with other core service registrations and the addition of the User module using `AddUserModule()`. This demonstrates a complete example of integrating modular Marten configuration into a .NET application.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/hostbuilder.md#_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .ConfigureServices(services =>\n    {\n        // The initial Marten configuration\n        services.AddMarten(\"some connection string\");\n\n        // Other core service registrations\n        services.AddLogging();\n\n        // Add the User module\n        services.AddUserModule();\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Custom ID Generation Implementation C#\nDESCRIPTION: This code snippet demonstrates a custom ID generation strategy by implementing the `IIdGeneration` interface. The `Build()` method returns the actual `IdGenerator<T>` for the document type, where `T` is the type of the Id field.  It requires referencing the Marten library.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/identity/custom.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic class MyCustomIdGeneration : IIdGeneration\n{\n    public Task<IdAssignment<T>> ToAssignment<T>(DocumentStore store, CancellationToken cancellation = default)\n    {\n        throw new NotImplementedException();\n    }\n\n    public IIdGenerator<T> Build<T>(DocumentMapping mapping, StoreOptions options)\n    {\n        return new MyCustomIdGenerator<T>();\n    }\n}\n\npublic class MyCustomIdGenerator<T> : IIdGenerator<T>\n{\n    public T Generate(IExecutionContext context, IDocumentOperations operations)\n    {\n        throw new NotImplementedException();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Previewing LINQ Explain Plan (C#)\nDESCRIPTION: This snippet demonstrates how to fetch and preview the PostgreSQL EXPLAIN plan for a LINQ query using the `IDocumentStore.Diagnostics.Explain` method.  It queries for every `Trade` document with a `Value` over 2,000 and retrieves the EXPLAIN plan as a string. This provides insight into query performance and optimization opportunities.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/diagnostics.md#_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nusing var store = DocumentStore.For(_ =>\n{\n    _.Connection(\"some connection string\");\n});\n\n\nvar plan = await store.Diagnostics.Explain(async s =>\n{\n    return await s.Query<Trade>().Where(x => x.Value > 2000).ToListAsync();\n});\n\nConsole.WriteLine(plan);\n```\n\n----------------------------------------\n\nTITLE: Adding Managed Tenants at Runtime in C#\nDESCRIPTION: This code snippet demonstrates how to add new tenant ID partitions at runtime using the `IDocumentStore.Advanced` API. It ensures that table partitions exist for all multi-tenanted documents with the specified tenant IDs. The `AddMartenManagedTenantsAsync` method attempts to add any missing table partitions to all known document types.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/multi-tenancy.md#_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\nawait theStore\n    .Advanced\n    // This is ensuring that there are tenant id partitions for all multi-tenanted documents\n    // with the named tenant ids\n    .AddMartenManagedTenantsAsync(CancellationToken.None, \"a1\", \"a2\", \"a3\");\n```\n\n----------------------------------------\n\nTITLE: Applying Database Changes - Bash\nDESCRIPTION: This bash command demonstrates how to apply pending database changes using the Marten command-line interface. The 'db-apply' command executes the necessary SQL scripts to update the database schema.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/schema/migrations.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ndotnet run -- db-apply\n```\n\n----------------------------------------\n\nTITLE: Using statement for System.Text.Json upcasting\nDESCRIPTION: Specifies the required using statement to enable System.Text.Json based upcasting within Marten projects. It imports necessary classes for working with System.Text.Json transformations.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/versioning.md#_snippet_37\n\nLANGUAGE: cs\nCODE:\n```\nusing Marten.Services.Json.Transformations.SystemTextJson;\n```\n\n----------------------------------------\n\nTITLE: Implementing Console Subscription in C#\nDESCRIPTION: This code snippet implements a simple `ConsoleSubscription` that implements the `ISubscription` interface.  The `ProcessEventsAsync` method writes out a console message for every event in the given page. It does not depend on any external services and demonstrates the basic structure of a Marten subscription.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/subscriptions.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic class ConsoleSubscription: ISubscription\n{\n    public Task<IChangeListener> ProcessEventsAsync(EventRange page, ISubscriptionController controller, IDocumentOperations operations,\n        CancellationToken cancellationToken)\n    {\n        Console.WriteLine($\"Starting to process events from {page.SequenceFloor} to {page.SequenceCeiling}\");\n        foreach (var e in page.Events)\n        {\n            Console.WriteLine($\"Got event of type {e.Data.GetType().NameInCode()} from stream {e.StreamId}\");\n        }\n\n        // If you don't care about being signaled for\n        return Task.FromResult(NullChangeListener.Instance);\n    }\n\n    public ValueTask DisposeAsync()\n    {\n        return new ValueTask();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating an Invoice (C#)\nDESCRIPTION: This snippet demonstrates how to create an instance of the `Invoice` aggregate and add line items to it. It creates a new invoice with invoice number 42, and then adds two line items with specific prices, VAT rates, and descriptions.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/scenarios/aggregates-events-repositories.md#_snippet_4\n\nLANGUAGE: cs\nCODE:\n```\nvar invoice = new Invoice(42);\n\ninvoice.AddLine(100, 24, \"Joo Janta 200 Super-Chromatic Peril Sensitive Sunglasses\");\ninvoice.AddLine(200, 16, \"Happy Vertical People Transporter\");\n```\n\n----------------------------------------\n\nTITLE: Querying for a Single User Document - C#\nDESCRIPTION: This C# code shows an example of using `ICompiledQuery<User>` to find a single user by `Username`, `FirstName`, and `LastName`. It implements the `QueryIs()` method to define the query expression using `IMartenQueryable<User>` and uses `Single()` to retrieve a single result. It requires the `User` class to exist.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/compiled-queries.md#_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\npublic class FindUserByAllTheThings: ICompiledQuery<User>\n{\n    public string Username { get; set; }\n    public string FirstName { get; set; }\n    public string LastName { get; set; }\n\n    public Expression<Func<IMartenQueryable<User>, User>> QueryIs()\n    {\n        return query =>\n            query.Where(x => x.FirstName == FirstName && Username == x.UserName)\n                .Where(x => x.LastName == LastName)\n                .Single();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Document Storage Class Diagram\nDESCRIPTION: This Mermaid class diagram illustrates the relationships between key interfaces and classes in Marten's document storage architecture, including IDocumentSession, IUnitOfWork, IDocumentStorage<T>, IStorageOperation, and IUpdateBatch. It showcases the dependencies and inheritance between these components, providing a visual representation of the system's structure.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/diagrams/storage.md#_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\nclassDiagram\n\nclass IDocumentSession {\n+ SaveChangesAsync()\n+ SaveChanges()\n}\n<<interface>> IDocumentSession\n\nclass IStorageOperation {\n    <<interface>> IStorageOperation\n    Postprocess(DbDataReader, IList~Exception~)\n    PostprocessAsync(DbDataReader, IList~Exception~, CancellationToken) \n}\n\n\nclass IQueryHandler {\n    + ConfigureCommand(CommandBuilder, IMartenSession)\n}\n<<interface>> IQueryHandler\n\nIStorageOperation ..|> IQueryHandler\n\nclass IUpdateBatch {\n    + ApplyChanges(IMartenSession)\n    + ApplyChangesAsync(IMartenSession)\n}\n<<interface>> IUpdateBatch\n\nclass CommandBuilder\n\nIUpdateBatch --> CommandBuilder\nIQueryHandler --> CommandBuilder\n\nclass IMartenSession\n<<interface>> IMartenSession\n\nclass DocumentSessionBase\n<<abstract>> DocumentSessionBase\n\nDocumentSessionBase ..|> IMartenSession\nDocumentSessionBase ..|> IDocumentSession\n\nIStorageOperation --> IMartenSession\n\nclass IUnitOfWork\n<<interface>> IUnitOfWork\n\nIUnitOfWork o-- IStorageOperation\nIUpdateBatch o-- IStorageOperation\nDocumentSessionBase --> IUpdateBatch\nDocumentSessionBase --> IUnitOfWork\nIDocumentStorage~T~ --> IStorageOperation\nDocumentSessionBase --> IDocumentStorage~T~\n\nclass IDocumentStorage~T~\n<<interface>> IDocumentStorage~T~\n\nclass LightweightDocumentSession\n\nclass DirtyCheckingDocumentSession\n\nclass IdentityMapDocumentSession\n\nLightweightDocumentSession --|> DocumentSessionBase\nDirtyCheckingDocumentSession --|> DocumentSessionBase\nIdentityMapDocumentSession --|> DocumentSessionBase\n\n```\n\n----------------------------------------\n\nTITLE: GitHub Actions Environment Variables - YAML\nDESCRIPTION: This YAML snippet defines environment variables used within a GitHub Actions workflow. These variables specify the build configuration, disable telemetry and the logo, define the .NET version, and set the project and solution names. These variables are then used throughout the workflow steps.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/devops/devops.md#_snippet_9\n\nLANGUAGE: YAML\nCODE:\n```\nenv:\n  BUILD_CONFIGURATION: Release\n  DOTNET_CLI_TELEMETRY_OPTOUT: true\n  DOTNET_NOLOGO: true\n  DOTNET_VERSION: 8.0.x\n  PROJECT: fooproject\n  SOLUTION: Application\n```\n\n----------------------------------------\n\nTITLE: Creating or Replacing a Function\nDESCRIPTION: This snippet showcases PostgreSQL's `CREATE OR REPLACE FUNCTION` syntax, which allows you to create a new function or replace an existing one with the same name. This avoids the need to drop the function before creating it again, as would be necessary in some other database systems.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/postgres/if-statements.md#_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\nCREATE OR REPLACE FUNCTION create_product\n```\n\n----------------------------------------\n\nTITLE: Configuring Hilo with Sequence Name - C#\nDESCRIPTION: This code snippet demonstrates how to use one sequence with multiple document types by specifying the same sequence name. This is done using the `HiloSequenceDefaults.SequenceName` property when configuring the store options.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/identity/sequential.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:configuring-global-hilo-defaults-sequencename]>\n```\n\n----------------------------------------\n\nTITLE: Custom Serializer Contract (C#)\nDESCRIPTION: Customizes the default behavior of the Json.NET serializer to support private property setters during deserialization, which is required for hydrating immutable projections.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/scenarios/immutable_projections_readmodel.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic class SerializerContract : SerializerFactory\n{\n    public override JsonContract CreateContract(Type objectType)\n    {\n        var contract = base.CreateContract(objectType);\n        contract.DefaultCreator = () => Activator.CreateInstance(objectType, true);\n        contract.IsReference = false;\n        foreach (var property in contract.Properties)\n        {\n            property.Readable = true;\n            property.Writable = true;\n            property.HasMemberAttribute = true;\n        }\n        return contract;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Masking by Event Filter (C#)\nDESCRIPTION: This snippet demonstrates how to apply event data masking to events across multiple streams based on an event filter. It uses the `ApplyEventDataMasking` method to include events of type `QuestStarted` from streams whose IDs are in the provided `streamIds` array.  This approach filters events irrespective of the stream they belong to, based on event properties.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/protection.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic static Task apply_masking_by_filter(IDocumentStore store, Guid[] streamIds)\n{\n    return store.Advanced.ApplyEventDataMasking(x =>\n        {\n            x.IncludeEvents(e => e.EventTypesAre(typeof(QuestStarted)) && e.StreamId.IsOneOf(streamIds));\n        });\n}\n```\n\n----------------------------------------\n\nTITLE: Enlisting in Existing Transactions with Marten\nDESCRIPTION: Demonstrates how to use an existing connection or transaction with Marten, how to enlist in an ambient transaction scope, and control transaction boundaries using SessionOptions.  This requires .NET Framework (> 4.6) or .NET Standard 2.0. The code showcases scenarios where Marten can either control or not control the transaction boundaries.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/sessions.md#_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\n// Use an existing connection, but Marten still controls the transaction lifecycle\nvar session1 = store.LightweightSession(SessionOptions.ForConnection(connection));\n\n// Enlist in an existing Npgsql transaction, but\n// choose not to allow the session to own the transaction\n// boundaries\nvar session3 = store.LightweightSession(SessionOptions.ForTransaction(transaction));\n\n// Enlist in the current, ambient transaction scope\nusing var scope = new TransactionScope();\nvar session4 = store.LightweightSession(SessionOptions.ForCurrentTransaction());\n```\n\n----------------------------------------\n\nTITLE: Multi-Column Index (Marten, C#)\nDESCRIPTION: Creates a multi-column calculated index using an anonymous type to specify multiple properties.  Requires Marten and Postgresql. Assumes a `User` document type with `FirstName` and `LastName` properties.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/indexing/computed-indexes.md#_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(opts =>\n{\n    // This creates a single index against both FirstName and ListName\n    opts.Schema.For<User>().Index(x => new { x.FirstName, x.LastName });\n});\n```\n\n----------------------------------------\n\nTITLE: Upcasting Event with System.Text.Json\nDESCRIPTION: This snippet demonstrates raw JSON transformation using System.Text.Json's `JsonDocument`. It upcasts an event by accessing the old event data as a `JsonDocument` and mapping its properties to the new event type. `options.UseSystemTextJsonForSerialization()` must be called before configuring the upcast.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/versioning.md#_snippet_16\n\nLANGUAGE: csharp\nCODE:\n```\noptions.UseSystemTextJsonForSerialization();\n\noptions.Events\n    .Upcast<ShoppingCartOpenedWithStatus>(\n        \"shopping_cart_opened\",\n        Upcast(oldEventJson =>\n        {\n            var oldEvent = oldEventJson.RootElement;\n\n            return new ShoppingCartOpenedWithStatus(\n                oldEvent.GetProperty(\"ShoppingCartId\").GetGuid(),\n                new Client(\n                    oldEvent.GetProperty(\"ClientId\").GetGuid()\n                ),\n                ShoppingCartStatus.Opened\n            );\n        })\n    );\n```\n\n----------------------------------------\n\nTITLE: Plugging Custom Retry Policy into StoreOptions (C#)\nDESCRIPTION: This snippet shows how to plug a custom `IRetryPolicy` implementation, such as `SampleRetryPolicy`, into the `StoreOptions` when configuring the Marten `DocumentStore`. The `RetryPolicy` method is used to register the retry policy for all database operations.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/advanced/retrypolicy.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n    _.Connection(\"your connection string\");\n    _.RetryPolicy<SampleRetryPolicy>();\n});\n```\n\n----------------------------------------\n\nTITLE: Defining the ITenancy Interface in Marten (C#)\nDESCRIPTION: This code defines the `ITenancy` interface, a pluggable interface for Marten multi-tenancy by database. It outlines the methods for retrieving tenants, finding or creating databases, and managing database configurations. The interface includes properties for accessing the default tenant and a composite document cleaner.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/multitenancy.md#_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\n/// <summary>\n///     Pluggable interface for Marten multi-tenancy by database\n/// </summary>\npublic interface ITenancy: IDatabaseSource, IDisposable\n{\n    /// <summary>\n    ///     The default tenant. This can be null.\n    /// </summary>\n    Tenant Default { get; }\n\n    /// <summary>\n    ///     A composite document cleaner for the entire collection of databases\n    /// </summary>\n    IDocumentCleaner Cleaner { get; }\n\n    /// <summary>\n    ///     Retrieve or create a Tenant for the tenant id.\n    /// </summary>\n    /// <param name=\"tenantId\"></param>\n    /// <exception cref=\"UnknownTenantIdException\"></exception>\n    /// <returns></returns>\n    Tenant GetTenant(string tenantId);\n\n    /// <summary>\n    ///     Retrieve or create a tenant for the tenant id\n    /// </summary>\n    /// <param name=\"tenantId\"></param>\n    /// <returns></returns>\n    ValueTask<Tenant> GetTenantAsync(string tenantId);\n\n    /// <summary>\n    ///     Find or create the named database\n    /// </summary>\n    /// <param name=\"tenantIdOrDatabaseIdentifier\"></param>\n    /// <returns></returns>\n    ValueTask<IMartenDatabase> FindOrCreateDatabase(string tenantIdOrDatabaseIdentifier);\n\n    /// <summary>\n    ///  Asserts that the requested tenant id is part of the current database\n    /// </summary>\n    /// <param name=\"database\"></param>\n    /// <param name=\"tenantId\"></param>\n    bool IsTenantStoredInCurrentDatabase(IMartenDatabase database, string tenantId);\n}\n```\n\n----------------------------------------\n\nTITLE: Previewing Generated Code with Marten CLI\nDESCRIPTION: This Bash command uses the Marten command-line interface (CLI) to preview the code that Marten would generate for the configured document types, compiled queries, and event store support. It leverages Oakton for command-line parsing and allows developers to inspect the generated code before writing it to the project.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/prebuilding.md#_snippet_5\n\nLANGUAGE: Bash\nCODE:\n```\ndotnet run -- codegen preview\n```\n\n----------------------------------------\n\nTITLE: Using Compiled Query Example C#\nDESCRIPTION: This code shows how to use the `FindByFirstName` compiled query to retrieve a user from the document store. It demonstrates the process of creating an instance of the compiled query, setting the parameter, and then executing the query against the document session.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/compiled_queries.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nvar user = session.Query(new FindByFirstName { FirstName = \"Jeremy\" });\n```\n\n----------------------------------------\n\nTITLE: Defining Session Interface with CorrelationId in C#\nDESCRIPTION: This code snippet defines an interface `ISession` with a `CorrelationId` property of type `Guid`. This interface is used to represent a session with a correlation identifier, which can be used for logging or other purposes.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/hostbuilder.md#_snippet_18\n\nLANGUAGE: cs\nCODE:\n```\npublic interface ISession\n{\n    Guid CorrelationId { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling optimistic concurrency with FetchForWriting in Marten\nDESCRIPTION: This code snippet demonstrates how to handle optimistic concurrency using `FetchForWriting` in Marten. It fetches an `Order` aggregate, processes a `MarkItemReady` command, appends events based on the command, and saves changes. It expects the `command.Version` to match the current stream version, throwing a `ConcurrencyException` if versions mismatch. The session and stream objects are part of the Marten library.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/scenarios/command_handler_workflow.md#_snippet_4\n\nLANGUAGE: cs\nCODE:\n```\npublic async Task Handle2(MarkItemReady command, IDocumentSession session)\n{\n    // Fetch the current value of the Order aggregate\n    var stream = await session\n        .Events\n\n        // Explicitly tell Marten the exptected, starting version of the\n        // event stream\n        .FetchForWriting<Order>(command.OrderId, command.Version);\n\n    var order = stream.Aggregate;\n\n    if (order.Items.TryGetValue(command.ItemName, out var item))\n    {\n        // Mark that the this item is ready\n        stream.AppendOne(new ItemReady(command.ItemName));\n    }\n    else\n    {\n        // Some crude validation\n        throw new InvalidOperationException($\"Item {command.ItemName} does not exist in this order\");\n    }\n\n    // If the order is ready to ship, also emit an OrderReady event\n    if (order.IsReadyToShip())\n    {\n        stream.AppendOne(new OrderReady());\n    }\n\n    await session.SaveChangesAsync();\n}\n```\n\n----------------------------------------\n\nTITLE: Querying with SelectMany() for simple array in Marten (C#)\nDESCRIPTION: This snippet shows how to use the `SelectMany()` operator to flatten a collection of string arrays (Tags) from `Product` documents into a single list of strings. It demonstrates retrieving distinct tags and all tags, verifying their content and count. Requires `theStore` to be an initialized `IDocumentStore` with `Product` documents stored.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/projections.md#_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic async Task can_do_simple_select_many_against_simple_array()\n{\n    var product1 = new Product {Tags = new[] {\"a\", \"b\", \"c\"}};\n    var product2 = new Product {Tags = new[] {\"b\", \"c\", \"d\"}};\n    var product3 = new Product {Tags = new[] {\"d\", \"e\", \"f\"}};\n\n    using (var session = theStore.LightweightSession())\n    {\n        session.Store(product1, product2, product3);\n        await session.SaveChangesAsync();\n    }\n\n    using (var query = theStore.QuerySession())\n    {\n        var distinct = query.Query<Product>().SelectMany(x => x.Tags).Distinct().ToList();\n\n        distinct.OrderBy(x => x).ShouldHaveTheSameElementsAs(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\");\n\n        var names = query.Query<Product>().SelectMany(x => x.Tags).ToList();\n        names\n            .Count().ShouldBe(9);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configure Template With Configure Marten - C#\nDESCRIPTION: This code snippet shows how to change the Ddl template against the underlying configuration model using the embedded configuration option. This allows for dynamic configuration of DDL templates.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/schema/authorization.md#_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:configure_template_with_configure_marten]>\n```\n\n----------------------------------------\n\nTITLE: Read Latest Invoice with FetchLatest - C#\nDESCRIPTION: This code snippet demonstrates how to use `FetchLatest` to retrieve the latest version of an `Invoice` aggregate from the event store. It shows that `FetchLatest` is available on `IDocumentSession` but not `IQuerySession`. The function takes an `IDocumentSession` and an `invoiceId` as input and returns the latest `Invoice` object.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/read-aggregates.md#_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic static async Task read_latest(\n    // Watch this, only available on the full IDocumentSession\n    IDocumentSession session,\n    Guid invoiceId)\n{\n    var invoice = await session\n        .Events.FetchLatest<Projections.Invoice>(invoiceId);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Global Custom ID Generation in Marten\nDESCRIPTION: This code shows how to configure a custom ID generation strategy globally for all document types that have a string Id in Marten. The code configures document store options to use the custom ID generation for all document types with a string ID.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/identity.md#_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\noptions.Policies.ForAllDocuments(m =>\n{\n    if (m.IdType == typeof(string))\n    {\n        m.IdStrategy = new CustomIdGeneration();\n    }\n});\n```\n\n----------------------------------------\n\nTITLE: Storing and Loading Invoice (C#)\nDESCRIPTION: This snippet shows how to store and load an invoice using the `AggregateRepository`. It creates an instance of the repository with a configured document store. The `StoreAsync` method is used to persist the invoice, and the `LoadAsync` method is used to retrieve the invoice from the event stream. Finally, assertions are performed to verify that the loaded invoice matches the original invoice.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/scenarios/aggregates-events-repositories.md#_snippet_5\n\nLANGUAGE: cs\nCODE:\n```\nvar repository = new AggregateRepository(theStore);\n\nawait repository.StoreAsync(invoice);\n\nvar invoiceFromRepository = await repository.LoadAsync<Invoice>(invoice.Id);\n\nAssert.Equal(invoice.ToString(), invoiceFromRepository.ToString());\nAssert.Equal(invoice.Total, invoiceFromRepository.Total);\n```\n\n----------------------------------------\n\nTITLE: Upcaster with Explicit Event Type Name\nDESCRIPTION: Shows how to explicitly define the event type name when upcasting with `AsyncOnlyEventUpcaster`.  This is useful when the event type name differs from the default naming convention. The class overrides the `EventTypeName` property to specify the correct event type name for the old event.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/versioning.md#_snippet_33\n\nLANGUAGE: cs\nCODE:\n```\npublic class ShoppingCartOpenedAsyncOnlyUpcaster:\n    AsyncOnlyEventUpcaster<ShoppingCartOpened, ShoppingCartOpenedWithStatus>\n{\n    // Explicit event type name mapping may be useful if you used other than default event type name\n    // for old event type.\n    public override string EventTypeName => \"shopping_cart_opened\";\n\n    private readonly IClientRepository _clientRepository;\n\n    public ShoppingCartOpenedAsyncOnlyUpcaster(IClientRepository clientRepository) =>\n        _clientRepository = clientRepository;\n\n    protected override async Task<ShoppingCartOpenedWithStatus> UpcastAsync(\n        ShoppingCartOpened oldEvent,\n        CancellationToken ct\n    )\n    {\n        // WARNING: UpcastAsync method is called each time old event\n        // is read from database and deserialized.\n        // We discourage to run resource consuming methods here.\n        // It might end up with N+1 problem.\n        var clientName = await _clientRepository.GetClientName(oldEvent.ClientId, ct);\n\n        return new ShoppingCartOpenedWithStatus(\n            oldEvent.ShoppingCartId,\n            new Client(oldEvent.ClientId, clientName),\n            ShoppingCartStatus.Opened\n        );\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Soft Deleted Documents in Marten\nDESCRIPTION: This code snippet demonstrates how to query for documents that have been marked as deleted using Marten's `IsDeleted()` method. It shows querying with and without a `where` clause. It initializes users, soft deletes based on username, and then queries for deleted users.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/deletes.md#_snippet_13\n\nLANGUAGE: cs\nCODE:\n```\n[Fact]\npublic async Task query_is_soft_deleted_docs()\n{\n    var user1 = new User { UserName = \"foo\" };\n    var user2 = new User { UserName = \"bar\" };\n    var user3 = new User { UserName = \"baz\" };\n    var user4 = new User { UserName = \"jack\" };\n\n    using var session = theStore.LightweightSession();\n    session.Store(user1, user2, user3, user4);\n    await session.SaveChangesAsync();\n\n    session.DeleteWhere<User>(x => x.UserName.StartsWith(\"b\"));\n    await session.SaveChangesAsync();\n\n    // no where clause\n    session.Query<User>().Where(x => x.IsDeleted()).OrderBy(x => x.UserName).Select(x => x.UserName)\n        .ToList().ShouldHaveTheSameElementsAs(\"bar\", \"baz\");\n\n    // with a where clause\n    session.Query<User>().Where(x => x.UserName != \"baz\" && x.IsDeleted())\n        .OrderBy(x => x.UserName)\n        .ToList()\n        .Select(x => x.UserName)\n        .Single().ShouldBe(\"bar\");\n}\n```\n\nLANGUAGE: cs\nCODE:\n```\n[Fact]\npublic async Task query_is_soft_deleted_docs()\n{\n    var user1 = new User { UserName = \"foo\" };\n    var user2 = new User { UserName = \"bar\" };\n    var user3 = new User { UserName = \"baz\" };\n    var user4 = new User { UserName = \"jack\" };\n\n    using var session = theStore.LightweightSession();\n    session.Store(user1, user2, user3, user4);\n    await session.SaveChangesAsync();\n\n    session.DeleteWhere<User>(x => x.UserName.StartsWith(\"b\"));\n    await session.SaveChangesAsync();\n\n    // no where clause\n    session.Query<User>().Where(x => x.IsDeleted()).OrderBy(x => x.UserName).Select(x => x.UserName)\n        .ToList().ShouldHaveTheSameElementsAs(\"bar\", \"baz\");\n\n    // with a where clause\n    session.Query<User>().Where(x => x.UserName != \"baz\" && x.IsDeleted())\n        .OrderBy(x => x.UserName)\n        .ToList()\n        .Select(x => x.UserName)\n        .Single().ShouldBe(\"bar\");\n}\n```\n\n----------------------------------------\n\nTITLE: Using FetchForWriting with Strong Typed Identifier - C#\nDESCRIPTION: This code demonstrates how to use the `FetchForWriting` API with a strongly-typed identifier (`PaymentId`). It shows how to extract the underlying primitive value (Guid in this case) from the `PaymentId` struct and pass it to `FetchForWriting` to retrieve the `Payment` aggregate for writing.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/aggregate-projections.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nprivate async Task use_fetch_for_writing_with_strong_typed_identifier(PaymentId id, IDocumentSession session)\n{\n    var stream = await session.Events.FetchForWriting<Payment>(id.Value);\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Namedatalen in StoreOptions - C#\nDESCRIPTION: Demonstrates how to configure the `NamedDataLength` property within Marten's `StoreOptions` to accommodate PostgreSQL's limitations on database object name lengths.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/index.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n    _.Connection(\"some connection string\");\n\n    // Tell Marten about your known\n    // NamedDataLength in Postgresql\n    _.Advanced.NamedDataLength = 128;\n});\n```\n\n----------------------------------------\n\nTITLE: Custom Linq Parser Implementation C#\nDESCRIPTION: This snippet demonstrates a custom Linq parser implementation for the `IsBlue()` method. It inherits from `IMethodCallParser` and includes logic to match method expressions and convert them into Postgresql \"where\" clauses.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/advanced/customizing_linq.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:custom-extension-for-linq]>\n```\n\n----------------------------------------\n\nTITLE: Defining an Invoice Projection Model in C#\nDESCRIPTION: This snippet defines the events and the `Invoice` aggregate, including how events are applied to the aggregate. It showcases the basic structure of a projection with events like `InvoiceCreated`, `InvoiceApproved`, `InvoiceCancelled`, `InvoicePaid`, and `InvoiceRejected`. The `Invoice` class includes properties such as `Amount`, `Description`, `Id`, `Created`, and `Status` that are updated by the event handlers.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/testing.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic record InvoiceCreated(string Description, decimal Amount);\n\npublic record InvoiceApproved;\npublic record InvoiceCancelled;\npublic record InvoicePaid;\npublic record InvoiceRejected;\n\npublic class Invoice\n{\n    public Invoice()\n    {\n    }\n\n    public static Invoice Create(IEvent<InvoiceCreated> created)\n    {\n        return new Invoice\n        {\n            Amount = created.Data.Amount,\n            Description = created.Data.Description,\n\n            // Capture the timestamp from the event\n            // metadata captured by Marten\n            Created = created.Timestamp,\n            Status = InvoiceStatus.Created\n        };\n    }\n\n    public int Version { get; set; }\n\n    public decimal Amount { get; set; }\n    public string Description { get; set; }\n    public Guid Id { get; set; }\n    public DateTimeOffset Created { get; set; }\n    public InvoiceStatus Status { get; set; }\n\n    public void Apply(InvoiceCancelled _) => Status = InvoiceStatus.Cancelled;\n    public void Apply(InvoiceRejected _) => Status = InvoiceStatus.Rejected;\n    public void Apply(InvoicePaid _) => Status = InvoiceStatus.Paid;\n    public void Apply(InvoiceApproved _) => Status = InvoiceStatus.Approved;\n}\n```\n\n----------------------------------------\n\nTITLE: Override to Single Tenancy in Marten\nDESCRIPTION: This snippet demonstrates how to override the default `TenancyStyle.Conjoined` set by policies and set the `Target` to `TenancyStyle.Single`. It utilizes `storeOptions.Schema.For<Target>().SingleTenanted()` to override the policy set on `storeOptions.Policies.ForAllDocuments`\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/multi-tenancy.md#_snippet_13\n\nLANGUAGE: cs\nCODE:\n```\nstoreOptions.Policies.ForAllDocuments(x => x.TenancyStyle = TenancyStyle.Conjoined);\nstoreOptions.Schema.For<Target>().SingleTenanted();\n```\n\n----------------------------------------\n\nTITLE: Projecting Stream with Private Event Apply Methods (C#)\nDESCRIPTION: Demonstrates how to project an event stream using AggregateWithPrivateEventApply, leveraging the previously configured private event application methods.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/scenarios/immutable_projections_readmodel.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nvar projection = await repository.AggregateWithPrivateEventApply<Projection>(streamId, token);\n\nvar projection2 = await repository.LoadAggregateWithPrivateEventApply<Projection>(streamId, token);\n```\n\n----------------------------------------\n\nTITLE: Cleaning Specific Marten Database with IHost\nDESCRIPTION: Demonstrates cleaning Marten data in a specific database using the IHost extension method CleanAllMartenDataAsync<TStore>().  This allows cleaning data in a specific Marten database when working with multiple databases. Requires an IHost instance and the specific DocumentStore type.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/schema/cleaning.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic async Task clean_out_database_documents(IHost host)\n{\n    // Clean off all Marten data in the IInvoicing DocumentStore for this host\n    await host.CleanAllMartenDataAsync<IInvoicingStore>();\n}\n```\n\n----------------------------------------\n\nTITLE: Resetting Hilo Sequence Floor - C#\nDESCRIPTION: This code snippet shows how to reset the \"floor\" of the Hilo sequence for a single document type using the `ResetHiloSequenceFloor` method. This is useful for importing data from existing sources, guaranteeing new IDs will be higher than the specified floor, but potentially leaving gaps in the sequence.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/identity/sequential.md#_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:ResetHiloSequenceFloor]>\n```\n\n----------------------------------------\n\nTITLE: Querying with `In` Operator using String List - Marten - C#\nDESCRIPTION: This code snippet demonstrates how to use the `In()` extension method in Marten to query for documents where a string property matches one of several provided values within a list.  It uses `session.Query<SuperUser>()` to query the `SuperUser` documents, checking if the `Role` property is one of the strings in `listOfRoles`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/child-collections.md#_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\n// Finds all SuperUser's whose role is either\n// Admin, Supervisor, or Director\nvar listOfRoles = new List<string> {\"Admin\", \"Supervisor\", \"Director\"};\n\nvar users = session.Query<SuperUser>()\n    .Where(x => x.Role.In(listOfRoles));\n```\n\n----------------------------------------\n\nTITLE: Defining ICompiledListQuery Interface\nDESCRIPTION: This interface defines a compiled query that retrieves a list of documents of type `TDoc` without any `Select()` transform. It inherits from `ICompiledListQuery<TDoc, TDoc>`, indicating that the input and output types are the same.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/compiled-queries.md#_snippet_5\n\nLANGUAGE: cs\nCODE:\n```\npublic interface ICompiledListQuery<TDoc>: ICompiledListQuery<TDoc, TDoc>\n{\n}\n```\n\n----------------------------------------\n\nTITLE: Opening Async Serializable Session\nDESCRIPTION: This snippet shows how to open an asynchronous and serializable IDocumentSession using LightweightSerializableSessionAsync. It retrieves Issue documents containing the \"open\" tag from the database. This is used for serializable transactions.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/sessions.md#_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\nawait using var session =\n    await store.LightweightSerializableSessionAsync(SessionOptions.ForConnectionString(\"another connection string\"));\n\nvar openIssues = await session.Query<Issue>()\n    .Where(x => x.Tags.Contains(\"open\"))\n    .ToListAsync();\n```\n\n----------------------------------------\n\nTITLE: Customizing Calculated Index (Marten)\nDESCRIPTION: This C# code demonstrates how to customize a calculated index within Marten using a second Lambda `Action`.  It allows specifying different index types or other Postgresql index options.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/computed_index.md#_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic class User\n{\n    public Guid Id { get; set; }\n    public string UserName { get; set; }\n}\n\npublic class UserConfiguration : Marten.Mapping.DocumentMapping<User>\n{\n    public UserConfiguration()\n    {\n        Index(x => x.UserName, idx =>\n        {\n            idx.Method = IndexMethod.hash;\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: String EqualsIgnoreCase in Marten with Linq\nDESCRIPTION: Demonstrates the use of `EqualsIgnoreCase` extension method (from *Baseline*) for case-insensitive string comparison in Marten Linq queries.  Requires a `query` object, a `User` document type with a `UserName` property, and assertions using `ShouldBe`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/strings.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nquery.Query<User>().Single(x => x.UserName.EqualsIgnoreCase(\"abc\")).Id.ShouldBe(user1.Id);\nquery.Query<User>().Single(x => x.UserName.EqualsIgnoreCase(\"aBc\")).Id.ShouldBe(user1.Id);\n```\n\n----------------------------------------\n\nTITLE: Applying All Configured Changes - C#\nDESCRIPTION: This code shows how to programmatically apply all detectable schema changes upfront using Marten. The `ApplyAllConfiguredChangesToDatabaseAsync` method updates the database schema to match the current Marten configuration. This requires an `IDocumentStore` instance connected to the target database.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/schema/migrations.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nawait store.Storage.ApplyAllConfiguredChangesToDatabaseAsync();\n```\n\n----------------------------------------\n\nTITLE: Enabling Multi-Tenancy for Events - Marten - C#\nDESCRIPTION: This code snippet demonstrates how to enable conjoined multi-tenancy for events in Marten. Setting the `TenancyStyle` to `TenancyStyle.Conjoined` configures the event storage to be multi-tenanted.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/configuration.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(opts =>\n{\n    opts.Connection(\"some connection string\");\n\n    // And that's all it takes, the events are now multi-tenanted\n    opts.Events.TenancyStyle = TenancyStyle.Conjoined;\n});\n```\n\n----------------------------------------\n\nTITLE: Querying Maybe Archived Events using Marten in C#\nDESCRIPTION: This snippet shows how to query for both archived and non-archived events using the `MaybeArchived()` method in Marten. It retrieves all raw events regardless of their archived status. Requires an active `IDocumentSession`. The result is a list of events, including both archived and non-archived ones.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/archiving.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvar events = await theSession.Events.QueryAllRawEvents()\n    .Where(x => x.MaybeArchived()).ToListAsync();\n```\n\n----------------------------------------\n\nTITLE: Define Duplicated Field Unique Index (Multiple Properties) via Attribute in Marten C#\nDESCRIPTION: This code snippet demonstrates defining a unique index on multiple properties as duplicated fields using the `UniqueIndex` attribute in Marten. The `FirstName` and `SecondName` properties of the `Person` class are annotated with `[UniqueIndex]` using the same `IndexName`, grouping them into a single unique index. This enforces uniqueness on the combination of first and second names.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/indexing/unique.md#_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic class Person\n{\n    private const string UniqueIndexName = \"sample_uidx_person\";\n\n    public Guid Id { get; set; }\n\n    [UniqueIndex(IndexType = UniqueIndexType.DuplicatedField, IndexName = UniqueIndexName)]\n    public string FirstName { get; set; }\n\n    [UniqueIndex(IndexType = UniqueIndexType.DuplicatedField, IndexName = UniqueIndexName)]\n    public string SecondName { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Batched Query in Marten (C#)\nDESCRIPTION: Demonstrates the usage of batched queries to fetch document data from Marten in a single database request. It involves creating an `IBatchedQuery` object, defining queries, and retrieving the results using Tasks after the batch execution.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/batched_queries.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic async Task using_batch_query(IDocumentStore store)\n{\n    using (var session = store.OpenSession())\n    {\n        var todo1 = new Todo { Assignee = \"Jeremy\", Name = \"Shave the Yak\" };\n        var todo2 = new Todo { Assignee = \"Max\", Name = \"Listen to the Thelonious Monk Quartet\" };\n        var todo3 = new Todo { Assignee = \"Jeremy\", Name = \"Rewatch all of Battlestar Galactica\" };\n\n        session.Store(todo1);\n        session.Store(todo2);\n        session.Store(todo3);\n\n        await session.SaveChangesAsync();\n    }\n\n    using (var session = store.OpenSession())\n    {\n        var batch = session.CreateBatchQuery();\n\n        // Issue a couple different queries within the batch\n        var jeremysTodos = batch.Query<Todo>(x => x.Assignee == \"Jeremy\");\n        var firstTodo = batch.Load<Todo>(todo2.Id);\n\n        // This *starts* the execution of the batched query\n        await batch.Execute();\n\n        // All results are available immediately\n        var todos = jeremysTodos.Result;\n        var todo = firstTodo.Result;\n\n        todos.Each(x => Debug.WriteLine(x.Name));\n        Debug.WriteLine(todo.Name);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Masking with Multi-Tenancy (C#)\nDESCRIPTION: This snippet demonstrates how to apply event data masking in a multi-tenant Marten environment. It uses the `ApplyEventDataMasking` method and specifies the `tenantId` using the `ForTenant` method. The masking is applied to events in the specified `streamId` within the provided tenant.  The order of `IncludeStream` and `ForTenant` does not matter.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/protection.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic static Task apply_masking_by_tenant(IDocumentStore store, string tenantId, Guid streamId)\n{\n    return store\n        .Advanced\n        .ApplyEventDataMasking(x =>\n        {\n            x.IncludeStream(streamId);\n\n            // Specify the tenant id, and it doesn't matter\n            // in what order this appears in\n            x.ForTenant(tenantId);\n        });\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Duplicated Field Unique Index with Attribute (Single Property) - C#\nDESCRIPTION: This code snippet demonstrates how to define a unique index on a duplicated field using the `[UniqueIndex]` attribute. This creates a unique index on a dedicated database column mapped to a document property. Using duplicated fields can improve query performance.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/unique.md#_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:using_a_single_property_duplicate_field_unique_index_through_store_attribute]>\n```\n\n----------------------------------------\n\nTITLE: Implementing Invoice Aggregate with Event Handling in C#\nDESCRIPTION: This snippet implements the `Invoice` aggregate, using the infrastructure provided by `AggregateBase`, to create and replay state from the defined events. It demonstrates state protection through immutability and argument validation, recording events for state modifications.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/scenarios/aggregates_events_repositories.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:scenario-aggregate-invoice]>\n```\n\n----------------------------------------\n\nTITLE: Configure Marten to use Metadata Type\nDESCRIPTION: Configures the Marten DocumentStore to use the `MyMetadata` class, instructing Marten to add extra columns to the documents and events for the metadata properties defined in `MyMetadata`.  The `UseMetadataType<MyMetadata>()` extension method would likely provide a fluent interface for fine-tuning the storage and applicability of the metadata.\nSOURCE: https://github.com/jasperfx/marten/blob/master/planning/MartenV4.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar store = DocumentStore.For(x => {\n    // other stuff\n\n    // This would direct Marten to add extra columns to\n    // the documents and events for the metadata properties\n    // on the MyMetadata type.\n\n    // This would probably be a fluent interface to optionally fine tune\n    // the storage and applicability -- i.e., to all documents, to events, etc.\n    x.UseMetadataType<MyMetadata>();\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing Dynamic Array for Non-Uniform Data - C#\nDESCRIPTION: This snippet creates a dynamic array containing objects with varying properties representing temperature sensor data. Some objects have a 'sensor' property, while others have a 'detector' property. The 'timestamp' and 'temperature' properties are common to all objects.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/scenarios/dynamic-data.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// Our documents with non-uniform structure\nvar records = new dynamic[]\n{\n    new {sensor = \"aisle-1\", timestamp = \"2020-01-21 11:19:19.283\", temperature = 21.2},\n    new {sensor = \"aisle-2\", timestamp = \"2020-01-21 11:18:19.220\", temperature = 21.6},\n    new {sensor = \"aisle-1\", timestamp = \"2020-01-21 11:17:19.190\", temperature = 21.6},\n    new {detector = \"aisle-1\", timestamp = \"2020-01-21 11:16:19.100\", temperature = 20.9},\n    new {sensor = \"aisle-3\", timestamp = \"2020-01-21 11:15:19.037\", temperature = 21.7,},\n    new {detector = \"aisle-1\", timestamp = \"2020-01-21 11:14:19.100\", temperature = -1.0}\n};\n```\n\n----------------------------------------\n\nTITLE: Overriding Database Schema Name (C#)\nDESCRIPTION: This snippet shows how to override the default database schema name in Marten.  It demonstrates setting the `StoreOptions.DatabaseSchemaName` to a custom value. This affects where the document tables and functions will be created in the PostgreSQL database. It is necessary to regenerate the Internal folder to apply the schema changes using `opts.GeneratedCodeMode = TypeLoadMode.Auto;`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/schema/index.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\nStoreOptions.DatabaseSchemaName = \"other\";\n```\n\n----------------------------------------\n\nTITLE: Applying Oakton Extensions to a WebApplication Builder - C#\nDESCRIPTION: This code snippet demonstrates how to integrate Oakton command-line extensions into a .NET application using the WebApplication builder. It adds Oakton functionality to the application's host, enabling command-line parsing and execution. This integration must occur before the `builder.Build()` call.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/cli.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvar builder = WebApplication.CreateBuilder(args);\n\n// Easiest to just do this right after creating builder\n// Must be done before calling builder.Build() at least\nbuilder.Host.ApplyOaktonExtensions();\n```\n\n----------------------------------------\n\nTITLE: Compiled Query with Include for Multiple Documents (Dictionary)\nDESCRIPTION: This snippet demonstrates how to use compiled queries with the `Include()` method to fetch multiple related `User` documents into a `Dictionary<Guid, User>`.  The `IssueWithUsersById` class implements `ICompiledListQuery<Issue>` and fetches related users based on the `AssigneeId` property of each `Issue` document.  The `UsersById` dictionary is populated with the retrieved users, keyed by their `Guid` Ids.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/compiled-queries.md#_snippet_11\n\nLANGUAGE: cs\nCODE:\n```\npublic class IssueWithUsersById: ICompiledListQuery<Issue>\n{\n    public IDictionary<Guid, User> UsersById { get; set; } = new Dictionary<Guid, User>();\n    // Can also work like that:\n    //public List<User> Users => new Dictionary<Guid,User>();\n\n    public Expression<Func<IMartenQueryable<Issue>, IEnumerable<Issue>>> QueryIs()\n    {\n        return query => query.Include(x => x.AssigneeId, UsersById);\n    }\n}\n\n[Fact]\npublic async Task compiled_include_to_dictionary()\n{\n    var user1 = new User();\n    var user2 = new User();\n\n    var issue1 = new Issue { AssigneeId = user1.Id, Title = \"Garage Door is busted\" };\n    var issue2 = new Issue { AssigneeId = user2.Id, Title = \"Garage Door is busted\" };\n    var issue3 = new Issue { AssigneeId = user2.Id, Title = \"Garage Door is busted\" };\n\n    using var session = theStore.IdentitySession();\n    session.Store(user1, user2);\n    session.Store(issue1, issue2, issue3);\n    await session.SaveChangesAsync();\n\n    using var querySession = theStore.QuerySession();\n    var compiledQuery = new IssueWithUsersById();\n\n    var issues = querySession.Query(compiledQuery).ToArray();\n\n    issues.ShouldNotBeEmpty();\n\n    compiledQuery.UsersById.Count.ShouldBe(2);\n    compiledQuery.UsersById.ContainsKey(user1.Id).ShouldBeTrue();\n    compiledQuery.UsersById.ContainsKey(user2.Id).ShouldBeTrue();\n}\n```\n\n----------------------------------------\n\nTITLE: Define Duplicated Field Unique Index (Single Property) via Attribute in Marten C#\nDESCRIPTION: This snippet showcases defining a unique index as a duplicated field on a single property using the `UniqueIndex` attribute in Marten. It applies the `[UniqueIndex]` attribute with `UniqueIndexType.DuplicatedField` to the `Name` property of the `Client` class. This enforces uniqueness for the `Name` property by creating a duplicated field in the database.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/indexing/unique.md#_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic class Client\n{\n    public Guid Id { get; set; }\n\n    [UniqueIndex(IndexType = UniqueIndexType.DuplicatedField)]\n    public string Name { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Sample Transformer Class for Projections in C#\nDESCRIPTION: This code illustrates a sample transformer class used in Marten projections. It defines methods for aggregating data, applying events to projected documents (both synchronous and immutable versions), and handling partial updates or deletions based on event data. It also supports dependency injection.\nSOURCE: https://github.com/jasperfx/marten/blob/master/planning/MartenV4.md#_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\n// This purposely does not implement any kind of interface\n// Defines how to apply changes to one kind of projected document\npublic class SampleTransformer\n{\n    \n\n    // Support constructor injection here for services from the container?\n    // Could also support method injection too, w/ maybe something like the ASP.net Core\n    // [FromServices] attribute on parameters???\n\n    // Marten should conform to the arguments of the method, so any combination of\n    // the actual event (either the specific type or a base type), the event wrapper\n    // with metadata, and the stream model. Plus the projected document where appropriate\n\n    // These may not be necessary, but if so, this is to \n    // get at what the identity of the aggregate document is\n    // Prefer the FI version of this though\n    public int AggregateBy(Event1 @event);\n    public int AggregateBy(EventWrapper @event);\n\n    // Sync version with raw event\n    public void Apply(Event1 @event, ProjectedDocument doc);\n\n    // Sync version with event wrapper, could be a custom implementation of IEvent\n    // to get at event metadata & stream metadata or partitioning information\n    public void Apply(EventWrapper<Event1> @event, MyEventStream stream, ProjectedDocument doc);\n\n    // Sync version w/ immutable projected docs\n    public ProjectedDocument Apply(Event1 @event, ProjectedDocument doc);\n\n    // apply a partial update to an aggregate document, but this wouldn't\n    // get used if there's some reason to fetch the whole aggregate for a segment\n    // of events. \n    public void Partial(Event1, @event, IDocumentSession session);\n\n    // Should the aggregate document be deleted based on some event data?\n    public bool ShouldBeDeleted(Event1 @event);\n    public bool ShouldBeDeleted(EventWrapper @event);\n    public bool ShouldBeDeleted(EventWrapper @event, MyEventStream stream);\n}\n```\n\n----------------------------------------\n\nTITLE: High Water Mark Log Message\nDESCRIPTION: Example message emitted to the log when High Water agent is stale.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/async-daemon.md#_snippet_12\n\nLANGUAGE: JavaScript\nCODE:\n```\n\"High Water agent is stale after threshold of {DelayInSeconds} seconds, skipping gap to events marked after {SafeHarborTime} for database {Name}\"\n```\n\n----------------------------------------\n\nTITLE: UsersByFirstName Compiled List Query Example C#\nDESCRIPTION: This code demonstrates a compiled query `UsersByFirstName` in C# that retrieves a list of user documents with a matching first name. It implements the `ICompiledListQuery` interface. The `QueryIs` method defines the Linq query used to filter the documents.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/compiled_queries.md#_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic class UsersByFirstName : ICompiledListQuery<User>\n{\n    public string FirstName { get; set; }\n\n    public Expression<Func<IQueryable<User>, IEnumerable<User>>> QueryIs()\n    {\n        return query => query.Where(x => x.FirstName == FirstName);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Writing Single Document with Compiled Query (Marten)\nDESCRIPTION: This C# code demonstrates how to write a single document to the HTTP context using a linq query. The JSON is written directly to the body without deserialization. Uses the `WriteSingle` extension method to write the document.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/aspnetcore.md#_snippet_7\n\nLANGUAGE: cs\nCODE:\n```\n[HttpGet(\"/issue3/{issueId}\")]\npublic Task Get3(Guid issueId, [FromServices] IQuerySession session, [FromQuery] string? sc = null)\n{\n    return sc is null\n        ? session.Query<Issue>().Where(x => x.Id == issueId)\n            .WriteSingle(HttpContext)\n        : session.Query<Issue>().Where(x => x.Id == issueId)\n            .WriteSingle(HttpContext, onFoundStatus: int.Parse(sc));\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Normal Level of Marten Connection Tracking\nDESCRIPTION: This snippet demonstrates how to enable connection tracking in Marten using the `TrackLevel.Normal` setting. It configures a `DocumentStore` with a connection string and sets the `TrackConnections` option to `Normal` within the `OpenTelemetry` configuration.  This enables the emission of Open Telemetry spans for Marten connections, named *marten.connection*, and tags exceptions from database command execution.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/otel.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nusing var store = DocumentStore.For(opts =>\n{\n    opts.Connection(\"some connection string\");\n\n    // Track Marten connection usage\n    opts.OpenTelemetry.TrackConnections = TrackLevel.Normal;\n});\n```\n\n----------------------------------------\n\nTITLE: Using Request Count (C#)\nDESCRIPTION: This snippet demonstrates how to access the request count for an `IDocumentSession`. The request count tells you how many commands have been issued to PostgreSQL by that session. This can be used to understand the chattiness of operations.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/diagnostics.md#_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nusing var store = DocumentStore.For(_ =>\n{\n    _.Connection(\"some connection string\");\n});\n\nusing var session = store.OpenSession();\n\n// do some stuff with the session\nsession.Load<Target>(Guid.NewGuid());\nsession.SaveChanges();\n\nConsole.WriteLine(\"Request Count: \" + session.RequestCount);\n```\n\n----------------------------------------\n\nTITLE: Simplified Integration Context with DocumentStore Extension\nDESCRIPTION: Simplifies access to the `IDocumentStore` by using the `DocumentStore` extension method on the `IHost`.  This provides a more concise way to obtain the document store instance. It depends on `IAlbaHost`, `IDocumentStore`, and `AppFixture`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/testing/integration.md#_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\npublic abstract class SimplifiedIntegrationContext : IAsyncLifetime\n{\n    protected SimplifiedIntegrationContext(AppFixture fixture)\n    {\n        Host = fixture.Host;\n        Store = Host.DocumentStore();\n    }\n\n    public IAlbaHost Host { get; }\n    public IDocumentStore Store { get; }\n\n    public async Task InitializeAsync()\n    {\n        // Using Marten, wipe out all data and reset the state\n        await Store.Advanced.ResetAllData();\n    }\n\n    // This is required because of the IAsyncLifetime\n    // interface. Note that I do *not* tear down database\n    // state after the test. That's purposeful\n    public Task DisposeAsync()\n    {\n        return Task.CompletedTask;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ICompiledQuery Interface - C#\nDESCRIPTION: This C# code defines the `ICompiledQuery<TDoc>` interface, which inherits from `ICompiledQuery<TDoc, TDoc>`. This interface serves as a convenience when querying for a single document without any transformations.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/compiled-queries.md#_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\npublic interface ICompiledQuery<TDoc>: ICompiledQuery<TDoc, TDoc>\n{\n}\n```\n\n----------------------------------------\n\nTITLE: Partitioning Operators in Marten Linq using C#\nDESCRIPTION: Demonstrates the usage of partitioning operators `Take()` and `Skip()` in Marten Linq queries. It uses `IDocumentSession` to query the `Target` document type, skipping the first 10 records and taking the next 10, then ordering the results by the `Number` property and converting them to an array.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/operators.md#_snippet_7\n\nLANGUAGE: cs\nCODE:\n```\npublic void using_take_and_skip(IDocumentSession session)\n{\n    // gets records 11-20 from the database\n    session.Query<Target>().Skip(10).Take(10).OrderBy(x => x.Number).ToArray();\n}\n```\n\n----------------------------------------\n\nTITLE: Scoping Session to Tenant for Reads in Marten\nDESCRIPTION: This snippet showcases how to load documents within the scope of a specific tenant. It assumes a session is already scoped to a specific tenant. The load operations will respect the tenancy of the session, ensuring that only documents associated with that tenant are retrieved. This is essential for maintaining data isolation and security in multi-tenant applications.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/tenancy/basicoperations.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:tenancy-scoping-session-read]>\n```\n\n----------------------------------------\n\nTITLE: Preventing Concurrency Conflicts with Marten in C#\nDESCRIPTION: This snippet demonstrates how to prevent concurrency conflicts when updating the `Invoice` aggregate. It utilizes the version attribute to ensure that the state of the object has not changed between replaying its state and introducing new deltas.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/scenarios/aggregates_events_repositories.md#_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:scenario-aggregate-conflict]>\n```\n\n----------------------------------------\n\nTITLE: Create Full Text Index for Single Property with Custom Settings (C#)\nDESCRIPTION: This code snippet demonstrates how to create a full text index for a single property with custom settings using the `[FullTextIndex]` attribute on a property. It indexes the 'FirstName' property and sets the language configuration to 'dutch'. Requires Marten and PostgreSQL version 10.0 or above.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/full_text.md#_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic class MyDocument\n{\n    public Guid Id { get; set; }\n\n    [FullTextIndex(RegConfig = \"dutch\")]\n    public string FirstName { get; set; }\n\n    public string LastName { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Inserting a Document Only if it Doesn't Exist (C#)\nDESCRIPTION: This code snippet shows how to use `IDocumentSession.Insert` to store a document only if it does not already exist. A `DocumentAlreadyExistsException` is thrown if the document already exists. This allows for controlled insertion behavior.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/basics/persisting.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nusing Marten;\nusing System;\nusing System.Threading.Tasks;\n\npublic class Question\n{\n    public Guid Id { get; set; }\n    public string Text { get; set; }\n}\n\npublic class SampleDocumentInsertonly\n{\n    public async Task Sample_Document_Insertonly(IDocumentStore store)\n    {\n        using (var session = store.OpenSession())\n        {\n            var question = new Question { Id = Guid.NewGuid(), Text = \"What is the meaning of life?\" };\n\n            try\n            {\n                session.Insert(question);\n                await session.SaveChangesAsync();\n            }\n            catch (DocumentAlreadyExistsException e)\n            {\n                Console.WriteLine(\"Document already exists: \" + e.Message);\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Order Aggregate for Command Handling\nDESCRIPTION: This snippet defines an `Order` aggregate class with properties like `Id`, `Version`, `Shipped`, and `Items`. It includes methods for applying events such as `OrderShipped` and `ItemReady`, and a method to check if the order is ready to ship (`IsReadyToShip`). The constructor takes an `OrderCreated` event to initialize the order's items.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/archiving.md#_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Item\n{\n    public string Name { get; set; }\n    public bool Ready { get; set; }\n}\n\npublic class Order\n{\n    // This would be the stream id\n    public Guid Id { get; set; }\n\n    // This is important, by Marten convention this would\n    // be the\n    public int Version { get; set; }\n\n    public Order(OrderCreated created)\n    {\n        foreach (var item in created.Items)\n        {\n            Items[item.Name] = item;\n        }\n    }\n\n    public void Apply(IEvent<OrderShipped> shipped) => Shipped = shipped.Timestamp;\n    public void Apply(ItemReady ready) => Items[ready.Name].Ready = true;\n\n    public DateTimeOffset? Shipped { get; private set; }\n\n    public Dictionary<string, Item> Items { get; set; } = new();\n\n    public bool IsReadyToShip()\n    {\n        return Shipped == null && Items.Values.All(x => x.Ready);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Compiled Query for Issue by ID (Marten)\nDESCRIPTION: This C# code defines a compiled query (`IssueById`) to retrieve a single `Issue` document by its ID. This compiled query implements `ICompiledQuery<Issue, Issue>`. The `Id` property is used as a parameter in the query. The query retrieves the first matching document or null if no document matches.  The property `Id` is used to filter the records\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/aspnetcore.md#_snippet_6\n\nLANGUAGE: cs\nCODE:\n```\npublic class IssueById: ICompiledQuery<Issue, Issue>\n{\n    public Expression<Func<IMartenQueryable<Issue>, Issue>> QueryIs()\n    {\n        return q => q.FirstOrDefault(x => x.Id == Id);\n    }\n\n    public Guid Id { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Store Document with Version - C#\nDESCRIPTION: This C# code snippet shows how to store a document with a specific version using the `IDocumentSession.Store(doc, version)` method. This allows explicitly specifying the expected version of the document being stored, which can be useful when handling external updates.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/advanced/optimistic_concurrency.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:store_with_the_right_version]>\n```\n\n----------------------------------------\n\nTITLE: Defining Wrapper Type with Dynamic Property\nDESCRIPTION: Defines a wrapper type with a 'dynamic' property to represent the non-uniform records.  This intermediate type allows for serialization and deserialization of the varying JSON structures within the Marten document store. The dynamic type enables flexible access to properties regardless of their specific structure.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/scenarios/dynamicdata.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:sample-scenarios-dynamic-type]>\n```\n\n----------------------------------------\n\nTITLE: Implementing Marten's IVersioned Interface (C#)\nDESCRIPTION: This code snippet demonstrates how to implement Marten's `IVersioned` interface for a document type, which automatically enables optimistic concurrency checking by mapping the current version to the `IVersioned.Version` property. The `MyVersionedDoc` class includes properties for `Id` and `Version`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/metadata.md#_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic class MyVersionedDoc: IVersioned\n{\n    public Guid Id { get; set; }\n    public Guid Version { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Foreign Key SQL Constraint\nDESCRIPTION: This SQL code demonstrates the foreign key constraint that Marten creates in the database based on the configuration provided in the C# code snippet.  It adds a foreign key constraint named `mt_doc_issue_assignee_id_fkey` on the `assignee_id` column of the `mt_doc_issue` table, referencing the `id` column of the `mt_doc_user` table. It also creates an index on the `assignee_id` column.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/indexing/foreign-keys.md#_snippet_2\n\nLANGUAGE: SQL\nCODE:\n```\nALTER TABLE public.mt_doc_issue\nADD CONSTRAINT mt_doc_issue_assignee_id_fkey FOREIGN KEY (assignee_id)\nREFERENCES public.mt_doc_user (id);\n\nCREATE INDEX mt_doc_issue_idx_assignee_id ON public.mt_doc_issue (\"assignee_id\");\n```\n\n----------------------------------------\n\nTITLE: Registering Marten Services in Lamar IoC Container\nDESCRIPTION: This code demonstrates how to register Marten's `IDocumentStore` and `IDocumentSession` services within the Lamar IoC container.  `IDocumentStore` is registered as a singleton and `IDocumentSession` is registered as one per transaction.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/getting_started.md#_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\n// Options +=> GettingStarted/MartenServices.cs\nusing Marten;\nusing Microsoft.Extensions.DependencyInjection;\n\npublic class MartenServices\n{\n    public void ConfigureContainer(IServiceCollection services)\n    {\n        services.AddMarten(options =>\n        {\n            // Establish the connection string to your Marten database\n            options.Connection(\"your_connection_string\");\n\n            // For development, let Marten just build the database schema\n            // automatically\n            options.AutoCreateSchemaObjects = AutoCreate.All;\n\n            // Opt into enabling possibly expensive but helpful auto-creates\n            options.Policies.ForbidDuplicateNames();\n\n            // If using other .Net Dependencies like ASP.Net Core or background workers\n            // you have to configure Npgsql to be thread safe.\n            // See https://github.com/JasperFx/marten/blob/master/src/Marten.AspNetCore/README.md\n            options.UseNpgsqlSafeThreadPool();\n\n\n            // All the other Marten configuration goes here\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Showing Daemon Diagnostics in Marten (C#)\nDESCRIPTION: This code snippet shows how to retrieve diagnostics information about the Marten asynchronous daemon, including projection progress, event store statistics, and the daemon's high water mark.  It requires an `IDocumentStore` instance. These diagnostics help monitor the state of asynchronous projections.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/appending.md#_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic static async Task ShowDaemonDiagnostics(IDocumentStore store)\n{\n    // This will tell you the current progress of each known projection shard\n    // according to the latest recorded mark in the database\n    var allProgress = await store.Advanced.AllProjectionProgress();\n    foreach (var state in allProgress)\n    {\n        Console.WriteLine($\"{state.ShardName} is at {state.Sequence}\");\n    }\n\n    // This will allow you to retrieve some basic statistics about the event store\n    var stats = await store.Advanced.FetchEventStoreStatistics();\n    Console.WriteLine($\"The event store highest sequence is {stats.EventSequenceNumber}\");\n\n    // This will let you fetch the current shard state of a single projection shard,\n    // but in this case we're looking for the daemon high water mark\n    var daemonHighWaterMark = await store.Advanced.ProjectionProgressFor(new ShardName(ShardState.HighWaterMark));\n    Console.WriteLine($\"The daemon high water sequence mark is {daemonHighWaterMark}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Hilo with Attribute - C#\nDESCRIPTION: This code snippet demonstrates how to override the Hilo configuration for a specific document type by decorating the document type with the `[HiloSequence]` attribute. This allows customization of the sequence increment and maximum lo at the document type level.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/identity/sequential.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:overriding-hilo-with-attribute]>\n```\n\n----------------------------------------\n\nTITLE: Query Handler Class Diagram\nDESCRIPTION: This Mermaid diagram illustrates the relationships between IQueryHandler, ListQueryHandler, OneResultHandler, ISelector, IMartenSession, Statement, and CommandBuilder, highlighting how they collaborate to handle database queries.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/diagrams/querying.md#_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\nclassDiagram\n\n\nclass IQueryHandler~T~ {\n    <<interface>> IQueryHandler~T~\n    ConfigureCommand(CommandBuilder, IMartenSession)\n    Handle(DbDataReader, IMartenSession) T\n    HandleAsync(DbDataReader, IMartenSession, CancellationToken) Task~T~\n}\n\nclass ListQueryHandler\nclass OneResultHandler\n\nListQueryHandler --> Statement: Uses\nListQueryHandler --> ISelector: Uses\n\nListQueryHandler ..|> IQueryHandler\nOneResultHandler ..|> IQueryHandler\n\nOneResultHandler --> Statement: Uses\nOneResultHandler --> ISelector\n\nclass ISelector~T~ {\n    <<interface>> ISelector\n    Resolve(DbDataReader) T\n    ResolveAsync(DbDataReader) Task~T~\n}\n\nISelector --> IMartenSession: Uses\nIQueryHandler --> IMartenSession: Uses\nStatement --> CommandBuilder: Configures\n\nclass CommandBuilder\n\n\nclass IMartenSession {\n    <<interface>> IMartenSession\n\n}\n\nclass Statement {\n    <<abstract>> Statement\n    Configure(CommandBuilder)\n}\n\n\n```\n\n----------------------------------------\n\nTITLE: Override Optimistic Concurrency - C#\nDESCRIPTION: This C# code snippet demonstrates how to override the store-wide optimistic concurrency setting within a specific session using `SessionOptions`. By setting `ConcurrencyChecks` to `ConcurrencyChecks.Disabled`, concurrency checks are disabled for that session.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/advanced/optimistic_concurrency.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:sample-override-optimistic-concurrency]>\n```\n\n----------------------------------------\n\nTITLE: Adding days to date in Postgres\nDESCRIPTION: This SQL snippet demonstrates how to add 5 days to the current timestamp in Postgres using interval arithmetic. The `now()` function returns the current timestamp.  The `+ '5 days'::interval` adds an interval of 5 days to the current timestamp. The `::interval` is a type cast that converts the string '5 days' to an interval type.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/postgres/dates.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\nSELECT now() + ‘5 days’::interval;\n```\n\n----------------------------------------\n\nTITLE: Querying Boolean Columns in PostgreSQL\nDESCRIPTION: This code demonstrates various ways to query a boolean column named `active` in a table named `users`. It includes examples of implicit checks, explicit comparisons to `true` and `false`, and using `is` and `is not` operators.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/postgres/types.md#_snippet_4\n\nLANGUAGE: sql\nCODE:\n```\nselect * from users where active;\n    select * from users where not active;\n\n    select * from users where active is true;\n    select * from users where active is false;\n\n    -- or\n\n    select * from users where active = true;\n    select * from users where active = false;;\n\n    -- or\n\n    select * from users where active is not true;\n    select * from users where active is not false;\n```\n\n----------------------------------------\n\nTITLE: Adding Marten Package via Powershell\nDESCRIPTION: This command adds the Marten NuGet package to your .NET project using the Powershell Package Manager. It allows you to manage project dependencies and integrate Marten into your .NET application.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/getting-started.md#_snippet_1\n\nLANGUAGE: powershell\nCODE:\n```\nPM> Install-Package Marten\n```\n\n----------------------------------------\n\nTITLE: Customizing Calculated Index to be Unique - C#\nDESCRIPTION: This code snippet demonstrates how to customize a computed index to enforce uniqueness. The `Index()` method takes a second Lambda `Action` to define the `IsUnique` property as `true`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/unique.md#_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:customizing-calculated-index]>\n```\n\n----------------------------------------\n\nTITLE: Batch Query with Compiled Queries (Async)\nDESCRIPTION: Demonstrates how to combine compiled queries with batch queries in Marten. It shows how to create a batch query, add compiled queries using the `IBatchedQuery.Query(ICompiledQuery)` method, and execute the batch asynchronously using `await batch.Execute()`.  The results of the compiled queries are then retrieved using `await` on the returned `Task` objects.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/batched-queries.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nvar batch = session.CreateBatchQuery();\n\nvar justin = batch.Query(new FindByFirstName { FirstName = \"Justin\" });\nvar tamba = batch.Query(new FindByFirstName { FirstName = \"Tamba\" });\n\nawait batch.Execute();\n\n(await justin).Id.ShouldBe(user1.Id);\n(await tamba).Id.ShouldBe(user2.Id);\n```\n\n----------------------------------------\n\nTITLE: Full Marten Dump PowerShell Command - PowerShell\nDESCRIPTION: This PowerShell command executes the `migrations.bat` script to perform a full dump of the Marten database schema, generating an SQL file containing the complete schema definition.  The resulting SQL file is placed in the migration scripts directory. Be sure to call the script from the project root directory.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/devops/devops.md#_snippet_6\n\nLANGUAGE: PowerShell\nCODE:\n```\n.\\migrations marten-dump -d Marten ..\\Migrations\\scripts\\up\\202312101536_marten_initial_database.sql\n```\n\n----------------------------------------\n\nTITLE: IEvent Interface (C#)\nDESCRIPTION: This snippet shows the `IEvent` interface in Marten, which provides access to event metadata such as ID, version, sequence, data, stream ID, stream key, timestamp, tenant ID, event type, causation ID, correlation ID, and headers. This allows accessing metadata associated with event data.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/metadata.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IEvent\n{\n    /// <summary>\n    ///     Unique identifier for the event. Uses a sequential Guid\n    /// </summary>\n    Guid Id { get; set; }\n\n    /// <summary>\n    ///     The version of the stream this event reflects. The place in the stream.\n    /// </summary>\n    long Version { get; set; }\n\n    /// <summary>\n    ///     The sequential order of this event in the entire event store\n    /// </summary>\n    long Sequence { get; set; }\n\n    /// <summary>\n    ///     The actual event data body\n    /// </summary>\n    object Data { get; }\n\n    /// <summary>\n    ///     If using Guid's for the stream identity, this will\n    ///     refer to the Stream's Id, otherwise it will always be Guid.Empty\n    /// </summary>\n    Guid StreamId { get; set; }\n\n    /// <summary>\n    ///     If using strings as the stream identifier, this will refer\n    ///     to the containing Stream's Id\n    /// </summary>\n    string? StreamKey { get; set; }\n\n    /// <summary>\n    ///     The UTC time that this event was originally captured\n    /// </summary>\n    DateTimeOffset Timestamp { get; set; }\n\n    /// <summary>\n    ///     If using multi-tenancy by tenant id\n    /// </summary>\n    string TenantId { get; set; }\n\n    /// <summary>\n    ///     The .Net type of the event body\n    /// </summary>\n    Type EventType { get; }\n\n    /// <summary>\n    ///     Marten's type alias string for the Event type\n    /// </summary>\n    string EventTypeName { get; set; }\n\n    /// <summary>\n    ///     Marten's string representation of the event type\n    ///     in assembly qualified name\n    /// </summary>\n    string DotNetTypeName { get; set; }\n\n    /// <summary>\n    ///     Optional metadata describing the causation id\n    /// </summary>\n    string? CausationId { get; set; }\n\n    /// <summary>\n    ///     Optional metadata describing the correlation id\n    /// </summary>\n    string? CorrelationId { get; set; }\n\n    /// <summary>\n    ///     Optional user defined metadata values. This may be null.\n    /// </summary>\n    Dictionary<string, object>? Headers { get; set; }\n\n    /// <summary>\n    ///     Has this event been archived and no longer applicable\n    ///     to projected views\n    /// </summary>\n    bool IsArchived { get; set; }\n\n    /// <summary>\n    ///     Marten's name for the aggregate type that will be persisted\n    ///     to the streams table. This will only be available when running\n    ///     within the Async Daemon\n    /// </summary>\n    public string? AggregateTypeName { get; set; }\n\n    /// <summary>\n    ///     Set an optional user defined metadata value by key\n    /// </summary>\n    /// <param name=\"key\"></param>\n    /// <param name=\"value\"></param>\n    void SetHeader(string key, object value);\n\n    /// <summary>\n    ///     Get an optional user defined metadata value by key\n    /// </summary>\n    /// <param name=\"key\"></param>\n    /// <returns></returns>\n    object? GetHeader(string key);\n}\n```\n\n----------------------------------------\n\nTITLE: Writing Generated Code with Marten CLI\nDESCRIPTION: This Bash command uses the Marten command-line interface (CLI) to generate and write the dynamic code to the project's `/Internal/Generated/` folder. This generated code covers document storage and event store support.  This step enables the optimized cold start functionality.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/prebuilding.md#_snippet_6\n\nLANGUAGE: Bash\nCODE:\n```\ndotnet run -- codegen write\n```\n\n----------------------------------------\n\nTITLE: Querying table definitions in PostgreSQL\nDESCRIPTION: This SQL query retrieves information about the columns of the 'product' table from the INFORMATION_SCHEMA.COLUMNS system view in PostgreSQL. It demonstrates how table and column names are stored in lowercase by default, even if they were initially created with Pascal case.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/postgres/naming.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\nselect *\nfrom INFORMATION_SCHEMA.COLUMNS\nwhere table_name = 'product';\n```\n\n----------------------------------------\n\nTITLE: Configuring Partitioning by Document Member - C#\nDESCRIPTION: This snippet demonstrates how to configure table partitioning based on a document member's value using the Marten API. It shows examples for range partitioning, externally managed partitioning, hash partitioning, and list partitioning.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/storage.md#_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nvar store = DocumentStore.For(opts =>\n{\n    opts.Connection(\"some connection string\");\n\n    // Set up table partitioning for the User document type\n    opts.Schema.For<User>()\n        .PartitionOn(x => x.Age, x =>\n        {\n            x.ByRange()\n                .AddRange(\"young\", 0, 20)\n                .AddRange(\"twenties\", 21, 29)\n                .AddRange(\"thirties\", 31, 39);\n        });\n\n    // Or use pg_partman to manage partitioning outside of Marten\n    opts.Schema.For<User>()\n        .PartitionOn(x => x.Age, x =>\n        {\n            x.ByExternallyManagedRangePartitions();\n\n            // or instead with list\n\n            x.ByExternallyManagedListPartitions();\n        });\n\n    // Or use PostgreSQL HASH partitioning and split the users over multiple tables\n    opts.Schema.For<User>()\n        .PartitionOn(x => x.UserName, x =>\n        {\n            x.ByHash(\"one\", \"two\", \"three\");\n        });\n\n    opts.Schema.For<Issue>()\n        .PartitionOn(x => x.Status, x =>\n        {\n            // There is a default partition for anything that doesn't fall into\n            // these specific values\n            x.ByList()\n                .AddPartition(\"completed\", \"Completed\")\n                .AddPartition(\"new\", \"New\");\n        });\n\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing a Document Policy (C#)\nDESCRIPTION: Shows the implementation of a custom document policy using the `IDocumentPolicy` interface. The policy checks if a document type implements `IRequireMultiTenancy` and configures it to be multi-tenanted if it does.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/document_policies.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n// SAMPLE: sample-policy-implementation\nusing Marten;\nusing Marten.Mapping;\n\npublic interface IRequireMultiTenancy\n{\n\n}\n\npublic class MultiTenancyPolicy : IDocumentPolicy\n{\n    public void Apply(DocumentMapping document, IReadOnlyStoreOptions options)\n    {\n        if (typeof(IRequireMultiTenancy).IsAssignableFrom(document.DocumentType))\n        {\n            document.TenancyStyle = TenancyStyle.Conjoined;\n        }\n    }\n}\n// ENDSAMPLE\n```\n\n----------------------------------------\n\nTITLE: Live Aggregation of Events with Marten in C#\nDESCRIPTION: This code snippet demonstrates how to fetch a stream of events and build an aggregate object live from the current event data using Marten. It showcases the use of `AggregateStreamAsync` to reconstruct the `QuestParty` aggregate from events associated with a specific stream ID. The code also shows how to query the aggregate at a specific version or timestamp.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/index.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nawait using var session2 = store.LightweightSession();\n// questId is the id of the stream\nvar party = await session2.Events.AggregateStreamAsync<QuestParty>(questId);\n\nvar party_at_version_3 = await session2.Events\n    .AggregateStreamAsync<QuestParty>(questId, 3);\n\nvar party_yesterday = await session2.Events\n    .AggregateStreamAsync<QuestParty>(questId, timestamp: DateTime.UtcNow.AddDays(-1));\n```\n\n----------------------------------------\n\nTITLE: Registering Document Session Listener Without Listeners.Add - C#\nDESCRIPTION: This snippet demonstrates how to create Marten `DocumentStore` without explicit adding of `IDocumentSessionListener`. It instantiates a listener and then a DocumentStore with the Marten `StoreOptions` configuration, but `Listeners` collection is not used here.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/diagnostics.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nvar stub1 = new StubDocumentSessionListener();\nvar stub2 = new StubDocumentSessionListener();\n\nusing (var store = SeparateStore(_ =>\n       {\n           _.Connection(ConnectionSource.ConnectionString);\n           _.AutoCreateSchemaObjects = AutoCreate.All;\n       }))\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom MartenAttribute - C#\nDESCRIPTION: This snippet demonstrates how to create a custom MartenAttribute subclass for customizing document storage at the document or member level. It provides virtual methods for modifying the DocumentMapping, handling member-specific modifications, and registering the attribute during automatic type discovery.  This extensibility enables developers to define custom behaviors through attributes.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/storeoptions.md#_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class MartenAttribute: Attribute\n{\n    /// <summary>\n    ///     Customize Document storage at the document level\n    /// </summary>\n    /// <param name=\"mapping\"></param>\n    public virtual void Modify(DocumentMapping mapping) { }\n\n    /// <summary>\n    ///     Customize the Document storage for a single member\n    /// </summary>\n    /// <param name=\"mapping\"></param>\n    /// <param name=\"member\"></param>\n    public virtual void Modify(DocumentMapping mapping, MemberInfo member) { }\n\n    /// <summary>\n    /// When used with the automatic type discovery (assembly scanning), this will be called\n    /// to make registrations to the Marten configuration with the type that this attribute\n    /// decorates\n    /// </summary>\n    /// <param name=\"discoveredType\"></param>\n    /// <param name=\"options\"></param>\n    public virtual void Register(Type discoveredType, StoreOptions options){}\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Issue Document\nDESCRIPTION: This C# code defines a sample `Issue` document with properties such as `Id`, `Title`, `Number`, `AssigneeId`, `ReporterId`, and `BugId`.  The `AssigneeId`, `ReporterId`, and `BugId` properties can be used to create foreign key relationships to other documents or tables. The `Issue` class has an empty constructor that initializes the `Id` property with a new Guid.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/indexing/foreign-keys.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic class Issue\n{\n    public Issue()\n    {\n        Id = Guid.NewGuid();\n    }\n\n    public string[] Tags { get; set; }\n\n    public Guid Id { get; set; }\n\n    public string Title { get; set; }\n\n    public int Number { get; set; }\n\n    public Guid? AssigneeId { get; set; }\n\n    public Guid? ReporterId { get; set; }\n\n    public Guid? BugId { get; set; }\n    public string Status { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Query by Two Named Parameters\nDESCRIPTION: Illustrates the use of named parameters in user supplied queries to avoid conflicts with Postgresql operators that include the '?' character. This enables more complex and readable queries. It requires Marten 1.2 or later.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/sql.md#_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nvar users = session.Query<User>(\"where data ->> 'FirstName' = :first and data ->> 'LastName' = :last\", new { first = \"Jeremy\", last = \"Miller\" }).ToList();\n```\n\n----------------------------------------\n\nTITLE: Rebuilding a Single Stream in Marten (C#)\nDESCRIPTION: This code snippet shows how to rebuild a single stream in Marten using `RebuildSingleStreamAsync`. It calls the method on `theStore.Advanced` providing the aggregate type `SimpleAggregate` and the stream id.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/rebuilding.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nawait theStore.Advanced.RebuildSingleStreamAsync<SimpleAggregate>(streamId);\n```\n\n----------------------------------------\n\nTITLE: New Event Type Name Example\nDESCRIPTION: This snippet illustrates an event type name change. It presents the new event `ConfirmedOrderStatusChanged`, which is intended to replace the old `OrderStatusChanged` event. A custom mapping is needed for Marten to handle the transition.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/events/versioning/index.md#_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ConfirmedOrderStatusChanged\n{\n    public Guid OrderId { get; set; }\n    public string Status { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: New Event Namespace Example\nDESCRIPTION: This snippet shows the event class after a namespace migration. The `OrderStatusChanged` event has been moved to a new namespace, which requires updating the event registration in Marten. The key aspect is the change in the namespace while the class name remains the same.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/events/versioning/index.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace MyApp.NewNamespace\n{\n    public class OrderStatusChanged\n    {\n        public Guid OrderId { get; set; }\n        public string Status { get; set; }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Docker Compose\nDESCRIPTION: This command starts the PostgreSQL database defined in the docker-compose.yml file in detached mode. It's used to set up the database before running integration tests.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/testing/integration.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndocker compose up -d\n```\n\n----------------------------------------\n\nTITLE: Configuring Event Append Mode in Marten (C#)\nDESCRIPTION: This snippet demonstrates how to configure the event append mode in Marten, choosing between 'Rich' and 'Quick' modes. The 'Rich' mode provides more metadata but may have performance implications, while the 'Quick' mode offers better performance at the cost of metadata availability in inline projections.  Requires `builder.Services.AddMarten()` and `.UseNpgsqlDataSource()`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/appending.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\nbuilder.Services.AddMarten(opts =>\n    {\n        // This is the default Marten behavior from 4.0 on\n        opts.Events.AppendMode = EventAppendMode.Rich;\n\n        // Lighter weight mode that should result in better\n        // performance, but with a loss of available metadata\n        // within inline projections\n        opts.Events.AppendMode = EventAppendMode.Quick;\n    })\n    .UseNpgsqlDataSource();\n```\n\n----------------------------------------\n\nTITLE: Custom Schema Sequence in Marten (C#)\nDESCRIPTION: This snippet demonstrates how to create a custom sequence using `Weasel.Postgresql.Sequence` and add it to Marten's extended schema objects. It creates a sequence named 'banana_seq' and applies the configuration changes to the database.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/schema/extensions.md#_snippet_4\n\nLANGUAGE: cs\nCODE:\n```\nStoreOptions(opts =>\n{\n    opts.RegisterDocumentType<Target>();\n\n    // Create a sequence to generate unique ids for documents\n    var sequence = new Sequence(\"banana_seq\");\n\n    opts.Storage.ExtendedSchemaObjects.Add(sequence);\n});\n\nawait theStore.Storage.ApplyAllConfiguredChangesToDatabaseAsync();\n```\n\n----------------------------------------\n\nTITLE: Bootstrapping a Document Store\nDESCRIPTION: This code shows how to create an `IDocumentStore` object with default behavior and a specified connection string. This is the entry point for interacting with Marten's document storage capabilities.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/getting_started.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\n// Options +=> GettingStarted/start_a_store.cs\nusing Marten;\n\npublic class start_a_store\n{\n    public void start_a_store_sample()\n    {\n        // Establish the connection to Postgresql\n        // with a connection string\n        using (var store = DocumentStore.For(\"host=localhost;database=marten;username=postgres;password=YOUR_PASSWORD\"))\n        {\n            // Nothing else is needed, go use the store!\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Wrapper Class with Dynamic Property - C#\nDESCRIPTION: This snippet defines a class `TemperatureData` with an `Id` property (integer) and a `Values` property of type `dynamic`. This class acts as a wrapper to hold the non-uniform data structures.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/scenarios/dynamic-data.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic class TemperatureData\n{\n    public int Id { get; set; }\n    public dynamic Values { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Cleaning Documents with Marten\nDESCRIPTION: This sample showcases the usage of `IDocumentStore.Advanced.Clean` to clean out documents in Marten.  It demonstrates how to use the document cleaner to remove persisted document state or completely tear down the document storage for automated testing purposes. The exact code sample is not provided, but the context indicates it utilizes the `IDocumentCleaner` service.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/advanced/cleaning.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:clean_out_documents]>\n```\n\n----------------------------------------\n\nTITLE: Async Event Upcaster with CLR Types in Marten\nDESCRIPTION: Illustrates implementing `AsyncOnlyEventUpcaster` for upcasting between CLR types. It transforms `ShoppingCartOpened` to `ShoppingCartOpenedWithStatus` using an injected `IClientRepository` to retrieve client information. The upcast method is asynchronous and takes a cancellation token.  The example warns about potential N+1 issues during deserialization if the `UpcastAsync` method performs resource-intensive operations.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/versioning.md#_snippet_32\n\nLANGUAGE: cs\nCODE:\n```\npublic class ShoppingCartOpenedAsyncOnlyUpcaster:\n    AsyncOnlyEventUpcaster<ShoppingCartOpened, ShoppingCartOpenedWithStatus>\n{\n    private readonly IClientRepository _clientRepository;\n\n    public ShoppingCartOpenedAsyncOnlyUpcaster(IClientRepository clientRepository) =>\n        _clientRepository = clientRepository;\n\n    protected override async Task<ShoppingCartOpenedWithStatus> UpcastAsync(\n        ShoppingCartOpened oldEvent,\n        CancellationToken ct\n    )\n    {\n        // WARNING: UpcastAsync method is called each time old event\n        // is read from database and deserialized.\n        // We discourage to run resource consuming methods here.\n        // It might end up with N+1 problem.\n        var clientName = await _clientRepository.GetClientName(oldEvent.ClientId, ct);\n\n        return new ShoppingCartOpenedWithStatus(\n            oldEvent.ShoppingCartId,\n            new Client(oldEvent.ClientId, clientName),\n            ShoppingCartStatus.Opened\n        );\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Structural Typing Classes in C#\nDESCRIPTION: This code snippet showcases two document types, `Area1.Product` and `Area2.Product`, where `Area2.Product` is a structural subset of `Area1.Product`. The `[StructuralTyped]` attribute is applied to `Area2.Product` to indicate to Marten that it should be mapped to the storage of `Area1.Product`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/advanced/structural_typing.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic class Area1\n{\n    public class Product\n    {\n        public Guid Id { get; set; }\n        public string Name { get; set; }\n        public string Description { get; set; }\n        public decimal Cost { get; set; }\n    }\n}\n\npublic class Area2\n{\n    [StructuralTyped]\n    public class Product\n    {\n        public Guid Id { get; set; }\n        public string Name { get; set; }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Aggregating Event Stream to Retrieve Invoice in C#\nDESCRIPTION: This code demonstrates how to use Marten's `AggregateStreamAsync` method to retrieve the current state of an Invoice entity by aggregating all events for a specific invoiceId. It depends on the Marten event store being configured and a session (`theSession`) being available to interact with the event store. It returns the Invoice object hydrated from the event stream.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/live-aggregates.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nvar invoice = await theSession.Events.AggregateStreamAsync<Invoice>(invoiceId);\n```\n\n----------------------------------------\n\nTITLE: Defining an Event with New Namespace C#\nDESCRIPTION: This code snippet defines a simple event class `OrderStatusChanged` within the `NewEventNamespace` after a namespace change. It includes properties for `OrderId` (Guid) and `Status` (int) and a corresponding constructor to initialize these properties. This shows the migrated event schema with an updated namespace.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/versioning.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nnamespace NewEventNamespace\n{\n    public class OrderStatusChanged\n    {\n        public Guid OrderId { get; }\n        public int Status { get; }\n\n        public OrderStatusChanged(Guid orderId, int status)\n        {\n            OrderId = orderId;\n            Status = status;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Writing Documents with Tenant Scoped Session in Marten (C#)\nDESCRIPTION: This code snippet demonstrates how to write User documents to a specific tenant using Marten's LightweightSession.  The session is scoped to the tenant \"tenant1\", and the Store method is used to persist the User objects.  The SaveChangesAsync method persists the changes to the database. Requires Marten document store instance.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/multi-tenancy.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n// Write some User documents to tenant \"tenant1\"\nusing (var session = theStore.LightweightSession(\"tenant1\"))\n{\n    session.Store(new User { Id = \"u1\", UserName = \"Bill\", Roles = new[] { \"admin\" } });\n    session.Store(new User { Id = \"u2\", UserName = \"Lindsey\", Roles = new string[0] });\n    await session.SaveChangesAsync();\n}\n```\n\n----------------------------------------\n\nTITLE: Query Subclass Hierarchy - C#\nDESCRIPTION: This snippet illustrates how to query the configured document type hierarchy. It shows how to query for all documents of a base type and retrieve instances of its subclasses as well. This is done using the session.Query method. Dependencies: Marten library.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/advanced/hierarchies.md#_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:query-subclass-hierarchy]>\n```\n\n----------------------------------------\n\nTITLE: Soft Delete with Index Attribute Configuration in Marten (C#)\nDESCRIPTION: This code snippet shows how to configure soft deletes with an index using the `SoftDeletedAttribute` with the `Indexed` property set to `true`.  This will create a partial index that only indexes documents when they are marked as deleted, optimizing queries that use `IsDeleted()`, `DeletedSince(DateTimeOffset)` and `DeletedBefore(DateTimeOffset)`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/indexing/metadata-indexes.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n[SoftDeleted(Indexed = true)]\npublic class IndexedSoftDeletedDoc\n{\n    public Guid Id;\n}\n```\n\n----------------------------------------\n\nTITLE: In (C#)\nDESCRIPTION: `In()` extension works exactly the same as `IsOneOf()`. It was introduced as syntactic sugar to ease RavenDB transition:\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/linq.md#_snippet_31\n\nLANGUAGE: C#\nCODE:\n```\nvar targets = session.Query<Target>().Where(x => x.Number.In(1, 2, 3)).ToList();\n```\n\n----------------------------------------\n\nTITLE: Implementing IMartenLogger Interface (C#)\nDESCRIPTION: This snippet shows the interface definition for `IMartenLogger`. This interface enables custom logging to be plugged into the `IDocumentStore`, `IQuerySession`, and `IDocumentSession` activity. It defines methods for obtaining loggers for different session types.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/diagnostics.md#_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IMartenLogger\n{\n    IQuerySessionLogger StartSession(IQuerySession session);\n    IDocumentSessionLogger StartSession(IDocumentSession session);\n}\n```\n\n----------------------------------------\n\nTITLE: Smurfs Hierarchy - C#\nDESCRIPTION: This snippet represents the hierarchy of Smurf document types. ISmurf is implemented by Smurf. Smurf has PapaSmurf and PapySmurf as subclasses that implement IPapaSmurf. PapaSmurf has BrainySmurf as its subclass. The snippet shows the relationship of the Smurf document types.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/advanced/hierarchies.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:smurfs-hierarchy]>\n```\n\n----------------------------------------\n\nTITLE: Defining an Inline SingleStreamProjection (Quest)\nDESCRIPTION: Defines a `Quest` record and a `QuestProjection` class, inheriting from `SingleStreamProjection<Quest>`. The `QuestProjection` class includes static methods for `Create` and `Apply` that handle events like `QuestStarted`, `MembersJoined`, `MembersDeparted`, `MembersEscaped`, and `QuestEnded` to update the state of the `Quest`. This projection persists the `Quest` state to the database as events are written.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/quickstart.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed record Quest(Guid Id, List<string> Members, List<string> Slayed, string Name, bool isFinished);\n\npublic sealed class QuestProjection: SingleStreamProjection<Quest>\n{\n    public static Quest Create(QuestStarted started) => new(started.QuestId, [], [], started.Name, false);\n    public static Quest Apply(MembersJoined joined, Quest party) =>\n        party with\n        {\n            Members = party.Members.Union(joined.Members).ToList()\n        };\n\n    public static Quest Apply(MembersDeparted departed, Quest party) =>\n        party with\n        {\n            Members = party.Members.Where(x => !departed.Members.Contains(x)).ToList()\n        };\n\n    public static Quest Apply(MembersEscaped escaped, Quest party) =>\n        party with\n        {\n            Members = party.Members.Where(x => !escaped.Members.Contains(x)).ToList()\n        };\n\n    public static Quest Apply(QuestEnded ended, Quest party) =>\n        party with { isFinished = true };\n\n}\n```\n\n----------------------------------------\n\nTITLE: Migrations Project Dockerfile - Dockerfile\nDESCRIPTION: This Dockerfile configures a Docker image for running database migrations using `grate`. It sets environment variables for the database connection string and version, creates directories for scripts and migration output, copies the SQL migration scripts into the container, sets up a non-root user, and defines the entry point to execute the `grate` command with specified parameters. The connection string and version are configured through environment variables at runtime.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/devops/devops.md#_snippet_2\n\nLANGUAGE: Dockerfile\nCODE:\n```\nFROM erikbra/grate:1.5.4 as migrations\n\n# Env Vars we need set at image runtime in order to control grate\nENV MIGRATIONS_CONNECTIONSTRING=\"\"\nENV VERSION=\"0.0.0.1\"\n\nWORKDIR /app\nRUN mkdir scripts\nRUN mkdir migration-output\nCOPY \"Migrations/scripts\" \"./scripts\"\n\nRUN addgroup -g 1001 -S nonroot && adduser -u 1001 -S nonroot -G nonroot\nRUN chown -R nonroot:nonroot /app\n\nUSER nonroot\n\nENTRYPOINT ./grate \\\n    --files=./scripts \\\n    --databasetype postgresql \\\n    --connectionstring=\"$MIGRATIONS_CONNECTIONSTRING\" \\\n    --version=$VERSION \\\n    --silent \\\n    --outputPath=./migration-output\n```\n\n----------------------------------------\n\nTITLE: Create Full Text Index for Whole Document via Attribute (C#)\nDESCRIPTION: This code snippet demonstrates how to create a full text index for the entire document by using the `[FullTextIndex]` attribute on the class definition. All properties of `MyDocument` are indexed. The index will be created with the default 'english' language configuration if no language is specified. Requires Marten and PostgreSQL version 10.0 or above.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/full_text.md#_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\n[FullTextIndex]\npublic class MyDocument\n{\n    public Guid Id { get; set; }\n    public string FirstName { get; set; }\n    public string LastName { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Querying with Full SQL Statement in Marten (C#)\nDESCRIPTION: This snippet illustrates querying Marten using a full SQL statement, including the `SELECT` clause.  It demonstrates how to retrieve a scalar value (in this case, an integer representing the count of documents) using `QueryAsync<int>()`. This is useful when invoking scalar functions or SQL transforms. The code assumes that the `session` variable is of type `IQuerySession`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/sql.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nvar sumResults = await session\n    .QueryAsync<int>(\"select count(*) from mt_doc_target\");\n```\n\n----------------------------------------\n\nTITLE: Renaming Property using Json.NET\nDESCRIPTION: This snippet shows how to rename a property (`CartId` instead of `ShoppingCartId`) using the `JsonProperty` attribute from Json.NET. This allows maintaining compatibility with older events while using the new property name in the code.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/versioning.md#_snippet_8\n\nLANGUAGE: cs\nCODE:\n```\npublic class ShoppingCartOpened\n{\n    [JsonProperty(\"ShoppingCartId\")]\n    public Guid CartId { get; }\n    public Guid ClientId { get; }\n\n    public ShoppingCartOpened(\n        Guid cartId,\n        Guid clientId\n    )\n    {\n        CartId = cartId;\n        ClientId = clientId;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Ordering with Dynamic Properties in Marten Linq using C#\nDESCRIPTION: Demonstrates how to order results using dynamic properties in Linq queries against a Marten database. Includes examples of `OrderBy()` and `OrderByDescending()` with property names as strings. It uses `IDocumentSession` to query the `Target` document type and applies dynamic ordering based on the provided property names, supporting both ascending and descending order.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/operators.md#_snippet_5\n\nLANGUAGE: cs\nCODE:\n```\npublic void order_by_dynamic_props(IDocumentSession session)\n{\n    // Sort in ascending order\n    session.Query<Target>().OrderBy(\"Date\");\n\n    // Sort in descending order\n    session.Query<Target>().OrderByDescending(\"Date\");\n\n    // You can use multiple order by's\n    session.Query<Target>().OrderBy(\"Date\").ThenBy(\"Number\");\n    session.Query<Target>().OrderByDescending(\"Date\").ThenBy(\"Number\");\n    session.Query<Target>().OrderBy(\"Date\").ThenByDescending(\"Number\");\n\n    // You can use pass props with sort order text\n    session.Query<Target>().OrderBy(\"Date ASC\");\n    session.Query<Target>().OrderBy(\"Date asc\");\n    session.Query<Target>().OrderBy(\"Number DESC\");\n    session.Query<Target>().OrderBy(\"Number desc\");\n\n    // You can use multiple order by props as params or list\n    session.Query<Target>().OrderBy(\"Date DESC\", \"Number\");\n}\n```\n\n----------------------------------------\n\nTITLE: Searching within Case Insensitive String Fields with Linq in Marten (C#)\nDESCRIPTION: Shows how to perform case-insensitive substring searches using `String.ToLower().Contains()`. This ensures that the search is not affected by the case of the characters in the string field. Needs a String property on the Target class\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/linq.md#_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic class Target\n{\n    public Guid Id { get; set; }\n    public string[] Tags { get; set; }\n    public Inner[] Children { get; set; }\n    public int? NullableNumber { get; set; }\n    public Outer Outer { get; set; }\n    public string String { get; set; }\n\n}\n\npublic class Inner\n{\n    public string Name { get; set; }\n    public int Age { get; set; }\n}\n\npublic class Outer\n{\n    public Middle Middle { get; set; }\n}\n\npublic class Middle\n{\n    public string Name { get; set; }\n}\n\n\nvar targets = session.Query<Target>()\n    .Where(x => x.String.ToLower().Contains(\"foo\")).ToList();\n```\n\n----------------------------------------\n\nTITLE: Configuring Mandatory Stream Type Declaration in Marten (C#)\nDESCRIPTION: This code snippet demonstrates how to configure Marten to enforce mandatory stream type declarations. This ensures that `StartStream` calls include the stream type and prevents appending events to non-existent streams. Requires the Marten library and configuration setup.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/appending.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\nbuilder.Services.AddMarten(opts =>\n{\n    opts.Connection(builder.Configuration.GetConnectionString(\"marten\"));\n\n    // Force users to supply a stream type on StartStream, and disallow\n    // appending events if the stream does not already exist\n    opts.Events.UseMandatoryStreamTypeDeclaration = true;\n});\n```\n\n----------------------------------------\n\nTITLE: Bootstrapping Separate Marten Store (C#, .NET)\nDESCRIPTION: Demonstrates how to bootstrap a separate Marten document store using `AddMartenStore<IInvoicingStore>`. This includes configuring the connection string, applying database schema changes on startup, adding an async daemon, initializing with data, and optimizing the artifact workflow for the separate store. It leverages the .NET `Host` builder for service configuration.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/hostbuilder.md#_snippet_24\n\nLANGUAGE: C#\nCODE:\n```\nusing var host = Host.CreateDefaultBuilder()\n    .ConfigureServices(services =>\n    {\n        // You can still use AddMarten() for the main document store\n        // of this application\n        services.AddMarten(\"some connection string\");\n\n        services.AddMartenStore<IInvoicingStore>(opts =>\n            {\n                // All the normal options are available here\n                opts.Connection(\"different connection string\");\n\n                // more configuration\n            })\n            // Optionally apply all database schema\n            // changes on startup\n            .ApplyAllDatabaseChangesOnStartup()\n\n            // Run the async daemon for this database\n            .AddAsyncDaemon(DaemonMode.HotCold)\n\n            // Use IInitialData\n            .InitializeWith(new DefaultDataSet())\n\n            // Use the V5 optimized artifact workflow\n            // with the separate store as well\n            .OptimizeArtifactWorkflow();\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Configuring Transaction Isolation Level (C#)\nDESCRIPTION: This code snippet shows how to configure the transaction isolation level when opening a new `IDocumentSession`.  It demonstrates setting the isolation level to `Serializable` for use cases like Saga pattern implementation in service bus architectures where message serialization needs to be ensured.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/basics/persisting.md#_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nusing Marten;\nusing System.Data;\nusing System.Threading.Tasks;\n\npublic class SerializableSagaTransaction\n{\n    public async Task Serializable_saga_transaction(IDocumentStore store)\n    {\n        using (var session = store.OpenSession(new SessionOptions { IsolationLevel = IsolationLevel.Serializable }))\n        {\n            // Load saga state, do some work,\n            // persist updated saga state\n            await session.SaveChangesAsync();\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting Database Matches Configuration - C#\nDESCRIPTION: This snippet demonstrates how to assert that a database schema matches the Marten configuration. The `AssertDatabaseMatchesConfigurationAsync` method checks for any differences between the configured schema and the actual database schema and throws an exception if discrepancies are found.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/schema/migrations.md#_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nawait store.Storage.Database.AssertDatabaseMatchesConfigurationAsync();\n```\n\n----------------------------------------\n\nTITLE: Query Against Number List with Count() Method (C#)\nDESCRIPTION: As of 1.2, you can also query against the `Count()` or `Length` of a child collection with the normal comparison operators (`==`, `>`, `>=`, etc.)\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/linq.md#_snippet_21\n\nLANGUAGE: C#\nCODE:\n```\npublic class Target\n{\n    public Guid Id { get; set; }\n    public string[] Tags { get; set; }\n    public List<string> ListTags {get; set;}\n    public List<int> Numbers { get; set; }\n\n}\n\nvar targets = session.Query<Target>().Where(x => x.Numbers.Count == 3).ToList();\n```\n\n----------------------------------------\n\nTITLE: Aggregating Events on the Fly\nDESCRIPTION: Demonstrates how to use Marten's `AggregateStreamAsync` method to aggregate events on the fly and retrieve the current state of a `QuestParty`.  It retrieves the `QuestParty` state at the latest version, at a specific version (3), and at a specific timestamp (yesterday).\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/quickstart.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nawait using var session2 = store.LightweightSession();\n// questId is the id of the stream\nvar party = await session2.Events.AggregateStreamAsync<QuestParty>(questId);\n\nvar party_at_version_3 = await session2.Events\n    .AggregateStreamAsync<QuestParty>(questId, 3);\n\nvar party_yesterday = await session2.Events\n    .AggregateStreamAsync<QuestParty>(questId, timestamp: DateTime.UtcNow.AddDays(-1));\n```\n\n----------------------------------------\n\nTITLE: Configuring DateTime Storage in Marten (C#)\nDESCRIPTION: This snippet shows how to configure Marten to store duplicated DateTime fields as `timestamp with time zone`. It overrides the default behavior.  It utilizes the `DuplicatedFieldUseTimestampWithoutTimeZoneForDateTime` property and sets it to `false`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/migration-guide.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nDuplicatedFieldUseTimestampWithoutTimeZoneForDateTime = false;\n```\n\n----------------------------------------\n\nTITLE: Cleaning Marten Data using IHost Extension\nDESCRIPTION: Demonstrates cleaning Marten data using the IHost extension method CleanAllMartenDataAsync(). This cleans all Marten data in the default DocumentStore for the host. Requires an IHost instance.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/schema/cleaning.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic async Task clean_out_documents(IHost host)\n{\n    // Clean off all Marten data in the default DocumentStore for this host\n    await host.CleanAllMartenDataAsync();\n}\n```\n\n----------------------------------------\n\nTITLE: Plugging in Custom IMartenLogger (C#)\nDESCRIPTION: This code demonstrates how to plug a custom `IMartenLogger` implementation into the `StoreOptions` object. This logger will be used as the default logger for all sessions created by the `DocumentStore`.  The connection string needs to be configured for the `DocumentStore` to function properly.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/diagnostics.md#_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n    _.Connection(\"some connection string\");\n    _.Logger(new MyMartenLogger());\n});\n```\n\n----------------------------------------\n\nTITLE: Using Custom Linq Parser with DocumentStore in C#\nDESCRIPTION: This C# code demonstrates how to configure a `DocumentStore` with a custom Linq parser. It showcases how to add an instance of a custom `IMethodCallParser` implementation (IsBlue) to the `MethodCallParsers` collection within the `StoreOptions` object. The sample also demonstrates how to query using the new custom linq extension.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/extending.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic async Task query_with_custom_parser()\n{\n    using var store = DocumentStore.For(opts =>\n    {\n        opts.Connection(ConnectionSource.ConnectionString);\n\n        // IsBlue is a custom parser I used for testing this\n        opts.Linq.MethodCallParsers.Add(new IsBlue());\n        opts.AutoCreateSchemaObjects = AutoCreate.All;\n\n        // This is just to isolate the test\n        opts.DatabaseSchemaName = \"isblue\";\n    });\n\n    await store.Advanced.Clean.CompletelyRemoveAllAsync();\n\n    var targets = new List<ColorTarget>();\n    for (var i = 0; i < 25; i++)\n    {\n        targets.Add(new ColorTarget {Color = \"Blue\"});\n        targets.Add(new ColorTarget {Color = \"Green\"});\n        targets.Add(new ColorTarget {Color = \"Red\"});\n    }\n\n    var count = targets.Count(x => x.Color.IsBlue());\n\n    targets.Each(x => x.Id = Guid.NewGuid());\n\n    await store.BulkInsertAsync(targets.ToArray());\n\n    using var session = store.QuerySession();\n    session.Query<ColorTarget>().Count(x => x.Color.IsBlue())\n        .ShouldBe(count);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an Event with New Type Name C#\nDESCRIPTION: This code snippet defines a simple event class `ConfirmedOrderStatusChanged` within the `NewEventNamespace` after a type name change. It includes properties for `OrderId` (Guid) and `Status` (int) and a corresponding constructor to initialize these properties. This shows the migrated event schema with an updated type name.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/versioning.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nnamespace NewEventNamespace\n{\n    public class ConfirmedOrderStatusChanged\n    {\n        public Guid OrderId { get; }\n        public int Status { get; }\n\n        public ConfirmedOrderStatusChanged(Guid orderId, int status)\n        {\n            OrderId = orderId;\n            Status = status;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Query Session (C#)\nDESCRIPTION: This snippet demonstrates how to create a new `IQuerySession` object from the `DocumentStore`. This session is used for querying or loading documents from the database.  It provides read-only access to the document data.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/index.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:start_a_query_session]>\n```\n\n----------------------------------------\n\nTITLE: Loading a Versioned Invoice from Marten in C#\nDESCRIPTION: This snippet shows how to load a specific version of the `Invoice` aggregate from the event stream. This demonstrates the ability to replay the state of the object at any point in its history.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/scenarios/aggregates_events_repositories.md#_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:scenario-aggregate-versionedload]>\n```\n\n----------------------------------------\n\nTITLE: Asserting Database (Legacy) - Bash\nDESCRIPTION: This bash command (for Marten < V5.0) demonstrates how to verify that the database schema matches the Marten configuration using the command line. The 'marten-assert' command throws an exception if discrepancies are found.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/schema/migrations.md#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\ndotnet run -- marten-assert\n```\n\n----------------------------------------\n\nTITLE: ConfigureMarten Method (Specific) - C#\nDESCRIPTION: Shows how a document type can configure its `DocumentMapping` using a `DocumentMapping<T>` parameter. This allows for more specific configuration, such as indexing or duplicating fields using .NET Expressions.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/index.md#_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic class MyOtherDocument\n{\n    public Guid Id { get; set; }\n    public string FirstName { get; set; }\n    public string LastName { get; set; }\n\n    public static void ConfigureMarten(DocumentMapping<MyOtherDocument> mapping)\n    {\n        mapping.Index(x => x.FirstName);\n        mapping.Duplicate(x => x.LastName);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Archived Events using Marten in C#\nDESCRIPTION: This snippet demonstrates how to query for archived events using Marten's LINQ support. It retrieves all raw events that are marked as archived using the `IsArchived` property.  Requires an active `IDocumentSession`. The result is a list of archived events.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/archiving.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar events = await theSession.Events\n    .QueryAllRawEvents()\n    .Where(x => x.IsArchived)\n    .ToListAsync();\n```\n\n----------------------------------------\n\nTITLE: GitHub Actions Workflow Trigger - YAML\nDESCRIPTION: This YAML snippet configures the trigger for a GitHub Actions workflow. It specifies that the workflow should be triggered on pull requests to the `main` branch and also allows for manual triggering via `workflow_dispatch`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/devops/devops.md#_snippet_8\n\nLANGUAGE: YAML\nCODE:\n```\non: \n  pull_request:\n    branches:\n      - main\n  workflow_dispatch:\n```\n\n----------------------------------------\n\nTITLE: Overriding RaiseSideEffects in TripProjection - C#\nDESCRIPTION: This code demonstrates how to override the `RaiseSideEffects()` method within a Marten `SingleStreamProjection` to perform side effects during continuous asynchronous projection execution. The method allows emitting new events, publishing messages, and interacting with the `IDocumentOperations` to store additional documents. The example uses the current state of the `Trip` aggregate to decide whether to append new events, publish messages, and store a `CompletelyDifferentDocument` based on the `TotalMiles` property. The emitted events are not immediately applied to the current projected document and must be handled separately.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/aggregate-projections.md#_snippet_17\n\nLANGUAGE: cs\nCODE:\n```\npublic class TripProjection: SingleStreamProjection<Trip>\n{\n    // Access event metadata through IEvent<T>\n    public Trip Create(IEvent<TripStarted> @event)\n    {\n        var trip = new Trip\n        {\n            Id = @event.StreamId, // Marten does this for you anyway\n            Started = @event.Timestamp,\n            CorrelationId = @event.Timestamp, // Open telemetry type tracing\n            Description = @event.Data.Description // Still access to the event body\n        };\n\n        // Use a custom header\n        if (@event.Headers.TryGetValue(\"customer\", out var customerId))\n        {\n            trip.CustomerId = (string)customerId;\n        }\n\n        return trip;\n    }\n\n    public void Apply(TripEnded ended, Trip trip, IEvent @event)\n    {\n        trip.Ended = @event.Timestamp;\n    }\n\n    // Other Apply/ShouldDelete methods\n\n    public override ValueTask RaiseSideEffects(IDocumentOperations operations, IEventSlice<Trip> slice)\n    {\n        // Emit other events or messages during asynchronous projection\n        // processing\n\n        // Access to the current state as of the projection\n        // event page being processed *right* now\n        var currentTrip = slice.Aggregate;\n\n        if (currentTrip.TotalMiles > 1000)\n        {\n            // Append a new event to this stream\n            slice.AppendEvent(new PassedThousandMiles());\n\n            // Append a new event to a different event stream by\n            // first specifying a different stream id\n            slice.AppendEvent(currentTrip.InsuranceCompanyId, new IncrementThousandMileTrips());\n\n            // \"Publish\" outgoing messages when the event page is successfully committed\n            slice.PublishMessage(new SendCongratulationsOnLongTrip(currentTrip.Id));\n\n            // And yep, you can make additional changes to Marten\n            operations.Store(new CompletelyDifferentDocument\n            {\n                Name = \"New Trip Segment\",\n                OriginalTripId = currentTrip.Id\n            });\n        }\n\n        // This usage has to be async in case you're\n        // doing any additional data access with the\n        // Marten operations\n        return new ValueTask();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Statement SQL Writing Sequence Diagram\nDESCRIPTION: This Mermaid sequence diagram shows the process of writing SQL for a typical Linq query statement. It highlights the interactions between IQueryHandler, Statement, ISelectClause, and ISqlFragment, demonstrating how the SQL command is built.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/diagrams/querying.md#_snippet_4\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\nnote left of Statement: This flow is for typical Linq query statements\nIQueryHandler ->> Statement: Configure(CommandBuilder)\nStatement ->> ISelectClause: WriteSelectClause(CommandBuilder)\nnote right of Statement: for any WHERE clause\n\nStatement ->> ISqlFragment: Apply(CommandBuilder)\nStatement ->> Statement: writeOrderClause(CommandBuilder)\nnote right of Statement: Also writes out any non zero Limit or Offset clauses to the CommandBuilder\n\nalt if there is a next statement\n    Statement --> Statement: Configure(CommandBuilder)\nend\n\n```\n\n----------------------------------------\n\nTITLE: Defining AggregateBase for Event Capture (C#)\nDESCRIPTION: This abstract class serves as the base for aggregates, providing infrastructure to capture state modifications as events. It includes properties for the aggregate ID, version, and a list of uncommitted events. Methods are provided to add uncommitted events, clear them, and retrieve them.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/scenarios/aggregates-events-repositories.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\n// Infrastructure to capture modifications to state in events\npublic abstract class AggregateBase\n{\n    // For indexing our event streams\n    public string Id { get; protected set; }\n\n    // For protecting the state, i.e. conflict prevention\n    // The setter is only public for setting up test conditions\n    public long Version { get; set; }\n\n    // JsonIgnore - for making sure that it won't be stored in inline projection\n    [JsonIgnore] private readonly List<object> _uncommittedEvents = new List<object>();\n\n    // Get the deltas, i.e. events that make up the state, not yet persisted\n    public IEnumerable<object> GetUncommittedEvents()\n    {\n        return _uncommittedEvents;\n    }\n\n    // Mark the deltas as persisted.\n    public void ClearUncommittedEvents()\n    {\n        _uncommittedEvents.Clear();\n    }\n\n    protected void AddUncommittedEvent(object @event)\n    {\n        // add the event to the uncommitted list\n        _uncommittedEvents.Add(@event);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Marten with StoreOptions - C#\nDESCRIPTION: This snippet shows how to add Marten to an `IServiceCollection` by passing a pre-configured `StoreOptions` object. This is useful for complex configurations and keeps the `Startup` class cleaner. Requires a `StoreOptions` object to be created and configured.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/integration.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:AddMartenByStoreOptions]>\n```\n\n----------------------------------------\n\nTITLE: Upcasting Event with CLR Types\nDESCRIPTION: This snippet demonstrates how to upcast an event using a lambda expression and CLR types. It transforms a `ShoppingCartOpened` event into a `ShoppingCartOpenedWithStatus` event by mapping the properties and setting the status. This approach uses the default event type name based on the old CLR type.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/versioning.md#_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\noptions.Events\n    .Upcast<ShoppingCartOpened, ShoppingCartOpenedWithStatus>(\n        oldEvent =>\n            new ShoppingCartOpenedWithStatus(\n                oldEvent.ShoppingCartId,\n                new Client(oldEvent.ClientId),\n                ShoppingCartStatus.Opened\n            )\n    );\n```\n\n----------------------------------------\n\nTITLE: PL/pgSQL Anonymous Block with Language Specification\nDESCRIPTION: This snippet shows an example of a PL/pgSQL block with explicit language specification.  The `LANGUAGE plpgsql` clause explicitly declares that the code within the `BEGIN` and `END` block should be interpreted using the PL/pgSQL language.  This ensures the correct execution of procedural SQL code.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/postgres/if-statements.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\nDO %%\nBEGIN\n\n    // your sql here…\n\nEND\n%% LANGUAGE plpgsql;\n```\n\n----------------------------------------\n\nTITLE: Distinct Strings Query with Marten (C#)\nDESCRIPTION: This code snippet demonstrates how to use the `Distinct()` operator in a Marten Linq query to retrieve distinct string values from the `Target` document. It stores several `Target` objects with duplicate string values, then queries for the distinct strings and asserts that the count of distinct strings is as expected.  It depends on xUnit for testing and Shouldly for assertions.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/operators.md#_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic async Task get_distinct_string()\n{\n    theSession.Store(new Target {String = \"one\"});\n    theSession.Store(new Target {String = \"one\"});\n    theSession.Store(new Target {String = \"two\"});\n    theSession.Store(new Target {String = \"two\"});\n    theSession.Store(new Target {String = \"three\"});\n    theSession.Store(new Target {String = \"three\"});\n\n    await theSession.SaveChangesAsync();\n\n    var queryable = theSession.Query<Target>().Select(x => x.String).Distinct();\n\n    queryable.ToList().Count.ShouldBe(3);\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Soft Deleted Documents\nDESCRIPTION: This C# code snippet demonstrates how Marten automatically filters out soft-deleted documents from Linq queries. It creates and stores user documents, soft-deletes some of them, and then queries the remaining active documents.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/deletes.md#_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic async Task query_soft_deleted_docs()\n{\n    var user1 = new User { UserName = \"foo\" };\n    var user2 = new User { UserName = \"bar\" };\n    var user3 = new User { UserName = \"baz\" };\n    var user4 = new User { UserName = \"jack\" };\n\n    using var session = theStore.LightweightSession();\n    session.Store(user1, user2, user3, user4);\n    await session.SaveChangesAsync();\n\n    // Deleting 'bar' and 'baz'\n    session.DeleteWhere<User>(x => x.UserName.StartsWith(\"b\"));\n    await session.SaveChangesAsync();\n\n    // no where clause, deleted docs should be filtered out\n    session.Query<User>().OrderBy(x => x.UserName).Select(x => x.UserName)\n        .ToList().ShouldHaveTheSameElementsAs(\"foo\", \"jack\");\n\n    // with a where clause\n    session.Query<User>().Where(x => x.UserName != \"jack\")\n        .ToList().Single().UserName.ShouldBe(\"foo\");\n}\n```\n\n----------------------------------------\n\nTITLE: Using statement for Json.NET upcasting\nDESCRIPTION: Shows the using statement required to utilize Json.NET based upcasting functionality in Marten.  This imports the necessary namespaces for working with Json.NET transformations.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/versioning.md#_snippet_35\n\nLANGUAGE: cs\nCODE:\n```\nusing Marten.Services.Json.Transformations.JsonNet;\n```\n\n----------------------------------------\n\nTITLE: Issue Class Definition with User References - C#\nDESCRIPTION: Defines an Issue class with properties for assignee and reporter user IDs, demonstrating the structure for establishing foreign key relationships with User documents. This example shows the properties that will be linked to other documents.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/foreign_keys.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:Issue]>\n```\n\n----------------------------------------\n\nTITLE: Deleting Generated Code with Marten CLI\nDESCRIPTION: This Bash command uses the Marten command-line interface (CLI) to delete the previously generated code from the project.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/prebuilding.md#_snippet_7\n\nLANGUAGE: Bash\nCODE:\n```\ndotnet run -- codegen delete\n```\n\n----------------------------------------\n\nTITLE: Building Application Docker Image with GitHub Actions\nDESCRIPTION: This step builds a Docker image for the application using the Dockerfile located in the ./Application/ directory. The image is tagged with the Git SHA.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/devops/devops.md#_snippet_12\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Build Application Docker Image\n  run: docker build -t myapp/application:${{ github.sha }} -f ./Application/Dockerfile .\n```\n\n----------------------------------------\n\nTITLE: AsJson with Anonymous Select Marten C#\nDESCRIPTION: This code snippet demonstrates combining `AsJson()` with a `Select()` transform to an anonymous type in a Marten query. It queries for `User` documents, orders them by `FirstName`, transforms the `User` class to an anonymous type with a `Name` property using `Select`, and then retrieves the JSON representation of the transformed result using `ToJsonFirstOrDefault()`. It showcases how to retrieve JSON for an anonymous type transformation.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/query-json.md#_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\n(await theSession\n        .Query<User>()\n        .OrderBy(x => x.FirstName)\n\n        // Transform to an anonymous type\n        .Select(x => new {Name = x.FirstName})\n\n        // Select only the raw JSON\n        .ToJsonFirstOrDefault())\n    .ShouldBe(\"{{\\\"Name\\\": \\\"Bill\\\"}}\");\n```\n\n----------------------------------------\n\nTITLE: Using QueryStatistics with Compiled Queries - C#\nDESCRIPTION: This C# code demonstrates how to use `QueryStatistics` with compiled queries in Marten to get the total number of rows matching a query. The `TargetsInOrder` class implements `ICompiledListQuery<Target>` and exposes a public `QueryStatistics` property. The query orders targets by `Id`, skips a certain number of records, and takes a specified page size.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/compiled-queries.md#_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\npublic class TargetsInOrder: ICompiledListQuery<Target>\n{\n    // This is all you need to do\n    public QueryStatistics Statistics { get; } = new QueryStatistics();\n\n    public int PageSize { get; set; } = 20;\n    public int Start { get; set; } = 5;\n\n    Expression<Func<IMartenQueryable<Target>, IEnumerable<Target>>> ICompiledQuery<Target, IEnumerable<Target>>.\n        QueryIs()\n    {\n        return q => q\n            .OrderBy(x => x.Id).Skip(Start).Take(PageSize);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Remove Primitive Element from Collection in Marten (C#)\nDESCRIPTION: Demonstrates removing a primitive element from a child collection using `Patch.Remove()`. The example generates a target object with a number array, selects a random number from the array, and then removes it using the patching API. The result is verified by loading the modified document. Dependencies: Marten, Xunit, Shouldly.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/partial-updates-patching.md#_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic async Task remove_primitive_element()\n{\n    var random = new Random();\n    var target = Target.Random();\n    target.NumberArray = new[] { random.Next(0, 10), random.Next(0, 10), random.Next(0, 10) };\n    target.NumberArray = target.NumberArray.Distinct().ToArray();\n\n    var initialCount = target.NumberArray.Length;\n\n    var child = target.NumberArray[random.Next(0, initialCount)];\n\n    theSession.Store(target);\n    await theSession.SaveChangesAsync();\n\n    theSession.Patch<Target>(target.Id).Remove(x => x.NumberArray, child);\n    await theSession.SaveChangesAsync();\n\n    using (var query = theStore.QuerySession())\n    {\n        var target2 = query.Load<Target>(target.Id);\n        target2.NumberArray.Length.ShouldBe(initialCount - 1);\n\n        target2.NumberArray.ShouldHaveTheSameElementsAs(target.NumberArray.ExceptFirst(child));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Async Snapshot for Invoice (C#)\nDESCRIPTION: Configures Marten to use an asynchronous snapshot lifecycle for the `Invoice` aggregate. This allows for asynchronous projection updates, which can be useful for blue/green deployments.  It uses `opts.Projections.Snapshot<Projections.Invoice>(SnapshotLifecycle.Async)` to set the snapshot lifecycle to async and `AddAsyncDaemon(DaemonMode.HotCold)` to enable asynchronous projection updates.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/read-aggregates.md#_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\nbuilder.Services.AddMarten(opts =>\n    {\n        opts.Connection(builder.Configuration.GetConnectionString(\"marten\"));\n\n        opts.Projections.Snapshot<Projections.Invoice>(SnapshotLifecycle.Async);\n    })\n    .AddAsyncDaemon(DaemonMode.HotCold);\n```\n\n----------------------------------------\n\nTITLE: Disabling Npgsql Logging in Marten - C#\nDESCRIPTION: This code snippet demonstrates how to disable the default Npgsql logging within Marten to reduce verbosity and storage costs. It configures the Marten options within the ConfigureServices method of an IHostBuilder, setting the DisableNpgsqlLogging property to true.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/diagnostics.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvar builder = Host.CreateDefaultBuilder();\nbuilder.ConfigureServices(services =>\n{\n    services.AddMarten(opts =>\n    {\n        opts.Connection(ConnectionSource.ConnectionString);\n\n        // Disable the absurdly verbose Npgsql logging\n        opts.DisableNpgsqlLogging = true;\n\n        opts.Events.AppendMode = EventAppendMode.Quick;\n        opts.Events.UseIdentityMapForAggregates = true;\n\n        opts.Projections.Add<DaemonTests.TestingSupport.TripProjection>(ProjectionLifecycle.Inline);\n    });\n});\n```\n\n----------------------------------------\n\nTITLE: Batch Query with Compiled Queries Example C#\nDESCRIPTION: This code demonstrates how to use a compiled query within a batched query.  It shows how to enqueue a compiled query to be executed as part of a batch operation, improving efficiency by grouping multiple operations into a single database round trip.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/compiled_queries.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nvar batch = session.CreateBatchQuery();\n\nvar task = batch.Query(new FindByFirstName { FirstName = \"Jeremy\" });\n\nawait batch.Execute();\n\nvar user = await task;\n```\n\n----------------------------------------\n\nTITLE: Setting Application Project for Marten (C#)\nDESCRIPTION: This snippet demonstrates how to explicitly set the application project assembly for Marten. This is useful in test harnesses or serverless environments where Marten might not be able to automatically determine the application assembly. It uses the `SetApplicationProject` extension method to specify the assembly that contains the `User` type.  It uses the `Microsoft.Extensions.Hosting` package for the host setup and depends on the `AddMarten` extension to configure the Marten document store.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/prebuilding.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nusing var host = Host.CreateDefaultBuilder()\n    .ConfigureServices(services =>\n    {\n        services.AddMarten(opts =>\n        {\n            opts.Connection(\"some connection string\");\n            opts.SetApplicationProject(typeof(User).Assembly);\n        });\n    })\n    .StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Define Duplicated Field Unique Index (Multiple Properties) via Store Options in Marten C#\nDESCRIPTION: This code snippet demonstrates creating a unique index on multiple properties as duplicated fields using Marten's `StoreOptions`. It enforces uniqueness based on `FirstName` and `FullName` properties of the `User` document. The snippet configures a connection and database schema.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/indexing/unique.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n    _.Connection(ConnectionSource.ConnectionString);\n    _.DatabaseSchemaName = \"unique_text\";\n\n    // This creates\n    _.Schema.For<User>().UniqueIndex(UniqueIndexType.DuplicatedField, x => x.FirstName, x => x.FullName);\n});\n```\n\n----------------------------------------\n\nTITLE: Querying with IsOneOf() in Marten (C#)\nDESCRIPTION: Demonstrates using the `IsOneOf()` extension method to query for documents where a field or property matches one of many supplied values.  The example shows how to query for users whose role is one of a specified list of roles.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/child-collections.md#_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\n// Finds all SuperUser's whose role is either\n// Admin, Supervisor, or Director\nvar users = session.Query<SuperUser>()\n    .Where(x => x.Role.IsOneOf(\"Admin\", \"Supervisor\", \"Director\"));\n```\n\n----------------------------------------\n\nTITLE: Defining Optimistic and Pessimistic Document Models in C#\nDESCRIPTION: This code snippet demonstrates how to define document models in C# using both optimistic and pessimistic approaches for handling nullable reference types when dealing with data retrieved from a database. The optimistic model assumes non-nullable properties, while the pessimistic model uses nullable properties. The user would need the C# language, and access to the Guid struct. The code returns classes for storing data.\nSOURCE: https://github.com/jasperfx/marten/blob/master/planning/MartenV4-WastazComments.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic class NutrientInfo { /* class omitted for brevity */ }\n\n// Optimistic\npublic class FruitDocument {\n  public Guid Id { get; set; }\n  public string Name { get; set; }\n  public int Ranking { get; set; }\n  public NutrientInfo { get; set; }\n}\n\n// Pessimistic\npublic class FruitDocument {\n  public Guid Id { get; set; }\n  public string? Name { get; set; }\n  public int Ranking { get; set; }\n  public NutrientInfo? { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting AutoCreateSchemaObjects to AutoCreate.All in Marten\nDESCRIPTION: This code snippet shows how to configure Marten to fully rebuild the database schema, allowing Marten to drop and recreate tables. This setting is useful during development when schema changes are frequent and data loss is acceptable. Setting `AutoCreateSchemaObjects` to `AutoCreate.All` allows Marten to automatically create, update, or drop schema objects based on the document store configuration.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/migration_guide.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nAutoCreateSchemaObjects = AutoCreate.All\n```\n\n----------------------------------------\n\nTITLE: Correlated Marten Logger Example - C#\nDESCRIPTION: Illustrates a custom Marten session logger that adds a correlation identifier to log output. This enhances log traceability by associating database operations with specific requests or messages. Requires a correlation ID and implementation for logging.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/integration.md#_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:CorrelatedMartenLogger]>\n```\n\n----------------------------------------\n\nTITLE: Configuring Initial Data for Marten\nDESCRIPTION: This code snippet demonstrates how to configure initial data for a Marten document store using .NET's `IHost`. It shows how to add implementations of the `IInitialData` interface during the configuration of the document store, ensuring they are executed upon initialization. It relies on `Microsoft.Extensions.Hosting` and `Microsoft.Extensions.DependencyInjection`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/initial-data.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .ConfigureServices(services =>\n    {\n        services.AddMarten(opts =>\n            {\n                opts.DatabaseSchemaName = \"Bug962\";\n\n                opts.Connection(ConnectionSource.ConnectionString);\n            })\n            // Add as many implementations of IInitialData as you need\n            .InitializeWith(new InitialData(InitialDatasets.Companies), new InitialData(InitialDatasets.Users));\n    }).StartAsync();\n\nvar store = host.Services.GetRequiredService<IDocumentStore>();\n```\n\n----------------------------------------\n\nTITLE: Querying Soft Deleted Since Documents in Marten\nDESCRIPTION: This code snippet demonstrates how to query for documents that have been soft deleted since a specific time using Marten's `DeletedSince()` method. It initializes users, deletes users, and then queries for users deleted since a particular time.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/deletes.md#_snippet_14\n\nLANGUAGE: cs\nCODE:\n```\n[Fact]\npublic async Task query_is_soft_deleted_since_docs()\n{\n    var user1 = new User { UserName = \"foo\" };\n    var user2 = new User { UserName = \"bar\" };\n    var user3 = new User { UserName = \"baz\" };\n    var user4 = new User { UserName = \"jack\" };\n\n    using var session = theStore.LightweightSession();\n    session.Store(user1, user2, user3, user4);\n    await session.SaveChangesAsync();\n\n    session.Delete(user3);\n    await session.SaveChangesAsync();\n\n    var epoch = session.MetadataFor(user3).DeletedAt;\n    session.Delete(user4);\n    await session.SaveChangesAsync();\n\n    session.Query<User>().Where(x => x.DeletedSince(epoch.Value)).Select(x => x.UserName)\n        .ToList().ShouldHaveTheSameElementsAs(\"jack\");\n}\n```\n\nLANGUAGE: cs\nCODE:\n```\n[Fact]\npublic async Task query_is_soft_deleted_since_docs()\n{\n    var user1 = new User { UserName = \"foo\" };\n    var user2 = new User { UserName = \"bar\" };\n    var user3 = new User { UserName = \"baz\" };\n    var user4 = new User { UserName = \"jack\" };\n\n    using var session = theStore.LightweightSession();\n    session.Store(user1, user2, user3, user4);\n    await session.SaveChangesAsync();\n\n    session.Delete(user3);\n    await session.SaveChangesAsync();\n\n    var epoch = session.MetadataFor(user3).DeletedAt;\n    session.Delete(user4);\n    await session.SaveChangesAsync();\n\n    session.Query<User>().Where(x => x.DeletedSince(epoch.Value)).Select(x => x.UserName)\n        .ToList().ShouldHaveTheSameElementsAs(\"jack\");\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Marten Schema Name\nDESCRIPTION: Configures the MartenSettings within the Alba host to use the generated schema name. This is done through the ConfigureServices method, where MartenSettings are configured with the SchemaName. Requires the AlbaHost and MartenSettings classes.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/testing/integration.md#_snippet_10\n\nLANGUAGE: cs\nCODE:\n```\nHost = await AlbaHost.For<Program>(b =>\n{\n    b.ConfigureServices((context, services) =>\n    {\n        services.Configure<MartenSettings>(s =>\n        {\n            s.SchemaName = SchemaName;\n        });\n    });\n});\n```\n\n----------------------------------------\n\nTITLE: Create Multiple Full Text Indexes for Multiple Properties (C#)\nDESCRIPTION: This code snippet demonstrates how to create multiple full text indexes for multiple properties with custom settings using the `[FullTextIndex]` attribute on multiple properties with different `IndexName` and `RegConfig`. Requires Marten and PostgreSQL version 10.0 or above.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/full_text.md#_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\npublic class MyDocument\n{\n    public Guid Id { get; set; }\n\n    [FullTextIndex(IndexName = \"FirstNameIndex\", RegConfig = \"french\")]\n    public string FirstName { get; set; }\n\n    [FullTextIndex(IndexName = \"LastNameIndex\", RegConfig = \"spanish\")]\n    public string LastName { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Lightweight Document Session for Manual Change Tracking (C#)\nDESCRIPTION: This snippet illustrates the creation of a new `DocumentSession` with `IDocumentStore.LightweightSession()` or `IDocumentStore.OpenSession()` for manual change tracking. In this mode, users are responsible for explicitly tracking and notifying the session about document changes.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/basics/persisting.md#_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nusing Marten;\nusing System.Threading.Tasks;\n\npublic class LightweightDocumentSessionUow\n{\n    public async Task Lightweight_document_session_uow(IDocumentStore store)\n    {\n        using (var session = store.LightweightSession())\n        {\n            // Or\n            //using (var session = store.OpenSession())\n            {\n                var target = new Target { Name = \"Initial Name\" };\n                session.Store(target);\n                await session.SaveChangesAsync();\n\n                // Later...\n\n                target.Name = \"Updated Name\";\n\n                // Need to tell the session that this document\n                // has changed\n                session.Update(target);\n\n                await session.SaveChangesAsync();\n            }\n        }\n    }\n\n    public class Target\n    {\n        public int Id { get; set; }\n        public string Name { get; set; }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Extension Method for Linq in C#\nDESCRIPTION: This C# code snippet defines a custom extension method named `IsBlue` for string values. This method is intended to be used within Linq queries and demonstrates how to create custom methods that can be recognized by Marten's Linq support.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/extending.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic static bool IsBlue(this string value)\n{\n    return value == \"Blue\";\n}\n```\n\n----------------------------------------\n\nTITLE: Using StoreOptions.Schema for Configuration - C#\nDESCRIPTION: This snippet demonstrates how to configure document storage using the StoreOptions.Schema property directly. It shows how to define connection settings and specify duplicate indexes for Organization and User documents. This approach provides a centralized way to manage document storage configurations.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/storeoptions.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(opts =>\n{\n    opts.Connection(ConnectionSource.ConnectionString);\n    opts.Schema.For<Organization>()\n        .Duplicate(x => x.OtherName);\n\n    opts.Schema\n        .For<User>().Duplicate(x => x.UserName);\n});\n```\n\n----------------------------------------\n\nTITLE: Create Multiple Full Text Indexes with Different Languages (C#)\nDESCRIPTION: This code snippet demonstrates how to create multiple full text indexes for the same document with different language configurations using the StoreOptions fluent interface in Marten. It creates one index with 'english' and another with 'german'. Requires Marten and PostgreSQL version 10.0 or above.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/full_text.md#_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nusing var store = DocumentStore.For(_ =>\n{\n    _.Connection(\"your_postgres_connection_string\");\n    _.Schema.For<MyDocument>().Searchable(regConfig: \"english\");\n    _.Schema.For<MyDocument>().Searchable(regConfig: \"german\");\n});\n```\n\n----------------------------------------\n\nTITLE: Escaping Identifiers in Postgres\nDESCRIPTION: Shows how to escape identifiers such as column and table names in Postgres using double quotes.  This is necessary when identifiers contain special characters or are reserved words.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/postgres/escaping.md#_snippet_1\n\nLANGUAGE: SQL\nCODE:\n```\nselect \"id\" from \"my_table\";\n```\n\n----------------------------------------\n\nTITLE: Statement Class Diagram\nDESCRIPTION: This Mermaid diagram visualizes the relationships between ISelectClause, Statement, ISqlFragment, IFieldMapping, IField, WhereClause, Ordering, and WhereClauseParser. It illustrates how these components are structured and used to build SQL statements, including the selection, filtering, and ordering aspects of a query.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/diagrams/querying.md#_snippet_3\n\nLANGUAGE: mermaid\nCODE:\n```\nclassDiagram\n\nclass ISelectClause {\n    <<interface>> ISelectClause\n    WriteSelectClause(CommandBuilder)\n    BuildSelector(IMartenSession) ISelector\n    BuildHandler~T~(IMartenSession, Statement, Statement) IQueryHandler~T~\n}\n\nISelectClause --> ISelector: Builds\nISelectClause --> CommandBuilder: Configures\n\n\nclass Statement {\n    <<abstract>> Statement\n    Configure(CommandBuilder)\n    ISqlFragment Where\n    Offset\n    Limit\n}\n\nStatement --> Statement : Next\nStatement --> CommandBuilder : Writes to\nStatement --> IFieldMapping : 1\nStatement --> ISqlFragment : Where\n\nclass ISqlFragment {\n    <<interface>> ISqlFragment\n    Apply(CommandBuilder)\n\n}\n\nclass IFieldMapping {\n    <<interface>> IFieldMapping\n}\n\nclass IField {\n    <<interface>> IField\n}\n\nIFieldMapping *-- IField\n\n\nclass WhereClause\nclass Ordering\n\nStatement --> WhereClause: 0..*\nStatement --> Ordering: 0..*\n\nclass WhereClauseParser {\n    Build(WhereClause) ISqlFragment\n}\n\nStatement --> WhereClauseParser: Uses\n\n\n```\n\n----------------------------------------\n\nTITLE: Querying with Select() and FirstOrDefault() in Marten (C#)\nDESCRIPTION: This example demonstrates chaining `Select()` with `FirstOrDefault()` to retrieve a single projected value. It projects the `FirstName` property of a `User` document into a `UserName` type and then retrieves the first one, asserting that its name matches \"Bill\". Requires `theSession` (an `IDocumentSession`) to be initialized and populated with `User` documents.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/projections.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic async Task use_select_to_another_type_with_first()\n{\n    theSession.Store(new User { FirstName = \"Hank\" });\n    theSession.Store(new User { FirstName = \"Bill\" });\n    theSession.Store(new User { FirstName = \"Sam\" });\n    theSession.Store(new User { FirstName = \"Tom\" });\n\n    await theSession.SaveChangesAsync();\n\n    theSession.Query<User>().OrderBy(x => x.FirstName).Select(x => new UserName { Name = x.FirstName })\n        .FirstOrDefault()\n        ?.Name.ShouldBe(\"Bill\");\n}\n```\n\n----------------------------------------\n\nTITLE: Deleting Aggregate with ShouldDelete Convention (Marten, C#)\nDESCRIPTION: Demonstrates using the `ShouldDelete()` method convention within a Marten projection to determine when to delete a Trip aggregate. The `ShouldDelete()` method can take the event, the aggregate, an IQuerySession, or a combination of those as arguments. It should return a boolean or Task<Boolean> indicating whether the aggregate should be deleted.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/aggregate-projections.md#_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\npublic class TripProjection: SingleStreamProjection<Trip>\n{\n    // The current Trip aggregate would be deleted if\n    // the Breakdown event is \"critical\"\n    public bool ShouldDelete(Breakdown breakdown) => breakdown.IsCritical;\n\n    // Alternatively, delete the aggregate if the trip\n    // is currently in New Mexico and the breakdown is critical\n    public bool ShouldDelete(Trip trip, Breakdown breakdown)\n        => breakdown.IsCritical && trip.State == \"New Mexico\";\n\n    public async Task<bool> ShouldDelete(IQuerySession session, Trip trip, Breakdown breakdown)\n    {\n        var anyRepairShopsInState = await session.Query<RepairShop>()\n            .Where(x => x.State == trip.State)\n            .AnyAsync();\n\n        // Delete the trip if there are no repair shops in\n        // the current state\n        return !anyRepairShopsInState;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Selecting Single Value with Marten Linq in C#\nDESCRIPTION: Demonstrates how to select a single value from a Marten database using Linq. Includes examples of using `Single()`, `SingleOrDefault()`, `First()`, `FirstOrDefault()`, `Last()`, and `LastOrDefault()` methods.  It uses `IDocumentSession` to query the `Target` document type based on specified conditions.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/operators.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\npublic void select_a_single_value(IDocumentSession session)\n{\n    // Single()/SingleOrDefault() will throw exceptions if more than\n    // one result is returned from the database\n    session.Query<Target>().Where(x => x.Number == 5).Single();\n    session.Query<Target>().Where(x => x.Number == 5).SingleOrDefault();\n\n    session.Query<Target>().Where(x => x.Number == 5).OrderBy(x => x.Date).First();\n    session.Query<Target>().Where(x => x.Number == 5).OrderBy(x => x.Date).FirstOrDefault();\n\n    session.Query<Target>().Where(x => x.Number == 5).OrderBy(x => x.Date).Last();\n    session.Query<Target>().Where(x => x.Number == 5).OrderBy(x => x.Date).LastOrDefault();\n\n    // Using the query inside of Single/Last/First is supported as well\n    session.Query<Target>().Single(x => x.Number == 5);\n}\n```\n\n----------------------------------------\n\nTITLE: Upcaster Class with CLR Types\nDESCRIPTION: This snippet shows how to upcast an event using a class that inherits from `EventUpcaster`. It transforms a `ShoppingCartOpened` event into a `ShoppingCartOpenedWithStatus` event. The event type name defaults to the old CLR type name.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/versioning.md#_snippet_18\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ShoppingCartOpenedUpcaster:\n    EventUpcaster<ShoppingCartOpened, ShoppingCartOpenedWithStatus>\n{\n    protected override ShoppingCartOpenedWithStatus Upcast(ShoppingCartOpened oldEvent) =>\n        new ShoppingCartOpenedWithStatus(\n            oldEvent.ShoppingCartId,\n            new Client(oldEvent.ClientId),\n            ShoppingCartStatus.Opened\n        );\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Tick Event Type (C#)\nDESCRIPTION: Defines a `Tick` class with properties for Value and Time. Represents a single tick of data, used as an event to update the `Candle` projection.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/projection-by-event-type.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic class Tick\n{\n    public decimal Value { get; set; }\n    public DateTime Time { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Marten via NuGet Package Manager\nDESCRIPTION: This command installs the Marten library using the NuGet Package Manager console in Visual Studio. Marten allows .NET applications to persist and query data in a PostgreSQL database.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/getting_started.md#_snippet_0\n\nLANGUAGE: PowerShell\nCODE:\n```\nPM> Install-Package Marten\n```\n\n----------------------------------------\n\nTITLE: IInitialData Implementation for Testing\nDESCRIPTION: This code snippet illustrates a basic implementation of the `IInitialData` interface intended for testing purposes.  The `Populate` method is intentionally left empty as a placeholder for adding baseline test data to the Marten document store during test setup.  It requires Marten's `IDocumentStore` and `IInitialData` interfaces.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/initial-data.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic class MyTestingData: IInitialData\n{\n    public Task Populate(IDocumentStore store, CancellationToken cancellation)\n    {\n        // TODO -- add baseline test data here\n        return Task.CompletedTask;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Invoice Events for State Changes in C#\nDESCRIPTION: This snippet introduces two events to capture state changes of an invoice: `InvoiceCreated` and `LineAdded`. These events represent the deltas in the invoice's state and are used to replay the state.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/scenarios/aggregates_events_repositories.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:scenario-aggregate-events]>\n```\n\n----------------------------------------\n\nTITLE: Applying Database Changes (Legacy) - Bash\nDESCRIPTION: This bash command (for Marten < V5.0) demonstrates how to apply pending database changes using the Marten command-line interface. The 'marten-apply' command executes the necessary SQL scripts to update the database schema.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/schema/migrations.md#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\ndotnet run -- marten-apply\n```\n\n----------------------------------------\n\nTITLE: Integration Context with Multiple Marten Databases\nDESCRIPTION: Demonstrates how to work with multiple Marten databases in integration tests. It retrieves document stores by their interface types, allowing access to different databases within the same test context. It depends on `IAlbaHost`, `IDocumentStore`, `IInvoicingStore`, and `AppFixture`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/testing/integration.md#_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IInvoicingStore: IDocumentStore\n{\n}\n\npublic abstract class MultipleMartenDatabasesIntegrationContext: IAsyncLifetime\n{\n    protected MultipleMartenDatabasesIntegrationContext(\n        AppFixture fixture\n    )\n    {\n        Host = fixture.Host;\n        Store = Host.DocumentStore();\n        InvoicingStore = Host.DocumentStore<IInvoicingStore>();\n    }\n\n    public IAlbaHost Host { get; }\n    public IDocumentStore Store { get; }\n    public IInvoicingStore InvoicingStore { get; }\n\n    public async Task InitializeAsync()\n    {\n        // Using Marten, wipe out all data and reset the state\n        await Store.Advanced.ResetAllData();\n    }\n\n    // This is required because of the IAsyncLifetime\n    // interface. Note that I do *not* tear down database\n    // state after the test. That's purposeful\n    public Task DisposeAsync()\n    {\n        return Task.CompletedTask;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Tenant Is One Of (C#)\nDESCRIPTION: Use `TenantIsOneOf` to query on a selected list of tenants.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/linq.md#_snippet_38\n\nLANGUAGE: C#\nCODE:\n```\nvar targets = session.Query<Target>().TenantIsOneOf(\"tenant1\", \"tenant2\").ToList();\n```\n\n----------------------------------------\n\nTITLE: Querying Against Event Type with Marten (C#)\nDESCRIPTION: This code snippet demonstrates how to query the Marten event store for specific event types using `QueryRawEventDataOnly<T>()`. It shows how to use LINQ operators like `Count()`, `ToArray()`, `SelectMany()`, `Distinct()`, `OrderBy()`, and `Single()` to filter and manipulate the event data. This is done within a Fact test method.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/querying.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic async Task can_query_against_event_type()\n{\n    theSession.Events.StartStream<Quest>(joined1, departed1);\n    theSession.Events.StartStream<Quest>(joined2, departed2);\n\n    await theSession.SaveChangesAsync();\n\n    theSession.Events.QueryRawEventDataOnly<MembersJoined>().Count().ShouldBe(2);\n    theSession.Events.QueryRawEventDataOnly<MembersJoined>().ToArray().SelectMany(x => x.Members).Distinct()\n        .OrderBy(x => x)\n        .ShouldHaveTheSameElementsAs(\"Egwene\", \"Matt\", \"Nynaeve\", \"Perrin\", \"Rand\", \"Thom\");\n\n    theSession.Events.QueryRawEventDataOnly<MembersDeparted>()\n        .Single(x => x.Members.Contains(\"Matt\")).Id.ShouldBe(departed2.Id);\n}\n```\n\n----------------------------------------\n\nTITLE: Using Select Many (C#)\nDESCRIPTION: You can use SelectMany() against collections of child documents.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/linq.md#_snippet_23\n\nLANGUAGE: C#\nCODE:\n```\npublic class Target\n{\n    public Guid Id { get; set; }\n    public string[] Tags { get; set; }\n    public List<string> ListTags {get; set;}\n    public List<int> Numbers { get; set; }\n    public IList<Child> Children { get; set; }\n\n}\n\npublic class Child\n{\n    public string Name { get; set; }\n    public int Age { get; set; }\n}\n\nvar targets = session.Query<Target>().SelectMany(x => x.Children).Where(x => x.Age > 5).ToList();\n```\n\n----------------------------------------\n\nTITLE: Querying for Paginated Results with QueryStatistics - C#\nDESCRIPTION: This C# code defines a compiled query (`TargetPaginationQuery`) for paginated results using Marten. It implements `ICompiledListQuery<Target>` and uses `QueryStatistics` to retrieve the total count of matching records. The query filters targets where `Number` is greater than 10, then skips and takes records based on `PageNumber` and `PageSize`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/compiled-queries.md#_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\npublic class TargetPaginationQuery: ICompiledListQuery<Target>\n{\n    public TargetPaginationQuery(int pageNumber, int pageSize)\n    {\n        PageNumber = pageNumber;\n        PageSize = pageSize;\n    }\n\n    public int PageNumber { get; set; }\n    public int PageSize { get; set; }\n\n    public QueryStatistics Stats { get; } = new QueryStatistics();\n\n    public Expression<Func<IMartenQueryable<Target>, IEnumerable<Target>>> QueryIs()\n    {\n        return query => query\n            .Where(x => x.Number > 10)\n            .Skip(PageNumber)\n            .Take(PageSize);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Querying with Boolean Flags using Marten Linq (C#)\nDESCRIPTION: This code snippet demonstrates how to query a Marten database for documents based on boolean properties. It shows examples for querying where a boolean flag is true or false, using both shorthand notation (e.g., `x => x.Flag`) and explicit comparison (e.g., `x => x.Flag == true`). Requires a Marten `IDocumentSession` and a document type with a boolean property named `Flag`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/booleans.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic void query_by_booleans(IDocumentSession session)\n{\n    // Flag is a boolean property.\n\n    // Where Flag is true\n    session.Query<Target>().Where(x => x.Flag).ToArray();\n    // or\n    session.Query<Target>().Where(x => x.Flag == true).ToArray();\n\n    // Where Flag is false\n    session.Query<Target>().Where(x => !x.Flag).ToArray();\n    // or\n    session.Query<Target>().Where(x => x.Flag == false).ToArray();\n}\n```\n\n----------------------------------------\n\nTITLE: Loading Versioned Aggregate - Marten C#\nDESCRIPTION: This snippet demonstrates how to load a specific version of an aggregate from a Marten repository. It uses the `LoadAsync` method to retrieve the `Invoice` aggregate with a specific version number (2 in this case). The assertion verifies the `Total` property of the loaded aggregate.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/scenarios/aggregates-events-repositories.md#_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nvar invoiceFromRepository = await repository.LoadAsync<Invoice>(invoice.Id, 2);\n\nAssert.Equal(124, invoiceFromRepository.Total);\n```\n\n----------------------------------------\n\nTITLE: Command Handler using FetchForWriting in C#\nDESCRIPTION: This code snippet shows a command handler (`Handle1`) that uses `FetchForWriting` to retrieve an `Order` aggregate by its stream id. It validates the command, appends events based on the command's logic, and saves the changes to the database. It also demonstrates concurrency handling with a `ConcurrencyException` if another process modifies the stream concurrently.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/scenarios/command_handler_workflow.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic async Task Handle1(MarkItemReady command, IDocumentSession session)\n{\n    // Fetch the current value of the Order aggregate\n    var stream = await session\n        .Events\n        .FetchForWriting<Order>(command.OrderId);\n\n    var order = stream.Aggregate;\n\n    if (order.Items.TryGetValue(command.ItemName, out var item))\n    {\n        // Mark that the this item is ready\n        stream.AppendOne(new ItemReady(command.ItemName));\n    }\n    else\n    {\n        // Some crude validation\n        throw new InvalidOperationException($\"Item {command.ItemName} does not exist in this order\");\n    }\n\n    // If the order is ready to ship, also emit an OrderReady event\n    if (order.IsReadyToShip())\n    {\n        stream.AppendOne(new OrderReady());\n    }\n\n    await session.SaveChangesAsync();\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Id Property with Attribute\nDESCRIPTION: This snippet demonstrates how to override the default Id property/field convention using the `[Identity]` attribute. This is useful when migrating existing document types from another database or when the desired Id property doesn't match the `id` or `Id` convention.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/identity.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic class NonStandardDoc\n{\n    [Identity]\n    public string Name;\n}\n```\n\n----------------------------------------\n\nTITLE: Plain Text Search Query - Marten C#\nDESCRIPTION: Executes a plain text search query using the `PlainTextSearch()` extension method on a Marten `IQueryable`. It searches the indexed text fields for the term 'somefilter' using plainto_tsquery. Requires the Marten library.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/full-text.md#_snippet_12\n\nLANGUAGE: cs\nCODE:\n```\nvar posts = session.Query<BlogPost>()\n    .Where(x => x.PlainTextSearch(\"somefilter\"))\n    .ToList();\n```\n\n----------------------------------------\n\nTITLE: Define Metadata Class\nDESCRIPTION: Defines a simple .NET class to represent document metadata, including properties for correlation ID and user ID. This metadata class can be used to automatically add extra columns to the documents and events managed by Marten.\nSOURCE: https://github.com/jasperfx/marten/blob/master/planning/MartenV4.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n    public class MyMetadata\n    {\n        public Guid CorrelationId { get; set; }\n        public string UserId { get; set; }\n    }\n```\n\n----------------------------------------\n\nTITLE: Applying Changes to Database - Bash\nDESCRIPTION: This command applies outstanding changes to the database based on the current configuration. All actions will be logged to 'log.txt'.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/cli.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nmarten marten-apply --log log.txt\n```\n\n----------------------------------------\n\nTITLE: Customize Newtonsoft.Json Serialization\nDESCRIPTION: Demonstrates how to customize the Newtonsoft.Json serialization settings within Marten. This involves explicitly supplying an instance of Marten's `JsonNetSerializer` and configuring the serializer settings within a nested closure to ensure consistent configuration across internal serializers.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/json/newtonsoft.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:customize_json_net_serialization]>\n```\n\n----------------------------------------\n\nTITLE: Defining a New Event Type (MemberJoined) C#\nDESCRIPTION: This snippet defines a new event type, `MemberJoined`, which represents a single member joining a quest. It includes properties for the day, location, and name of the member. A static `From` method is provided to transform a `MembersJoined` event (which contains a list of members) into an array of `MemberJoined` events, one for each member. This showcases how to introduce new event types based on existing ones within Marten.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/scenarios/copy-and-transform-stream.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\npublic class MemberJoined\n{\n    public int Day { get; set; }\n    public string Location { get; set; }\n    public string Name { get; set; }\n\n    public MemberJoined()\n    {\n    }\n\n    public MemberJoined(int day, string location, string name)\n    {\n        Day = day;\n        Location = location;\n        Name = name;\n    }\n\n    public static MemberJoined[] From(MembersJoined @event)\n    {\n        return @event.Members.Select(x => new MemberJoined(@event.Day, @event.Location, x)).ToArray();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Paging with ToPagedList (C#)\nDESCRIPTION: Demonstrates synchronous data paging using Marten's `ToPagedList` extension method on an `IQueryable<T>`. It retrieves a paged list of `Target` objects, specifying the page number and page size. Dependencies include Marten and Linq.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/paging.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvar pagedList = query.ToPagedList(2, 10);\n```\n\n----------------------------------------\n\nTITLE: GinIndexed Attribute Example - C#\nDESCRIPTION: Shows how to create a custom attribute for adding a GIN index to the JSONB storage, allowing for more efficient ad-hoc querying of documents. This illustrates the use of custom attributes for extending Marten's configuration capabilities.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/index.md#_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic class GinIndexedAttribute : MartenAttribute\n{\n    public override void Modify(DocumentMapping mapping, MemberInfo member)\n    {\n        mapping.AddGinIndexToDataField();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Duplicated DateTime Fields as Timestamp with Time Zone in Marten\nDESCRIPTION: This code snippet configures Marten to store duplicated DateTime fields as timestamp with time zone. This configuration maintains compatibility with previous versions or specific data models requiring timezone information to be stored with DateTime values in duplicated fields. Setting `DuplicatedFieldUseTimestampWithoutTimeZoneForDateTime` to `false` ensures that timezone information is preserved.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/migration_guide.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nDuplicatedFieldUseTimestampWithoutTimeZoneForDateTime = false;\n```\n\n----------------------------------------\n\nTITLE: Configuring Inline Snapshot for Invoice (C#)\nDESCRIPTION: Configures Marten to use an inline snapshot lifecycle for the `Invoice` aggregate.  This means the aggregate state is updated synchronously with each event.  It uses `opts.Projections.Snapshot<Projections.Invoice>(SnapshotLifecycle.Inline)` to set the snapshot lifecycle to inline.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/read-aggregates.md#_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\nbuilder.Services.AddMarten(opts =>\n{\n    opts.Connection(builder.Configuration.GetConnectionString(\"marten\"));\n\n    opts.Projections.Snapshot<Projections.Invoice>(SnapshotLifecycle.Inline);\n});\n```\n\n----------------------------------------\n\nTITLE: Querying a boolean column in PostgreSQL\nDESCRIPTION: These SQL snippets demonstrate various ways to query a boolean column named `active` in a table named `users`.  They show implicit checks, explicit comparisons using `true` and `false`, and the use of `is` and `is not` operators.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/postgres/types.md#_snippet_4\n\nLANGUAGE: SQL\nCODE:\n```\nselect * from users where active;\nselect * from users where not active;\n```\n\nLANGUAGE: SQL\nCODE:\n```\nselect * from users where active is true;\nselect * from users where active is false;\n\n-- or\n\nselect * from users where active = true;\nselect * from users where active = false;;\n```\n\nLANGUAGE: SQL\nCODE:\n```\nselect * from users where active is not true;\nselect * from users where active is not false;\n```\n\n----------------------------------------\n\nTITLE: Install Alba NuGet Package\nDESCRIPTION: Installs the Alba NuGet package, a library for testing ASP.NET Core applications, into the project. Alba is used to set up and interact with the application's host during integration testing.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/testing/integration.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ndotnet add package Alba\n```\n\n----------------------------------------\n\nTITLE: Deep Calculated Index SQL Representation\nDESCRIPTION: This SQL code snippet represents the database index generated by Marten for a deep calculated index on the `Inner.Color` property. It uses the `data -> 'Inner' ->> 'Color'` expression and casts the result to an integer.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/computed_index.md#_snippet_3\n\nLANGUAGE: SQL\nCODE:\n```\nCREATE INDEX mt_doc_target_idx_inner_color ON public.mt_doc_target (((data -> 'Inner' ->> 'Color')::int));\n```\n\n----------------------------------------\n\nTITLE: Appending Events with Event ID Assertion (C#)\nDESCRIPTION: This example showcases appending events to a stream while also asserting on the expected version (or maximum event ID) of the stream. If the expected version does not match the actual version, an `EventStreamUnexpectedMaxEventIdException` will be thrown, aborting the transaction. This ensures that events are appended only if the stream is in the expected state, preventing concurrency issues.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/events/appending.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nusing var store = DocumentStore.Empty();\n\nvar questId = Guid.NewGuid();\n\n// Starting a brand new stream with a user-supplied stream id\nvar joined = new MembersJoined { Members = new[] { \"Bilbo\", \"Frodo\" } };\nvar departed = new MembersDeparted { Members = new[] { \"Frodo\" } };\n\nusing var session = store.OpenSession();\n\n// Append events to existing stream with assertion\nsession.Events.Append(questId, 1, joined, departed);\n\nsession.SaveChanges();\n```\n\n----------------------------------------\n\nTITLE: Hard Deleting Documents in Marten\nDESCRIPTION: This code snippet demonstrates how to force a hard delete of documents using Marten's `HardDelete()` and `HardDeleteWhere()` methods. It shows deleting by document, by id, and by criteria.  It requires an `IDocumentSession` and a document or criteria.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/deletes.md#_snippet_17\n\nLANGUAGE: cs\nCODE:\n```\ninternal void ExplicitlyHardDelete(IDocumentSession session, User document)\n{\n    // By document\n    session.HardDelete(document);\n\n    // By type and identity\n    session.HardDelete<User>(document.Id);\n\n    // By type and criteria\n    session.HardDeleteWhere<User>(x => x.Roles.Contains(\"admin\"));\n\n    // And you still have to call SaveChanges()/SaveChangesAsync()\n    // to actually perform the operations\n}\n```\n\n----------------------------------------\n\nTITLE: Using Request Count\nDESCRIPTION: Demonstrates how to access the request count for a session, indicating the number of commands issued to PostgreSQL. The example queries the database multiple times using the session and then asserts that the request count matches the number of queries performed.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/diagnostics.md#_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\nusing (var session = theStore.QuerySession())\n{\n    var users = session.Query<User>().ToList();\n    var count = session.Query<User>().Count();\n    var any = session.Query<User>().Any();\n\n    session.RequestCount.ShouldBe(3);\n}\n```\n\n----------------------------------------\n\nTITLE: PL/pgSQL Anonymous Code Block Example\nDESCRIPTION: This code snippet demonstrates the basic structure of a PL/pgSQL anonymous code block in PostgreSQL. It starts with `DO %%`, includes a `BEGIN` and `END` block, and can optionally specify the language using `LANGUAGE plpgsql`. This structure is necessary to execute procedural code, such as IF statements, within PostgreSQL.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/postgres/if-statements.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\nDO %%\nBEGIN\n\n    // your sql here…\n\nEND\n%%;\n```\n\n----------------------------------------\n\nTITLE: Dumping DDL to Separate Files by Document Type - Bash\nDESCRIPTION: This command dumps the DDL (Data Definition Language) for the configured Marten database to separate files, one for each document type, into a folder named \"scripts\". This separation is useful for managing database schema in a more modular way.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/cli.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nmarten marten-dump scripts --by-type\n```\n\n----------------------------------------\n\nTITLE: Static Using for System.Text.Json Upcasting\nDESCRIPTION: This snippet shows the static using statement required to use the System.Text.Json upcasting helpers. It imports the `JsonTransformations` class from the `Marten.Services.Json.Transformations.SystemTextJson` namespace.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/versioning.md#_snippet_17\n\nLANGUAGE: csharp\nCODE:\n```\nusing static Marten.Services.Json.Transformations.SystemTextJson.JsonTransformations;\n```\n\n----------------------------------------\n\nTITLE: Defining StreamMovedTo Event C#\nDESCRIPTION: This snippet defines a simple event class, `StreamMovedTo`, which is used to mark an event stream as having been copied or moved to a new location. It contains a single property, `To`, which specifies the name or identifier of the new stream. This event is appended to the original stream to indicate that it should no longer be used for appending new events.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/scenarios/copy-and-transform-stream.md#_snippet_3\n\nLANGUAGE: cs\nCODE:\n```\npublic class StreamMovedTo\n{\n    public string To { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Schema Feature (C#)\nDESCRIPTION: This C# code snippet demonstrates creating a custom schema feature in Marten by inheriting from `FeatureSchemaBase`. It defines a custom table with a single column. It showcases how to use the `FeatureSchemaBase` class to easily define custom schema features.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/advanced/extensions.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic class FakeSchemaFeature : FeatureSchemaBase\\n{\\n    public const string FeatureName = \"Fake\";\\n\\n    public FakeSchemaFeature() : base(FeatureName, AutoCreate.CreateOrUpdate)\\n    {\\n    }\\n\\n    protected override IEnumerable<ISchemaObject> schemaObjects()\\n    {\\n        yield return new Table(\"fake_table_name\")\\n        {\\n            Columns =\\n            {\\n                new TableColumn(\"name\", \"varchar\")\\n            }\\n        };\\n    }\\n}\n```\n\n----------------------------------------\n\nTITLE: Publish docs (.NET CLI)\nDESCRIPTION: This command publishes the documentation by executing the build project with the 'publish-docs' argument using the .NET CLI.\nSOURCE: https://github.com/jasperfx/marten/blob/master/README.md#_snippet_10\n\nLANGUAGE: .NET CLI\nCODE:\n```\ndotnet run --project build/build.csproj -- publish-docs\n```\n\n----------------------------------------\n\nTITLE: Pushing Migrations Docker Image to Registry\nDESCRIPTION: This step pushes the migrations' Docker image to the configured registry. The image is tagged with the Git SHA.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/devops/devops.md#_snippet_16\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Push Migrations Docker Image\n  run: docker push myapp/migrations:${{ github.sha }}\n```\n\n----------------------------------------\n\nTITLE: Event Metadata Definition\nDESCRIPTION: This code snippet shows the properties of the `IEvent` interface in Marten, which represent event metadata. It includes properties such as `StreamId`, `Version`, `Sequence`, `Timestamp`, `TenantId`, `CausationId`, `CorrelationId`, and `Headers`. These properties provide information about the event's context and relationships within the event stream.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/storage.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\n/// <summary>\n///     A reference to the stream that contains\n///     this event\n/// </summary>\npublic Guid StreamId { get; set; }\n\n/// <summary>\n///     A reference to the stream if the stream\n///     identifier mode is AsString\n/// </summary>\npublic string? StreamKey { get; set; }\n\n/// <summary>\n///     An alternative Guid identifier to identify\n///     events across databases\n/// </summary>\npublic Guid Id { get; set; }\n\n/// <summary>\n///     An event's version position within its event stream\n/// </summary>\npublic long Version { get; set; }\n\n/// <summary>\n///     A global sequential number identifying the Event\n/// </summary>\npublic long Sequence { get; set; }\n\n/// <summary>\n///     The UTC time that this event was originally captured\n/// </summary>\npublic DateTimeOffset Timestamp { get; set; }\n\npublic string TenantId { get; set; } = Tenancy.DefaultTenantId;\n\n/// <summary>\n///     Optional metadata describing the causation id\n/// </summary>\npublic string? CausationId { get; set; }\n\n/// <summary>\n///     Optional metadata describing the correlation id\n/// </summary>\npublic string? CorrelationId { get; set; }\n\n/// <summary>\n///     This is meant to be lazy created, and can be null\n/// </summary>\npublic Dictionary<string, object>? Headers { get; set; }\n```\n\n----------------------------------------\n\nTITLE: Building Migrations Docker Image with GitHub Actions\nDESCRIPTION: This step builds a Docker image for the database migrations using the Dockerfile located in the ./Migrations/ directory. The image is tagged with the Git SHA.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/devops/devops.md#_snippet_13\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Build Migrations Docker Image\n  run: docker build -t myapp/migrations:${{ github.sha }} -f ./Migrations/Dockerfile .\n```\n\n----------------------------------------\n\nTITLE: AsJson with Select Marten C#\nDESCRIPTION: This code snippet shows how to combine `AsJson()` with a `Select()` transform in a Marten query. It queries for `User` documents, orders them by `FirstName`, transforms the `User` class to a `UserName` type using `Select`, and then retrieves the JSON representation of the transformed result using `ToJsonFirst()`. It demonstrates how to get JSON output after applying a transformation to the query results.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/query-json.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nvar json = await theSession\n    .Query<User>()\n    .OrderBy(x => x.FirstName)\n\n    // Transform the User class to a different type\n    .Select(x => new UserName { Name = x.FirstName })\n    .ToJsonFirst();\n\njson.ShouldBe(\"{{\\\"Name\\\": \\\"Bill\\\"}}\");\n```\n\n----------------------------------------\n\nTITLE: Defining IBatchQueryPlan Interface - C#\nDESCRIPTION: This code presents the `IBatchQueryPlan<T>` interface, which is used to define reusable queries within Marten batched queries. The `Fetch` method takes an `IBatchedQuery` instance as input and returns a `Task<T>`, allowing for custom query logic within a batch operation. This interface is especially helpful when complex operations are not supported by Marten compiled queries.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/compiled-queries.md#_snippet_21\n\nLANGUAGE: csharp\nCODE:\n```\n/// <summary>\n/// Marten's concept of the \"Specification\" pattern for reusable\n/// queries within Marten batched queries. Use this for operations that cannot be supported by Marten compiled queries\n/// </summary>\n/// <typeparam name=\"T\"></typeparam>\npublic interface IBatchQueryPlan<T>\n{\n    Task<T> Fetch(IBatchedQuery query);\n}\n```\n\n----------------------------------------\n\nTITLE: Configure Template With Attribute - C#\nDESCRIPTION: This code snippet demonstrates how to configure the DDL template for a document type using the `[DdlTemplate(\"name\")]` attribute. This attribute allows you to specify the template to use for a specific document type directly in the class definition.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/schema/authorization.md#_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:configure_template_with_attribute]>\n```\n\n----------------------------------------\n\nTITLE: Batch Query with Compiled Queries (Sync)\nDESCRIPTION: Demonstrates how to execute a batch query with compiled queries synchronously using `IBatchedQuery.ExecuteSynchronously()`.  The code is very similar to the asynchronous version, but it calls `ExecuteSynchronously()` instead of `Execute()`.  The results of the compiled queries are accessed using the `.Result` property of the returned `Task` objects.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/batched-queries.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nvar batch = session.CreateBatchQuery();\n\nvar justin = batch.Query(new FindByFirstName { FirstName = \"Justin\" });\nvar tamba = batch.Query(new FindByFirstName { FirstName = \"Tamba\" });\n\nbatch.ExecuteSynchronously();\n\njustin.Result.Id.ShouldBe(user1.Id);\ntamba.Result.Id.ShouldBe(user2.Id);\n```\n\n----------------------------------------\n\nTITLE: Initializing Schema Name\nDESCRIPTION: Generates a unique schema name for each test. The generated schema name is prefixed with \"sch\" and consists of a GUID with hyphens removed. This ensures that each test runs in isolation with its own database schema.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/testing/integration.md#_snippet_9\n\nLANGUAGE: cs\nCODE:\n```\nprivate string SchemaName { get; } = \"sch\" + Guid.NewGuid().ToString().Replace(\"-\", string.Empty);\n```\n\n----------------------------------------\n\nTITLE: Using a Query Plan with IQuerySession - C#\nDESCRIPTION: This snippet demonstrates how to use a previously defined query plan (`ColorTargets`) with an `IQuerySession` to retrieve data. It utilizes the `QueryByPlanAsync` method, passing in an instance of the query plan and a cancellation token. The result is a list of `Target` documents matching the specified color.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/compiled-queries.md#_snippet_20\n\nLANGUAGE: csharp\nCODE:\n```\npublic static async Task use_query_plan(IQuerySession session, CancellationToken token)\n{\n    var targets = await session\n        .QueryByPlanAsync(new ColorTargets(Colors.Blue), token);\n}\n```\n\n----------------------------------------\n\nTITLE: SQL Server Procedure Creation (Example)\nDESCRIPTION: This code snippet illustrates how procedure creation might look in SQL Server, included for comparison. It demonstrates how a stored procedure could be created or dropped using `DROP PROCEDURE` and `CREATE PROCEDURE`. It is provided only for context and comparison with PostgreSQL equivalents.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/postgres/if_statements.md#_snippet_3\n\nLANGUAGE: SQL\nCODE:\n```\nDROP PROCEDURE CreateProduct…\nCREATE PROCEDURE CreateProduct…\n```\n\n----------------------------------------\n\nTITLE: Duplicating Fields with Fluent Interface - C#\nDESCRIPTION: Shows how to duplicate fields using the fluent interface off of `StoreOptions` in Marten. This allows for programmatic configuration of duplicated fields for query optimization.  It also covers defining not null constraints and indexing.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/duplicated_fields.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:IndexExamples]>\n```\n\n----------------------------------------\n\nTITLE: Search within Child Collections using Linq in Marten (C#)\nDESCRIPTION: Demonstrates how to query for documents based on the contents of child collections using the `Any()` and `Contains()` methods. `Any()` checks for equality of members, while `Contains` searches within arrays or lists of simple elements.  This utilizes the Postgresql JSONB containment operator for underlying SQL.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/linq.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic class Target\n{\n    public Guid Id { get; set; }\n    public string[] Tags { get; set; }\n    public Inner[] Children { get; set; }\n}\n\npublic class Inner\n{\n    public string Name { get; set; }\n    public int Age { get; set; }\n}\n\n\n\nvar targets = session.Query<Target>().Where(x => x.Children.Any(c => c.Name == \"Jeremy\")).ToList();\n\n// Searching within arrays of simple types\nvar targets2 = session.Query<Target>().Where(x => x.Tags.Contains(\"Tag1\")).ToList();\n```\n\n----------------------------------------\n\nTITLE: Using Identity Map with Marten\nDESCRIPTION: This sample demonstrates how to leverage Marten's Identity Map functionality within an IDocumentSession to cache and reuse loaded documents, avoiding redundant database queries. It illustrates the basic usage of the Identity Map pattern in a Marten application. The specific code is referenced by a sample name.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/advanced/identitymap.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:using-identity-map]>\n```\n\n----------------------------------------\n\nTITLE: Setting PostgreSQL image version\nDESCRIPTION: This command sets the PostgreSQL image version to be used for testing, using Docker Compose. It's useful when testing with specific PostgreSQL versions.\nSOURCE: https://github.com/jasperfx/marten/blob/master/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nPOSTGRES_IMAGE=postgres:15.3-alpine docker compose up\n```\n\n----------------------------------------\n\nTITLE: Deep Nested Properties Querying with Marten Linq in C#\nDESCRIPTION: Demonstrates how to perform deep queries on nested properties within documents in Marten using Linq. It uses `IDocumentSession` to query the `Target` document type, accessing the `Inner.Number` property to filter the results.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/operators.md#_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\npublic void deep_queries(IDocumentSession session)\n{\n    session.Query<Target>().Where(x => x.Inner.Number == 3);\n}\n```\n\n----------------------------------------\n\nTITLE: SaveChangesAsync() Sequence Diagram\nDESCRIPTION: This Mermaid sequence diagram illustrates the flow of execution when calling `SaveChangesAsync()` on a `DocumentSessionBase`. It shows the interactions between the `Client`, `DocumentSessionBase`, `IUnitOfWork`, `IManagedConnection`, `IDocumentSessionListener`, and `UpdateBatch`, including transaction management, operation sorting, listener invocation, and batched database command execution. Note that event appending workflow is omitted.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/diagrams/storage.md#_snippet_1\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\nautoNumber\nClient ->> DocumentSessionBase:SaveChangesAsync()\nNote right of DocumentSessionBase: The method will exit w/o any outstanding work\nDocumentSessionBase->>IUnitOfWork:HasOutstandingWork()\nIUnitOfWork-->>DocumentSessionBase:any work to commit?\n\nDocumentSessionBase->>IManagedConnection:BeginTransaction()\nNote left of IUnitOfWork: Order the operations between document type dependencies\nDocumentSessionBase->>IUnitOfWork: Sort()\nloop for each listener\n    DocumentSessionBase->>IDocumentSessionListener:BeforeSaveChanges(session)\nend\n\nDocumentSessionBase->>IUnitOfWork: AllOperations\nIUnitOfWork-->>DocumentSessionBase: sorted IStorageOperation objects\nNote right of DocumentSessionBase: Create the batched database commands from the ordered operations in the unit of work\nDocumentSessionBase->>UpdateBatch: new(operations)\nDocumentSessionBase->>UpdateBatch: ApplyChangesAsync(session)\n\n\nDocumentSessionBase->>IManagedConnection:CommandAsync()\n\nloop for each listener\n    DocumentSessionBase->>IDocumentSessionListener:AfterCommitAsync(session, unitOfWork, token)\nend\n\nnote right of DocumentSessionBase: finally, reset the internal unit of work\n\n```\n\n----------------------------------------\n\nTITLE: Benchmark Results: AppendEvents\nDESCRIPTION: This snippet presents the benchmark results for the AppendEvents method, indicating its mean execution time and standard deviation. These metrics provide insight into the performance of this specific operation.\nSOURCE: https://github.com/jasperfx/marten/blob/master/benchmarks/2.0.baseline/results/EventActions-report-github.md#_snippet_1\n\nLANGUAGE: INI\nCODE:\n```\nMethod |       Mean |    StdDev |\n------------- |----------- |---------- |\n AppendEvents | 44.3330 ms | 0.8700 ms |\n```\n\n----------------------------------------\n\nTITLE: Query By Nullable Types using Linq in Marten (C#)\nDESCRIPTION: Shows how to query for documents based on the presence or absence of null values in nullable properties. The example demonstrates both checking for null and not null conditions.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/linq.md#_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic class Target\n{\n    public Guid Id { get; set; }\n    public string[] Tags { get; set; }\n    public Inner[] Children { get; set; }\n    public int? NullableNumber { get; set; }\n\n}\n\npublic class Inner\n{\n    public string Name { get; set; }\n    public int Age { get; set; }\n}\n\nvar hasNulls = session.Query<Target>().Where(x => x.NullableNumber == null).ToList();\nvar hasValues = session.Query<Target>().Where(x => x.NullableNumber != null).ToList();\n```\n\n----------------------------------------\n\nTITLE: IMultitenantEvent Interface Definition\nDESCRIPTION: Defines the interface for a multitenant event.  This interface extends `IEvent` by adding a `TenantId` property, enabling the support for multitenancy within the event sourcing infrastructure.\nSOURCE: https://github.com/jasperfx/marten/blob/master/planning/MartenV4.md#_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\n// This might be too heavyweight\npublic interface IMultitenantEvent<TEventBase>: IEvent<TEventBase>\n{\n    string TenantId { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Default Polly Setup in Marten (C#)\nDESCRIPTION: This snippet shows the default Polly retry policy used by Marten. It handles NpgsqlException, MartenCommandException, and EventLoaderException with a maximum of 3 retry attempts, a delay of 50 milliseconds, and an exponential backoff strategy. This is part of Marten's internal resilience mechanism.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/retries.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n// default Marten policies\nreturn builder\n   .AddRetry(new()\n    {\n        ShouldHandle = new PredicateBuilder()\n            .Handle<NpgsqlException>()\n            .Handle<MartenCommandException>()\n            .Handle<EventLoaderException>(),\n        MaxRetryAttempts = 3,\n        Delay = TimeSpan.FromMilliseconds(50),\n        BackoffType = DelayBackoffType.Exponential\n    });\n```\n\n----------------------------------------\n\nTITLE: Customize Newtonsoft.Json Collection Storage\nDESCRIPTION: Demonstrates how to change the collection storage to `AsArray` using a custom `JsonConverter` for `ICollection<>`, `IList<>`, `IReadOnlyCollection<>`, and `IEnumerable<>`. This improves nested collections queries handling by storing collections as regular JSON arrays.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/json/newtonsoft.md#_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:customize_json_net_snakecase_collectionstorage]>\n```\n\n----------------------------------------\n\nTITLE: Using Schema Name in Marten\nDESCRIPTION: Configures the Marten store to use the schema name defined in MartenSettings. It retrieves MartenSettings from the service provider and sets both Events.DatabaseSchemaName and DatabaseSchemaName on the StoreOptions if a schema name is provided. Requires Marten and Microsoft.Extensions.Options.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/testing/integration.md#_snippet_12\n\nLANGUAGE: cs\nCODE:\n```\nservices.AddMarten(sp =>\n{\n    var options = new StoreOptions();\n    options.Connection(ConnectionSource.ConnectionString);\n    var martenSettings = sp.GetRequiredService<IOptions<MartenSettings>>().Value;\n\n    if (!string.IsNullOrEmpty(martenSettings.SchemaName))\n    {\n        options.Events.DatabaseSchemaName = martenSettings.SchemaName;\n        options.DatabaseSchemaName = martenSettings.SchemaName;\n    }\n\n    return options;\n}).UseLightweightSessions();\n```\n\n----------------------------------------\n\nTITLE: Enabling Unique Index on Event Id\nDESCRIPTION: This code snippet demonstrates how to enable a unique index on the `id` column of the `mt_events` table. This index can be useful for referencing events from external systems. The code configures the Marten document store to enable the `EnableUniqueIndexOnEventId` option within the `Events` configuration.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/storage.md#_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\nbuilder.Services.AddMarten(opts =>\n{\n    opts.Connection(\"some connection string\");\n\n    // Add the unique index to the id field\n    opts.Events.EnableUniqueIndexOnEventId = true;\n});\n```\n\n----------------------------------------\n\nTITLE: Adding days to current date using Postgres interval\nDESCRIPTION: This SQL snippet demonstrates how to add 5 days to the current timestamp in Postgres using the `interval` type.  It adds an interval of '5 days' to the `now()` function, which returns the current timestamp. The `::interval` cast is used to treat the string '5 days' as an interval.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/postgres/dates.md#_snippet_1\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT now() + ‘5 days’::interval;\n```\n\n----------------------------------------\n\nTITLE: Custom IRetryPolicy Implementation in Marten (C#)\nDESCRIPTION: This code snippet demonstrates a custom implementation of the `IRetryPolicy` interface in Marten for handling failing database operations. It retries a preconfigured number of times and includes an optional predicate based on the thrown exception type. It requires a dependency on Npgsql and uses asynchronous operations for retries.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/advanced/retrypolicy.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic class SampleRetryPolicy : IRetryPolicy\n{\n    private readonly int _maxRetries;\n    private readonly Func<Exception, bool> _exceptionPredicate;\n\n    public SampleRetryPolicy(int maxRetries = 3, Func<Exception, bool> exceptionPredicate = null)\n    {\n        _maxRetries = maxRetries;\n        _exceptionPredicate = exceptionPredicate ?? (_ => true);\n    }\n\n    public async Task<bool> ShouldRetry(Exception ex, int attempt, CancellationToken token)\n    {\n        if (attempt > _maxRetries)\n        {\n            return false;\n        }\n\n        return _exceptionPredicate(ex);\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining IConfigureMarten Interface in C#\nDESCRIPTION: This code defines the `IConfigureMarten` interface, which is used to register additional Marten configuration.  The configuration is applied after the initial `AddMarten()` configuration, but before the `DocumentStore` is initialized. It allows users to modify the Marten `StoreOptions` within a service provider context.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/hostbuilder.md#_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\n/// <summary>\n///     Mechanism to register additional Marten configuration that is applied after AddMarten()\n///     configuration, but before DocumentStore is initialized\n/// </summary>\npublic interface IConfigureMarten\n{\n    void Configure(IServiceProvider services, StoreOptions options);\n}\n```\n\n----------------------------------------\n\nTITLE: Marten Async Daemon Command Line\nDESCRIPTION: Illustrates various command line options available for managing Marten asynchronous projections, including starting the daemon, listing projections, rebuilding projections, and specifying tenants for multi-tenant databases.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/async-daemon.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ndotnet run -- projections\n```\n\nLANGUAGE: bash\nCODE:\n```\ndotnet run -- projections -i\n```\n\nLANGUAGE: bash\nCODE:\n```\ndotnet run -- projections --interactive\n```\n\nLANGUAGE: bash\nCODE:\n```\ndotnet run -- projections --list\n```\n\nLANGUAGE: bash\nCODE:\n```\ndotnet run -- projections --projection [shard name]\n```\n\nLANGUAGE: bash\nCODE:\n```\ndotnet run -- projections -p [shard name]\n```\n\nLANGUAGE: bash\nCODE:\n```\ndotnet run -- projections --rebuild\n```\n\nLANGUAGE: bash\nCODE:\n```\ndotnet run -- projections -i --rebuild\n```\n\nLANGUAGE: bash\nCODE:\n```\ndotnet run -- projections --rebuild -p [shard name]\n```\n\nLANGUAGE: bash\nCODE:\n```\ndotnet run -- projections --rebuild --tenant tenant1\n```\n\n----------------------------------------\n\nTITLE: Creating a Table Conditionally\nDESCRIPTION: This snippet demonstrates how to create a table in PostgreSQL only if it doesn't already exist, using the `CREATE TABLE IF NOT EXISTS` syntax.  This statement prevents errors that would occur if the table already existed and simplifies the table creation process.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/postgres/if-statements.md#_snippet_4\n\nLANGUAGE: sql\nCODE:\n```\nCREATE TABLE IF NOT EXISTS Product (….\n```\n\n----------------------------------------\n\nTITLE: C# code example with region tags\nDESCRIPTION: This example shows how to annotate existing C# files with unique #region/#endregion pairs for inclusion in the documentation using MarkdownSnippets.\nSOURCE: https://github.com/jasperfx/marten/blob/master/CONTRIBUTING.md#_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n#region sample_my_unique_name\n// Your code example here\n#endregion\n```\n\n----------------------------------------\n\nTITLE: Querying IEnumerable with Any() in Marten (C#)\nDESCRIPTION: Demonstrates querying over IEnumerables using the `Any()` method for equality in Marten, similar to `Contains()`. The example creates documents with lists of integers and queries for documents where the list contains a specific integer or if the list contains any element at all.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/child-collections.md#_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n[Fact]\npublic async Task query_against_number_list_with_any()\n{\n    var doc1 = new DocWithLists { Numbers = new List<int> { 1, 2, 3 } };\n    var doc2 = new DocWithLists { Numbers = new List<int> { 3, 4, 5 } };\n    var doc3 = new DocWithLists { Numbers = new List<int> { 5, 6, 7 } };\n    var doc4 = new DocWithLists { Numbers = new List<int> { } };\n\n    theSession.Store(doc1, doc2, doc3, doc4);\n\n    await theSession.SaveChangesAsync();\n\n    theSession.Logger = new TestOutputMartenLogger(_output);\n\n    theSession.Query<DocWithLists>().Where(x => x.Numbers.Any(_ => _ == 3)).ToArray()\n        .Select(x => x.Id).ShouldHaveTheSameElementsAs(doc1.Id, doc2.Id);\n\n    // Or without any predicate\n    theSession.Query<DocWithLists>()\n        .Count(x => x.Numbers.Any()).ShouldBe(3);\n}\n```\n\n----------------------------------------\n\nTITLE: Mermaid Class Diagram - Async Daemon Class Diagram\nDESCRIPTION: This Mermaid diagram visually represents the class relationships within the Marten V4 asynchronous daemon architecture. It shows the interactions between `IHostedService`, `NodeAgent`, `LeaderMode`, `AgentMode`, `HighWaterDetector`, and `IProjectionAgent`, illustrating how the daemon operates in both leader and agent modes.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/diagrams/v4eventstore.md#_snippet_1\n\nLANGUAGE: mermaid\nCODE:\n```\nclassDiagram\n\nclass IHostedService {\n    <<interface>>\n}\n\nclass NodeAgent\n\nNodeAgent ..|> IHostedService\n\nclass LeaderMode\nclass AgentMode\n\nNodeAgent --> LeaderMode: if the leader\nNodeAgent --> AgentMode: if not the leader\n\nNodeAgent ..> IProjectionAgent: 0..*\n\nclass HighWaterDetector\n\nLeaderMode --> HighWaterDetector : Uses\n\n\n\n```\n\n----------------------------------------\n\nTITLE: In List (C#)\nDESCRIPTION: To find one of for a list you can use this strategy:\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/linq.md#_snippet_33\n\nLANGUAGE: C#\nCODE:\n```\nvar numbers = new List<int> {1, 2, 3};\nvar targets = session.Query<Target>().Where(x => x.Number.In(numbers)).ToList();\n```\n\n----------------------------------------\n\nTITLE: Defining Order Events for Command Handling in C#\nDESCRIPTION: This code defines the events related to the `Order` aggregate, including `OrderShipped`, `OrderCreated`, `OrderReady`, and `ItemReady`. These events represent state changes in the order fulfillment process and are used to update the aggregate's state.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/scenarios/command_handler_workflow.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic record OrderShipped;\npublic record OrderCreated(Item[] Items);\npublic record OrderReady;\n\npublic record ItemReady(string Name);\n```\n\n----------------------------------------\n\nTITLE: Introducing a new event type - C#\nDESCRIPTION: This code snippet illustrates how to introduce a new event type to expand an existing event in Marten. It transforms the `MembersJoined` event into a series of events, one for each member. This is akin to versioning an event.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/scenarios/copyandtransformstream.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:scenario-copyandtransformstream-newevent]>\n```\n\n----------------------------------------\n\nTITLE: GitHub Actions Test Report Generation - Dockerfile\nDESCRIPTION: This YAML snippet integrates test report generation into a GitHub Actions workflow. If the tests are not skipped and either succeed or fail, it uses the dorny/test-reporter action to generate and publish test reports from TRX files. The configuration specifies the report name, path to TRX files, reporter type, and lists failed test suites and tests.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/devops/devops.md#_snippet_11\n\nLANGUAGE: Dockerfile\nCODE:\n```\n        - uses: dorny/test-reporter@v1\n            if: ${{ env.SKIP_TESTS == 'false' && (success() || failure()) }}\n            with:\n                name: Testreport\n                path: \"**/*.trx\"\n                reporter: dotnet-trx\n                list-suites: 'failed'\n                list-tests: 'failed'\n```\n\n----------------------------------------\n\nTITLE: PLV8 Function Example (SQL)\nDESCRIPTION: This SQL snippet shows the structure of a PLV8 function generated by Marten when loading a Javascript transformation.  It wraps the Javascript code, exposes it to Postgresql, and sets relevant function properties such as `LANGUAGE plv8`, `IMMUTABLE`, and `STRICT`.  The function takes a JSONB document as input and returns a transformed JSONB document based on the embedded Javascript logic.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/advanced/javascript_transformations.md#_snippet_7\n\nLANGUAGE: sql\nCODE:\n```\nCREATE OR REPLACE FUNCTION public.mt_transform_get_fullname(doc jsonb)\n  RETURNS jsonb AS\n$BODY$\n\n  var module = {export: {}};\n\nmodule.exports = function (doc) {\n    return {fullname: doc.FirstName + ' ' + doc.LastName};\n}\n\n  var func = module.exports;\n\n  return func(doc);\n\n$BODY$\n  LANGUAGE plv8 IMMUTABLE STRICT\n  COST 100;\n```\n\n----------------------------------------\n\nTITLE: Append Element to Child Collection in Marten (C#)\nDESCRIPTION: This snippet demonstrates how to append a complex element to a child collection within a Marten document using the `Patch.Append()` operation. It stores a `Target` object, appends a new `child` element to its `Children` collection, and verifies the change by loading the document again. Dependencies: Marten, Xunit, Shouldly.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/partial-updates-patching.md#_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic async Task append_complex_element()\n{\n    var target = Target.Random(true);\n    var initialCount = target.Children.Length;\n\n    var child = Target.Random();\n\n    theSession.Store(target);\n    await theSession.SaveChangesAsync();\n\n    theSession.Patch<Target>(target.Id).Append(x => x.Children, child);\n    await theSession.SaveChangesAsync();\n\n    using (var query = theStore.QuerySession())\n    {\n        var target2 = query.Load<Target>(target.Id);\n        target2.Children.Length.ShouldBe(initialCount + 1);\n\n        target2.Children.Last().Id.ShouldBe(child.Id);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Aggregate Class with Apply Methods in C#\nDESCRIPTION: This code snippet demonstrates how to define an aggregate class (`QuestParty`) with `Apply` methods for handling events.  The `Apply` methods are used to incrementally update the state of the aggregate object based on incoming events. The aggregate is a record for immutable updates.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/index.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed record QuestParty(Guid Id, List<string> Members)\n{\n    // These methods take in events and update the QuestParty\n    public static QuestParty Create(QuestStarted started) => new(started.QuestId, []);\n    public static QuestParty Apply(MembersJoined joined, QuestParty party) =>\n        party with\n        {\n            Members = party.Members.Union(joined.Members).ToList()\n        };\n\n    public static QuestParty Apply(MembersDeparted departed, QuestParty party) =>\n        party with\n        {\n            Members = party.Members.Where(x => !departed.Members.Contains(x)).ToList()\n        };\n\n    public static QuestParty Apply(MembersEscaped escaped, QuestParty party) =>\n        party with\n        {\n            Members = party.Members.Where(x => !escaped.Members.Contains(x)).ToList()\n        };\n}\n```\n\n----------------------------------------\n\nTITLE: Insert Element into Child Collection in Marten (C#)\nDESCRIPTION: This snippet shows how to insert a complex element at the beginning of a child collection within a Marten document using the `Patch.Insert()` operation.  It stores a `Target` object, inserts a new `child` element to the `Children` collection at index 0, and validates the insertion. Dependencies: Marten, Xunit, Shouldly.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/partial-updates-patching.md#_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic async Task insert_first_complex_element()\n{\n    var target = Target.Random(true);\n    var initialCount = target.Children.Length;\n\n    var child = Target.Random();\n\n    theSession.Store(target);\n    await theSession.SaveChangesAsync();\n\n    theSession.Patch<Target>(target.Id).Insert(x => x.Children, child);\n    await theSession.SaveChangesAsync();\n\n    using (var query = theStore.QuerySession())\n    {\n        var target2 = query.Load<Target>(target.Id);\n        target2.Children.Length.ShouldBe(initialCount + 1);\n\n        target2.Children.Last().Id.ShouldBe(child.Id);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Create Full Text Index for Multiple Properties via Attribute (C#)\nDESCRIPTION: This code snippet demonstrates how to create a single full text index for multiple properties using the `[FullTextIndex]` attribute on multiple properties with the same `IndexName`. It indexes both 'FirstName' and 'LastName' as a single index named \"Names\". The index will be created with the default 'english' language configuration if no language is specified. Requires Marten and PostgreSQL version 10.0 or above.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/full_text.md#_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic class MyDocument\n{\n    public Guid Id { get; set; }\n\n    [FullTextIndex(IndexName = \"Names\")]\n    public string FirstName { get; set; }\n\n    [FullTextIndex(IndexName = \"Names\")]\n    public string LastName { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Regular Text Search Query - Marten C#\nDESCRIPTION: Executes a regular text search query using the `Search()` extension method on a Marten `IQueryable`. It searches the indexed text fields for the term 'somefilter' using the default 'english' language configuration. Requires the Marten library.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/full-text.md#_snippet_11\n\nLANGUAGE: cs\nCODE:\n```\nvar posts = session.Query<BlogPost>()\n    .Where(x => x.Search(\"somefilter\"))\n    .ToList();\n```\n\n----------------------------------------\n\nTITLE: Marten Compiled Query Example\nDESCRIPTION: Illustrates a compiled query class named `FindByFirstName` that implements `ICompiledQuery<User, User>`.  The query retrieves the first user with a matching first name. The `FirstName` property is used as a parameter in the compiled query.  The `QueryIs` method defines the LINQ expression to execute the query.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/batched-queries.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic class FindByFirstName: ICompiledQuery<User, User>\n{\n    public string FirstName { get; set; }\n\n    public Expression<Func<IMartenQueryable<User>, User>> QueryIs()\n    {\n        return q => q.FirstOrDefault(x => x.FirstName == FirstName);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering custom IConfigureMarten implementation in C#\nDESCRIPTION: This code snippet demonstrates how to register a custom `IConfigureMarten` implementation in the IoC container using `AddSingleton`. It also shows how to register `IConfigureMarten<T>` for multiple databases. This enables modular configuration of Marten, allowing different modules to configure their own document stores independently.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/hostbuilder.md#_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\npublic static IServiceCollection AddUserModule2(this IServiceCollection services)\n{\n    // This applies additional configuration to the main Marten DocumentStore\n    // that is configured elsewhere\n    services.AddSingleton<IConfigureMarten, UserMartenConfiguration>();\n\n    // If you're using multiple databases per Host, register `IConfigureMarten<T>`, like this:\n    services.AddSingleton<IConfigureMarten<IInvoicingStore>, InvoicingStoreConfiguration>();\n\n    // Other service registrations specific to the User submodule\n    // within the bigger system\n\n    return services;\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Event Store Schema - Marten - C#\nDESCRIPTION: This snippet demonstrates how to explicitly set the database schema name for the event store tables in Marten. By default, the event store uses the same schema as the document store. This configuration allows you to move the event storage to a separate schema, such as 'events'.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/configuration.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(opts =>\n{\n    opts.Connection(\"some connection string\");\n\n    opts.Events.DatabaseSchemaName = \"events\";\n});\n```\n\n----------------------------------------\n\nTITLE: Deleting Aggregate by Event Type (Marten, C#)\nDESCRIPTION: Demonstrates how to delete a Trip aggregate when a TripAborted event is encountered within a Marten projection. This is achieved by calling DeleteEvent<TripAborted>() inside the TripProjection constructor. This sets up the projection to automatically delete the aggregate when the specified event occurs.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/aggregate-projections.md#_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\npublic class TripProjection: SingleStreamProjection<Trip>\n{\n    public TripProjection()\n    {\n        // The current Trip aggregate would be deleted if\n        // the projection encountered a TripAborted event\n        DeleteEvent<TripAborted>();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Benchmark Configuration Details\nDESCRIPTION: This snippet displays the benchmark configuration, including the BenchmarkDotNet version, operating system, processor details, .NET runtime version, and jitter. It is used to understand the environment in which the benchmarks were executed.\nSOURCE: https://github.com/jasperfx/marten/blob/master/benchmarks/2.0.baseline/results/BulkLoading-report-github.md#_snippet_0\n\nLANGUAGE: INI\nCODE:\n```\nBenchmarkDotNet=v0.10.1, OS=Microsoft Windows NT 6.1.7601 Service Pack 1\nProcessor=Intel(R) Core(TM) i7-4980HQ CPU 2.80GHz, ProcessorCount=4\nFrequency=10000000 Hz, Resolution=100.0000 ns, Timer=UNKNOWN\n  [Host]     : Clr 4.0.30319.42000, 64bit RyuJIT-v4.6.1076.0\n  Job-DNINOD : Clr 4.0.30319.42000, 64bit RyuJIT-v4.6.1076.0\n\nWarmupCount=2  Gen 0=834.5588  Allocated=7.74 MB\n```\n\n----------------------------------------\n\nTITLE: Boolean Queries (C#)\nDESCRIPTION: Linq queries against boolean properties can use shorthand mechanisms in `Where()` clauses like so:\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/linq.md#_snippet_26\n\nLANGUAGE: C#\nCODE:\n```\npublic class Target\n{\n    public Guid Id { get; set; }\n    public string[] Tags { get; set; }\n    public List<string> ListTags {get; set;}\n    public List<int> Numbers { get; set; }\n    public IList<Child> Children { get; set; }\n    public string String { get; set; }\n    public bool Flag {get; set;}\n\n}\n\npublic class Child\n{\n    public string Name { get; set; }\n    public int Age { get; set; }\n}\n\nvar trueFlags = session.Query<Target>().Where(x => x.Flag).ToList();\nvar falseFlags = session.Query<Target>().Where(x => !x.Flag).ToList();\n```\n\n----------------------------------------\n\nTITLE: Registering Kafka Subscription with IoC in C#\nDESCRIPTION: This line of code initializes a builder for building the host. This will later be used to register the KafkaSubscription.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/subscriptions.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\n```\n\n----------------------------------------\n\nTITLE: Define Travel Event with Movements and Stops (C#)\nDESCRIPTION: This C# code defines the `Travel` event, which contains a list of `Movement` objects and a list of `Stop` objects. This is used to demonstrate the 'fan out' feature of projections in Marten. The properties `Movements` and `Stops` are lists that will be processed separately within the projection.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/multi-stream-projections.md#_snippet_11\n\nLANGUAGE: cs\nCODE:\n```\npublic IList<Movement> Movements { get; set; } = new List<Movement>();\npublic List<Stop> Stops { get; set; } = new();\n```\n\n----------------------------------------\n\nTITLE: Defining New Event Type\nDESCRIPTION: This snippet defines the new event type `ShoppingCartOpenedWithStatus` after an upcasting transformation. It includes `ShoppingCartId`, `Client` (nested object containing `Id` and `Name`), and `Status` properties.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/versioning.md#_snippet_11\n\nLANGUAGE: cs\nCODE:\n```\npublic record ShoppingCartOpenedWithStatus(\n    Guid ShoppingCartId,\n    Client Client,\n    ShoppingCartStatus Status\n);\n\npublic record Client(\n    Guid Id,\n    string Name = \"Unknown\"\n);\n\npublic enum ShoppingCartStatus\n{\n    Pending = 1,\n    Opened = 2,\n    Confirmed = 3,\n    Cancelled = 4\n}\n```\n\n----------------------------------------\n\nTITLE: Get Distinct Strings (C#)\nDESCRIPTION: New in Marten 1.2 is support for the Linq `Distinct()` operator:\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/linq.md#_snippet_24\n\nLANGUAGE: C#\nCODE:\n```\npublic class Target\n{\n    public Guid Id { get; set; }\n    public string[] Tags { get; set; }\n    public List<string> ListTags {get; set;}\n    public List<int> Numbers { get; set; }\n    public IList<Child> Children { get; set; }\n\n}\n\npublic class Child\n{\n    public string Name { get; set; }\n    public int Age { get; set; }\n}\n\nvar targets = session.Query<Target>().Select(x => x.String).Distinct().ToList();\n```\n\n----------------------------------------\n\nTITLE: Wiring Async Daemon Listener in Marten\nDESCRIPTION: This C# snippet shows how to register a custom `IChangeListener` implementation (`FakeListener` in this case) with Marten's asynchronous daemon update process.  The listener is added to the `AsyncListeners` collection within the `StoreOptions` configuration.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/diagnostics.md#_snippet_6\n\nLANGUAGE: cs\nCODE:\n```\nvar listener = new FakeListener();\nStoreOptions(x =>\n{\n    x.Projections.Add(new TripProjectionWithCustomName(), ProjectionLifecycle.Async);\n    x.Projections.AsyncListeners.Add(listener);\n});\n```\n\n----------------------------------------\n\nTITLE: Project Setup Workflow Diagram - Mermaid\nDESCRIPTION: This Mermaid diagram visualizes the end-to-end DevOps workflow for a Marten application. It starts with project setup, including application and migrations projects, progresses through Dockerfile configuration and dependency management, and continues with building, testing, and pushing Docker images using GitHub Actions. The process concludes with deployment to Amazon EKS using Octopus Deploy and Kubernetes.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/devops/devops.md#_snippet_0\n\nLANGUAGE: Mermaid\nCODE:\n```\ngraph TD\n    A[Start: Project Setup] -->|Set up two projects| B[Migrations Project Setup]\n    A -->|Set up Dockerfile and dependencies| C[Application Project Setup]\n    B --> D[Add Migration Scripts]\n    C --> E[Building and Testing with GitHub Actions]\n    D --> E\n    E --> F[Building and Pushing Docker Images]\n    F --> G[Deployment with Octopus Deploy]\n    G --> H[Configure Octopus for EKS Deployment]\n    H --> I[Define Kubernetes YAML with Migrations as Init Container]\n    I --> J[Deploy to Amazon EKS]\n    J --> K[End: Application Deployed and Running]\n```\n\n----------------------------------------\n\nTITLE: Event Type Name Migration Options\nDESCRIPTION: This snippet demonstrates how to register a custom mapping in Marten when an event type name has changed. By using `Events.EventMappingFor`, Marten can associate the new `ConfirmedOrderStatusChanged` event with the old event type name (`order_status_changed`).\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/events/versioning/index.md#_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nstoreOptions.Events.EventMappingFor<ConfirmedOrderStatusChanged>(\"order_status_changed\");\n```\n\n----------------------------------------\n\nTITLE: Upcasting with Json.NET JObject in Marten\nDESCRIPTION: Demonstrates how to upcast events using Json.NET's `JObject` to transform raw JSON data. It retrieves properties from the `JObject` using string indexers and casts them to the appropriate types. An `IClientRepository` dependency is used. The example includes a warning about potential N+1 performance issues during deserialization if the `UpcastAsync` method executes resource-intensive operations.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/versioning.md#_snippet_34\n\nLANGUAGE: cs\nCODE:\n```\npublic class ShoppingCartOpenedAsyncOnlyUpcaster:\n    AsyncOnlyEventUpcaster<ShoppingCartOpenedWithStatus>\n{\n    private readonly IClientRepository _clientRepository;\n\n    public ShoppingCartOpenedAsyncOnlyUpcaster(IClientRepository clientRepository) =>\n        _clientRepository = clientRepository;\n\n    public override string EventTypeName => \"shopping_cart_opened\";\n\n    protected override async Task<ShoppingCartOpenedWithStatus> UpcastAsync(\n        JObject oldEvent,\n        CancellationToken ct\n    )\n    {\n        var clientId = (Guid)oldEvent[\"ClientId\"]!;\n        // WARNING: UpcastAsync method is called each time old event\n        // is read from database and deserialized.\n        // We discourage to run resource consuming methods here.\n        // It might end up with N+1 problem.\n        var clientName = await _clientRepository.GetClientName(clientId, ct);\n\n        return new ShoppingCartOpenedWithStatus(\n            (Guid)oldEvent[\"ShoppingCartId\"]!,\n            new Client(clientId, clientName),\n            ShoppingCartStatus.Opened\n        );\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Marking C# Code Snippets for Documentation\nDESCRIPTION: This snippet demonstrates how to mark C# code blocks for inclusion in documentation using named regions.  The region name should start with `sample_` and use kebab-case.  This allows MarkdownSnippets to extract the code for use in the documentation files.\nSOURCE: https://github.com/jasperfx/marten/blob/master/README.md#_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\n#region sample_my-snippet\n// code sample/snippet\n// ...\n#endregion\n```\n\n----------------------------------------\n\nTITLE: Deep Calculated Index SQL (Postgresql)\nDESCRIPTION: Shows the SQL generated by Marten for creating a calculated index on a nested property.  This SQL uses JSON operators to access the nested property and casts the value to an integer.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/indexing/computed-indexes.md#_snippet_3\n\nLANGUAGE: SQL\nCODE:\n```\nCREATE INDEX mt_doc_target_idx_inner_color ON public.mt_doc_target (((data -> 'Inner' ->> 'Color')::int));\n```\n\n----------------------------------------\n\nTITLE: Query with only the WHERE clause\nDESCRIPTION: Demonstrates a simple query using custom SQL for the WHERE clause. It leverages Marten's convention of the 'data' field representing the JSONB data in the database table.  Marten automatically constructs the complete SQL statement by adding the SELECT and FROM clauses when they are not present in the supplied SQL.  The database table name follows the convention 'mt_doc_[name of the class]'.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/sql.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvar users = session.Query<User>(\"where data ->> 'FirstName' = 'Jeremy'\").ToList();\n```\n\n----------------------------------------\n\nTITLE: Registering Value Types with Marten StoreOptions (Extended)\nDESCRIPTION: This snippet shows how to register several value types with Marten's `StoreOptions`.  This step is essential for Marten to properly handle these custom types within LINQ queries. `opts` represents the `StoreOptions` configured during Marten's setup.  The registration informs Marten about the value types, allowing their seamless usage in LINQ expressions.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/identity.md#_snippet_24\n\nLANGUAGE: cs\nCODE:\n```\n// opts is a StoreOptions just like you'd have in\n// AddMarten() calls\nopts.RegisterValueType(typeof(GuidId));\nopts.RegisterValueType(typeof(UpperLimit));\nopts.RegisterValueType(typeof(LowerLimit));\nopts.RegisterValueType(typeof(Description));\n```\n\n----------------------------------------\n\nTITLE: Query with Basic Operators using Linq in Marten (C#)\nDESCRIPTION: Shows how to use basic Linq operators such as `Where()` to filter documents based on various criteria.  The example includes checks for equality, inequality, greater than, and less than conditions on document properties.  This assumes properties like `Number`, `String`, and `Date` exist on the document type.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/linq.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvar list = session.Query<Target>()\n    .Where(x => x.Number == 3)\n    .Where(x => x.String != \"foo\")\n    .Where(x => x.Date > DateTime.Today.AddDays(-1))\n    .Where(x => x.Date <= DateTime.Today)\n    .ToList();\n```\n\n----------------------------------------\n\nTITLE: Generated SQL for Paged Query (SQL)\nDESCRIPTION: This SQL statement shows the generated query by Marten when using `Stats()` and `Take()` for paging. It selects data and IDs from the `mt_doc_target` table, filters based on the `Number` property, calculates the total row count using `count(*) OVER()`, and limits the results to 5 rows.  The query demonstrates how Marten efficiently handles paging with total count retrieval.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/paging.md#_snippet_3\n\nLANGUAGE: SQL\nCODE:\n```\nselect d.data, d.id, count(*) OVER() as total_rows from public.mt_doc_target as d \nwhere CAST(d.data ->> 'Number' as integer) > :arg0 LIMIT 5\n```\n\n----------------------------------------\n\nTITLE: Customizing Calculated Index (Marten, C#)\nDESCRIPTION: Shows how to customize a calculated index, including changing the index method, casing, name, concurrency, uniqueness, tenancy scope, and adding a predicate.  Requires Marten and Postgresql. Assumes a `Target` document type with a `Number` property and a `User` document type with `LastName` property.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/indexing/computed-indexes.md#_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n    _.Connection(ConnectionSource.ConnectionString);\n\n    // The second, optional argument to Index()\n    // allows you to customize the calculated index\n    _.Schema.For<Target>().Index(x => x.Number, x =>\n    {\n        // Change the index method to \"brin\"\n        x.Method = IndexMethod.brin;\n\n        // Force the index to be generated with casing rules\n        x.Casing = ComputedIndex.Casings.Lower;\n\n        // Override the index name if you want\n        x.Name = \"mt_my_name\";\n\n        // Toggle whether or not the index is concurrent\n        // Default is false\n        x.IsConcurrent = true;\n\n        // Toggle whether or not the index is a UNIQUE\n        // index\n        x.IsUnique = true;\n\n        // Toggle whether index value will be constrained unique in scope of whole document table (Global)\n        // or in a scope of a single tenant (PerTenant)\n        // Default is Global\n        x.TenancyScope = Marten.Schema.Indexing.Unique.TenancyScope.PerTenant;\n\n        // Partial index by supplying a condition\n        x.Predicate = \"(data ->> 'Number')::int > 10\";\n    });\n\n    // For B-tree indexes, it's also possible to change\n    // the sort order from the default of \"ascending\"\n    _.Schema.For<User>().Index(x => x.LastName, x =>\n    {\n        // Change the index method to \"brin\"\n        x.SortOrder = SortOrder.Desc;\n    });\n});\n```\n\n----------------------------------------\n\nTITLE: Ignore Index on Marten Document Table in C#\nDESCRIPTION: This code snippet demonstrates how to configure a Marten `DocumentStore` to ignore a specific index on a document table. It uses the `IgnoreIndex` method within the `DocumentStore.For` configuration. The `Connection` is established using a connection string. The index named \"foo\" on the `User` document table will be ignored by Marten's schema management.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/indexing/ignore-indexes.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(opts =>\n{\n    opts.Connection(ConnectionSource.ConnectionString);\n    opts.Schema.For<User>().IgnoreIndex(\"foo\");\n});\n```\n\n----------------------------------------\n\nTITLE: DDL Template for Postgresql Functions (SQL)\nDESCRIPTION: This SQL snippet shows an example of a DDL template file for Postgresql functions generated by Marten. The template includes statements for altering the function owner and granting execute permissions to a specific role. Placeholders such as %SCHEMA%, %FUNCTIONNAME%, and %SIGNATURE% are used and will be replaced by Marten with the actual values when the template is applied. The function signature is important for uniquely identifying overloaded functions.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/schema/authorization.md#_snippet_6\n\nLANGUAGE: SQL\nCODE:\n```\nALTER FUNCTION %SCHEMA%.%FUNCTIONNAME%(%SIGNATURE%) OWNER TO \"SchemaOwners\";\nGRANT EXECUTE ON FUNCTION  %SCHEMA%.%FUNCTIONNAME%(%SIGNATURE%) TO \"ServiceAccountRole\";\n```\n\n----------------------------------------\n\nTITLE: Logging into Docker Hub with GitHub Actions\nDESCRIPTION: This step logs into Docker Hub using the docker/login-action. It uses secrets stored in the GitHub repository for username and password.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/devops/devops.md#_snippet_14\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Login to Docker Hub\n  uses: docker/login-action@v1\n  with:\n    username: ${{ secrets.DOCKER_HUB_USERNAME }}\n    password: ${{ secrets.DOCKER_HUB_ACCESS_TOKEN }}\n```\n\n----------------------------------------\n\nTITLE: Basic PL/pgSQL Anonymous Code Block\nDESCRIPTION: This code snippet demonstrates a basic anonymous code block in PL/pgSQL.  It shows the structure for executing PL/pgSQL code within a PostgreSQL environment. No specific actions are performed other than establishing the block structure.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/postgres/if_statements.md#_snippet_0\n\nLANGUAGE: PL/pgSQL\nCODE:\n```\nDO $$\nBEGIN\n\n    // your sql here…\n\nEND\n$$;\n```\n\n----------------------------------------\n\nTITLE: MartenRegistry Subclass - C#\nDESCRIPTION: Illustrates how to create a subclass of `MartenRegistry` to configure a Marten document store using a fluent interface. Declarations are placed in the constructor function of the registry.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/index.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic class MyMartenRegistry : MartenRegistry\n{\n    public MyMartenRegistry()\n    {\n        For<MyDocument>().Identity(x => x.Id);        \n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Is Superset Of (C#)\nDESCRIPTION: \nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/linq.md#_snippet_34\n\nLANGUAGE: C#\nCODE:\n```\nvar numbers = new List<int> {1, 2};\nvar targets = session.Query<Target>().Where(x => x.Numbers.IsSupersetOf(numbers)).ToList();\n```\n\n----------------------------------------\n\nTITLE: Resetting Marten Data using IHost\nDESCRIPTION: Demonstrates resetting Marten data using the IHost extension method ResetAllMartenDataAsync(). This deletes all current document and event data, then reapplies the configured initial data from the IHost instance. Requires an IHost instance configured with Marten and initial data.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/schema/cleaning.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .ConfigureServices(\n        services =>\n        {\n            services.AddMarten(\n                    opts =>\n                    {\n                        opts.Connection(ConnectionSource.ConnectionString);\n                        opts.Logger(new TestOutputMartenLogger(_output));\n                    }\n                )\n                .InitializeWith(new Users());\n        }\n    )\n    .StartAsync();\n\nawait host.ResetAllMartenDataAsync();\n```\n\n----------------------------------------\n\nTITLE: Defining IMartenLogger Interface\nDESCRIPTION: This C# snippet defines the `IMartenLogger` interface, which allows plugging in custom logging to Marten's `IDocumentStore`, `IQuerySession`, and `IDocumentSession`. It also defines the `IMartenSessionLogger` interface for session-specific logging, including logging commands, batches, failures, and saved changes.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/diagnostics.md#_snippet_7\n\nLANGUAGE: cs\nCODE:\n```\n/// <summary>\n///     Records command usage, schema changes, and sessions within Marten\n/// </summary>\npublic interface IMartenLogger\n{\n    /// <summary>\n    ///     Called when the session is initialized\n    /// </summary>\n    /// <param name=\"session\"></param>\n    /// <returns></returns>\n    IMartenSessionLogger StartSession(IQuerySession session);\n\n    /// <summary>\n    ///     Capture any DDL executed at runtime by Marten\n    /// </summary>\n    /// <param name=\"sql\"></param>\n    void SchemaChange(string sql);\n}\n\n/// <summary>\n///     Use to create custom logging within an IQuerySession or IDocumentSession\n/// </summary>\npublic interface IMartenSessionLogger\n{\n    /// <summary>\n    ///     Log a command that executed successfully\n    /// </summary>\n    /// <param name=\"command\"></param>\n    void LogSuccess(NpgsqlCommand command);\n\n    /// <summary>\n    ///     Log a command that failed\n    /// </summary>\n    /// <param name=\"command\"></param>\n    /// <param name=\"ex\"></param>\n    void LogFailure(NpgsqlCommand command, Exception ex);\n\n    /// <summary>\n    ///     Log a command that executed successfully\n    /// </summary>\n    /// <param name=\"batch\"></param>\n    void LogSuccess(NpgsqlBatch batch);\n\n    /// <summary>\n    ///     Log a batch that failed\n    /// </summary>\n    /// <param name=\"batch\"></param>\n    /// <param name=\"ex\"></param>\n    void LogFailure(NpgsqlBatch batch, Exception ex);\n\n    /// <summary>\n    /// Log a message for generic errors\n    /// </summary>\n    /// <param name=\"ex\"></param>\n    /// <param name=\"message\"></param>\n    /// <param name=\"batch\"></param>\n    void LogFailure(Exception ex, string message);\n\n    /// <summary>\n    ///     Called immediately after committing an IDocumentSession\n    ///     through SaveChanges() or SaveChangesAsync()\n    /// </summary>\n    /// <param name=\"session\"></param>\n    /// <param name=\"commit\"></param>\n    void RecordSavedChanges(IDocumentSession session, IChangeSet commit);\n\n    /// <summary>\n    ///     Called just before a command is to be executed. Use this to create\n    ///     performance logging of Marten operations\n    /// </summary>\n    /// <param name=\"command\"></param>\n    public void OnBeforeExecute(NpgsqlCommand command);\n\n    /// <summary>\n    ///     Called just before a command is to be executed. Use this to create\n    ///     performance logging of Marten operations\n    /// </summary>\n    /// <param name=\"command\"></param>\n    public void OnBeforeExecute(NpgsqlBatch batch);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a table using an existing sequence\nDESCRIPTION: This SQL snippet creates a table named `serial_two` that reuses the sequence `serial_one_id_seq` from the previous example for its `id` column.  It defines the column as `int` with a default value of `nextval('serial_one_id_seq')`. It then inserts two rows and selects all data from the table.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/postgres/types.md#_snippet_2\n\nLANGUAGE: SQL\nCODE:\n```\ncreate table if not exists serial_two (\n    id int not null default(nextval('serial_one_id_seq')),\n    name text\n);\n\ninsert into serial_two (name) values ('demi');\ninsert into serial_two (name) values ('nigel');\n\nselect * from serial_two;\n```\n\n----------------------------------------\n\nTITLE: Reading Inline Invoice Aggregate (C#)\nDESCRIPTION: Demonstrates how to read the current state of an `Invoice` aggregate using `LoadAsync()` when configured as an `Inline` projection. Because it's stored as a regular document in Marten, we can use `LoadAsync()` to get its latest state.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/read-aggregates.md#_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\npublic static async Task read_inline_invoice(\n    IQuerySession session,\n    Guid invoiceId)\n{\n    var invoice = await session\n        .LoadAsync<Invoice>(invoiceId);\n}\n```\n\n----------------------------------------\n\nTITLE: Using Query Statistics with Stats() in Marten (C#)\nDESCRIPTION: This C# code demonstrates how to retrieve query statistics using the `Stats()` method in Marten. It first queries for a count and then uses `Stats()` to obtain the total results while also retrieving a limited set of data using `Take()`.  The `ShouldBeGreaterThan` and `ShouldBeTrue` assertions come from a testing framework such as XUnit or NUnit.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/paging.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic void can_get_the_total_in_results()\n{\n    var count = theSession.Query<Target>().Count(x => x.Number > 10);\n    count.ShouldBeGreaterThan(0);\n\n    // We're going to use stats as an output\n    // parameter to the call below, so we\n    // have to declare the \"stats\" object\n    // first\n    QueryStatistics stats = null;\n\n    var list = theSession\n        .Query<Target>()\n        .Stats(out stats)\n        .Where(x => x.Number > 10).Take(5)\n        .ToList();\n\n    list.Any().ShouldBeTrue();\n\n    // Now, the total results data should\n    // be available\n    stats.TotalResults.ShouldBe(count);\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Maybe Soft Deleted Documents - C#\nDESCRIPTION: This snippet demonstrates how to include soft-deleted documents in a Linq query using the `MaybeDeleted()` method. This method allows you to retrieve both active and soft-deleted documents, overriding the default filtering behavior.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/advanced/soft_deletes.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nvar all = await session.Query<User>().Where(x => x.UserName.StartsWith(\"B\")).MaybeDeleted().ToListAsync();\nall.Count.ShouldBeGreaterThan(1);\n```\n\n----------------------------------------\n\nTITLE: Upcaster Class with Json.NET JObject\nDESCRIPTION: This snippet demonstrates how to upcast an event using a class that inherits from `EventUpcaster` with Json.NET's `JObject`.  It upcasts an event by accessing the old event data as a `JObject` and mapping its properties to the new event type.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/versioning.md#_snippet_20\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ShoppingCartOpenedUpcaster:\n    EventUpcaster<ShoppingCartOpenedWithStatus>\n{\n    public override string EventTypeName => \"shopping_cart_opened\";\n\n    protected override ShoppingCartOpenedWithStatus Upcast(JObject oldEvent) =>\n        new ShoppingCartOpenedWithStatus(\n            (Guid)oldEvent[\"ShoppingCartId\"]!,\n            new Client(\n                (Guid)oldEvent[\"ClientId\"]!\n            ),\n            ShoppingCartStatus.Opened\n        );\n}\n```\n\n----------------------------------------\n\nTITLE: Implement ISoftDeleted Interface - Marten - C#\nDESCRIPTION: Demonstrates how to enable soft deletes by implementing the `ISoftDeleted` interface on a document class.  The interface provides `Deleted` and `DeletedAt` properties which are used by Marten to track soft delete status. Requires Marten library.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/deletes.md#_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic class MySoftDeletedDoc: ISoftDeleted\n{\n    // Always have to have an identity of some sort\n    public Guid Id { get; set; }\n\n    // Is the document deleted? From ISoftDeleted\n    public bool Deleted { get; set; }\n\n    // When was the document deleted? From ISoftDeleted\n    public DateTimeOffset? DeletedAt { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Documents with Tenant Scoped Session in Marten (C#)\nDESCRIPTION: This code snippet demonstrates how to query User documents within a specific tenant using Marten's QuerySession. The session is scoped to the tenant \"tenant1\".  It retrieves a list of usernames. Requires Marten document store instance and Shouldly library for assertions.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/multi-tenancy.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n// When you query for data from the \"tenant1\" tenant,\n// you only get data for that tenant\nusing (var query = store.QuerySession(\"tenant1\"))\n{\n    query.Query<User>()\n        .Select(x => x.UserName)\n        .ToList()\n        .ShouldHaveTheSameElementsAs(\"Bill\", \"Lindsey\");\n}\n```\n\n----------------------------------------\n\nTITLE: MultiStreamProjection: Using IEvent Metadata for Document Identity\nDESCRIPTION: This example showcases how to use the `IEvent` metadata, specifically the `Timestamp` property, to determine the document identity within a `MultiStreamProjection`. The `CustomerInsightsProjection` aggregates customer creation and deletion events based on the date of the event, using the date as the document ID. It demonstrates the use of `IEvent<T>` to access event metadata within the projection.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/multi-stream-projections.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic class CustomerInsightsProjection : MultiStreamProjection<CustomerInsightsResponse, string>\n{\n\n    public CustomerInsightsProjection()\n    {\n        Identity<IEvent<CustomerCreated>>(x => DateOnly.FromDateTime(x.Timestamp.Date).ToString(CultureInfo.InvariantCulture));\n        Identity<IEvent<CustomerDeleted>>(x => DateOnly.FromDateTime(x.Timestamp.Date).ToString(CultureInfo.InvariantCulture));\n    }\n\n    public CustomerInsightsResponse Create(IEvent<CustomerCreated> @event)\n        => new(@event.Timestamp.Date.ToString(CultureInfo.InvariantCulture), DateOnly.FromDateTime(@event.Timestamp.DateTime), 1);\n\n    public CustomerInsightsResponse Apply(IEvent<CustomerCreated> @event, CustomerInsightsResponse current)\n        => current with { NewCustomers = current.NewCustomers + 1 };\n\n    public CustomerInsightsResponse Apply(IEvent<CustomerDeleted> @event, CustomerInsightsResponse current)\n        => current with { NewCustomers = current.NewCustomers - 1 };\n}\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Paging with ToPagedListAsync in Marten (C#)\nDESCRIPTION: This code snippet demonstrates how to use the `ToPagedListAsync` extension method in Marten for asynchronously retrieving paged data. It shows how to specify the page number and page size. It relies on an active Marten `theSession` and returns a Task that resolves to the paged list.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/paging.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvar pageNumber = 2;\nvar pageSize = 10;\n\nvar pagedList = await theSession.Query<Target>().ToPagedListAsync(pageNumber, pageSize);\n```\n\n----------------------------------------\n\nTITLE: Creating Gin Index on JSONB field in Marten\nDESCRIPTION: This code snippet demonstrates how to create a Gin index on the data field (JSONB) in a Marten-managed Postgresql table. The index is created using the `data_gin` syntax. The purpose is to improve the performance of ad-hoc queries against the JSONB document.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/gin_or_gist_index.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:IndexExamples]>\n```\n\n----------------------------------------\n\nTITLE: Define Types with Guid Identifiers\nDESCRIPTION: Introduces types with `Guid` identifiers, where a `Matter` field encapsulates the human-readable number reference. These types represent entities within the system that are referenced by user-friendly numeric identifiers.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/scenarios/usingsequenceforuniqueid.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:scenario-usingsequenceforuniqueid-setup-types]>\n```\n\n----------------------------------------\n\nTITLE: Static Using for Json.NET Transformations in Marten\nDESCRIPTION: This code shows the necessary using statement to enable the JsonTransformations static methods, allowing for concise syntax when working with Json.NET transformations.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/versioning.md#_snippet_28\n\nLANGUAGE: cs\nCODE:\n```\nusing static Marten.Services.Json.Transformations.JsonNet.JsonTransformations;\n```\n\n----------------------------------------\n\nTITLE: Query with Type Parameter Overload\nDESCRIPTION: Shows how to perform SQL queries using the non-generic `IQuerySession` extensions, allowing you to specify the document type at runtime.  The example uses the `dynamic` type to handle the returned data. It provides flexibility when the document type is not known at compile time.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/sql.md#_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nvar targetType = typeof(User);\ndynamic users = session.Query(targetType, \"where data ->> 'FirstName' = 'Jeremy'\").ToList();\n```\n\n----------------------------------------\n\nTITLE: Transforming the event stream - C#\nDESCRIPTION: This code snippet showcases how to copy and transform an event stream in Marten. It copies the existing stream to a new one while applying transforms to the event data being copied. This allows for removing unwanted events and introducing new ones based on existing data.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/scenarios/copyandtransformstream.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:scenario-copyandtransformstream-transform]>\n```\n\n----------------------------------------\n\nTITLE: Static Using for Json.NET Upcasting\nDESCRIPTION: This snippet shows the static using statement required to use the Json.NET upcasting helpers. It imports the `JsonTransformations` class from the `Marten.Services.Json.Transformations.JsonNet` namespace.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/versioning.md#_snippet_15\n\nLANGUAGE: csharp\nCODE:\n```\nusing static Marten.Services.Json.Transformations.JsonNet.JsonTransformations;\n```\n\n----------------------------------------\n\nTITLE: Benchmark Configuration\nDESCRIPTION: This snippet shows the configuration used for the benchmark, including the BenchmarkDotNet version, operating system, processor details, and .NET runtime version.\nSOURCE: https://github.com/jasperfx/marten/blob/master/benchmarks/2.0.baseline/results/EventActions-report-github.md#_snippet_0\n\nLANGUAGE: INI\nCODE:\n```\nBenchmarkDotNet=v0.10.1, OS=Microsoft Windows NT 6.1.7601 Service Pack 1\nProcessor=Intel(R) Core(TM) i7-4980HQ CPU 2.80GHz, ProcessorCount=4\nFrequency=10000000 Hz, Resolution=100.0000 ns, Timer=UNKNOWN\n  [Host]     : Clr 4.0.30319.42000, 64bit RyuJIT-v4.6.1076.0\n  Job-DNINOD : Clr 4.0.30319.42000, 64bit RyuJIT-v4.6.1076.0\n\nWarmupCount=2  Allocated=1.88 MB\n```\n\n----------------------------------------\n\nTITLE: Initializing Full Text Index with Custom Settings (C#)\nDESCRIPTION: This code snippet demonstrates how to create a full-text index for a specific property (`FirstName`) with custom settings such as index name and language configuration (`RegConfig`) in Marten using the fluent interface of `StoreOptions`. It indexes only the specified property with the provided custom settings.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/full-text.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n    _.Connection(ConnectionSource.ConnectionString);\n\n    // This creates\n    _.Schema.For<User>().FullTextIndex(\n        index =>\n        {\n            index.Name = \"mt_custom_italian_user_fts_idx\";\n            index.RegConfig = \"italian\";\n        },\n        d => d.FirstName);\n});\n```\n\n----------------------------------------\n\nTITLE: Querying All Raw Events in Marten (C#)\nDESCRIPTION: This snippet shows how to query all raw events from the Marten event store using `QueryAllRawEvents()`. It uses LINQ's `Where()` and `OrderBy()` methods to filter by stream ID and order by sequence. The resulting events are then converted to a list using `ToList()`.  Requires an `IDocumentSession` and a `Guid` stream identifier.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/querying.md#_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic void example_of_querying_for_event_data(IDocumentSession session, Guid stream)\n{\n    var events = session.Events.QueryAllRawEvents()\n        .Where(x => x.StreamId == stream)\n        .OrderBy(x => x.Sequence)\n        .ToList();\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring DDL Template by Fluent Interface (C#)\nDESCRIPTION: This code snippet demonstrates how to configure a DDL template for a specific document type using Marten's fluent interface. The `DdlTemplate` method of the `Schema.For<T>()` configuration is used to specify the template name for the `User` document type. This allows overwriting the default template on a document-by-document type basis.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/schema/authorization.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n    _.Schema.For<User>().DdlTemplate(\"readonly\");\n});\n```\n\n----------------------------------------\n\nTITLE: Rename Deep Property in Marten (C#)\nDESCRIPTION: Demonstrates renaming a nested property within a Marten document using `Patch.Rename()`.  This test stores a `Target` object with nested properties, renames `Inner.String` to `Inner.AnotherString`, and verifies the change.  Dependencies: Marten, Xunit, Shouldly.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/partial-updates-patching.md#_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic async Task rename_deep_prop()\n{\n    var target = Target.Random(true);\n    target.Inner.String = \"Foo\";\n    target.Inner.AnotherString = \"Bar\";\n\n    theSession.Store(target);\n    await theSession.SaveChangesAsync();\n\n    theSession.Patch<Target>(target.Id).Rename(\"String\", x => x.Inner.AnotherString);\n    await theSession.SaveChangesAsync();\n\n    using (var query = theStore.QuerySession())\n    {\n        var target2 = query.Load<Target>(target.Id);\n        target2.Inner.AnotherString.ShouldBe(\"Foo\");\n        target2.Inner.String.ShouldBeNull();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Marten to IServiceCollection\nDESCRIPTION: This code snippet demonstrates how to register Marten services within the `ConfigureServices` method of a .NET Core application's Startup class, using the `IServiceCollection` abstraction. This makes Marten's services available for dependency injection throughout the application.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/getting_started.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n// Options +=> Marten/AspNetCore/service_collection.cs\nusing Marten;\nusing Microsoft.Extensions.DependencyInjection;\n\npublic class StartupConfigureServices\n{\n    public void ConfigureServices(IServiceCollection services)\n    {\n        services.AddMarten(options =>\n        {\n            // Establish the connection string to your Marten database\n            options.Connection(\"your_connection_string\");\n\n            // For development, let Marten just build the database schema\n            // automatically\n            options.AutoCreateSchemaObjects = AutoCreate.All;\n\n            // Opt into enabling possibly expensive but helpful auto-creates\n            options.Policies.ForbidDuplicateNames();\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Soft Deleted Document in Marten\nDESCRIPTION: This code snippet defines a document class with properties `IsDeleted` and `DeletedWhen` to represent soft deletion status. Unlike the previous example, this class does not implement the `ISoftDeleted` interface, requiring manual mapping to Marten's metadata.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/deletes.md#_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\npublic class ASoftDeletedDoc\n{\n    // Always have to have an identity of some sort\n    public Guid Id { get; set; }\n\n    public bool IsDeleted { get; set; }\n\n    public DateTimeOffset? DeletedWhen { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Querying for Multiple Scalars as a Tuple in Marten using AdvancedSql\nDESCRIPTION: This snippet showcases querying for multiple scalar values (int, string, boolean) using `session.AdvancedSql.QueryAsync<T1, T2, T3>()` and returning them as a tuple. It uses a dummy table to select pre-defined values. The correct order of the values is ensured through SQL ROW statements.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/advanced-sql.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvar (number,text, boolean) = (await session.AdvancedSql.QueryAsync<int, string, bool>(\n    \"select row(5), row('foo'), row(true) from (values(1)) as dummy\",\n    CancellationToken.None)).First();\n```\n\n----------------------------------------\n\nTITLE: Id Samples\nDESCRIPTION: This code sample demonstrates example usages of different Id types in Marten documents, showing how to define the `Id` property with different data types such as `Guid`, `int`, and `string`. It illustrates the standard convention Marten uses to identify document types.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/identity/index.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// SAMPLE: id_samples\npublic class DocWithGuid\n{\n    public Guid Id { get; set; }\n}\n\npublic class DocWithInt\n{\n    public int Id { get; set; }\n}\n\npublic class DocWithString\n{\n    public string Id { get; set; }\n}\n// ENDSAMPLE\n```\n\n----------------------------------------\n\nTITLE: Bootstrapping DocumentStore with MartenRegistry - C#\nDESCRIPTION: Shows how to bootstrap the `IDocumentStore` using a custom `MartenRegistry`. This approach applies the configurations defined within the `MartenRegistry` during document store initialization.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/index.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For<MyMartenRegistry>();\n```\n\n----------------------------------------\n\nTITLE: Verifying Asynchronous Projections for New Tenant Databases (C#)\nDESCRIPTION: This code demonstrates how to add new tenant databases and verify that the Marten asynchronous projections are running for these new tenants. It retrieves the `MasterTableTenancy` and adds database records using `AddDatabaseRecordAsync`. The code then uses `IProjectionCoordinator` to get the daemon for each database and waits for the projections to start running. Requires access to the Marten `Store` and `IHost` instances.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/multitenancy.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic async Task add_tenant_database_and_verify_the_daemon_projections_are_running()\n{\n    // In this code block, I'm adding new tenant databases to the system that I\n    // would expect Marten to discover and start up an asynchronous projection\n    // daemon for all three newly discovered databases\n    var tenancy = (MasterTableTenancy)theStore.Options.Tenancy;\n    await tenancy.AddDatabaseRecordAsync(\"tenant1\", tenant1ConnectionString);\n    await tenancy.AddDatabaseRecordAsync(\"tenant2\", tenant2ConnectionString);\n    await tenancy.AddDatabaseRecordAsync(\"tenant3\", tenant3ConnectionString);\n \n    // This is a new service in Marten specifically to help you interrogate or\n    // manipulate the state of running asynchronous projections within the current process\n    var coordinator = _host.Services.GetRequiredService<IProjectionCoordinator>();\n    var daemon1 = await coordinator.DaemonForDatabase(\"tenant1\");\n    var daemon2 = await coordinator.DaemonForDatabase(\"tenant2\");\n    var daemon3 = await coordinator.DaemonForDatabase(\"tenant3\");\n \n    // Just proving that the configured projections for the 3 new databases\n    // are indeed spun up and running after Marten's new daemon coordinator\n    // \"finds\" the new databases\n    await daemon1.WaitForShardToBeRunning(\"TripCustomName:All\", 30.Seconds());\n    await daemon2.WaitForShardToBeRunning(\"TripCustomName:All\", 30.Seconds());\n    await daemon3.WaitForShardToBeRunning(\"TripCustomName:All\", 30.Seconds());\n}\n```\n\n----------------------------------------\n\nTITLE: Querying with Statistics (C#)\nDESCRIPTION: Shows how to use the `Stats()` Linq operator to retrieve query statistics, including the total row count. This example queries `Target` objects where the `Number` property is greater than a specified value and retrieves the total number of matching records along with the results. Dependencies include Marten and Linq.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/paging.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nvar list = session.Query<Target>().Where(x => x.Number > 3).Stats(out var stats).Take(5).ToList();\n```\n\n----------------------------------------\n\nTITLE: Defining IFeatureSchema Interface in Marten (C#)\nDESCRIPTION: This C# code snippet shows the definition of the `IFeatureSchema` interface in Marten. It outlines the methods required for custom database schema feature implementations, including `Objects()` to retrieve schema objects and `Identifier` for schema identification.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/advanced/extensions.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IFeatureSchema : ISchemaObject\\n{\\n    \\n    /// <summary>\\n    ///     Used to uniquely identify this schema feature\\n    ///     in schema patches and schema feature detection\\n    /// </summary>\\n    \\n    Type Identifier { get; }\\n\\n    /// <summary>\\n    ///     All the schema objects (tables, functions, etc.) needed\\n    ///     to support this feature\\n    /// </summary>\\n    /// <param name=\"storeOptions\"></param>\\n    /// <returns></returns>\\n    \\n    IEnumerable<ISchemaObject> Objects(StoreOptions storeOptions);\\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Fake Schema Feature in Marten (C#)\nDESCRIPTION: This code snippet demonstrates how to create a custom schema feature in Marten by inheriting from `FeatureSchemaBase`. It defines a `FakeStorage` class that creates a custom table with a single varchar column.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/schema/extensions.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\npublic class FakeStorage: FeatureSchemaBase\n{\n    private readonly StoreOptions _options;\n\n    public FakeStorage(StoreOptions options): base(\"fake\", options.Advanced.Migrator)\n    {\n        _options = options;\n    }\n\n    protected override IEnumerable<ISchemaObject> schemaObjects()\n    {\n        var table = new Table(new PostgresqlObjectName(_options.DatabaseSchemaName, \"mt_fake_table\"));\n        table.AddColumn(\"name\", \"varchar\");\n\n        yield return table;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Customize Newtonsoft.Json Collection Storage (C#)\nDESCRIPTION: This snippet demonstrates how to configure Newtonsoft.Json to store collections as JSON arrays instead of the default strongly typed representation. This can improve nested collections query handling.  Dependencies: Marten DocumentStore, Newtonsoft.Json.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/json.md#_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n    // Replace the default (strongly typed) JsonNetSerializer collection storage // [!code focus:3]\n    // with JSON array formatting\n    _.UseNewtonsoftForSerialization(collectionStorage: CollectionStorage.AsArray);\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Enum Storage as String in Marten (C#)\nDESCRIPTION: This snippet shows how to configure Marten to store enum fields as strings (`varchar`) in duplicated fields.  This overrides the default behavior of storing enums as integers.  It utilizes the `DuplicatedFieldEnumStorage` property and sets it to `EnumStorage.AsString`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/migration-guide.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nDuplicatedFieldEnumStorage = EnumStorage.AsString;\n```\n\n----------------------------------------\n\nTITLE: Defining Invoicing Store Interface (Marten, C#)\nDESCRIPTION: Defines a custom marker interface, `IInvoicingStore`, for a separate Marten document store targeting an \"invoicing\" database. The interface is public and implements `IDocumentStore`, enabling Marten to build a dynamic type for this additional store internally.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/hostbuilder.md#_snippet_23\n\nLANGUAGE: C#\nCODE:\n```\n// These marker interfaces *must* be public\npublic interface IInvoicingStore : IDocumentStore\n{\n\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Document Ids\nDESCRIPTION: This snippet shows different ways of defining the Id property in Marten documents, including using strings, Guids, integers, and longs. It demonstrates different naming conventions that Marten accepts for the Id property or field.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/identity.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic class Division\n{\n    // String property as Id\n    public string Id { get; set; }\n}\n\npublic class Category\n{\n    // Guid's work, fields too\n    public Guid Id;\n}\n\npublic class Invoice\n{\n    // int's and long's can be the Id\n    // \"id\" is accepted\n    public int id { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Compiled Query with Statistics in Test - C#\nDESCRIPTION: This C# code illustrates how to use a compiled query with `QueryStatistics` within a test scenario.  It first deletes existing `Target` documents, inserts new ones, creates a `TargetsInOrder` query with specific page size and start values, executes the query, and then asserts that the `TotalResults` property of the `QueryStatistics` object matches the expected total count.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/compiled-queries.md#_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic async Task use_compiled_query_with_statistics()\n{\n    await theStore.Advanced.Clean.DeleteDocumentsByTypeAsync(typeof(Target));\n    var targets = Target.GenerateRandomData(100).ToArray();\n    await theStore.BulkInsertAsync(targets);\n\n    var query = new TargetsInOrder { PageSize = 10, Start = 20 };\n\n    var results = await theSession.QueryAsync(query);\n\n    // Verifying that the total record count in the database matching\n    // the query is determined when this is executed\n    query.Statistics.TotalResults.ShouldBe(100);\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling External Wolverine Transports\nDESCRIPTION: Disables all external Wolverine transports within the Alba host setup. Useful for testing in isolation, preventing external messaging from interfering with the test execution. Requires Wolverine and Alba integration.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/testing/integration.md#_snippet_15\n\nLANGUAGE: cs\nCODE:\n```\nservices.DisableAllExternalWolverineTransports();\n```\n\n----------------------------------------\n\nTITLE: Defining Order Aggregate for Command Handling in C#\nDESCRIPTION: This code defines the `Order` aggregate class with properties like `Id`, `Version`, `Shipped`, and `Items`. It includes methods for applying events (`Apply`) and checking the order's readiness to ship (`IsReadyToShip`). The constructor takes an `OrderCreated` event and initializes the `Items` dictionary.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/scenarios/command_handler_workflow.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic class Item\n{\n    public string Name { get; set; }\n    public bool Ready { get; set; }\n}\n\npublic class Order\n{\n    // This would be the stream id\n    public Guid Id { get; set; }\n\n    // This is important, by Marten convention this would\n    // be the\n    public int Version { get; set; }\n\n    public Order(OrderCreated created)\n    {\n        foreach (var item in created.Items)\n        {\n            Items[item.Name] = item;\n        }\n    }\n\n    public void Apply(IEvent<OrderShipped> shipped) => Shipped = shipped.Timestamp;\n    public void Apply(ItemReady ready) => Items[ready.Name].Ready = true;\n\n    public DateTimeOffset? Shipped { get; private set; }\n\n    public Dictionary<string, Item> Items { get; set; } = new();\n\n    public bool IsReadyToShip()\n    {\n        return Shipped == null && Items.Values.All(x => x.Ready);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Document with Value Types in Marten (Extended)\nDESCRIPTION: This code snippet defines an extended document `LimitedDoc` with several properties as value types (`UpperLimit`, `LowerLimit`, `Description`, and `GuidId`).  The `[ValueObject<T>]` attributes define the underlying type of each value object. These value objects and the document class are essential for demonstrating querying capabilities with Marten's LINQ support.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/identity.md#_snippet_22\n\nLANGUAGE: cs\nCODE:\n```\n[ValueObject<long>]\npublic partial struct UpperLimit;\n\n[ValueObject<int>]\npublic partial struct LowerLimit;\n\n[ValueObject<string>]\npublic partial struct Description;\n\n[ValueObject<Guid>]\npublic partial struct GuidId;\n\npublic class LimitedDoc\n{\n    public Guid Id { get; set; }\n\n    public GuidId? ParentId { get; set; }\n    public UpperLimit? Upper { get; set; }\n    public LowerLimit Lower { get; set; }\n    public Description? Description { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Track Event Counters in Marten\nDESCRIPTION: This code snippet demonstrates how to enable the tracking of event counters in Marten.  It configures a `DocumentStore` with a connection string and calls the `TrackEventCounters()` method on the `OpenTelemetry` configuration.  This adds a `Counter` metric named `marten.event.append` that tracks the number of events appended to the system, with tags for `event_type` and `tenant.id`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/otel.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nusing var store = DocumentStore.For(opts =>\n{\n    opts.Connection(\"some connection string\");\n\n    // Track the number of events being appended to the system\n    opts.OpenTelemetry.TrackEventCounters();\n});\n```\n\n----------------------------------------\n\nTITLE: Any Query Through Child Collection with AND using Linq in Marten (C#)\nDESCRIPTION: Shows how to search for elements in a child collection that satisfy multiple conditions combined with the `&&` operator. This example filters based on both `Name` and `Age` properties of the child collection elements.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/linq.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic class Target\n{\n    public Guid Id { get; set; }\n    public string[] Tags { get; set; }\n    public Inner[] Children { get; set; }\n}\n\npublic class Inner\n{\n    public string Name { get; set; }\n    public int Age { get; set; }\n}\n\nvar targets = session.Query<Target>().Where(x => x.Children.Any(c => c.Name == \"Jeremy\" && c.Age == 34)).ToList();\n```\n\n----------------------------------------\n\nTITLE: UserNamesForFirstName Compiled List Query Example C#\nDESCRIPTION: This code demonstrates a compiled query `UserNamesForFirstName` in C# that retrieves a list of user names with a matching first name. It implements the `ICompiledListQuery` interface, using `Select()` to transform the results. The `QueryIs` method defines the Linq query used to filter and transform the documents.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/compiled_queries.md#_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic class UserNamesForFirstName : ICompiledListQuery<User, string>\n{\n    public string FirstName { get; set; }\n\n    public Expression<Func<IQueryable<User>, IEnumerable<string>>> QueryIs()\n    {\n        return query => query.Where(x => x.FirstName == FirstName).Select(x => x.UserName);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting a New Stream with Existing Guid (C#)\nDESCRIPTION: This snippet illustrates starting a new event stream using a predefined Guid ID.  This allows you to explicitly control the stream's identity. Note that `StartStream` will throw an `ExistingStreamIdCollisionException` if a stream with the specified ID already exists.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/events/appending.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nusing var store = DocumentStore.Empty();\n\nvar questId = Guid.NewGuid();\n\n// Starting a brand new stream with a user-supplied stream id\nvar joined = new MembersJoined { Members = new[] { \"Bilbo\", \"Frodo\" } };\n\nusing var session = store.OpenSession();\n\n// Use StartStream() to start a new event stream with specified Guid\nsession.Events.StartStream(questId, joined);\n\nsession.SaveChanges();\n```\n\n----------------------------------------\n\nTITLE: Previewing LINQ Query SQL\nDESCRIPTION: Demonstrates how to preview the generated SQL command for a LINQ query. It retrieves a queryable object, converts it to a command using `ToCommand`, and prints the SQL command text to the debug output.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/diagnostics.md#_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\n// store is the active IDocumentStore\nvar queryable = theStore.QuerySession().Query<Trade>().Where(x => x.Value > 2000);\nvar cmd = queryable.ToCommand(FetchType.FetchMany);\n\nDebug.WriteLine(cmd.CommandText);\n```\n\n----------------------------------------\n\nTITLE: Rebuilding a Single Projection in C#\nDESCRIPTION: This code snippet demonstrates how to rebuild a single projection on demand using the `IDaemon` interface. This is useful when the code defining the projection changes and requires events to be reapplied to maintain correct state.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/events/projections/index.md#_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\n// SAMPLE: rebuild-single-projection\nusing var host = Host.CreateDefaultBuilder()\n    .ConfigureServices(services =>\n    {\n        services.AddMarten(opts =>\n        {\n            opts.Projections.SelfAggregate<QuestParty>();\n        }).AddMartenDaemon()\n            .AddTransient<RebuildHandler>();\n    }).Build();\n\npublic class RebuildHandler\n{\n    private readonly IDaemon _daemon;\n\n    public RebuildHandler(IDaemon daemon)\n    {\n        _daemon = daemon;\n    }\n\n    public async Task Rebuild()\n    {\n        await _daemon.RebuildProjection<QuestParty>();\n    }\n}\n// ENDSAMPLE\n```\n\n----------------------------------------\n\nTITLE: Querying All Documents of a Type in Marten\nDESCRIPTION: This code snippet demonstrates how to retrieve all documents of a specific type from a Marten database using `session.Query<Target>()`. The `ToListAsync()` method is used to execute the query and return the results as a list. This method is useful for retrieving all documents of a type but is generally discouraged outside of testing scenarios.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/index.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic async Task get_all_documents_of_a_type(IDocumentSession session)\n{\n    // Calling ToArray() just forces the query to be executed\n    var targets = await session.Query<Target>().ToListAsync();\n}\n```\n\n----------------------------------------\n\nTITLE: Projecting to Anonymous Types with Select(), C#\nDESCRIPTION: This code snippet showcases how to retrieve specific document properties and transform them into an anonymous type using the `Select()` method in Marten. It allows for creating temporary data structures without explicitly defining a class. The underlying mechanism used is the linq `IQueryable.Select()` method.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/projections.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:anonymous_type_projection]>\n```\n\n----------------------------------------\n\nTITLE: Javascript Transformation Function Example\nDESCRIPTION: This Javascript code defines a function that takes a JSON document as input and returns a new JSON document with a modified structure.  It exports the transformation function using the CommonJS `module.exports` syntax, which is required by Marten. The function concatenates the `FirstName` and `LastName` properties of the input document to create a `fullname` property in the output document.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/advanced/javascript_transformations.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nmodule.exports = function (doc) {\n    return {fullname: doc.FirstName + ' ' + doc.LastName};\n}\n```\n\n----------------------------------------\n\nTITLE: Immutable Projection Class Definition (C#)\nDESCRIPTION: Defines an immutable projection class with private event application methods (Apply) and no public property setters. The projection is applied by aggregators.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/scenarios/immutable_projections_readmodel.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic class Projection\n{\n    public Guid Id { get; private set; }\n    public string Name { get; private set; }\n\n    private void Apply(Event1 e)\n    {\n        Id = e.Id;\n        Name = e.Name;\n    }\n\n    private void Apply(Event2 e)\n    {\n        Name = e.Description;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling All Informational Fields in Marten (C#)\nDESCRIPTION: This code snippet demonstrates how to disable all informational metadata fields in Marten. It configures the `DocumentStore` using `opts.Policies.DisableInformationalFields()`, directing Marten to omit all informational metadata columns for leaner operation.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/metadata.md#_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(opts =>\n{\n    opts.Connection(\"some connection string\");\n\n    // This will direct Marten to omit all informational\n    // metadata fields\n    opts.Policies.DisableInformationalFields();\n});\n```\n\n----------------------------------------\n\nTITLE: Get Raw JSON Marten C#\nDESCRIPTION: This code snippet demonstrates how to retrieve raw JSON from a Marten query. It stores an `Issue` document and then retrieves its JSON representation using various methods such as `ToJsonArray`, `ToJsonFirst`, `ToJsonFirstOrDefault`, `ToJsonSingle`, and `ToJsonSingleOrDefault` after applying a `Where` clause to the query. It shows different ways to get the raw JSON representation based on the query results.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/query-json.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic async Task when_get_json_then_raw_json_should_be_returned()\n{\n    var issue = new Issue { Title = \"Issue 1\" };\n\n    theSession.Store(issue);\n    await theSession.SaveChangesAsync();\n    var json = await theSession.Query<Issue>().Where(x => x.Title == \"Issue 1\").ToJsonArray();\n    json.ShouldNotBeNull();\n\n    json = await theSession.Query<Issue>().ToJsonFirst();\n    json = await theSession.Query<Issue>().ToJsonFirstOrDefault();\n    json = await theSession.Query<Issue>().ToJsonSingle();\n    json = await theSession.Query<Issue>().ToJsonSingleOrDefault();\n}\n```\n\n----------------------------------------\n\nTITLE: Async Upcasting with Json.NET in Marten\nDESCRIPTION: This snippet showcases asynchronous upcasting using Json.NET with Marten. It converts an event using a JObject, retrieving client data asynchronously and creating a new event. It also utilizes the AsyncOnlyUpcast helper to adapt the async lambda for Marten.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/versioning.md#_snippet_27\n\nLANGUAGE: cs\nCODE:\n```\noptions.UseNewtonsoftForSerialization();\n\noptions.Events\n    .Upcast<ShoppingCartOpenedWithStatus>(\n        \"shopping_cart_opened\",\n        AsyncOnlyUpcast(async (oldEvent, ct) =>\n            {\n                var clientId = (Guid)oldEvent[\"ClientId\"]!;\n                // WARNING: UpcastAsync method is called each time old event\n                // is read from database and deserialized.\n                // We discourage to run resource consuming methods here.\n                // It might end up with N+1 problem.\n                var clientName = await clientRepository.GetClientName(clientId, ct);\n\n                return new ShoppingCartOpenedWithStatus(\n                    (Guid)oldEvent[\"ShoppingCartId\"]!,\n                    new Client(clientId, clientName),\n                    ShoppingCartStatus.Opened\n                );\n            }\n        )\n    );\n```\n\n----------------------------------------\n\nTITLE: Configuring Global Sequential Guid\nDESCRIPTION: This code shows how to configure the document store to use a sequential (Comb) Guid generation strategy for all document types. It applies the `CombGuidIdGeneration` to all documents with a Guid Id.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/identity.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\noptions.Policies.ForAllDocuments(m =>\n{\n    if (m.IdType == typeof(Guid))\n    {\n        m.IdStrategy = new CombGuidIdGeneration();\n    }\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Session Factory in C#\nDESCRIPTION: This code defines a custom `ISessionFactory` implementation named `ScopedSessionFactory`. It depends on `IDocumentStore`, `ILogger<IDocumentSession>`, and `ISession`. The `OpenSession` method creates a lightweight session and replaces the default Marten session logger with the custom `CorrelatedMartenLogger`, injecting the required dependencies for correlation tracking.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/hostbuilder.md#_snippet_20\n\nLANGUAGE: cs\nCODE:\n```\npublic class ScopedSessionFactory: ISessionFactory\n{\n    private readonly IDocumentStore _store;\n    private readonly ILogger<IDocumentSession> _logger;\n    private readonly ISession _session;\n\n    // This is important! You will need to use the\n    // IDocumentStore to open sessions\n    public ScopedSessionFactory(IDocumentStore store, ILogger<IDocumentSession> logger, ISession session)\n    {\n        _store = store;\n        _logger = logger;\n        _session = session;\n    }\n\n    public IQuerySession QuerySession()\n    {\n        return _store.QuerySession();\n    }\n\n    public IDocumentSession OpenSession()\n    {\n        var session = _store.LightweightSession();\n\n        // Replace the Marten session logger with our new\n        // correlated marten logger\n        session.Logger = new CorrelatedMartenLogger(_logger, _session);\n\n        return session;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Open Telemetry Exporting from Marten (Aspire)\nDESCRIPTION: This snippet demonstrates how to configure Open Telemetry exporting in a Marten application using Project Aspire. It adds tracing and metrics sources for Marten. The endpoint URI is retrieved from configuration.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/async-daemon.md#_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\n// This is passed in by Project Aspire. The exporter usage is a little\n// different for other tools like Prometheus or SigNoz\nvar endpointUri = builder.Configuration[\"OTEL_EXPORTER_OTLP_ENDPOINT\"];\nConsole.WriteLine(\"OLTP endpoint: \" + endpointUri);\n\nbuilder.Services.AddOpenTelemetry().UseOtlpExporter();\n\nbuilder.Services.AddOpenTelemetry()\n    .WithTracing(tracing =>\n    {\n        tracing.AddSource(\"Marten\");\n    })\n    .WithMetrics(metrics =>\n    {\n        metrics.AddMeter(\"Marten\");\n    });\n```\n\n----------------------------------------\n\nTITLE: Implementing CandleProjection (C#)\nDESCRIPTION: Implements a `ViewProjection` that projects `Candle` data from `Tick` events.  The `Apply` method updates the `Candle` projection based on incoming `Tick` events.  This projection subscribes to the 'Tick' event.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/projection-by-event-type.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nusing Marten.Events.Projections;\n\npublic class CandleProjection : ViewProjection<Candle, Tick>\n{\n    public CandleProjection()\n    {\n        // Tweak the lifecycle. The default is Sync.\n        Lifecycle = ProjectionLifecycle.Async;\n    }\n\n    public Candle Apply(Candle candle, Tick tick)\n    {\n        if (candle == null)\n        {\n            candle = new Candle { Open = tick.Value, High = tick.Value, Low = tick.Value, Time = tick.Time };\n        }\n\n        candle.Close = tick.Value;\n        if (tick.Value > candle.High) candle.High = tick.Value;\n        if (tick.Value < candle.Low) candle.Low = tick.Value;\n\n        candle.Volume++;\n\n        return candle;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Querying for Documents in Marten using AdvancedSql\nDESCRIPTION: This snippet illustrates querying for documents of type `DocWithoutMeta` using `session.AdvancedSql.QueryAsync<T>()`. It retrieves the 'id' and 'data' columns from the document's table, ensuring the correct column order for Marten to map the result to the document. It retrieves the schema using `session.DocumentStore.Options.Schema`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/advanced-sql.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nvar schema = session.DocumentStore.Options.Schema;\nvar docs = await session.AdvancedSql.QueryAsync<DocWithoutMeta>(\n    $\"select id, data from {schema.For<DocWithoutMeta>()} order by data ->> 'Name'\",\n    CancellationToken.None);\n```\n\n----------------------------------------\n\nTITLE: Querying with `IsSubsetOf` Operator - Marten - C#\nDESCRIPTION: This code snippet demonstrates how to use the `IsSubsetOf()` extension method in Marten to query for documents where an array property is a subset of the provided values. It uses `theSession.Query<Post>()` to query the `Post` documents, checking if `Tags` is a subset of {\"c#\", \"json\", \"postgres\"}.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/child-collections.md#_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\n// Finds all Posts whose Tags is subset of\n// c#, json, or postgres\nvar posts = theSession.Query<Post>()\n    .Where(x => x.Tags.IsSubsetOf(\"c#\", \"json\", \"postgres\"));\n```\n\n----------------------------------------\n\nTITLE: Negated Contains Query with Linq in Marten (C#)\nDESCRIPTION: Demonstrates how to query for documents where a collection does *not* contain a specific value.  This uses the negation operator `!` in conjunction with the `Contains` method. Requires a string array called Tags\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/linq.md#_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic class Target\n{\n    public Guid Id { get; set; }\n    public string[] Tags { get; set; }\n    public Inner[] Children { get; set; }\n}\n\npublic class Inner\n{\n    public string Name { get; set; }\n    public int Age { get; set; }\n}\n\nvar targets = session.Query<Target>().Where(x => !x.Tags.Contains(\"foo\")).ToList();\n```\n\n----------------------------------------\n\nTITLE: Override Schema Per Table with Marten\nDESCRIPTION: This code snippet shows how to override the default schema for a specific document type within Marten. It demonstrates the use of `StoreOptions.Schema.For<T>().UseStorageSchema(\"schemaName\")` to specify a different schema for a particular document type, providing fine-grained control over schema placement.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/schema/schema.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// Establish a DocumentStore using StoreOptions\nvar store = DocumentStore.For(_ =>\n{\n    // Override the default schema name\n    _.DatabaseSchemaName = \"other\";\n\n    // Override the schema name just for User\n    _.Schema.For<User>().UseStorageSchema(\"users\");\n});\n```\n\n----------------------------------------\n\nTITLE: Querying with `In` Operator using String Array - Marten - C#\nDESCRIPTION: This code snippet demonstrates how to use the `In()` extension method in Marten to query for documents where a string property matches one of several provided values. The `In` method is used for syntactic sugar to ease RavenDB transition. It uses the `session.Query<SuperUser>()` to query the `SuperUser` documents.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/child-collections.md#_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\n// Finds all SuperUser's whose role is either\n// Admin, Supervisor, or Director\nvar users = session.Query<SuperUser>()\n    .Where(x => x.Role.In(\"Admin\", \"Supervisor\", \"Director\"));\n```\n\n----------------------------------------\n\nTITLE: Marten Schema Customization\nDESCRIPTION: Defines a Marten schema customization type, deriving from `FeatureSchemaBase`. This customization is responsible for handling the PostgreSQL sequence creation and management within the Marten schema.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/scenarios/usingsequenceforuniqueid.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:scenario-usingsequenceforuniqueid-setup]>\n```\n\n----------------------------------------\n\nTITLE: Configuring Marten to use Noda Time without JSON.NET configuration\nDESCRIPTION: This code snippet shows how to configure Marten to use Noda Time, but without automatically configuring the JSON.NET serializer.  Setting `shouldConfigureJsonNetSerializer` to `false` allows for manual configuration of NodaTime Json serialization, allowing developers to maintain full control over their Json serializer configuration.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/noda_time.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:noda_time_setup_without_json_net_serializer_configuration]>\n```\n\n----------------------------------------\n\nTITLE: Delegating Arguments to Console Application - Bash\nDESCRIPTION: This bash script creates a command named 'marten' that allows passing arguments to the console application, enabling the usage of the Marten command-line tools.  It is intended to be saved as a shell script (e.g. marten.cmd or marten) at the root of the project.  `src/MyConsoleApp` is a placeholder for the location of the console application.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/cli.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ndotnet run --project src/MyConsoleApp %*\n```\n\n----------------------------------------\n\nTITLE: Override Document Alias Programmatically in Marten (C#)\nDESCRIPTION: This snippet demonstrates how to override the default document alias using the `MartenRegistry` within the `DocumentStore.For()` configuration.  It sets up a `DocumentStore` and configures the schema for the `User` document type, assigning it the alias \"folks\". The code depends on the Marten library and uses a connection string.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/schema/storage.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n    _.Connection(ConnectionSource.ConnectionString);\n\n    _.Schema.For<User>().DocumentAlias(\"folks\");\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Postgresql Function with the Function Class (C#)\nDESCRIPTION: This C# code demonstrates how to create a Postgresql function by subclassing the `Function` base class. It showcases the structure of the `mt_append_event` function within the Marten event store, defining the function's arguments and body using SQL. The constructor accepts `StoreOptions` to access schema name and other database related options.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/advanced/extensions.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\ninternal class AppendEventFunction : Function\\n{\\n    public AppendEventFunction(StoreOptions options) : base(new DbObjectName(options.DatabaseSchemaName, \"mt_append_event\"))\\n    {\\n        Body = @\"\\nCREATE OR REPLACE FUNCTION {0}(stream uuid, event_type varchar, event_typename varchar, timestamp timestamp with time zone, data jsonb, causation_id uuid, correlation_id uuid, origin varchar, version integer)\\nRETURNS void AS $$\nBEGIN\\n\\nINSERT INTO mt_events (stream_id, event_type, event_typename, timestamp, data, causation_id, correlation_id, origin, version)\\nVALUES (stream, event_type, event_typename, timestamp, data, causation_id, correlation_id, origin, version);\\n\\nEND;\\n$$ LANGUAGE plpgsql;\\n\";\\n    }\\n}\n```\n\n----------------------------------------\n\nTITLE: Registering a Custom Aggregator Lookup in C#\nDESCRIPTION: This code snippet demonstrates how to register a custom `IAggregatorLookup` to customize the way Marten finds and uses aggregator classes. This is useful for implementing generic aggregation strategies.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/events/projections/index.md#_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\n// SAMPLE: register-custom-aggregator-lookup\nusing Marten;\nusing Marten.Events;\nusing Marten.Events.Aggregation;\nusing Microsoft.Extensions.DependencyInjection;\nusing Weasel.Core;\n\npublic class CustomAggregatorLookup : IAggregatorLookup\n{\n    public IAggregator<T> Find<T>()\n    {\n        throw new System.NotImplementedException();\n    }\n}\n\npublic static class ServiceCollectionExtensions\n{\n    public static IServiceCollection AddCustomMarten(this IServiceCollection services)\n    {\n        services.AddMarten(opts =>\n        {\n            opts.Events.UseAggregatorLookup(new CustomAggregatorLookup());\n            opts.AutoCreateSchemaObjects = AutoCreate.All;\n        });\n\n        return services;\n    }\n}\n// ENDSAMPLE\n```\n\n----------------------------------------\n\nTITLE: FindJsonUserByUsername Compiled Query C#\nDESCRIPTION: This code snippet shows how to implement `ICompiledQuery` for querying for a single user document as JSON by username. Includes an example `ToJson()` method call, intended to serialize the User object to JSON.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/compiled_queries.md#_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\npublic class FindJsonUserByUsername : ICompiledQuery<User, string>\n{\n    public string Username { get; set; }\n\n    public Expression<Func<IQueryable<User>, string>> QueryIs()\n    {\n        return query => query.Where(x => x.UserName == Username).AsJson().FirstOrDefault();\n    }\n\n    // Our ToJson() method simply returns a string representation of the User instance in Json notation\n}\n```\n\n----------------------------------------\n\nTITLE: Querying with IsOneOf() for Lists in Marten (C#)\nDESCRIPTION: Demonstrates using the `IsOneOf()` extension to query for documents where a field's value exists in a given list. This example shows querying SuperUser documents, filtering by roles present within listOfRoles.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/child-collections.md#_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\n// Finds all SuperUser's whose role is either\n// Admin, Supervisor, or Director\nvar listOfRoles = new List<string> {\"Admin\", \"Supervisor\", \"Director\"};\n\nvar users = session.Query<SuperUser>()\n    .Where(x => x.Role.IsOneOf(listOfRoles));\n```\n\n----------------------------------------\n\nTITLE: Adding Required Property with Default Value\nDESCRIPTION: This snippet illustrates adding a new, required property (`Status`) to the `ShoppingCartOpened` event with a default value (`ShoppingCartStatus.Opened`). This ensures that older events will have this property set to the default value during deserialization.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/versioning.md#_snippet_7\n\nLANGUAGE: cs\nCODE:\n```\npublic enum ShoppingCartStatus\n{\n    UnderFraudDetection = 1,\n    Opened = 2,\n    Confirmed = 3,\n    Cancelled = 4\n}\n\npublic record ShoppingCartOpened(\n    Guid ShoppingCartId,\n    Guid ClientId,\n    // Adding new required property with default value\n    ShoppingCartStatus Status = ShoppingCartStatus.Opened\n);\n```\n\n----------------------------------------\n\nTITLE: Writing Single Document By Id to HttpResponse (Marten)\nDESCRIPTION: This C# code demonstrates how to write a single Marten document to the HTTP response by its id using the `WriteById` extension method.  It streams the raw JSON of a document specified by `issueId` directly to the `HttpContext.Response.Body`, setting the appropriate content-type and content-length headers. The `onFoundStatus` parameter allows specifying the HTTP status code when the document is found.  Dependency: `IQuerySession`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/aspnetcore.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\n[HttpGet(\"/issue/{issueId}\")]\npublic Task Get(Guid issueId, [FromServices] IQuerySession session, [FromQuery] string? sc = null)\n{\n    // This \"streams\" the raw JSON to the HttpResponse\n    // w/o ever having to read the full JSON string or\n    // deserialize/serialize within the HTTP request\n    return sc is null\n        ? session.Json\n            .WriteById<Issue>(issueId, HttpContext)\n        : session.Json\n            .WriteById<Issue>(issueId, HttpContext, onFoundStatus: int.Parse(sc));\n\n}\n```\n\n----------------------------------------\n\nTITLE: Event Store Quickstart\nDESCRIPTION: This code snippet provides a quickstart example of using Marten's Event Store. It demonstrates basic operations like starting a new stream and appending events to it. This snippet likely showcases the fundamental usage pattern for interacting with the event store.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/events/index.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:event-store-quickstart]>\n```\n\n----------------------------------------\n\nTITLE: Benchmark Results: BulkInsertDocuments\nDESCRIPTION: This snippet presents the performance result for the `BulkInsertDocuments` method. It includes the mean execution time (in milliseconds) and the standard deviation. The results allow for evaluating the performance characteristics of the method.\nSOURCE: https://github.com/jasperfx/marten/blob/master/benchmarks/2.0.baseline/results/BulkLoading-report-github.md#_snippet_1\n\nLANGUAGE: INI\nCODE:\n```\n              Method |        Mean |    StdDev |\n-------------------- |------------ |---------- |\n BulkInsertDocuments | 196.4910 ms | 9.4850 ms |\n```\n\n----------------------------------------\n\nTITLE: Registering Event Projection with Lifecycle Configuration (C#)\nDESCRIPTION: Shows how to register an EventProjection with Marten's DocumentStore, specifying whether the projection should run inline or asynchronously. It sets up the DocumentStore with a connection string and then adds the SampleEventProjection to the store's projections, configuring it to run either inline or asynchronously using the ProjectionLifecycle enum.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/event-projections.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(opts =>\n{\n    opts.Connection(\"some connection string\");\n\n    // Run inline...\n    opts.Projections.Add(new SampleEventProjection(), ProjectionLifecycle.Inline);\n\n    // Or nope, run it asynchronously\n    opts.Projections.Add(new SampleEventProjection(), ProjectionLifecycle.Async);\n});\n```\n\n----------------------------------------\n\nTITLE: Duplicating Field in Marten\nDESCRIPTION: This code snippet demonstrates how to duplicate an existing field's value to a new field using the `Patch` and `Duplicate` methods.  It copies the value from `t.String` to `t.AnotherString` for a given `Target` document.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/partial-updates-patching.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nvar target = Target.Random();\ntarget.AnotherString = null;\ntheSession.Store(target);\nawait theSession.SaveChangesAsync();\n\ntheSession.Patch<Target>(target.Id).Duplicate(t => t.String, t => t.AnotherString);\nawait theSession.SaveChangesAsync();\n\nusing (var query = theStore.QuerySession())\n{\n    var result = query.Load<Target>(target.Id);\n    result.AnotherString.ShouldBe(target.String);\n}\n```\n\n----------------------------------------\n\nTITLE: Querying with AND/OR Operators in Marten Linq using C#\nDESCRIPTION: Demonstrates how to combine multiple conditions using AND and OR operators in Linq queries against a Marten database.  It uses `IDocumentSession` to query the `Target` document type, combining conditions with `&&` (AND) and `||` (OR) operators.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/operators.md#_snippet_3\n\nLANGUAGE: cs\nCODE:\n```\npublic void and_or(IDocumentSession session)\n{\n    // AND queries\n    session.Query<Target>().Where(x => x.Number > 0 && x.Number <= 5);\n\n    // OR queries\n    session.Query<Target>().Where(x => x.Number == 5 || x.Date == DateTime.Today);\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Custom Projection in DocumentStore (C#)\nDESCRIPTION: This snippet shows how to register a custom projection within a Marten `DocumentStore`.  It configures the store using `DocumentStore.For` and adds the `QuestPatchTestProjection` with either `ProjectionLifecycle.Inline` or `ProjectionLifecycle.Async`, determining when the projection is applied.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/custom.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(opts =>\n{\n    opts.Connection(\"some connection string\");\n\n    // Use inline lifecycle\n    opts.Projections.Add(new QuestPatchTestProjection(), ProjectionLifecycle.Inline);\n\n    // Or use this as an asychronous projection\n    opts.Projections.Add(new QuestPatchTestProjection(), ProjectionLifecycle.Async);\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Soft Deletes with Partitioning\nDESCRIPTION: This C# code demonstrates how to configure Marten to use PostgreSQL table partitioning for soft-deleted documents.  It shows how to opt into partitioning for a single document type, with an index, and for all soft-deleted documents.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/deletes.md#_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(opts =>\n{\n    opts.Connection(\"some connection string\");\n\n    // Opt into partitioning for one document type\n    opts.Schema.For<User>().SoftDeletedWithPartitioning();\n\n    // Opt into partitioning and and index for one document type\n    opts.Schema.For<User>().SoftDeletedWithPartitioningAndIndex();\n\n    // Opt into partitioning for all soft-deleted documents\n    opts.Policies.AllDocumentsSoftDeletedWithPartitioning();\n});\n```\n\n----------------------------------------\n\nTITLE: Order2 with StronglyTypedId (Int) in C#\nDESCRIPTION: This snippet demonstrates using the `StronglyTypedId` library to create a strong typed identifier `Order2Id` that wraps an `int`. The `[StronglyTypedId(Template.Int)]` attribute is used to generate the value object. The `Order2` class uses `Order2Id` as its identifier.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/identity.md#_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\n[StronglyTypedId(Template.Int)]\npublic partial struct Order2Id;\n\npublic class Order2\n{\n    public Order2Id? Id { get; set; }\n    public string Name { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Marten Store Configuration - Part 2\nDESCRIPTION: Executes the configuration against the database, generating and executing the DDL statements necessary to create the required database objects, including the sequence.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/scenarios/usingsequenceforuniqueid.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:scenario-usingsequenceforuniqueid-storesetup-2]>\n```\n\n----------------------------------------\n\nTITLE: Add Subclass Hierarchy - C#\nDESCRIPTION: This snippet shows how to configure the hierarchy of document types in Marten, specifically for the Smurf hierarchy. It maps the PapaSmurf and PapySmurf as subclasses of Smurf.  This configuration allows queries against Smurf to retrieve Smurf, PapaSmurf, and PapySmurf documents. Dependencies: Marten library.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/advanced/hierarchies.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:add-subclass-hierarchy]>\n```\n\n----------------------------------------\n\nTITLE: Event Store: Start Stream with Explicit Type\nDESCRIPTION: This code snippet demonstrates how to start a new event stream in Marten's event store with an explicitly defined aggregate type. This is useful when you need to specify the type association for the stream explicitly. The `StartStream<T>` method is used with the type parameter specifying the aggregate.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/events/index.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:event-store-start-stream-with-explicit-type]>\n```\n\n----------------------------------------\n\nTITLE: Overriding Schema Name for Event Store in Marten (C#)\nDESCRIPTION: This code snippet demonstrates how to override the default schema for the EventStore's tables and functions. This involves setting the `DatabaseSchemaName` property within the `EventStoreOptions` during store configuration. Doing so places all EventStore objects in the specified schema.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/schema/index.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\noptions.DatabaseSchemaName = \"event_store\";\n```\n\n----------------------------------------\n\nTITLE: Using Document Alias Attribute in Marten (C#)\nDESCRIPTION: This snippet illustrates how to use the `DocumentAlias` attribute to override the default document alias for a class.  The `Tractor` class is decorated with the `[DocumentAlias(\"johndeere\")]` attribute, which will cause Marten to use \"johndeere\" as the alias for this document type. It depends on the Marten library.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/schema/storage.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[DocumentAlias(\"johndeere\")]\npublic class Tractor\n{\n    public string id;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Duplicated Field Unique Index with Store Options (Single Property) - C#\nDESCRIPTION: This code snippet demonstrates how to define a unique index on a duplicated field using the `StoreOptions` fluent interface. This method creates a unique index on a dedicated database column mapped to a document property. Using duplicated fields can improve query performance.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/unique.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:using_a_single_property_duplicate_field_unique_index_through_store_options]>\n```\n\n----------------------------------------\n\nTITLE: Implementing MartenRegistry - C#\nDESCRIPTION: This snippet demonstrates how to create a custom MartenRegistry subclass to define document type configurations. It shows how to specify duplicate indexes for Organization and User documents using the fluent interface provided by MartenRegistry.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/storeoptions.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic class OrganizationRegistry: MartenRegistry\n{\n    public OrganizationRegistry()\n    {\n        For<Organization>().Duplicate(x => x.OtherName);\n        For<User>().Duplicate(x => x.UserName);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Resolving Document Schema in Marten\nDESCRIPTION: Demonstrates how to resolve document schema settings using `DocumentSchemaResolver`. It retrieves the database and events schema names from the document store options and asserts their values.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/advanced-sql.md#_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nvar schema = theSession.DocumentStore.Options.Schema;\n\nschema.DatabaseSchemaName.ShouldBe(\"public\");\nschema.EventsSchemaName.ShouldBe(\"public\");\n```\n\n----------------------------------------\n\nTITLE: SQL Query for Active Users\nDESCRIPTION: This SQL snippet shows the generated SQL query to retrieve active (non-deleted) users, filtering based on the `mt_deleted` column. It orders the result by the `UserName`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/deletes.md#_snippet_10\n\nLANGUAGE: SQL\nCODE:\n```\nselect d.data ->> 'UserName' from public.mt_doc_user as d where mt_deleted = False order by d.data ->> 'UserName'\n```\n\n----------------------------------------\n\nTITLE: MultiStreamProjection:  Using a Common Interface for Identity\nDESCRIPTION: This example demonstrates how to use a common interface to define the identity for multiple event types in a MultiStreamProjection. It creates a UserGroupsAssignmentProjection2 and uses Identity<IUserEvent>(x => x.UserId) to specify the aggregate ID for any event that implements the IUserEvent interface.  This simplifies the identity configuration when multiple event types share a common identity property.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/multi-stream-projections.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic class UserGroupsAssignmentProjection2: MultiStreamProjection<UserGroupsAssignment, Guid>\n{\n    public UserGroupsAssignmentProjection2()\n    {\n        // This is just specifying the aggregate document id\n        // per event type. This assumes that each event\n        // applies to only one aggregated view document\n\n        // The easiest possible way to do this is to use\n        // a common interface or base type, and specify\n        // the identity rule on that common type\n        Identity<IUserEvent>(x => x.UserId);\n    }\n\n    public void Apply(UserRegistered @event, UserGroupsAssignment view)\n        => view.Id = @event.UserId;\n\n    public void Apply(SingleUserAssignedToGroup @event, UserGroupsAssignment view)\n        => view.Groups.Add(@event.GroupId);\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Id Fluent Interface\nDESCRIPTION: This code sample demonstrates how to configure the identity property or field for a document type through `StoreOptions` using the `Schema` to obtain a document mapping.  This is an alternative approach to using the `[Identity]` attribute.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/identity/index.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n// SAMPLE: sample-override-id-fluent-interance\nusing Marten;\nusing Marten.Mapping;\n\npublic class User {\n  public int UserId {get; set;}\n  public string FirstName {get; set;}\n  public string LastName {get; set;}\n\n}\n\npublic static class OverrideIdConfig {\n  public static void OverrideId() {\n    var store = DocumentStore.For(_ => {\n      _.Connection(\"some connection string\");\n      _.Schema.For<User>().IdStrategy(x => x.UserId);\n    });\n  }\n}\n// ENDSAMPLE\n```\n\n----------------------------------------\n\nTITLE: Configuring Event Store Database Schema (C#)\nDESCRIPTION: This snippet demonstrates how to configure the database schema for the Marten EventStore.  By setting `StoreOptions.Events.DatabaseSchemaName`, you can ensure that all EventStore-related tables and functions are created in a specific schema, separate from the default document store schema. This allows for better organization and management of event data.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/schema/index.md#_snippet_3\n\nLANGUAGE: cs\nCODE:\n```\nStoreOptions.Events.DatabaseSchemaName = \"event_store\";\n```\n\n----------------------------------------\n\nTITLE: Custom StoreOptions subclass - C#\nDESCRIPTION: Illustrates how to create a custom subclass of `StoreOptions` to encapsulate Marten configuration. This approach is useful for sharing configuration across different applications, testing, or migration tooling.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/index.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic class DevelopmentStoreOptions : StoreOptions\n{\n    public DevelopmentStoreOptions()\n    {\n        Connection(\"some connection string\");\n        AutoCreateSchema(AutoCreate.All);\n        DatabaseSchemaName = \"override\";\n        \n        // Use a lower batch size for testing\n        // purposes\n        Projections.MaximumSnapshotEnvelopeAge = TimeSpan.FromSeconds(5);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Invoice Approval Workflow with Mutate - C#\nDESCRIPTION: This snippet demonstrates a command handler that uses the `MutateInvoice` extension method to approve an invoice by appending an `InvoiceApproved` event if the invoice's status is not already approved. It takes an `IDocumentSession` and an `invoiceId` as input, then uses `MutateInvoice` to handle the event appending and persistence.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/read-aggregates.md#_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic static Task Approve(IDocumentSession session, Guid invoiceId)\n{\n    return session.MutateInvoice(invoiceId, invoice =>\n    {\n        if (invoice.Status != InvoiceStatus.Approved)\n        {\n            return [new InvoiceApproved()];\n        }\n\n        return [];\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Querying with SelectMany() for child documents in Marten (C#)\nDESCRIPTION: This snippet shows how to use `SelectMany()` to query against collections of child documents. It flattens the `Children` collection of `Target` documents, applies a `Where` clause, orders the result, skips some elements, takes a subset, and then converts the results to a List. Requires `query` to be an initialized `IQuerySession`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/projections.md#_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nvar results = query.Query<Target>()\n    .SelectMany(x => x.Children)\n    .Where(x => x.Flag)\n    .OrderBy(x => x.Id)\n    .Skip(20)\n    .Take(15)\n    .ToList();\n```\n\n----------------------------------------\n\nTITLE: Customizing Upsert Rights - C#\nDESCRIPTION: This code snippet shows how to configure Marten to use definer permissions for the generated upsert functions. This will cause the functions to execute under the privileges of the Postgresql user account that created the function, rather than the current user.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/schema/authorization.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:customizing_upsert_rights]>\n```\n\n----------------------------------------\n\nTITLE: Overriding Hilo with Marten Registry\nDESCRIPTION: This snippet demonstrates how to override the Hilo configuration for a document type using the `MartenRegistry` fluent interface. It configures the `HiloSettings` for the `IntDoc` document type, specifically setting the `MaxLo` value.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/identity.md#_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n    // Overriding the Hilo settings for the document type \"IntDoc\"\n    _.Schema.For<IntDoc>()\n        .HiloSettings(new HiloSettings {MaxLo = 66});\n\n    _.Connection(ConnectionSource.ConnectionString);\n\n    _.DatabaseSchemaName = \"sequences\";\n});\n```\n\n----------------------------------------\n\nTITLE: Write Schema Patch to SQL File with Marten (C#)\nDESCRIPTION: Shows how to export a SQL patch file containing DDL commands to update the database schema to match the Marten configuration. It uses the IDocumentStore.Schema.WritePatch() method to generate both update and rollback scripts. The update script is suffixed with '.sql' and the rollback with 'drop.sql'.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/schema/migrations.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n[sample:WritePatch]\n```\n\n----------------------------------------\n\nTITLE: Indexing Soft Deleted Documents with Attribute in Marten (C#)\nDESCRIPTION: This code snippet illustrates creating a partial index on deleted documents using the `SoftDeletedAttribute`. This helps optimize queries utilizing `IsDeleted()`, `DeletedSince(DateTimeOffset)` and `DeletedBefore(DateTimeOffset)`. The index is only created for documents where `mt_deleted = true`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/metadata_index.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:SoftDeletedWithIndexAttribute]>\n```\n\n----------------------------------------\n\nTITLE: Customizing Database Role - C#\nDESCRIPTION: This code snippet demonstrates how to configure Marten to run DDL scripts under a specific Postgresql ROLE. This will wrap any DDL scripts generated or exported by Marten with `SET ROLE [ROLE_NAME];` and `RESET ROLE;` statements.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/schema/authorization.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:customizing_role]>\n```\n\n----------------------------------------\n\nTITLE: Storing Non-Uniform JSON Records (Dynamic)\nDESCRIPTION: Illustrates a sample scenario with non-uniform records representing temperature sensor data, where records are identified by either the 'detector' or 'sensor' field. This data structure showcases the need for dynamic handling of varying JSON structures.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/scenarios/dynamicdata.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:sample-scenarios-dynamic-records]>\n```\n\n----------------------------------------\n\nTITLE: Deleting Redundant Property with Patch - C#\nDESCRIPTION: This code snippet demonstrates how to delete a redundant property from a persisted document using the `Patch.Delete()` operation.  It utilizes the string overload of `Delete()` to specify the property to be removed. The property specified does not need to exist on the current document structure.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/partial-updates-patching.md#_snippet_13\n\nLANGUAGE: cs\nCODE:\n```\ntheSession.Patch<Target>(target.Id).Delete(\"String\");\n```\n\n----------------------------------------\n\nTITLE: Installing Marten.NodaTime via NuGet\nDESCRIPTION: This command installs the Marten.NodaTime NuGet package, which provides the necessary setup for using Noda Time with Marten. This package needs to be installed to enable NodaTime support within a Marten project. The command is executed in the Package Manager Console.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/noda_time.md#_snippet_0\n\nLANGUAGE: powershell\nCODE:\n```\nPM> Install-Package Marten.NodaTime\n```\n\n----------------------------------------\n\nTITLE: Fetching Stream State in Marten (C#)\nDESCRIPTION: Illustrates how to check the state of an event stream, including its version (number of events) and aggregate type, using `IEventStore.FetchStreamState()` or `IBatchQuery.Events.FetchStreamState()`. Returns a `StreamState` object containing creation and last updated timestamps.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/events/streams.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:fetching_stream_state]>\n```\n\n----------------------------------------\n\nTITLE: Configure Global Projections for Conjoined Tenancy (C#)\nDESCRIPTION: This C# code snippet shows how to enable global projections for conjoined tenancy in Marten. This configuration is required when using conjoined tenancy within your event storage. The snippet assumes you have a `StoreOptions` object named `opts`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/multi-stream-projections.md#_snippet_10\n\nLANGUAGE: cs\nCODE:\n```\n// opts is a StoreOptions object\nopts.Events.EnableGlobalProjectionsForConjoinedTenancy = true;\n```\n\n----------------------------------------\n\nTITLE: Querying Interface Definition with Linq in Marten\nDESCRIPTION: This code snippet defines the `Query<T>` method within the `IMartenQueryable` interface. It allows querying documents of type `T` using Linq operators. The method returns an `IMartenQueryable<T>` object, which implements `IQueryable`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/index.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n/// <summary>\n///     Use Linq operators to query the documents\n///     stored in Postgresql\n/// </summary>\n/// <typeparam name=\"T\"></typeparam>\n/// <returns></returns>\nIMartenQueryable<T> Query<T>();\n```\n\n----------------------------------------\n\nTITLE: Include with Dictionary - C#\nDESCRIPTION: This code snippet showcases including a list of related `User` documents into a dictionary keyed by their Id.  It queries for `Issue` documents and includes related `User` documents based on `AssigneeId`, storing them in the `users` dictionary.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/include.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar users = new Dictionary<Guid, User>();\n\nvar issues = await session.Query<Issue>()\n    .Include(x => x.AssigneeId, users)\n    .ToListAsync();\n```\n\n----------------------------------------\n\nTITLE: Creating a Table using an Existing Sequence in PostgreSQL\nDESCRIPTION: This snippet demonstrates how to create a new table that utilizes an existing sequence for its `id` column. It shows how to define the column as an `int` with a default value that calls `nextval()` on the specified sequence. This enables sharing a sequence between multiple tables.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/postgres/types.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\ncreate table if not exists serial_two (\n        id int not null default(nextval('serial_one_id_seq')),\n        name text\n    );\n\n    insert into serial_two (name) values ('demi');\n    insert into serial_two (name) values ('nigel');\n\n    select * from serial_two;\n```\n\n----------------------------------------\n\nTITLE: Customize JSON Enum Storage (C#)\nDESCRIPTION: This snippet shows how to customize the storage of enum values in Marten's JSON serialization.  It configures both Newtonsoft.Json and System.Text.Json to store enums as strings instead of the default integer representation. Dependencies: Marten DocumentStore.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/json.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n    // Newtonsoft // [!code focus:5]\n    _.UseNewtonsoftForSerialization(enumStorage: EnumStorage.AsString);\n\n    // STJ\n    _.UseSystemTextJsonForSerialization(enumStorage: EnumStorage.AsString);\n});\n```\n\n----------------------------------------\n\nTITLE: Custom Grouper Using Flat Table Projection (C#)\nDESCRIPTION: This snippet demonstrates a custom `IAggregateGrouper` (`ProjectEventGrouper`) that uses a flat table projection to resolve the `ProjectId` based on the `UserId` for `TaskCompleted` events.  It queries the `user_project_mapping` table to find the `ProjectId` associated with the `UserId` (which is available as `StreamId` in this sample) and then adds the event to the corresponding group.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/multi-stream-projections.md#_snippet_7\n\nLANGUAGE: cs\nCODE:\n```\npublic class ProjectEventGrouper : IAggregateGrouper<Guid>\n{\n    public async Task Group(IQuerySession session, IEnumerable<IEvent> events, ITenantSliceGroup<Guid> grouping)\n    {\n        foreach (var @event in userEvents)\n        {\n            if(@event.Data is TaskCompleted taskCompleted)\n            {\n                var mapping = await session.Query<UserJoinedProject>()\n                    .Where(mapping => mapping.UserId == @event.StreamId)\n                    .SingleAsync();\n                grouping.AddEvent(mapping.ProjectId, @event);\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Searching Case-Insensitive String Fields in Marten with Linq\nDESCRIPTION: Shows how to perform case-insensitive string searches using `StartsWith`, `EndsWith`, `Contains`, and `Equals` with `StringComparison.OrdinalIgnoreCase`.  Requires an `IDocumentSession` and a document type with a string property.  Also depends on `Marten.Util` for `Contains` extension.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/strings.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic void case_insensitive_string_fields(IDocumentSession session)\n{\n    session.Query<Target>().Where(x => x.String.StartsWith(\"A\", StringComparison.OrdinalIgnoreCase));\n    session.Query<Target>().Where(x => x.String.EndsWith(\"SuFfiX\", StringComparison.OrdinalIgnoreCase));\n\n    // using Marten.Util\n    session.Query<Target>().Where(x => x.String.Contains(\"soMeThiNg\", StringComparison.OrdinalIgnoreCase));\n\n    session.Query<Target>().Where(x => x.String.Equals(\"ThE SaMe ThInG\", StringComparison.OrdinalIgnoreCase));\n\n}\n```\n\n----------------------------------------\n\nTITLE: Using Statement for Json.NET Upcaster Class\nDESCRIPTION: This snippet shows the using statement needed to import the `JsonNet` upcaster base class.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/versioning.md#_snippet_21\n\nLANGUAGE: csharp\nCODE:\n```\nusing Marten.Services.Json.Transformations.JsonNet;\n```\n\n----------------------------------------\n\nTITLE: Storing and Reading Invoice Data from Marten in C#\nDESCRIPTION: This snippet demonstrates how to persist an invoice to the event stream using a Marten repository and then reload it from the event stream.  It verifies that the replayed state matches the original data.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/scenarios/aggregates_events_repositories.md#_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:scenario-aggregate-storeandreadinvoice]>\n```\n\n----------------------------------------\n\nTITLE: ISerializer Interface Definition\nDESCRIPTION: Defines the ISerializer interface, which acts as an adapter for JSON serialization within Marten. This interface allows for different JSON serialization libraries or custom configurations to be plugged into the DocumentStore. Implementing this interface enables users to customize how Marten serializes and deserializes documents to/from JSON.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/json/index.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic interface ISerializer\n{\n    string ToJson(object document);\n    T FromJson<T>(string json);\n\n    // The actual Newtonsoft.Json.JsonSerializer used internally\n    JsonSerializer Serializer { get; }\n\n    // Customize the LINQ expression generation\n    IExpressionCompiler ExpressionCompiler { get; }\n\n    // Customize the data type mappings to Postgresql\n    ITypeNameSource TypeNameSource { get; }\n\n    // Write out JSON to a stream\n    void ToJson(object document, Stream stream);\n\n    // Read JSON from a stream\n    object FromJson(Type type, Stream stream);\n}\n```\n\n----------------------------------------\n\nTITLE: Deleting Nested Redundant Property with Patch - C#\nDESCRIPTION: This code snippet demonstrates how to delete a redundant nested property within a persisted document using `Patch.Delete()`. It uses a location lambda to specify the nested property's path. The property specified does not need to exist on the current document structure.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/partial-updates-patching.md#_snippet_14\n\nLANGUAGE: cs\nCODE:\n```\ntheSession.Patch<Target>(target.Id).Delete(\"String\", t => t.Inner);\n```\n\n----------------------------------------\n\nTITLE: Creating a Schema Conditionally\nDESCRIPTION: This snippet demonstrates how to create a schema in PostgreSQL only if it doesn't already exist. It uses a PL/pgSQL block with an IF statement to check for the existence of the schema in the `information_schema.schemata` catalog. If the schema doesn't exist, it executes a `CREATE SCHEMA` command.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/postgres/if-statements.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\nDO $$\nBEGIN\n    IF NOT EXISTS(\n        SELECT schema_name\n          FROM information_schema.schemata\n          WHERE schema_name = 'inventory'\n      )\n    THEN\n      EXECUTE 'CREATE SCHEMA inventory';\n    END IF;\nEND\n$$;\n```\n\n----------------------------------------\n\nTITLE: Using Take() and Skip() for Paging with Linq in Marten (C#)\nDESCRIPTION: Demonstrates how to use the `IQueryable.Take()` and `IQueryable.Skip()` methods for simple paging. `Take()` specifies the number of items to return, and `Skip()` specifies the number of items to skip.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/linq.md#_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\nvar page1 = session.Query<Target>().Skip(0).Take(10).ToList(); // First 10\nvar page2 = session.Query<Target>().Skip(10).Take(10).ToList(); // Next 10\n```\n\n----------------------------------------\n\nTITLE: Customizing Table Creation Style - C#\nDESCRIPTION: This code snippet demonstrates how to customize the table creation style in Marten to use `CREATE TABLE IF NOT EXISTS` instead of the default `DROP TABLE` followed by `CREATE TABLE`. This can be useful to avoid errors when the table already exists.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/schema/authorization.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:customizing_table_creation]>\n```\n\n----------------------------------------\n\nTITLE: Projecting Deep (Nested) Properties, C#\nDESCRIPTION: This code snippet demonstrates how to run projection queries on deep (nested) properties using the `Select()` method in Marten.  It allows accessing properties within complex object structures.  This is accomplished by using the linq `IQueryable.Select()` method.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/projections.md#_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:deep_properties_projection]>\n```\n\n----------------------------------------\n\nTITLE: Using DDL Templates - C#\nDESCRIPTION: This code snippet demonstrates how to apply DDL templates to customize database security on document storage tables and upsert functions. It reads template files from a directory and applies them during `IDocumentStore` initialization.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/schema/authorization.md#_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:using_ddl_templates]>\n```\n\n----------------------------------------\n\nTITLE: Defining Candle Data Type (C#)\nDESCRIPTION: Defines a `Candle` class with properties for Open, Close, High, Low, Volume, and Time. This data represents a financial candle used in charting.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/projection-by-event-type.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic class Candle\n{\n    public decimal Open { get; set; }\n    public decimal Close { get; set; }\n    public decimal High { get; set; }\n    public decimal Low { get; set; }\n    public int Volume { get; set; }\n    public DateTime Time { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Sequences in PostgreSQL\nDESCRIPTION: This snippet shows how to query available sequences in PostgreSQL using the `information_schema.sequences` table. This is useful for identifying the sequences created by `serial` columns or manually created sequences. It returns all sequences defined in the current database.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/postgres/types.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\nselect * from information_schema.sequences;\n```\n\n----------------------------------------\n\nTITLE: Explicitly Mapping Metadata in Marten (C#)\nDESCRIPTION: This snippet demonstrates how to explicitly map members of a document type to metadata columns in Marten. It configures the `DocumentStore` to map the `Version`, `Causation`, and `IsDeleted` properties of the `DocWithMetadata` class to the `mt_version`, `correlation_id` and `mt_deleted` metadata columns respectively.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/metadata.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(opts =>\n{\n    opts.Connection(\"some connection string\");\n\n    // Explicitly map the members on this document type\n    // to metadata columns.\n    opts.Schema.For<DocWithMetadata>().Metadata(m =>\n    {\n        m.Version.MapTo(x => x.Version);\n        m.CausationId.MapTo(x => x.Causation);\n        m.IsSoftDeleted.MapTo(x => x.IsDeleted);\n    });\n});\n```\n\n----------------------------------------\n\nTITLE: Default Username Transformation Logic (C#)\nDESCRIPTION: This C# code defines a simple logic for generating a default username by concatenating the first and last names of a user. It serves as an example of the kind of transformation that might be applied to existing documents using a Javascript function for data migration.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/advanced/javascript_transformations.md#_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\npublic void AssignUserName(User user)\n{\n    if (string.IsNullOrEmpty(user.UserName))\n    {\n        user.UserName = user.FirstName + user.LastName;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Find User by First Name (Compiled Query) in Marten (C#)\nDESCRIPTION: Defines a compiled query to find the first user with a given first name using Marten. Compiled queries can be incorporated into batch queries for enhanced performance.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/batched_queries.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic class FindByFirstName : ICompiledQuery<User, User>\n{\n    public FindByFirstName(string firstName)\n    {\n        FirstName = firstName;\n    }\n\n    public string FirstName { get; set; }\n\n    public Expression<Func<IQueryable<User>, User>> QueryIs()\n    {\n        return q => q.FirstOrDefault(x => x.FirstName == FirstName);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Custom MartenAttribute - C#\nDESCRIPTION: Demonstrates how to create a custom attribute by subclassing `MartenAttribute`. This allows for custom configuration of `DocumentMapping` models based on attribute annotations on document types or their fields/properties.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/index.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic class MyCustomAttribute : MartenAttribute\n{\n    private readonly string _columnName;\n\n    public MyCustomAttribute(string columnName)\n    {\n        _columnName = columnName;\n    }\n\n    public override void Modify(DocumentMapping mapping, MemberInfo member)\n    {\n        if (member is PropertyInfo property)\n        {\n            mapping.Field(member).JsonName(_columnName);\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Plugging In Session Logger to Session\nDESCRIPTION: This C# snippet shows how to apply a custom session logger (`RecordingLogger`) directly to an `IQuerySession` or `IDocumentSession`. The `Logger` property of the session is assigned the custom logger instance.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/diagnostics.md#_snippet_9\n\nLANGUAGE: cs\nCODE:\n```\nusing var session = store.LightweightSession();\n// Replace the logger for only this one session\nsession.Logger = new RecordingLogger();\n```\n\n----------------------------------------\n\nTITLE: DDL Template for Document Storage Tables (SQL)\nDESCRIPTION: This SQL snippet shows an example of a DDL template file for document storage tables in Marten. The template includes statements for altering the table owner and granting select, insert, update, and delete permissions to specific roles. Placeholders such as %SCHEMA%, %TABLENAME%, %COLUMNS%, %NON_ID_COLUMNS%, and %METADATA_COLUMNS% are used and will be replaced by Marten with the actual values when the template is applied.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/schema/authorization.md#_snippet_5\n\nLANGUAGE: SQL\nCODE:\n```\nALTER TABLE %SCHEMA%.%TABLENAME% OWNER TO \"SchemaOwners\";\nGRANT SELECT (%COLUMNS%) ON TABLE %SCHEMA%.%TABLENAME% TO \"ServiceAccountRole\", \"SchemaOwners\";\nGRANT INSERT (%COLUMNS%) ON TABLE %SCHEMA%.%TABLENAME% TO \"SchemaOwners\";\nGRANT UPDATE (%NON_ID_COLUMNS%) ON TABLE %SCHEMA%.%TABLENAME% TO \"SchemaOwners\";\nGRANT DELETE ON %SCHEMA%.%TABLENAME% TO \"ServiceAccountRole\";\n```\n\n----------------------------------------\n\nTITLE: Using Query Plan in Batched Query - C#\nDESCRIPTION: This code snippet illustrates how to use a query plan within a batched query in Marten.  It creates a batch query, registers query plans for different colors using `batch.QueryByPlan`, executes the batch, and then retrieves the results.  The example showcases the usage of `ColorTargets` query plans to fetch blue and green targets, and then asserts that results contain the right data.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/compiled-queries.md#_snippet_22\n\nLANGUAGE: csharp\nCODE:\n```\n[Fact]\npublic async Task use_as_batch()\n{\n    await theStore.Advanced.Clean.DeleteDocumentsByTypeAsync(typeof(Target));\n\n    var targets = Target.GenerateRandomData(1000).ToArray();\n    await theStore.BulkInsertDocumentsAsync(targets);\n\n    // Start a batch query\n    var batch = theSession.CreateBatchQuery();\n\n    // Using the ColorTargets plan twice, once for \"Blue\" and once for \"Green\" target documents\n    var blueFetcher = batch.QueryByPlan(new ColorTargets(Colors.Blue));\n    var greenFetcher = batch.QueryByPlan(new ColorTargets(Colors.Green));\n\n    // Execute the batch query\n    await batch.Execute();\n\n    // The batched querying in Marten is essentially registering a \"future\"\n    // for each query, so we'll await each task from above to get at the actual\n    // data returned from batch.Execute() above\n    var blues = await blueFetcher;\n    var greens = await greenFetcher;\n\n    // And the assertion part of our arrange, act, assertion test\n    blues.ShouldNotBeEmpty();\n    greens.ShouldNotBeEmpty();\n\n    var expectedBlues = targets.Where(x => x.Color == Colors.Blue).OrderBy(x => x.Number);\n    var expectedReds = targets.Where(x => x.Color == Colors.Green).OrderBy(x => x.Number);\n\n    blues.Select(x => x.Id).ShouldBe(expectedBlues.Select(x => x.Id));\n    greens.Select(x => x.Id).ShouldBe(expectedReds.Select(x => x.Id));\n}\n```\n\n----------------------------------------\n\nTITLE: Document Store Configuration with Auto Mode (C#)\nDESCRIPTION: This code snippet shows how to configure a Marten document store with the `TypeLoadMode.Auto` setting.  When a document type is encountered for the first time, Marten will either use a pre-compiled type or generate a new C# code file under `/Internal/Generated/DocumentStorage`. The ConnectionSource.ConnectionString is used for the database connection. This requires the Marten library and the connection string to be set up.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/prebuilding.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nusing var store = DocumentStore.For(opts =>\n{\n    // ConnectionSource is a little helper in the Marten\n    // test suite\n    opts.Connection(ConnectionSource.ConnectionString);\n\n    opts.GeneratedCodeMode = TypeLoadMode.Auto;\n});\n```\n\n----------------------------------------\n\nTITLE: Using System.Text.Json Transformations in Marten\nDESCRIPTION: This snippet shows the necessary using statement to incorporate System.Text.Json transformations within Marten. It ensures that the correct namespace is included for working with JSON transformations.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/versioning.md#_snippet_23\n\nLANGUAGE: cs\nCODE:\n```\nusing Marten.Services.Json.Transformations.SystemTextJson;\n```\n\n----------------------------------------\n\nTITLE: Add Subclass Hierarchy\nDESCRIPTION: Configures Marten to recognize and use the defined Smurf hierarchy for querying. It shows how to add a hierarchy using `AddSubClassHierarchy` and provides alternative options with assembly scanning (though discouraged for larger projects). Also includes setting up connection and schema options.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/hierarchies.md#_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\npublic query_with_inheritance(ITestOutputHelper output)\n{\n    _output = output;\n    StoreOptions(_ =>\n    {\n        _.Schema.For<ISmurf>()\n            .AddSubClassHierarchy(typeof(Smurf), typeof(PapaSmurf), typeof(PapySmurf), typeof(IPapaSmurf),\n                typeof(BrainySmurf));\n\n        // Alternatively, you can use the following:\n        // _.Schema.For<ISmurf>().AddSubClassHierarchy();\n        // this, however, will use the assembly\n        // of type ISmurf to get all its' subclasses/implementations.\n        // In projects with many types, this approach will be unadvisable.\n\n        _.Connection(ConnectionSource.ConnectionString);\n        _.AutoCreateSchemaObjects = AutoCreate.All;\n\n        _.Schema.For<ISmurf>().GinIndexJsonData();\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Query Database for Sequence Value\nDESCRIPTION: Demonstrates how to query the database for a new and unique sequence number when creating and persisting new instances. It retrieves a human-readable identifier and assigns it to the `Matter` field while using a `Guid` for the internal ID.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/scenarios/usingsequenceforuniqueid.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:scenario-usingsequenceforuniqueid-querymatter]>\n```\n\n----------------------------------------\n\nTITLE: Querying Directly Against Event Data (C#)\nDESCRIPTION: Demonstrates how to issue Linq queries against specific event types using the `IEventStore.Query()` method. This queries the `mt_events` table directly and should be used with caution due to performance implications.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/events/streams.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:query-against-event-data]>\n```\n\n----------------------------------------\n\nTITLE: Setting Stream Identity - Marten - C#\nDESCRIPTION: This snippet shows how to configure the stream identity in Marten's event store. Streams can be identified by either Guids or strings. This example sets the stream identity to use strings by configuring the `StreamIdentity` property. The stream identity must be configured once per store and different identity types cannot be mixed.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/configuration.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(opts =>\n{\n    opts.Connection(\"some connection string\");\n\n    // Override the stream identity to use strings\n    opts.Events.StreamIdentity = StreamIdentity.AsString;\n});\n```\n\n----------------------------------------\n\nTITLE: Querying to AsyncEnumerable with Marten in C#\nDESCRIPTION: This code snippet demonstrates how to use the `ToAsyncEnumerable()` extension method in Marten to process query results as an `IAsyncEnumerable<T>`. It fetches a set of `Target` objects, iterates through them asynchronously, and verifies that the expected number of objects were retrieved. The code requires Marten and xUnit for testing.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/async-enumerable.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\n[Fact]\npublic async Task query_to_async_enumerable()\n{\n    var targets = Target.GenerateRandomData(20).ToArray();\n    await theStore.BulkInsertAsync(targets);\n\n    var ids = new List<Guid>();\n\n    var results = theSession.Query<Target>()\n        .ToAsyncEnumerable();\n\n    await foreach (var target in results)\n    {\n        ids.Add(target.Id);\n    }\n\n    ids.Count.ShouldBe(20);\n    foreach (var target in targets)\n    {\n        ids.ShouldContain(target.Id);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: ICompiledQuery for Single Document C#\nDESCRIPTION: This code snippet defines the `ICompiledQuery` interface for queries that return a single document without any transformation. It's a specialization of `ICompiledQuery` where both the document type and result type are the same.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/compiled_queries.md#_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\npublic interface ICompiledQuery<TDoc> : ICompiledQuery<TDoc, TDoc>\n{\n\n}\n```\n\n----------------------------------------\n\nTITLE: Bulk Insert with Overwrite Duplicates (C#)\nDESCRIPTION: Illustrates how to use bulk insert to overwrite existing documents with matching IDs. Marten creates a temporary table, inserts the new values, and then uses INSERT and UPDATE commands to copy and overwrite data in the real table.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/basics/bulk_insert.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:bulk_insert_with_OverwriteExisting]>\n```\n\n----------------------------------------\n\nTITLE: Old Event Namespace Example\nDESCRIPTION: This snippet demonstrates the structure of an event class before a namespace migration. It shows the original namespace and class definition of the `OrderStatusChanged` event. This is the starting point before moving the event to a new namespace.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/events/versioning/index.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic class OrderStatusChanged\n{\n    public Guid OrderId { get; set; }\n    public string Status { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Live Transformed Events in C#\nDESCRIPTION: This sample demonstrates how to query for live transformed events using the `TransformTo<T>` extension method. This allows you to retrieve the transformed view document directly from the event store without needing to pre-calculate it.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/events/projections/index.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n// SAMPLE: using_live_transformed_events\nusing var host = Host.CreateDefaultBuilder()\n    .ConfigureServices(services =>\n    {\n        services.AddMarten(opts =>\n        {\n            opts.Projections.Add<MonsterDefeatedTransform>(ProjectionLifecycle.Inline);\n        });\n    }).Build();\n\nusing (var scope = host.Services.CreateScope())\n{\n    var store = scope.ServiceProvider.GetRequiredService<IEventStore>();\n\n    var streamId = Guid.NewGuid();\n    await using (var session = store.OpenSession())\n    {\n        session.Events.Append(streamId, new MonsterSlayed(\"Troll\", \"Bob\"));\n        await session.SaveChangesAsync();\n    }\n\n    await using (var querySession = store.QuerySession())\n    {\n        // Look up the transformed view from the underlying event stream\n        var defeated = await querySession\n            .Events\n            .QueryStream(streamId)\n            .TransformTo<MonsterDefeated>(streamId);\n    }\n}\n// ENDSAMPLE\n```\n\n----------------------------------------\n\nTITLE: IsBlue Method Definition C#\nDESCRIPTION: This snippet defines an extension method `IsBlue()` for the `Target` class. This method is intended to be used within Linq queries, although its actual implementation is not strictly required for Linq parsing.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/advanced/customizing_linq.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n <[sample:IsBlue]>\n```\n\n----------------------------------------\n\nTITLE: Replacing Serializer with Jil in C#\nDESCRIPTION: This code snippet demonstrates how to replace the default `ISerializer` in Marten with a custom serializer, in this case, the `JilSerializer`. It shows how to configure the `DocumentStore` to use the custom serializer by setting the `Serializer` property in the `Settings` configuration. This step is necessary to tell Marten to use Jil for all serialization and deserialization operations.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/json/jil.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n    _.Connection(\"some connection string\");\n    _.Serializer(new JilSerializer());\n});\n```\n\n----------------------------------------\n\nTITLE: Defining a User Document\nDESCRIPTION: This code defines a simple User document with properties like Id, FirstName, and LastName. This demonstrates how to represent data as a document within Marten.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/getting_started.md#_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\n// Options +=> GettingStarted/user_document.cs\nusing System;\n\npublic class User\n{\n    public Guid Id { get; set; }\n\n    public string FirstName { get; set; }\n    public string LastName { get; set; }\n\n    public string FullName => $\"{FirstName} {LastName}\";\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an IEvent Interface (C#)\nDESCRIPTION: Shows the structure of a strongly-typed `Event<T>` object which implements `IEvent`. This provides metadata about the event, including its version number within the stream.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/events/streams.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:IEvent]>\n```\n\n----------------------------------------\n\nTITLE: Using Min() with Linq in Marten (C#)\nDESCRIPTION: Demonstrates how to use the `IQueryable.Min()` method to find the minimum value of a specific property across all matching documents.  This example finds the minimum value of the `Number` property.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/linq.md#_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\nvar min = session.Query<Target>().Min(x => x.Number);\n```\n\n----------------------------------------\n\nTITLE: Using Average() with Linq in Marten (C#)\nDESCRIPTION: Demonstrates how to use the `IQueryable.Average()` method to calculate the average value of a specific property across all matching documents.  This example calculates the average value of the `Number` property.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/linq.md#_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\nvar avg = session.Query<Target>().Average(x => x.Number);\n```\n\n----------------------------------------\n\nTITLE: Querying within Value IEnumerables using Linq in Marten (C#)\nDESCRIPTION: Illustrates how to perform \"contains\" searches within Arrays, Lists & ILists of primitive values like string or numbers. Uses Contains.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/linq.md#_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\npublic class Target\n{\n    public Guid Id { get; set; }\n    public string[] Tags { get; set; }\n\n}\n\nvar targets = session.Query<Target>().Where(x => x.Tags.Contains(\"Tag1\")).ToList();\n```\n\n----------------------------------------\n\nTITLE: Using Count() with Linq in Marten (C#)\nDESCRIPTION: Shows how to use the `IQueryable.Count()` method to retrieve the number of documents matching specific criteria.  This example counts the number of documents where the `Number` property is greater than 2.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/linq.md#_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nvar count = session.Query<Target>().Count(x => x.Number > 2);\n```\n\n----------------------------------------\n\nTITLE: Selecting a Single Document with Linq in Marten (C#)\nDESCRIPTION: Shows how to use the `IQueryable.FirstOrDefault()` method to retrieve a single document that matches the specified criteria. Returns the first element, or a default value if no element is found.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/linq.md#_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\nvar single = session.Query<Target>().FirstOrDefault(x => x.Number == 3);\n```\n\n----------------------------------------\n\nTITLE: Add Marten with Scoped Custom Session Factory - C#\nDESCRIPTION: This snippet shows how to register a new scoped session factory within the IoC container, ensuring the correct `ISession` is used at runtime for request-specific logging. Requires a custom `ISessionFactory` implementation that is registered as `Scoped`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/integration.md#_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:AddMartenWithCustomSessionCreationByScope]>\n```\n\n----------------------------------------\n\nTITLE: Using QueryAsync\nDESCRIPTION: Demonstrates how to execute custom SQL queries asynchronously using `QueryAsync`. This improves application responsiveness by offloading the query execution to a background thread. This approach requires using `ToListAsync()` to properly materialize the results.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/sql.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nvar users = await session.Query<User>(\"where data ->> 'FirstName' = 'Jeremy'\").ToListAsync();\n```\n\n----------------------------------------\n\nTITLE: Serializing to Camel Case with Marten\nDESCRIPTION: This code snippet demonstrates how to configure Marten's built-in Json.Net serializer to serialize properties to camel case. It utilizes the `StoreOptions.UseDefaultSerialization` method to customize serialization settings.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/troubleshoot/index.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:sample-serialize-to-camelcase]>\n```\n\n----------------------------------------\n\nTITLE: Defining an Event with Old Namespace C#\nDESCRIPTION: This code snippet defines a simple event class `OrderStatusChanged` within the `OldEventNamespace`. It includes properties for `OrderId` (Guid) and `Status` (int) and a corresponding constructor to initialize these properties. This represents the initial version of the event schema before a namespace change.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/versioning.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nnamespace OldEventNamespace\n{\n    public class OrderStatusChanged\n    {\n        public Guid OrderId { get; }\n        public int Status { get; }\n\n        public OrderStatusChanged(Guid orderId, int status)\n        {\n            OrderId = orderId;\n            Status = status;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Test Data with InitializeMartenWith\nDESCRIPTION: This code snippet demonstrates how to apply initial data specifically for testing scenarios using `IServiceCollection.InitializeMartenWith()` as of Marten v5.1. It configures the application's Marten store in a test project by adding `MyTestingData` as initial data. After initialization, the example shows how to reset and reapply the test data.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/initial-data.md#_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n// Use the configured host builder for your application\n// by calling the Program.CreateHostBuilder() method from\n// your application\n\n// This would be slightly different using WebApplicationFactory,\n// but the IServiceCollection mechanisms would be the same\nvar hostBuilder = Program.CreateHostBuilder(Array.Empty<string>());\n\n// Add initial data to the application's Marten store\n// in the test project\nusing var host = await hostBuilder\n    .ConfigureServices(services =>\n    {\n        services.InitializeMartenWith<MyTestingData>();\n\n        // or\n\n        services.InitializeMartenWith(new MyTestingData());\n    }).StartAsync();\n\n// The MyTestingData initial data set would be applied at\n// this point\nvar store = host.Services.GetRequiredService<IDocumentStore>();\n\n// And in between tests, maybe do this to wipe out the store, then reapply\n// MyTestingData:\nawait store.Advanced.ResetAllData();\n```\n\n----------------------------------------\n\nTITLE: Defining Computed Unique Index with Attribute (Single Property) - C#\nDESCRIPTION: This code snippet demonstrates how to define a unique computed index on a single property using the `[UniqueIndex]` attribute. The absence of the `IndexType` parameter defaults to a computed index.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/unique.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:using_a_single_property_computed_unique_index_through_attribute]>\n```\n\n----------------------------------------\n\nTITLE: Querying sequences in PostgreSQL\nDESCRIPTION: This SQL snippet queries the `information_schema.sequences` table to retrieve information about existing sequences in the database. This is useful for finding sequences created implicitly by `serial` columns.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/postgres/types.md#_snippet_1\n\nLANGUAGE: SQL\nCODE:\n```\nselect * from information_schema.sequences;\n```\n\n----------------------------------------\n\nTITLE: Indexing Last Modified Property via Fluent Interface in Marten (C#)\nDESCRIPTION: This code snippet demonstrates how to create an index on the document's `mt_last_modified` metadata column using the fluent interface within the `DocumentStore.For()` configuration. This method offers more control over the schema configuration.  It configures Marten during the document store setup.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/indexing/metadata-indexes.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nDocumentStore.For(_ =>\n{\n    _.Schema.For<User>().IndexLastModified();\n});\n```\n\n----------------------------------------\n\nTITLE: Querying for Arbitrary JSON Objects in Marten using AdvancedSql\nDESCRIPTION: This snippet demonstrates querying for arbitrary JSON objects that will be deserialized into `Foo` and `Bar` types using `session.AdvancedSql.QueryAsync<T1, T2>()`. It constructs JSON objects using `json_build_object` in the SQL query and returns them as a tuple.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/advanced-sql.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nvar result = (await session.AdvancedSql.QueryAsync<Foo, Bar>(\n    \"select row(json_build_object('Name', 'foo')), row(json_build_object('Name', 'bar')) from (values(1)) as dummy\",\n    CancellationToken.None)).First();\n```\n\n----------------------------------------\n\nTITLE: Creating a custom sequence in PostgreSQL\nDESCRIPTION: This SQL snippet creates a sequence named `my_own_named_sequence`.  This allows for explicit control over sequence naming and configuration before using it in table definitions.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/postgres/types.md#_snippet_3\n\nLANGUAGE: SQL\nCODE:\n```\ncreate sequence my_own_named_sequence\n```\n\n----------------------------------------\n\nTITLE: Querying Any String Array using Linq in Marten (C#)\nDESCRIPTION: Marten also allows you to query over IEnumerables using the Any method for equality (similar to Contains)\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/linq.md#_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\npublic class Target\n{\n    public Guid Id { get; set; }\n    public string[] Tags { get; set; }\n    public List<string> ListTags {get; set;}\n\n}\n\nvar targets = session.Query<Target>().Where(x => x.ListTags.Any(t => t == \"Tag1\")).ToList();\n```\n\n----------------------------------------\n\nTITLE: Replacing Logger per Session\nDESCRIPTION: Shows how to replace the default Marten logger for a specific session. A custom logger (`TestOutputMartenLogger`) is instantiated and assigned to the `Logger` property of the session object.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/diagnostics.md#_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\n// We frequently use this special marten logger per\n// session to pipe Marten logging to the xUnit.Net output\ntheSession.Logger = new TestOutputMartenLogger(_output);\n```\n\n----------------------------------------\n\nTITLE: Bulk Insert Mode Usages in Marten\nDESCRIPTION: This snippet showcases different `BulkInsertMode` options when bulk inserting documents in Marten: `IgnoreDuplicates`, `InsertsOnly` (default), and `OverwriteExisting`. It requires a configured `DocumentStore`, a `Target` class with a `GenerateRandomData` method, and an array of `Target` objects.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/storing.md#_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\n// Just say we have an array of documents we want to bulk insert\nvar data = Target.GenerateRandomData(100).ToArray();\n\nusing var store = DocumentStore.For(\"some connection string\");\n\n// Discard any documents that match the identity of an existing document\n// in the database\nawait store.BulkInsertDocumentsAsync(data, BulkInsertMode.IgnoreDuplicates);\n\n// This is the default mode, the bulk insert will fail if any duplicate\n// identities with existing data or within the data set being loaded are detected\nawait store.BulkInsertDocumentsAsync(data, BulkInsertMode.InsertsOnly);\n\n// Overwrite any existing documents with the same identity as the documents\n// being loaded\nawait store.BulkInsertDocumentsAsync(data, BulkInsertMode.OverwriteExisting);\n```\n\n----------------------------------------\n\nTITLE: Defining ICompiledListQuery with Select\nDESCRIPTION: This interface defines a compiled query that retrieves a list of transformed documents, where the input document type is `TDoc` and the output type is `TOut`. It inherits from `ICompiledQuery<TDoc, IEnumerable<TOut>>` to support a `Select()` transform in the query.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/compiled-queries.md#_snippet_7\n\nLANGUAGE: cs\nCODE:\n```\npublic interface ICompiledListQuery<TDoc, TOut>: ICompiledQuery<TDoc, IEnumerable<TOut>>\n{\n}\n```\n\n----------------------------------------\n\nTITLE: Deleting Documents by Id or Document in Marten\nDESCRIPTION: Demonstrates how to delete documents within a Marten `IDocumentSession` either by passing the document itself, or just by the document Id. The actual deletions are executed within a single database transaction when `IDocumentSession.SaveChanges()` is called.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/basics/deleting.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:deletes]>\n```\n\n----------------------------------------\n\nTITLE: Defining Marten Settings\nDESCRIPTION: Defines a custom configuration class MartenSettings to hold the schema name.  It includes a SECTION constant for configuration binding and a SchemaName property. The SchemaName property will be used to configure the Marten store options.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/testing/integration.md#_snippet_11\n\nLANGUAGE: cs\nCODE:\n```\npublic class MartenSettings\n{\n    public const string SECTION = \"Marten\";\n    public string SchemaName { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled Query AsJson C#\nDESCRIPTION: This code snippet demonstrates how to query for a single document and return it as JSON. It makes a call to `AsJson()` before the call to the aggregation method.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/compiled_queries.md#_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\npublic class CompiledAsJson : ICompiledQuery<User, string>\n{\n    public Expression<Func<IQueryable<User>, string>> QueryIs()\n    {\n        return query => query.AsJson().FirstOrDefault();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled Query to Json Array C#\nDESCRIPTION: This code snippet demonstrates a compiled query that returns multiple results as a JSON array. It utilizes the `ToJsonArray()` method to serialize the query results into a JSON string.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/compiled_queries.md#_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\npublic class CompiledToJsonArray : ICompiledQuery<User, string>\n{\n    public Expression<Func<IQueryable<User>, string>> QueryIs()\n    {\n        return query => query.ToJsonArray();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a custom IConfigureMarten class in C#\nDESCRIPTION: This code demonstrates a custom implementation of the `IConfigureMarten` interface.  The `UserMartenConfiguration` class registers the `User` document type and allows for additional Marten configurations within its `Configure` method. This allows for centralized, type-safe configuration management within a module.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/hostbuilder.md#_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\ninternal class UserMartenConfiguration: IConfigureMarten\n{\n    public void Configure(IServiceProvider services, StoreOptions options)\n    {\n        options.RegisterDocumentType<User>();\n        // and any other additional Marten configuration\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Add Marten with Eager Initialization - C#\nDESCRIPTION: Demonstrates how to force Marten to initialize the document store during bootstrapping, instead of waiting for the first usage. This can be useful for ensuring that the database schema is up-to-date early in the application lifecycle.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/integration.md#_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:AddMartenWithEagerInitialization]>\n```\n\n----------------------------------------\n\nTITLE: Soft Deleted Attribute with Partitioning\nDESCRIPTION: This C# code demonstrates using an attribute to configure soft deletes with partitioning on a document class.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/deletes.md#_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\n[SoftDeleted(UsePartitioning = true)]\npublic class SoftDeletedAndPartitionedDocument\n{\n    public Guid Id { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Multi-Property Calculated Index SQL (Postgresql)\nDESCRIPTION: Shows the SQL generated by Marten for a multi-property calculated index.  The index includes both the `FirstName` and `LastName` properties of the `User` document.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/indexing/computed-indexes.md#_snippet_5\n\nLANGUAGE: SQL\nCODE:\n```\nCREATE INDEX mt_doc_user_idx_first_namelast_name ON public.mt_doc_user USING btree (((data ->> 'FirstName'::text)), ((data ->> 'LastName'::text)))\n```\n\n----------------------------------------\n\nTITLE: Creating table 'Product' with Pascal case in PostgreSQL\nDESCRIPTION: This SQL snippet demonstrates creating a table named 'Product' in PostgreSQL using Pascal case for the table name and column names, which is a common convention in SQL Server. However, PostgreSQL stores table and column names in lowercase by default, so this practice is generally discouraged for better consistency and readability when querying the database metadata.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/postgres/naming.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\ncreate table if not exists Product (\n    Id serial,\n    Name text,\n    Price money,\n    IsDeleted bool,\n    CategoryId int,\n    CreatedByUser int,\n    ModifiedByUser int\n);\n```\n\n----------------------------------------\n\nTITLE: Text Search with Custom Language - Marten C#\nDESCRIPTION: Executes a phrase search query with a non-default language configuration ('italian'). Specifies the language to be used when processing the search term. Requires the Marten library.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/full-text.md#_snippet_16\n\nLANGUAGE: cs\nCODE:\n```\nvar posts = session.Query<BlogPost>()\n    .Where(x => x.PhraseSearch(\"somefilter\", \"italian\"))\n    .ToList();\n```\n\n----------------------------------------\n\nTITLE: Defining Archived Event in Marten\nDESCRIPTION: This snippet defines the `Archived` event record within the `Marten.Events` namespace.  When this event is appended to a stream and processed by a single stream projection, Marten automatically marks the entire stream as archived. The event takes a `Reason` string as a parameter to describe why the event was archived.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/archiving.md#_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace Marten.Events;\n\n/// <summary>\n/// The presence of this event marks a stream as \"archived\" when it is processed\n/// by a single stream projection of any sort\n/// </summary>\npublic record Archived(string Reason);\n```\n\n----------------------------------------\n\nTITLE: Creating PLV8 Extension in PostgreSQL\nDESCRIPTION: This SQL command creates the plv8 extension in the PostgreSQL database, enabling the execution of JavaScript functions within the database. It requires the plv8 binaries to be installed correctly in the PostgreSQL directories.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/admin/installing-plv8-windows.md#_snippet_0\n\nLANGUAGE: SQL\nCODE:\n```\nCREATE EXTENSION plv8;\n```\n\n----------------------------------------\n\nTITLE: Reading Live Invoice Aggregate (C#)\nDESCRIPTION: Demonstrates how to read the current state of an `Invoice` aggregate using `AggregateStreamAsync()` when configured as a `Live` projection. This API retrieves the aggregate state by applying events to the stream identified by `invoiceId`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/read-aggregates.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic static async Task read_live_invoice(\n    IQuerySession session,\n    Guid invoiceId)\n{\n    var invoice = await session\n        .Events.AggregateStreamAsync<Invoice>(invoiceId);\n}\n```\n\n----------------------------------------\n\nTITLE: Include Many Documents into Dictionary with Marten in C#\nDESCRIPTION: This code snippet showcases how to include multiple related documents into a dictionary when querying with Marten. It fetches `Issue` documents along with their assigned `User` documents, storing the related `User` documents in a `Dictionary<Guid, User>`. The `Include()` method takes the dictionary as an argument, and `On()` specifies the join condition based on `AssigneeId`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/include.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic async Task include_to_dictionary()\n{\n    var user1 = new User();\n    var user2 = new User();\n\n    var issue1 = new Issue { AssigneeId = user1.Id, Title = \"Garage Door is busted\" };\n    var issue2 = new Issue { AssigneeId = user2.Id, Title = \"Garage Door is busted\" };\n    var issue3 = new Issue { AssigneeId = user2.Id, Title = \"Garage Door is busted\" };\n\n    using var session = theStore.IdentitySession();\n    session.Store(user1, user2);\n    session.Store(issue1, issue2, issue3);\n    await session.SaveChangesAsync();\n\n    using var query = theStore.QuerySession();\n    var dict = new Dictionary<Guid, User>();\n\n    query.Query<Issue>().Include(dict).On(x => x.AssigneeId).ToArray();\n\n    dict.Count.ShouldBe(2);\n    dict.ContainsKey(user1.Id).ShouldBeTrue();\n    dict.ContainsKey(user2.Id).ShouldBeTrue();\n}\n```\n\n----------------------------------------\n\nTITLE: Static using for System.Text.Json transformations\nDESCRIPTION: Shows the usage of a static using directive to simplify the syntax when working with System.Text.Json transformations in Marten. It imports helper classes from the `Marten.Services.Json.Transformations.SystemTextJson.JsonTransformations` namespace, allowing for more concise code.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/versioning.md#_snippet_31\n\nLANGUAGE: cs\nCODE:\n```\nusing static Marten.Services.Json.Transformations.SystemTextJson.JsonTransformations;\n```\n\n----------------------------------------\n\nTITLE: Multi-Tenancy with Bulk Insert in Marten\nDESCRIPTION: This snippet demonstrates how to use bulk insert with multi-tenanted documents in Marten. It shows how to configure the `DocumentStore` for multi-tenancy and then bulk insert documents for a specific tenant. It requires a configured `DocumentStore` for multi-tenancy, a `Target` class with a `GenerateRandomData` method, and an array of `Target` objects.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/storing.md#_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\n// Just say we have an array of documents we want to bulk insert\nvar data = Target.GenerateRandomData(100).ToArray();\n\nusing var store = DocumentStore.For(opts =>\n{\n    opts.Connection(\"some connection string\");\n    opts.Policies.AllDocumentsAreMultiTenanted();\n});\n\n// If multi-tenanted\nawait store.BulkInsertDocumentsAsync(\"a tenant id\", data);\n```\n\n----------------------------------------\n\nTITLE: Marten DDL Schema - SQL\nDESCRIPTION: This SQL script represents the Data Definition Language (DDL) generated by Marten for creating database objects for document storage. It includes table creation scripts for `mt_doc_user`, `mt_doc_company`, and `mt_doc_issue`, along with corresponding upsert functions. Additionally, it sets up the `mt_hilo` table and `mt_get_next_hi` function for HiLo identifier generation. Indexes are created to optimize queries on searchable fields.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/schema/exporting.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\nDROP TABLE IF EXISTS mt_doc_user CASCADE;\nCREATE TABLE mt_doc_user (\n    id           uuid CONSTRAINT pk_mt_doc_user PRIMARY KEY,\n    data         jsonb NOT NULL ,\n    user_name    varchar \n);\n\n\nCREATE OR REPLACE FUNCTION mt_upsert_user(docId uuid, doc JSONB, arg_user_name varchar) RETURNS VOID AS\n$$\nBEGIN\nINSERT INTO mt_doc_user VALUES (docId, doc, arg_user_name)\n  ON CONFLICT ON CONSTRAINT pk_mt_doc_user\n  DO UPDATE SET data = doc, user_name = arg_user_name;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE INDEX mt_doc_user_idx_user_name ON mt_doc_user (user_name)\n\n\nDROP TABLE IF EXISTS mt_doc_company CASCADE;\nCREATE TABLE mt_doc_company (\n    id      uuid CONSTRAINT pk_mt_doc_company PRIMARY KEY,\n    data    jsonb NOT NULL \n);\n\n\nCREATE OR REPLACE FUNCTION mt_upsert_company(docId uuid, doc JSONB) RETURNS VOID AS\n$$\nBEGIN\nINSERT INTO mt_doc_company VALUES (docId, doc)\n  ON CONFLICT ON CONSTRAINT pk_mt_doc_company\n  DO UPDATE SET data = doc;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE INDEX mt_doc_company_idx_data ON mt_doc_company USING gin (data jsonb_path_ops)\n\n\nDROP TABLE IF EXISTS mt_doc_issue CASCADE;\nCREATE TABLE mt_doc_issue (\n    id      uuid CONSTRAINT pk_mt_doc_issue PRIMARY KEY,\n    data    jsonb NOT NULL \n);\n\n\nCREATE OR REPLACE FUNCTION mt_upsert_issue(docId uuid, doc JSONB) RETURNS VOID AS\n$$\nBEGIN\nINSERT INTO mt_doc_issue VALUES (docId, doc)\n  ON CONFLICT ON CONSTRAINT pk_mt_doc_issue\n  DO UPDATE SET data = doc;\nEND;\n$$ LANGUAGE plpgsql;\n\n\nDROP TABLE IF EXISTS mt_hilo CASCADE;\nCREATE TABLE mt_hilo (\n    entity_name            varchar CONSTRAINT pk_mt_hilo PRIMARY KEY,\n    hi_value            bigint default 0\n);\n\nCREATE OR REPLACE FUNCTION mt_get_next_hi(entity varchar) RETURNS int AS $$\nDECLARE\n    current_value bigint;\n    next_value bigint;\nBEGIN\n    select hi_value into current_value from mt_hilo where entity_name = entity;\n    IF current_value is null THEN\n        insert into mt_hilo (entity_name, hi_value) values (entity, 0);\n        next_value := 0;\n    ELSE\n        next_value := current_value + 1;\n        update mt_hilo set hi_value = next_value where entity_name = entity;\n    END IF;\n\n    return next_value;\nEND\n$$ LANGUAGE plpgsql;\n```\n\n----------------------------------------\n\nTITLE: Creating Candle Projection\nDESCRIPTION: Introduces a `CandleProjection` that subscribes to the `Tick` event. The projection implements the `ViewProjection` interface to build `Candle` projections from `Tick` events.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/events/projections/projectionbyeventtype.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:sample-candleprojection]>\n```\n\n----------------------------------------\n\nTITLE: Exempting Document Types via Fluent Interface in C#\nDESCRIPTION: This code snippet demonstrates how to exempt a document type from partitioning using the fluent interface. This approach provides an alternative to using the `[DoNotPartition]` attribute. It allows configuring partitioning behavior directly within the Marten schema configuration.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/multi-tenancy.md#_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\nopts.Schema.For<DocThatShouldBeExempted2>().DoNotPartition();\n```\n\n----------------------------------------\n\nTITLE: Compiled Query with Statistics C#\nDESCRIPTION: This code demonstrates a compiled query that retrieves paginated results and includes statistics about the query. It shows how to use the `Stats()` method to capture the `QueryStatistics` and access the total count and other pagination information. A property of type `QueryStatistics` is defined on the compiled query class.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/compiled_queries.md#_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\npublic class FindUsersWithStats : ICompiledListQuery<User, FindUsersWithStats>\n{\n    public QueryStatistics Stats { get; set; }\n    public int PageSize { get; set; } = 10;\n    public int PageNumber { get; set; } = 1;\n\n    public Expression<Func<IQueryable<User>, IEnumerable<FindUsersWithStats>>> QueryIs()\n    {\n        return q => q.Stats(Stats).Skip((PageNumber - 1) * PageSize).Take(PageSize).AsEnumerable();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Saga Transaction with Marten using Isolation Level\nDESCRIPTION: Demonstrates how to open a Marten session with a specific transaction isolation level such as Snapshot.  This allows for managing transaction isolation for scenarios like the Saga pattern.  The code shows opening a session with `IsolationLevel.Snapshot`, loading saga state, performing work, and saving changes.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/sessions.md#_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\npublic async Task execute_saga(IDocumentStore store, Guid sagaId, CancellationToken ct)\n{\n    // The session below will open its connection and start a\n    // snapshot transaction\n    await using var session = store.LightweightSession(IsolationLevel.Snapshot);\n    var state = await session.LoadAsync<MySagaState>(sagaId, ct);\n\n    // do some work against the saga\n\n    await session.SaveChangesAsync(ct);\n}\n```\n\n----------------------------------------\n\nTITLE: Querying for Single Document as JSON - C#\nDESCRIPTION: This C# code presents a compiled query (`FindJsonUserByUsername`) for retrieving a single user as a JSON string. It implements `ICompiledQuery<User>` and the `QueryIs()` method filters users by `Username` and uses `Single()` to retrieve a single record. The `AsJson()` call is missing but implied by the documentation.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/compiled-queries.md#_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\npublic class FindJsonUserByUsername: ICompiledQuery<User>\n{\n    public string Username { get; set; }\n\n    Expression<Func<IMartenQueryable<User>, User>> ICompiledQuery<User, User>.QueryIs()\n    {\n        return query =>\n            query.Where(x => Username == x.UserName).Single();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Old Event Type\nDESCRIPTION: This code snippet defines the original event type `ShoppingCartOpened` before an upcasting transformation. It consists of `ShoppingCartId` and `ClientId` properties.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/versioning.md#_snippet_10\n\nLANGUAGE: cs\nCODE:\n```\npublic record ShoppingCartOpened(\n    Guid ShoppingCartId,\n    Guid ClientId\n);\n```\n\n----------------------------------------\n\nTITLE: Defining Candle Data Type\nDESCRIPTION: Defines a `Candle` type to hold candle data. This type will be populated and updated by the projection based on events.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/events/projections/projectionbyeventtype.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:sample-type-candle]>\n```\n\n----------------------------------------\n\nTITLE: Using Keyed NpgsqlDataSource with Marten (.NET 8+)\nDESCRIPTION: This snippet shows how to use a keyed `NpgsqlDataSource` registration with Marten.  This is useful when you need more than one data source registered. It adds a keyed Npgsql data source and then configures Marten to use the data source associated with a particular key.  It also demonstrates using lightweight sessions.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/hostbuilder.md#_snippet_5\n\nLANGUAGE: cs\nCODE:\n```\nconst string dataSourceKey = \"marten_data_source\";\n\nservices.AddNpgsqlDataSource(ConnectionSource.ConnectionString, serviceKey: dataSourceKey);\n\nservices.AddMarten()\n    .UseLightweightSessions()\n    .UseNpgsqlDataSource(dataSourceKey);\n```\n\n----------------------------------------\n\nTITLE: Implementing AggregateBase for Event Dispatching in C#\nDESCRIPTION: This snippet implements the `AggregateBase` class, which serves as the foundation for objects whose state is to be modeled using events. It provides the mechanism to dispatch events to their respective handlers and tracks changes for persistence.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/scenarios/aggregates_events_repositories.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:scenario-aggregate-base]>\n```\n\n----------------------------------------\n\nTITLE: Executing Linq Query Sequence Diagram\nDESCRIPTION: This Mermaid sequence diagram illustrates how a Linq query is executed in Marten, starting from the client calling Query and ToListAsync.  It details the interaction between IQuerySession, IMartenQueryable, LinqQueryProvider, LinqHandlerBuilder, IQueryHandler, IMartenSession, IManagedConnection and NpgsqlCommand to execute the query and return the results.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/diagrams/querying.md#_snippet_2\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n\nClient->>IQuerySession:Query~T~()\nIQuerySession-->>Client: IMartenQueryable~T~\nnote right of IQuerySession: configure the query through Linq operators\nClient->>IMartenQueryable~T~: Where()/Select()/OrderBy()/etc.\nnote right of IQuerySession: invoke one of the Linq query result operators\nClient->>IMartenQueryable~T~: ToListAsync()\nIMartenQueryable~T~ ->> LinqQueryProvider:ExecuteAsync(Expression)\nLinqQueryProvider ->> LinqHandlerBuilder: new(IMartenSession, Expression)\nnote right of LinqQueryProvider: This is where all the Linq parsing magic happens\nLinqQueryProvider ->> LinqHandlerBuilder: BuildHandler()\nLinqHandlerBuilder -->> LinqQueryProvider: IQueryHandler\nLinqQueryProvider ->> LinqQueryProvider: ExecuteHandlerAsync(IQueryHandler)\nnote right of LinqQueryProvider: Build up the database command\nLinqQueryProvider ->> IMartenSession: BuildCommand(IQueryHandler)\nIMartenSession ->> IQueryHandler: ConfigureCommand(CommandBuilder, IMartenSession)\nIMartenSession -->> LinqQueryProvider: NpgsqlCommand\nLinqQueryProvider ->> IManagedConnection: ExecuteReaderAsync()\nIManagedConnection -->> LinqQueryProvider: DbDataReader\nLinqQueryProvider ->> IQueryHandler: HandleAsync(DbDataReader, IMartenSession)\nIQueryHandler -->> LinqQueryProvider: results\nLinqQueryProvider -->> Client: results\n\n```\n\n----------------------------------------\n\nTITLE: Generated SQL Query\nDESCRIPTION: This is the SQL query generated by Marten for the LINQ query in the previous example. It selects data from the `mt_doc_trade` table where the value is greater than a specified parameter.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/diagnostics.md#_snippet_13\n\nLANGUAGE: SQL\nCODE:\n```\nselect d.data from mt_doc_trade as d where d.value > :arg0\n```\n\n----------------------------------------\n\nTITLE: Defining Aggregate Document with Soft Delete (C#)\nDESCRIPTION: This code defines a simple aggregate document type `StartAndStopAggregate` that implements the `ISoftDeleted` interface. This indicates to Marten that the document can be soft-deleted. The class includes properties for count, id, deleted status, and deletion timestamp.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/custom-aggregates.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic class StartAndStopAggregate: ISoftDeleted\n{\n    public int Count { get; set; }\n\n    public Guid Id { get; set; }\n\n    // These are Marten controlled\n    public bool Deleted { get; set; }\n    public DateTimeOffset? DeletedAt { get; set; }\n\n    public void Increment()\n    {\n        Count++;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Executing a JavaScript Function in PostgreSQL\nDESCRIPTION: This SQL query calls the 'test_js_func' function, passing 'Manipulated' as the input value. The expected output is 'I' a Manipulated string', demonstrating the successful execution of the JavaScript function via PLV8 within PostgreSQL.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/admin/installing-plv8-windows.md#_snippet_2\n\nLANGUAGE: SQL\nCODE:\n```\nselect test_js_func('Manipulated');\n```\n\n----------------------------------------\n\nTITLE: Adding Marten with Custom Session Creation - C#\nDESCRIPTION: This snippet shows how to register a custom session factory with the `IServiceCollection` using the `BuildSessionsWith()` method. It customizes how document sessions are created globally within the application. Requires a custom `ISessionFactory` implementation.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/integration.md#_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:AddMartenWithCustomSessionCreation]>\n```\n\n----------------------------------------\n\nTITLE: Setting up the initial event stream - C#\nDESCRIPTION: This code snippet demonstrates how to set up an initial event stream in Marten. It involves creating a new stream with a series of events. The purpose is to establish a starting point for the subsequent copy and transformation operations.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/scenarios/copyandtransformstream.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:scenario-copyandtransformstream-setup]>\n```\n\n----------------------------------------\n\nTITLE: Querying Documents by Last Modified Time in Marten (C#)\nDESCRIPTION: This code snippet demonstrates how to query Marten documents modified within a specific time range using the `ModifiedSince` and `ModifiedBefore` extension methods. It uses an `IQuerySession` to execute the query and returns a list of `Target` objects. The example calculates timestamps representing time intervals of 5 and 10 minutes ago and queries based on those.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/metadata.md#_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic async Task sample_usage(IQuerySession session)\n{\n    var fiveMinutesAgo = DateTime.UtcNow.AddMinutes(-5);\n    var tenMinutesAgo = DateTime.UtcNow.AddMinutes(-10);\n\n    // Query for documents modified between 5 and 10 minutes ago\n    var recents = await session.Query<Target>()\n        .Where(x => x.ModifiedSince(tenMinutesAgo))\n        .Where(x => x.ModifiedBefore(fiveMinutesAgo))\n        .ToListAsync();\n}\n```\n\n----------------------------------------\n\nTITLE: Is One Of List (C#)\nDESCRIPTION: To find one of for a list you can use this strategy:\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/linq.md#_snippet_30\n\nLANGUAGE: C#\nCODE:\n```\nvar numbers = new List<int> {1, 2, 3};\nvar targets = session.Query<Target>().Where(x => x.Number.IsOneOf(numbers)).ToList();\n```\n\n----------------------------------------\n\nTITLE: In Array (C#)\nDESCRIPTION: To find one of for an array you can use this strategy:\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/linq.md#_snippet_32\n\nLANGUAGE: C#\nCODE:\n```\nvar numbers = new[] {1, 2, 3};\nvar targets = session.Query<Target>().Where(x => x.Number.In(numbers)).ToList();\n```\n\n----------------------------------------\n\nTITLE: Define Event Stream State Enum\nDESCRIPTION: Defines an enum representing the possible states of an event stream.  This allows for managing the lifecycle of the stream during event capture and projection.\nSOURCE: https://github.com/jasperfx/marten/blob/master/planning/MartenV4.md#_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic enum StreamState\n{\n    CreateNew,\n    Append,\n    AppendOrCreate,\n    Pending,\n    History\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a table with a serial column\nDESCRIPTION: This SQL snippet creates a table named `serial_one` with an auto-incrementing integer column `id` using the `serial` data type. It then inserts two rows and selects all data from the table.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/postgres/types.md#_snippet_0\n\nLANGUAGE: SQL\nCODE:\n```\ncreate table if not exists serial_one (\n    id serial,\n    name text\n);\n\ninsert into serial_one (name) values ('phill');\ninsert into serial_one (name) values ('james');\n\nselect * from serial_one;\n```\n\n----------------------------------------\n\nTITLE: Adding Marten Package via Paket\nDESCRIPTION: This command adds the Marten package to your .NET project using Paket, a dependency manager for .NET. It streamlines dependency management and ensures consistent builds across different environments.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/getting-started.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ndotnet paket add Marten\n```\n\n----------------------------------------\n\nTITLE: Defining Tick Event Type\nDESCRIPTION: Defines a `Tick` event type that represents an event.  The `CandleProjection` will subscribe to this event type.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/events/projections/projectionbyeventtype.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:sample-type-tick]>\n```\n\n----------------------------------------\n\nTITLE: Creating a JavaScript Function in PostgreSQL with PLV8\nDESCRIPTION: This SQL statement defines a PostgreSQL function named 'test_js_func' that uses PLV8 to execute JavaScript code. The function takes a text input, manipulates a predefined string using JavaScript's replace function, and returns the modified string. The 'language plv8' clause specifies that the function's code is written in JavaScript and should be executed by the PLV8 extension.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/admin/installing-plv8-windows.md#_snippet_1\n\nLANGUAGE: SQL\nCODE:\n```\ncreate or replace function test_js_func(value text) returns text as $$\n\n    var thing = 'I\\' a JavaScript string';\n\n    var result = thing.replace(/JavaScript/g, value);\n\n    return result;\n\n$$ language plv8;\n```\n\n----------------------------------------\n\nTITLE: Install Marten.NodaTime Package\nDESCRIPTION: Installs the Marten.NodaTime NuGet package to enable Noda Time support within Marten. This is the first step to using Noda Time with Marten.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/noda-time.md#_snippet_0\n\nLANGUAGE: powershell\nCODE:\n```\nPM> Install-Package Marten.NodaTime\n```\n\n----------------------------------------\n\nTITLE: PostgreSQL Function Creation (CREATE OR REPLACE)\nDESCRIPTION: This code snippet showcases the `CREATE OR REPLACE FUNCTION` statement in PostgreSQL. This allows for creating a new function or replacing an existing one with the same name, simplifying function management. It eliminates the need for separate DROP and CREATE statements.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/postgres/if_statements.md#_snippet_5\n\nLANGUAGE: SQL\nCODE:\n```\nCREATE OR REPLACE FUNCTION create_product\n```\n\n----------------------------------------\n\nTITLE: Jil Serializer Implementation in C#\nDESCRIPTION: This code snippet demonstrates how to implement the `ISerializer` interface to use the Jil library for JSON serialization in Marten. It handles both serialization and deserialization using Jil's `JSON.Serialize` and `JSON.Deserialize` methods. This custom serializer needs to be registered with the `DocumentStore` to be used by Marten.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/json/jil.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic class JilSerializer : ISerializer\n{\n    public string ToJson(object document)\n    {\n        using (var writer = new StringWriter())\n        {\n            JSON.Serialize(document, writer, Options.ISO8601);\n            return writer.ToString();\n        }\n    }\n\n    public object FromJson(Type type, string json)\n    {\n        return JSON.Deserialize(json, type, Options.ISO8601);\n    }\n\n    public T FromJson<T>(string json)\n    {\n        return JSON.Deserialize<T>(json, Options.ISO8601);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Marten Store Configuration - Part 1\nDESCRIPTION: Configures the Marten store by plugging in the sequence-yielding customization. This step integrates the custom schema feature into the Marten configuration, allowing it to manage the sequence during database schema generation and updates.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/scenarios/usingsequenceforuniqueid.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:scenario-usingsequenceforuniqueid-storesetup-1]>\n```\n\n----------------------------------------\n\nTITLE: SQL generated by Marten for paging queries (SQL)\nDESCRIPTION: This SQL snippet shows the query generated by Marten when using `Take()` to limit results, and using statistics to retrieve a total count. It selects the data and id from the `mt_doc_target` table, filters based on the 'Number' property in the JSON data, and limits the results using `LIMIT`. The `count(*) OVER()` function calculates the total number of rows that match the condition.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/paging.md#_snippet_3\n\nLANGUAGE: SQL\nCODE:\n```\nselect d.data, d.id, count(*) OVER() as total_rows from public.mt_doc_target as d\nwhere CAST(d.data ->> 'Number' as integer) > :arg0 LIMIT 5\n```\n\n----------------------------------------\n\nTITLE: Defining Document Type\nDESCRIPTION: Defines a simple document type `Trade` with an Id and a Value property. The `[DuplicateField]` attribute instructs Marten to duplicate the `Value` into a separate database field for querying efficiency.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/diagnostics.md#_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\npublic class Trade\n{\n    public int Id { get; set; }\n\n    [DuplicateField]\n    public double Value { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Simple Calculated Index SQL Representation\nDESCRIPTION: This SQL code snippet represents the database index generated by Marten for a simple calculated index on the `UserName` property. It uses the `data ->> 'UserName'` expression to access the property within the JSON data.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/computed_index.md#_snippet_1\n\nLANGUAGE: SQL\nCODE:\n```\nCREATE INDEX mt_doc_user_idx_user_name ON public.mt_doc_user ((data ->> 'UserName'));\n```\n\n----------------------------------------\n\nTITLE: Document with Metadata Properties (C#)\nDESCRIPTION: This code snippet defines a sample `DocWithMetadata` class that includes properties for tracking metadata such as `Version`, `Causation`, and `IsDeleted`.  The document class includes `Guid Id`, `Guid Version`, `string Causation`, and `bool IsDeleted` properties. This example shows the document structure to which metadata can be mapped.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/metadata.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic class DocWithMetadata\n{\n    public Guid Id { get; set; }\n\n    // other members\n\n    public Guid Version { get; set; }\n    public string Causation { get; set; }\n    public bool IsDeleted { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Deep Calculated Index (Marten, C#)\nDESCRIPTION: Demonstrates creating a calculated index on a deeply nested property within a document.  Requires Marten and Postgresql.  Assumes a `Target` document type with a nested `Inner` object that has a `Color` property.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/indexing/computed-indexes.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n    _.Connection(ConnectionSource.ConnectionString);\n\n    _.Schema.For<Target>().Index(x => x.Inner.Color);\n});\n```\n\n----------------------------------------\n\nTITLE: Noda Time Setup without JSON Serializer Configuration\nDESCRIPTION: Configures Marten to use Noda Time but disables the default JSON serializer configuration. This allows for custom JSON serialization configurations. Requires manual configuration of Noda Time JSON serialization.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/noda-time.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n    _.Connection(ConnectionSource.ConnectionString);\n\n    _.Serializer<CustomJsonSerializer>();\n\n    // sets up NodaTime handling\n    _.UseNodaTime(shouldConfigureJsonSerializer: false);\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing DocumentStore with Connection String (C#)\nDESCRIPTION: This snippet demonstrates the simplest way to initialize a `DocumentStore` in Marten using a connection string. It initializes the store, allowing Marten to manage database schema and dynamic code generation based on the default settings, optimized for developer productivity.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/optimized_artifact_workflow.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvar store = DocumentStore.For(\"connection string\");\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom Projection (C#)\nDESCRIPTION: This code demonstrates a custom projection, `QuestPatchTestProjection`, implementing the `IProjection` interface. It processes events from the event stream to either store a new `QuestPatchTestProjection` document or patch an existing one based on the event type (`Quest` or `QuestStarted`). It utilizes `IDocumentOperations` to interact with the document store.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/custom.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic class QuestPatchTestProjection: IProjection\n{\n    public Guid Id { get; set; }\n\n    public string Name { get; set; }\n\n    public void Apply(IDocumentOperations operations, IReadOnlyList<StreamAction> streams)\n    {\n        var questEvents = streams.SelectMany(x => x.Events).OrderBy(s => s.Sequence).Select(s => s.Data);\n\n        foreach (var @event in questEvents)\n        {\n            if (@event is Quest quest)\n            {\n                operations.Store(new QuestPatchTestProjection { Id = quest.Id });\n            }\n            else if (@event is QuestStarted started)\n            {\n                operations.Patch<QuestPatchTestProjection>(started.Id).Set(x => x.Name, \"New Name\");\n            }\n        }\n    }\n\n    public Task ApplyAsync(IDocumentOperations operations, IReadOnlyList<StreamAction> streams,\n        CancellationToken cancellation)\n    {\n        Apply(operations, streams);\n        return Task.CompletedTask;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Document Projection with Fluent Interface in C#\nDESCRIPTION: This code demonstrates the fluent interface for defining a projection to a document in Marten. It shows how to specify the transformer, aggregation strategy (by stream, tenant, or event data), deletion criteria, and snapshotting frequency.\nSOURCE: https://github.com/jasperfx/marten/blob/master/planning/MartenV4.md#_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nProjectTo<ProjectedDocument>()\n    // How to transform the events to the projected document, see below\n    .TransformWith<SampleTransformer>()\n\n    // Optionally aggregate by stream\n    .AggregateByStream() // Think this is self-descriptive\n\n    .AggregateByTenant() // Not sure how common this would be. Aggregate across the entire tenant\n\n    // Or aggregate by something special, hopefull use a common base type here for the event type\n    .AggregateByEventData<TEvent>(Expression<Func<TEvent, int>> expression) // what's the identity of the projected, aggregate doc?\n\n    .DeleteOn<TEvent>() // the aggregate document should be deleted if an event of this type hits\n                        // In this case, we could look ahead and \"know\" in the rebuilds not to rebuild\n                        // a projection for this aggregate as an optimization\n\n    .SnapshotInIncrementsOf(10) // Then maybe there are other options to retain old snapshots or not? Dunno\n```\n\n----------------------------------------\n\nTITLE: Basic LINQ Query Example\nDESCRIPTION: Demonstrates a basic LINQ query using Marten to query a document collection. It shows how to use `Where`, `OrderBy`, and `ToListAsync` methods to retrieve a list of `Target` objects from the database.\nSOURCE: https://github.com/jasperfx/marten/blob/master/src/Marten/Linq/notes.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar results = await session.Query<Target>().Where(x => x.Number == 5).OrderBy(x => x.String).ToListAsync();\n```\n\n----------------------------------------\n\nTITLE: Defining Client Repository Interface in C#\nDESCRIPTION: This code defines an interface for retrieving client information asynchronously. The GetClientName method takes a client ID and cancellation token and returns the client's name as a string within a Task.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/versioning.md#_snippet_29\n\nLANGUAGE: cs\nCODE:\n```\npublic interface IClientRepository\n{\n    Task<string> GetClientName(Guid clientId, CancellationToken ct);\n}\n```\n\n----------------------------------------\n\nTITLE: Generating a Database Patch (Legacy) - Bash\nDESCRIPTION: This bash command (for Marten < V5.0) demonstrates how to create a database patch using the Marten command-line interface. The 'marten-patch' command creates a SQL script containing the changes needed to update the database schema.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/schema/migrations.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ndotnet run -- marten-patch [filename]\n```\n\n----------------------------------------\n\nTITLE: Defining a Postgresql Table with the Table Class (C#)\nDESCRIPTION: This C# code snippet showcases the definition of a Postgresql table using the `Table` class in Marten, specifically the `mt_events` table from the event store. It illustrates how to define table columns with their respective data types and nullability.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/advanced/extensions.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\ninternal class EventsTable : Table\\n{\\n    public EventsTable(StoreOptions options) : base(new DbObjectName(options.DatabaseSchemaName, \"mt_events\"))\\n    {\\n        AddColumn(\"id\", x => x.Id).AsPrimaryKey();\\n\n        AddColumn<Guid>(\"stream_id\", x => x.StreamId).NotNull();\\n        AddColumn<string>(\"event_type\", x => x.EventType).NotNull();\\n        AddColumn<string>(\"event_typename\", x => x.EventTypeName);\\n        AddColumn<DateTimeOffset>(\"timestamp\", x => x.Timestamp).NotNull();\\n        AddColumn<string>(\"data\", x => x.Data).NotNull();\\n        AddColumn<string>(\"metadata\", \"jsonb\");\\n        AddColumn<Guid>(\"causation_id\", x => x.CausationId);\\n        AddColumn<Guid>(\"correlation_id\", x => x.CorrelationId);\\n        AddColumn<string>(\"origin\", x => x.Origin);\\n        AddColumn<int>(\"version\", x => x.Version).NotNull();\\n\\n\n        AddColumn(\" DotNetTypeName\", \"varchar\", nullability: ColumnNullability.Null);\\n\n\\n        Indexes.Add(new GinIndex(\"mt_events\", new string[] { \"data\" }));\\n    }\\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Duplicated Field Index (C#)\nDESCRIPTION: This code snippet shows how to customize indexes on duplicated fields in Marten. It demonstrates how to add GIN indexes, define duplicated columns with data type and null constraints, and customize the index by setting properties like name, method, uniqueness, and sort order.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/indexing/unique.md#_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nvar store = DocumentStore.For(options =>\n{\n    // Add a gin index to the User document type\n    options.Schema.For<User>().GinIndexJsonData();\n\n    // Adds a basic btree index to the duplicated\n    // field for this property that also overrides\n    // the Postgresql database type for the column\n    options.Schema.For<User>().Duplicate(x => x.FirstName, pgType: \"varchar(50)\");\n\n    // Defining a duplicate column with not null constraint\n    options.Schema.For<User>().Duplicate(x => x.Department, pgType: \"varchar(50)\", notNull: true);\n\n    // Customize the index on the duplicated field\n    // for FirstName\n    options.Schema.For<User>().Duplicate(x => x.FirstName, configure: idx =>\n    {\n        idx.Name = \"idx_special\";\n        idx.Method = IndexMethod.hash;\n    });\n\n    // Customize the index on the duplicated field\n    // for UserName to be unique\n    options.Schema.For<User>().Duplicate(x => x.UserName, configure: idx =>\n    {\n        idx.IsUnique = true;\n    });\n\n    // Customize the index on the duplicated field\n    // for LastName to be in descending order\n    options.Schema.For<User>().Duplicate(x => x.LastName, configure: idx =>\n    {\n        idx.SortOrder = SortOrder.Desc;\n    });\n});\n```\n\n----------------------------------------\n\nTITLE: Running Oakton Commands in a WebApplication - C#\nDESCRIPTION: This code snippet illustrates how to use Oakton to handle command-line parsing and execution within a .NET application. Instead of using `App.Run()`, `app.RunOaktonCommands(args)` is called to delegate command-line execution to Oakton. The return value is then returned from the application's main method to allow for proper exit codes from commands.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/cli.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n// Instead of App.Run(), use the app.RunOaktonCommands(args)\n// as the last line of your Program.cs file\nreturn await app.RunOaktonCommands(args);\n```\n\n----------------------------------------\n\nTITLE: Customizing Duplicated Field Index to be Unique - C#\nDESCRIPTION: Demonstrates configuring a duplicated field to be a unique index.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/unique.md#_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:IndexExamples]>\n```\n\n----------------------------------------\n\nTITLE: Creating External Foreign Key SQL Constraint\nDESCRIPTION: This SQL code demonstrates the foreign key constraint that Marten creates in the database to an external table based on the configuration provided in the C# code snippet. It adds a foreign key constraint named `mt_doc_issue_bug_id_fkey` on the `bug_id` column of the `mt_doc_issue` table, referencing the `id` column of the `bugs` table in the `bugtracker` schema.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/indexing/foreign-keys.md#_snippet_4\n\nLANGUAGE: SQL\nCODE:\n```\nALTER TABLE public.mt_doc_issue\nADD CONSTRAINT mt_doc_issue_bug_id_fkey FOREIGN KEY (bug_id)\nREFERENCES bugtracker.bugs (id);\n```\n\n----------------------------------------\n\nTITLE: Newtonsoft.Json Default Configuration\nDESCRIPTION: Shows the default configuration that Marten uses for Newtonsoft.Json serialization. This configuration is used out of the box by Marten for serializing and deserializing documents.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/json/newtonsoft.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:newtonsoft-configuration]>\n```\n\n----------------------------------------\n\nTITLE: Defining Simple Event Record\nDESCRIPTION: This code snippet defines a simple event record `ShoppingCartOpened` with `ShoppingCartId` and `ClientId` properties. This represents the initial event schema before any migration.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/versioning.md#_snippet_5\n\nLANGUAGE: cs\nCODE:\n```\npublic record ShoppingCartOpened(\n    Guid ShoppingCartId,\n    Guid ClientId\n);\n```\n\n----------------------------------------\n\nTITLE: Use Metadata in DocumentSession\nDESCRIPTION: Illustrates how to use the defined metadata type within a `DocumentSession`.  The session's `UseMetadata<MyMetadata>(metadata)` method allows developers to associate metadata with a document session.  The document also suggests that .Net Core integration can automate setting metadata upon new `DocumentSession` objects being created from the IoC.\nSOURCE: https://github.com/jasperfx/marten/blob/master/planning/MartenV4.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nsession.UseMetadata<MyMetadta>(metadata);\n```\n\n----------------------------------------\n\nTITLE: Postgres Identifier Escaping\nDESCRIPTION: Escapes the 'id' column name and 'my_table' table name using double quotes, which is the standard way to handle case-sensitive identifiers or reserved keywords in Postgres.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/postgres/escaping.md#_snippet_1\n\nLANGUAGE: postgres\nCODE:\n```\nselect \"id\" from \"my_table\";\n```\n\n----------------------------------------\n\nTITLE: Implementing IQueryPlanning for Compiled Queries\nDESCRIPTION: This class shows an example of implementing the `IQueryPlanning` interface to assist Marten in creating a compiled query plan. The `SetUniqueValuesForQueryPlanning()` method is used to set unique values for the query parameters (e.g., `Page`, `PageSize`, `Type`) during query planning. The `[MartenIgnore]` attribute excludes properties from being considered as query parameters.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/compiled-queries.md#_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\npublic class CompiledTimeline : ICompiledListQuery<TimelineItem>, IQueryPlanning\n{\n    public int PageSize { get; set; } = 20;\n\n    [MartenIgnore] public int Page { private get; set; } = 1;\n    public int SkipCount => (Page - 1) * PageSize;\n    public string Type { get; set; }\n    public Expression<Func<IMartenQueryable<TimelineItem>, IEnumerable<TimelineItem>>> QueryIs() =>\n        query => query.Where(i => i.Event == Type).Skip(SkipCount).Take(PageSize);\n\n    public void SetUniqueValuesForQueryPlanning()\n    {\n        Page = 3; // Setting Page to 3 forces the SkipCount and PageSize to be different values\n        PageSize = 20; // This has to be a positive value, or the Take() operator has no effect\n        Type = Guid.NewGuid().ToString();\n    }\n\n    // And hey, if you have a public QueryStatistics member on your compiled\n    // query class, you'll get the total number of records\n    public QueryStatistics Statistics { get; } = new QueryStatistics();\n}\n```\n\n----------------------------------------\n\nTITLE: ICompiledQuery Interface Definition C#\nDESCRIPTION: This code snippet defines the `ICompiledQuery` interface in C#. This interface serves as the base for all compiled queries in Marten and is used to define a strongly typed query with a specific document type and result type.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/compiled_queries.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic interface ICompiledQuery<TDoc, TResult>\n{\n    Expression<Func<IQueryable<TDoc>, TResult>> QueryIs();\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Integration Collection Fixture\nDESCRIPTION: Defines an xUnit collection fixture named \"integration\" that shares the `AppFixture` between tests. This reduces the overhead of spinning up the entire host and database setup for each test, especially when running tests in parallel.  It depends on the `AppFixture`.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/testing/integration.md#_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n[CollectionDefinition(\"integration\")]\npublic class IntegrationCollection : ICollectionFixture<AppFixture>\n{\n}\n```\n\n----------------------------------------\n\nTITLE: Kubernetes Deployment YAML with Init Container\nDESCRIPTION: This Kubernetes YAML defines a deployment with an init container for running database migrations before the application starts. The image tags are dynamically replaced by Octopus Deploy.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/devops/devops.md#_snippet_17\n\nLANGUAGE: yaml\nCODE:\n```\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: myapp-deployment\nspec:\n  replicas: 2\n  selector:\n    matchLabels:\n      app: myapp\n  template:\n    metadata:\n      labels:\n        app: myapp\n    spec:\n      initContainers:\n      - name: migrations\n        image: myapp/migrations:${TAG} # TAG is dynamically replaced by Octopus\n        env:\n        - name: MIGRATIONS_CONNECTIONSTRING\n          value: \"YourDatabaseConnectionString\"\n      containers:\n      - name: myapp\n        image: myapp/application:${TAG} # TAG is dynamically replaced by Octopus\n        ports:\n        - containerPort: 80\n```\n\n----------------------------------------\n\nTITLE: Migrations Project File - XML\nDESCRIPTION: This XML snippet defines the `Migrations.csproj` file, which is a shell project without any classes or code, used for storing SQL migration scripts. It includes the necessary configurations for the target framework and specifies that SQL scripts in the `scripts` directory should be copied to the output directory.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/devops/devops.md#_snippet_1\n\nLANGUAGE: XML\nCODE:\n```\n<!-- needed to have an empty project without cs files -->\n<Project Sdk=\"Microsoft.Build.NoTargets/3.7.0\">\n    <PropertyGroup>\n        <!-- mandoditory, but meaningless -->\n        <TargetFramework>net8.0</TargetFramework>\n    </PropertyGroup>\n    <ItemGroup>\n        <None Include=\"scripts\\**\\*.sql\">\n            <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>\n        </None>\n    </ItemGroup>\n</Project>\n```\n\n----------------------------------------\n\nTITLE: Create Full Text Index for Single Property with Custom Settings (C#)\nDESCRIPTION: This code snippet demonstrates how to create a full text index for a single property with custom settings using the StoreOptions fluent interface in Marten. It indexes the 'FirstName' property of the 'MyDocument' document and configures the language to 'german'. Requires Marten and PostgreSQL version 10.0 or above.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/full_text.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nusing var store = DocumentStore.For(_ =>\n{\n    _.Connection(\"your_postgres_connection_string\");\n    _.Schema.For<MyDocument>().Searchable(x => x.FirstName, regConfig: \"german\");\n});\n```\n\n----------------------------------------\n\nTITLE: PostgreSQL Conditional Table Creation (IF NOT EXISTS)\nDESCRIPTION: This snippet demonstrates the `CREATE TABLE IF NOT EXISTS` statement in PostgreSQL, which provides a concise way to create a table only if it doesn't already exist. It avoids the need for a separate IF EXISTS check, simplifying table creation logic. This simplifies conditional table creation without needing PL/pgSQL.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/postgres/if_statements.md#_snippet_6\n\nLANGUAGE: SQL\nCODE:\n```\nCREATE TABLE IF NOT EXISTS Product (….\n```\n\n----------------------------------------\n\nTITLE: Get Postgres Version\nDESCRIPTION: Illustrates how to retrieve the PostgreSQL server version using the `IDocumentStore.Diagnostics` property. The `GetPostgresVersion()` method returns the version information.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/diagnostics.md#_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\nvar pgVersion = theStore.Diagnostics.GetPostgresVersion();\n```\n\n----------------------------------------\n\nTITLE: Initializing PostgreSQL Database with .NET CLI\nDESCRIPTION: This command initializes a PostgreSQL database using the .NET CLI. It's part of the Marten test configuration to find the database if no connection string is explicitly configured.\nSOURCE: https://github.com/jasperfx/marten/blob/master/CONTRIBUTING.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndotnet run --framework net6.0 -- init-db\n```\n\n----------------------------------------\n\nTITLE: Updating documentation with MarkdownSnippets\nDESCRIPTION: This command runs MarkdownSnippets to update the documentation after adding or modifying code examples. It's essential to keep the documentation in sync with the code.\nSOURCE: https://github.com/jasperfx/marten/blob/master/CONTRIBUTING.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nnpm run mdsnippets\n```\n\n----------------------------------------\n\nTITLE: Initializing DocumentStore with Serializer Choice (C#)\nDESCRIPTION: This code snippet demonstrates how to initialize a DocumentStore in Marten and configure it to use either Newtonsoft.Json or System.Text.Json for serialization.  It shows how to explicitly select which serializer to use.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/json.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar store = DocumentStore.For(_ =>\n{\n    _.Connection(\"some connection string\");\n\n    // Newtonsoft - Enabled by default\n    _.UseNewtonsoftForSerialization(); // [!code ++]\n\n    // System.Text.Json - Opt in\n    _.UseSystemTextJsonForSerialization(); // [!code ++]\n});\n```\n\n----------------------------------------\n\nTITLE: Marten Patch PowerShell Command - PowerShell\nDESCRIPTION: This PowerShell command executes the `migrations.bat` script to generate a patch migration for the Marten database.  The `-d Marten` parameter specifies the database name, and the output SQL file (patch) is saved to the migrations script directory.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/devops/devops.md#_snippet_7\n\nLANGUAGE: PowerShell\nCODE:\n```\n.\\migrations marten-patch -d Marten ..\\Migrations\\scripts\\up\\2202312101536_patch1.sql\n```\n\n----------------------------------------\n\nTITLE: Escaping Identifiers in SQL Server\nDESCRIPTION: Shows how to escape identifiers such as column and table names in SQL Server using square brackets. This is necessary when identifiers contain special characters or are reserved words.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/postgres/escaping.md#_snippet_0\n\nLANGUAGE: SQL\nCODE:\n```\nselect [Id] from [MyTable];\n```\n\n----------------------------------------\n\nTITLE: Setting AutoCreateSchemaObjects in Marten (C#)\nDESCRIPTION: This snippet demonstrates how to configure Marten to fully rebuild the database schema during application startup. It sets the `AutoCreateSchemaObjects` property to `AutoCreate.All`, allowing Marten to drop and recreate tables as needed. This is useful for development environments where schema changes are frequent.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/migration-guide.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nAutoCreateSchemaObjects = AutoCreate.All\n```\n\n----------------------------------------\n\nTITLE: ICompiledListQuery Interface (With Select) C#\nDESCRIPTION: This code snippet defines the `ICompiledListQuery` interface for queries that return a list of transformed results using `Select()`. It allows compiled queries to return a collection of objects derived from the document type through a transformation.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/compiled_queries.md#_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic interface ICompiledListQuery<TDoc, TResult> : ICompiledQuery<TDoc, IEnumerable<TResult>>\n```\n\n----------------------------------------\n\nTITLE: Embedding Code Snippets in Markdown (v4.x+)\nDESCRIPTION: This snippet demonstrates how to embed a C# code snippet within a Markdown document for v4.x and above. The `snippet` and `endSnippet` tags are used to indicate the location where the external code snippet should be injected.  The `sample_my-snippet` value corresponds to the name of the C# region.\nSOURCE: https://github.com/jasperfx/marten/blob/master/README.md#_snippet_13\n\nLANGUAGE: Markdown\nCODE:\n```\n<pre>\n&#60;!-- snippet: sample_my-snippet -->\n&#60;!-- endSnippet -->\n</pre>\n```\n\n----------------------------------------\n\nTITLE: Asserting Database Matches Configuration - Bash\nDESCRIPTION: This command asserts that the database matches the current Marten configuration.  If there are differences between the database and the Marten configuration, the command will fail and log to the specified file, 'log.txt'.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/cli.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nmarten marten-assert --log log.txt\n```\n\n----------------------------------------\n\nTITLE: Transforming Documents with Javascript (C#)\nDESCRIPTION: This C# code shows an example of how to apply a Javascript transformation named 'default_username' to existing `User` documents in the database.  The `Transform()` method of the `IAsyncDocumentOperations` interface is used to execute the Javascript transformation function on the documents identified by the provided expression, which updates the JSON data directly in the database.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/advanced/javascript_transformations.md#_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nawait session.DocumentOperations.Transform(\"default_username\")\n    .Where(x => string.IsNullOrEmpty(x.UserName))\n    .ExecuteAsync();\n```\n\n----------------------------------------\n\nTITLE: Creating a Patch and Rollback File - Bash\nDESCRIPTION: This command evaluates the current configuration against the database and, if differences are found, writes a patch file named \"patch1.sql\" and a corresponding rollback file named \"patch1.drop.sql\". These files contain the SQL commands to update the database to match the application configuration, and revert the changes, respectively.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/cli.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nmarten marten-patch patch1.sql --drop patch1.drop.sql\n```\n\n----------------------------------------\n\nTITLE: Loading Documents by Id Synchronously (Marten)\nDESCRIPTION: This code snippet demonstrates how to synchronously load a document from Marten by its id using the `IDocumentSession` interface. It implicitly uses the default conventions for document storage based on the id. The `Load<T>(id)` method retrieves a single document of type `T` based on the provided id.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/basics/loading.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:load_by_id]>\n```\n\n----------------------------------------\n\nTITLE: Benchmark Configuration\nDESCRIPTION: This snippet shows the configuration used for the benchmark execution. It includes information about the BenchmarkDotNet version, operating system, processor details, and CLR version.\nSOURCE: https://github.com/jasperfx/marten/blob/master/benchmarks/2.0.newtonsoft.upgrade/results/EventActions-report-github.md#_snippet_0\n\nLANGUAGE: .ini\nCODE:\n```\nBenchmarkDotNet=v0.10.1, OS=Microsoft Windows NT 6.1.7601 Service Pack 1\nProcessor=Intel(R) Core(TM) i7-4980HQ CPU 2.80GHz, ProcessorCount=4\nFrequency=10000000 Hz, Resolution=100.0000 ns, Timer=UNKNOWN\n  [Host]     : Clr 4.0.30319.42000, 64bit RyuJIT-v4.6.1076.0\n  Job-DNINOD : Clr 4.0.30319.42000, 64bit RyuJIT-v4.6.1076.0\n\nWarmupCount=2  Allocated=1.88 MB  \n```\n\n----------------------------------------\n\nTITLE: Abstract EventStreamBase Class Definition\nDESCRIPTION: Defines an abstract base class for event streams. This class encapsulates common properties such as ID, State, Events and Pending events and sets the groundwork for specialized stream types. It's parameterized to be reusable with different key and event types.\nSOURCE: https://github.com/jasperfx/marten/blob/master/planning/MartenV4.md#_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n// This really represents a segment of the underlying stream\npublic abstract class EventStreamBase<TKey, TEvent, TEventBase> where TEvent : IEvent<TEventBase>\n{\n    public TKey Id { get; set; }\n\n    // There's a little bit of optimization for inline\n    // projections by doing this\n\n    // Other folks want different mechanics\n    public StreamState State { get; set; }\n\n    public IList<TEvent> Events { get; } = new List<TEvent>();\n\n\n    // Data in here while it's being appended, but moves up above when\n    // it's pushed into the database\n    public IList<TEventBase> Pending { get; } = new List<TEventBase>();\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Databases for Tenants (C#)\nDESCRIPTION: This code shows how to configure Marten to automatically create databases for tenants if they don't exist. It utilizes the `CreateDatabasesForTenants` option within `AddMarten` to specify the maintenance connection string and tenant-specific database settings. This functionality requires Marten to be bootstrapped as part of an `IHost` and will apply changes on startup.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/schema/index.md#_snippet_4\n\nLANGUAGE: cs\nCODE:\n```\nvar maintenanceConnectionString = ConnectionSource.ConnectionString;\nvar applicationConnectionString = \"\";\nvar builder = Host.CreateApplicationBuilder();\nbuilder.Services.AddMarten(options =>\n{\n    // This might be different than the maintenance connection string\n    options.Connection(applicationConnectionString);\n\n    options.CreateDatabasesForTenants(c =>\n    {\n        // Specify a db to which to connect in case database needs to be created.\n        // If not specified, defaults to 'postgres' on the connection for a tenant.\n        c.MaintenanceDatabase(maintenanceConnectionString);\n        c.ForTenant()\n            .CheckAgainstPgDatabase()\n\n            .WithOwner(\"postgres\")\n            .WithEncoding(\"UTF-8\")\n            .ConnectionLimit(-1);\n    });\n});\n\nusing var host = builder.Build();\n\n// NOTE: The new database will only be built upon the call to IHost.StartAsync()\nawait host.StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Resolving Metadata from IDocumentSession\nDESCRIPTION: This code snippet demonstrates how to retrieve metadata values for a given document object using the `IDocumentSession` in Marten. This method provides access to metadata such as last modified time, .Net type, version, and other tracking information. It requires an `IDocumentSession` and a document object.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/schema/metadata.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:resolving_metadata]>\n```\n\n----------------------------------------\n\nTITLE: Adding days to date in SQL Server\nDESCRIPTION: This SQL snippet demonstrates how to add 5 days to the current UTC date in SQL Server using the `DATEADD` function. The `getutcdate()` function returns the current UTC date and time. `DATEADD` takes three arguments: the date part to modify (day), the amount to add (5), and the date to modify (the result of `getutcdate()`).\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/postgres/dates.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\nSELECT DATEADD(day, 5, getutcdate())\n```\n\n----------------------------------------\n\nTITLE: Mixed Tenancy and Non-Tenancy Operations in Marten\nDESCRIPTION: This sample demonstrates persisting documents as non-tenanted (under the default tenant) and under other named tenants. It also shows querying them back in a session scoped to both a specific named tenant and the default tenant. This highlights the flexibility of Marten in handling different tenancy scenarios within the same application.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/tenancy/basicoperations.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:tenancy-mixed-tenancy-non-tenancy-sample]>\n```\n\n----------------------------------------\n\nTITLE: Open StoryTeller editor (.NET CLI)\nDESCRIPTION: This command opens the StoryTeller editor by executing the build project with the 'open_st' argument using the .NET CLI.\nSOURCE: https://github.com/jasperfx/marten/blob/master/README.md#_snippet_8\n\nLANGUAGE: .NET CLI\nCODE:\n```\ndotnet run --project build/build.csproj -- open_st\n```\n\n----------------------------------------\n\nTITLE: Defining a Document Type (User)\nDESCRIPTION: This C# code defines a simple `User` class to be used as a document type in Marten.  It includes properties for Id, FirstName, LastName, and Internal status.  `Id` serves as the unique identifier for each document.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/getting-started.md#_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\npublic class User\n{\n    public Guid Id { get; set; }\n    public required string FirstName { get; set; }\n    public required string LastName { get; set; }\n\n    public bool Internal { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Marten via .NET CLI\nDESCRIPTION: This command installs the Marten library using the .NET Command Line Interface (CLI). It adds Marten as a package dependency to the project's .csproj file.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/getting_started.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\ndotnet add package Marten\n```\n\n----------------------------------------\n\nTITLE: Document Insertion Benchmark\nDESCRIPTION: This snippet presents the benchmark results for the `InsertDocuments` method. It shows the mean execution time and standard deviation.\nSOURCE: https://github.com/jasperfx/marten/blob/master/benchmarks/2.0.newtonsoft.upgrade/results/DocumentActions-report-github.md#_snippet_1\n\nLANGUAGE: INI\nCODE:\n```\n          Method |       Mean |    StdDev |\n---------------- |----------- |---------- |\n InsertDocuments | 43.2947 ms | 1.7796 ms |\n```\n\n----------------------------------------\n\nTITLE: Creating a Table with Serial Column in PostgreSQL\nDESCRIPTION: This code snippet demonstrates how to create a table with a `serial` column in PostgreSQL. The `serial` type is an auto-incrementing integer, similar to `IDENTITY` in SQL Server. The code also includes insertions into the table and a select statement.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/postgres/types.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\ncreate table if not exists serial_one (\n        id serial,\n        name text\n    );\n\n    insert into serial_one (name) values ('phill');\n    insert into serial_one (name) values ('james');\n\n    select * from serial_one;\n```\n\n----------------------------------------\n\nTITLE: Benchmark Configuration\nDESCRIPTION: This snippet displays the configuration settings used during the benchmark execution. It includes the BenchmarkDotNet version, operating system, processor details, and .NET CLR version.\nSOURCE: https://github.com/jasperfx/marten/blob/master/benchmarks/2.0.newtonsoft.upgrade/results/DocumentActions-report-github.md#_snippet_0\n\nLANGUAGE: INI\nCODE:\n```\nBenchmarkDotNet=v0.10.1, OS=Microsoft Windows NT 6.1.7601 Service Pack 1\nProcessor=Intel(R) Core(TM) i7-4980HQ CPU 2.80GHz, ProcessorCount=4\nFrequency=10000000 Hz, Resolution=100.0000 ns, Timer=UNKNOWN\n  [Host]     : Clr 4.0.30319.42000, 64bit RyuJIT-v4.6.1076.0\n  Job-DNINOD : Clr 4.0.30319.42000, 64bit RyuJIT-v4.6.1076.0\n\nWarmupCount=2  Gen 0=287.5000  Allocated=4.48 MB\n```\n\n----------------------------------------\n\nTITLE: SQL Server Identifier Escaping\nDESCRIPTION: Escapes the 'Id' column name and 'MyTable' table name using square brackets, which is the standard way to handle identifiers with spaces or reserved keywords in SQL Server.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/postgres/escaping.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\nselect [Id] from [MyTable];\n```\n\n----------------------------------------\n\nTITLE: Initializing PostgreSQL database (dotnet)\nDESCRIPTION: This command initializes a PostgreSQL database using a .NET application. It requires .NET SDK and assumes a configured database connection.\nSOURCE: https://github.com/jasperfx/marten/blob/master/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ndotnet run --framework net6.0 -- init-db\n```\n\n----------------------------------------\n\nTITLE: Running PostgreSQL with Docker\nDESCRIPTION: This command starts a PostgreSQL database in a Docker container. It's a quick way to set up a development environment for Marten, especially for testing and local development.\nSOURCE: https://github.com/jasperfx/marten/blob/master/CONTRIBUTING.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker-compose up\n```\n\n----------------------------------------\n\nTITLE: IEvent Interface Definition\nDESCRIPTION: Defines the interface for an event. This interface includes properties for event identification (Id), versioning, sequencing, associated data (Data), and timestamp. Also includes space for additional user-defined metadata properties.\nSOURCE: https://github.com/jasperfx/marten/blob/master/planning/MartenV4.md#_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IEvent<TEventBase>\n{\n    Guid Id { get; set; }\n    int Version { get; set; }\n    long Sequence { get; set; }\n    TEventBase Data { get; set; }\n    DateTimeOffset Timestamp { get; set; }\n\n    // Additional, user-defined metadata properties\n    // like user id or correlation id or whatever\n\n}\n```\n\n----------------------------------------\n\nTITLE: Correlation Id Service Example - C#\nDESCRIPTION: This snippet exemplifies a service scoped to an HTTP request that tracks a correlation identifier. This ID can be used to connect logs with HTTP requests. It is assumed to be registered as Scoped to the request.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/integration.md#_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:CorrelationIdWithISession]>\n```\n\n----------------------------------------\n\nTITLE: Registering Custom Session Factory in C#\nDESCRIPTION: This snippet demonstrates how to register the custom `ScopedSessionFactory` with the ASP.NET Core dependency injection container. It uses the `AddMarten` extension method to configure Marten, enabling the optimized artifact workflow and building sessions using the custom session factory with `ServiceLifetime.Scoped`. This ensures the correct `ISession` is used at runtime.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/hostbuilder.md#_snippet_21\n\nLANGUAGE: cs\nCODE:\n```\nvar connectionString = Configuration.GetConnectionString(\"postgres\");\n\nservices.AddMarten(opts =>\n    {\n        opts.Connection(connectionString);\n    })\n    // Using the \"Optimized artifact workflow\" for Marten >= V5\n    // sets up your Marten configuration based on your environment\n    // See https://martendb.io/configuration/optimized_artifact_workflow.html\n    .OptimizeArtifactWorkflow()\n    // Chained helper to replace the CustomSessionFactory\n    .BuildSessionsWith<ScopedSessionFactory>(ServiceLifetime.Scoped);\n```\n\n----------------------------------------\n\nTITLE: Is One Of (C#)\nDESCRIPTION: `IsOneOf()` extension can be used to query for documents having a field or property matching one of many supplied values:\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/linq.md#_snippet_28\n\nLANGUAGE: C#\nCODE:\n```\nvar targets = session.Query<Target>().Where(x => x.Number.IsOneOf(1, 2, 3)).ToList();\n```\n\n----------------------------------------\n\nTITLE: UpdateBatch Internals Sequence Diagram\nDESCRIPTION: This Mermaid sequence diagram describes the internal workings of the `UpdateBatch` class during the `ApplyChangesAsync` operation. It shows how the `UpdateBatch` builds batched database commands by iterating through `IStorageOperation` objects and calling `ConfigureCommand` on each. The diagram also illustrates the execution of batched commands and the post-processing steps, including optimistic version checks.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/diagrams/storage.md#_snippet_2\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n\nDocumentSessionBase->>UpdateBatch: ApplyChangesAsync(session)\n\nnote right of UpdateBatch: build up the batched database command(s) for the operations\nloop for each IStorageOperation\n    UpdateBatch->>IStorageOperation: ConfigureCommand(builder, session)\nend\nnote right of UpdateBatch: execute the batched database command (s)\nUpdateBatch->>IManagedConnection: ExecuteReaderAsync(command, token)\n\nnote right of UpdateBatch: check any post processing conditions (like optimistic version checks) per operation\nloop for each IStorageOperation\n    UpdateBatch->>IStorageOperation: PostprocessAsync(reader, exceptions, token)\nend\n\n```\n\n----------------------------------------\n\nTITLE: Installing Marten via Paket\nDESCRIPTION: This command installs the Marten library using Paket, a dependency manager for .NET. It adds Marten as a NuGet dependency to the project's paket.dependencies file.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/getting_started.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npaket add nuget Marten\n```\n\n----------------------------------------\n\nTITLE: Defining IAsyncConfigureMarten Interface (C#)\nDESCRIPTION: This code snippet defines the `IAsyncConfigureMarten` interface, which allows for asynchronous configuration of Marten's `StoreOptions` using services resolved from an IoC container. It is used to configure Marten after `AddMarten()` but before the `DocumentStore` is initialized.  The `Configure` method takes `StoreOptions` and a `CancellationToken` as parameters.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/hostbuilder.md#_snippet_12\n\nLANGUAGE: cs\nCODE:\n```\n/// <summary>\n///     Mechanism to register additional Marten configuration that is applied after AddMarten()\n///     configuration, but before DocumentStore is initialized when you need to utilize some\n/// kind of asynchronous services like Microsoft's FeatureManagement feature to configure Marten\n/// </summary>\npublic interface IAsyncConfigureMarten\n{\n    ValueTask Configure(StoreOptions options, CancellationToken cancellationToken);\n}\n```\n\n----------------------------------------\n\nTITLE: Program Entry Point - C#\nDESCRIPTION: This C# snippet shows the necessary line in `program.cs` to enable Oakton commands within your application. It ensures that the application can run Oakton-based commands from the command line, for example code generation.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/devops/devops.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nreturn await app.RunOaktonCommands(args);\n```\n\n----------------------------------------\n\nTITLE: Phrase Search in Query Sample (C#)\nDESCRIPTION: \nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/linq.md#_snippet_41\n\nLANGUAGE: C#\nCODE:\n```\nvar targets = session.Query<Target>().Where(x => x.String.PhraseSearch(\"token\")).ToList();\n```\n\n----------------------------------------\n\nTITLE: Setting Event Store Schema - C#\nDESCRIPTION: This code snippet demonstrates how to configure Marten to use a specific schema for event store objects, rather than the default schema.  This can be useful for organizing database objects and separating concerns. The `Events.DatabaseSchemaName` method allows you to specify the desired schema name.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/events/schema.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// Nothing to see here, see sample Marten.Examples.EventStore.CustomSchemaUsage\n```\n\n----------------------------------------\n\nTITLE: Configure Foreign Key to External Table - C#\nDESCRIPTION: Shows how to configure a foreign key relationship from an Issue document to a table in an external schema.  This creates a foreign key constraint from the `mt_doc_issue` table to a specified table and schema.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/foreign_keys.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:configure-external-foreign-key]>\n```\n\n----------------------------------------\n\nTITLE: Benchmark Results: AppendEvents\nDESCRIPTION: This snippet displays the benchmark results for the 'AppendEvents' method.  It shows the mean execution time and standard deviation, indicating the performance characteristics of this method. The values are measured in milliseconds.\nSOURCE: https://github.com/jasperfx/marten/blob/master/benchmarks/2.0.newtonsoft.upgrade/results/EventActions-report-github.md#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n       Method |       Mean |    StdDev |\n------------- |----------- |---------- |\n AppendEvents | 44.6766 ms | 0.9392 ms |\n```\n\n----------------------------------------\n\nTITLE: Implementing Aggregate Repository (C#)\nDESCRIPTION: This class implements a repository for persisting and loading aggregates using Marten. The `StoreAsync` method appends uncommitted events to the event stream, indexed by the aggregate ID. The `LoadAsync` method retrieves an aggregate from the event stream by ID and optionally by version. It uses `IDocumentStore` to access Marten's event sourcing capabilities.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/scenarios/aggregates-events-repositories.md#_snippet_3\n\nLANGUAGE: cs\nCODE:\n```\npublic sealed class AggregateRepository\n{\n    private readonly IDocumentStore store;\n\n    public AggregateRepository(IDocumentStore store)\n    {\n        this.store = store;\n    }\n\n    public async Task StoreAsync(AggregateBase aggregate, CancellationToken ct = default)\n    {\n        await using var session = await store.LightweightSerializableSessionAsync(token: ct);\n        // Take non-persisted events, push them to the event stream, indexed by the aggregate ID\n        var events = aggregate.GetUncommittedEvents().ToArray();\n        session.Events.Append(aggregate.Id, aggregate.Version, events);\n        await session.SaveChangesAsync(ct);\n        // Once successfully persisted, clear events from list of uncommitted events\n        aggregate.ClearUncommittedEvents();\n    }\n\n    public async Task<T>\n        LoadAsync<\n            T\n        >(\n        string id,\n        int? version = null,\n        CancellationToken ct = default\n    ) where T : AggregateBase\n    {\n        await using var session = await store.LightweightSerializableSessionAsync(token: ct);\n        var aggregate = await session.Events.AggregateStreamAsync<T>(id, version ?? 0, token: ct);\n        return aggregate ?? throw new InvalidOperationException($\"No aggregate by id {id}.\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Explicit PL/pgSQL Language Declaration\nDESCRIPTION: This code snippet shows how to explicitly define the language as PL/pgSQL at the end of an anonymous code block.  This clarifies the language being used within the BEGIN/END block. It is functionally equivalent to the first example, which implicitly assumes PL/pgSQL.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/postgres/if_statements.md#_snippet_1\n\nLANGUAGE: PL/pgSQL\nCODE:\n```\nDO $$\nBEGIN\n\n    // your sql here…\n\nEND\n$$ LANGUAGE plpgsql;\n```\n\n----------------------------------------\n\nTITLE: Running PostgreSQL in Docker\nDESCRIPTION: This command is used to start a PostgreSQL database in a Docker container. It simplifies development by providing a readily available database instance.\nSOURCE: https://github.com/jasperfx/marten/blob/master/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ndocker-compose up\n```\n\n----------------------------------------\n\nTITLE: Using Fake Time Provider in Async Aggregation Test (C#)\nDESCRIPTION: This code snippet illustrates how to use a `FakeTimeProvider` in an asynchronous aggregation test with Marten. It sets up a host with Marten configured to use the `FakeTimeProvider` for event timestamps. It then injects events, waits for projection data to be non-stale, loads the projected document, and asserts that the document's created timestamp matches the start time of the `FakeTimeProvider`.  Requires Microsoft.Extensions.Hosting and Microsoft.Extensions.DependencyInjection.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/events/projections/testing.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic async Task test_async_aggregation_with_wait_for_and_fake_time_provider()\n{\n    // Hang on to this for later!!!\n    var eventsTimeProvider = new FakeTimeProvider();\n\n    // In your tests, you would most likely use the IHost for your\n    // application as it is normally built\n    using var host = await Host.CreateDefaultBuilder()\n        .ConfigureServices(services =>\n        {\n            services.AddMarten(opts =>\n                {\n                    opts.Connection(\n                        \"Host=localhost;Port=5432;Database=marten_testing;Username=postgres;password=postgres;Command Timeout=5\");\n                    opts.DatabaseSchemaName = \"incidents\";\n\n                    // Notice that the \"snapshot\" is running inline\n                    opts.Projections.Snapshot<Invoice>(SnapshotLifecycle.Async);\n\n                    opts.Events.TimeProvider = eventsTimeProvider;\n                })\n\n                // Using Solo in tests will help it start up a little quicker\n                .AddAsyncDaemon(DaemonMode.Solo);\n        }).StartAsync();\n\n    var store = host.Services.GetRequiredService<IDocumentStore>();\n\n    var invoiceId = Guid.NewGuid();\n\n    // Pump in events\n    using (var session = store.LightweightSession())\n    {\n        session.Events.StartStream<Invoice>(invoiceId, new InvoiceCreated(\"Blue Shoes\", 112.24m));\n        await session.SaveChangesAsync();\n\n        session.Events.Append(invoiceId,new InvoiceApproved());\n        session.Events.Append(invoiceId,new InvoicePaid());\n        await session.SaveChangesAsync();\n    }\n\n    // Now, this is going to pause here in this thread until the async daemon\n    // running in our IHost is completely caught up to at least the point of the\n    // last event captured at the point this method was called\n    await store.WaitForNonStaleProjectionDataAsync(5.Seconds());\n\n    // NOW, we should expect reliable results by just loading the already\n    // persisted documents built by rebuilding the projection\n    await using var query = store.QuerySession();\n\n    // Load the document that was \"projected\" from the events above\n    // and immediately persisted to the document store\n    var invoice = await query.LoadAsync<Invoice>(invoiceId);\n\n    // Run assertions, and we'll use the faked timestamp\n    // from our time provider\n    invoice.Created.ShouldBe(eventsTimeProvider.Start);\n}\n```\n\n----------------------------------------\n\nTITLE: Running restore, build and test (.NET CLI)\nDESCRIPTION: This command restores dependencies, builds the solution, and runs tests using the .NET CLI.  It's a standard way to build and test .NET projects.\nSOURCE: https://github.com/jasperfx/marten/blob/master/README.md#_snippet_4\n\nLANGUAGE: .NET CLI\nCODE:\n```\ndotnet build src\\Marten.sln\n```\n\n----------------------------------------\n\nTITLE: Adding days to current date using DATEADD\nDESCRIPTION: This SQL snippet shows how to add 5 days to the current UTC date in SQL Server using the `DATEADD` function.  `DATEADD` takes three arguments: the date part to increment (day), the number of increments (5), and the date to modify (`getutcdate()`). The result is a new date 5 days in the future.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/postgres/dates.md#_snippet_0\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT DATEADD(day, 5, getutcdate())\n```\n\n----------------------------------------\n\nTITLE: Sample Events\nDESCRIPTION: This snippet defines sample event classes used in the Marten Event Store examples. These classes likely represent different events occurring during a quest, such as `QuestStarted`, `MembersJoined`, and `MonstersSlain`. They serve as a model for capturing and persisting event data.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/events/index.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:sample-events]>\n```\n\n----------------------------------------\n\nTITLE: Defining Aggregate Events (C#)\nDESCRIPTION: These classes define events for capturing state changes in an invoice.  `InvoiceCreated` captures the creation of an invoice with an invoice number. `LineItemAdded` captures the addition of a line item to an invoice, including the price, VAT, and description.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/scenarios/aggregates-events-repositories.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\npublic sealed class InvoiceCreated\n{\n    public int InvoiceNumber { get; }\n\n    public InvoiceCreated(int invoiceNumber)\n    {\n        InvoiceNumber = invoiceNumber;\n    }\n}\n\npublic sealed class LineItemAdded\n{\n    public decimal Price { get; }\n    public decimal Vat { get; }\n    public string Description { get; }\n\n    public LineItemAdded(decimal price, decimal vat, string description)\n    {\n        Price = price;\n        Vat = vat;\n        Description = description;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Is One Of Array (C#)\nDESCRIPTION: To find one of for an array you can use this strategy:\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/linq.md#_snippet_29\n\nLANGUAGE: C#\nCODE:\n```\nvar numbers = new[] {1, 2, 3};\nvar targets = session.Query<Target>().Where(x => x.Number.IsOneOf(numbers)).ToList();\n```\n\n----------------------------------------\n\nTITLE: Run all tests including mocha tests (.NET CLI)\nDESCRIPTION: This command runs all tests, including Mocha tests, by executing the build project with the 'test' argument using the .NET CLI.\nSOURCE: https://github.com/jasperfx/marten/blob/master/README.md#_snippet_5\n\nLANGUAGE: .NET CLI\nCODE:\n```\ndotnet run --project build/build.csproj -- test\n```\n\n----------------------------------------\n\nTITLE: Installing Node.js packages\nDESCRIPTION: This command installs the required Node.js packages for updating or adding new documentation. It should be run in the root directory of the repository after installing Node.js.\nSOURCE: https://github.com/jasperfx/marten/blob/master/CONTRIBUTING.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm install\n```\n\n----------------------------------------\n\nTITLE: Run docs website locally (.NET CLI)\nDESCRIPTION: This command runs the documentation website locally by executing the build project with the 'docs' argument using the .NET CLI.\nSOURCE: https://github.com/jasperfx/marten/blob/master/README.md#_snippet_9\n\nLANGUAGE: .NET CLI\nCODE:\n```\ndotnet run --project build/build.csproj -- docs\n```\n\n----------------------------------------\n\nTITLE: Querying Marten with SQL Asynchronously\nDESCRIPTION: Illustrates how to execute custom SQL queries asynchronously against a Marten database. This involves using the `QueryAsync()` method, allowing for more complex or specific data retrieval scenarios beyond standard Linq. Requires Marten setup and connection string.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/async.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:using-queryasync]>\n```\n\n----------------------------------------\n\nTITLE: Issue Class with ForeignKey Attribute - C#\nDESCRIPTION: Demonstrates how to configure properties as foreign key relationships using the `[ForeignKey]` attribute in C#.  This provides an alternative to the fluent configuration approach.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/configuration/foreign_keys.md#_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n<[sample:issue-with-fk-attribute]>\n```\n\n----------------------------------------\n\nTITLE: Run StoryTeller tests (.NET CLI)\nDESCRIPTION: This command runs the StoryTeller tests by executing the build project with the 'storyteller' argument using the .NET CLI.\nSOURCE: https://github.com/jasperfx/marten/blob/master/README.md#_snippet_7\n\nLANGUAGE: .NET CLI\nCODE:\n```\ndotnet run --project build/build.csproj -- storyteller\n```\n\n----------------------------------------\n\nTITLE: Setting PostgreSQL version for tests\nDESCRIPTION: This command sets the PostgreSQL version to be used by the test explorer. This enforces a specific database version if the explorer doesn't detect it automatically.\nSOURCE: https://github.com/jasperfx/marten/blob/master/README.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\npostgresql_version=15.3\n```\n\n----------------------------------------\n\nTITLE: Defining an Immutable F# Event with Record Type\nDESCRIPTION: This F# code defines an immutable event `MyEvent` using a record type. Record types in F# are inherently immutable, meaning their fields cannot be modified after creation. This provides a more functional and predictable approach to event handling compared to mutable C# classes with public setters.\nSOURCE: https://github.com/jasperfx/marten/blob/master/planning/MartenV4-WastazComments.md#_snippet_0\n\nLANGUAGE: fsharp\nCODE:\n```\ntype MyEvent = {\n  fruit : string\n  numberOfFruitsBought : int\n}\n```\n\n----------------------------------------\n\nTITLE: Ordering Results in Marten Linq using C#\nDESCRIPTION: Shows how to order query results in Marten using Linq, including ascending and descending order. Demonstrates using `OrderBy()`, `OrderByDescending()`, `ThenBy()`, and `OrderBySql()`. It uses `IDocumentSession` to query the `Target` document type and applies different ordering strategies.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/documents/querying/linq/operators.md#_snippet_4\n\nLANGUAGE: cs\nCODE:\n```\npublic void order_by(IDocumentSession session)\n{\n    // Sort in ascending order\n    session.Query<Target>().OrderBy(x => x.Date);\n\n    // Sort in descending order\n    session.Query<Target>().OrderByDescending(x => x.Date);\n\n    // You can use multiple order by's\n    session.Query<Target>().OrderBy(x => x.Date).ThenBy(x => x.Number);\n\n    // If you're brave, you can even use raw SQL literals as of Marten v7!\n    session.Query<Target>().OrderBySql(\"substring(d.data -> 'String', 1, 2)\");\n}\n```\n\n----------------------------------------\n\nTITLE: SQL Server Conditional Table Creation (Example)\nDESCRIPTION: This code snippet exemplifies conditional table creation in SQL Server.  It checks if a table exists, and if not, creates it. This is included as a comparison to the more concise PostgreSQL syntax.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/postgres/if_statements.md#_snippet_4\n\nLANGUAGE: SQL\nCODE:\n```\nIF NOT EXISTS (….)\nBEGIN\n    CREATE TABLE Product (…\n\n```\n\n----------------------------------------\n\nTITLE: Pushing Application Docker Image to Registry\nDESCRIPTION: This step pushes the application's Docker image to the configured registry (e.g., Docker Hub). The image is tagged with the Git SHA.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/devops/devops.md#_snippet_15\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Push Application Docker Image\n  run: docker push myapp/application:${{ github.sha }}\n```\n\n----------------------------------------\n\nTITLE: Run benchmarks (.NET CLI)\nDESCRIPTION: This command runs benchmarks by executing the build project with the 'benchmarks' argument using the .NET CLI.\nSOURCE: https://github.com/jasperfx/marten/blob/master/README.md#_snippet_11\n\nLANGUAGE: .NET CLI\nCODE:\n```\ndotnet run --project build/build.csproj -- benchmarks\n```\n\n----------------------------------------\n\nTITLE: Marking C# Code Snippets for Documentation (v3.x)\nDESCRIPTION: This snippet demonstrates how to mark C# code blocks for inclusion in documentation using `// SAMPLE:` and `// ENDSAMPLE` comments in v3.x. The text following `// SAMPLE:` is the identifier used to reference the snippet.\nSOURCE: https://github.com/jasperfx/marten/blob/master/README.md#_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\n// SAMPLE: name-of-sample\n// code to include\n// ENDSAMPLE\n```\n\n----------------------------------------\n\nTITLE: Dumping DDL to Single File - Bash\nDESCRIPTION: This command dumps the entire DDL (Data Definition Language) for the configured Marten database to a single file named \"database.sql\". This output represents the complete schema for the database as defined by Marten.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/configuration/cli.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nmarten marten-dump database.sql\n```\n\n----------------------------------------\n\nTITLE: Web Search in Query Sample (C#)\nDESCRIPTION: \nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/linq.md#_snippet_42\n\nLANGUAGE: C#\nCODE:\n```\nvar targets = session.Query<Target>().Where(x => x.String.WebStyleSearch(\"token\")).ToList();\n```\n\n----------------------------------------\n\nTITLE: Adding Marten Package via .NET CLI\nDESCRIPTION: This command adds the Marten NuGet package to your .NET project using the .NET CLI. It simplifies the process of including the Marten library and its dependencies into your project.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/getting-started.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ndotnet add package Marten\n```\n\n----------------------------------------\n\nTITLE: Marten Generated SQL DDL\nDESCRIPTION: This SQL script is the output of the DDL export from Marten. It contains the table definitions for `mt_doc_user`, `mt_doc_company`, and `mt_doc_issue`, along with corresponding `mt_upsert` functions and indexes. Additionally, it includes the `mt_hilo` table and `mt_get_next_hi` function used for Marten's HiLo identifier strategy.\nSOURCE: https://github.com/jasperfx/marten/blob/master/docs/schema/exporting.md#_snippet_1\n\nLANGUAGE: SQL\nCODE:\n```\nDROP TABLE IF EXISTS mt_doc_user CASCADE;\nCREATE TABLE mt_doc_user (\n    id           uuid CONSTRAINT pk_mt_doc_user PRIMARY KEY,\n    data         jsonb NOT NULL ,\n    user_name    varchar\n);\n\n\nCREATE OR REPLACE FUNCTION mt_upsert_user(docId uuid, doc JSONB, arg_user_name varchar) RETURNS VOID AS\n$$\nBEGIN\nINSERT INTO mt_doc_user VALUES (docId, doc, arg_user_name)\n  ON CONFLICT ON CONSTRAINT pk_mt_doc_user\n  DO UPDATE SET data = doc, user_name = arg_user_name;\nEND;\n$$\nLANGUAGE plpgsql;\n\nCREATE INDEX mt_doc_user_idx_user_name ON mt_doc_user (user_name)\n\n\nDROP TABLE IF EXISTS mt_doc_company CASCADE;\nCREATE TABLE mt_doc_company (\n    id      uuid CONSTRAINT pk_mt_doc_company PRIMARY KEY,\n    data    jsonb NOT NULL\n);\n\n\nCREATE OR REPLACE FUNCTION mt_upsert_company(docId uuid, doc JSONB) RETURNS VOID AS\n$$\nBEGIN\nINSERT INTO mt_doc_company VALUES (docId, doc)\n  ON CONFLICT ON CONSTRAINT pk_mt_doc_company\n  DO UPDATE SET data = doc;\nEND;\n$$\nLANGUAGE plpgsql;\n\nCREATE INDEX mt_doc_company_idx_data ON mt_doc_company USING gin (data jsonb_path_ops)\n\n\nDROP TABLE IF EXISTS mt_doc_issue CASCADE;\nCREATE TABLE mt_doc_issue (\n    id      uuid CONSTRAINT pk_mt_doc_issue PRIMARY KEY,\n    data    jsonb NOT NULL\n);\n\n\nCREATE OR REPLACE FUNCTION mt_upsert_issue(docId uuid, doc JSONB) RETURNS VOID AS\n$$\nBEGIN\nINSERT INTO mt_doc_issue VALUES (docId, doc)\n  ON CONFLICT ON CONSTRAINT pk_mt_doc_issue\n  DO UPDATE SET data = doc;\nEND;\n$$\nLANGUAGE plpgsql;\n\n\nDROP TABLE IF EXISTS mt_hilo CASCADE;\nCREATE TABLE mt_hilo (\n    entity_name            varchar CONSTRAINT pk_mt_hilo PRIMARY KEY,\n    hi_value            bigint default 0\n);\n\nCREATE OR REPLACE FUNCTION mt_get_next_hi(entity varchar) RETURNS int AS $$\nDECLARE\n    current_value bigint;\n    next_value bigint;\nBEGIN\n    select hi_value into current_value from mt_hilo where entity_name = entity;\n    IF current_value is null THEN\n        insert into mt_hilo (entity_name, hi_value) values (entity, 0);\n        next_value := 0;\n    ELSE\n        next_value := current_value + 1;\n        update mt_hilo set hi_value = next_value where entity_name = entity;\n    END IF;\n\n    return next_value;\nEND\n$$ LANGUAGE plpgsql;\n```\n\n----------------------------------------\n\nTITLE: Run just mocha tests (.NET CLI)\nDESCRIPTION: This command runs only the Mocha tests by executing the build project with the 'mocha' argument using the .NET CLI.\nSOURCE: https://github.com/jasperfx/marten/blob/master/README.md#_snippet_6\n\nLANGUAGE: .NET CLI\nCODE:\n```\ndotnet run --project build/build.csproj -- mocha\n```\n\n----------------------------------------\n\nTITLE: Analyzing Benchmark Results\nDESCRIPTION: This code snippet presents benchmark results for the 'AppendEvents' method. It provides the mean execution time and standard deviation, offering insights into performance characteristics. The results are specific to the .NET CLR 4.0 and are influenced by the hardware configuration.\nSOURCE: https://github.com/jasperfx/marten/blob/master/benchmarks/2.0.newtonsoft.upgrade/results/EventActions-report-default.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nBenchmarkDotNet=v0.10.1, OS=Microsoft Windows NT 6.1.7601 Service Pack 1\nProcessor=Intel(R) Core(TM) i7-4980HQ CPU 2.80GHz, ProcessorCount=4\nFrequency=10000000 Hz, Resolution=100.0000 ns, Timer=UNKNOWN\n  [Host]     : Clr 4.0.30319.42000, 64bit RyuJIT-v4.6.1076.0\n  Job-DNINOD : Clr 4.0.30319.42000, 64bit RyuJIT-v4.6.1076.0\n\nWarmupCount=2  Allocated=1.88 MB  \n\n       Method |       Mean |    StdDev |\n------------- |----------- |---------- |\n AppendEvents | 44.6766 ms | 0.9392 ms |\n```\n\n----------------------------------------\n\nTITLE: Embedding Code Snippets in Markdown (v3.x)\nDESCRIPTION: This snippet demonstrates how to embed a C# code snippet within a Markdown document for v3.x. The `<[sample:name-of-sample]>` tag is used to indicate the location where the external code snippet should be injected. The `name-of-sample` value corresponds to the name given to the code snippet.\nSOURCE: https://github.com/jasperfx/marten/blob/master/README.md#_snippet_15\n\nLANGUAGE: Markdown\nCODE:\n```\n<[sample:name-of-sample]>\n```\n\n----------------------------------------\n\nTITLE: Extension Method for SQL Generation\nDESCRIPTION: Provides an extension method used as a shorthand for generating the SQL statement needed to query the database for the next value in a sequence. This simplifies the process of retrieving the next available sequence number.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/scenarios/usingsequenceforuniqueid.md#_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\n<[sample:scenario-usingsequenceforuniqueid-setup-extensions]>\n```\n\n----------------------------------------\n\nTITLE: Parsing Linq Query Sequence Diagram\nDESCRIPTION: This Mermaid sequence diagram shows the flow of parsing a Linq query in Marten, starting from the LinqQueryProvider, involving LinqHandlerBuilder, MartenQueryParser, IMartenSession, and DocumentStatement. It shows how the query expression is parsed and translated into a DocumentStatement.\nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/diagrams/querying.md#_snippet_1\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n\nnote right of LinqQueryProvider: there are other options to inject result operators\nLinqQueryProvider ->> LinqHandlerBuilder: new(IMartenSession, Expression)\nLinqHandlerBuilder ->> MartenQueryParser: GetParsedQuery(Expression)\nMartenQueryParser -->> LinqHandlerBuilder: QueryModel\nLinqHandlerBuilder ->> IMartenSession: StorageFor(Type)\nIMartenSession -->> LinqHandlerBuilder: IDocumentStorage\nLinqHandlerBuilder ->> DocumentStatement: new(IDocumentStorage)\nnote right of LinqHandlerBuilder: A *lot* of stuff happens in here to visit all the body, where, order, take, while, and select clauses of the Linq query\nLinqHandlerBuilder -> LinqHandlerBuilder: readQueryModel(QueryModel)\n\n```\n\n----------------------------------------\n\nTITLE: Text Search with Non Default RegConfig Sample (C#)\nDESCRIPTION: \nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/linq.md#_snippet_44\n\nLANGUAGE: C#\nCODE:\n```\nvar targets = session.Query<Target>().Where(x => x.String.Search(\"token\", regConfig: \"french\")).ToList();\n```\n\n----------------------------------------\n\nTITLE: Plain Search in Query Sample (C#)\nDESCRIPTION: \nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/linq.md#_snippet_40\n\nLANGUAGE: C#\nCODE:\n```\nvar targets = session.Query<Target>().Where(x => x.String.PlainSearch(\"token\")).ToList();\n```\n\n----------------------------------------\n\nTITLE: Search in Query Sample (C#)\nDESCRIPTION: \nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/linq.md#_snippet_39\n\nLANGUAGE: C#\nCODE:\n```\nvar targets = session.Query<Target>().Where(x => x.String.Search(\"token\")).ToList();\n```\n\n----------------------------------------\n\nTITLE: Is Subset Of (C#)\nDESCRIPTION: \nSOURCE: https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/linq.md#_snippet_35\n\nLANGUAGE: C#\nCODE:\n```\nvar numbers = new List<int> {1, 2};\nvar targets = session.Query<Target>().Where(x => x.Numbers.IsSubsetOf(numbers)).ToList();\n```"
  }
]