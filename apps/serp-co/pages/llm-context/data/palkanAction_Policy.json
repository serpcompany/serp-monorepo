[
  {
    "owner": "palkan",
    "repo": "action_policy",
    "content": "TITLE: Defining a Policy Class with Predicate Methods in Ruby\nDESCRIPTION: Defines a policy class `PostPolicy` inheriting from `ActionPolicy::Base`, which contains predicate methods (`index?`, `update?`) to authorize specific actions on posts based on context, such as user permissions and record ownership.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/writing_policies.md#_snippet_0\n\nLANGUAGE: Ruby\nCODE:\n```\nclass PostPolicy < ActionPolicy::Base\n  def index?\n    # allow everyone to perform \"index\" activity on posts\n    true\n  end\n\n  def update?\n    # here we can access our context and record\n    user.admin? || (user.id == record.user_id)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Defining PostPolicy\nDESCRIPTION: This code snippet shows how to define a policy for a Post resource. It includes example rules for checking permissions to show and update a post based on user roles and ownership. The `user` is the performing subject and `record` is the target object.\nSOURCE: https://github.com/palkan/action_policy/blob/master/README.md#_snippet_3\n\nLANGUAGE: ruby\nCODE:\n```\nclass PostPolicy < ApplicationPolicy\n  # everyone can see any post\n  def show?\n    true\n  end\n\n  def update?\n    # `user` is a performing subject,\n    # `record` is a target object (post we want to update)\n    user.admin? || (user.id == record.user_id)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring Authorization Context for Controller\nDESCRIPTION: This snippet shows how to configure the authorization context within a Rails controller.  It sets up the `current_user` method to be used as the subject for authorization. This is done by overriding the default behavior via the `authorize` method, which can receive a symbol representing the user and a `:through` option to specify how to retrieve the current user. Alternatively, a Proc can be used with `:through` to handle scenarios like ActiveSupport::CurrentAttributes.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/rails.md#_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nclass ApplicationController < ActionController::Base\n  authorize :user, through: :my_current_user\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring Authorization Context with Proc for Controller\nDESCRIPTION: This snippet demonstrates using a Proc to define the authorization context in a Rails controller, specifically when using `ActiveSupport::CurrentAttributes`. The `authorize` method is used, similar to the previous example, but `:through` option now takes a Proc that dynamically retrieves the user.  This allows for flexibility in accessing the current user based on the application's needs.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/rails.md#_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nclass ApplicationController < ActionController::Base\n  authorize :user, through: -> { Current.user }\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Action Policy Authorization in a Ruby Class\nDESCRIPTION: Demonstrates how to integrate Action Policy authorization into a plain Ruby class. It includes the `ActionPolicy::Behaviour` module, specifies the authorization subject (performer) using `authorize :user`, and uses the `authorize!` method within a business logic method (`call`) to enforce the `:update?` policy on a `post` object before allowing the update operation.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/non_rails.md#_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nclass PostUpdateAction\n  include ActionPolicy::Behaviour\n\n  # provide authorization subject (performer)\n  authorize :user\n\n  attr_reader :user\n\n  def initialize(user)\n    @user = user\n  end\n\n  def call(post, params)\n    authorize! post, to: :update?\n\n    post.update!(params)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Adding Action Policy to Gemfile - Ruby\nDESCRIPTION: Specifies the Action Policy gem as a dependency in a Rails application's Gemfile. After adding this line, running 'bundle install' adds the gem and its dependencies to the application, making Action Policy available for authorization functionality.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/quick_start.md#_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\ngem \"action_policy\"\n```\n\n----------------------------------------\n\nTITLE: Defining Resource-Specific Policy Rules - Ruby\nDESCRIPTION: Implements a 'PostPolicy' class inheriting from 'ApplicationPolicy' with resource-specific access rules. The 'show?' method allows access to all users, while 'update?' restricts access to admins or the user who owns the post. Relies on 'user' and 'record' context provided by Action Policy. The resource policy must be placed where Action Policy can infer it based on the resource's class name.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/quick_start.md#_snippet_5\n\nLANGUAGE: ruby\nCODE:\n```\nclass PostPolicy < ApplicationPolicy\n  # everyone can see any post\n  def show?\n    true\n  end\n\n  def update?\n    # `user` is a performing subject,\n    # `record` is a target object (post we want to update)\n    user.admin? || (user.id == record.user_id)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Testing policy classes with RSpec in Ruby\nDESCRIPTION: This snippet demonstrates how to test an authorization policy class using RSpec by instantiating the policy with a record and user context. It verifies rule methods (e.g., #update?) return expected boolean results depending on user roles or ownership. No special tooling is required beyond RSpec and basic test doubles (e.g., build_stubbed). Inputs include a user and a post record; the output is the boolean authorization decision from the policy.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/testing.md#_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\ndescribe PostPolicy do\n  let(:user) { build_stubbed(:user) }\n  let(:post) { build_stubbed(:post) }\n\n  let(:policy) { described_class.new(post, user: user) }\n\n  describe \"#update?\" do\n    subject { policy.apply(:update?) }\n\n    it \"returns false when the user is not admin nor author\" do\n      is_expected.to eq false\n    end\n\n    context \"when the user is admin\" do\n      let(:user) { build_stubbed(:user, :admin) }\n\n      it { is_expected.to eq true }\n    end\n\n    context \"when the user is an author\" do\n      let(:post) { build_stubbed(:post, user: user) }\n\n      it { is_expected.to eq true }\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Handling Authorization Errors - Ruby\nDESCRIPTION: Configures error handling for 'ActionPolicy::Unauthorized' exceptions raised when an authorization rule fails. The rescue_from block allows introspection of the exception to access the violated policy and rule, which can be leveraged for custom error pages or logging. This should be added to the relevant controller or globally in the application controller.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/quick_start.md#_snippet_7\n\nLANGUAGE: ruby\nCODE:\n```\nrescue_from ActionPolicy::Unauthorized do |ex|\n  # Exception object contains the following information\n  ex.policy #=> policy class, e.g. UserPolicy\n  ex.rule #=> applied rule, e.g. :show?\nend\n```\n\n----------------------------------------\n\nTITLE: Fail-Fast or Pass-Fast Authorization with `allow!` and `deny!` in Ruby\nDESCRIPTION: Illustrates how to explicitly allow or deny actions within policy methods using `allow!` and `deny!`, producing clearer control flow and immediate permission rejection or acceptance, such as permitting admins to view or blocking actions based on specific record conditions.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/writing_policies.md#_snippet_4\n\nLANGUAGE: Ruby\nCODE:\n```\nclass PostPolicy < ApplicationPolicy\n  def show?\n    allow! if user.admin?\n\n    check?(:publicly_visible?)\n  end\n\n  def destroy?\n    deny! if record.subscribers.any?\n\n    # some general logic\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Calling Other Policies within a Policy in Ruby\nDESCRIPTION: Shows how to invoke other policy rules from within a policy class using the `allowed_to?` method, allowing composite permission checks involving related records such as posts and comments. Also demonstrates the optional parameters like `with` for contextual control.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/writing_policies.md#_snippet_2\n\nLANGUAGE: Ruby\nCODE:\n```\nclass CommentPolicy < ApplicationPolicy\n  def update?\n    user.admin? || (user.id == record.id) ||\n      allowed_to?(:update?, record.post)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring Authorization Context for Action Cable Channel\nDESCRIPTION: This snippet demonstrates how to configure the authorization context for an Action Cable channel, in a way similar to controllers.  It uses the `authorize` method inside an `ApplicationCable::Channel` class to specify the authorization context. By setting `authorize :user`, the channel actions will use the `current_user` as an authorization context. This snippet enables consistent authorization across the application.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/rails.md#_snippet_7\n\nLANGUAGE: ruby\nCODE:\n```\nmodule ApplicationCable\n  class Channel < ActionCable::Channel::Base\n    # assuming that identifier is called `user`\n    authorize :user\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Testing ActiveRecord relation scopes with RSpec in Ruby\nDESCRIPTION: This snippet illustrates testing policy scope filters on ActiveRecord relations. It sets up different user roles and creates sample posts with attributes for filtering. It verifies that the authorized scope yields appropriately filtered sets depending on the user role or banned status. Key inputs are the user role and set of posts; output is the filtered collection of post names confirming correct scope application.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/testing.md#_snippet_3\n\nLANGUAGE: ruby\nCODE:\n```\ndescribe PostPolicy do\n  describe \"relation scope\" do\n    let(:user) { build_stubbed :user }\n    let(:context) { {user: user} }\n\n    before do\n      create(:post, name: \"A\")\n      create(:post, name: \"B\", draft: true)\n    end\n\n    let(:target) do\n      Post.where(name: %w[A B]).order(name: :asc)\n    end\n\n    subject { policy.apply_scope(target, type: :active_record_relation).pluck(:name) }\n\n    context \"as user\" do\n      it { is_expected.to eq(%w[A]) }\n    end\n\n    context \"as manager\" do\n      before { user.role = :manager }\n\n      it { is_expected.to eq(%w[A B]) }\n    end\n\n    context \"as banned user\" do\n      before { user.banned = true }\n\n      it { is_expected.to be_empty }\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Using `check?` as an Alias for `allowed_to?` for Readability in Ruby\nDESCRIPTION: Provides an alternative method `check?`, which acts as a wrapper around `allowed_to?`, enhancing code readability when performing policy checks. Example usage in `show?` and `publicly_visible?` methods showcases flexible permission evaluation.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/writing_policies.md#_snippet_3\n\nLANGUAGE: Ruby\nCODE:\n```\nclass PostPolicy < ApplicationPolicy\n  def show?\n    user.admin? || check?(:publicly_visible?)\n  end\n\n  def publicly_visible?\n    # ...\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Conditional Links in ERB Views using allowed_to? - ERB\nDESCRIPTION: Shows how to use the 'allowed_to?' helper in Rails HTML ERB templates to check user authorization before rendering links or actions. Iterates through posts and conditionally displays an 'Edit' link only if the current user has permission, determined by Action Policy. This usage requires Action Policy's helpers to be available in the view context.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/quick_start.md#_snippet_8\n\nLANGUAGE: erb\nCODE:\n```\n<% @posts.each do |post| %>\n  <li><%= post.title %>\n    <% if allowed_to?(:edit?, post) %>\n      <%= link_to \"Edit\", post %>\n    <% end %>\n  </li>\n<% end %>\n```\n\n----------------------------------------\n\nTITLE: Asserting authorization in Minitest with Action Policy in Ruby\nDESCRIPTION: This snippet demonstrates how to test that a controller action correctly authorizes an operation using Minitest and Action Policy's `assert_authorized_to` helper. The test calls `authorize!` within the controller action, then verifies authorization by wrapping the action call inside the assertion. The assertion requires the rule, target, policy class (optional), and an optional context. Input is the controller action invocation; output is test pass/fail confirming authorization was performed.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/testing.md#_snippet_5\n\nLANGUAGE: ruby\nCODE:\n```\n# in your controller\nclass PostsController < ApplicationController\n  def update\n    @post = Post.find(params[:id])\n    authorize! @post, context: {favorite: true}\n    if @post.update(post_params)\n      redirect_to @post\n    else\n      render :edit\n    end\n  end\nend\n\n# in your test\nrequire \"action_policy/test_helper\"\n\nclass PostsControllerTest < ActionDispatch::IntegrationTest\n  include ActionPolicy::TestHelper\n\n  test \"update is authorized\" do\n    sign_in users(:john)\n\n    post = posts(:example)\n\n    assert_authorized_to(:update?, post, with: PostPolicy, context: {favorite: true}) do\n      patch :update, id: post.id, name: \"Bob\"\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Adding Authorization to Rails Controller - Ruby\nDESCRIPTION: Adds authorization to a Rails controller's 'update' action using the 'authorize!' method provided by Action Policy. The snippet demonstrates fetching a post, performing the authorization check, and handling the outcome of an update operation. This relies on Action Policy's integration with Rails controllers and infers policy and rule names automatically.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/quick_start.md#_snippet_6\n\nLANGUAGE: ruby\nCODE:\n```\nclass PostsController < ApplicationController\n  def update\n    @post = Post.find(params[:id])\n    authorize! @post\n\n    if @post.update(post_params)\n      redirect_to @post\n    else\n      render :edit\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Testing authorization with RSpec and be_authorized_to matcher in Ruby\nDESCRIPTION: This example demonstrates testing controller authorization calls in RSpec using the `be_authorized_to` matcher from Action Policy. By requiring `action_policy/rspec`, tests can assert that a block of code authorizes a specific rule on a target record. Policy class specification is optional if inferrable. Context matching is supported with `with_context`. Input is the request invocation; output validates authorization expectations.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/testing.md#_snippet_6\n\nLANGUAGE: ruby\nCODE:\n```\nrequire \"action_policy/rspec\"\n\ndescribe PostsController do\n  subject { patch :update, id: post.id, params: params }\n\n  it \"is authorized\" do\n    expect { subject }.to be_authorized_to(:update?, post)\n      .with(PostPolicy)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Authorizing in Rails Controller\nDESCRIPTION: This code snippet shows how to add authorization to a Rails controller using the `authorize!` method. It finds a post by ID, authorizes access to it, and then updates the post's attributes if authorized. If authorization fails, `ActionPolicy::Unauthorized` error is raised.\nSOURCE: https://github.com/palkan/action_policy/blob/master/README.md#_snippet_4\n\nLANGUAGE: ruby\nCODE:\n```\nclass PostsController < ApplicationController\n  def update\n    @post = Post.find(params[:id])\n    authorize! @post\n\n    if @post.update(post_params)\n      redirect_to @post\n    else\n      render :edit\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Using have_authorized_scope Matcher in RSpec (Ruby)\nDESCRIPTION: Demonstrates the basic usage of the `have_authorized_scope` RSpec matcher within a controller spec. It verifies that executing the controller action (`subject`) applies an authorization scope, identified by `:active_record_relation`, using the `PostPolicy`.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/testing.md#_snippet_11\n\nLANGUAGE: ruby\nCODE:\n```\ndescribe UsersController do\n  subject { get :index }\n\n  it \"has authorized scope\" do\n    expect { subject }.to have_authorized_scope(:active_record_relation)\n      .with(PostPolicy)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Using authorize! Method in Ruby\nDESCRIPTION: This snippet shows the use of `authorize!` method to perform authorization. It raises an `ActionPolicy::Unauthorized` exception if the authorization fails based on the policy rule specified with the `to` parameter.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/behaviour.md#_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\n# `to` is a name of the policy rule to apply\nauthorize! post, to: :update?\n```\n\n----------------------------------------\n\nTITLE: Defining different types of scopes in a policy class\nDESCRIPTION: Examples of defining scopes for different data types (relations and hashes) within a policy class using the scope_for method.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/scoping.md#_snippet_3\n\nLANGUAGE: ruby\nCODE:\n```\nclass PostPolicy < ApplicationPolicy\n  # define a scope of a `relation` type\n  scope_for :relation do |relation|\n    relation.where(user: user)\n  end\n\n  # define a scope of `data` type,\n  # which acts on hashes\n  scope_for :data do |data|\n    next data if user.admin?\n    data.delete_if { |k, _| SENSITIVE_KEYS.include?(k) }\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring scope matchers for automatic type inference in Action Policy\nDESCRIPTION: Examples of configuring scope matchers to enable automatic type inference when the scope type isn't explicitly specified, including using both class-based and Proc-based matchers.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/scoping.md#_snippet_9\n\nLANGUAGE: ruby\nCODE:\n```\nclass ApplicationPolicy < ActionPolicy::Base\n  scope_matcher :relation, ActiveRecord::Relation\n\n  # use Proc to handle AR models classes\n  scope_matcher :relation, ->(target) { target < ActiveRecord::Base }\n\n  scope_matcher :custom, MyCustomClass\nend\n```\n\nLANGUAGE: ruby\nCODE:\n```\nclass ApplicationPolicy < ActionPolicy::Base\n  scope_matcher :relation, ActiveRecord::Relation\n\n  # now you can define scope rules like this\n  relation_scope { |relation| relation }\nend\n```\n\n----------------------------------------\n\nTITLE: Including ActionPolicy and Authorizing in Ruby\nDESCRIPTION: This code demonstrates how to include `ActionPolicy::Behaviour` in a custom service object to enable authorization. It uses the `authorize` method to set the authorization subject and the `authorize!` method to enforce authorization rules based on policy.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/behaviour.md#_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nclass PostUpdateAction\n  # First, we should include the behaviour\n  include ActionPolicy::Behaviour\n\n  # Secondly, provide authorization subject (performer)\n  authorize :user\n\n  attr_reader :user\n\n  def initialize(user)\n    @user = user\n  end\n\n  def call(post, params)\n    # Now we can use authorization methods\n    authorize! post, to: :update?\n\n    post.update!(params)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Adding Pundit-compatible policy helper methods with Action Policy in Rails controllers\nDESCRIPTION: Implements 'policy' and 'policy_scope' helper methods that mimic Pundit's API but use Action Policy's 'policy_for' and 'authorized' methods. Makes them available as view helpers with 'helper_method'.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/pundit_migration.md#_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nhelper_method :policy\nhelper_method :policy_scope\n\ndef policy(record)\n  policy_for(record: record)\nend\n\ndef policy_scope(scope)\n  authorized scope\nend\n```\n\n----------------------------------------\n\nTITLE: Installing Action Policy with RubyGems - Ruby\nDESCRIPTION: Installs the Action Policy gem directly using RubyGems for use in a Ruby project. This command fetches the gem and makes it available for use in any Ruby environment. No additional dependencies are required when installing this way, but the gem must be properly required in your application to utilize it.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/quick_start.md#_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\ngem install action_policy\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Base Policy with ActionPolicy in Ruby\nDESCRIPTION: This Ruby class defines 'ActionPolicy::Base' by including multiple ActionPolicy modules to aggregate features such as core policy behavior, authorization, pre-checks, reason handling, aliasing, scoping, and caching. It extends Rails-specific scope matchers to support ActiveRecord relations and ActionController parameters and prepends instrumentation for Active Support notifications. Default authorization rules and aliases are set within the class, specifically authorizing the :user, defining default and aliased rules, and providing false-denying implementations for 'index?', 'create?', and 'manage?' actions. This setup is designed to provide a comprehensive and extensible base policy for Rails applications using ActionPolicy.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/custom_policy.md#_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nclass ActionPolicy::Base\n  include ActionPolicy::Policy::Core\n  include ActionPolicy::Policy::Authorization\n  include ActionPolicy::Policy::PreCheck\n  include ActionPolicy::Policy::Reasons\n  include ActionPolicy::Policy::Aliases\n  include ActionPolicy::Policy::Scoping\n  include ActionPolicy::Policy::Cache\n  include ActionPolicy::Policy::CachedApply\n  include ActionPolicy::Policy::Defaults\n\n  # Rails-specific scoping extensions\n  extend ActionPolicy::ScopeMatchers::ActiveRecord\n  scope_matcher :active_record_relation, ActiveRecord::Relation\n  extend ActionPolicy::ScopeMatchers::ActionControllerParams\n  scope_matcher :action_controller_params, ActionController::Parameters\n\n  # Active Support notifications\n  prepend ActionPolicy::Policy::Rails::Instrumentation\n\n  # ActionPolicy::Policy::Defaults module adds the following\n\n  authorize :user\n\n  default_rule :manage?\n  alias_rule :new?, to: :create?\n\n  def index?\n    false\n  end\n\n  def create?\n    false\n  end\n\n  def manage?\n    false\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Updating ApplicationPolicy initializer for Action Policy compatibility\nDESCRIPTION: Modifies the ApplicationPolicy initializer to use named parameters, specifically requiring a 'user' parameter that matches Action Policy's authorization context expectations.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/pundit_migration.md#_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\ndef initialize(target, user:)\n  # ...\nend\n```\n\n----------------------------------------\n\nTITLE: Using scopes explicitly without including Action Policy behaviour\nDESCRIPTION: Example of how to use scopes explicitly by initializing a policy instance and applying a scope without including the Action Policy behaviour module.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/scoping.md#_snippet_8\n\nLANGUAGE: ruby\nCODE:\n```\n# initialize policy\npolicy = ApplicantPolicy.new(user: user)\n# apply scope\npolicy.apply_scope(User.all, type: :relation)\n```\n\n----------------------------------------\n\nTITLE: Defining the Application Policy Base Class - Ruby\nDESCRIPTION: Creates a base 'ApplicationPolicy' class inheriting from 'ActionPolicy::Base'. This class serves as a parent for all custom resource-specific policies, centralizing shared configurations or methods. Requires the Action Policy gem and is typically placed in 'app/policies' within a Rails project for organizational purposes.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/quick_start.md#_snippet_3\n\nLANGUAGE: ruby\nCODE:\n```\nclass ApplicationPolicy < ActionPolicy::Base\nend\n```\n\n----------------------------------------\n\nTITLE: Accessing Policy Class Identifiers in Ruby\nDESCRIPTION: Demonstrates how each policy class has an `identifier` method returning its underscored class name, useful for tracking or internationalization purposes. Shows how to override the default identifier for custom naming, including namespaced policies.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/writing_policies.md#_snippet_5\n\nLANGUAGE: Ruby\nCODE:\n```\nclass CommentPolicy < ApplicationPolicy\nend\n\nCommentPolicy.identifier #=> :comment\n\nmodule ActiveAdmin\n  class UserPolicy < ApplicationPolicy\n  end\nend\n\nActiveAdmin::UserPolicy.identifier # => :\"active_admin/user\"\n\nmodule MyVeryLong\n  class LongLongNamePolicy < ApplicationPolicy\n    self.identifier = :long_name\n  end\nend\n\nMyVeryLong::LongLongNamePolicy.identifier #=> :long_name\n```\n\n----------------------------------------\n\nTITLE: Using Action Controller parameters scoping with Action Policy\nDESCRIPTION: Example of implementing and using params filters in Action Policy to control strong parameters based on user permissions, demonstrating both default and named parameter filters.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/scoping.md#_snippet_11\n\nLANGUAGE: ruby\nCODE:\n```\nclass UserPolicy < ApplicationPolicy\n  # Equals to `scope_for :action_controller_params do ...`\n  params_filter do |params|\n    if user.admin?\n      params.permit(:name, :email, :role)\n    else\n      params.permit(:name)\n    end\n  end\n\n  params_filter(:update) do |params|\n    params.permit(:name)\n  end\nend\n\nclass UsersController < ApplicationController\n  def create\n    # Call `authorized_scope` on `params` object\n    @user = User.create!(authorized_scope(params.require(:user)))\n    # Or you can use `authorized` alias which fits this case better\n    @user = User.create!(authorized(params.require(:user)))\n    head :ok\n  end\n\n  def update\n    @user.update!(authorized_scope(params.require(:user), as: :update))\n    head :ok\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing basic scoping in a Rails controller without Action Policy\nDESCRIPTION: A simple example of manually implementing data scoping in a Rails controller without using Action Policy, showing how posts are filtered based on user permissions.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/scoping.md#_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nclass PostsController < ApplicationController\n  def index\n    @posts =\n      if current_user.admin?\n        Post.all\n      else\n        Post.where(user: current_user)\n      end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Using custom RSpec matcher be_an_alias_of to test authorization rule aliases in Ruby\nDESCRIPTION: This snippet shows how to test that one authorization rule is an alias of another using a custom RSpec matcher `be_an_alias_of`. It requires adding `require \"action_policy/rspec\"` in the RSpec helper files. The test checks if the :show? rule is effectively an alias for the :index? rule. Inputs include the policy instance and the rules to compare; output is a boolean expectation result.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/testing.md#_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nrequire \"action_policy/rspec\"\n\ndescribe PostPolicy do\n  let(:user) { build_stubbed(:user) }\n  let(:post) { build_stubbed(:post) }\n\n  let(:policy) { described_class.new(post, user: user) }\n\n  describe \"#show?\" do\n    it \"is an alias of :index? authorization rule\" do\n      expect(:show?).to be_an_alias_of(policy, :index?)\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Testing authorized scope with additional target assertions in Minitest using Action Policy in Ruby\nDESCRIPTION: Extending the previous example, this snippet demonstrates using `.with_target` chained after `assert_have_authorized_scope` to further validate the scope target object passed to the `authorized` call. This allows verifying that the scope is applied to the expected dataset or relation. Requires the test block to yield the target for assertions. Inputs include the scoped target; output is a test confirming correct scope application and target identity.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/testing.md#_snippet_9\n\nLANGUAGE: ruby\nCODE:\n```\ntest \"index has authorized scope\" do\n  sign_in users(:john)\n\n  assert_have_authorized_scope(type: :active_record_relation, with: UserPolicy) do\n    get :index\n  end.with_target do |target|\n    assert_equal User.all, target\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Testing Rails Views with Action Policy and Stubbed User in RSpec (Ruby)\nDESCRIPTION: Provides an RSpec view spec example demonstrating how to test views that use Action Policy helpers like `allowed_to?`. It involves stubbing the `current_user` method on the controller to provide the necessary authorization context, preventing `Missing policy authorization context` errors.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/testing.md#_snippet_15\n\nLANGUAGE: ruby\nCODE:\n```\ndescribe \"users/index.html.slim\" do\n  let(:user) { build_stubbed :user }\n  let(:users) { create_list(:user, 2) }\n\n  before do\n    allow(controller).to receive(:current_user).and_return(user)\n\n    assign :users, users\n    render\n  end\n\n  describe \"displays user#index correctly\" do\n    it { expect(rendered).to have_link(users.first.email, href: edit_user_path(users.first)) }\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Setting up Action Policy Instrumentation in Non-Rails Applications\nDESCRIPTION: Code for enabling instrumentation events in non-Rails applications that have ActiveSupport::Notifications available. It shows how to extend the base policy class and authorizer with Rails instrumentation modules.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/instrumentation.md#_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\n# Enable `apply_rule` event by extending the base policy class\nrequire \"action_policy/rails/policy/instrumentation\"\nActionPolicy::Base.include ActionPolicy::Policy::Rails::Instrumentation\n\n# Enabled `authorize` event by extending the authorizer class\nrequire \"action_policy/rails/authorizer\"\nActionPolicy::Authorizer.singleton_class.prepend ActionPolicy::Rails::Authorizer\n```\n\n----------------------------------------\n\nTITLE: Implementing scope inheritance and chaining with super in Ruby\nDESCRIPTION: Example demonstrating how scope inheritance works in Action Policy, where a child policy can use super to call and extend the parent's scope implementation.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/scoping.md#_snippet_5\n\nLANGUAGE: ruby\nCODE:\n```\nclass ApplicationPolicy < ActionPolicy::Base\n  authorize :user, :account\n\n  scope_for :relation do |relation|\n    relation.where(account_id: account.id)\n  end\nend\n\nclass PostPolicy < ApplicationPolicy\n  scope_for :relation do |relation|\n    super(relation).published\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Defining a Minimal Application Policy with ActionPolicy Core in Ruby\nDESCRIPTION: This minimal Ruby class defines an 'ApplicationPolicy' by including only the 'ActionPolicy::Policy::Core' module, which provides essential methods like 'apply' and 'allowed_to?'. It serves as a basic template for users who prefer to build their policies from scratch without inheriting the standard defaults provided by 'ActionPolicy::Base'. This setup requires no additional dependencies beyond the core module and is suitable for custom or lightweight policy implementations.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/custom_policy.md#_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\n# minimal ApplicationPolicy\nclass ApplicationPolicy\n  include ActionPolicy::Policy::Core\nend\n```\n\n----------------------------------------\n\nTITLE: Customizing Policy Lookup in Ruby\nDESCRIPTION: This snippet showcases how to customize policy lookup for authorization methods. It demonstrates the use of options like `with`, `namespace`, `strict_namespace`, and `default` to control the policy class used for authorization.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/behaviour.md#_snippet_4\n\nLANGUAGE: ruby\nCODE:\n```\nallowed_to?(:edit?, post, with: SpecialPostPolicy)\n```\n\n----------------------------------------\n\nTITLE: Adding a Controller Hook to Verify Authorization\nDESCRIPTION: This snippet demonstrates how to add a controller hook using `verify_authorized` to ensure that `authorize!` has been called in an action. This hook is an `after_action` callback that verifies authorization. The example also shows how to pass options like `except: :index` to exclude certain actions. This mechanism helps enforce authorization checks across all actions of the controller.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/rails.md#_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\nclass ApplicationController < ActionController::Base\n  # adds an after_action callback to verify\n  # that `authorize!` has been called.\n  verify_authorized\n\n  # you can also pass additional options,\n  # like with a usual callback\n  verify_authorized except: :index\nend\n```\n\n----------------------------------------\n\nTITLE: Replacing Pundit RSpec helpers with Action Policy's Pundit-compatible testing syntax\nDESCRIPTION: Demonstrates how to replace Pundit's RSpec testing helpers with Action Policy's Pundit-compatible syntax by changing the required file in test setup.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/pundit_migration.md#_snippet_3\n\nLANGUAGE: ruby\nCODE:\n```\n# Remove DSL\n# require \"pundit/rspec\"\n#\n# Add Action Policy Pundit DSL\nrequire \"action_policy/rspec/pundit_syntax\"\n```\n\n----------------------------------------\n\nTITLE: Testing authorized scope application in Minitest with Action Policy in Ruby\nDESCRIPTION: This snippet shows how to test that an authorized scope is applied during a controller action in Minitest using `assert_have_authorized_scope` from Action Policy test helpers. The test ensures the specified scope type and policy class are used when calling the action. Additionally, it supports chaining `.with_target` to make assertions about the scoped target object. Inputs include request execution within the block; outputs are assertions on scope usage.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/testing.md#_snippet_8\n\nLANGUAGE: ruby\nCODE:\n```\nrequire \"action_policy/test_helper\"\n\nclass UsersControllerTest < ActionDispatch::IntegrationTest\n  include ActionPolicy::TestHelper\n\n  test \"index has authorized scope\" do\n    sign_in users(:john)\n\n    assert_have_authorized_scope(type: :active_record_relation, with: UserPolicy) do\n      get :index\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Nested Module Namespace Policy Lookup in Ruby with Action Policy\nDESCRIPTION: Shows how Action Policy handles nested module namespaces by traversing up the module hierarchy to find an appropriate policy.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/namespaces.md#_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nmodule Admin\n  module Client\n    class UsersController < ApplicationController\n      def index\n        # lookup for Admin::Client::UserPolicy -> Admin::UserPolicy -> UserPolicy\n        authorize!\n      end\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Initializing Policy Objects with Target Record and Context in Ruby\nDESCRIPTION: Demonstrates how to instantiate a policy by passing the target record and context (like user) to the constructor, enabling rule methods to evaluate permissions dynamically. Usage of `policy.update?` is shown for simple checks, with `apply(:update?)` allowing wrapped execution with additional functionalities.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/writing_policies.md#_snippet_1\n\nLANGUAGE: Ruby\nCODE:\n```\npolicy = PostPolicy.new(post, user: user)\n\n# simply call rule method\npolicy.update?\n\n# Omitting record defaults to nil\npolicy = PostPolicy.new(nil, user: user)\n\n# Using apply method for additional features\npolicy.apply(:update?)\n```\n\n----------------------------------------\n\nTITLE: Enhancing policy_for for Draper Integration (Ruby)\nDESCRIPTION: This Ruby code snippet enhances the `policy_for` method within the ActionPolicy module to correctly handle Draper decorators. It recursively unwraps the decorator using `record.model` until it reaches the underlying model.  This modification ensures that the authorization mechanism of ActionPolicy can correctly identify the target record's class, even when the record is wrapped by a Draper decorator. This implementation relies on the Draper gem. The output is the unwrapped record.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/decorators.md#_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nmodule ActionPolicy\n  module Draper\n    def policy_for(record:, **opts)\n      # From https://github.com/GoodMeasuresLLC/draper-cancancan/blob/master/lib/draper/cancancan.rb\n      record = record.model while record.is_a?(::Draper::Decorator)\n      super\n    end\n  end\nend\n\nclass ApplicationController < ActionController::Base\n  prepend ActionPolicy::Draper\nend\n```\n\n----------------------------------------\n\nTITLE: Using a callable object for scoping logic in Action Policy\nDESCRIPTION: Example of encapsulating scoping logic in a separate callable class that can be referenced from the policy, demonstrating a more modular approach to scoping.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/scoping.md#_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\nclass PostsController < ApplicationController\n  def index\n    @posts = authorized_scope(Post.all)\n  end\nend\n\nclass PostPolicy < ApplicationPolicy\n  relation_scope AuthorizedPosts\nend\n\nclass AuthorizedPosts\n  class << self\n    def call(policy, relation, **_scope_options)\n      user = policy.user\n      user.admin? ? relation : relation.where(user: user)\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Overriding Authorization Context Explicitly during Authorization Calls - Ruby\nDESCRIPTION: Shows how to explicitly override or add keys to the implicit authorization context when calling authorization methods such as `authorize!`. The explicitly provided context hash is merged with the implicit one, allowing selective context replacement or extension during policy checks.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/authorization_context.md#_snippet_3\n\nLANGUAGE: ruby\nCODE:\n```\ndef show\n  user = User.find(params[:id])\n\n  authorize! user, context: {account: user.account}\nend\n```\n\n----------------------------------------\n\nTITLE: Handling Unauthorized Exception and Accessing Details\nDESCRIPTION: Demonstrates handling the `ActionPolicy::Unauthorized` exception, typically in a controller or application-wide handler. The example shows how to access the `details` from the `reasons` associated with the `ExecutionResult` (`ex.result.reasons.details`) to get structured information about why authorization failed.\nSOURCE: https://github.com/palkan/action_policy/blob/master/CHANGELOG.md#_snippet_9\n\nLANGUAGE: Ruby\nCODE:\n```\nrescue_from ActionPolicy::Unauthorized do |ex|\n  ex.result.reasons.details #=> { stage: [:show?] }\nend\n```\n\n----------------------------------------\n\nTITLE: Nested Policies Sharing Authorization Contexts in Action Policy - Ruby\nDESCRIPTION: Demonstrates challenges when nested policies have different authorization contexts, causing errors due to missing context keys. The sample shows nested policies where UserPolicy calls ProfilePolicy, but ProfilePolicy requires additional context keys not present in UserPolicy's current context. Highlights the requirement for shared or superset authorization contexts among policies to function together correctly.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/authorization_context.md#_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\nclass UserPolicy < ActionPolicy::Base\n  authorize :user\n\n  def show?\n    allowed_to?(:show?, record.profile)\n  end\nend\n\nclass ProfilePolicy < ActionPolicy::Base\n  authorize :user, :account\nend\n\nclass ApplicationController < ActionController::Base\n  authorize :user, through: :current_user\n  authorize :account, through: :current_account\nend\n\nclass UsersController < ApplicationController\n  def show\n    user = User.find(params[:id])\n\n    authorize! user #=> raises \"Missing policy authorization context: account\"\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Testing Action Controller params scope with RSpec in Ruby\nDESCRIPTION: This example shows how to test parameter scoping in controller contexts using Action Policy. It wraps parameters in ActionController::Parameters and checks that the applied scope returns a filtered parameter hash depending on the user role. Inputs include user context and parameters hash; the output is a filtered set of parameters allowed by the policy scope.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/testing.md#_snippet_4\n\nLANGUAGE: ruby\nCODE:\n```\ndescribe PostPolicy do\n  describe \"params scope\" do\n    let(:user) { build_stubbed :user }\n    let(:context) { {user: user} }\n\n    let(:params) { {name: \"a\", password: \"b\"} }\n    let(:target) { ActionController::Parameters.new(params) }\n\n    subject { policy.apply_scope(target, type: :action_controller_params).to_h }\n\n    context \"as user\" do\n      it { is_expected.to eq({name: \"a\"}) }\n    end\n\n    context \"as manager\" do\n      before { user.update!(role: :manager) }\n\n      it { is_expected.to eq({name: \"a\", password: \"b\"}) }\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Using all_details Helper for Simplified Access to Details\nDESCRIPTION: Shows how to use the all_details helper method to easily access all failure details merged into a single hash.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/reasons.md#_snippet_7\n\nLANGUAGE: ruby\nCODE:\n```\nclass PostPolicy < ApplicationPolicy\n  def edit?\n    check?(:published?)\n  end\n\n  def published?\n    details[:not_found] = true\n    record.published?\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Namespace Handling for Namespaced Resources in Ruby with Action Policy\nDESCRIPTION: Demonstrates how Action Policy handles namespaced resources by default, using the full namespaced class name for policy lookup.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/namespaces.md#_snippet_3\n\nLANGUAGE: ruby\nCODE:\n```\nclass Admin\n  class User\n  end\nend\n\n# search for Admin::UserPolicy, but not for UserPolicy\nauthorize! Admin::User.new\n```\n\n----------------------------------------\n\nTITLE: Inferring Resource Class for Authorization in Controller\nDESCRIPTION: This snippet demonstrates how Action Policy can infer the resource class from the controller name when calling `authorize!` without a resource specified. The example shows an `index` action within `PostsController` where `authorize!` is called without an explicit resource.  Action Policy uses `controller_name.classify.safe_constantize` to find the associated resource.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/rails.md#_snippet_4\n\nLANGUAGE: ruby\nCODE:\n```\nclass PostsController < ApplicationController\n  def index\n    # Uses Post class as a resource implicitly.\n    # NOTE: it just calls `controller_name.classify.safe_constantize`,\n    # you can override this by defining `implicit_authorization_target` method.\n    authorize!\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Using allowed_to? Method in Ruby\nDESCRIPTION: This snippet demonstrates the usage of `allowed_to?` method, which is a predicate version of `authorize!`. It returns `true` if authorization succeeds and `false` otherwise. This method is used to check authorization before proceeding with an action.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/behaviour.md#_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\n# the first argument is the rule to apply\n# the second one is the target\nif allowed_to?(:edit?, post)\n  # ...\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring I18n for Non-Rails Projects\nDESCRIPTION: This snippet shows how to manually configure the `i18n` gem in a non-Rails project to load translation files, which is necessary for ActionPolicy to use localized messages. It appends the locale directory to the `I18n.load_path`.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/i18n.md#_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nI18n.load_path << Dir[File.expand_path(\"config/locales\") + \"/*.yml\"]\n```\n\n----------------------------------------\n\nTITLE: Generating Application Policy with Rails Generator - Shell\nDESCRIPTION: Uses the Rails generator to scaffold an ApplicationPolicy base class for the project. This command sets up the folder structure and base class required for Action Policy integration. Requires Rails and the action_policy gem to be present.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/quick_start.md#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\nrails generate action_policy:install\n```\n\n----------------------------------------\n\nTITLE: Authorizing Mutations with `authorize!`\nDESCRIPTION: Shows how to enforce authorization within mutation resolve methods using `authorize!` to check permissions before performing actions like deleting a user. It highlights that mutations are treated as behaviors and the core approach is calling `authorize!` with the target object and action.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/graphql.md#_snippet_5\n\nLANGUAGE: Ruby\nCODE:\n```\nclass Mutations::DestroyUser < Types::BaseMutation\n  argument :id, ID, required: true\n\ndef resolve(id:)\n  user = User.find(id)\n\n  # Raise an exception if the user has not enough permissions\n  authorize! user, to: :destroy?\n\n  user.destroy!\n\n  {deleted_id: user.id}\nend\nend\n```\n\n----------------------------------------\n\nTITLE: Skipping Authorization Verification in Controller\nDESCRIPTION: This snippet shows how to skip the `verify_authorized` hook for specific actions or dynamically within an action. `skip_verify_authorized only: :show` skips the verification for the `show` action. Additionally, `skip_verify_authorized! if some_condition` allows conditional skipping based on the given condition. This provides control to bypass authorization checks where necessary.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/rails.md#_snippet_3\n\nLANGUAGE: ruby\nCODE:\n```\nclass PostsController < ApplicationController\n  skip_verify_authorized only: :show\n\n  def index\n    # or dynamically within an action\n    skip_verify_authorized! if some_condition\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Handling Unauthorized Access with i18n Messages in Rails\nDESCRIPTION: This snippet demonstrates how to rescue from `ActionPolicy::Unauthorized` exceptions in a Rails controller and access the localized error message and full reasons provided by ActionPolicy, leveraging the i18n integration.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/i18n.md#_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nclass ApplicationController < ActionController::Base\n  rescue_from ActionPolicy::Unauthorized do |ex|\n    p ex.result.message #=> \"You do not have access to the stage\"\n    p ex.result.reasons.full_messages #=> [\"You do not have access to the stage\"]\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Defining Rule Aliases in ActionPolicy Policies with Ruby\nDESCRIPTION: This Ruby snippet shows how to define alias rules inside an ActionPolicy policy class. The alias_rule method maps multiple rule names (edit?, destroy?) to a single underlying rule (update?). This technique avoids duplication of rule logic and enables cache-friendly, testable authorization behavior. Dependencies include inheriting from ActionPolicy::Base or including ActionPolicy::Policy::Aliases. Rules must be public methods and suffix with a question mark. Inputs are calls to alias_rule, and outputs modify how authorization resolves rules at runtime.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/aliases.md#_snippet_1\n\nLANGUAGE: Ruby\nCODE:\n```\nclass PostPolicy < ApplicationPolicy\n  alias_rule :edit?, :destroy?, to: :update?\nend\n```\n\n----------------------------------------\n\nTITLE: Using `allowed_to?` Helper in Rails View (ERB)\nDESCRIPTION: Illustrates using the `allowed_to?` helper multiple times within an ERB view to check different permissions (`:edit?`, `:destroy?`) for the same `@post` record. This scenario benefits from Action Policy's per-instance policy memoization, avoiding redundant policy object creation and rule execution within the same request.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/caching.md#_snippet_1\n\nLANGUAGE: erb\nCODE:\n```\n# app/views/posts/show.html.erb\n<h1><%= @post.title %>\n\n<% if allowed_to?(:edit?, @post) %>\n  <%= link_to \"Edit\", @post %>\n<% end %>\n\n<% if allowed_to?(:destroy?, @post) %>\n  <%= link_to \"Delete\", @post, method: :delete %>\n<% end %>\n```\n\n----------------------------------------\n\nTITLE: Basic Policy Rules Without Pre-Checks in Ruby\nDESCRIPTION: A typical policy implementation with duplicated super admin checks in each rule. This example demonstrates the common pattern that pre-checks aim to improve.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/pre_checks.md#_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nclass PostPolicy < ApplicationPolicy\n  def show?\n    user.super_admin? || record.published\n  end\n\n  def update?\n    user.super_admin? || (user.id == record.user_id)\n  end\n\n  # more rules\nend\n```\n\n----------------------------------------\n\nTITLE: Declaring Authorization Context Keys in Action Policy Base Class - Ruby\nDESCRIPTION: Defines authorization context keys in a policy by declaring them using the `authorize` method inside the policy class. Required context keys must be supplied during policy initialization, else an error is raised. Supports options such as `allow_nil` to accept nil values and `optional` to allow omitting keys.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/authorization_context.md#_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nclass ApplicationPolicy < ActionPolicy::Base\n  authorize :account\nend\n```\n\nLANGUAGE: ruby\nCODE:\n```\nclass GuestPolicy < ApplicationPolicy\n  # Allow nil for the user key but key presence still required\n  authorize :user, allow_nil: true\nend\n\nclass ProjectPolicy < ApplicationPolicy\n  # Allow to omit the `team` key entirely\n  authorize :team, optional: true\nend\n\nGuestPolicy.new(user: nil) #=> OK\nGuestPolicy.new #=> raises ActionPolicy::AuthorizationContextMissing\n\nProjectPolicy.new(user: user) #=> OK\n```\n\n----------------------------------------\n\nTITLE: Installing Gems with Bundler - Shell\nDESCRIPTION: Runs Bundler to install all gems listed in the application's Gemfile, including Action Policy. This step ensures that all dependencies are resolved and installed in the application's environment.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/quick_start.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nbundle install\n```\n\n----------------------------------------\n\nTITLE: Configuring Authorization Contexts in Rails Controllers using Action Policy - Ruby\nDESCRIPTION: Configures authorization context keys and their sources in a Rails controller using the `authorize` class method. The first argument matches the authorization key declared in policies, and `through:` specifies how to fetch the context at runtime, either via a method name or a proc. This enables automatic context provision in `authorize!` and `allowed_to?` calls.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/authorization_context.md#_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nclass ApplicationController < ActionController::Base\n  # Provide :account via current_account method\n  authorize :account, through: :current_account\n\n  # Provide :user context via proc returning Current.user\n  authorize :user, through: -> { Current.user }\nend\n```\n\n----------------------------------------\n\nTITLE: Including Action Policy Behaviour in GraphQL Types and Mutations\nDESCRIPTION: Adds the ActionPolicy::GraphQL::Behaviour module to base GraphQL types, mutations, and resolvers to enable authorization features such as field protection, preauthorization, and rules exposure. These inclusions are essential for integrating authorization logic into the GraphQL schema.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/graphql.md#_snippet_0\n\nLANGUAGE: Ruby\nCODE:\n```\n# For fields authorization, lists scoping and rules exposing\nclass Types::BaseObject < GraphQL::Schema::Object\n  include ActionPolicy::GraphQL::Behaviour\nend\n```\n\nLANGUAGE: Ruby\nCODE:\n```\nclass Types::BaseMutation < GraphQL::Schema::Mutation\n  include ActionPolicy::GraphQL::Behaviour\nend\n```\n\nLANGUAGE: Ruby\nCODE:\n```\nclass Types::BaseResolver < GraphQL::Schema::Resolver\n  include ActionPolicy::GraphQL::Behaviour\nend\n```\n\n----------------------------------------\n\nTITLE: Using allowance_to Method in Ruby\nDESCRIPTION: This snippet illustrates the usage of `allowance_to` method. This method returns an authorization result, providing more information than `allowed_to?`. It is useful for APIs where you need to return reasons for failure in JSON format.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/behaviour.md#_snippet_3\n\nLANGUAGE: ruby\nCODE:\n```\nresult = allowance_to(:edit?, post)\n\n{value: result.value, fullMessages: result.reasons.full_messages, details: result.reasons.details}.to_json\n```\n\n----------------------------------------\n\nTITLE: Authorizing Action in Rails Controller using authorize!\nDESCRIPTION: Uses the `authorize!` helper in a Rails controller to check authorization before executing an action. It specifies the rule `:admin` to be checked against a target implicitly determined by the controller's name (`AdminPolicy`), explicitly specifying the rule alias `:update_settings`.\nSOURCE: https://github.com/palkan/action_policy/blob/master/CHANGELOG.md#_snippet_2\n\nLANGUAGE: Ruby\nCODE:\n```\nclass AdminController < ApplicationController\n  authorize! :admin, to: :update_settings\nend\n```\n\n----------------------------------------\n\nTITLE: Applying Policy Scope to Relation using authorized\nDESCRIPTION: Applies the relevant policy scope to a relation (`User.all`) using the `authorized` helper method within a controller action. This method finds the policy for the relation's model (`UserPolicy`) and invokes its `relation_scope` (if defined) to filter the data according to the current user's permissions.\nSOURCE: https://github.com/palkan/action_policy/blob/master/CHANGELOG.md#_snippet_3\n\nLANGUAGE: Ruby\nCODE:\n```\nclass UsersController < ApplicationController\n  def index\n    @user = authorized(User.all)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Overriding the Default Lookup Chain in Ruby\nDESCRIPTION: Shows how to completely replace Action Policy's lookup chain with a custom implementation. The example demonstrates a simple lambda structure that accepts a record and options parameters for custom lookup logic.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/custom_lookup_chain.md#_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nActionPolicy::LookupChain.chain = [\n  # Probe accepts record as the first argument\n  # and arbitrary options (passed to `authorize!` / `allowed_to?` call)\n  lambda do |record, **options|\n    # your custom lookup logic\n  end\n]\n```\n\n----------------------------------------\n\nTITLE: Scoping Collection using authorized in Rails Controller\nDESCRIPTION: Applies the policy scope for `Post` objects to the `Post.all` collection using the `authorized` helper in a controller action. This filters the collection based on the rules defined in the `PostPolicy`.\nSOURCE: https://github.com/palkan/action_policy/blob/master/CHANGELOG.md#_snippet_5\n\nLANGUAGE: Ruby\nCODE:\n```\nclass PostsController < ApplicationController\n  def index\n    @posts = authorized(Post.all)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Active Record scopes in Action Policy\nDESCRIPTION: Examples of implementing Active Record relation scopes using the relation_scope macro, including both default and named scopes for different filtering scenarios.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/scoping.md#_snippet_10\n\nLANGUAGE: ruby\nCODE:\n```\nclass PostPolicy < ApplicationPolicy\n  # Equals `scope_for :active_record_relation do ...`\n  relation_scope do |scope|\n    if super_user? || admin?\n      scope\n    else\n      scope.joins(:accesses).where(accesses: {user_id: user.id})\n    end\n  end\n\n  # define named scope\n  relation_scope(:own) do |scope|\n    next scope.none if user.guest?\n    scope.where(user: user)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Explicit Policy and Rule Specification - Ruby\nDESCRIPTION: Demonstrates how to override Action Policy's automatic inference by explicitly specifying the authorization rule or policy class. The code shows the usage of the 'authorize!' and 'allowed_to?' methods with custom rule and policy class arguments. This is essential when deviating from naming conventions or introducing complex authorization logic.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/quick_start.md#_snippet_9\n\nLANGUAGE: ruby\nCODE:\n```\n# specify the rule to verify access\nauthorize! @post, to: :update?\n\n# specify policy class\nauthorize! @post, with: CustomPostPolicy\n\n# or\nallowed_to? :edit?, @post, with: CustomPostPolicy\n```\n\n----------------------------------------\n\nTITLE: Including ActionPolicy in API Controller\nDESCRIPTION: This code demonstrates how to manually include Action Policy in a custom Rails controller that doesn't inherit from `ActionController::Base` (e.g., `ActionController::API`).  It also shows how to specify the authorization context explicitly. By manually including `ActionPolicy::Controller` and using `authorize :user, through: :current_user`, the API controller gains the authorization functionalities provided by Action Policy.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/rails.md#_snippet_5\n\nLANGUAGE: ruby\nCODE:\n```\nclass ApiController < ActionController::API\n  include ActionPolicy::Controller\n\n  # NOTE: you have to provide authorization context manually as well\n  authorize :user, through: :current_user\nend\n```\n\n----------------------------------------\n\nTITLE: Accessing Merged Details and Using in Error Handling\nDESCRIPTION: Demonstrates how to access the merged details and use them for conditional error handling logic.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/reasons.md#_snippet_8\n\nLANGUAGE: ruby\nCODE:\n```\np ex.result.all_details #=> {not_found: true}\n\nrescue_from ActionPolicy::Unauthorized do |ex|\n  if ex.result.all_details[:not_found]\n    head :not_found\n  else\n    head :unauthorized\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Authorizing Action Cable Channel Actions\nDESCRIPTION: This snippet demonstrates how to integrate Action Policy with Action Cable to authorize channel actions.  It uses `authorize! chat, to: :show?` within the `follow` method of `ChatChannel` to ensure a user is authorized to perform an action. This protects channel actions by using the authorization policy defined for the `Chat` model. It assumes the presence of a `ChatPolicy` class for authorization.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/rails.md#_snippet_6\n\nLANGUAGE: ruby\nCODE:\n```\nclass ChatChannel < ApplicationCable::Channel\n  def follow(data)\n    chat = Chat.find(data[\"chat_id\"])\n\n    # Verify against ChatPolicy#show? rule\n    authorize! chat, to: :show?\n    stream_from chat\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring Authorization Behavior and Rules\nDESCRIPTION: Shows how to customize the default exception raising behavior and authorization rules globally, including setting the default rule for fields and node types, and overriding the behavior using configuration flags. These settings influence how policies are enforced site-wide.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/graphql.md#_snippet_2\n\nLANGUAGE: Ruby\nCODE:\n```\nActionPolicy::GraphQL.authorize_raise_exception = false\n```\n\nLANGUAGE: Ruby\nCODE:\n```\nActionPolicy::GraphQL.default_authorize_rule = :show_graphql_field?\n```\n\nLANGUAGE: Ruby\nCODE:\n```\nActionPolicy::GraphQL.preauthorize_raise_exception = false\n```\n\nLANGUAGE: Ruby\nCODE:\n```\nActionPolicy::GraphQL.default_preauthorize_list_rule = :index?\nActionPolicy::GraphQL.default_preauthorize_node_rule = :show?\n```\n\n----------------------------------------\n\nTITLE: Using `preauthorize: *` for Pre-Authorization in Fields\nDESCRIPTION: Demonstrates the use of `preauthorize:` options to perform authorization checks before resolving the field value. Typically used for list or singleton types, with configurability for raising exceptions, and passing the field's name as the record for debugging.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/graphql.md#_snippet_3\n\nLANGUAGE: Ruby\nCODE:\n```\nfield :homes, [Home], null: false, preauthorize: {with: HomePolicy}\n\ndef homes\n  Home.all\nend\n```\n\nLANGUAGE: Ruby\nCODE:\n```\n# Equivalent to\nfield :homes, [Home], null: false\n\ndef homes\n  authorize! \"homes\", to: :index?, with: HomePolicy\n  Home.all\nend\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Rule Alias and Default Rule Resolution in ActionPolicy Using Ruby\nDESCRIPTION: This Ruby snippet provides a concrete example of alias_rule and default_rule usages across a superclass and a subclass policy. It shows how aliases defined at subclass level override superclass aliases and how default_rule controls fallback authorization logic, including how nil disables fallback causing exceptions. The example clarifies the rule resolution order for concrete methods, aliases, and defaults. Dependencies require proper inheritance and adherence to public predicate method conventions. Inputs involve authorization calls against various rule names, outputs are the resolved effective rule based on override and fallback hierarchy.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/aliases.md#_snippet_3\n\nLANGUAGE: Ruby\nCODE:\n```\nclass SuperPolicy < ApplicationPolicy\n  alias_rule :update?, :destroy?, :create?, to: :edit?\n\n  def manage?\n  end\n\n  def edit?\n  end\n\n  def index?\n  end\nend\n\nclass SubPolicy < AbstractPolicy\n  default_rule nil\n\n  alias_rule :index?, :update?, to: :manage?\n\n  def create?\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Defining a Complex Policy Rule (Ruby)\nDESCRIPTION: Defines a sample policy rule method `feed?` using a combination of boolean logic (`||`, `&&`) and other predicate methods (`admin?`, `allowed_to?`) or attribute checks (`user.name == ...`). This serves as an example of a rule that might benefit from debugging.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/debugging.md#_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\ndef feed?\n  (admin? || allowed_to?(:access_feed?)) &&\n    (user.name == \"Jack\" || user.name == \"Kate\")\nend\n```\n\n----------------------------------------\n\nTITLE: Adding Detailed Reasons with Context Information\nDESCRIPTION: Demonstrates how to provide additional context details in failure reasons which can be used in error messages.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/reasons.md#_snippet_5\n\nLANGUAGE: ruby\nCODE:\n```\nclass ApplicantPolicy < ApplicationPolicy\n  def show?\n    allowed_to?(:show?, record.stage)\n  end\nend\n\nclass StagePolicy < ApplicationPolicy\n  def show?\n    # Add stage title to the failure reason (if any)\n    # (could be used by client to show more descriptive message)\n    details[:title] = record.title\n\n    # then perform the checks\n    user.stages.where(id: record.id).exists?\n  end\nend\n\n# when accessing the reasons\np ex.result.reasons.to_h #=> { stage: [{show?: {title: \"Onboarding\"}] }\n```\n\n----------------------------------------\n\nTITLE: Authorizing Resource in Rails Controller (Ruby)\nDESCRIPTION: Demonstrates calling `authorize!` within a Rails controller action (`show`). This triggers policy lookup and execution for the `@post` record. Action Policy's per-instance memoization might be used if the same policy is needed again in the view.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/caching.md#_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\n# app/controllers/posts_controller.rb\nclass PostsController < ApplicationController\n  def show\n    @post = Post.find(params[:id])\n    authorize! @post\n    render :show\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Checking Permissions in Loop (ERB)\nDESCRIPTION: An ERB view iterating through a collection of `@comments` and calling `allowed_to?(:edit?, comment)` for each one. Without proper caching (like per-thread memoization), this can lead to N+1 authorization checks.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/caching.md#_snippet_3\n\nLANGUAGE: erb\nCODE:\n```\n# app/views/comments/index.html.erb\n<% @comments.each do |comment| %>\n  <li><%= comment.text %>\n    <% if allowed_to?(:edit?, comment) %>\n      <%= link_to comment, \"Edit\" %>\n    <% end %>\n  </li>\n<% end %>\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Action Policy Behavior in GraphQL Base Object (Ruby)\nDESCRIPTION: This Ruby code snippet demonstrates how to manually configure Action Policy within a GraphQL base object (`Types::BaseObject`). It includes core Action Policy behavior and memoization modules, defines the authorization context using `authorize`, adds a helper method (`current_user`) to access the user from the context, extends the field class with `ActionPolicy::GraphQL::AuthorizedField` for field-level authorization, and includes `ActionPolicy::GraphQL::Fields` for authorization rule exposure. This approach allows developers to tailor the included functionality instead of using the default `ActionPolicy::GraphQL::Behaviour`.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/graphql.md#_snippet_11\n\nLANGUAGE: ruby\nCODE:\n```\nclass Types::BaseObject < GraphQL::Schema::Object\n  # include Action Policy behaviour and its extensions\n  include ActionPolicy::Behaviour\n  include ActionPolicy::Behaviours::ThreadMemoized\n  include ActionPolicy::Behaviours::Memoized\n  include ActionPolicy::Behaviours::Namespaced\n\n  # define authorization context\n  authorize :user, through: :current_user\n\n  # add a method helper to get the current_user from the context\n  def current_user\n    context[:current_user]\n  end\n\n  # extend the field class to add `authorize` and `authorized_scope` options\n  field_class.prepend(ActionPolicy::GraphQL::AuthorizedField)\n\n  # add `expose_authorization_rules` macro\n  include ActionPolicy::GraphQL::Fields\nend\n```\n\n----------------------------------------\n\nTITLE: Skipping Pre-Checks for Specific Rules in Ruby\nDESCRIPTION: Shows how to skip pre-checks for specific rules using the skip_pre_check method with only/except options. This example skips the admin check only for the destroy? rule.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/pre_checks.md#_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\nclass UserPolicy < ApplicationPolicy\n  skip_pre_check :allow_admins, only: :destroy?\n\n  def destroy?\n    user.admin? && !record.admin?\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Defining Policies with Failure Reason Tracking\nDESCRIPTION: Shows how to define a policy that tracks failure reasons when using allowed_to? checks within policy rules.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/reasons.md#_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nclass ApplicantPolicy < ApplicationPolicy\n  def show?\n    user.has_permission?(:view_applicants) &&\n      allowed_to?(:show?, record.stage)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Using Local Rules with allowed_to? for Reasons Tracking\nDESCRIPTION: Shows how to wrap local policy rules with allowed_to? to include them in failure reasons tracking.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/reasons.md#_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\nclass ApplicantPolicy < ApplicationPolicy\n  def show?\n    allowed_to?(:view_applicants?) &&\n      allowed_to?(:show?, record.stage)\n  end\n\n  def view_applicants?\n    user.has_permission?(:view_applicants)\n  end\nend\n\n# then the reasons object could be\np ex.result.reasons.to_h #=> { applicant: [:view_applicants?] }\n\n# or\np ex.result.reasons.to_h #=> { stage: [:show?] }\n```\n\n----------------------------------------\n\nTITLE: Using inline_reasons for Propagating Nested Policy Reasons\nDESCRIPTION: Shows how to propagate reasons from nested policy calls using the inline_reasons option.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/reasons.md#_snippet_4\n\nLANGUAGE: ruby\nCODE:\n```\nclass ApplicantPolicy < ApplicationPolicy\n  def show?\n    allowed_to?(:show?, record.stage, inline_reasons: true)\n  end\nend\n\nclass StagePolicy < ApplicationPolicy\n  def show?\n    deny!(:archived) if record.archived?\n  end\nend\n\n# When applying ApplicationPolicy and the stage is archived\np ex.result.reasons.details #=> { stage: [:archived] }\n# Without inline_reasons we would get { stage: [:show?] } instead\n```\n\n----------------------------------------\n\nTITLE: Configuring Per-Thread Cache (Ruby)\nDESCRIPTION: Shows how to programmatically enable or disable Action Policy's per-thread cache. This cache is useful for memoizing policy instances across multiple checks within a single thread (e.g., a web request) but is often disabled by default in test environments.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/caching.md#_snippet_5\n\nLANGUAGE: ruby\nCODE:\n```\nActionPolicy::PerThreadCache.enabled = true # or false to disable\n```\n\n----------------------------------------\n\nTITLE: Configuring Cache Store in Rails Application (Ruby)\nDESCRIPTION: Illustrates the Rails-specific way to configure the Action Policy cache store within `config/application.rb` or environment files. It often leverages Rails' built-in cache stores like `:redis_cache_store`.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/caching.md#_snippet_8\n\nLANGUAGE: ruby\nCODE:\n```\n# config/application.rb (or config/environments/<environment>.rb)\nRails.application.configure do |config|\n  config.action_policy.cache_store = :redis_cache_store\nend\n```\n\n----------------------------------------\n\nTITLE: Marking Policy Rule for Cache Store (Ruby)\nDESCRIPTION: Demonstrates how to mark a specific policy rule (`show?`) for long-term caching using an external cache store. The `cache` class method is used, optionally accepting store-specific options like `expires_in`. This is useful for performance-heavy rules.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/caching.md#_snippet_6\n\nLANGUAGE: ruby\nCODE:\n```\nclass StagePolicy < ApplicationPolicy\n  # mark show? rule to be cached\n  cache :show?\n  # you can also provide store-specific options\n  # cache :show?, expires_in: 1.hour\n\n  def show?\n    full_access? ||\n      user.stage_permissions.where(\n        stage_id: record.id\n      ).exists?\n  end\n\n  private\n\n  def full_access?\n    !record.funnel.is_private? ||\n      user.permissions\n        .where(\n          funnel_id: record.funnel_id,\n          full_access: true\n        ).exists?\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Define a default policy in Ruby\nDESCRIPTION: This code snippet provides an example on how to define a default policy to use in case lookup finds nothing.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/behaviour.md#_snippet_7\n\nLANGUAGE: ruby\nCODE:\n```\n# either explicitly\nauthorize! post, to: :destroy?, default: GuestPolicy\n```\n\n----------------------------------------\n\nTITLE: Using pp in Pry to Inspect Rule Evaluation (Ruby)\nDESCRIPTION: Demonstrates how to call the `pp` method within a `pry` debugging session on the policy instance (`self` inside the method). It shows the command `pp :feed?` and its corresponding output, which visually breaks down the rule's logical structure and shows the boolean result of each sub-expression or predicate call. It also shows inspecting a simpler rule.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/debugging.md#_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\npry> pp :feed?\n```\n\nLANGUAGE: ruby\nCODE:\n```\npry> pp :admin?\n```\n\n----------------------------------------\n\nTITLE: Authorizing Controller Actions Using ActionPolicy in Ruby\nDESCRIPTION: This Ruby snippet demonstrates how to perform authorization in a Rails controller by loading a resource and calling the authorize! method on it, which automatically selects the appropriate policy rule based on the controller action name. It requires ActionPolicy gem integration and relies on implicit rule naming conventions ending with a question mark (e.g., edit?). Inputs include controller params for resource identification, and outputs determine access permission through exceptions or returns. It highlights usage within a before_action filter to enforce authorization consistently across multiple actions.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/aliases.md#_snippet_0\n\nLANGUAGE: Ruby\nCODE:\n```\nclass PostsController < ApplicationController\n  before_action :load_post, only: [:edit, :update, :destroy]\n\n  private\n\n  def load_post\n    @post = Post.find(params[:id])\n    # depending on action, an `edit?`, `update?` or `destroy?`\n    # rule would be applied\n    authorize! @post\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring Ignored Debugger Expressions (Ruby)\nDESCRIPTION: Shows how to modify the `ActionPolicy::PrettyPrint.ignore_expressions` array to add custom regular expressions. Any expression matching these patterns will be skipped during pretty-printing to avoid interference with debugger setups other than the default `binding.pry`/`binding.irb`.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/debugging.md#_snippet_3\n\nLANGUAGE: ruby\nCODE:\n```\nActionPolicy::PrettyPrint.ignore_expressions << /\\bdebug\\b/\n```\n\n----------------------------------------\n\nTITLE: Defining Custom `policy_cache_key` on Models (Ruby)\nDESCRIPTION: Shows how to define custom `#policy_cache_key` methods on models (User, Resource). This allows for creating cache keys that are more efficient or automatically change when relevant data (like `role_id` or `access_updated_at`) is updated, aiding implicit cache invalidation.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/caching.md#_snippet_11\n\nLANGUAGE: ruby\nCODE:\n```\nclass User\n  def policy_cache_key\n    \"user::#{id}::#{role_id}\"\n  end\nend\n\nclass Resource\n  def policy_cache_key\n    \"#{resource.class.name}::#{id}::#{access_updated_at}\"\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Disabling Action Policy Instrumentation in Rails\nDESCRIPTION: Configuration snippet to turn off Action Policy instrumentation in a Rails application. This must be set during application initialization to take effect.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/instrumentation.md#_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nconfig.action_policy.instrumentation_enabled = false\n```\n\n----------------------------------------\n\nTITLE: Setting a Default Authorization Rule in an ActionPolicy Policy Using Ruby\nDESCRIPTION: This Ruby snippet illustrates how to configure a fallback or default rule in an ActionPolicy policy class with the default_rule method. The specified default rule (manage?) is applied during authorization if no other explicit or aliased rules match the requested permission. This allows handling of wildcard or catch-all authorization logic. The example also comments on aliasing other rules to the default to broaden managescope. Dependencies include inheriting from ActionPolicy::Base, and rules must be public predicate methods. Inputs are authorization requests with missing rules; outputs are decisions from the default fallback rule.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/aliases.md#_snippet_2\n\nLANGUAGE: Ruby\nCODE:\n```\nclass PostPolicy < ApplicationPolicy\n  # For an ApplicationPolicy, makes :manage? match anything that is\n  # not :index?, :create? or :new?\n  default_rule :manage?\n\n  # If you want manage? to catch really everything, place this alias\n  #alias_rule :index?, :create?, :new?, to: :manage?\n  def manage?\n    # ...\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Overriding Cache Namespace for Invalidation (Ruby)\nDESCRIPTION: Illustrates a simple cache invalidation strategy by overriding the `cache_namespace` method in the base `ApplicationPolicy`. Changing the `CACHE_VERSION` constant effectively invalidates all previously cached items across the application.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/caching.md#_snippet_12\n\nLANGUAGE: ruby\nCODE:\n```\nclass ApplicationPolicy < ActionPolicy::Base\n  # It's a good idea to store the changing part in the constant\n  CACHE_VERSION = \"v2\".freeze\n\n  # or even from the env variable\n  # CACHE_VERSION = ENV.fetch(\"POLICY_CACHE_VERSION\", \"v2\").freeze\n\n  def cache_namespace\n    \"action_policy::#{CACHE_VERSION}\"\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Accessing Failure Reasons in Exception Handling\nDESCRIPTION: Demonstrates how to access failure reasons when rescuing from ActionPolicy::Unauthorized exceptions, including internationalization support.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/reasons.md#_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nclass ApplicationController < ActionController::Base\n  rescue_from ActionPolicy::Unauthorized do |ex|\n    p ex.result.reasons.to_h #=> { stage: [:show?] }\n\n    # or with i18n support\n    p ex.result.reasons.full_messages #=> [\"You do not have access to the stage\"]\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Simplified policy specs with Action Policy RSpec DSL in Ruby\nDESCRIPTION: This example introduces a custom RSpec DSL provided by Action Policy that reduces boilerplate in policy testing. It requires `require \"action_policy/rspec/dsl\"` in spec helpers. Using `describe_rule`, `succeed`, and `failed` blocks, it expressively defines expected outcomes for rules such as :show? under varying contexts like draft state and user roles. Inputs are the authorization target, context, and rule execution; outputs are test assertions on rule results.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/testing.md#_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\n# Add this to your spec_helper.rb / rails_helper.rb\nrequire \"action_policy/rspec/dsl\"\n\ndescribe PostPolicy do\n  let(:user) { build_stubbed :user }\n  let(:record) { build_stubbed :post, draft: false }\n\n  let(:context) { {user: user} }\n\n  describe_rule :show? do\n    succeed \"when post is published\"\n\n    failed \"when post is draft\" do\n      before { post.draft = false }\n\n      succeed \"when user is a manager\" do\n        before { user.role = \"manager\" }\n      end\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Manual Cache Invalidation Using Callbacks (Ruby)\nDESCRIPTION: Demonstrates a manual cache invalidation approach using ActiveRecord callbacks (`after_commit`). It involves defining a custom `cache_key` structure in the policy and then using callbacks on related models (Access, User) to explicitly delete matching cache entries from the store using `delete_matched` when relevant data changes.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/caching.md#_snippet_13\n\nLANGUAGE: ruby\nCODE:\n```\nclass ApplicationPolicy < ActionPolicy::Base\n  # Define custom cache key generator\n  def cache_key(rule)\n    \"policy_cache/#{user.id}/#{self.class.name}/#{record.id}/#{rule}\"\n  end\nend\n```\n\nLANGUAGE: ruby\nCODE:\n```\nclass Access < ApplicationRecord\n  belongs_to :resource\n  belongs_to :user\n\n  after_commit :cleanup_policy_cache, on: [:create, :destroy]\n\n  def cleanup_policy_cache\n    # Clear cache for the corresponding user-record pair\n    ActionPolicy.cache_store.delete_matched(\n      \"policy_cache/#{user_id}/#{ResourcePolicy.name}/#{resource_id}/*\"\n    )\n  end\nend\n```\n\nLANGUAGE: ruby\nCODE:\n```\nclass User < ApplicationRecord\n  belongs_to :role\n\n  after_commit :cleanup_policy_cache, on: [:update], if: :role_id_changed?\n\n  def cleanup_policy_cache\n    # Clear all policies cache for user\n    ActionPolicy.cache_store.delete_matched(\n      \"policy_cache/#{user_id}/*\"\n    )\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Default Rule Cache Key Structure (Ruby)\nDESCRIPTION: Illustrates the default structure used by Action Policy to generate cache keys for cached rules. The key includes a versioned namespace, context keys, the record's cache key, the policy class name, and the rule name.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/caching.md#_snippet_9\n\nLANGUAGE: ruby\nCODE:\n```\n\"#{cache_namespace}/#{context_cache_key}\" \\\n\"/#{record.policy_cache_key}/#{policy.class.name}/#{rule}\"\n```\n\n----------------------------------------\n\nTITLE: Testing Authorized Scope in RSpec with Action Policy\nDESCRIPTION: Demonstrates how to write an RSpec test to verify that a controller action applies a policy scope using the `authorized` helper. It uses the `have_authorized_scope` matcher, specifying the expected scope type and the policy class expected to be used for scoping.\nSOURCE: https://github.com/palkan/action_policy/blob/master/CHANGELOG.md#_snippet_4\n\nLANGUAGE: Ruby\nCODE:\n```\ndescribe UsersController do\n  subject { get :index }\n  it \"has authorized scope\" do\n    expect { subject }.to have_authorized_scope(:active_record_relation)\n      .with(PostPolicy)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Using scopes within policy classes in Action Policy\nDESCRIPTION: Example showing how to use authorized_scope method within policy classes themselves, allowing composition of scopes in more complex scenarios.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/scoping.md#_snippet_7\n\nLANGUAGE: ruby\nCODE:\n```\nrelation_scope(:edit) do |scope|\n  teachers = authorized_scope(Teacher.all, as: :edit)\n  scope\n    .joins(:teachers)\n    .where(teacher_id: teachers)\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring Action Policy Per-Thread Cache Enabled State\nDESCRIPTION: Demonstrates how to control the per-thread cache mechanism in Action Policy by setting the `enabled` property of `ActionPolicy::PerThreadCache`. Setting it to `true` enables the cache, while `false` disables it.\nSOURCE: https://github.com/palkan/action_policy/blob/master/CHANGELOG.md#_snippet_7\n\nLANGUAGE: Ruby\nCODE:\n```\nActionPolicy::PerThreadCache.enabled = true # or false\n```\n\n----------------------------------------\n\nTITLE: Basic Namespace Policy Lookup in Ruby with Action Policy\nDESCRIPTION: Demonstrates how Action Policy looks up policies with respect to the current execution namespace, falling back to non-namespaced policies if needed.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/namespaces.md#_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nmodule Admin\n  class UsersController < ApplicationController\n    def index\n      # uses Admin::UserPolicy if any, otherwise fallbacks to UserPolicy\n      authorize!\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Disabling Action Policy Namespace Resolution Cache\nDESCRIPTION: Shows how to disable the namespace resolution cache in Action Policy by setting the `namespace_cache_enabled` property on `ActionPolicy::LookupChain` to `false`. This cache improves performance during policy lookup in namespaced contexts but can be disabled if needed.\nSOURCE: https://github.com/palkan/action_policy/blob/master/CHANGELOG.md#_snippet_8\n\nLANGUAGE: Ruby\nCODE:\n```\nActionPolicy::LookupChain.namespace_cache_enabled = false\n```\n\n----------------------------------------\n\nTITLE: Configuring `preauthorize` Behavior for Mutations\nDESCRIPTION: Describes how to modify the default exception raising behavior for preauthorization within mutations using configuration options. It clarifies that `preauthorize:` can be used similarly to fields, but `authorize:` is deprecated for mutations.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/graphql.md#_snippet_6\n\nLANGUAGE: Ruby\nCODE:\n```\nActionPolicy::GraphQL.preauthorize_mutation_raise_exception = true\n```\n\n----------------------------------------\n\nTITLE: Fetching All Comments in Controller (Ruby)\nDESCRIPTION: A controller action that fetches all `Comment` records. This sets the stage for potential N+1 authorization problems when permissions are checked for each comment individually in the view.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/caching.md#_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\n# app/controllers/comments_controller.rb\nclass CommentsController < ApplicationController\n  def index\n    # all comments for all posts\n    @comments = Comment.all\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Subscribing to ActionPolicy Events for Librato Metrics\nDESCRIPTION: Sample code for subscribing to the action_policy.apply_rule event and sending timing data to Librato. It tracks cache hit and miss events separately and records the execution time in milliseconds.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/instrumentation.md#_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nActiveSupport::Notifications.subscribe(\"action_policy.apply_rule\") do |event, started, finished, _, data|\n  # Track hit and miss events separately (to display two measurements)\n  measurement = \"#{event}.#{data[:cached] ? \"hit\" : \"miss\"}\"\n  # show ms times\n  timing = ((finished - started) * 1000).to_i\n  Librato.tracker.check_worker\n  Librato.timing measurement, timing, percentile: [95, 99]\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring Policy Name for Non-Inferrable Resources in Ruby\nDESCRIPTION: Shows how to specify a policy name at the class level for resources where policy cannot be inferred, ensuring proper namespace lookup.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/namespaces.md#_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\nclass Guest < User\n  def self.policy_name\n    \"UserPolicy\"\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Creating a NullPolicy Class in Ruby\nDESCRIPTION: Implements a NullPolicy class that serves as a fallback when no specific policy is found for a resource. It inherits from ActionPolicy::Base, sets a default rule, and always returns false for any authorization check.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/custom_lookup_chain.md#_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nclass NullPolicy < ActionPolicy::Base\n  default_rule :any?\n\n  def any?\n    false\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Installing Action Policy bundle\nDESCRIPTION: This code snippet shows how to install the action policy bundle.\nSOURCE: https://github.com/palkan/action_policy/blob/master/README.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nbundle install\n```\n\n----------------------------------------\n\nTITLE: Implementing Pre-Checks in Ruby Policy Classes\nDESCRIPTION: Demonstrates how to implement pre-checks to extract the common admin check logic from multiple rules. The private allow_admins method uses allow! to conditionally authorize super admins.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/pre_checks.md#_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nclass PostPolicy < ApplicationPolicy\n  pre_check :allow_admins\n\n  def show?\n    record.published\n  end\n\n  def update?\n    user.id == record.user_id\n  end\n\n  private\n\n  def allow_admins\n    allow! if user.super_admin?\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Creating ApplicationPolicy\nDESCRIPTION: This code snippet demonstrates how to create an application-specific ApplicationPolicy class that inherits from ActionPolicy::Base. This class serves as a base for all other policies in the application. It can be generated using `rails generate action_policy:install`.\nSOURCE: https://github.com/palkan/action_policy/blob/master/README.md#_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\nclass ApplicationPolicy < ActionPolicy::Base\nend\n```\n\n----------------------------------------\n\nTITLE: Adding a Debug Breakpoint (Ruby)\nDESCRIPTION: Illustrates how to insert a `binding.pry` (or `binding.irb`) breakpoint at the beginning of a policy rule method. This allows execution to pause within the method, enabling interactive debugging using the `pp` method.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/debugging.md#_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\ndef feed?\n  binding.pry # rubocop:disable Lint/Debugger\n  #...\nend\n```\n\n----------------------------------------\n\nTITLE: Testing authorization context matching with RSpec in Ruby\nDESCRIPTION: This snippet illustrates how to verify that an authorization is performed with a specific context using RSpec's `be_authorized_to` matcher and the `with_context` modifier. It ensures the authorization context includes specific key-value pairs. Inputs are the controller action subject and the expected context; output is a test pass/fail based on context matching during authorization calls.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/testing.md#_snippet_7\n\nLANGUAGE: ruby\nCODE:\n```\nclass PostController\n  def post\n    authorize! post, context: {favorite: true}\n  end\nend\n\ndescribe PostsController do\n  subject { patch :update, id: post.id, params: params }\n\n  it \"is authorized\" do\n    expect { subject }.to be_authorized_to(:update?, post)\n      .with_context(favorite: true)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Defining Policy Rule with Nested Authorization (Ruby)\nDESCRIPTION: Defines a `CommentPolicy` where the `edit?` rule includes a call to `allowed_to?(:manage?, record.post)`. This demonstrates how a single authorization check can trigger subsequent checks on associated records, potentially causing N+1 problems if many comments share the same post. Per-thread memoization helps mitigate this.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/caching.md#_snippet_4\n\nLANGUAGE: ruby\nCODE:\n```\n# app/policies/comment_policy.rb\nclass CommentPolicy < ApplicationPolicy\n  def edit?\n    user.admin? || (user.id == record.id) ||\n      allowed_to?(:manage?, record.post)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Caching Arbitrary Values within Policy (Ruby)\nDESCRIPTION: Demonstrates using the `#cache` instance method within policy methods (`permissions`, `account_permissions`) to cache arbitrary computation results. It uses the same underlying cache store and key generation logic as rule caching, accepting one or more objects as cache key parts.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/caching.md#_snippet_10\n\nLANGUAGE: ruby\nCODE:\n```\nclass ApplicationPolicy < ActionPolicy::Base\n  # Suppose that a user has many roles each having an array of permissions\n  def permissions\n    cache(user) { user.roles.pluck(:permissions).flatten.uniq }\n  end\n\n  # You can pass multiple cache key \"parts\"\n  def account_permissions(account)\n    cache(user, account) { user.account_roles.where(account: account).pluck(:permissions).flatten.uniq }\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Applying Authorization Scopes to Data\nDESCRIPTION: Illustrates how to scope data in GraphQL fields such as connections using `authorized_scope: true` or with a specific policy. This ensures that data returned respects the defined policies and filters data accordingly.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/graphql.md#_snippet_8\n\nLANGUAGE: Ruby\nCODE:\n```\nclass CityType < ::Common::Graphql::Type\n  # Automatically applies scope from the policy\n  field :events, EventType.connection_type,\n    null: false,\n    authorized_scope: true\n\n  # Explicitly specify policy\n  field :events, EventType.connection_type,\n    null: false,\n    authorized_scope: {with: CustomEventPolicy}\n\n  def events\n    authorized_scope object.events\n    # or with policy\n    authorized_scope object.events, with: CustomEventPolicy\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Exposing Authorization Rules to the Client\nDESCRIPTION: Describes how to expose policy rule results as fields in GraphQL types using `expose_authorization_rules`. It generates fields like `can_edit` and `can_destroy` with detailed result types that include value, message, reasons, etc., facilitating client-side permission checks.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/graphql.md#_snippet_9\n\nLANGUAGE: Ruby\nCODE:\n```\nclass ProfileType < Types::BaseType\n  # Adds can_edit, can_destroy fields\n  expose_authorization_rules :edit?, :destroy?, prefix: \"can_\"\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring RuboCop RSpec for Action Policy Aliases (YAML)\nDESCRIPTION: Shows the necessary YAML configuration to add to `.rubocop.yml` for projects using `rubocop-rspec` (version 2.0 or newer) alongside Action Policy. This `inherit_gem` directive ensures RuboCop correctly recognizes the RSpec aliases defined by Action Policy, preventing linting errors.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/testing.md#_snippet_16\n\nLANGUAGE: yaml\nCODE:\n```\ninherit_gem:\n  action_policy: config/rubocop-rspec.yml\n```\n\n----------------------------------------\n\nTITLE: Using have_authorized_scope with with_context Option in RSpec (Ruby)\nDESCRIPTION: Demonstrates using the `with_context` option for the `have_authorized_scope` matcher. This allows asserting that specific values (like the current user) are present in the context hash passed during the authorization scope application.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/testing.md#_snippet_14\n\nLANGUAGE: ruby\nCODE:\n```\nexpect { get :for_user, params: {id: user.id} }.to have_authorized_scope(:scope)\n  .with_scope_options(matching(with_deleted: a_falsey_value))\n  .with_context(a_hash_including(user:))\n```\n\n----------------------------------------\n\nTITLE: Implementing Pundit-compatible authorize method with Action Policy in Rails controllers\nDESCRIPTION: Creates an 'authorize' method that mimics Pundit's API but uses Action Policy's 'authorize!' method under the hood. Accepts a record and optional rule parameter, forwarding the rule as a named parameter if provided.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/pundit_migration.md#_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\ndef authorize(record, rule = nil)\n  options = {}\n  options[:to] = rule unless rule.nil?\n\n  authorize! record, **options\nend\n```\n\n----------------------------------------\n\nTITLE: Using allowed_to? in views\nDESCRIPTION: This code snippet demonstrates how to use the `allowed_to?` method in a view to conditionally display a link based on authorization. It checks if the current user is allowed to edit a post before displaying the edit link.\nSOURCE: https://github.com/palkan/action_policy/blob/master/README.md#_snippet_5\n\nLANGUAGE: erb\nCODE:\n```\n<% @posts.each do |post| %>\n  <li><%= post.title %>\n    <% if allowed_to?(:edit?, post) %>\n      <%= link_to post, \"Edit\"> <!-- Corrected the missing \" -->\n    <% end %>\n  </li>\n<% end %>\n```\n\n----------------------------------------\n\nTITLE: Using have_authorized_scope with with_target Modifier in RSpec (Ruby)\nDESCRIPTION: Shows how to use the `with_target` modifier in conjunction with `have_authorized_scope`. This allows running additional expectations directly on the resolved authorization scope target (e.g., the result of `User.all`) if the initial matcher passes.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/testing.md#_snippet_13\n\nLANGUAGE: ruby\nCODE:\n```\nexpect { subject }.to have_authorized_scope(:scope)\n  .with_scope_options(matching(with_deleted: a_falsey_value))\n  .with_target { |target|\n    expect(target).to eq(User.all)\n  }\n```\n\n----------------------------------------\n\nTITLE: Authorizing a GraphQL Field with `authorize: true`\nDESCRIPTION: Illustrates how to protect a GraphQL field using the `authorize: true` option, which internally calls `authorize!` to enforce policies based on the resolved object. When access is denied, an `ActionPolicy::Unauthorized` exception is raised unless configured otherwise.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/graphql.md#_snippet_1\n\nLANGUAGE: Ruby\nCODE:\n```\nfield :home, Home, null: false, authorize: true do\n  argument :id, ID, required: true\nend\n\ndef home(id:)\n  Home.find(id)\nend\n```\n\nLANGUAGE: Ruby\nCODE:\n```\n# Without `authorize: true`\ndef home(id:)\n  Home.find(id).tap { |home| authorize! home, to: :show? }\nend\n```\n\n----------------------------------------\n\nTITLE: Generating Action Policy with Parent Class - Ruby\nDESCRIPTION: This snippet shows the Ruby code generated by the `rails g action_policy:policy` command when using the `--parent` option. It defines a new policy class, `UserPolicy`, which inherits from the specified `BasePolicy`, illustrating how generators support custom inheritance structures.\nSOURCE: https://github.com/palkan/action_policy/blob/master/CHANGELOG.md#_snippet_0\n\nLANGUAGE: Ruby\nCODE:\n```\nclass UserPolicy < BasePolicy\n# ...\nend\n\n```\n\n----------------------------------------\n\nTITLE: Using the authorized_scope method in controllers with different options\nDESCRIPTION: Various examples of using the authorized_scope method in a controller, demonstrating different ways to specify scope types, named scopes, and additional options.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/scoping.md#_snippet_6\n\nLANGUAGE: ruby\nCODE:\n```\nclass PostsController < ApplicationController\n  def index\n    # The first argument is the target,\n    # which is passed to the scope block\n    #\n    # The second argument is the scope type\n    @posts = authorized_scope(Post, type: :relation)\n    #\n    # For named scopes provide `as` option\n    @events = authorized_scope(Event, type: :relation, as: :own)\n    #\n    # If you want to specify scope options provide `scope_options` option\n    @events = authorized_scope(Event, type: :relation, scope_options: {with_deleted: true})\n  end\nend\n```\n\nLANGUAGE: ruby\nCODE:\n```\n@posts = authorized_scope(Post, with: CustomPostPolicy)\n```\n\n----------------------------------------\n\nTITLE: Defining Implicit Authorization Target in Ruby\nDESCRIPTION: This code demonstrates the use of implicit authorization targets. By defining `implicit_authorization_target`, you can omit the target argument in authorization calls, as it defaults to the result of this method.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/behaviour.md#_snippet_8\n\nLANGUAGE: ruby\nCODE:\n```\nclass PostActions\n  include ActionPolicy::Behaviour\n\n  authorize :user\n\n  attr_reader :user, :post\n\n  def initialize(user, post)\n    @user = user\n    @post = post\n  end\n\n  def update(params)\n    # post is used here implicitly as a target\n    authorize! to: :update\n\n    post.update!(params)\n  end\n\n  def destroy\n    # post is used here implicitly as a target\n    authorize! to: :destroy\n\n    post.destroy!\n  end\n\n  def implicit_authorization_target\n    post\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Handling Authorization Exceptions in GraphQL Schema\nDESCRIPTION: Provides a pattern for rescuing `ActionPolicy::Unauthorized` exceptions in GraphQL schemas, transforming them into `GraphQL::ExecutionError` with detailed messages and extension data, ensuring client receives meaningful error information.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/graphql.md#_snippet_7\n\nLANGUAGE: Ruby\nCODE:\n```\nrescue_from(ActionPolicy::Unauthorized) do |exp|\n  raise GraphQL::ExecutionError.new(\n    exp.result.message,\n    extensions: {\n      code: :unauthorized,\n      fullMessages: exp.result.reasons.full_messages,\n      details: exp.result.reasons.details\n    }\n  )\nend\n```\n\n----------------------------------------\n\nTITLE: Defining Relation Scope in Action Policy\nDESCRIPTION: Defines a `relation_scope` block within an Action Policy class. This block is used to modify a relation (e.g., an ActiveRecord query) based on policy logic and potentially parameters like `with_deleted`. It takes the original relation as input and returns the modified relation.\nSOURCE: https://github.com/palkan/action_policy/blob/master/CHANGELOG.md#_snippet_1\n\nLANGUAGE: Ruby\nCODE:\n```\ndescribe UserPolicy < Application do\n  relation_scope do |relation, with_deleted: false|\n    rel = some_logic(relation)\n    with_deleted ? rel.with_deleted : rel\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Class-Level Authorization with `self.authorized?`\nDESCRIPTION: Illustrates how to implement class-level authorization logic using the `self.authorized?` method in GraphQL type classes. It allows combining custom logic with inherited authorization behavior, and explicitly passing context for policy checks.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/graphql.md#_snippet_4\n\nLANGUAGE: Ruby\nCODE:\n```\nclass Types::Friendship < Types::BaseObject\n  def self.authorized?(object, context)\n    super &&\n      allowed_to?(\n        :show?,\n        object,\n        # Provide context explicitly\n        context: {user: context[:current_user]}\n      )\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Setting Global Cache Store (Ruby)\nDESCRIPTION: Shows the configuration of a global cache store instance for Action Policy. The assigned object must respond to `#read(key)` and `#write(key, value, **options)` methods. This store is used for rules marked with the `cache` directive.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/caching.md#_snippet_7\n\nLANGUAGE: ruby\nCODE:\n```\nActionPolicy.cache_store = MyCacheStore.new\n```\n\n----------------------------------------\n\nTITLE: Using have_authorized_scope with Composed Matchers in RSpec (Ruby)\nDESCRIPTION: Illustrates using RSpec composed matchers like `matching` within the `with_scope_options` chain of the `have_authorized_scope` matcher. This example checks if the scope options include `with_deleted` set to a falsey value.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/testing.md#_snippet_12\n\nLANGUAGE: ruby\nCODE:\n```\nexpect { subject }.to have_authorized_scope(:scope)\n  .with_scope_options(matching(with_deleted: a_falsey_value))\n```\n\n----------------------------------------\n\nTITLE: Implementing Conditional Relation Scope in Post Policy\nDESCRIPTION: Defines a `relation_scope` in `PostPolicy` that conditionally modifies the query. If the `user` is an admin, the original relation is returned; otherwise, the relation is filtered to include only posts belonging to the current `user`.\nSOURCE: https://github.com/palkan/action_policy/blob/master/CHANGELOG.md#_snippet_6\n\nLANGUAGE: Ruby\nCODE:\n```\nclass PostPolicy < ApplicationPolicy\n  relation_scope do |relation|\n    next relation if user.admin?\n    relation.where(user: user)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Using Namespace Lookup in Ruby\nDESCRIPTION: This snippet illustrates the usage of namespace lookup to look for authorization policies within a namespace. The snippet demonstrates that when using namespace lookup, the policy will first try to lookup Admin::PostPolicy before searching for PostPolicy.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/behaviour.md#_snippet_5\n\nLANGUAGE: ruby\nCODE:\n```\n# Would try to lookup Admin::PostPolicy first\nauthorize! post, to: :destroy?, namespace: Admin\n```\n\n----------------------------------------\n\nTITLE: Customizing Authorization Field Prefix and Specific Rules\nDESCRIPTION: Shows how to override default prefixes for authorization fields globally and also how to specify custom field names for individual rules, providing flexibility in how authorization information is exposed to GraphQL clients.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/graphql.md#_snippet_10\n\nLANGUAGE: Ruby\nCODE:\n```\nActionPolicy::GraphQL.default_authorization_field_prefix = \"allowed_to_\"\n```\n\nLANGUAGE: Ruby\nCODE:\n```\nclass ProfileType < ::Common::Graphql::Type\n  # Adds can_create_post field with custom rule source\n  expose_authorization_rules :create?, with: PostPolicy, field_name: \"can_create_post\"\nend\n```\n\n----------------------------------------\n\nTITLE: Adding a NullPolicy Probe to the Lookup Chain in Ruby\nDESCRIPTION: Demonstrates how to extend the existing lookup chain by appending a new probe that returns the NullPolicy class. This ensures that policy lookups always return a policy object rather than raising an exception.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/custom_lookup_chain.md#_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\nActionPolicy::LookupChain.chain << ->(_, _) { NullPolicy }\n```\n\n----------------------------------------\n\nTITLE: Using strict_namespace Lookup in Ruby\nDESCRIPTION: This snippet shows how to use strict_namespace lookup. By setting strict_namespace to true, if Admin::PostPolicy does not exist then it would not fallback to PostPolicy for a lookup.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/behaviour.md#_snippet_6\n\nLANGUAGE: ruby\nCODE:\n```\n# Would not fallback lookup PostPolicy if Admin::PostPolicy doesn't exist\nauthorize! post, to: :destroy?, namespace: Admin, strict_namespace: true\n```\n\n----------------------------------------\n\nTITLE: Requiring Action Policy RSpec Integration in Ruby\nDESCRIPTION: Includes the Action Policy RSpec helpers in a `rails_helper.rb` or `spec_helper.rb` file. This step is necessary to enable the use of custom Action Policy matchers like `have_authorized_scope` in RSpec tests.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/testing.md#_snippet_10\n\nLANGUAGE: ruby\nCODE:\n```\nrequire \"action_policy/rspec\"\n```\n\n----------------------------------------\n\nTITLE: Creating named scopes and scopes with options in Action Policy\nDESCRIPTION: Examples showing how to create named scopes for more specific filtering operations and how to add optional parameters to scopes for more flexible logic.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/scoping.md#_snippet_4\n\nLANGUAGE: ruby\nCODE:\n```\nclass EventPolicy < ApplictionPolicy\n  scope_for :relation, :own do |relation|\n    relation.where(owner: user)\n  end\nend\n```\n\nLANGUAGE: ruby\nCODE:\n```\nclass PostPolicy < ApplicationPolicy\n  scope_for :relation do |relation, with_deleted: false|\n    rel = some_logic(relation)\n    with_deleted ? rel.with_deleted : rel\n  end\nend\n```\n\nLANGUAGE: ruby\nCODE:\n```\nclass PostPolicy < ApplicationPolicy\n  scope_for :relation do |relation, some_required_option:, with_deleted: false, magic_number: 42|\n    # Your code\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Using Action Policy's authorized_scope in a controller with policy implementation\nDESCRIPTION: Example of using Action Policy's authorized_scope method in a controller to filter posts, along with the corresponding policy implementation defining the relation_scope.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/scoping.md#_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nclass PostsController < ApplicationController\n  def index\n    @posts = authorized_scope(Post.all)\n  end\nend\n\nclass PostPolicy < ApplicationPolicy\n  relation_scope do |relation|\n    next relation if user.admin?\n    relation.where(user: user)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Customizing Authorization Namespace in Ruby with Action Policy\nDESCRIPTION: Shows how to override the authorization_namespace method to implement custom namespace resolution logic based on user roles.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/namespaces.md#_snippet_4\n\nLANGUAGE: ruby\nCODE:\n```\ndef authorization_namespace\n  return ::Admin if current_user.admin?\n  return ::Staff if current_user.staff?\n  # fallback to current namespace\n  super\nend\n```\n\n----------------------------------------\n\nTITLE: Installing Action Policy gem\nDESCRIPTION: This code snippet shows how to add the Action Policy gem to your application's Gemfile and then execute bundle install to install it.\nSOURCE: https://github.com/palkan/action_policy/blob/master/README.md#_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\ngem \"action_policy\"\n```\n\n----------------------------------------\n\nTITLE: Configuring I18n for Detailed Failure Reasons\nDESCRIPTION: Shows how to configure internationalization for displaying detailed failure reasons with interpolated values.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/reasons.md#_snippet_6\n\nLANGUAGE: ruby\nCODE:\n```\n# YAML Configuration\n# en:\n#   action_policy:\n#     policy:\n#       stage:\n#         show?: \"The %{title} stage is not accessible\"\n\np ex.result.reasons.full_messages #=> The Onboarding stage is not accessible\n```\n\n----------------------------------------\n\nTITLE: Specifying Custom Reasons with deny!\nDESCRIPTION: Demonstrates how to specify custom reason messages when using deny! in policy rules.\nSOURCE: https://github.com/palkan/action_policy/blob/master/docs/reasons.md#_snippet_3\n\nLANGUAGE: ruby\nCODE:\n```\nclass TeamPolicy < ApplicationPolicy\n  def show?\n    deny!(:no_user) if user.anonymous?\n\n    user.has_permission?(:view_teams)\n  end\nend\n\np ex.result.reasons.to_h #=> { applicant: [:no_user] }\n```"
  }
]