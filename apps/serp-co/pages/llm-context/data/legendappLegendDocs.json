[
  {
    "owner": "legendapp",
    "repo": "legend-docs",
    "content": "TITLE: Creating an Observable Store for a Todo App in TypeScript\nDESCRIPTION: This snippet demonstrates how to create an observable store for a Todo app using Legend-State. It includes the store interface, computed properties, and an action to add todos.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/intro/getting-started.mdx#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { observable } from \"@legendapp/state\";\n\n// Type your Store interface\ninterface Todo {\n  id: number;\n  text: string;\n  completed?: boolean;\n}\n\ninterface Store {\n  todos: Todo[];\n  total: number;\n  numCompleted: number;\n  addTodo: () => void;\n}\n\n// Create a global observable for the Todos\nlet nextId = 0;\nconst store$ = observable<Store>({\n  todos: [],\n  // Computeds\n  total: (): number => {\n    return store$.todos.length;\n  },\n  numCompleted: (): number => {\n    return store$.todos.get().filter((todo) => todo.completed).length;\n  },\n  addTodo: () => {\n    const todo: Todo = {\n      id: nextId++,\n      text: \"\",\n    };\n    store$.todos.push(todo);\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling Reactive Components in Legend-State\nDESCRIPTION: This snippet shows how to enable reactive components for either React or React Native platforms. This is a prerequisite for using the Reactive components that provide reactive props.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/react/fine-grained-reactivity.mdx#2025-04-11_snippet_1\n\nLANGUAGE: js\nCODE:\n```\n// React\nimport { enableReactComponents } from \"@legendapp/state/config/enableReactComponents\";\nenableReactComponents();\n\n// React Native\nimport { enableReactNativeComponents } from \"@legendapp/state/config/enableReactNativeComponents\";\nenableReactNativeComponents();\n```\n\n----------------------------------------\n\nTITLE: Using useTraceListeners Hook in React\nDESCRIPTION: Demonstrates how to use useTraceListeners() to log all observable dependencies being tracked in a component. Helps identify what observables are being listened to for changes.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/react/tracing.mdx#2025-04-11_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useTraceListeners } from \"@legendapp/state/trace\";\n\nconst Component = observer(function Component(props) {\n  // Call useTraceListeners anywhere inside the component\n  useTraceListeners();\n\n  const count = use$(state.count)\n\n  return <div>{count}</div>;\n\n  /* This logs:\n\n    [legend-state] tracking 1 observable:\n    1: count\n\n    */\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing a Todo App with Legend-State in React/React Native\nDESCRIPTION: This snippet shows how to use Legend-State observables in a React/React Native component. It demonstrates the use of use$, useObservable, and reactive components for efficient state management and rendering.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/intro/getting-started.mdx#2025-04-11_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { observer, use$, useObservable } from \"@legendapp/state/react\"\nimport { $TextInput } from \"@legendapp/state/react-native\"\n\nexport function App() {\n    // Consume the computed observables from the global store$\n    const total = use$(store$.total)\n    const completed = use$(store$.numCompleted)\n    // Create a local observable\n    const theme$ = useObservable<'light' | 'dark'>('dark')\n    const theme = use$(theme$)\n\n    const onClickClear = () => store$.todos.set([])\n\n    return (\n        <Box theme={theme}>\n            <ThemeButton $value={theme$} />\n            <Text>Total: {total}</Text>\n            <Text>Completed: {completed}</Text>\n            <For each={store$.todos} item={TodoItem} />\n            <View className=\"flex justify-between\">\n                <Button onClick={store$.addTodo}>Add</Button>\n                <Button onClick={onClickClear}>Clear</Button>\n            </View>\n        </Box>\n    )\n}\n\n// Receives item$ prop from the For component\nfunction TodoItem({ item$ }: { item$: Observable<Todo> }) {\n    const onKeyDown = (e) => {\n        // Call addTodo from the global store$\n        if (e.key === 'Enter') store$.addTodo()\n    }\n\n    // The child components are bound directly to the observable properties\n    // so this component never has to re-render.\n    return (\n        <View className=\"row\">\n            <Checkbox $value={item$.completed} />\n            <$TextInput\n                $value={item$.text}\n                onKeyDown={onKeyDown}\n            />\n        </View>\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: Organizing State with Multiple Individual Atoms in Legend-State\nDESCRIPTION: This pattern demonstrates creating multiple separate observable atoms across different files, allowing for more modular state management and better code organization.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/guides/patterns.mdx#2025-04-11_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\n// settings.ts\nexport const theme$ = observable('light')\nexport const fontSize$ = observable(14)\n\n// UIState.ts\nexport const uiState$ = observable({\n    windowSize: undefined as { width: number, height: number },\n    activeTab: 'home' as 'home' | 'user' | 'profile',\n})\n```\n\n----------------------------------------\n\nTITLE: Creating Global State with Legend-State\nDESCRIPTION: Demonstrates how to create a global state store using observables with typed properties and nested structure.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/intro/getting-started.mdx#2025-04-11_snippet_5\n\nLANGUAGE: js\nCODE:\n```\nimport { observable } from '@legendapp/state';\n\nexport const state$ = observable({\n    UI: {\n        windowSize: undefined as { width: number, height: number },\n        activeTab: 'home' as 'home' | 'user' | 'profile',\n        ...\n    },\n    settings: {\n        theme: 'light' as 'light' | 'dark',\n        fontSize: 14,\n        ...\n    },\n    todos: []\n})\n```\n\n----------------------------------------\n\nTITLE: Conditional Rendering with Show Component\nDESCRIPTION: These examples demonstrate how to use the Show component for conditional rendering based on observable state, with optional fallback content and wrapper components for animations. The component doesn't cause parent re-renders when conditions change.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/react/fine-grained-reactivity.mdx#2025-04-11_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\n<Show\n  if={state.show}\n  else={() => <div>Nothing to see here</div>}\n  wrap={AnimatePresence}\n>\n  {() => <Modal />}\n</Show>\n```\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Show, useObservable } from \"@legendapp/state/react\";\nimport { AnimatePresence } from \"framer-motion\";\n\nfunction ShowExampleWithSelector() {\n  const state$ = useObservable({ collection: [] });\n  return (\n    <Show\n      if={() => state$.collection.get().length > 0}\n      else={() => <div>Nothing to see here</div>}\n      wrap={AnimatePresence}\n    >\n      {() => <Modal />}\n    </Show>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Observing Observables in Legend State\nDESCRIPTION: Shows how to create observables with computed values, get and set values, and use the observe function for reactive contexts. Also demonstrates the use of use$ in React components.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/intro/introduction.mdx#2025-04-11_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport { observable, observe } from \"@legendapp/state\"\nimport { observer } from \"@legendapp/state/react\"\n\n// Observables can be primitives or deep objects\nconst settings$ = observable({\n    theme: 'dark'\n    // Computed observables with just a function\n    isDark: () => settings$.theme.get() === 'dark'\n})\n\n// get returns the raw data\nsettings$.theme.get() // 'dark'\n// set sets\nsettings$.theme.set('light')\n\n// observing contexts re-run when tracked observables change\nobserve(() => {\n  console.log(settings$.theme.get())\n})\n\nfunction Component() {\n    const theme = use$(state$.settings.theme)\n    // use$ tracks get() calls to automatically re-render on changes\n    const isDark = use$(() => state$.settings.theme.get() === 'dark')\n\n    return <div>Theme: {theme}</div>\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Large Global State Store in Legend-State\nDESCRIPTION: Example of creating a single large global state object containing UI state, settings, and application data. This pattern centralizes all state in one observable store.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/guides/patterns.mdx#2025-04-11_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nconst store$ = observable({\n    UI: {\n        windowSize: undefined as { width: number, height: number },\n        activeTab: 'home' as 'home' | 'user' | 'profile',\n        ...\n    },\n    settings: {\n        theme: 'light' as 'light' | 'dark',\n        fontSize: 14,\n        ...\n    },\n    todos: [] as TodoItem[]\n})\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Legend State Observables in React\nDESCRIPTION: Demonstrates how to create an observable object, get and set values, observe changes, and use observables in React components with automatic tracking. Shows the basic pattern of Legend State's simplified state management without boilerplate.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/intro/introduction.mdx#2025-04-11_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\n// Create an observable object\nconst state$ = observable({ settings: { theme: \"dark\" } });\n\n// Just get and set\nconst theme = state$.settings.theme.get();\nstate$.settings.theme.set(\"light\");\n\n// observe re-runs when accessed observables change\nobserve(() => {\n  console.log(state$.settings.theme.get());\n});\n\n// Enable React components to automatically track observables\nenableReactTracking({ auto: true });\n\nconst Component = function Component() {\n  // get() makes this component re-render whenever theme changes\n  const theme = state$.settings.theme.get();\n\n  return <div>Theme: {theme}</div>;\n};\n```\n\n----------------------------------------\n\nTITLE: Using Observables with React Components in Legend State\nDESCRIPTION: Demonstrates how to create and use observables in Legend State, including setting values and using them in React components with automatic re-rendering.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/intro/introduction.mdx#2025-04-11_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nconst state$ = observable({\n    settings: { theme: 'dark' }\n})\n\nstate$.settings.theme.set('light')\n\nconst Component = () => {\n    const theme = use$(state$.settings.theme)\n\n    return <div>Theme: {theme}</div>\n}\n```\n\n----------------------------------------\n\nTITLE: Deprecated enableReactTracking in Legend State\nDESCRIPTION: Shows the deprecated enableReactTracking configuration which was a shortcut to use get() without observer. This is broken in React 19 and is being removed in favor of the use$ pattern.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/other/migrating.mdx#2025-04-11_snippet_6\n\nLANGUAGE: jsx\nCODE:\n```\nenableReactAutoTracking({ auto: true })\nconst state$ = observable({ value: 10 })\nconst Component = () => {\n    const value = state$.value.get()\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Using Multiple Individual Atoms in Legend-State\nDESCRIPTION: Shows how to organize state using multiple smaller, separate observable objects in their own files. This approach separates concerns by creating dedicated atoms for different parts of the application like settings and UI state.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/guides/patterns.mdx#2025-04-11_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\n// Settings\nexport const theme$ = observable('light')\nexport const fontSize$ = observable(14)\n\n// UIState\nexport const uiState$ = observable({\n    windowSize: undefined as { width: number, height: number },\n    activeTab: 'home' as 'home' | 'user' | 'profile',\n})\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Observables in Legend-State\nDESCRIPTION: Demonstrates how to create an observable with nested objects, access values using get(), and modify values using set().\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/intro/getting-started.mdx#2025-04-11_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nimport { observable } from \"@legendapp/state\";\n\nconst state$ = observable({ text: \"hello\", obj: { value: 10 } });\n\nconst text = state$.text.get(); // 'hello'\nstate$.obj.value.get() === 10; // true\n\n// Use the set function anywhere\nstate$.text.set(\"hi\");\n\n// Easily modify the previous value\nstate$.text.set((text) => text + \" there\");\n```\n\n----------------------------------------\n\nTITLE: Using opaqueObject for Primitive-like Treatment in JavaScript\nDESCRIPTION: Demonstrates how to use the opaqueObject function to mark an object in an observable as opaque, treating it as a primitive. This is useful for storing DOM or React elements or other large objects in an observable when you don't need to track their internal properties.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/usage/helper-functions.mdx#2025-04-11_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { observable. opaqueObject } from '@legendapp/state'\n\nconst state$ = observable({ text: 'hi', body: opaqueObject(document.body) })\n```\n\n----------------------------------------\n\nTITLE: Using observer HOC with Legend-State in React\nDESCRIPTION: The observer HOC wraps a component to automatically track observable state changes. It creates a Proxy around the component for efficient tracking and re-rendering, and is more performant than using multiple hooks or enableReactTracking.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/react/react-API.mdx#2025-04-11_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport { observable } from \"@legendapp/state\"\nimport { observer } from \"@legendapp/state/react\"\n\nconst state$ = observable({ count: 0 })\n\nconst Component = observer(function Component() {\n  // Accessing state automatically makes this component track changes to re-render\n  const count = state$.count.get()\n\n  // Re-renders whenever count changes\n  return <div>{count}</div>\n});\n```\n\n----------------------------------------\n\nTITLE: Batching Operations in Legend-State\nDESCRIPTION: Demonstrates how to use batching in Legend-State to postpone renders and listeners until multiple changes are complete. This is useful for modifying multiple observables at once without triggering callbacks for each change.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/guides/performance.mdx#2025-04-11_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { batch, beginBatch, endBatch } from \"@legendapp/state\";\n\n// Wrap in begin and end\nbeginBatch();\ndoManyChanges();\nendBatch();\n\n// Or batch with a callback\nbatch(() => {\n  doManyChanges();\n});\n```\n\n----------------------------------------\n\nTITLE: Using use$ Hook with Legend-State in React\nDESCRIPTION: The use$ hook computes a value from observables and automatically re-renders when the computed value changes. It can take either an observable directly or a function that accesses observables.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/react/react-API.mdx#2025-04-11_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport { observable } from \"@legendapp/state\"\nimport { use$ } from \"@legendapp/state/react\"\n\nconst state$ = observable({ selected: 1, theme })\n\nconst Component = ({ id }) => {\n    // Only re-renders if the return value changes\n    const isSelected = use$(() => id === state$.selected.get())\n\n    // Get the raw value of an observable and re-render when it changes\n    const theme = use$(state$.theme)\n\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Using useMountOnce hook for guaranteed single execution on mount\nDESCRIPTION: The useMountOnce hook combines useMount with a workaround for development mode, ensuring the mount callback only runs once regardless of React's double-rendering behavior in development.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/react/react-API.mdx#2025-04-11_snippet_11\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useMountOnce } from \"@legendapp/state/react\";\n\nconst Component = () => {\n  useMountOnce(() => console.log(\"mounted\"));\n};\n```\n\n----------------------------------------\n\nTITLE: Mapping Observable Arrays with Performance Considerations\nDESCRIPTION: Shows how to properly map through observable arrays without causing unnecessary re-renders. Using peek() instead of get() when accessing fields during mapping prevents tracking that would cause outer component re-renders.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/guides/performance.mdx#2025-04-11_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nimport { observable } from \"@legendapp/state\";\nimport { For } from \"@legendapp/state/react\";\n\nconst state$ = observable({ arr: [{ id: 1, text: \"hi\" }] });\n\nfunction Row({ item }) {\n  return <div>{item.text}</div>;\n}\nfunction List() {\n  // Be sure to use peek() to make sure you don't track any observable fields here\n  return state$.arr.map((item) => <Row key={item.peek().id} item={item} />);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Robust Offline-First Sync with CRUD\nDESCRIPTION: Advanced example showing how to implement a robust offline-first sync engine using the CRUD plugin. Features include local persistence, retry mechanisms, realtime updates, and syncing only changes since last sync.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/persist-sync.mdx#2025-04-11_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { observable } from '@legendapp/state'\nimport { syncedCrud } from '@legendapp/state/sync-plugins/crud'\nimport { ObservablePersistLocalStorage } from '@legendapp/state/persist-plugins/local-storage'\n\nconst profile$ = observable(syncedCrud({\n    list: () => {/*...*/},\n    create: () => {/*...*/},\n    update: () => {/*...*/},\n    // Enable realtime. Some plugins have this built in so it's not required.\n    subscribe: ({ refresh, update }) => {\n        return realtime.subscribe({ /*...*/ }, () => {\n            // Trigger a refresh of the list function\n            refresh()\n        })\n    },\n    // Local first configuration\n    persist: {\n        plugin: ObservablePersistLocalStorage, // Set the persistence plugin\n        name: 'profile', // Set the name of this object in persistence\n        retrySync: true, // Persist pending changes to retry\n    },\n    retry: {\n        infinite: true, // Keep retrying until it saves\n    },\n    changesSince: 'last-sync', // Sync only diffs\n    fieldUpdatedAt: 'updatedAt' // Required for syncing only diffs\n}))\n```\n\n----------------------------------------\n\nTITLE: Using onChange to Track Observable Changes in Legend-State\nDESCRIPTION: Demonstrates how to use onChange to listen for changes in observables at any level, showing both basic usage and advanced options with tracking previous values.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/usage/reactivity.mdx#2025-04-11_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nconst state$ = observable({ text: \"hi\" });\n\nstate$.text.onChange(({ value }) => console.log(\"text changed to\", value));\nstate$.onChange(({ value }) => console.log(\"state changed to\", value));\n\nstate$.text.set(\"hello\");\n\n// Log: text changed to \"hello\"\n// Log: state changed to { text: \"hello\" }\n```\n\n----------------------------------------\n\nTITLE: Creating and Accessing Basic Observables in JavaScript\nDESCRIPTION: This snippet shows how to create a basic observable with the observable() function and access its value using get(). Observables can contain primitives, objects, arrays, and functions.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/usage/observable.mdx#2025-04-11_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { observable } from \"@legendapp/state\";\n\nconst state$ = observable({ text: \"hello\" });\n\nconsole.log(state$.get());\n// { text: 'hello' }\n```\n\n----------------------------------------\n\nTITLE: Conditional Rendering with Switch Component\nDESCRIPTION: This example shows how to use the Switch component for conditional rendering based on an observable value. It renders different content based on matching the value to case keys, with an optional default case.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/react/fine-grained-reactivity.mdx#2025-04-11_snippet_6\n\nLANGUAGE: jsx\nCODE:\n```\n<Switch value={state.index}>\n  {{\n    0: () => <div>Tab 1</div>,\n    1: () => <div>Tab 2</div>,\n    default: () => <div>Error</div>,\n  }}\n</Switch>\n```\n\n----------------------------------------\n\nTITLE: Using observer Higher-Order Component in Legend-State\nDESCRIPTION: The observer HOC optimizes components that consume multiple observables by tracking all observable accesses with a single hook, reducing the number of hooks in your component.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/react/react-API.mdx#2025-04-11_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nimport { observable } from \"@legendapp/state\"\nimport { observer, use$ } from \"@legendapp/state/react\"\n\nconst state$ = observable({ count: 0 })\n\nconst Component = observer(function Component() {\n  // Accessing state automatically makes this component track changes to re-render\n  const count = use$(state$.count)\n\n  // Re-renders whenever count changes\n  return <div>{count}</div>\n})\n```\n\n----------------------------------------\n\nTITLE: Advanced IndexedDB Configuration with Legend-State\nDESCRIPTION: Detailed configuration for IndexedDB persistence showing two persistence modes: dictionary-based persistence where each value has an ID field, and row-based persistence with itemID option. Includes database configuration setup.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/guides/persistence.mdx#2025-04-11_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport { persistObservable } from \"@legendapp/state/persist\"\nimport { ObservablePersistIndexedDB } from \"@legendapp/state/persist-plugins/indexeddb\"\n\nconfigureObservablePersistence({\n  pluginLocal: ObservablePersistIndexedDB,\n  local: {\n    indexedDB: {\n      databaseName: \"Legend\",\n      version: 1,\n      tableNames: [\"documents\", \"store\"],\n    },\n  },\n})\n\n// Mode 1: Persist a dictionary\nconst state$ = observable({\n  obj1: { id: \"obj1\", text: \"...\" },\n  obj2: { id: \"obj2\", text: \"...\" },\n})\n\npersistObservable(state$, {\n  local: \"documents\", // IndexedDB table name\n})\n\n// Mode 2: Persist an object with itemId\nconst settings$ = observable({ theme: \"light\" })\n\npersistObservable(settings$, {\n  local: {\n    name: \"store\", // IndexedDB table name\n    indexedDB: {\n      itemID: \"settings\",\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Using Reactive Components with Responsive Props\nDESCRIPTION: This example demonstrates how to use Reactive components with reactive props that update based on state changes. It shows reactive styling, conditional rendering, and two-way data binding with form inputs.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/react/fine-grained-reactivity.mdx#2025-04-11_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Reactive } from \"@legendapp/state/react\"\n\nfunction Component() {\n    // This component renders only once\n    const state$ = useObservable({ name: '', age: 18 })\n\n    return (\n        <div>\n            // Reactive styling\n            <Reactive.div\n                $style={() => ({\n                    color: state$.age.get() > 5 ? 'green' : 'red'\n                })}\n                $className={() => state$.age.get() > 5 ? 'kid' : 'baby'}\n            />\n            // Reactive children\n            <Reactive.div>\n                {() => (\n                    <div>{state$.age.get() > 5 ? <Kid /> : <Baby />}</div>\n                )}\n            />\n            // Two-way bind to inputs\n            <Reactive.textarea $value={state$.name} />\n            <Reactive.select $value={state$.age}>...</Reactive.select>\n            <Reactive.input\n                $value={state$.name}\n                $className={() => !state$.name.get() && \"border-red-500\"}\n                $style={() => !state$.name.get() && { borderWidth: 1 }}\n            />\n        </div>\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Using Observation Contexts in Legend-State\nDESCRIPTION: Demonstrates the different observing contexts that automatically track and react to changes in observables, including observe, when, and computed.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/intro/getting-started.mdx#2025-04-11_snippet_2\n\nLANGUAGE: js\nCODE:\n```\n// This will re-run whenever accessed observables change\nobserve(() => {\n  console.log(\"Theme is\", state$.settings.theme.get());\n});\n\n// when waits for a value to become truthy.\nawait when(() => state$.settings.theme.get() === \"dark\");\n\n// an observable can be computed based on other observables\nconst isDark$ = observable(() => state$.settings.theme.get() === \"dark\");\n```\n\n----------------------------------------\n\nTITLE: Using useMeasure Hook for Element Size Tracking\nDESCRIPTION: Shows basic usage of useMeasure hook to track element dimensions.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/react/helpers-and-hooks.mdx#2025-04-11_snippet_6\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useMeasure } from \"@legendapp/state/react-hooks/useMeasure\";\nimport { useRef } from \"react\";\n\nfunction Component() {\n  const ref = useRef();\n  const { width, height } = useMeasure(ref);\n\n  return (\n    <div ref={ref}>\n      Width: {width}, Height: {height}\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Tracking Async Observable Status with syncState\nDESCRIPTION: Demonstrates using the syncState helper to track the loading and error states of an asynchronous observable, making it easier to handle different async states reactively.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/usage/observable.mdx#2025-04-11_snippet_16\n\nLANGUAGE: javascript\nCODE:\n```\nconst status$ = syncState(serverState$)\nobserve(() => {\n    // This will re-run as the status changes\n    const { isLoaded, error } = status$.get()\n    if (error) {\n        // Handle error\n    } else if (isLoaded) {\n        // Do the thing\n    }\n})\n```\n\n----------------------------------------\n\nTITLE: Setting Up Legend State Persistence with Storage Plugins\nDESCRIPTION: Shows how to implement persistence in Legend State using plugins for local storage and Firebase. This example demonstrates setting up an observable with both local caching and remote synchronization capabilities.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/intro/introduction.mdx#2025-04-11_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nimport { ObservablePersistLocalStorage } from '@legendapp/state/persist-plugins/local-storage'\nimport { ObservablePersistFirebase } from \"@legendapp/state/persist-plugins/firebase\"\nimport { persistObservable } from '@legendapp/state/persist'\nimport { observable } from '@legendapp/state'\n\nconst state$ = observable({ store: { bigObject: { ... } } })\n\n// Persist this observable\npersistObservable(state$, {\n    pluginLocal: ObservablePersistLocalStorage,\n    local: 'store',\n    pluginRemote: ObservablePersistFirebase,\n    remote: {\n        firebase: {\n            refPath: (uid) => `/users/${uid}/`,\n            requireAuth: true,\n        },\n    }\n})\n```\n\n----------------------------------------\n\nTITLE: Creating Observable Objects and Atoms in JavaScript\nDESCRIPTION: Demonstrates how to create observable objects with computed functions and actions, as well as smaller individual observable atoms. Observables allow for reactive state management with features like computed properties and action methods.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/usage/observable.mdx#2025-04-11_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { observable } from \"@legendapp/state\"\n\n// Create observable objects as large and deep as you want. They can include computed functions\n// and action functions.\nconst state$ = observable({\n    fname: 'Annyong',\n    lname: 'Bluth',\n    // Computeds\n    name: () => state$.fname.get() + ' ' + state$.lname.get(),\n    // Actions\n    setName: (name: string) => {\n        const [fname, lname] = name.split(' ');\n        state$.assign({ fname, lname })\n    }\n})\n\n// Or create small individual atoms if you prefer\nconst fname$ = observable('Annyong')\nconst lname$ = observable('Bluth')\n```\n\n----------------------------------------\n\nTITLE: Creating Local State with useObservable in Legend-State\nDESCRIPTION: The useObservable hook creates a new observable within a React component, useful for local component state or when managing multiple values. It can also create computed observables using a function.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/react/react-API.mdx#2025-04-11_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nimport { observer, useObservable } from \"@legendapp/state/react\"\n\nconst Component = function Component() {\n    const state$ = useObservable({\n        title: 'Title',\n        first: '',\n        last: '',\n        profile: {...}\n    })\n\n    const fullname$ = useObservable(() => `${state$.fname.get()} ${state$.lname.get()}`)\n\n    return (\n        <div>\n            <div>{fullname$}</div>\n            <Input text={state$.first} />\n            <Input text={state$.last} />\n            <Profile name={fullname$} />\n        </div>\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Using the For Component with Legend-State Arrays\nDESCRIPTION: Demonstrates two ways to use the optimized For component: providing an item component or using a render function as a child. The For component efficiently renders arrays by isolating element rendering.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/guides/performance.mdx#2025-04-11_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nimport { observable } from \"@legendapp/state\"\nimport { For } from \"@legendapp/state/react\"\n\nconst state$ = observable({ arr: [{ id: 1, text: 'hi' }]})\n\nfunction Row({ item }) {\n    return <div>{item.text}</div>\n}\nfunction List() {\n    // 1. Use the For component with an item prop\n    return <For each={state$.arr} item={Row} />\n\n    // 2. Use the For component with a render function as the child\n    return (\n        <For each={list}>\n            {item => (\n                <div>\n                    {item.text}\n                </div>\n            )}\n        </For>\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Using Memo Component for Independent Rendering\nDESCRIPTION: This snippet demonstrates the Memo component which, similar to Computed, extracts children into a separate tracking context but never re-renders when the parent component renders - only when its own observables change.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/react/fine-grained-reactivity.mdx#2025-04-11_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nfunction Component() {\n  return (\n    <Memo>\n      {() =>\n        state.messages.map((message) => (\n          <div key={message.id}>\n            {message.text} {localVar}\n          </div>\n        ))\n      }\n    </Memo>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using When Function for One-Time Reactions in Legend-State\nDESCRIPTION: Demonstrates the when function which waits for a condition to become truthy and then executes a callback once, with both promise and callback approaches.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/usage/reactivity.mdx#2025-04-11_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport { when } from \"@legendapp/state\";\n\nconst state$ = observable({ ok: false });\n\n// Option 1: Promise\nawait when(state$.ok);\n\n// Option 2: callback\nconst dispose = when(\n  () => state$.ok.get(),\n  () => console.log(\"Don't worry, it's ok\")\n);\n\n// Cancel listening manually\ndispose();\n```\n\n----------------------------------------\n\nTITLE: Setting Values in Observables\nDESCRIPTION: This snippet shows how to use set() to modify observables. It demonstrates setting values directly, using a function to update based on the previous value, and automatically filling undefined object paths.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/usage/observable.mdx#2025-04-11_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst state$ = observable({ text: \"hi\" });\n\n// Set directly\nstate$.text.set(\"hello there\");\n\n// Set with a function relative to previous value\nstate$.text.set((prev) => prev + \" there\");\n\n// Set will automatically fill out objects that were undefined\nstate$.otherKey.otherProp.set(\"hi\");\n```\n\n----------------------------------------\n\nTITLE: Rendering Observable Arrays with For Component in React\nDESCRIPTION: Demonstrates two ways to use the For component to render observable arrays: using an item prop and using a render function as a child.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/react/fine-grained-reactivity.mdx#2025-04-11_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\nimport { observable } from \"@legendapp/state\"\nimport { For, use$ } from \"@legendapp/state/react\"\n\nconst state$ = observable({ arr: [{ id: 1, text: 'hi' }]})\n\nconst Row = function Row({ item$ }) {\n    const text = use$(item$.text)\n    return <div>{text}</div>\n}\nfunction List() {\n    // 1. Use the For component with an item prop\n    return <For each={state$.arr} item={Row} />\n\n    // 2. Use the For component with a render function as the child\n    return (\n        <For each={list} optimized>\n            {item$ => (\n                <div>\n                    {item$.text.get()}\n                </div>\n            )}\n        </div>\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Usage Examples for Legend-Motion Components in React Native\nDESCRIPTION: Demonstrates comprehensive usage of Motion components including View, SVG, and LinearGradient with reactive animations based on value changes.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/motion/src/content/docs/getting-started/introduction.mdx#2025-04-11_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\n<Motion.View\n    animate={{\n        x: value * 100,\n        opacity: value ? 1 : 0.2,\n        scale: value ? 1 : 0.5\n    }}\n/>\n<MotionSvg.Svg>\n    <MotionSvg.Polygon\n        animateProps={{ points: value === 1 ?\n            \"120,10 190,160 70,190 23,184\" :\n            \"100,50 140,160 50,130 23,84\"\n        }}\n    />\n</MotionSvg.Svg>\n<MotionLinearGradient\n    animateProps={{\n        colors: value ?\n            [\"#F81FEC\", \"#59B0F8\"] :\n            [\"blue\", \"yellow\"]\n    }}\n/>\n```\n\n----------------------------------------\n\nTITLE: Using Computed Component for Optimized Rendering in React\nDESCRIPTION: Explains how to use the Computed component from Legend-State to optimize rendering of children that depend on both observables and local state.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/react/fine-grained-reactivity.mdx#2025-04-11_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nfunction Component() {\n  return (\n    <Computed>\n      {() =>\n        state$.messages.map((message) => (\n          <div key={message.id}>\n            {message.text} {localVar}\n          </div>\n        ))\n      }\n    </Computed>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using useSelector hook with Legend-State in React\nDESCRIPTION: The useSelector hook computes a value and automatically listens to any observables accessed while running, re-rendering only when the computed value changes. It can be used with a computation function or directly with an observable.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/react/react-API.mdx#2025-04-11_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport { observable } from \"@legendapp/state\"\nimport { useSelector } from \"@legendapp/state/react\"\n\nconst state$ = observable({ selected: 1, theme })\n\nconst Component = ({ id }) => {\n    // Only re-renders if the return value changes\n    const isSelected = useSelector(() => id === state$.selected.get())\n\n    // Get the raw value of an observable and listen to it\n    const theme = useSelector(state$.theme)\n\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Creating One Large Global State Object in Legend-State\nDESCRIPTION: Demonstrates how to organize application state using a single large observable object that contains all state categories including UI elements, settings, and data collections.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/guides/patterns.mdx#2025-04-11_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nconst store$ = observable({\n    UI: {\n        windowSize: undefined as { width: number, height: number },\n        activeTab: 'home' as 'home' | 'user' | 'profile',\n        ...\n    },\n    settings: {\n        theme: 'light' as 'light' | 'dark',\n        fontSize: 14,\n        ...\n    },\n    todos: [] as TodoItem[]\n})\n```\n\n----------------------------------------\n\nTITLE: Using scrollToItem Method in LegendList\nDESCRIPTION: Scrolls to a specific item in the list. Requires linear scan through data, so scrollToIndex is preferred when possible. Provided for compatibility with FlatList.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/api/props.mdx#2025-04-11_snippet_42\n\nLANGUAGE: typescript\nCODE:\n```\nscrollToItem(params: {\n  animated?: ?boolean,\n  item: Item,\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling View Recycling in Legend List (TypeScript)\nDESCRIPTION: The recycleItems prop enables view recycling, which reuses component instances rendered by renderItem instead of destroying and creating new views while scrolling. This optimization improves performance but may cause issues with local state persistence.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/api/performance.mdx#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nrecycleItems?: boolean // default: false\n```\n\n----------------------------------------\n\nTITLE: Using useObserve hook for reactive side effects in React\nDESCRIPTION: The useObserve hook creates an observe function that runs when observables change. It can be used to respond to state changes with side effects, similar to useEffect but triggered by observable changes rather than dependency arrays.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/react/react-API.mdx#2025-04-11_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nimport { event } from \"@legendapp/state\";\nimport { useObserve, useObservable, Reactive } from \"@legendapp/state/react\";\n\nconst eventUpdateTitle = event();\n\nfunction ProfilePage() {\n  const profile$ = useObservable({ name: \"\" });\n\n  // This runs whenever profile changes\n  useObserve(() => {\n    document.title = `${profile$.name.get()} - Profile`;\n  });\n\n  // Observe a single observable with a callback when it changes\n  useObserve(profile$.name, ({ value }) => {\n    document.title = `${value} - Profile`;\n  });\n\n  // Observe an event with a callback when it changes\n  useObserve(eventUpdateTitle, () => {\n    document.title = `${profile$.name.get()} - Profile`;\n  });\n\n  return (\n    <div>\n      <span>Name:</span>\n      <Reactive.input $value={profile$.name} />\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Observables with Memo Component in React\nDESCRIPTION: This snippet demonstrates how to use the Memo component to create mini elements that re-render only when the observed value changes, without causing parent component re-renders. It shows two examples: directly rendering an observable and using a selector function.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/react/fine-grained-reactivity.mdx#2025-04-11_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Memo } from \"@legendapp/state/react\";\n\nconst count$ = observable(0);\n\n// These components never re-render.\n// The Memo element re-renders itself when its value changes.\nfunction WithObservable() {\n  return (\n    <div>\n      Count:\n      <Memo>{count$}</Memo>\n    </div>\n  );\n}\nfunction WithSelector() {\n  return (\n    <div>\n      <Memo>{() => <div>Count: {count$.get()}</div>}</Memo>\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Observing Changes in Legend-State\nDESCRIPTION: Shows how to subscribe to changes in an observable using onChange() and demonstrates various observation methods including observe, when, and computed.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/intro/getting-started.mdx#2025-04-11_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nconst state$ = observable({\n  settings: { theme: \"light\" },\n  array: [{ text: \"hi\" }],\n});\n\n// Listen to observable directly\nstate$.settings.theme.onChange(({ value }) => console.log(\"Theme is\", value));\n```\n\n----------------------------------------\n\nTITLE: Updating Reactive Props Syntax in Legend-State\nDESCRIPTION: This example shows how to update the syntax for reactive props in Legend-State, changing from a suffix to a prefix $ notation.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/other/migrating.mdx#2025-04-11_snippet_16\n\nLANGUAGE: jsx\nCODE:\n```\nfunction Component() {\n  const text$ = useObservable(\"test\");\n  return (\n    <Reactive.div\n      // Change this\n      className$={() => \"...\"}\n      // to this\n      $className={() => \"...\"}\n    >\n      ...\n    </Reactive.div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Rendering with Switch Component in React\nDESCRIPTION: Shows how to use the Switch component from Legend-State for conditional rendering based on a value prop, with support for multiple cases and a default case.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/react/fine-grained-reactivity.mdx#2025-04-11_snippet_6\n\nLANGUAGE: jsx\nCODE:\n```\n<Switch value={state.index}>\n  {{\n    0: () => <div>Tab 1</div>,\n    1: () => <div>Tab 2</div>,\n    default: () => <div>Error</div>,\n  }}\n</Switch>\n```\n\n----------------------------------------\n\nTITLE: Creating local observable state with useObservable hook\nDESCRIPTION: The useObservable hook creates an observable within a React component, useful for component-specific state or managing multiple values. The observables must be tracked separately for re-rendering.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/react/react-API.mdx#2025-04-11_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nimport { observer, useObservable } from \"@legendapp/state/react\"\n\nconst Component = function Component() {\n    const state$ = useObservable({\n        title: 'Title',\n        first: '',\n        last: '',\n        profile: {...}\n    })\n\n    const fullname$ = useObservable(() => `${state$.fname.get()} ${state$.lname.get()}`)\n\n    return (\n        <div>\n            <div>{fullname$}</div>\n            <Input text={state$.first} />\n            <Input text={state$.last} />\n            <Profile name={fullname$} />\n        </div>\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Persisting an Observable with Local Storage\nDESCRIPTION: Example of persisting an observable object using the persistObservable function with a unique local name. This persists the entire store$ observable to the local storage mechanism configured globally.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/guides/persistence.mdx#2025-04-11_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport { persistObservable } from '@legendapp/state/persist'\n\nconst store$ = observable({ store: { bigObject: { ... } } })\n\n// Persist this observable\npersistObservable(store$, {\n    local: 'store' // Unique name\n})\n```\n\n----------------------------------------\n\nTITLE: Modifying Observables with set()\nDESCRIPTION: Shows different ways to use the set() method to modify observables, including direct value setting, setting with a function based on previous value, and setting values in undefined nested paths.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/usage/observable.mdx#2025-04-11_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nconst state$ = observable({ text: \"hi\" })\n\n// Set directly\nstate$.text.set(\"hello there\")\n\n// Set with a function relative to previous value\nstate$.text.set((prev) => prev + \" there\")\n\n// Set will automatically fill out objects that were undefined\nstate$.otherKey.otherProp.set(\"hi\")\n```\n\n----------------------------------------\n\nTITLE: Using useEffectOnce hook for guaranteed single execution\nDESCRIPTION: The useEffectOnce hook is a workaround for useEffect in development mode, ensuring the effect only runs once regardless of React's double-rendering behavior in development.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/react/react-API.mdx#2025-04-11_snippet_10\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useEffectOnce } from \"@legendapp/state/react\";\n\nconst Component = () => {\n  useEffectOnce(() => {\n    console.log(\"mounted\");\n  }, []);\n};\n```\n\n----------------------------------------\n\nTITLE: Multi-Property Transition Animation\nDESCRIPTION: Complex animation example with multiple properties and different transition types for each property.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/motion/src/content/docs/2-usage/1-overview.mdx#2025-04-11_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\n<Motion.View\n  animate={{\n    x: value * 100,\n    opacity: value ? 1 : 0.2,\n    scale: value ? 1 : 0.5,\n  }}\n  transition={{\n    default: {\n      type: \"spring\",\n      damping: 20,\n      stiffness: 300,\n    },\n    x: {\n      type: \"spring\",\n      damping: 20,\n      stiffness: 1000,\n    },\n    opacity: {\n      type: \"tween\",\n      duration: 1000,\n    },\n  }}\n/>\n```\n\n----------------------------------------\n\nTITLE: Creating computed observables with useComputed hook in React\nDESCRIPTION: The useComputed hook creates a computed observable that automatically updates when its dependencies change. It's similar to useObservable but specifically for derived values.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/react/react-API.mdx#2025-04-11_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\nimport { observable } from \"@legendapp/state\";\nimport { useComputed, Memo } from \"@legendapp/state/react\";\n\nconst state$ = observable({ test: 10, test2: 20 });\n\nfunction Component() {\n  const sum = useComputed(() => state$.test.get() + state$.test2.get());\n\n  return <div>Sum: <Memo>{sum}</Memo></div>;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Local Storage Persistence in React\nDESCRIPTION: Configuration for using LocalStorage as the persistence layer in a React application with Legend-State. This sets up the global configuration for the ObservablePersistLocalStorage plugin.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/guides/persistence.mdx#2025-04-11_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { configureObservablePersistence } from '@legendapp/state/persist'\nimport { ObservablePersistLocalStorage } from '@legendapp/state/persist-plugins/local-storage'\n\n// Global configuration\nconfigureObservablePersistence({\n    pluginLocal: ObservablePersistLocalStorage\n})\n```\n\n----------------------------------------\n\nTITLE: Using Observer Pattern with Legend-State in React\nDESCRIPTION: Demonstrates how to use the observer wrapper to create reactive components that efficiently track observable changes.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/react/react-introduction.mdx#2025-04-11_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport { observable } from \"@legendapp/state\";\nimport { observer } from \"@legendapp/state/react\";\n\nconst state$ = observable({ count: 0 });\n\nconst Component = observer(function Component() {\n  // Accessing state$ automatically makes this component track changes to re-render\n  const count = state$.count.get();\n\n  // Re-renders whenever count changes\n  return <div>{count}</div>;\n});\n```\n\n----------------------------------------\n\nTITLE: Component lifecycle hooks in Legend-State: useUnmount\nDESCRIPTION: The useUnmount hook is a convenience wrapper around useEffect that runs a callback when a component unmounts, avoiding the need for empty dependency arrays and cleanup functions.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/react/react-API.mdx#2025-04-11_snippet_9\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useUnmount } from \"@legendapp/state/react\";\n\nconst Component = () => {\n  useUnmount(() => console.log(\"un-mounted\"));\n};\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Animated Components with createMotionComponent in JavaScript\nDESCRIPTION: This snippet demonstrates how to use the createMotionComponent function to create an animated version of a custom component. It imports createMotionComponent from @legendapp/motion and applies it to an Animated.View component to add animation capabilities.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/motion/src/content/docs/2-usage/4-custom-components.mdx#2025-04-11_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createMotionComponent } from \"@legendapp/motion\";\n\nconst AnimatedView = createMotionComponent(Animated.View);\n```\n\n----------------------------------------\n\nTITLE: Adding Function Methods to Observables\nDESCRIPTION: Shows how to add custom function methods to observables for additional behavior, such as toggling boolean values with custom side effects.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/usage/observable.mdx#2025-04-11_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nconst state$ = observable({\n    isReady: false,\n    toggle: () => {\n        state$.isReady.toggle()\n        console.log('set to', state$.isReady.get())\n    }\n})\n```\n\n----------------------------------------\n\nTITLE: Using peek() with Observables\nDESCRIPTION: This snippet demonstrates how to use peek() to access the raw value of an observable without tracking it within an observing context.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/usage/observable.mdx#2025-04-11_snippet_3\n\n\n\n----------------------------------------\n\nTITLE: Using assign() for Shallow Object Updates\nDESCRIPTION: Demonstrates how to use the assign() method for shallow object updates, similar to Object.assign(), to set multiple properties at once while batching updates for efficient rendering.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/usage/observable.mdx#2025-04-11_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nconst state$ = observable({ text: \"hi\", text2: \"there\" })\n\n// Assign\nstate$.assign({\n    text: \"hi!\" ,\n    text2: \"there!\"\n})\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Events in Legend-State (JavaScript)\nDESCRIPTION: Shows how to create and use events in Legend-State. Events are observables without a value, useful for simple events like onClosed.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/usage/observable.mdx#2025-04-11_snippet_23\n\nLANGUAGE: javascript\nCODE:\n```\nimport { event } from \"@legendapp/state\"\n\nconst onClosed$ = event()\n\n// Simply pass a callback to the `onChange` function\nonClosed$.onChange(() => { ... })\n\n// Or use 'on' which is an alias of `onChange`\nonClosed$.on(() => { ... })\n\n// Dispatch the event to call listeners\nonClosed$.fire()\n```\n\n----------------------------------------\n\nTITLE: Migrating Change Functions to Observe/When in JavaScript\nDESCRIPTION: Demonstrates how to replace deprecated change functions (onTrue, onHasValue, onEquals, onChangeShallow) with the new 'observe' and 'when' functions for tracking observable changes.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/other/migrating.mdx#2025-04-11_snippet_32\n\nLANGUAGE: javascript\nCODE:\n```\nimport { observe, when } from \"@legendapp/state\";\n\nconst obs = observable({ value: undefined });\n\n// onTrue\nobs.value.onTrue(handler);\n// New onTrue equivalent\nwhen(() => obs.value === true, handler);\n\n// onHasValue\nobs.value.onHasValue(\"text\", handler);\n// onHasValue equivalent\nwhen(() => obs.value, handler);\n\n// onEquals\nobs.value.onEquals(\"text\", handler);\n// onEquals equivalent\nwhen(() => obs.value === \"text\", handler);\n\n// onChangeShallow\nobs.value.onChangeShallow(handler);\n// onChangeShallow equivalent\nobs.value.onChange(handler, { shallow: true });\n```\n\n----------------------------------------\n\nTITLE: Using assign() with Observables\nDESCRIPTION: This snippet demonstrates how to use assign() for shallow object merging with observables, similar to Object.assign().\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/usage/observable.mdx#2025-04-11_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nconst state$ = observable({ text: \"hi\" });\n\n// Assign\nstate$.assign({ text: \"hi2\" });\n```\n\n----------------------------------------\n\nTITLE: Using Shallow Modifiers for Improved Performance in Legend-State\nDESCRIPTION: Shows how to use shallow tracking with get(true) to optimize performance by only updating when array items change instead of when their properties change.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/usage/reactivity.mdx#2025-04-11_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nconst state$ = observable({ messages: [] });\n\nobserve(() => {\n  // Only need this to update when messages added/removed\n  const messages = state$.messages.get(true);\n\n  console.log(\"Latest message\", messages[0]);\n});\n```\n\n----------------------------------------\n\nTITLE: Using use$ hook with Legend State observables\nDESCRIPTION: Shows the new recommended pattern for consuming observable values in React components using the use$ hook, which replaces the previous observer and get() pattern.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/other/migrating.mdx#2025-04-11_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nconst state$ = observable({ value: 10 })\nconst Component = () => {\n    const value = use$(state$.value)\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Rendering with Show Component in React\nDESCRIPTION: Demonstrates how to use the Show component from Legend-State for conditional rendering in React, including the use of if/else props and optional wrapping components.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/react/fine-grained-reactivity.mdx#2025-04-11_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\n<Show\n  if={state.show}\n  else={() => <div>Nothing to see here</div>}\n  wrap={AnimatePresence}\n>\n  {() => <Modal />}\n</Show>\n```\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Show, useObservable } from \"@legendapp/state/react\";\nimport { AnimatePresence } from \"framer-motion\";\n\nfunction ShowExampleWithSelector() {\n  const state$ = useObservable({ collection: [] });\n  return (\n    <Show\n      if={() => state$.collection.get().length > 0}\n      else={() => <div>Nothing to see here</div>}\n      wrap={AnimatePresence}\n    >\n      {() => <Modal />}\n    </Show>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using useTraceUpdates Hook in React\nDESCRIPTION: Shows how to use useTraceUpdates() to log information about observable changes that trigger component renders. Useful for debugging unnecessary renders.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/react/tracing.mdx#2025-04-11_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useTraceUpdates } from \"@legendapp/state/trace\";\n\nconst Component = observer(function Component(props) {\n  // Call useTraceUpdates anywhere inside the component\n  useTraceUpdates();\n\n  const count = use$(state$.count)\n\n  return <div>{count}</div>;\n\n  /* This logs:\n\n    [legend-state] Rendering because \"count\" changed:\n    from: 0\n    to: 1\n\n    */\n});\n```\n\n----------------------------------------\n\nTITLE: Using get() with Observables\nDESCRIPTION: This snippet demonstrates how to use get() to access the raw value of an observable. It shows the difference between the observable proxy and the underlying data, and how get() can be used with tracking parameters.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/usage/observable.mdx#2025-04-11_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst profile = { name: \"Test user\" };\nconst state$ = observable({ profile: profile, test: 0 });\n\n// The raw value is unchanged\nstate$.profile.get(); // { name: 'Test user' }\nstate$.profile === profile; //  false. The observable is not strictly equal to profile.\nstate$.profile.get() === profile; //  true. The raw data is exactly what was set.\n```\n\nLANGUAGE: javascript\nCODE:\n```\nconst state$ = observable({ data: someHugeThing });\nconst { data } = state$.get();\n\n// Nothing special happens when working with the raw data\nprocessData(data);\n```\n\nLANGUAGE: javascript\nCODE:\n```\nstate$.get(true); // Create a shallow listener\n```\n\n----------------------------------------\n\nTITLE: Tracking Observable Change History with trackHistory in JavaScript\nDESCRIPTION: Shows how to use trackHistory to create an observable that tracks all changes in the target observable, including previous values at the time of change. This can be useful for implementing undo functionality or version history in applications.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/usage/helper-functions.mdx#2025-04-11_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { observable } from '@legendapp/state'\nimport { trackHistory } from '@legendapp/state/history'\n\nconst state$ = observable({ profile: { name: 'Hello' }})\n\n// Track all changes to state\nconst history = trackHistory(state$)\n\n// Change something in state\nstate$.profile.name.set('Annyong')\n\n// History shows the previous value when it changed:\n{\n    1666593133018: {\n        profile: {\n            name: 'Hello'\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Memo Component for Independent Children in React\nDESCRIPTION: Shows how to use the Memo component from Legend-State to optimize rendering of children that are completely independent from the parent component.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/react/fine-grained-reactivity.mdx#2025-04-11_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nfunction Component() {\n  return (\n    <Memo>\n      {() =>\n        state.messages.map((message) => (\n          <div key={message.id}>\n            {message.text} {localVar}\n          </div>\n        ))\n      }\n    </Memo>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Card Grid Layout with Starlight Components\nDESCRIPTION: Creates a responsive grid of cards with the CardGrid and Card components, displaying next steps for users to follow after setting up their Starlight documentation site.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/motion/src/content/docs/index.mdx#2025-04-11_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n<CardGrid stagger>\n\t<Card title=\"Update content\" icon=\"pencil\">\n\t\tEdit `src/content/docs/index.mdx` to see this page change.\n\t</Card>\n\t<Card title=\"Add new content\" icon=\"add-document\">\n\t\tAdd Markdown or MDX files to `src/content/docs` to create new pages.\n\t</Card>\n\t<Card title=\"Configure your site\" icon=\"setting\">\n\t\tEdit your `sidebar` and other config in `astro.config.mjs`.\n\t</Card>\n\t<Card title=\"Read the docs\" icon=\"open-book\">\n\t\tLearn more in [the Starlight Docs](https://starlight.astro.build/).\n\t</Card>\n</CardGrid>\n```\n\n----------------------------------------\n\nTITLE: Configuring Draw Distance in Legend List (TypeScript)\nDESCRIPTION: The drawDistance prop defines the buffer size in pixels rendered above and below the viewport. Increasing this value can reduce blank space during fast scrolling, but may impact performance if items are computationally expensive to render.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/api/performance.mdx#2025-04-11_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ndrawDistance?: number\n```\n\n----------------------------------------\n\nTITLE: Working with Undefined Observable Values\nDESCRIPTION: This snippet demonstrates how observables track paths rather than data, allowing access to undefined values. It shows setting up listeners for fields that don't exist yet and setting values within undefined objects.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/usage/observable.mdx#2025-04-11_snippet_13\n\nLANGUAGE: jsx\nCODE:\n```\nconst state$ = observable({ user: undefined });\n\nwhen(state$.user.uid, (uid) => {\n  // Handle login\n});\n```\n\nLANGUAGE: jsx\nCODE:\n```\nconst state$ = observable({ user: undefined });\n\nobserve(() => {\n  // This will be undefined until the full user profile is set\n  console.log(`Name: ${state$.user.profile.name.get()}`);\n});\n\nstate$.user.profile.name.set(\"Annyong\");\n\n// state$ == { user: { profile: { name: 'Annyong' } } }\n```\n\n----------------------------------------\n\nTITLE: Batching Dependent Observable Changes\nDESCRIPTION: Illustrates the importance of batching when observables depend on each other. This prevents intermediate states and ensures computations are based on the final state of all changes.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/guides/performance.mdx#2025-04-11_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst name$ = observable({ first: \"\", last: \"\" });\n\nconst fullName = computed(() => `${name$.first} ${name$.last}`);\n\nobserve(() => console.log(\"fullName = \", fullName.get()));\n\n// Not batched:\nname$.first.set(\"First\");\nname$.last.set(\"Last\");\n//  fullName notifies its listeners with incomplete state\n// fullName = \"First \"\n// fullName = \"First Last\"\n\n// Batched:\nbatch(() => {\n  name$.first.set(\"First\");\n  name$.last.set(\"Last\");\n});\n//  fullName notifies only with final state\n// fullName = \"First Last\"\n```\n\n----------------------------------------\n\nTITLE: Deleting Properties with delete()\nDESCRIPTION: Shows how to use the delete() method to remove properties from observable objects or to set the whole value to undefined. Also demonstrates removing elements from arrays.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/usage/observable.mdx#2025-04-11_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nconst state$ = observable({ text: \"hi\" })\n\n// Delete text\nstate$.text.delete()\n\n// Set the whole value to undefined\nstate$.delete()\n```\n\n----------------------------------------\n\nTITLE: Handling Top of List with onStartReached\nDESCRIPTION: A callback triggered when scrolling within onStartReachedThreshold of the top. It resets when scrolling below the threshold. Useful for loading previous content.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/api/props.mdx#2025-04-11_snippet_28\n\nLANGUAGE: TypeScript\nCODE:\n```\nonStartReached?: ((info: { distanceFromStart: number }) => void) | null | undefined;\n```\n\n----------------------------------------\n\nTITLE: Setting Default Sync Configuration with configureSynced\nDESCRIPTION: Shows how to configure default options for sync plugins using configureSynced. This reduces duplication and enforces consistency by creating customized versions of plugins with preset defaults.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/persist-sync.mdx#2025-04-11_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { configureSynced, syncedCrud } from \"@legendapp/state/sync\"\nimport { ObservablePersistLocalStorage } from \"@legendapp/state/persist-plugins/local-storage\"\n\n// Configure the base `synced`\nconst syncPlugin = configureSynced({\n    persist: {\n        plugin: ObservablePersistMMKV\n    }\n})\n\n// Or configure options derived from another plugin\nconst syncPlugin = configureSynced(syncedCrud, {\n    persist: {\n        plugin: ObservablePersistMMKV\n    }\n})\n\n// Then using them will merge the options on top of the defaults.\nconst state$ = observable(syncPlugin({\n    persist: {\n        name: 'test',\n    }\n}))\n```\n\n----------------------------------------\n\nTITLE: Configuring Firebase Realtime Database Plugin\nDESCRIPTION: Shows how to configure the Firebase Realtime Database plugin with Legend State, including authentication requirements, path configuration, and data transformation options.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/guides/persistence.mdx#2025-04-11_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\nimport { ObservablePersistLocalStorage } from \"@legendapp/state/persist-plugins/local-storage\"\nimport { ObservablePersistFirebase } from \"@legendapp/state/persist-plugins/firebase\"\nimport { persistObservable } from \"@legendapp/state/persist\"\n\npersistObservable(state.user, {\n  pluginLocal: ObservablePersistLocalStorage,\n  local: {\n    name: \"user\",\n  },\n  pluginRemote: ObservablePersistFirebase,\n  remote: {\n    transform: {\n      in: (value) => decrypt(value),\n      out: (value) => encrypt(value),\n    },\n    onSaveError: (err) => console.error(err),\n    firebase: {\n      refPath: (uid) => `/users/${uid}/`,\n      requireAuth: true,\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Wrapping External Library Components with Legend State\nDESCRIPTION: Demonstrates how to wrap external library components (e.g., Framer Motion) to make them reactive, allowing updates based on observables without re-rendering the parent component.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/react/fine-grained-reactivity.mdx#2025-04-11_snippet_12\n\nLANGUAGE: js\nCODE:\n```\nimport { reactive } from \"@legendapp/state/react\";\nimport { motion } from \"framer-motion\";\n\nconst ReactiveMotionDiv = reactive(motion.div);\n\nfunction Component() {\n  // This component renders only once\n  const width$ = useObservable(100);\n\n  return (\n    <ReactiveMotionDiv\n      $animate={() => ({\n        x: width$.get(),\n      })}\n    >\n      ...\n    </ReactiveMotionDiv>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring MMKV Persistence for React Native with Legend State\nDESCRIPTION: Instructions for setting up the MMKV persistence plugin for React Native applications using Legend State, which provides a high-performance storage solution.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/persist-sync.mdx#2025-04-11_snippet_19\n\nLANGUAGE: javascript\nCODE:\n```\nimport { syncObservable } from '@legendapp/state/sync'\nimport { ObservablePersistMMKV } from '@legendapp/state/persist-plugins/mmkv'\n\nsyncObservable(state$, {\n    persist: {\n        name: \"documents\",\n        plugin: ObservablePersistMMKV\n    }\n})\n```\n\n----------------------------------------\n\nTITLE: Using useObservableReducer hook for Redux-like state management\nDESCRIPTION: The useObservableReducer hook works similarly to React's useReducer but sets an observable rather than triggering a render, providing a Redux-like pattern with Legend-State's reactivity.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/react/react-API.mdx#2025-04-11_snippet_6\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useObservableReducer } from \"@legendapp/state/react\"\n\nconst Component = () => {\n    // Only re-renders if the return value changes\n    const isSelected$ = useObservableReducer()\n\n    // Get the value of the reducer\n    const theme = isSelected$.get()\n\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Array Optimizations in React JSX\nDESCRIPTION: Shows how to opt-in to array optimizations using the 'For' component with the 'optimized' prop in React JSX.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/other/migrating.mdx#2025-04-11_snippet_29\n\nLANGUAGE: jsx\nCODE:\n```\nconst obs = observable({ items: [] });\n\nconst Row = observer(function Row({ item }) {\n  return <div>{item.text}</div>;\n});\n\nconst List = observer(function () {\n  // The optimized prop enables the optimizations which were previously default\n  return <For each={list} item={Row} optimized />;\n});\n```\n\n----------------------------------------\n\nTITLE: Using the Fetch Plugin for Remote Persistence in Legend-State\nDESCRIPTION: Example of using the built-in Fetch plugin for remote persistence with Legend-State. This demonstrates a simplified way to connect an observable to remote endpoints for getting and setting data.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/guides/persistence.mdx#2025-04-11_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nimport { persistObservable } from \"@legendapp/state/persist\"\nimport { persistPluginQuery } from \"@legendapp/state/persist-plugins/query\"\n\nconst state$ = observable({ name: '' })\n\npersistObservable(state$, {\n  pluginRemote: persistPluginFetch({\n    get: 'https://url.to.get',\n    set: 'https://url.to.set'\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Creating Proxy Observables\nDESCRIPTION: This snippet demonstrates creating a proxy observable that generates computed observables for each key accessed. This allows dynamically referencing parts of state based on a selector.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/usage/observable.mdx#2025-04-11_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\nimport { observable, proxy } from \"@legendapp/state\"\n\nconst state$ = observable({\n  selector: 'text',\n  items: { test1: { text: 'hi', othertext: 'bye' }, test2: { text: 'hello', othertext: 'goodbye' } },\n    itemText: proxy((key) => {\n    return state$.items[key][obs.selector.get()];\n  }),\n});\n\n// Now these reference the same thing:\nstate$.items.test1.text.get()\nstate$.itemText.test1.get()\n```\n\n----------------------------------------\n\nTITLE: Encryption Transform Example\nDESCRIPTION: Shows how to implement end-to-end encryption using data transforms.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/persist-sync.mdx#2025-04-11_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport { combineTransforms, transformStringifyDates } from '@legendapp/state/sync'\nconst state$ = observable(synced({\n    get: () => {/* ... */},\n    transform: {\n        load: async (value) => {\n            return decrypt(value)\n        },\n        save: async (value) => {\n            return encrypt(value)\n        }\n    }\n}))\n```\n\n----------------------------------------\n\nTITLE: Enabling maintainVisibleContentPosition for Stable Scrolling\nDESCRIPTION: Adjusts item positions when items are added/removed/resized above the viewport to prevent visible content from shifting. Useful for dynamic content but adds overhead.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/api/props.mdx#2025-04-11_snippet_22\n\nLANGUAGE: TypeScript\nCODE:\n```\nmaintainVisibleContentPosition?: boolean;\n```\n\n----------------------------------------\n\nTITLE: Creating Two-Way Computed Observables\nDESCRIPTION: This snippet shows how to create a two-way computed observable that can both read from and write to its dependencies. The set parameter allows changes to flow back to the source observables.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/usage/observable.mdx#2025-04-11_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nconst selected$ = observable([false, false, false]);\nconst selectedAll$ = computed(\n  // selectedAll is true when every element is selected\n  () => selected$.every((val$) => val$.get()),\n\n  // setting selectedAll sets the value of every element\n  (value) => selected$.forEach((val$) => val$.set(value))\n);\n\nselectedAll$.set(true);\n// selected.get() === [true, true, true]\n```\n\n----------------------------------------\n\nTITLE: Creating Linked Observables\nDESCRIPTION: This snippet demonstrates creating a two-way link to a target observable by returning an observable from a computed function. Operations and listeners on the link behave the same as on the original target.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/usage/observable.mdx#2025-04-11_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nconst state$ = observable({\n  items: [\"hi\", \"there\", \"hello\"],\n  selectedIndex: 0,\n  selectedItem: computed(() => state$.items[state$.selectedIndex.get()]),\n});\n\nstate$.selectedItem.get() === \"hi\"; // true\n\nstate$.selectedIndex.set(2);\n\nstate$.selectedItem.get() === \"hello\"; // true\n```\n\n----------------------------------------\n\nTITLE: Implementing Persistence and Sync in Legend-State\nDESCRIPTION: Shows how to set up persistence and synchronization with a backend using Legend-State. This example demonstrates configuring local storage persistence and defining get/set operations for server synchronization.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/intro/why.mdx#2025-04-11_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nimport { ObservablePersistLocalStorage } from '@legendapp/state/persist-plugins/local-storage'\nimport { synced } from '@legendapp/state/sync'\nimport { observable } from '@legendapp/state'\n\nconst state$ = observable({\n    initial: {\n        { bigObject: { ... } }\n    },\n    get: () => fetch('url').then(res => res.json()),\n    set: ({ value }) =>\n        fetch('https://url.to.set', { method: 'POST', data: JSON.stringify(value) }),\n    persist: {\n        name: 'test'\n    }\n})\n```\n\n----------------------------------------\n\nTITLE: Migrating from proxy to functions with parameters\nDESCRIPTION: Shows how to migrate from the proxy pattern to using functions with string parameters directly in observables, which simplifies the API while maintaining the same functionality.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/other/migrating.mdx#2025-04-11_snippet_10\n\nLANGUAGE: ts\nCODE:\n```\n// Change\nconst state$ = observable({\n    items: { test1: { text: 'hi' }, test2: { text: 'hello' } },\n    itemText: proxy((key) => {\n        return state$.items[key]['text'];\n    })\n})\n// To\nconst state$ = observable({\n    items: { test1: { text: 'hi' }, test2: { text: 'hello' } },\n    texts: (key: string) => {\n        return state$.items[key]['text']\n    }\n})\n```\n\n----------------------------------------\n\nTITLE: Adding New Elements with Local IDs in Legend-State\nDESCRIPTION: Demonstrates how to add new elements to an observable with a locally generated ID before it has been created on the server, allowing immediate local usage of the data.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/keel.mdx#2025-04-11_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Message } from './keelClient'\nimport { observable } from '@legendapp/state'\nimport { generateKeelId, syncedKeel } from '@legendapp/state/sync-plugins/keel'\n\n\nconst profile$ = observable(syncedKeel({\n    get: queries.getProfile,\n    create: mutations.createProfile,\n    update: mutations.updateProfile,\n    delete: mutations.deleteProfile,\n}))\n\nfunction addMessage(text: string) {\n    const id = generateKeelId()\n    // Add keyed by id to the messages$ observable\n    messages$[id].set({\n        id,\n        text,\n        createdAt: undefined,\n        updatedAt: undefined\n    })\n}\naddMessage('test')\n```\n\n----------------------------------------\n\nTITLE: Using ObservableHint.opaque in Legend-State\nDESCRIPTION: Demonstrates how to use ObservableHint.opaque to mark an object in an observable as opaque, causing it to be treated as a primitive. This prevents properties inside the object from becoming observable, which is useful for DOM elements or other large objects where property tracking isn't needed.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/usage/helper-functions.mdx#2025-04-11_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { observable, ObservableHint } from '@legendapp/state'\n\nconst state$ = observable({ text: 'hi', body: ObservableHint.opaque(document.body) })\n```\n\n----------------------------------------\n\nTITLE: Using pageHashParams Observable for URL Parameter Management\nDESCRIPTION: Shows how to use pageHashParams to manage URL hash parameters as observables.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/react/helpers-and-hooks.mdx#2025-04-11_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { pageHashParams, configurePageHash } from '@legendapp/state/helpers/pageHashParams'\n\nobserve(() => {\n    console.log('userid param changed to': pageHashParams.userid.get())\n})\n\npageHashParams.userid.set('newuser')\n// location.hash == \"#userid=newuser\"\n```\n\n----------------------------------------\n\nTITLE: Migrating from useSelector to use$ in React with Legend State\nDESCRIPTION: Shows how to migrate from the old useSelector hook to the new use$ hook, which is functionally equivalent but has a new name to avoid confusion with selector patterns from other libraries.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/other/migrating.mdx#2025-04-11_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\n//  From\nconst value = useSelector(state$.value)\n//  To\nconst value = use$(state$.value)\n```\n\n----------------------------------------\n\nTITLE: Configuring Babel Plugin for Legend State\nDESCRIPTION: Instructions for adding the Legend State Babel plugin to the project's Babel configuration.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/react/fine-grained-reactivity.mdx#2025-04-11_snippet_9\n\nLANGUAGE: js\nCODE:\n```\nmodule.exports = {\n  plugins: [\"@legendapp/state/babel\"],\n};\n```\n\n----------------------------------------\n\nTITLE: Observable Change Debugging in JavaScript\nDESCRIPTION: Example of how to debug observable changes by adding custom change listeners with console logging and debugger statements.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/react/tracing.mdx#2025-04-11_snippet_4\n\nLANGUAGE: js\nCODE:\n```\n// Why is count rendering so often?\nstate.count.onChange(({ value }) => {\n  console.log(\"Count changed\", value);\n  console.trace();\n  debugger;\n});\n```\n\n----------------------------------------\n\nTITLE: Using createObservableHook for Custom Hook Conversion\nDESCRIPTION: Demonstrates how to convert existing hooks to return observables using createObservableHook.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/react/helpers-and-hooks.mdx#2025-04-11_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createObservableHook } from \"@legendapp/state/react-hooks/createObservableHook\"\n\nconst useMyHookObservable = createObservableHook(useMyHook)\n\nfunction Component() {\n    const value = useMyHookObservable()\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing pageHash Observable for URL Hash Management\nDESCRIPTION: Demonstrates using pageHash observable to track and update the URL hash, with configuration options for state management.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/react/helpers-and-hooks.mdx#2025-04-11_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { pageHash, configurePageHash } from '@legendapp/state/helpers/pageHash'\n\nconfigurePageHash({ setter: 'pushState' })\n\nobserve(() => {\n    console.log('hash changed to': pageHash.get())\n})\n\npageHash.set('value=test')\n// location.hash == \"#value=test\"\n```\n\n----------------------------------------\n\nTITLE: Using get() for tracking observables\nDESCRIPTION: Example of using the get() method to retrieve and track the value of an observable. This is a fundamental way to work with observables in Legend-State.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/usage/reactivity.mdx#2025-04-11_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst theme = state.settings.theme.get();\n//  Tracking [state.settings.theme]\n```\n\n----------------------------------------\n\nTITLE: Adding ListFooterComponent to List Bottom\nDESCRIPTION: Renders a component at the bottom of all list items. Can be used for loading indicators, pagination controls, or additional information.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/api/props.mdx#2025-04-11_snippet_17\n\nLANGUAGE: TypeScript\nCODE:\n```\nListFooterComponent?: React.ComponentType<any> | React.ReactElement | null | undefined;\n```\n\n----------------------------------------\n\nTITLE: Simple Animation Implementation\nDESCRIPTION: Demonstrates basic animation using the animate prop with x-axis movement.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/motion/src/content/docs/2-usage/1-overview.mdx#2025-04-11_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n<Motion.View\n  animate={{\n    x: value * 100,\n  }}\n/>\n```\n\n----------------------------------------\n\nTITLE: Creating Observable Hook with createObservableHook\nDESCRIPTION: Demonstrates how to convert existing hooks to return observables using createObservableHook.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/react/helpers-and-hooks.mdx#2025-04-11_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createObservableHook } from \"@legendapp/state/react-hooks/createObservableHook\"\n\nconst useMyHookObservable = createObservableHook(useMyHook)\n\nfunction Component() {\n    const value = useMyHookObservable()\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Multiple Atom States in Legend-State\nDESCRIPTION: Shows an alternative approach to state management using multiple individual observable atoms spread across different files.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/intro/getting-started.mdx#2025-04-11_snippet_6\n\nLANGUAGE: js\nCODE:\n```\n// settings.ts\nexport const theme$ = observable('light')\nexport const fontSize$ = observable(14)\n\n// UIState.ts\nexport const uiState$ = observable({\n    windowSize: undefined as { width: number, height: number },\n    activeTab: 'home' as 'home' | 'user' | 'profile',\n})\n```\n\n----------------------------------------\n\nTITLE: Using Observe with Reaction Functions in Legend-State\nDESCRIPTION: Shows how to observe changes to state with a reaction function that runs when the observed value changes, using both a direct observable reference and a selector function.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/usage/reactivity.mdx#2025-04-11_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n// Observe the return value of a selector and observe all accessed observables\nobserve(state$.isOnline, (e) => {\n  console.log(\"Online status\", e.value);\n});\n// Observe the return value of a selector and observe all accessed observables\nobserve(\n  () => state$.isOnline.get() && state$.user.get(),\n  (e) => {\n    console.log(\"Signed in status\", e.value);\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Safety Levels in JavaScript Observable Creation\nDESCRIPTION: Shows the three safety levels (Unsafe, Default, and Safe) for creating observables in Legend State, including examples of allowed and disallowed operations for each level.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/other/migrating.mdx#2025-04-11_snippet_27\n\nLANGUAGE: javascript\nCODE:\n```\n// 1. Unsafe: Use false for the previous unsafe behavior\nconst obs = observable({ ... }, /*safe*/ false)\n\n// 2. Default: The new default behavior prevent directly assigning to objects, but allows directly assining to primitives\nconst obs = observable({ text: 'hello',  obj: {} })\n\nobs.text = 'hi'\n//  Setting a primitive works in default mode but not in safe mode.\n\nobs.obj = {}\n//  Error. Cannot assign to objects directly.\n\n// 3. Safe: Safe mode prevents all direct assignment\nconst obs = observable({ text: 'hello',  obj: {} }, /*safe*/true)\n\nobs.text = 'hi'\n//  Error. Cannot assign directly in safe mode.\n```\n\n----------------------------------------\n\nTITLE: Updating Primitive Observable Access in JavaScript\nDESCRIPTION: Shows the change from using 'current' to 'value' for accessing and modifying primitive observables, allowing direct modification of the 'value' property.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/other/migrating.mdx#2025-04-11_snippet_33\n\nLANGUAGE: javascript\nCODE:\n```\nconst obs = observable(10);\n// Before\nobs.current === 10;\nobs.curent = 20; //  Error\n// Now\nobs.value === 10;\nobs.value = 20; //  Works\n```\n\n----------------------------------------\n\nTITLE: Batching Dependent Observable Updates\nDESCRIPTION: Shows how batching prevents intermediate state updates when dealing with dependent observables. Compares batched vs non-batched approaches when updating related state properties.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/usage/reactivity.mdx#2025-04-11_snippet_13\n\nLANGUAGE: javascript\nCODE:\n```\nconst name$ = observable({ first: \"\", last: \"\" });\n\nconst fullName = observable(() => `${name$.first} ${name$.last}`);\n\nobserve(() => console.log(\"fullName = \", fullName.get()));\n\n// Not batched:\nname$.first.set(\"First\");\nname$.last.set(\"Last\");\n//  fullName notifies its listeners with incomplete state\n// fullName = \"First \"\n// fullName = \"First Last\"\n\n// Batched:\nbatch(() => {\n  name$.first.set(\"First\");\n  name$.last.set(\"Last\");\n});\n//  fullName notifies only with final state\n// fullName = \"First Last\"\n```\n\n----------------------------------------\n\nTITLE: Advanced onChange with Options in Legend-State\nDESCRIPTION: Shows the full range of options available with onChange, including tracking previous values, handling batched changes, and controlling when callbacks are executed.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/usage/reactivity.mdx#2025-04-11_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\n// Full example\nstate$.onChange(\n  ({ value, getPrevious, changes }) => {\n    const prev = getPrevious();\n    changes.forEach(({ path, valueAtPath, prevAtPath }) => {\n      console.log(valueAtPath, \"changed at\", path, \"from\", prevAtPath);\n    });\n  },\n  { initial: true, trackingType: true }\n);\n```\n\n----------------------------------------\n\nTITLE: Creating Reactive Components with Legend State in React\nDESCRIPTION: Demonstrates how to use the reactive function to create reactive versions of components with observable props.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/react/fine-grained-reactivity.mdx#2025-04-11_snippet_11\n\nLANGUAGE: js\nCODE:\n```\nimport { observable } from \"@legendapp/state\";\nimport { reactive } from \"@legendapp/state/react\";\n\nconst isSignedIn$ = observable(false);\n\nconst Component = reactive(function Component({ message }) {\n  return <div>{message}</div>;\n});\n\nfunction App() {\n  return (\n    <Component $message={() => isSignedIn$.get() ? \"Hello\" : \"Goodbye\"} />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Chat Interface with Legend List in React\nDESCRIPTION: Example implementation of a chat interface using Legend List component. This code shows how to render a list of chat messages that align at the bottom of the screen and maintain scroll position when new messages are added.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/examples/chatInterfaces.mdx#2025-04-11_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n<LegendList\n  data={items}\n  renderItem={({ item }) => <Text>{item.title}</Text>}\n  estimatedItemSize={320}\n  alignItemsAtEnd\n  maintainScrollAtEnd\n  maintainScrollAtEndThreshold={0.1}\n/>\n```\n\n----------------------------------------\n\nTITLE: Tracking Visible Items with onViewableItemsChanged\nDESCRIPTION: Called when the viewability of items changes according to the viewabilityConfig prop. Useful for analytics or lazy loading of content.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/api/props.mdx#2025-04-11_snippet_30\n\nLANGUAGE: TypeScript\nCODE:\n```\nonViewableItemsChanged?: OnViewableItemsChanged | undefined;\n```\n\n----------------------------------------\n\nTITLE: Using Different Observable Tracking Approaches in Legend-State\nDESCRIPTION: Demonstrates various ways to track observable state changes in Legend-State, including proper and improper tracking methods through get(), object references, and array operations.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/usage/reactivity.mdx#2025-04-11_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst state$ = observable({\n  settings: {\n    theme: \"dark\",\n  },\n  chats: {\n    messages: [{ id: 0, text: \"hi\" }],\n  },\n});\n\nobserve(() => {\n  // Example 1:\n  const theme = state$.settings.theme.get();\n  //  Tracking [state$.settings.theme] because of get()\n\n  // Example 2:\n  const settings = state$.settings;\n  //  Not tracking because it's an object\n\n  const theme = settings.theme.get();\n  //  Tracking [state$.settings.theme] because of get()\n\n  // Example 3:\n  const theme$ = state$.settings.theme;\n  //  Not tracking with no get()\n\n  // Example 4:\n  state$.chats.messages.map((m) => <Message key={m.peek().id} message={m} />);\n  //  Tracking [state$.chats.messages (shallow)] because of map()\n\n  // Example 5:\n  Object.keys(state$.settings);\n  //  Tracking [state$.settings (shallow)]\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing useHover Hook with Legend-State\nDESCRIPTION: Demonstrates the useHover hook for tracking element hover states reactively.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/react/helpers-and-hooks.mdx#2025-04-11_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Show } from \"@legendapp/state/react\";\nimport { useHover } from \"@legendapp/state/react-hooks/useHover\";\nimport { useRef } from \"react\";\n\nfunction ButtonWithTooltip() {\n  const refButton = useRef();\n  const isHovered = useHover(refButton);\n\n  return (\n    <div>\n      <button ref={refButton}>Click me</button>\n      <Show if={isHovered}>\n        {() => <Tooltip text=\"Tooltip!\" target={refButton} />}\n      </Show>\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Reactive Components with Legend State\nDESCRIPTION: Shows how to use the 'reactive' wrapper to create reactive versions of component props, allowing components to accept reactive props while receiving regular props.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/react/fine-grained-reactivity.mdx#2025-04-11_snippet_11\n\nLANGUAGE: js\nCODE:\n```\nimport { observable } from \"@legendapp/state\";\nimport { reactive } from \"@legendapp/state/react\";\n\nconst isSignedIn$ = observable(false);\n\nconst Component = reactive(function Component({ message }) {\n  return <div>{message}</div>;\n});\n\nfunction App() {\n  return (\n    <Component $message={() => isSignedIn$.get() ? \"Hello\" : \"Goodbye\"} />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating from observer to use$ in React components\nDESCRIPTION: Demonstrates how to transition from using observer HOC with direct get() calls to using the new use$ hook pattern, which is better compatible with React Compiler optimizations.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/other/migrating.mdx#2025-04-11_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nconst state$ = observable({ value: 10 })\n\n// observer is now just an optional performance optimization\nconst Component = observer(() => {\n    //  The new way\n    const value = use$(state$.value)\n\n    //  The old way\n    const value = state$.value.get()\n})\n```\n\n----------------------------------------\n\nTITLE: Replacing Memo and Isolate Props with Components in React JSX\nDESCRIPTION: Demonstrates the change from using 'memo' and 'computed' props to using explicit Memo and Computed components for better clarity in React components.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/other/migrating.mdx#2025-04-11_snippet_36\n\nLANGUAGE: jsx\nCODE:\n```\n// Before\n<div memo>...</div>\n<div computed>...</div>\n\n// Now\n<Memo><div>...</div></Memo>\n<Computed><div>...</div></Computed>\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Synced Observable with Remote and Local Persistence\nDESCRIPTION: Demonstrates creating a basic synced observable with remote fetch/save capabilities and local persistence using the synced helper function.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/persist-sync.mdx#2025-04-11_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nimport { observable } from '@legendapp/state'\nimport { synced } from '@legendapp/state/sync'\n\nconst state$ = observable(synced({\n    get: () =>\n        fetch('https://url.to.get').then((res) => res.json()),\n    set: ({ value }) =>\n        fetch('https://url.to.set', { method: 'POST', data: JSON.stringify(value) }),\n    persist: {\n        name: 'test',\n    },\n}))\n```\n\n----------------------------------------\n\nTITLE: Efficient Array Mapping in React with Legend-State\nDESCRIPTION: Shows how to efficiently map through an observable array in React using Legend-State. It emphasizes the use of peek() to prevent tracking observable properties during mapping.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/guides/performance.mdx#2025-04-11_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\nimport { observable } from \"@legendapp/state\";\nimport { For } from \"@legendapp/state/react\";\n\nconst state$ = observable({ arr: [{ id: 1, text: \"hi\" }] });\n\nfunction Row({ item }) {\n  return <div>{item.text}</div>;\n}\nfunction List() {\n  // Be sure to use peek() to make sure you don't track any observable fields here\n  return state$.arr.map((item) => <Row key={item.peek().id} item={item} />);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring AsyncStorage Persistence for React Native with Legend State\nDESCRIPTION: Example showing how to set up AsyncStorage persistence in React Native applications using Legend State, including global configuration and handling asynchronous loading.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/persist-sync.mdx#2025-04-11_snippet_20\n\nLANGUAGE: javascript\nCODE:\n```\nimport { configureSynced, syncObservable } from '@legendapp/state/sync'\nimport { observablePersistAsyncStorage } from '@legendapp/state/persist-plugins/async-storage'\nimport AsyncStorage from '@react-native-async-storage/async-storage'\n\n// Global configuration\nconst persistOptions = configureSynced({\n    persist: {\n        plugin: observablePersistAsyncStorage({\n            AsyncStorage\n        })\n    }\n})\nsyncObservable(state$, persistOptions({\n    persist: {\n        name: 'store'\n    }\n}))\n```\n\n----------------------------------------\n\nTITLE: Implementing List Operations with syncedCrud in TypeScript\nDESCRIPTION: Example showing how to use syncedCrud with list operations for managing multiple items. Demonstrates setup for handling collections of profiles with list, create, update, and delete functionality.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/crud.mdx#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst profiles$ = observable(syncedCrud({\n    list: listProfiles,\n    create: createProfile,\n    update: updateProfile,\n    delete: deleteProfile,\n}))\n// profile$.get() is a Record<string, Profile>\n```\n\n----------------------------------------\n\nTITLE: Recommended Keel Model Structure for Legend-State\nDESCRIPTION: Shows the recommended Keel model structure for use with Legend-State, including handling of required fields, changeable fields, and the updateAt parameter.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/keel.mdx#2025-04-11_snippet_7\n\nLANGUAGE: keel\nCODE:\n```\nmodel Message {\n    fields {\n        // Cannot change after create\n        user User\n        // Changeable\n        text Text\n        status Boolean?\n    }\n    actions {\n        list listUsers(updatedAt?)\n        create createUser() with (id?, user.id, name, status?)\n        create updateUser(id) with (name?, status?)\n        delete deleteUser(id)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Sync State and Error Handling\nDESCRIPTION: Shows how to access and handle sync state and errors using the syncState helper.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/persist-sync.mdx#2025-04-11_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { observable, syncState } from '@legendapp/state'\nimport { synced } from '@legendapp/state/sync'\n\nconst obs$ = observable(synced({ /*...*/ }))\nconst state$ = syncState(obs$)\nconst error = state$.error.get()\nconst isLoaded = state$.isLoaded.get()\n\nif (error) {\n    // Handle error\n} else if (!isLoaded) {\n    // Do something while loading\n} else {\n    // Good to go\n    const value = obs$.get()\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling React Tracking in Legend-State\nDESCRIPTION: Configuration to enable automatic tracking of observables in React components using get() method.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/usage/configuring.mdx#2025-04-11_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { enableReactTracking } from \"@legendapp/state/config/enableReactTracking\"\nenableReactTracking({\n    auto: true,\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Synced Observables with Keel in Legend State\nDESCRIPTION: Demonstrates how to set up synced observables using Legend State's sync engine, including persistence, debouncing, and retry options. Shows integration with Keel for CRUD operations.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/intro/introduction.mdx#2025-04-11_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nconst state$ = observable(\n    users: syncedKeel({\n        list: queries.getUsers,\n        create: mutations.createUsers,\n        update: mutations.updateUsers,\n        delete: mutations.deleteUsers,\n        persist: { name: 'users', retrySync: true },\n        debounceSet: 500,\n        retry: {\n            infinite: true,\n        },\n        changesSince: 'last-sync',\n    }),\n    // direct link to my user within the users observable\n    me: () => state$.users['myuid']\n)\n\nobserve(() => {\n    // get() activates through to state$.users and starts syncing.\n    // it updates itself and re-runs observers when name changes\n    const name = me$.name.get()\n})\n\n// Setting a value goes through to state$.users and saves update to server\nme$.name.set('Annyong')\n```\n\n----------------------------------------\n\nTITLE: Linking Observables in Legend-State (JavaScript)\nDESCRIPTION: Demonstrates how to create a two-way link between observables using computed functions. This allows for dynamic updates and pass-through operations.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/usage/observable.mdx#2025-04-11_snippet_20\n\nLANGUAGE: javascript\nCODE:\n```\nconst state$ = observable({\n  items: [\"hi\", \"there\", \"hello\"],\n  selectedIndex: 0,\n  selectedItem: () => state$.items[state$.selectedIndex.get()],\n})\n\nobserve(() => {\n    console.log('observe:' + state$.selectedItem.get())\n})\n// observe: 'hi'\n\nstate$.selectedIndex.set(2)\n// observe: 'hello'\n\nstate$.selectedItem.set('HELLO!')\n// observe: 'HELLO!'\n\n// items = [\"hi\", \"there\", \"HELLO!\"]\n```\n\n----------------------------------------\n\nTITLE: Using ItemSeparatorComponent Between List Items\nDESCRIPTION: Renders a component between each item in the list, excluding the top of the first item and the bottom of the last item.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/api/props.mdx#2025-04-11_snippet_14\n\nLANGUAGE: TypeScript\nCODE:\n```\nItemSeparatorComponent?: React.ComponentType<any>;\n```\n\n----------------------------------------\n\nTITLE: Complex Data Transformation Example\nDESCRIPTION: Demonstrates combining multiple transform helpers for complex data transformation scenarios.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/persist-sync.mdx#2025-04-11_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport { combineTransforms, transformStringifyDates } from '@legendapp/state/sync'\nconst state$ = observable(synced({\n    get: () => {/* ... */},\n    transform: combineTransforms(\n        transformStringifyDates(),\n        transformStringifyKeys('jsonData', 'messagesArr'),\n        {\n            load: async (value) => {\n                value.localBool = value.serverOption !== 'no'\n                delete value.serverOption\n                return value\n            },\n            save: async (value) => {\n                value.serverOption = value.localBool ? 'yes' : 'no'\n                delete value.localBool\n                return value\n            }\n        }\n    )\n}))\n```\n\n----------------------------------------\n\nTITLE: Using useTraceUpdates() in React with Legend State\nDESCRIPTION: Shows how to use useTraceUpdates() to log information about observable changes causing renders. This hook helps track down why components are rendering too frequently.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/react/tracing.mdx#2025-04-11_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useTraceUpdates } from \"@legendapp/state/trace\";\n\nconst Component = observer(function Component(props) {\n  // Call useTraceUpdates anywhere inside the component\n  useTraceUpdates();\n\n  return <div>{state.count.get()}</div>;\n\n  /* This logs:\n\n    [legend-state] Rendering because \"count\" changed:\n    from: 0\n    to: 1\n\n    */\n});\n```\n\n----------------------------------------\n\nTITLE: Data Migration and Transformation Example\nDESCRIPTION: Shows how to transform data between versions and handle data migration in persisted storage.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/persist-sync.mdx#2025-04-11_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nconst state$ = observable(synced({\n    get: () => {/* ... */},\n    persist: {\n        name: 'state',\n        transform: {\n            load: (value) => {\n                if (value.version === 2) {\n                    if (value.currentPeriodStart) {\n                        value.periodStart = new Date(value.currentPeriodStart * 1000)\n                        delete value.currentPeriodStart\n                    }\n                }\n                return value\n            }\n        }\n    }\n}))\n```\n\n----------------------------------------\n\nTITLE: Adding TypeScript Declaration for Legend State Babel Plugin\nDESCRIPTION: Shows how to add a TypeScript declaration file to expand types for direct JSX children in Computed and Memo components.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/react/fine-grained-reactivity.mdx#2025-04-11_snippet_10\n\nLANGUAGE: js\nCODE:\n```\n/// <reference types=\"@legendapp/state/types/babel\" />\n```\n\n----------------------------------------\n\nTITLE: Customizing ScrollView with renderScrollComponent\nDESCRIPTION: Allows rendering a custom ScrollView component with the provided props. Enables advanced customization of the underlying scroll behavior.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/api/props.mdx#2025-04-11_snippet_35\n\nLANGUAGE: TypeScript\nCODE:\n```\nrenderScrollComponent?: (props: ScrollViewProps) => ReactNode\n```\n\n----------------------------------------\n\nTITLE: Using undoRedo in Legend-State\nDESCRIPTION: Demonstrates how to use undoRedo to track changes to an observable and provide undo/redo functionality. It supports limiting history depth and provides observables for the number of available undos and redos which can be used in UI rendering.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/usage/helper-functions.mdx#2025-04-11_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport { observable } from \"@legendapp/state\";\nimport { undoRedo } from \"@legendapp/state/helpers/undoRedo\";\n\nconst state$ = observable({ todos: [\"Get milk\"] });\n\nconst { undo, redo, getHistory } = undoRedo(state$.todos, { limit: 100 });\n\nstate$.todos.push(\"Pick up bread\");\n// todos is now [\"Get milk\", \"Pick up bread\"]\n\nundo();\n// todos is now back to [\"Get milk\"]\n\nredo();\n// todos is restored to [\"Get milk\", \"Pick up bread\"]\n\ngetHistory(); // returns an array of all the different states it contains\n\nstate$.todos.set(getHistory()[0]); // reset to the original state in history\n\nundo(); // now back to where it was just prior to resetting\n```\n\n----------------------------------------\n\nTITLE: Migrating from afterBatch to batch in JavaScript\nDESCRIPTION: Demonstrates how to replace the deprecated afterBatch function with the new batch function that includes an after-batch callback.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/other/migrating.mdx#2025-04-11_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\n// Change\nbeginBatch();\nafterBatch(() => {\n  console.log(\"done\");\n});\nobs$.set(true);\nendBatch();\n\n// To\nbatch(\n  () => {\n    obs$.set(true);\n  },\n  () => {\n    console.log(\"done\");\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: Using useObserve with Legend-State in React\nDESCRIPTION: The useObserve hook creates an observer that reacts to changes in observables, similar to useEffect but triggered by observable changes rather than a dependency array. It runs during component render.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/react/react-API.mdx#2025-04-11_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nimport { event } from \"@legendapp/state\"\nimport { useObserve, useObservable } from \"@legendapp/state/react\"\nimport { $React } from \"@legendapp/state/react-web\"\n\n\nconst eventUpdateTitle = event()\n\nfunction ProfilePage() {\n  const profile$ = useObservable({ name: \"\" })\n\n  // This runs whenever profile changes\n  useObserve(() => {\n    document.title = `${profile$.name.get()} - Profile`\n  })\n\n  // Observe a single observable with a callback when it changes\n  useObserve(profile$.name, ({ value }) => {\n    document.title = `${value} - Profile`\n  })\n\n  // Observe an event with a callback when it changes\n  useObserve(eventUpdateTitle, () => {\n    document.title = `${profile$.name.get()} - Profile`\n  })\n\n  return (\n    <div>\n      <span>Name:</span>\n      <$React.input $value={profile$.name} />\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Using Direct Peek Example\nDESCRIPTION: Example demonstrating direct peek patterns for accessing and modifying observable values without notifications.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/usage/configuring.mdx#2025-04-11_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nimport { observable } from \"@legendapp/state\"\n\nconst state$ = observable({ test: \"hi\", num: 0 })\n\n// _ is a shorthand for peek()\nconst testValue = state$.test._\n\n// Assign to _ to modify the underlying object without notifying listeners\nstate$.test._ = \"hello\"\n\n// Assign objects too\nstate$._ = { test: \"hello\" }\n```\n\n----------------------------------------\n\nTITLE: Applying contentContainerStyle to ScrollView Container\nDESCRIPTION: Applies a style to the underlying ScrollView's content container, useful for adding padding or other layout adjustments.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/api/props.mdx#2025-04-11_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\ncontentContainerStyle?: StyleProp<ViewStyle>;\n```\n\n----------------------------------------\n\nTITLE: Creating Undo/Redo UI with Legend-State\nDESCRIPTION: Shows how to build a UI for undo/redo functionality using the undoRedo helper's undos$ and redos$ observables. These are used to track the number of available undo/redo operations and conditionally render UI buttons.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/usage/helper-functions.mdx#2025-04-11_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\nimport { observable } from \"@legendapp/state\";\nimport { observer } from \"@legendapp/state/react\";\nimport { undoRedo } from \"@legendapp/state/helpers/undoRedo\";\n\nconst state$ = observable({ todos: [\"Get milk\"] });\n\nconst { undo, redo, undos$, redos$ } = undoRedo(state$.todos, { limit: 100 });\n\nexport function UndoUI() {\n  const undos = use$(undos$);\n  const redos = use$(redos$);\n\n  return (\n    <div>\n      {undos > 0 ? (\n        <button onClick={undo}>Undo</button>\n      ) : (\n        <button disabled={true}>Undo</button>\n      )}\n      {redos > 0 ? (\n        <button onClick={undo}>Redo</button>\n      ) : (\n        <button disabled={true}>Redo</button>\n      )}\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Observable Listener in Legend State\nDESCRIPTION: Demonstrates how to add a custom listener to an observable for debugging purposes. This technique allows developers to track changes to specific observables and set breakpoints for detailed analysis.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/react/tracing.mdx#2025-04-11_snippet_4\n\nLANGUAGE: js\nCODE:\n```\n// Why is count rendering so often?\nstate.count.onChange(({ value }) => {\n  console.log(\"Count changed\", value);\n  console.trace();\n  debugger;\n});\n```\n\n----------------------------------------\n\nTITLE: Optimized Array Rendering with For Component\nDESCRIPTION: This snippet demonstrates the For component which is optimized for rendering arrays of observable objects. It extracts items into separate tracking contexts and prevents parent re-renders. It provides multiple ways to render items and optional performance optimizations.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/react/fine-grained-reactivity.mdx#2025-04-11_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\nimport { observable } from \"@legendapp/state\"\nimport { For, observer } from \"@legendapp/state/react\"\n\nconst state$ = observable({ arr: [{ id: 1, text: 'hi' }]})\n\nconst Row = observer(function Row({ item$ }) {\n    const text = item$.text.get()\n    return <div>{text}</div>\n})\nfunction List() {\n    // 1. Use the For component with an item prop\n    return <For each={state$.arr} item={Row} />\n\n    // 2. Use the For component with a render function as the child\n    return (\n        <For each={list} optimized>\n            {item$ => (\n                <div>\n                    {item$.text.get()}\n                </div>\n            )}\n        </div>\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Global Settings for Keel Integration\nDESCRIPTION: Shows how to set up global configuration options for the Keel plugin, including client setup and authentication handling for sync control.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/keel.mdx#2025-04-11_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { observable } from '@legendapp/state'\nimport { syncedKeel } from '@legendapp/state/sync-plugins/keel'\nimport { configureSynced } from '@legendapp/state/sync/'\nimport { APIClient } from './keelClient'\n\nconst client = new APIClient({\n  baseUrl: process.env.API_BASE_URL,\n})\n\nconst isAuthed$ = observable(false);\n\n// Set defaults\nconst sync = configureSynced(syncedKeel, {\n    client,\n    persist: {\n        plugin: ObservablePersistLocalStorage,\n    },\n    waitFor: isAuthed$\n})\n\n// enable sync after authentication succeeds\nasync function doAuth() {\n    // authenticate the client\n    await keel.auth.authenticateWithPassword(email, pass)\n\n    // check that the client is authenticated\n    const isAuthenticated = await keel.auth.isAuthenticated()\n\n    // Set isAuthed$ to start syncing\n    isAuthed$.set(true)\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Soft Deletes in Legend-State Keel Integration\nDESCRIPTION: Shows how to implement soft deletes using a deleted field instead of actual delete operations, allowing deleted records to be tracked in sync operations.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/keel.mdx#2025-04-11_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nconst { mutations, queries } = client.api\n\nconst profiles$ = observable(syncedKeel({\n    list: queries.listProfiles,\n    create: mutations.createProfile,\n    update: mutations.updateProfile,\n    fieldDeleted: 'deleted'\n}))\n```\n\n----------------------------------------\n\nTITLE: Deprecated direct get() usage with observer in Legend State\nDESCRIPTION: Shows the deprecated pattern of calling get() directly within observer components, which is being phased out in favor of the use$ hook pattern for better React Compiler compatibility.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/other/migrating.mdx#2025-04-11_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\nconst state$ = observable({ value: 10 })\nconst Component = observer(() => {\n    const value = state$.value.get()\n    // ...\n})\n```\n\n----------------------------------------\n\nTITLE: Component lifecycle hooks in Legend-State: useMount\nDESCRIPTION: The useMount hook is a convenience wrapper around useEffect that runs a callback when a component mounts, avoiding the need for empty dependency arrays.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/react/react-API.mdx#2025-04-11_snippet_8\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useMount } from \"@legendapp/state/react\";\n\nconst Component = () => {\n  useMount(() => console.log(\"mounted\"));\n};\n```\n\n----------------------------------------\n\nTITLE: Handling Asynchronous Loading with IndexedDB in Legend State\nDESCRIPTION: Shows how to handle the asynchronous nature of IndexedDB by waiting for persistence to load before proceeding with application logic using the syncState and when utilities.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/persist-sync.mdx#2025-04-11_snippet_18\n\nLANGUAGE: javascript\nCODE:\n```\nconst syncState$ = syncState(state$)\nawait when(syncState$.isPersistLoaded)\n// Continue with load\n```\n\n----------------------------------------\n\nTITLE: Fast isNumeric Check in JavaScript\nDESCRIPTION: A micro-optimization technique for checking if a value is numeric, using arithmetic operations instead of the slower isNaN function. This approach provides better performance for numeric type checking in high-frequency operations.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/intro/fast.mdx#2025-04-11_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n+n - +n < 1\n```\n\n----------------------------------------\n\nTITLE: Updating Bindable Component Imports in React\nDESCRIPTION: Shows the new import paths for automatically bound exports, renamed from 'LS' to 'Bindable', for both web and React Native environments.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/other/migrating.mdx#2025-04-11_snippet_35\n\nLANGUAGE: javascript\nCODE:\n```\n// Web\nimport { Bindable } from \"@legendapp/state/react-components\";\n\n// React Native\nimport { Bindable } from \"@legendapp/state/react-native-components\";\n```\n\n----------------------------------------\n\nTITLE: Using $React namespace for reactive web components\nDESCRIPTION: Shows the new $React namespace for reactive DOM components in web applications, replacing the previous Reactive pattern for better bundle size optimization and typing.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/other/migrating.mdx#2025-04-11_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nimport { $React } from \"@legendapp/state/react-web\"\n\nfunction Component() {\n    return (\n        <$React.div\n            $className={() => state$.age.get() > 5 ? 'kid' : 'baby'}\n        />\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating from ref to obs in Legend Observables\nDESCRIPTION: Demonstrates how to update code using the renamed 'ref' method to the new 'obs' method for accessing observables, which was changed to avoid conflicts with React's ref property.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/other/migrating.mdx#2025-04-11_snippet_13\n\nLANGUAGE: javascript\nCODE:\n```\nconst state$ = observable({ text: \"\" });\n\n// Before\nconst textRef = state$.ref(\"text\");\nconst textRef2 = state$.text.ref();\n\n// Now\nconst textObs = obs.obs(\"text\");\nconst textObs2 = obs.text.obs();\n```\n\n----------------------------------------\n\nTITLE: Using reactiveObserver for Combined Functionality\nDESCRIPTION: Explains the use of 'reactiveObserver', which combines the functionality of both 'observer' and 'reactive' in a single HOC for optimal performance.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/react/fine-grained-reactivity.mdx#2025-04-11_snippet_13\n\nLANGUAGE: js\nCODE:\n```\nimport { observable } from \"@legendapp/state\";\nimport { reactiveObserver } from \"@legendapp/state/react\";\n\nconst name$ = observable(\"Annyong\");\nconst isSignedIn$ = observable(false);\n\nconst Component = reactiveObserver(function Component({ message }) {\n  const name = name$.get();\n\n  return (\n    <div>\n      {message} {name}\n    </div>\n  );\n});\n\nfunction App() {\n  return (\n    <Component $message={() => (isSignedIn$.get() ? \"Hello\" : \"Goodbye\")} />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating shallow tracking options in Legend Observables\nDESCRIPTION: Demonstrates how to update code using the shallow option for 'get()' and 'obs()' to use the new Tracking namespace instead of passing 'shallow' directly to an observable.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/other/migrating.mdx#2025-04-11_snippet_15\n\nLANGUAGE: javascript\nCODE:\n```\nimport { Tracking } from \"@legendapp/state\";\n\nconst obs = observable([]);\n\n// Before\nobs.get(shallow);\n\n// Now\nobs.get(Tracking.shallow);\n```\n\n----------------------------------------\n\nTITLE: Showing Pull-to-Refresh State with refreshing\nDESCRIPTION: Set to true while waiting for new data from a refresh operation. Controls the visibility of the pull-to-refresh indicator.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/api/props.mdx#2025-04-11_snippet_33\n\nLANGUAGE: TypeScript\nCODE:\n```\nrefreshing?: boolean;\n```\n\n----------------------------------------\n\nTITLE: Migrating persistence configuration in Legend State\nDESCRIPTION: Shows how to migrate from the old persistObservable and global configuration to the new syncObservable with plugin system, which provides more flexibility and fixes compatibility issues.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/other/migrating.mdx#2025-04-11_snippet_12\n\nLANGUAGE: ts\nCODE:\n```\nimport { syncState } from \"@legendapp/state\"\nimport { configureSynced, syncObservable } from \"@legendapp/state/sync\"\n// Change\nconfigureObservablePersistence({\n    pluginLocal: ObservablePersistLocalStorage\n})\nconst { state } = persistObservable(state$, {\n    local: {\n        name: \"store\",\n    }\n})\n// To\nconst syncPlugin = configureSynced({\n    persist: {\n        plugin: ObservablePersistLocalStorage\n    }\n})\nsyncObservable(state$, syncPlugin({\n    persist: {\n        name: \"store\",\n    }\n}))\nconst state = syncState(state$);\n```\n\n----------------------------------------\n\nTITLE: Using renamed computed and event functions in Legend\nDESCRIPTION: Demonstrates how to update code to use the simplified naming of 'computed' and 'event' functions which replace 'observableComputed' and 'observableEvent'.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/other/migrating.mdx#2025-04-11_snippet_19\n\nLANGUAGE: javascript\nCODE:\n```\nimport { computed, event } from '@legendapp/state'\n\n// Before\nconst value = observableComputed(() => ...)\n// Now\nconst value = computed(() => ...)\n\n// Before\nconst evt = observableEvent(() => ...)\n// Now\nconst evt = event(() => ...)\n```\n\n----------------------------------------\n\nTITLE: Tracking Function Calls in Observing Contexts\nDESCRIPTION: Demonstrates how observable get() calls within functions are tracked when used in observing contexts like use$, including nested function calls for computed properties.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/usage/observable.mdx#2025-04-11_snippet_10\n\nLANGUAGE: jsx\nCODE:\n```\nconst state$ = observable({\n    fname: 'Annyong',\n    lname: 'Bluth',\n    fullName: () => state$.fname.get() + ' ' + state$.lname.get()\n})\n\nfunction Name() {\n    // Tracks [state$.fname, state$.lname]\n    const name = use$(() => state$.fullName())\n    return <div>{name}</div>\n}\n```\n\n----------------------------------------\n\nTITLE: Using Selectors with when function\nDESCRIPTION: Examples of using selectors with the when function to wait for specific conditions. Selectors can be either an observable or a function that returns a value based on observables.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/usage/reactivity.mdx#2025-04-11_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst isSignedIn$ = observable(false);\nconst isOnline$ = observable(false);\n\n// A selector can be just an observable, which will be tracked for changes\nawait when(isSignedIn$);\n\n// Or selector can be a function which tracks all get() calls for changes\nawait when(() => isSignedIn$.get() && isOnline$.get());\n```\n\n----------------------------------------\n\nTITLE: Importing Persistence Plugins from Updated Path in Legend-State\nDESCRIPTION: Example of importing persistence plugins from the new '/persist-plugins' path instead of the previous direct imports, a change introduced in version 0.22.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/other/migrating.mdx#2025-04-11_snippet_25\n\nLANGUAGE: javascript\nCODE:\n```\nimport { ObservablePersistLocalStorage } from \"@legendapp/state/persist-plugins/local-storage\";\nimport { ObservablePersistMMKV } from \"@legendapp/state/persist-plugins/mmkv\";\n```\n\n----------------------------------------\n\nTITLE: Updating Legend Components to Reactive Components\nDESCRIPTION: This snippet illustrates how to migrate from the old Legend components to the new Reactive components in both React and React Native environments.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/other/migrating.mdx#2025-04-11_snippet_15\n\nLANGUAGE: javascript\nCODE:\n```\n// Old way - React\nimport { Legend } from \"@legendapp/state/react-components\";\nfunction Component() {\n  return <Legend.div>...</Legend.div>;\n}\n\n// Old way - React Native\nimport { Legend } from \"@legendapp/state/react-native-components\";\nfunction Component() {\n  return <Legend.View>...</Legend.View>;\n}\n\n// New way\n// React\nimport { enableReactComponents } from \"@legendapp/state/config/enableReactComponents\";\nenableReactComponents();\n\n// React Native\nimport { enableReactNativeComponents } from \"@legendapp/state/config/enableReactNativeComponents\";\nenableReactNativeComponents();\n\n// Now you can use them anywhere\nimport { Reactive } from \"@legendapp/state/react\";\n\nfunction Component() {\n  // React\n  return <Reactive.div>...</Reactive.div>;\n\n  // React Native\n  return <Reactive.View>...</Reactive.View>;\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Persist Plugin Imports\nDESCRIPTION: Example of the updated import paths for persistence plugins which were moved to the /persist-plugins directory.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/other/migrating.mdx#2025-04-11_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\nimport { ObservablePersistLocalStorage } from \"@legendapp/state/persist-plugins/local-storage\";\nimport { ObservablePersistMMKV } from \"@legendapp/state/persist-plugins/mmkv\";\n```\n\n----------------------------------------\n\nTITLE: Rendering Observables with Memo Component in React\nDESCRIPTION: Demonstrates how to use the Memo component from Legend-State to render observable values and selectors in React components without causing parent re-renders.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/react/fine-grained-reactivity.mdx#2025-04-11_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Memo } from \"@legendapp/state/react\";\n\nconst count$ = observable(0);\n\n// These components never re-render.\n// The Memo element re-renders itself when its value changes.\nfunction WithObservable() {\n  return (\n    <div>\n      Count:\n      <Memo>{count$}</Memo>\n    </div>\n  );\n}\nfunction WithSelector() {\n  return (\n    <div>\n      <Memo>{() => <div>Count: {count$.get()}</div>}</Memo>\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring IndexedDB Persistence with Legend State in React\nDESCRIPTION: Example showing how to configure and use the IndexedDB plugin with Legend State in two modes: persisting a dictionary of objects with ID fields and persisting multiple observables to separate rows using itemID option.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/persist-sync.mdx#2025-04-11_snippet_17\n\nLANGUAGE: javascript\nCODE:\n```\nimport { configureSynced, syncObservable } from \"@legendapp/state/sync\"\nimport { observablePersistIndexedDB } from \"@legendapp/state/persist-plugins/indexeddb\"\n\n// Create default persist options\nconst persistOptions = configureSynced({\n    persist: {\n        plugin: observablePersistIndexedDB({\n            databaseName: \"Legend\",\n            version: 1,\n            tableNames: [\"documents\", \"store\"]\n        })\n    }\n})\n\n// Mode 1: Persist a dictionary\nconst state$ = observable({\n    obj1: { id: \"obj1\", text: \"...\" },\n    obj2: { id: \"obj2\", text: \"...\" },\n})\n\nsyncObservable(state$, persistOptions({\n    persist: {\n        name: \"documents\" // IndexedDB table name\n    }\n}))\n\n// Mode 2: Persist an object with itemId\nconst settings$ = observable({ theme: \"light\" })\n\nsyncObservable(settings$, persistOptions({\n    persist: {\n        name: \"store\", // IndexedDB table name\n        indexedDB: {\n            itemID: \"settings\"\n        }\n    }\n}))\n```\n\n----------------------------------------\n\nTITLE: Importing Legend-Motion Library\nDESCRIPTION: Basic import statement for the Motion component from Legend-Motion library.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/motion/src/content/docs/2-usage/1-overview.mdx#2025-04-11_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {Motion} from \"@legendapp/motion\"\n```\n\n----------------------------------------\n\nTITLE: Updating Type Reference for Legend-State Babel Types\nDESCRIPTION: This code shows how to update the type reference for Legend-State Babel types, moving from a generic types.d.ts to a more specific path.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/other/migrating.mdx#2025-04-11_snippet_20\n\nLANGUAGE: javascript\nCODE:\n```\n// Change this:\n/// <reference types=\"@legendapp/state/types\" />\n\n// To this:\n/// <reference types=\"@legendapp/state/types/babel\" />\n```\n\n----------------------------------------\n\nTITLE: Updating persistObservable Usage in JavaScript\nDESCRIPTION: Shows the change in the return value of persistObservable, which now returns an object with a state property for sync state.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/other/migrating.mdx#2025-04-11_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst { state } = persistObservable(initialStateOrObservable, { ... })\n```\n\n----------------------------------------\n\nTITLE: Using Computed Component for Extracted Rendering\nDESCRIPTION: This example shows how to use the Computed component to extract children so that their changes don't affect the parent, but they still update when parent state changes. It's useful for content that depends on both observable state and local parent variables.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/react/fine-grained-reactivity.mdx#2025-04-11_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nfunction Component() {\n  return (\n    <Computed>\n      {() =>\n        state$.messages.map((message) => (\n          <div key={message.id}>\n            {message.text} {localVar}\n          </div>\n        ))\n      }\n    </Computed>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Adding TypeScript Reference for Legend State Babel Types\nDESCRIPTION: Demonstrates how to add a TypeScript reference to expand types for direct JSX children in Computed and Memo components.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/react/fine-grained-reactivity.mdx#2025-04-11_snippet_10\n\nLANGUAGE: js\nCODE:\n```\n/// <reference types=\"@legendapp/state/types/babel\" />\n```\n\n----------------------------------------\n\nTITLE: Importing MotionLinearGradient for React Native Web\nDESCRIPTION: Import statement for using MotionLinearGradient in a React Native Web project after configuring webpack.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/motion/src/content/docs/2-usage/3-linear-gradient.mdx#2025-04-11_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { MotionLinearGradient } from \"@legendapp/motion/linear-gradient\";\n```\n\n----------------------------------------\n\nTITLE: Replacing afterBatch with batch in Legend-State\nDESCRIPTION: This snippet demonstrates how to replace the deprecated afterBatch function with the new batch function in Legend-State, which now includes an optional callback for after-batch operations.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/other/migrating.mdx#2025-04-11_snippet_21\n\nLANGUAGE: javascript\nCODE:\n```\n// Change\nbeginBatch();\nafterBatch(() => {\n  console.log(\"done\");\n});\nobs$.set(true);\nendBatch();\n\n// To\nbatch(\n  () => {\n    obs$.set(true);\n  },\n  () => {\n    console.log(\"done\");\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: Migrating from LS to Bindable for automatically bound components\nDESCRIPTION: Shows how to update imports from the LS namespace to the new Bindable namespace for automatically bound components, with different imports for web versus React Native.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/other/migrating.mdx#2025-04-11_snippet_20\n\nLANGUAGE: javascript\nCODE:\n```\n// Web\nimport { Bindable } from \"@legendapp/state/react-components\";\n\n// React Native\nimport { Bindable } from \"@legendapp/state/react-native-components\";\n```\n\n----------------------------------------\n\nTITLE: Advanced usage of observe function with cleanup\nDESCRIPTION: Example showing how to use the observe function with cleanup effects. The onCleanup property allows for running code when the observe function reruns or is disposed.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/usage/reactivity.mdx#2025-04-11_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport { observe, observable } from \"@legendapp/state\";\nconst state$ = observable({ isOnline: false, toasts: [] });\n\nconst dispose = observe((e) => {\n  // This observe will automatically track state.isOnline for changes\n  if (!state$.isOnline.get()) {\n    // Show an \"Offline\" toast when offline\n    const toast = { id: \"offline\", text: \"Offline\", color: \"red\" };\n    state$.toasts.push(toast);\n\n    // Remove the toast when the observe is re-run, which will be when isOnline becomes true\n    e.onCleanup = () => state$.toasts.splice(state$.toasts.indexOf(toast), 1);\n  }\n});\n\n// Cancel the observe\ndispose();\n```\n\n----------------------------------------\n\nTITLE: Managing Related Tables with waitForSet\nDESCRIPTION: Demonstrates using waitForSet to ensure dependent records are created in the proper order, preventing relationship creation errors in Keel.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/keel.mdx#2025-04-11_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nconst rooms$ = observable(syncedKeel({\n    list: queries.listRooms,\n    create: mutations.createRoom,\n    update: mutations.updateRoom,\n}))\nconst roomMessages$ = observable(\n    (roomId: string) => syncedKeel({\n        list: queries.getRoomMessages,\n        where: { roomId },\n        create: (message) => mutations.createMessage({ roomId, ...message }),\n        update: mutations.updateMessage,\n        waitForSet: rooms$[roomId].createdAt\n    })\n)\n```\n\n----------------------------------------\n\nTITLE: Using when() with Boolean Selector in Legend-State\nDESCRIPTION: Example of using the when() function with a selector that returns a boolean, which is required since version 0.22 when targeting empty objects or arrays.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/other/migrating.mdx#2025-04-11_snippet_26\n\nLANGUAGE: javascript\nCODE:\n```\nconst obs = {}\nwhen(() => !!obs, () => {...})\n```\n\n----------------------------------------\n\nTITLE: Enabling Direct Access\nDESCRIPTION: Configuration for enabling direct access to observable values using the $ shorthand.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/usage/configuring.mdx#2025-04-11_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport { enableDirectAccess } from \"@legendapp/state/config/enableDirectAccess\"\nenableDirectAccess()\n```\n\n----------------------------------------\n\nTITLE: Basic Batching Implementation in JavaScript\nDESCRIPTION: Demonstrates two methods of implementing batching: using beginBatch/endBatch pair and using the batch callback function. Both approaches allow grouping multiple state changes together.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/usage/reactivity.mdx#2025-04-11_snippet_12\n\nLANGUAGE: javascript\nCODE:\n```\nimport { batch, beginBatch, endBatch } from \"@legendapp/state\";\n\n// Wrap in begin and end\nbeginBatch();\ndoManyChanges();\nendBatch();\n\n// Or batch with a callback\nbatch(() => {\n  doManyChanges();\n});\n```\n\n----------------------------------------\n\nTITLE: Easing Animation Examples\nDESCRIPTION: Demonstrations of different easing functions in animations.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/motion/src/content/docs/2-usage/1-overview.mdx#2025-04-11_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\n<Motion.View\n  animate={{ x: value * 100 }}\n  transition={{\n    type: \"timing\",\n    duration: 300,\n    easing: \"linear\",\n  }}\n/>\n<Motion.View\n  animate={{ x: value * 100 }}\n  transition={{\n    type: \"timing\",\n    duration: 300,\n    easing: Easing.easing,\n  }}\n/>\n```\n\n----------------------------------------\n\nTITLE: Updating Observable References in JavaScript\nDESCRIPTION: Demonstrates the renaming of 'ref' to 'obs' for obtaining observable references, improving clarity and avoiding conflicts with React.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/other/migrating.mdx#2025-04-11_snippet_28\n\nLANGUAGE: javascript\nCODE:\n```\nconst state$ = observable({ text: \"\" });\n\n// Before\nconst textRef = state$.ref(\"text\");\nconst textRef2 = state$.text.ref();\n\n// Now\nconst textObs = obs.obs(\"text\");\nconst textObs2 = obs.text.obs();\n```\n\n----------------------------------------\n\nTITLE: Using reactiveObserver for Combined Observer and Reactive Functionality\nDESCRIPTION: Demonstrates the use of reactiveObserver HOC which combines the functionality of both observer and reactive in a single component.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/react/fine-grained-reactivity.mdx#2025-04-11_snippet_13\n\nLANGUAGE: js\nCODE:\n```\nimport { observable } from \"@legendapp/state\";\nimport { reactiveObserver, use$ } from \"@legendapp/state/react\";\n\nconst name$ = observable(\"Annyong\");\nconst isSignedIn$ = observable(false);\n\nconst Component = reactiveObserver(function Component({ message }) {\n  const name = use$(name$);\n\n  return (\n    <div>\n      {message} {name}\n    </div>\n  );\n});\n\nfunction App() {\n  return (\n    <Component $message={() => (isSignedIn$.get() ? \"Hello\" : \"Goodbye\")} />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using pageHash Observable for URL Hash Management\nDESCRIPTION: Demonstrates pageHash observable for tracking and updating URL hash with configurable behavior.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/react/helpers-and-hooks.mdx#2025-04-11_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nimport { pageHash, configurePageHash } from '@legendapp/state/helpers/pageHash'\n\nconfigurePageHash({ setter: 'pushState' })\n\nobserve(() => {\n    console.log('hash changed to': pageHash.get())\n})\n\npageHash.set('value=test')\n// location.hash == \"#value=test\"\n```\n\n----------------------------------------\n\nTITLE: Using currentTime Observable in Legend-State\nDESCRIPTION: Shows implementation of currentTime observable that automatically updates every minute with the current time.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/react/helpers-and-hooks.mdx#2025-04-11_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { currentTime } from \"@legendapp/state/helpers/time\"\n\nobserve(() => {\n    console.log('The time is is': currentTime.get())\n})\n```\n\n----------------------------------------\n\nTITLE: Renaming Computed and Event Observables in JavaScript\nDESCRIPTION: Demonstrates the renaming of 'observableComputed' to 'computed' and 'observableEvent' to 'event' for clarity and consistency in the Legend State API.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/other/migrating.mdx#2025-04-11_snippet_34\n\nLANGUAGE: javascript\nCODE:\n```\nimport { computed, event } from '@legendapp/state'\n\n// Before\nconst value = observableComputed(() => ...)\n// Now\nconst value = computed(() => ...)\n\n// Before\nconst evt = observableEvent(() => ...)\n// Now\nconst evt = event(() => ...)\n```\n\n----------------------------------------\n\nTITLE: Using Reactive Components in React Web with Legend-State\nDESCRIPTION: Shows how to use reactive versions of DOM elements provided by Legend-State for React Web, including reactive styling, children, and two-way binding for inputs.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/react/fine-grained-reactivity.mdx#2025-04-11_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport { $React } from \"@legendapp/state/react-web\"\n\nfunction Component() {\n    // This component renders only once\n    const state$ = useObservable({ name: '', age: 18 })\n\n    return (\n        <div>\n            {/* Reactive styling */}\n            <$React.div\n                $style={() => ({\n                    color: state$.age.get() > 5 ? 'green' : 'red'\n                })}\n                $className={() => state$.age.get() > 5 ? 'kid' : 'baby'}\n            />\n            {/* Reactive children */}\n            <$React.div>\n                {() => (\n                    <div>{state$.age.get() > 5 ? <Kid /> : <Baby />}</div>\n                )}\n            />\n            {/* Two-way bind to inputs */}\n            <$React.textarea $value={state$.name} />\n            <$React.select $value={state$.age}>...</$React.select>\n            <$React.input\n                $value={state$.name}\n                $className={() => !state$.name.get() && \"border-red-500\"}\n                $style={() => !state$.name.get() && { borderWidth: 1 }}\n            />\n        </div>\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Using use$ with computed values in Legend State\nDESCRIPTION: Shows how to wrap functions that consume observables with use$ to create computed values, which only trigger re-renders when the return value changes.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/other/migrating.mdx#2025-04-11_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nconst state$ = observable({ v1: 10, v2: 20 })\nconst getComputedData = () => {\n    return state$.v1.get() + state$.v2.get()\n}\nconst Component = () => {\n    const v = use$(() => getComputedData())\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Using Linked Observables for Data Serialization\nDESCRIPTION: Demonstrates using linked observables to automatically deserialize and serialize data, creating a two-way binding between a string representation and its parsed value.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/usage/observable.mdx#2025-04-11_snippet_18\n\nLANGUAGE: javascript\nCODE:\n```\nconst str$ = observable('[1,2,3]')\nconst arr$ = observable(linked({\n  get: () => JSON.parse(str$.get())\n  set: (value) => str$.set(JSON.stringify(value))\n}))\n```\n\n----------------------------------------\n\nTITLE: Updating TypeScript Reference Path for Legend-State\nDESCRIPTION: Shows the updated path for TypeScript type definitions, moving from types.d.ts to types/babel.d.ts.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/other/migrating.mdx#2025-04-11_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\n// Change this:\n/// <reference types=\"@legendapp/state/types\" />\n\n// To this:\n/// <reference types=\"@legendapp/state/types/babel\" />\n```\n\n----------------------------------------\n\nTITLE: Deleting Array Elements with delete()\nDESCRIPTION: Demonstrates how to use the delete() method to remove elements from observable arrays, which removes the element rather than just setting it to undefined.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/usage/observable.mdx#2025-04-11_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nconst state$ = observable([ 'apple', 'orange' ])\n\n// Delete from the array\nstate$[0].delete()\n// state === ['orange']\n```\n\n----------------------------------------\n\nTITLE: Migrating from enableLegendStateReact to Memo Component in React\nDESCRIPTION: Demonstrates how to replace the deprecated enableLegendStateReact() function with the new Memo component for rendering observables directly in React components.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/other/migrating.mdx#2025-04-11_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\n// Remove these:\nenableLegendStateReact();\nenableLegendStateReact();\n\nfunction Component() {\n  const text$ = useObservable(\"test\");\n  return (\n    <>\n      Change this: {text$}\n      To this: <Memo>{text$}</Memo>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using observer as an optimization with multiple use$ hooks\nDESCRIPTION: Demonstrates how observer can still be used as a performance optimization to merge multiple use$ calls into a single hook, which is beneficial for large components with many observable dependencies.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/other/migrating.mdx#2025-04-11_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nconst state$ = observable({ value1: 10, /* ... */ })\nconst Component = observer(() => {\n    // Observer makes this run only a single hook\n    const value1 = use$(state$.value1)\n    const value2 = use$(state$.value2)\n    const value3 = use$(state$.value3)\n    const value4 = use$(state$.value4)\n    const value5 = use$(state$.value5)\n    const value6 = use$(state$.value6)\n    const value7 = use$(state$.value7)\n    // ...\n})\n```\n\n----------------------------------------\n\nTITLE: Persisting Observable with IndexedDB itemID Option\nDESCRIPTION: Example showing how to persist an observable to IndexedDB using the new itemID option. This approach allows saving non-dictionary values to specific rows in an IndexedDB table.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/other/migrating.mdx#2025-04-11_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nconst settings = observable({ theme: \"light\" });\npersistObservable(settings, {\n  local: {\n    name: \"store\",\n    indexedDB: {\n      itemID: \"settings\",\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Retrieving Raw Data from Observables for Performance\nDESCRIPTION: Demonstrates retrieving raw data from observables using get() to avoid unnecessary proxy creation during expensive computations that don't need to trigger reactive updates.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/usage/observable.mdx#2025-04-11_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst state$ = observable({ data: someHugeThing })\nconst { data } = state$.get()\n\n// Nothing special happens when working with the raw data\nprocessData(data)\n```\n\n----------------------------------------\n\nTITLE: Using useEffectOnce in Legend-State for React\nDESCRIPTION: The useEffectOnce hook is a version of useEffect that ensures it only runs once, even in development mode. It's useful for initialization code that should only execute on component mount.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/react/react-API.mdx#2025-04-11_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useEffectOnce } from \"@legendapp/state/react\"\n\nconst Component = () => {\n  useEffectOnce(() => {\n    console.log(\"mounted\")\n  }, [])\n}\n```\n\n----------------------------------------\n\nTITLE: Using useIsMounted Hook in Legend-State\nDESCRIPTION: Shows how to use useIsMounted hook to track component mount state for async operations.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/react/helpers-and-hooks.mdx#2025-04-11_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useIsMounted } from \"@legendapp/state/react/useIsMounted\";\n\nfunction Component() {\n  const isMounted = useIsMounted();\n\n  const onClick = () => {\n    setTimeout(() => {\n      if (isMounted.get()) {\n        console.log(\"Debounced click\");\n      }\n    }, 100);\n  };\n\n  return <button onClick={onClick}>Click me</button>;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Local Storage Persistence\nDESCRIPTION: Shows how to set up Local Storage persistence which is no longer the default persistence mechanism. This must be configured at the app startup.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/other/migrating.mdx#2025-04-11_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\nimport { configureObservablePersistence } from \"@legendapp/state/persist\";\nimport { ObservablePersistLocalStorage } from \"@legendapp/state/local-storage\";\n\nconfigureObservablePersistence({\n  persistLocal: ObservablePersistLocalStorage,\n});\n```\n\n----------------------------------------\n\nTITLE: Using peek() to Get Values Without Tracking\nDESCRIPTION: Demonstrates how to use the peek() method to retrieve values from observables without automatically tracking them, useful when you don't want components or observing contexts to update when the value changes.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/usage/observable.mdx#2025-04-11_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst state$ = observable({ name: 'Test user' })\n\n// get the underlying value from the observable\nconst name = state$.name.peek()\n```\n\n----------------------------------------\n\nTITLE: Implementing Get Operations with syncedCrud in TypeScript\nDESCRIPTION: Example showing how to use syncedCrud with get operations for single-item CRUD operations. Demonstrates basic setup for profile management with get, create, update, and delete functionality.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/crud.mdx#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { syncedCrud } from '@legendapp/state/sync-plugins/crud'\n\nconst profile$ = observable(syncedCrud({\n    get: getProfile,\n    create: createProfile,\n    update: updateProfile,\n    delete: deleteProfile,\n}))\n// profile$.get() is a Profile\n```\n\n----------------------------------------\n\nTITLE: Importing MotionLinearGradient for React Native\nDESCRIPTION: Import statement for using MotionLinearGradient in a React Native project after installing react-native-linear-gradient.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/motion/src/content/docs/2-usage/3-linear-gradient.mdx#2025-04-11_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { MotionLinearGradient } from \"@legendapp/motion/linear-gradient\";\n```\n\n----------------------------------------\n\nTITLE: Using When with Boolean Selector\nDESCRIPTION: Shows how to use the when function with a boolean selector to handle empty objects or arrays, which no longer trigger when by default.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/other/migrating.mdx#2025-04-11_snippet_12\n\nLANGUAGE: javascript\nCODE:\n```\nconst obs = {}\nwhen(() => !!obs, () => {...})\n```\n\n----------------------------------------\n\nTITLE: Using the observe function in Legend-State\nDESCRIPTION: Example of using the observe function to track changes to a theme setting. The observe function creates an observing context that automatically re-runs when tracked observables change.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/usage/reactivity.mdx#2025-04-11_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nobserve(() => {\n    console.log(settings$.theme.get())\n})\n```\n\n----------------------------------------\n\nTITLE: Using Component-Level Observable State with React\nDESCRIPTION: Example of creating observable state within React components using the useObservable hook. This demonstrates how to pass observable state to child components through props.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/guides/patterns.mdx#2025-04-11_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nfunction App() {\n  const store$ = useObservable({\n    profile: { name: \"hi\" },\n  });\n\n  return (\n    <div>\n      <Profile profile={store$.profile} />\n    </div>\n  );\n}\n\nfunction Profile({ profile }) {\n  return <div>{profile.name}</div>;\n}\n```\n\n----------------------------------------\n\nTITLE: Local State Management with Legend-State\nDESCRIPTION: Demonstrates how to create and manage local state using useObservable hook in React components.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/react/react-introduction.mdx#2025-04-11_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nimport { observer, useObservable } from \"@legendapp/state/react\";\n\nfunction App() {\n  const store$ = useObservable({\n    profile: { name: \"hi\" },\n  });\n\n  // This component does not get() the store so only Profile will re-render on changes\n\n  return (\n    <div>\n      <Profile profile$={store$.profile} />\n    </div>\n  );\n}\n\nconst Profile = observer(function Profile({ profile$ }) {\n  const name = profile$.name.get();\n\n  return <div>Name: {name}</div>;\n})\n```\n\n----------------------------------------\n\nTITLE: Using optimized array rendering with Legend's For component\nDESCRIPTION: Shows how to enable array optimizations which are now opt-in through the 'optimized' prop on the For component. This change was made because the optimizations were only useful in React and could lead to unexpected behavior.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/other/migrating.mdx#2025-04-11_snippet_14\n\nLANGUAGE: jsx\nCODE:\n```\nconst obs = observable({ items: [] });\n\nconst Row = observer(function Row({ item }) {\n  return <div>{item.text}</div>;\n});\n\nconst List = observer(function () {\n  // The optimized prop enables the optimizations which were previously default\n  return <For each={list} item={Row} optimized />;\n});\n```\n\n----------------------------------------\n\nTITLE: Using onChange to listen for observable changes\nDESCRIPTION: Basic example of using onChange to listen to observable changes. The onChange method fires notifications for every change recursively up the tree.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/usage/reactivity.mdx#2025-04-11_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nconst state$ = observable({ text: \"hi\" });\n\nstate$.text.onChange(({ value }) => console.log(\"text changed to\", value));\nstate$.onChange(({ value }) => console.log(\"state changed to\", value));\n\nstate$.text.set(\"hello\");\n\n// Log: text changed to \"hello\"\n// Log: state changed to { text: \"hello\" }\n```\n\n----------------------------------------\n\nTITLE: Managing State Within React Components Using Legend-State\nDESCRIPTION: Illustrates how to create observable state objects within React components using the useObservable hook. Shows how state can be passed down to child components through props, enabling reactive UI updates.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/guides/patterns.mdx#2025-04-11_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nfunction App() {\n  const store$ = useObservable({\n    profile: { name: \"hi\" },\n  });\n\n  return (\n    <div>\n      <Profile profile={store$.profile} />\n    </div>\n  );\n}\n\nfunction Profile({ profile }) {\n  return <div>{profile.name}</div>;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Observe with Cleanup Effects in Legend-State\nDESCRIPTION: Demonstrates the observe function with cleanup effects to manage toasts based on online status changes, showing how to track and respond to observable state changes.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/usage/reactivity.mdx#2025-04-11_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { observe, observable } from \"@legendapp/state\";\nconst state$ = observable({ isOnline: false, toasts: [] });\n\nconst dispose = observe((e) => {\n  // This observe will automatically track state.isOnline for changes\n  if (!state$.isOnline.get()) {\n    // Show an \"Offline\" toast when offline\n    const toast = { id: \"offline\", text: \"Offline\", color: \"red\" };\n    state$.toasts.push(toast);\n\n    // Remove the toast when the observe is re-run, which will be when isOnline becomes true\n    e.onCleanup = () => state$.toasts.splice(state$.toasts.indexOf(toast), 1);\n  }\n});\n\n// Cancel the observe\ndispose();\n```\n\n----------------------------------------\n\nTITLE: Using the new batching API in Legend Observables\nDESCRIPTION: Shows how to update code to use the new direct exports for batching operations after the removal of the observableBatcher namespace. Batching allows multiple state changes to be processed in a single update.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/other/migrating.mdx#2025-04-11_snippet_16\n\nLANGUAGE: javascript\nCODE:\n```\nimport { batch, beginBatch, endBatch } from '@legendapp/state'\n\n// begin/end\nbeginBatch()\nobs1.set(...)\nobs2.set(...)\nendBatch()\n\n// batch()\nbatch(() => {\n    obs1.set(...)\n    obs2.set(...)\n}\n```\n\n----------------------------------------\n\nTITLE: Using whenReady for non-empty collections\nDESCRIPTION: Example of using whenReady function to wait for arrays or objects to not be empty before executing code.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/usage/reactivity.mdx#2025-04-11_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nimport { whenReady } from \"@legendapp/state\";\n\nconst state$ = observable({ arr: [] });\n\nwhenReady(state$.arr, () => console.log(\"Array has some values\"));\n// Not ready yet\n\nstate$.arr.push(\"hello\");\n\n// \"Array has some values\"\n```\n\n----------------------------------------\n\nTITLE: Creating Multiple Reactive Components with reactiveComponents\nDESCRIPTION: Shows how to use 'reactiveComponents' to create multiple reactive components at once, useful for wrapping UI libraries with multiple components in a namespace.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/react/fine-grained-reactivity.mdx#2025-04-11_snippet_14\n\nLANGUAGE: js\nCODE:\n```\nimport { reactiveComponents } from \"@legendapp/state/react\";\nimport { motion } from \"framer-motion\";\n\nconst ReactiveMotion = reactiveComponents(motion);\n\nfunction Component() {\n  // This component renders only once\n  const width$ = useObservable(100);\n\n  return (\n    <ReactiveMotion.div\n      $animate={() => ({\n        x: width$.get(),\n      })}\n    >\n      ...\n    </ReactiveMotion.div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Deprecated React Tracking Features in JavaScript\nDESCRIPTION: This snippet shows how to enable deprecated React tracking features, including warnings for unobserved get() calls and auto-tracking of observables in React components.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/usage/configuring.mdx#2025-04-11_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { enableReactTracking } from \"@legendapp/state/config/enableReactTracking\"\nenableReactTracking({\n    warnUnobserved: true,\n})\n```\n\nLANGUAGE: javascript\nCODE:\n```\nimport { enableReactTracking } from \"@legendapp/state/config/enableReactTracking\"\nenableReactTracking({\n    auto: true,\n})\n```\n\nLANGUAGE: jsx\nCODE:\n```\nimport { observable } from \"@legendapp/state\"\nconst state$ = observable({ test: \"hi\" })\n\nfunction Component() {\n  // This makes this component responsive to test changing\n  const test = state$.test.get()\n\n  return <div>{test}</div>\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating from change functions to observe/when in Legend\nDESCRIPTION: Shows how to replace removed utility functions (onTrue, onHasValue, onEquals, onChangeShallow) with the new observe and when functions that can automatically track all observables accessed while running.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/other/migrating.mdx#2025-04-11_snippet_17\n\nLANGUAGE: javascript\nCODE:\n```\nimport { observe, when } from \"@legendapp/state\";\n\nconst obs = observable({ value: undefined });\n\n// onTrue\nobs.value.onTrue(handler);\n// New onTrue equivalent\nwhen(() => obs.value === true, handler);\n\n// onHasValue\nobs.value.onHasValue(\"text\", handler);\n// onHasValue equivalent\nwhen(() => obs.value, handler);\n\n// onEquals\nobs.value.onEquals(\"text\", handler);\n// onEquals equivalent\nwhen(() => obs.value === \"text\", handler);\n\n// onChangeShallow\nobs.value.onChangeShallow(handler);\n// onChangeShallow equivalent\nobs.value.onChange(handler, { shallow: true });\n```\n\n----------------------------------------\n\nTITLE: Using trackHistory in Legend-State\nDESCRIPTION: Shows how to use trackHistory to create an observable that tracks all changes in a target observable, with the previous value at the time it was changed. This can be useful for implementing version history in applications like text editors.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/usage/helper-functions.mdx#2025-04-11_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { observable } from '@legendapp/state'\nimport { trackHistory } from '@legendapp/state/helpers/trackHistory'\n\nconst state$ = observable({ profile: { name: 'Hello' }})\n\n// Track all changes to state\nconst history = trackHistory(state$)\n\n// Change something in state\nstate$.profile.name.set('Annyong')\n\n// History shows the previous value when it changed:\n{\n    1666593133018: {\n        profile: {\n            name: 'Hello'\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using mergeIntoObservable in Legend-State\nDESCRIPTION: Demonstrates how to merge a deep object into an observable using mergeIntoObservable, which retains existing observables and listeners and fires listeners as values change. The example shows merging a new object into state$ while preserving reference equality.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/usage/helper-functions.mdx#2025-04-11_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { observable } from \"@legendapp/state\";\nimport { mergeIntoObservable } from \"@legendapp/state\";\n\nconst state$ = observable({ store: { text: \"hello\", other: \"hello there\" } });\n\nstate$.store.text.onChange(({ value }) =>\n  console.log(`text changed to \"${value}\"`)\n);\n\nconst newValue = { store: { text: \"hi\", other: \"hi there\" } };\nmergeIntoObservable(state$, newValue);\n\n// text changed to \"hi\"\n\nstate$.store === newValue.store; //  true\n```\n\n----------------------------------------\n\nTITLE: Basic Observable Operations in Legend-State\nDESCRIPTION: Demonstrates the fundamental get() and set() operations on observables in Legend-State, along with using the observe() function to reactively track changes.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/intro/why.mdx#2025-04-11_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nconst state$ = observable({ value: 1 });\nstate$.value.get();\nstate$.value.set(2);\n\n// Tracks automatically and runs on every change\nobserve(() => {\n  console.log(state$.value.get());\n});\n```\n\n----------------------------------------\n\nTITLE: Using Computed component instead of Isolate in Legend\nDESCRIPTION: Shows how to update code to use the renamed Computed component which replaces the Isolate component for control flow.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/other/migrating.mdx#2025-04-11_snippet_21\n\nLANGUAGE: jsx\nCODE:\n```\n// Before\n<div memo>...</div>\n<div computed>...</div>\n\n// Now\n<Memo><div>...</div></Memo>\n<Computed><div>...</div></Computed>\n```\n\n----------------------------------------\n\nTITLE: Using ObservableHint.plain in Legend-State\nDESCRIPTION: Shows how to use ObservableHint.plain to mark an object as not having any child functions or observables. This is a performance optimization that prevents the observable from recursing through children, but will break any descendant functions or computeds.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/usage/helper-functions.mdx#2025-04-11_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { observable, ObservableHint } from '@legendapp/state'\n\nconst bigObject = {}\n\nconst state$ = observable({ text: 'hi', child: ObservableHint.plain(bigObject) })\n```\n\n----------------------------------------\n\nTITLE: Updating Reactive Props Syntax in React Components\nDESCRIPTION: Illustrates the change in syntax for reactive props, moving from a suffix $ to a prefix $ for better autocomplete and visual scanning.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/other/migrating.mdx#2025-04-11_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nfunction Component() {\n  const text$ = useObservable(\"test\");\n  return (\n    <Reactive.div\n      // Change this\n      className$={() => \"...\"}\n      // to this\n      $className={() => \"...\"}\n    >\n      ...\n    </Reactive.div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using useVerifyOneRender() in React with Legend State\nDESCRIPTION: Shows how to use useVerifyOneRender() to ensure components render only once. This hook is useful for optimizing component performance and identifying unnecessary re-renders.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/react/tracing.mdx#2025-04-11_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useVerifyOneRender } from \"@legendapp/state/trace\";\n\nconst Component = observer(function Component(props) {\n  // Call useVerifyOneRender anywhere inside the component\n  useVerifyOneRender();\n\n  // This will log an error after one render when count is updated\n  return <div>{state.count.get()}</div>;\n});\nconst Component = observer(function Component(props) {\n  // Call useVerifyOneRender anywhere inside the component\n  useVerifyOneRender();\n\n  // This will not log because `get(false)` does not track observable\n  // does not re-render this component\n  return <div>{state.count.get(false)}</div>;\n});\n```\n\n----------------------------------------\n\nTITLE: Defining data Array Prop in LegendList\nDESCRIPTION: The data prop is required and specifies the array of items to render in the list. This can be an array of items or an array of keys if you want to get the item by key in renderItem.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/api/props.mdx#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndata: ItemT[];\n```\n\n----------------------------------------\n\nTITLE: Optimized For Component Rendering in Legend-State\nDESCRIPTION: Demonstrates using the optimized prop with the For component to maximize rendering performance by reusing React elements. This approach significantly improves performance for operations like swapping or sorting array elements.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/guides/performance.mdx#2025-04-11_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\nimport { For } from \"@legendapp/state/react\"\n\n...\n\nfunction List() {\n    // Use the optimized prop\n    return <For each={list} item={Row} optimized />\n}\n```\n\n----------------------------------------\n\nTITLE: Optimizing Iteration Through Observable Arrays\nDESCRIPTION: Shows how to optimize performance when iterating through large observable arrays by using get() to access raw data and avoid creating unnecessary Proxies for each element.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/guides/performance.mdx#2025-04-11_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst state$ = observable({ items: [{ data: { value: 10 }}, ...] })\n\nlet sum = 0\n\n//  This will create proxies for each element's data and value\nstate$.items.forEach(item => sum += item.data.value.get())\n\n//  This will not do anything special\nstate$.items.get().forEach(item => sum += item.data.value)\n```\n\n----------------------------------------\n\nTITLE: Shallow tracking with get(true)\nDESCRIPTION: Example of using get(true) for shallow tracking of an observable array. This is useful when a component only needs to re-render if array items are added or removed rather than when their properties change.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/usage/reactivity.mdx#2025-04-11_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nconst state$ = observable({ messages: [] });\n\nobserve(() => {\n  // Only need this to update when messages added/removed\n  const messages = state$.messages.get(true);\n\n  console.log(\"Latest message\", messages[0]);\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing renderItem Prop in LegendList\nDESCRIPTION: The renderItem prop takes an item from data and renders it into the list. It receives LegendListRenderItemProps and should return a ReactNode.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/api/props.mdx#2025-04-11_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nrenderItem?: (props: LegendListRenderItemProps<ItemT>) => ReactNode;\n```\n\n----------------------------------------\n\nTITLE: Using useObservableReducer in Legend-State for React\nDESCRIPTION: The useObservableReducer hook works like React's useReducer but sets an observable rather than triggering a render. It returns an observable state and a dispatch function to update it through actions.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/react/react-API.mdx#2025-04-11_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useObservableReducer } from \"@legendapp/state/react\"\n\nfunction reducer(state, action) {\n    if (action.type === 'incremented_age') {\n        return {\n            age: state.age + 1\n        }\n    }\n}\nconst Component = () => {\n    // Only re-renders if the return value changes\n    const [age$, dispatch] = useObservableReducer(reducer, { age: 42 })\n\n    // Get the value of the reducer\n    const theme = age$.get()\n}\n```\n\n----------------------------------------\n\nTITLE: Efficient Iteration through Observables\nDESCRIPTION: Demonstrates how to efficiently iterate through large objects in observables by using get() to access raw data, avoiding unnecessary Proxy creation for improved performance.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/guides/performance.mdx#2025-04-11_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst state$ = observable({ items: [{ data: { value: 10 }}, ...] })\n\nlet sum = 0\n\n//  This will create proxies for each element's data and value\nstate$.items.forEach(item => sum += item.data.value.get())\n\n//  This will not do anything special\nstate$.items.get().forEach(item => sum += item.data.value)\n```\n\n----------------------------------------\n\nTITLE: Waiting for Remote Data Load Completion\nDESCRIPTION: Shows how to use the createdAt field as an indicator that data has been successfully saved to Keel, allowing code to wait for confirmation before proceeding.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/keel.mdx#2025-04-11_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\n// Wait for profile to have saved\nawait when(profile$.createdAt)\n```\n\n----------------------------------------\n\nTITLE: Using keyExtractor Prop in LegendList\nDESCRIPTION: The keyExtractor prop allows LegendList to save item layouts by key for reuse when the data array changes. This improves performance by only updating changed items.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/api/props.mdx#2025-04-11_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nkeyExtractor?: (item: ItemT, index: number) => string;\n```\n\n----------------------------------------\n\nTITLE: Using useUnmount Hook in Legend-State for React\nDESCRIPTION: The useUnmount hook provides a convenient way to run code when a component unmounts, without using dependency arrays. It uses useEffectOnce under the hood.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/react/react-API.mdx#2025-04-11_snippet_9\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useUnmount } from \"@legendapp/state/react\"\n\nconst Component = () => {\n  useUnmount(() => console.log(\"mounted\"))\n}\n```\n\n----------------------------------------\n\nTITLE: Using Shallow Tracking in JavaScript Observables\nDESCRIPTION: Demonstrates the updated syntax for using shallow tracking with observables, replacing the direct 'shallow' parameter with the 'Tracking.shallow' namespace.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/other/migrating.mdx#2025-04-11_snippet_30\n\nLANGUAGE: javascript\nCODE:\n```\nimport { Tracking } from \"@legendapp/state\";\n\nconst obs = observable([]);\n\n// Before\nobs.get(shallow);\n\n// Now\nobs.get(Tracking.shallow);\n```\n\n----------------------------------------\n\nTITLE: Using Delete Tracking in Keel Query Hooks\nDESCRIPTION: Shows how to integrate the listTableWithDeletes function in a beforeQuery hook to ensure deleted records are properly included in sync operations.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/keel.mdx#2025-04-11_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nconst hooks: ListMessagesHooks = {\n    async beforeQuery(ctx, inputs, query) {\n        return listTableWithDeletes('message', inputs)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Applying columnWrapperStyle Prop to Multiple Columns\nDESCRIPTION: Applies a style to each column's wrapper view when using multiple columns with the numColumns prop.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/api/props.mdx#2025-04-11_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\ncolumnWrapperStyle?: StyleProp<ViewStyle>;\n```\n\n----------------------------------------\n\nTITLE: Using useVerifyOneRender Hook in React\nDESCRIPTION: Shows how to use useVerifyOneRender() to ensure components only render once. Useful for optimizing render performance.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/react/tracing.mdx#2025-04-11_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useVerifyOneRender } from \"@legendapp/state/trace\";\n\nconst Component = observer(function Component(props) {\n  // Call useVerifyOneRender anywhere inside the component\n  useVerifyOneRender();\n\n  const count = use$(state$.count)\n\n  // This will log an error after one render when count is updated\n  return <div>{count}</div>;\n});\nconst Component = observer(function Component(props) {\n  // Call useVerifyOneRender anywhere inside the component\n  useVerifyOneRender();\n\n  const count = state$.count.peek()\n\n\n  // This will not log because `get(false)` does not track observable\n  // does not re-render this component\n  return <div>{state.count.peek()}</div>;\n});\n```\n\n----------------------------------------\n\nTITLE: Using the new primitive value property instead of current\nDESCRIPTION: Shows how to update code for primitive observables which now use 'value' instead of 'current'. Unlike before, the value property can now be directly modified.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/other/migrating.mdx#2025-04-11_snippet_18\n\nLANGUAGE: javascript\nCODE:\n```\nconst obs = observable(10);\n// Before\nobs.current === 10;\nobs.curent = 20; //  Error\n// Now\nobs.value === 10;\nobs.value = 20; //  Works\n```\n\n----------------------------------------\n\nTITLE: Batching Array Operations for Performance\nDESCRIPTION: Demonstrates how batching can prevent excessive renders when performing multiple array operations. Shows optimization for bulk array updates using batching.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/usage/reactivity.mdx#2025-04-11_snippet_14\n\nLANGUAGE: javascript\nCODE:\n```\nconst state$ = observable({ items: [] });\n\nfunction addItems() {\n  for (let i = 0; i < 1000; i++) {\n    state$.items.push({ text: `Item ${i}` });\n  }\n}\n\n//  This can render 1000 times while pushing to the array\naddItems();\n\n//  Batching delays until complete and renders once\nbatch(addItems);\n```\n\n----------------------------------------\n\nTITLE: Using extraData Prop for Re-rendering\nDESCRIPTION: Extra data that will trigger a re-render when changed, even if the data items haven't changed. Useful for dependent data outside the item array.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/api/props.mdx#2025-04-11_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nextraData?: any;\n```\n\n----------------------------------------\n\nTITLE: Migrating from computed to observable functions\nDESCRIPTION: Shows how to migrate from the separate computed concept to using functions within observables directly, which is more efficient and the recommended pattern in version 3.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/other/migrating.mdx#2025-04-11_snippet_9\n\nLANGUAGE: ts\nCODE:\n```\n// Change\nconst compValue$ = computed(() => /* ... */)\n// to\nconst compValue$ = observable(() => /* ... */)\n\n// Change\nconst state$ = observable(() => ({\n    value: 1,\n    comp: computed(() => state$.value.get())\n}))\n// to\nconst state$ = observable(() => ({\n    value: 1,\n    comp: () => state$.value.get()\n}))\n```\n\n----------------------------------------\n\nTITLE: Implementing Batching in JavaScript Observables\nDESCRIPTION: Shows the new syntax for batching operations in Legend State, using individually exported batching functions instead of the removed 'observableBatcher' namespace.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/other/migrating.mdx#2025-04-11_snippet_31\n\nLANGUAGE: javascript\nCODE:\n```\nimport { batch, beginBatch, endBatch } from '@legendapp/state'\n\n// begin/end\nbeginBatch()\nobs1.set(...)\nobs2.set(...)\nendBatch()\n\n// batch()\nbatch(() => {\n    obs1.set(...)\n    obs2.set(...)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Observables with Functions and Computed Values\nDESCRIPTION: This example demonstrates creating an observable with methods and computed properties. The observable includes action functions and a computed fullname that automatically updates when its dependencies change.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/usage/observable.mdx#2025-04-11_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { computed, observable } from \"@legendapp/state\";\n\nconst state$ = observable({\n  fname: \"hello\",\n  lname: \"there\",\n  setName: (name: string) => {\n    // Create Actions by just adding a function\n    const [fname, lname] = name.split(name);\n    state$.assign({\n      fname,\n      lname,\n    });\n  },\n  fullname: computed((): Observable<string> => {\n    // Set up computed observables within your state object\n    // or if you prefer them elsewhere that's cool too \n    return `${state$.fname.get()} ${state$.lname.get()}`;\n  }),\n});\n\nconsole.log(state$.fullname.get());\n// hello there\n```\n\n----------------------------------------\n\nTITLE: Enabling horizontal Mode for LegendList\nDESCRIPTION: When set to true, renders all items in the list horizontally instead of vertically.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/api/props.mdx#2025-04-11_snippet_10\n\nLANGUAGE: TypeScript\nCODE:\n```\nhorizontal?: boolean; // default: false\n```\n\n----------------------------------------\n\nTITLE: Using individual exports for React Native components\nDESCRIPTION: Shows the new pattern for using reactive components in React Native with individual component exports rather than a namespace, which provides better typing and bundle size optimization.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/other/migrating.mdx#2025-04-11_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\nimport { $TextInput } from \"@legendapp/state/react-native\"\n\nfunction Component() {\n    return (\n        <$TextInput\n            $value={state$.name}\n        />\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Using For Component for Optimized Array Rendering in React\nDESCRIPTION: Explains how to use the For component from Legend-State to optimize rendering of arrays in React. It demonstrates two ways of using the component: with an item prop and with a render function as a child.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/guides/performance.mdx#2025-04-11_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nimport { observable } from \"@legendapp/state\"\nimport { For } from \"@legendapp/state/react\"\n\nconst state$ = observable({ arr: [{ id: 1, text: 'hi' }]})\n\nfunction Row({ item }) {\n    return <div>{item.text}</div>\n}\nfunction List() {\n    // 1. Use the For component with an item prop\n    return <For each={state$.arr} item={Row} />\n\n    // 2. Use the For component with a render function as the child\n    return (\n        <For each={list}>\n            {item => (\n                <div>\n                    {item.text}\n                </div>\n            )}\n        </div>\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Full Keel Integration Example with Legend-State\nDESCRIPTION: Comprehensive example demonstrating a complete setup for Keel integration with Legend-State, including authentication, persistence, and message operations.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/keel.mdx#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { observable } from '@legendapp/state'\nimport { ObservablePersistLocalStorage } from '@legendapp/state/persist-plugins/local-storage'\nimport { configureSynced } from '@legendapp/state/sync/'\nimport { generateKeelId, syncedKeel } from '@legendapp/state/sync-plugins/keel'\nimport { APIClient } from './keelClient'\n\nconst client = new APIClient({\n  baseUrl: process.env.API_BASE_URL\n})\n\nconst isAuthed$ = observable(false);\n\n// Set defaults\nconst sync = configureSynced(syncedKeel, {\n    client,\n    persist: {\n        plugin: ObservablePersistLocalStorage,\n        retrySync: true\n    },\n    debounceSet: 500,\n    retry: {\n        infinite: true,\n    },\n    changesSince: 'last-sync',\n    waitFor: isAuthed$\n})\n\n// enable sync after authentication succeeds\nasync function doAuth() {\n    // authenticate the client\n    await keel.auth.authenticateWithPassword(email, pass)\n\n    // check that the client is authenticated\n    const isAuthenticated = await keel.auth.isAuthenticated()\n\n    // Set isAuthed$ to start syncing\n    isAuthed$.set(true)\n}\n\n// Set up your observables with Keel queries\nconst { mutations, queries } = client.api\n\n// create an observable with the action functions\nconst messages$ = observable(sync({\n    list: queries.getMessages,\n    create: mutations.createMessage,\n    update: mutations.updateMessage,\n    delete: mutations.deleteMessage,\n    persist: { name: 'messages' },\n}))\n\n// get() activates and starts syncing\nconst messages = messages$.get()\n\nfunction addMessage(text: string) {\n    const id = generateKeelId()\n    // Add keyed by id to the messages$ observable to trigger the create action\n    messages$[id].set({\n        id,\n        text,\n        createdAt: undefined,\n        updatedAt: undefined\n    })\n}\n\nfunction updateMessage(id: string, text: string) {\n    // Just set valudes in the observable to trigger the update action\n    messages$[id].text.set(text)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ListEmptyComponent for Empty Lists\nDESCRIPTION: Specifies a component to render when the list is empty. Useful for displaying loading states or messages when no data is available.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/api/props.mdx#2025-04-11_snippet_15\n\nLANGUAGE: TypeScript\nCODE:\n```\nListEmptyComponent?: React.ComponentType<any> | React.ReactElement | null | undefined;\n```\n\n----------------------------------------\n\nTITLE: Configuring IndexedDB Persistence for Non-Dictionary Observable in Legend-State\nDESCRIPTION: Example of using persistObservable with an IndexedDB configuration that uses the itemID option to persist a non-dictionary observable to a specific row in the table.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/other/migrating.mdx#2025-04-11_snippet_23\n\nLANGUAGE: javascript\nCODE:\n```\nconst settings = observable({ theme: \"light\" });\npersistObservable(settings, {\n  local: {\n    name: \"store\",\n    indexedDB: {\n      itemID: \"settings\",\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Migrating from useComputed to useObservable\nDESCRIPTION: Shows how to migrate from useComputed to useObservable hooks, which provides the same functionality with a new name that better reflects its use with the observable pattern.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/other/migrating.mdx#2025-04-11_snippet_11\n\nLANGUAGE: ts\nCODE:\n```\n// Change\nconst state$ = useComputed(() => state$.text.get())\n// To\nconst state$ = useObservable(() => state$.text.get())\n```\n\n----------------------------------------\n\nTITLE: Configuring React Integration in Legend-State\nDESCRIPTION: Shows how to enable automatic React tracking for Legend-State observables using the enableReactTracking configuration function.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/intro/getting-started.mdx#2025-04-11_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nimport { enableReactTracking } from \"@legendapp/state/config/enableReactTracking\";\n// This makes React components automatically track get() calls to re-render\nenableReactTracking({ auto: true });\n```\n\n----------------------------------------\n\nTITLE: Styling Footer Container with ListFooterComponentStyle\nDESCRIPTION: Applies styling to the internal View container that wraps the ListFooterComponent, allowing customization of its appearance.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/api/props.mdx#2025-04-11_snippet_18\n\nLANGUAGE: TypeScript\nCODE:\n```\nListFooterComponentStyle?: StyleProp<ViewStyle> | undefined;\n```\n\n----------------------------------------\n\nTITLE: Handling Asynchronous Persistence Loading\nDESCRIPTION: Example showing how to wait for asynchronous persistence to load before accessing the data. This is necessary for persistence plugins like IndexedDB and AsyncStorage that require time to load.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/persist-sync.mdx#2025-04-11_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { syncState } from \"@legendapp/state\"\nimport { syncObservable } from '@legendapp/state/sync'\n\nsyncObservable(state$, {\n    persist: {\n        name: 'store'\n    }\n})\nconst status$ = syncState(state$)\nawait when(status$.isPersistLoaded)\n// Proceed with load\n```\n\n----------------------------------------\n\nTITLE: Updating persistObservable Usage in Legend-State\nDESCRIPTION: This snippet demonstrates how to update the usage of persistObservable to handle the new return value structure, which includes a state property for sync state.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/other/migrating.mdx#2025-04-11_snippet_17\n\nLANGUAGE: javascript\nCODE:\n```\nconst { state } = persistObservable(initialStateOrObservable, { ... })\n```\n\n----------------------------------------\n\nTITLE: Using useVerifyNotTracking Hook in React\nDESCRIPTION: Demonstrates useVerifyNotTracking() to verify that a component is not tracking any observables. Useful for ensuring fine-grained reactivity.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/react/tracing.mdx#2025-04-11_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useVerifyNotTracking } from \"@legendapp/state/trace\";\n\nconst Component = observer(function Component(props) {\n  // Call useVerifyNotTracking anywhere inside the component\n  useVerifyNotTracking();\n\n  const count = use$(state$.count)\n\n  // This will log an error because get() makes it track\n  return <div>{count}</div>;\n});\nconst FineComponent = observer(function FineComponent(props) {\n  // Call useVerifyNotTracking anywhere inside the component\n  useVerifyNotTracking();\n\n  // This will not log because rendering the observable directly\n  // does not re-render this component\n  return <Memo>{state$.count}</Memo>;\n});\n```\n\n----------------------------------------\n\nTITLE: Adding ListHeaderComponent to List Top\nDESCRIPTION: Renders a component at the top of all list items. Can be used for search bars, filters, or header information.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/api/props.mdx#2025-04-11_snippet_19\n\nLANGUAGE: TypeScript\nCODE:\n```\nListHeaderComponent?: React.ComponentType<any> | React.ReactElement | null | undefined;\n```\n\n----------------------------------------\n\nTITLE: Implementing Pagination with Synced Observables\nDESCRIPTION: Demonstrates how to implement pagination using synced observables with the 'append' mode. This allows new pages of data to be appended to the existing array when the page number changes.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/persist-sync.mdx#2025-04-11_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { observable, observe } from \"@legendapp/state\"\nimport { syncedFetch } from \"@legendapp/state/sync-plugins/fetch\"\n\n// Create an observable with \"users\" synced\nconst store$ = observable({\n    usersPage: 1,\n    users: syncedFetch({\n        get: () => `https://reqres.in/api/users?page=${store$.usersPage.get()}`,\n        mode: 'append'\n    }),\n})\n\n// Activate the synced to get the first page\nstore$.users.get()\n// gets from https://reqres.in/api/users?page=1\n\n// Get the next page\nstore$.usersPage.set(page => page + 1)\n// gets from https://reqres.in/api/users?page=2\n```\n\n----------------------------------------\n\nTITLE: Updating Persistence Plugin Names in JavaScript\nDESCRIPTION: Demonstrates the renaming of persistence plugin options for clarity, changing from persistLocal to pluginLocal.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/other/migrating.mdx#2025-04-11_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\npersistObservable(initialStateOrObservable, {\n    // Before\n    persistLocal: ObservablePersistLocalStorage\n    // After\n    pluginLocal: ObservablePersistLocalStorage\n })\n```\n\n----------------------------------------\n\nTITLE: Using Reactive Components Example\nDESCRIPTION: Example demonstrating how to use reactive components with dynamic styles and class names.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/usage/configuring.mdx#2025-04-11_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Reactive } from \"@legendapp/state/react\"\n\nfunction Component() {\n  return (\n    <Reactive.div\n      $style={() => ({\n        color: state.age.get() > 5 ? \"green\" : \"red\",\n      })}\n      $className={() => (state.age.get() > 5 ? \"kid\" : \"baby\")}\n    />\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling maintainScrollAtEnd for Chat Interfaces\nDESCRIPTION: When enabled, checks if the list is scrolled to the bottom when data changes and maintains that position. Useful for chat interfaces that should stay scrolled to the latest messages.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/api/props.mdx#2025-04-11_snippet_20\n\nLANGUAGE: TypeScript\nCODE:\n```\nmaintainScrollAtEnd?: boolean;\n```\n\n----------------------------------------\n\nTITLE: Using Synced Observable in React Components\nDESCRIPTION: Demonstrates creating and using synced observables within React components using useObservable hook.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/persist-sync.mdx#2025-04-11_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { synced } from '@legendapp/state/sync'\nimport { useObservable } from '@legendapp/state/react'\n\nfunction Component() {\n    const user$ = useObservable(synced({\n        get: fetch('https://url.to.get').then((res) => res.json()),\n        persist: {\n            name: 'test'\n        }\n    }))\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating Promise Error Handling in Legend-State\nDESCRIPTION: This snippet demonstrates how to update error handling for Promises in observables. Instead of checking the 'error' property directly on the observable, it now uses the 'state.error' property.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/other/migrating.mdx#2025-04-11_snippet_13\n\nLANGUAGE: javascript\nCODE:\n```\n// Old way\nif (observable$.error) {\n  // Handle error\n}\n\n// New way\nif (observable$.state.error) {\n  // Handle error\n}\n```\n\n----------------------------------------\n\nTITLE: Batching State Changes in Legend-State\nDESCRIPTION: Demonstrates how to batch multiple state changes together to prevent excessive re-renders. When adding many items to an array, batching ensures the UI only updates once instead of potentially updating for each individual addition.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/guides/performance.mdx#2025-04-11_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst state$ = observable({ items: [] });\n\nfunction addItems() {\n  for (let i = 0; i < 1000; i++) {\n    state$.items.push({ text: `Item ${i}` });\n  }\n}\n\n//  This can render 1000 times while pushing to the array\naddItems();\n\n//  Batching delays until complete and renders once\nbatch(addItems);\n```\n\n----------------------------------------\n\nTITLE: Setting maintainScrollAtEndThreshold for Bottom Detection\nDESCRIPTION: Defines what percentage of the screen counts as being at the bottom for the maintainScrollAtEnd functionality. The default is 0.1 (10% from bottom).\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/api/props.mdx#2025-04-11_snippet_21\n\nLANGUAGE: TypeScript\nCODE:\n```\nmaintainScrollAtEndThreshold?: number;\n```\n\n----------------------------------------\n\nTITLE: Local Storage Persistence Plugin Configuration\nDESCRIPTION: Shows how to configure the Local Storage persistence plugin for React applications.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/persist-sync.mdx#2025-04-11_snippet_16\n\nLANGUAGE: javascript\nCODE:\n```\nimport { ObservablePersistLocalStorage } from '@legendapp/state/persist-plugins/local-storage'\n\nsyncObservable(state$, {\n    persist: {\n        name: \"documents\",\n        plugin: ObservablePersistLocalStorage\n    }\n})\n```\n\n----------------------------------------\n\nTITLE: Enabling Direct Peek\nDESCRIPTION: Configuration for enabling direct peek access to observable values without tracking.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/usage/configuring.mdx#2025-04-11_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nimport { enableDirectPeek } from \"@legendapp/state/config/enableDirectPeek\"\nenableDirectPeek()\n```\n\n----------------------------------------\n\nTITLE: Enabling Direct Observable Access in JavaScript\nDESCRIPTION: This snippet demonstrates how to enable and use the $GetSet feature, which allows direct access and modification of observable values using the $ symbol.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/usage/configuring.mdx#2025-04-11_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { enable$GetSet } from \"@legendapp/state/config/enable$GetSet\";\nenable$GetSet();\n```\n\nLANGUAGE: javascript\nCODE:\n```\nimport { observable } from \"@legendapp/state\"\n\nconst state$ = observable({ test: \"hi\", num: 0 })\n\n// $ is a shorthand for get()\nconst testValue = state$.test.$\n\n// Assign to $ as a shorthand for set()\nstate$.test.$ = \"hello\"\n\n// Assign objects too just like you can with set()\nstate$.$ = { test: \"hello\" }\n\n// Incrementing works as you'd expect\nstate$.num.$++\n```\n\n----------------------------------------\n\nTITLE: Setting onEndReachedThreshold for Load More Trigger\nDESCRIPTION: Defines how close to the end of the list (as a percentage of screen size) the user must scroll to trigger onEndReached. A value of 0.5 means half a screen away.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/api/props.mdx#2025-04-11_snippet_25\n\nLANGUAGE: TypeScript\nCODE:\n```\nonEndReachedThreshold?: number | null | undefined;\n```\n\n----------------------------------------\n\nTITLE: Persisting Observables with synced in Constructor\nDESCRIPTION: Alternative approach to persistence using the synced function directly in the observable constructor. This initializes persistence at the time of observable creation rather than afterwards.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/persist-sync.mdx#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { observable } from \"@legendapp/state\"\nimport { synced } from \"@legendapp/state/sync\"\n\n// Create an observable with \"todos\" persisted\nconst store$ = observable(\n    synced({\n        initial: [],\n        persist: {\n            name: 'persistKey',\n        }\n    })\n)\n\n// Any changes will be persisted\nstore$.todos.push({ id: 0 })\n```\n\n----------------------------------------\n\nTITLE: Implementing Delete Operations with syncedCrud in TypeScript\nDESCRIPTION: Example showing how to implement the delete function in syncedCrud with error handling and confirmation support.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/crud.mdx#2025-04-11_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst profile$ = observable(syncedCrud({\n    // ...\n    delete: ({ id }, options) => {\n        const { data, error } = await serverDeleteProfile(id);\n        if (error) {\n            // Handle error, throw an Error to trigger a retry\n        } else if (data) {\n            return data;\n        }\n    }\n}))\n```\n\n----------------------------------------\n\nTITLE: Using currentDate Observable in Legend-State\nDESCRIPTION: Demonstrates how to use the currentDate observable to track the current date, which updates automatically at midnight.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/react/helpers-and-hooks.mdx#2025-04-11_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { currentDate } from \"@legendapp/state/helpers/time\"\n\nobserve(() => {\n    console.log('Today is': currentDate.get())\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Pull-to-Refresh with onRefresh\nDESCRIPTION: Callback triggered when a user pulls down to refresh the list. Used in conjunction with the refreshing prop to show a loading indicator.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/api/props.mdx#2025-04-11_snippet_27\n\nLANGUAGE: TypeScript\nCODE:\n```\nonRefresh?: () => void;\n```\n\n----------------------------------------\n\nTITLE: Persisting Observables with syncObservable in React Native\nDESCRIPTION: Example showing how to create an observable with initial data and persist it using syncObservable with MMKV storage in React Native. This demonstrates how to set up persistence after an observable is created.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/persist-sync.mdx#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { observable } from \"@legendapp/state\"\nimport { syncObservable } from \"@legendapp/state/sync\"\nimport { ObservablePersistMMKV } from \"@legendapp/state/persist-plugins/mmkv\"\n\n// Create an observable\nconst store$ = observable({\n  todos: [],\n})\n\n// Persist the observable to the named key of the global persist plugin\nsyncObservable(store$, {\n    persist: {\n        name: 'persistKey',\n        plugin: ObservablePersistMMKV\n    }\n})\n\n// Any changes made after syncObservable will be persisted\nstore$.todos.push({ id: 0 })\n```\n\n----------------------------------------\n\nTITLE: Using useMount Hook in Legend-State for React\nDESCRIPTION: The useMount hook provides a convenient way to run code when a component mounts, without using dependency arrays. It uses useEffectOnce under the hood.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/react/react-API.mdx#2025-04-11_snippet_8\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useMount } from \"@legendapp/state/react\"\n\nconst Component = () => {\n  useMount(() => console.log(\"mounted\"))\n}\n```\n\n----------------------------------------\n\nTITLE: Using Reactive Components in React Native with Legend-State\nDESCRIPTION: Demonstrates the use of reactive versions of React Native components provided by Legend-State, including reactive styling, children, and two-way binding for inputs.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/react/fine-grained-reactivity.mdx#2025-04-11_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nimport { $View, $Text, $TextInput } from \"@legendapp/state/react-native\"\n\nfunction Component() {\n    // This component renders only once\n    const state$ = useObservable({ name: '', age: 18 })\n\n    return (\n        <div>\n            {/* Reactive styling */}\n            <$View\n                $style={() => ({\n                    color: state$.age.get() > 5 ? 'green' : 'red'\n                })}\n            />\n            {/* Reactive children */}\n            <$Text>\n                {() => state$.age.get() > 5 ? 'child' : 'baby'}\n            </$Text>\n            {/* Two-way bind to inputs */}\n            <$TextInput $value={state$.name} />\n        </div>\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Fine-grained Reactivity Components in Legend-State\nDESCRIPTION: Shows advanced usage of Legend-State's fine-grained reactivity components like Memo, For, Reactive, Show, and Switch for optimized rendering.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/react/react-introduction.mdx#2025-04-11_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nimport { observable } from \"@legendapp/state\";\nimport { Memo, For, Reactive, Show, Switch } from \"@legendapp/state/react\";\n\nconst state$ = observable({ showModal: false, page: 0, users: [] });\n\nfunction MemoExample() {\n  // This component itself never re-renders\n\n  return (\n    <div>\n      // Reactive components have reactive props and children which re-render\n      themselves on changes\n      <Reactive.div\n        $className={state$.showModal.get() ? \"bg-blue-500\" : \"bg-red-500\"}\n      >\n        {() => `Showing page: ${state$.page.get()}`}\n      </Reactive.div>\n      // Show re-renders itself whenever showModal changes\n      <Show if={state$.showModal}>{() => <Modal />}</Show>\n      // Switch re-renders itself whenever page changes\n      <Switch value={state$.page}>\n        {{\n          0: <Page0 />,\n          1: <Page1 />,\n          2: <Page2 />,\n        }}\n      </Switch>\n      // For optimizes array updates to be much faster\n      <For each={state$.users} item={User} optimized />\n    </div>\n  );\n}\n\nfunction User({ item }) {\n  return <Memo>{item.name}</Memo>;\n}\n```\n\n----------------------------------------\n\nTITLE: Adjusting RefreshControl Position with progressViewOffset\nDESCRIPTION: Sets an offset in pixels for the refresh indicator. Useful when the list has headers or is displayed below other UI elements.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/api/props.mdx#2025-04-11_snippet_31\n\nLANGUAGE: TypeScript\nCODE:\n```\nprogressViewOffset?: number | undefined;\n```\n\n----------------------------------------\n\nTITLE: Using syncedFetch Plugin with Legend State in TypeScript\nDESCRIPTION: Example of using the syncedFetch plugin to create an observable state that syncs with remote endpoints. The example demonstrates setting up GET and POST endpoints with a custom handler for processing the response data.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/fetch.mdx#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { syncedFetch } from '@legendapp/state/sync-plugins/fetch';\nimport { observable } from '@legendapp/state';\n\nconst state$ = observable(syncedFetch({\n    get: 'https://url.to.get',\n    set: 'https://url.to.set',\n    onSaved: (value) => {\n        return {\n            updatedAt: value.updatedAt\n        }\n    }\n}))\n```\n\n----------------------------------------\n\nTITLE: Deleting Observable Properties\nDESCRIPTION: This snippet shows how to use delete() to remove a key from an observable object or set an observable to undefined.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/usage/observable.mdx#2025-04-11_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nconst state$ = observable({ text: \"hi\" });\n\n// Delete text\nstate$.text.delete();\n\n// Set the whole value to undefined\nstate$.delete();\n```\n\n----------------------------------------\n\nTITLE: Replacing Direct Rendering with Memo Component in React\nDESCRIPTION: This code shows how to replace the deprecated direct rendering of observables with the new Memo component in React applications using Legend-State.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/other/migrating.mdx#2025-04-11_snippet_14\n\nLANGUAGE: jsx\nCODE:\n```\n// Remove these:\nenableLegendStateReact();\nenableLegendStateReact();\n\nfunction Component() {\n  const text$ = useObservable(\"test\");\n  return (\n    <>\n      Change this: {text$}\n      To this: <Memo>{text$}</Memo>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Style Prop in LegendList\nDESCRIPTION: Defines the style prop that can be applied to the underlying ScrollView of the LegendList component.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/api/props.mdx#2025-04-11_snippet_36\n\nLANGUAGE: typescript\nCODE:\n```\nstyle?: StyleProp<ViewStyle>;\n```\n\n----------------------------------------\n\nTITLE: Implementing Changes-Since Sync with Legend-State\nDESCRIPTION: Demonstrates how to use the changesSince option with syncedKeel to sync only data that has changed since the last sync, for both lists and single values.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/keel.mdx#2025-04-11_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n// Sync diffs of a list\nsyncedKeel({\n    list: queries.listMessages,\n    changesSince: 'last-sync',\n    persist: {\n        name: 'messages'\n    }\n})\n// Sync diffs of a single value\nsyncedKeel({\n    list: queries.listUserById,\n    where: { id: myId },\n    as: 'value',\n    changesSince: 'last-sync',\n    persist: {\n        name: 'me'\n    }\n})\n```\n\n----------------------------------------\n\nTITLE: Custom Key Extraction for Observable Arrays\nDESCRIPTION: Shows how to specify a custom key extractor function for arrays where objects use a different field than 'id' or 'key' as their unique identifier.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/guides/performance.mdx#2025-04-11_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst data$ = observable({\n  arr: [],\n  arr_keyExtractor: (item) => item.idObject._id,\n});\n```\n\n----------------------------------------\n\nTITLE: Setting estimatedItemSize Prop in LegendList\nDESCRIPTION: An estimated size for all items which is used to estimate the list layout before items actually render. If not provided, the component will log a suggested value for optimal performance.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/api/props.mdx#2025-04-11_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nestimatedItemSize?: number;\n```\n\n----------------------------------------\n\nTITLE: Configuring ViewabilityConfigCallbackPairs in LegendList\nDESCRIPTION: Defines a list of ViewabilityConfig/onViewableItemsChanged pairs where callbacks are triggered when their corresponding configuration conditions are met.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/api/props.mdx#2025-04-11_snippet_38\n\nLANGUAGE: typescript\nCODE:\n```\nviewabilityConfigCallbackPairs?: ViewabilityConfigCallbackPairs | undefined;\n```\n\n----------------------------------------\n\nTITLE: Configuring Keel Model for Sync Diff Support\nDESCRIPTION: Defines a Keel model with updatedAt parameter in the list action to enable syncing only changed data since the last query.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/keel.mdx#2025-04-11_snippet_9\n\nLANGUAGE: text\nCODE:\n```\nmodel Message {\n    ...\n    actions {\n        list listMessages(updatedAt?)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using React Suspense with Legend-State\nDESCRIPTION: Using the suspense option with use$ makes the component work with React Suspense. When the observable is a Promise, Suspense will render the fallback until the promise resolves.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/react/react-API.mdx#2025-04-11_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useObservable, useSelector } from \"@legendapp/state/react\"\nimport { Suspense } from \"react\"\n\nfunction Test({ state$ }) {\n  const value = useSelector(state$, { suspense: true })\n  return <div>{value}</div>\n}\n\nexport default function App() {\n  const state$ = useObservable(\n    new Promise((resolve) => {\n      setTimeout(() => {\n        resolve(\"hello\")\n      }, 1000)\n    })\n  )\n  return (\n    <div>\n      <div>Suspense test</div>\n      <Suspense fallback={<div>Loading...</div>}>\n        <Test state$={state$} />\n      </Suspense>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Persistence with Legend-State in TypeScript\nDESCRIPTION: This snippet demonstrates how to set up persistence for a Legend-State observable using MMKV storage. It shows global configuration for sync and persistence, and how to sync an observable with storage.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/intro/getting-started.mdx#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { observable } from \"@legendapp/state\"\nimport { syncObservable } from '@legendapp/state/sync'\nimport { ObservablePersistMMKV } from \"@legendapp/state/persist-plugins/mmkv\"\n\nconst store$ = observable<Store>({\n    todos: {},\n})\n\n// Persist the observable to the named key of the global persist plugin\nsyncObservable(store$, {\n    persist: {\n        name: 'gettingStarted',\n        plugin: ObservablePersistMMKV\n    }\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing TanStack Query Plugin with Legend State\nDESCRIPTION: Demonstrates how to use persistPluginQuery to integrate TanStack Query with Legend State. The example shows pagination implementation using observable query keys that update automatically when dependencies change.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/guides/persistence.mdx#2025-04-11_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\nimport { observable } from \"@legendapp/state\"\nimport { persistObservable } from \"@legendapp/state/persist\"\nimport { persistPluginQuery } from \"@legendapp/state/persist-plugins/query\"\nimport { QueryClient } from \"@tanstack/react-query\"\n\nconst queryClient = new QueryClient();\n\nconst page$ = observable(1)\n\nconst obs$ = persistObservable(\n  { initialValue: \"hello\" },\n  {\n    pluginRemote: persistPluginQuery({\n      queryClient,\n      query: {\n        // queryKey is a computed function that updates the query when page$ changes\n        queryKey: () => [\"key\", page$.get()],\n        queryFn: () => {\n          return fetch(\"https://url.to.get?page=\" + page$.get()).then((res) =>\n            res.json()\n          )\n        },\n      },\n    }),\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Setting waitForInitialLayout Prop in LegendList\nDESCRIPTION: Controls whether the component delays rendering until the initial layout is complete. Default is false.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/api/props.mdx#2025-04-11_snippet_39\n\nLANGUAGE: typescript\nCODE:\n```\nwaitForInitialLayout?: boolean; // default false\n```\n\n----------------------------------------\n\nTITLE: Using List Action in Keel with Legend-State\nDESCRIPTION: Shows how to use the 'list' action with the Keel plugin in Legend-State, explaining how the data is structured and how to perform create, update, and delete operations.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/keel.mdx#2025-04-11_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst { mutations, queries } = client.api\n\nconst profiles$ = observable(syncedKeel({\n    list: queries.listProfiles,\n    create: mutations.createProfile,\n    update: mutations.updateProfile,\n    delete: mutations.deleteProfile,\n}))\n// profile$.get() is a Record<string, Profile>\n```\n\n----------------------------------------\n\nTITLE: Using useTraceListeners() in React with Legend State\nDESCRIPTION: Demonstrates how to use useTraceListeners() to log tracked observables in a React component. This hook helps identify which observables are being listened to for changes.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/react/tracing.mdx#2025-04-11_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useTraceListeners } from \"@legendapp/state/trace\";\n\nconst Component = observer(function Component(props) {\n  // Call useTraceListeners anywhere inside the component\n  useTraceListeners();\n\n  return <div>{state.count.get()}</div>;\n\n  /* This logs:\n\n    [legend-state] tracking 1 observable:\n    1: count\n\n    */\n});\n```\n\n----------------------------------------\n\nTITLE: Using the when function for one-time reactions\nDESCRIPTION: Examples of using the when function to run code or resolve a promise when a condition becomes truthy. It automatically tracks observables and disposes listeners after triggering.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/usage/reactivity.mdx#2025-04-11_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nimport { when } from \"@legendapp/state\";\n\nconst state$ = observable({ ok: false });\n\n// Option 1: Promise\nawait when(state$.ok);\n\n// Option 2: callback\nwhen(\n  () => state$.ok.get(),\n  () => console.log(\"Don't worry, it's ok\")\n);\n```\n\n----------------------------------------\n\nTITLE: Using scrollToEnd Method in LegendList\nDESCRIPTION: Scrolls to the end of the list with an optional animation parameter that defaults to true.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/api/props.mdx#2025-04-11_snippet_43\n\nLANGUAGE: typescript\nCODE:\n```\nscrollToEnd(params?: {\n  animated?: boolean,\n});\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Keel Model in DSL\nDESCRIPTION: Shows a basic example of a Keel model definition with fields and actions for a Profile model, including get, create, update, and delete operations.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/keel.mdx#2025-04-11_snippet_0\n\nLANGUAGE: keel\nCODE:\n```\nmodel Profile {\n    fields {\n        name Text\n    }\n\n    actions {\n        get getProfile()\n        create createProfile() with (name)\n        update updateProfile(id) with (name)\n        delete deleteProfile(id)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Soft Delete with syncedCrud in TypeScript\nDESCRIPTION: Example showing how to implement soft delete functionality using the fieldDeleted option instead of a hard delete operation.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/crud.mdx#2025-04-11_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst profile$ = observable(syncedCrud({\n    // ...\n    update: () => {/* ... */},\n    fieldDeleted: 'deleted'\n}))\n```\n\n----------------------------------------\n\nTITLE: Using Observable State with get() and set() in JavaScript\nDESCRIPTION: This snippet demonstrates the basic usage of Legend-State observables, showing how to create an observable state object, get its value, set a new value, and automatically track changes with the observe function.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/intro/why.mdx#2025-04-11_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nconst state$ = observable({ value: 1 });\nstate$.value.get();\nstate$.value.set(2);\n\n// Tracks automatically and runs on every change\nobserve(() => {\n  console.log(state$.value.get());\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring State Persistence with Local Storage and Firebase\nDESCRIPTION: This snippet shows how to set up state persistence in Legend-State using both local storage and Firebase. It demonstrates importing persistence plugins, creating an observable state object, and configuring persistence with both local and remote options.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/intro/why.mdx#2025-04-11_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nimport { ObservablePersistLocalStorage } from '@legendapp/state/persist-plugins/local-storage'\nimport { ObservablePersistFirebase } from \"@legendapp/state/persist-plugins/firebase\"\nimport { persistObservable } from '@legendapp/state/persist'\nimport { observable } from '@legendapp/state'\n\nconst state$ = observable({ store: { bigObject: { ... } } })\n\n// Persist this observable\npersistObservable(state$, {\n    pluginLocal: ObservablePersistLocalStorage,\n    local: 'store',\n    pluginRemote: ObservablePersistFirebase,\n    remote: {\n        firebase: {\n            refPath: (uid) => `/users/${uid}/`,\n            requireAuth: true,\n        },\n    }\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Recycling Hooks in LegendList Items\nDESCRIPTION: Example showing how to use the recycling hooks within a list item component to manage state and side effects during item recycling.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/api/props.mdx#2025-04-11_snippet_45\n\nLANGUAGE: tsx\nCODE:\n```\nexport function ItemComponent({ item, useRecyclingEffect, useRecyclingState }) {\n\n    // Like useState but it resets when the item is recycled\n    const [isExpanded, setIsExpanded] = useRecyclingState(() => false);\n\n    // A callback when the item is recycled into a new item\n    useRecyclingEffect?.(({ item, prevItem, index, prevIndex }) => {\n        // Reset any side effects from the previous item\n        refSwipeable?.current?.close();\n        refVideo?.current?.reset();\n    });\n\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TanStack Query Outside React\nDESCRIPTION: Shows how to use syncedQuery outside of React components using @tanstack/query-core. This implementation works with the core Query functionality without React dependencies.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/tanstack-query.mdx#2025-04-11_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { syncedQuery } from '@legendapp/state/sync-plugins/tanstack-query';\nimport { QueryClient } from '@tanstack/react-query';\n\nconst queryClient = new QueryClient()\n\nconst state$ = observable(syncedQuery({\n    queryClient,\n    query: {\n        queryKey: ['user'],\n        queryFn: async () => {\n            return fetch('https://reqres.in/api/users/1').then((v) => v.json())\n        },\n    },\n    mutation: {\n        mutationFn: async (variables) => {\n            return fetch(\n                'https://reqres.in/api/users/1',\n                { body: JSON.stringify(variables), method: 'POST' }\n            )\n        },\n    },\n}))\n\nobserve(() => {\n    // get() the value to start syncing, and it will be reactive to updates coming in\n    console.log(state$.get())\n})\n```\n\n----------------------------------------\n\nTITLE: Updating Persistence Plugin Names in Legend-State\nDESCRIPTION: This code shows how to update the persistence plugin names in Legend-State, specifically changing persistLocal to pluginLocal for clarity.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/other/migrating.mdx#2025-04-11_snippet_18\n\nLANGUAGE: javascript\nCODE:\n```\npersistObservable(initialStateOrObservable, {\n    // Before\n    persistLocal: ObservablePersistLocalStorage\n    // After\n    pluginLocal: ObservablePersistLocalStorage\n })\n```\n\n----------------------------------------\n\nTITLE: Using Legend-State with React Context\nDESCRIPTION: Passing an observable through React Context provides the benefits of Context without the downsides like unnecessary re-renders. Since the observable object is stable, the Context value never changes, and only components observing specific parts of the state re-render.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/react/react-API.mdx#2025-04-11_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createContext, useContext } from \"react\"\nimport { observer, useObservable } from \"@legendapp/state/react\"\n\ninterface UserState {\n    profile: {\n        name: string;\n    };\n}\n\n// Create a typed context. It can have a default value of undefined because\n// the Provider will always be created with an Observable.\nconst StateContext = createContext<Observable<UserState>>(undefined as any);\n\nfunction App() {\n  const state$ = useObservable({\n    profile: {\n      name: \"\",\n    },\n  })\n\n  return (\n    <StateContext.Provider value={state$}>\n      <div>\n        <Sidebar />\n        <Main />\n      </div>\n    </StateContext.Provider>\n  )\n}\n\nconst Sidebar = function Sidebar() {\n  // StateContext will never change so this will never cause a render\n  const state$ = useContext(StateContext)\n\n  // This component never re-renders, but name re-renders itself\n  return (\n    <div>\n      Name: <Memo>{state$.profile.name}</Memo>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Using useSelector with React Suspense for asynchronous data\nDESCRIPTION: The useSelector hook can work with React Suspense by passing { suspense: true } as the second parameter. If the observable is a Promise, Suspense will render the fallback until it resolves to a value.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/react/react-API.mdx#2025-04-11_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useObservable, useSelector } from \"@legendapp/state/react\";\nimport { Suspense } from \"react\";\n\nfunction Test({ state$ }) {\n  const value = useSelector(state$, { suspense: true });\n  return <div>{value}</div>;\n}\n\nexport default function App() {\n  const state$ = useObservable(\n    new Promise((resolve) => {\n      setTimeout(() => {\n        resolve(\"hello\");\n      }, 1000);\n    })\n  );\n  return (\n    <div>\n      <div>Suspense test</div>\n      <Suspense fallback={<div>Loading...</div>}>\n        <Test state$={state$} />\n      </Suspense>\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Merging Deep Objects into Observables with mergeIntoObservable in JavaScript\nDESCRIPTION: Shows how to use mergeIntoObservable to merge a deep object into an observable while retaining existing observables and listeners. This function is used internally by persistObservable and fires listeners as values change.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/usage/helper-functions.mdx#2025-04-11_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { observable } from \"@legendapp/state\";\nimport { mergeIntoObservable } from \"@legendapp/state\";\n\nconst state$ = observable({ store: { text: \"hello\", other: \"hello there\" } });\n\nstate$.store.text.onChange(({ value }) =>\n  console.log(`text changed to \"${value}\"`)\n);\n\nconst newValue = { store: { text: \"hi\", other: \"hi there\" } };\nmergeIntoObservable(state$, newValue);\n\n// text changed to \"hi\"\n\nstate$.store === newValue.store; //  true\n```\n\n----------------------------------------\n\nTITLE: Estimating Item Sizes in Legend List (TypeScript)\nDESCRIPTION: These props help Legend List manage item sizing more efficiently. estimatedItemSize provides a default size, getEstimatedItemSize allows different size calculations per item, and onItemSizeChanged provides feedback when rendered sizes change, reducing layout shifting during rendering.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/api/performance.mdx#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nestimatedItemSize?: number;\ngetEstimatedItemSize?: (index: number, item: T) => number;\nonItemSizeChanged?: (info: {\n        size: number;\n        previous: number;\n        index: number;\n        itemKey: string;\n        itemData: ItemT;\n    }) => void;\n```\n\n----------------------------------------\n\nTITLE: Implementing Subscribe Operations with syncedCrud in TypeScript\nDESCRIPTION: Example showing how to implement real-time updates or polling using the subscribe function with refresh and update capabilities.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/crud.mdx#2025-04-11_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst profile$ = observable(syncedCrud({\n    // ...\n    list: () => {/* ... */},\n    subscribe: ({ refresh, update }) => {\n        const unsubscribe = pusher.subscribe({ /*...*/ }, (data) => {\n            // Either update with the received data\n            update(data)\n            // Or trigger a refresh of the get function\n            refresh()\n        })\n        // return unsubscribe function\n        return unsubscribe\n    }\n}))\n```\n\n----------------------------------------\n\nTITLE: Using React Auto-Tracking with Component Example\nDESCRIPTION: Example showing how to use automatic tracking in a React component after enabling the feature.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/usage/configuring.mdx#2025-04-11_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport { observable } from \"@legendapp/state\"\nconst state$ = observable({ test: \"hi\" })\n\nfunction Component() {\n  // This makes this component responsive to test changing\n  const test = state$.test.get()\n\n  return <div>{test}</div>\n}\n```\n\n----------------------------------------\n\nTITLE: Using syncObservable with Fetch Plugin\nDESCRIPTION: Demonstrates using syncObservable with the built-in fetch plugin for simplified remote data synchronization.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/persist-sync.mdx#2025-04-11_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\nimport { observable } from '@legendapp/state'\nimport { syncObservable } from '@legendapp/state/sync'\nimport { syncedFetch } from \"@legendapp/state/sync-plugins/fetch\"\n\nconst users$ = observable([])\n\nsyncObservable(users$, syncedFetch({\n    get: 'https://reqres.in/api/users',\n    set: 'https://reqres.in/api/users'\n}))\n```\n\n----------------------------------------\n\nTITLE: Using waitForInitialLayout Prop in Legend List (TypeScript)\nDESCRIPTION: The waitForInitialLayout prop solves layout jumps by delaying the display of list items by one frame, ensuring they start at the correct position. This is useful when actual item sizes differ significantly from estimated sizes.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/api/performance.mdx#2025-04-11_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nwaitForInitialLayout?: boolean\n```\n\n----------------------------------------\n\nTITLE: Implementing Update Operations with syncedCrud in TypeScript\nDESCRIPTION: Example showing how to implement the update function in syncedCrud with partial updates and error handling. Includes configuration for updated_at field tracking.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/crud.mdx#2025-04-11_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst profile$ = observable(syncedCrud({\n    // ...\n    update: (value, options) => {\n        const { data, error } = await serverUpdateProfile(value);\n        if (error) {\n            // Handle error, throw an Error to trigger a retry\n        } else if (data) {\n            return data;\n        }\n    },\n    fieldCreatedAt: 'updated_at',\n    updatePartial: true // Update with only changed fields\n}))\n```\n\n----------------------------------------\n\nTITLE: Configuring Local Storage Persistence in Legend-State\nDESCRIPTION: Example of configuring Observable persistence to use Local Storage, which is no longer the default persistence mechanism starting from version 0.22.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/other/migrating.mdx#2025-04-11_snippet_24\n\nLANGUAGE: javascript\nCODE:\n```\nimport { configureObservablePersistence } from \"@legendapp/state/persist\";\nimport { ObservablePersistLocalStorage } from \"@legendapp/state/local-storage\";\n\nconfigureObservablePersistence({\n  persistLocal: ObservablePersistLocalStorage,\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Infinite Scroll Callbacks in TypeScript\nDESCRIPTION: This code snippet defines two optional callback functions for infinite scrolling. onStartReached is triggered when scrolling to the top, while onEndReached is triggered when scrolling to the bottom. These callbacks receive an object with distance information.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/examples/infiniteScrolling.mdx#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nonStartReached?: ((info: { distanceFromStart: number }) => void) | null | undefined;\nonEndReached?: ((info: { distanceFromEnd: number }) => void) | null | undefined;\n```\n\n----------------------------------------\n\nTITLE: Available Props for Chat Interfaces in TypeScript\nDESCRIPTION: TypeScript definition of key props for creating chat interfaces in Legend List. These props enable aligning items at the bottom of the screen and maintaining scroll position when new messages are added.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/examples/chatInterfaces.mdx#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nalignItemsAtEnd?: boolean;\nmaintainScrollAtEnd?: boolean;\nmaintainScrollAtEndThreshold?: number;\n```\n\n----------------------------------------\n\nTITLE: Implementing Create Operations with syncedCrud in TypeScript\nDESCRIPTION: Example showing how to implement the create function in syncedCrud with error handling and server response handling. Includes configuration for created_at field tracking.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/crud.mdx#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst profile$ = observable(syncedCrud({\n    // ...\n    create: (value, options) => {\n        const { data, error } = await serverCreateProfile(value);\n        if (error) {\n            // Handle error, throw an Error to trigger a retry\n        } else if (data) {\n            return data;\n        }\n    },\n    fieldCreatedAt: 'created_at'\n}))\n```\n\n----------------------------------------\n\nTITLE: Enabling React Tracking Warnings in JavaScript\nDESCRIPTION: This snippet demonstrates how to enable warnings for missing use$ in React components when using get() on observables. It helps identify potential reactivity issues.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/usage/configuring.mdx#2025-04-11_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { enableReactTracking } from \"@legendapp/state/config/enableReactTracking\"\nenableReactTracking({\n    warnMissingUse: true,\n})\n```\n\n----------------------------------------\n\nTITLE: Using observe with reaction parameter\nDESCRIPTION: Examples of using observe with a reaction parameter, which runs after the selector and does not track changes. This is useful for observing specific events or observables.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/usage/reactivity.mdx#2025-04-11_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\n// Observe the return value of a selector and observe all accessed observables\nobserve(state$.isOnline, (e) => {\n  console.log(\"Online status\", e.value);\n});\n// Observe the return value of a selector and observe all accessed observables\nobserve(\n  () => state$.isOnline.get() && state$.user.get(),\n  (e) => {\n    console.log(\"Signed in status\", e.value);\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: Installing TypeScript Type Definitions for React and React Native\nDESCRIPTION: This code snippet shows how to install TypeScript type definitions for React and React Native, which are necessary for proper type support in Legend-Motion.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/motion/src/content/docs/3-resources/2-typescript.mdx#2025-04-11_snippet_0\n\nLANGUAGE: JSX\nCODE:\n```\n<Install name=\"@types/react @types/react-native\" />\n```\n\n----------------------------------------\n\nTITLE: Configuring Supabase Table with Timestamps and Soft Delete\nDESCRIPTION: SQL script for adding timestamp columns and triggers for handling created_at and updated_at fields, plus soft delete functionality.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/supabase.mdx#2025-04-11_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\n-- Add new columns to table named `created_at` and `updated_at`\nALTER TABLE YOUR_TABLE_NAME\nADD COLUMN created_at timestamptz default now(),\nADD COLUMN updated_at timestamptz default now(),\n-- Add column for soft deletes, remove this if you don't need that\nADD COLUMN deleted boolean default false;\n\n-- This will set the `created_at` column on create and `updated_at` column on every update\nCREATE OR REPLACE FUNCTION handle_times()\n    RETURNS trigger AS\n    $$\n    BEGIN\n    IF (TG_OP = 'INSERT') THEN\n        NEW.created_at := now();\n        NEW.updated_at := now();\n    ELSEIF (TG_OP = 'UPDATE') THEN\n        NEW.created_at = OLD.created_at;\n        NEW.updated_at = now();\n    END IF;\n    RETURN NEW;\n    END;\n    $$ language plpgsql;\n\nCREATE TRIGGER handle_times\n    BEFORE INSERT OR UPDATE ON YOUR_TABLE_NAME\n    FOR EACH ROW\nEXECUTE PROCEDURE handle_times();\n```\n\n----------------------------------------\n\nTITLE: Updating Import Paths for React Utilities\nDESCRIPTION: Shows the correct import path for observer, reactive, and reactiveObserver, which should now come from /react instead of /react-components.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/other/migrating.mdx#2025-04-11_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n// Change this:\nimport {\n  observer,\n  reactive,\n  reactiveObserver,\n} from \"@legendapp/state/react-components\";\n// To this:\nimport { observer, reactive, reactiveObserver } from \"@legendapp/state/react\";\n```\n\n----------------------------------------\n\nTITLE: Configuring AsyncStorage Persistence in React Native\nDESCRIPTION: Configuration for using AsyncStorage as the persistence layer in a React Native application with Legend-State. This requires passing the AsyncStorage implementation to the plugin configuration.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/guides/persistence.mdx#2025-04-11_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { configureObservablePersistence } from '@legendapp/state/persist'\nimport { ObservablePersistAsyncStorage } from '@legendapp/state/persist-plugins/async-storage'\n\n// Global configuration\nconfigureObservablePersistence({\n    // Use AsyncStorage in React Native\n    pluginLocal: ObservablePersistAsyncStorage,\n    localOptions: {\n        asyncStorage: {\n            // The AsyncStorage plugin needs to be given the implementation of AsyncStorage\n            AsyncStorage\n        }\n    }\n})\n```\n\n----------------------------------------\n\nTITLE: Setting Up Basic Keel Integration with Legend-State\nDESCRIPTION: Shows how to create a basic observable synced with Keel by passing functions from the generated keelClient to syncedKeel.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/keel.mdx#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { observable } from '@legendapp/state'\nimport { syncedKeel } from '@legendapp/state/sync-plugins/keel'\nconst { mutations, queries } = client.api\n\nconst profile$ = observable(syncedKeel({\n    get: queries.getProfile,\n    create: mutations.createProfile,\n    update: mutations.updateProfile,\n    delete: mutations.deleteProfile,\n}))\n```\n\n----------------------------------------\n\nTITLE: Initializing Full Supabase Integration with Legend-State\nDESCRIPTION: Complete example showing Supabase client setup with Legend-State including message management, realtime sync, and persistence configuration.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/supabase.mdx#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createClient } from '@supabase/supabase-js'\nimport { Database } from './database.types'\nimport { observable } from '@legendapp/state'\nimport { configureSyncedSupabase, syncedSupabase } from '@legendapp/state/sync-plugins/supabase'\nimport { v4 as uuidv4 } from \"uuid\"\n\nconst supabase = createClient<Database>(process.env.SUPABASE_URL, process.env.SUPABASE_ANON_KEY)\n\n// provide a function to generate ids locally\nconst generateId = () => uuidv4()\nconfigureSyncedSupabase({\n    generateId\n})\nconst uid = ''\n\nconst messages$ = observable(syncedSupabase({\n    supabase,\n    collection: 'messages',\n    // Optional:\n    // Select only id and text fields\n    select: (from) => from.select('id,text'),\n    // Filter by the current user\n    filter: (select) => select.eq('user_id', uid),\n    // Don't allow delete\n    actions: ['read', 'create', 'update'],\n    // Realtime filter by user_id\n    realtime: { filter: `user_id=eq.${uid}` },\n    // Persist data and pending changes locally\n    persist: { name: 'messages', retrySync: true },\n    // Sync only diffs\n    changesSince: 'last-sync'\n}))\n\n// get() activates and starts syncing\nconst messages = messages$.get()\n\nfunction addMessage(text: string) {\n    const id = generateId()\n    // Add keyed by id to the messages$ observable to trigger a create in Supabase\n    messages$[id].set({\n        id,\n        text,\n        created_at: null,\n        updated_at: null\n    })\n}\n\nfunction updateMessage(id: string, text: string) {\n    // Just set values in the observable to trigger an update to Supabase\n    messages$[id].text.set(text)\n}\n```\n\n----------------------------------------\n\nTITLE: Using useUnmountOnce hook for guaranteed single execution on unmount\nDESCRIPTION: The useUnmountOnce hook combines useEffect with a workaround for development mode, ensuring the unmount callback only runs once regardless of React's double-rendering behavior in development.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/react/react-API.mdx#2025-04-11_snippet_12\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useUnmountOnce } from \"@legendapp/state/react\";\n\nconst Component = () => {\n  useUnmountOnce(() => console.log(\"mounted\"));\n};\n```\n\n----------------------------------------\n\nTITLE: Customizing Keel Actions with Legend-State\nDESCRIPTION: Shows how to customize Keel actions by providing custom functions that call the Keel actions with additional parameters, useful for implementing lookup tables or adding query options.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/keel.mdx#2025-04-11_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { mutations, queries, CreateProfileInput } from './keelClient'\n\nconst profiles$ = observable({\n    user: (userId: string) =>\n        syncedKeel({\n            get: () => queries.getProfile({ userId }),\n            create: (data: CreateProfileInput) =>\n                mutations.createProfile({ user: { id: staffId }, ...data }),\n            update: mutations.updateProfile,\n            delete: mutations.deleteProfile,\n        })\n})\n```\n\n----------------------------------------\n\nTITLE: Babel Plugin Transformation for Legend State Components\nDESCRIPTION: Shows how the Babel plugin transforms JSX for Computed, Memo, and Show components to make the syntax less verbose.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/react/fine-grained-reactivity.mdx#2025-04-11_snippet_8\n\nLANGUAGE: jsx\nCODE:\n```\n// You write\n<Computed><div>Count: {state$.count.get()}</div></Computed>\n<Memo><div>Count: {state$.count.get()}</div></Memo>\n<Show if={state$.visible}><Modal /></Show>\n\n// Babel transforms it to\n<Computed>{() => <div>Count: {state.count.get()}</div>}</Computed>\n<Memo>{() => <div>Count: {state$.count.get()}</div>}</Memo>\n<Show if={state$.visible}>{() => <Modal />}</Show>\n```\n\n----------------------------------------\n\nTITLE: Advanced useMeasure Hook with Animation\nDESCRIPTION: Shows advanced usage of useMeasure hook with Framer Motion for animated bottom sheet.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/react/helpers-and-hooks.mdx#2025-04-11_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\nimport { reactive } from \"@legendapp/state/react\";\nimport { useMeasure } from \"@legendapp/state/react-hooks/useMeasure\";\nimport { motion } from \"framer-motion\";\nimport { useRef } from \"react\";\n\nconst MotionDiv$ = reactive(motion.div);\n\nfunction BottomSheet({ children }) {\n  const refInner = useRef();\n  const { width, height } = useMeasure(refInner);\n\n  return (\n    <MotionDiv$\n      style={{ position: \"fixed\", bottom: 0, left: 0, right: 0 }}\n      $animate={() => ({ y: -height.get() })}\n    >\n      <div ref={refInner}>{children}</div>\n    </MotionDiv$>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using Get Action in Keel with Legend-State\nDESCRIPTION: Demonstrates how to use the 'get' action with the Keel plugin in Legend-State, showing how creating, updating, and deleting work with get actions.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/keel.mdx#2025-04-11_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst { mutations, queries } = client.api\n\nconst profile$ = observable(syncedKeel({\n    get: queries.getProfile,\n    create: mutations.createProfile,\n    update: mutations.updateProfile,\n    delete: mutations.deleteProfile,\n}))\n// profile$.get() is a Profile\n```\n\n----------------------------------------\n\nTITLE: Using currentTime Observable in Legend-State\nDESCRIPTION: Shows usage of currentTime observable that automatically updates every minute to track the current time.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/react/helpers-and-hooks.mdx#2025-04-11_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { currentTime } from \"@legendapp/state/helpers/time\"\n\nobserve(() => {\n    console.log('The time is is': currentTime.get())\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Remote Persistence with Transformation in Legend-State\nDESCRIPTION: Example of remote persistence configuration with data transformation for encryption/decryption and error handling. This demonstrates how to use the transformation capabilities and event handlers for remote persistence.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/guides/persistence.mdx#2025-04-11_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nconst { state } = persistObservable(settings, {\n    pluginRemote: ...,\n    remote: {\n        transform: {\n            in: (value) => decrypt(value),\n            out: (value) => encrypt(value),\n        },\n        onSaveError: (err) => console.log(err),\n    }\n})\nwhen(state.isLoaded, () => console.log('Loaded from remote'))\n```\n\n----------------------------------------\n\nTITLE: Disposing of onChange listeners\nDESCRIPTION: Example showing how to dispose of listeners to stop tracking observable changes. Calling the returned dispose function cancels the listener.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/usage/reactivity.mdx#2025-04-11_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\nconst state$ = observable({ text: 'hello' })\n\nconst onChange = () => { ... }\n\nconst dispose = state$.text.onChange(onChange)\n\n// Cancel listening manually\ndispose()\n```\n\n----------------------------------------\n\nTITLE: Using Where Parameter with List Actions in Keel\nDESCRIPTION: Demonstrates how to use the 'where' parameter with list actions to filter query results, particularly useful when implementing lookup tables.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/keel.mdx#2025-04-11_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst { mutations, queries } = client.api\n\nconst messages$ = observable({\n    room: (roomId: string) =>\n        syncedKeel({\n            list: queries.listMessages,\n            where: { roomId }\n        })\n})\n// profile$.get() is a Record<string, Profile>\n```\n\n----------------------------------------\n\nTITLE: Optimized Number Validation Check in Legend-State\nDESCRIPTION: A code snippet showing how Legend-State optimizes number validation by using the expression '+n - +n < 1' instead of the slower isNaN() function. This micro-optimization improves performance when validating if a string is a number.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/intro/fast.mdx#2025-04-11_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n+n - +n < 1\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Remote Persistence Plugin in Legend-State\nDESCRIPTION: Example of implementing a custom remote persistence plugin with get and set functions. This demonstrates how to create a plugin that fetches data from a remote endpoint and includes polling functionality.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/guides/persistence.mdx#2025-04-11_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nimport { persistObservable } from \"@legendapp/state/persist\"\n\nconst obs$ = persistObservable(\n  { initialValue: \"hello\" },\n  {\n    pluginRemote: {\n      get: ({ onChange }) => {\n        const getFn = () =>\n          fetch(\"https://url.to.get\").then((res) => res.json())\n\n        // Set a timer to poll every 10 seconds\n        setInterval(async () => {\n          const value = getFn()\n          onChange({ value })\n        }, 10000)\n\n        // Return the initial value\n        return getFn()\n      },\n      set: async ({ value, changes }) => {\n        await fetch(\"https://url.to.set\", {\n          method: \"POST\",\n          body: JSON.stringify(value),\n        })\n      },\n    },\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Using Legend-State with React Context for local state sharing\nDESCRIPTION: Legend-State observables can be passed through React Context. Since the observable is a stable object, changing its values won't cause context consumers to re-render unless they're explicitly tracking those values.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/react/react-API.mdx#2025-04-11_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\nimport { createContext, useContext } from \"react\";\nimport { observer, useObservable } from \"@legendapp/state/react\";\n\nconst StateContext = createContext();\n\nfunction App() {\n  const state$ = useObservable({\n    profile: {\n      name: \"\",\n    },\n  });\n\n  return (\n    <StateContext.Provider value={state$}>\n      <div>\n        <Sidebar />\n        <Main />\n      </div>\n    </StateContext.Provider>\n  );\n}\n\nconst Sidebar = function Sidebar() {\n  // StateContext will never change so this will never cause a render\n  const state$ = useContext(StateContext);\n\n  // This component never re-renders, but name re-renders itself\n  return (\n    <div>\n      Name: <Memo>{state$.profile.name}</Memo>\n    </div>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Advanced useMeasure Hook with Animation Example\nDESCRIPTION: Advanced example showing useMeasure hook with Framer Motion for animated bottom sheet.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/react/helpers-and-hooks.mdx#2025-04-11_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\nimport { reactive } from \"@legendapp/state/react\";\nimport { useMeasure } from \"@legendapp/state/react-hooks/useMeasure\";\nimport { motion } from \"framer-motion\";\nimport { useRef } from \"react\";\n\nconst MotionDiv$ = reactive(motion.div);\n\nfunction BottomSheet({ children }) {\n  const refInner = useRef();\n  const { width, height } = useMeasure(refInner);\n\n  return (\n    <MotionDiv$\n      style={{ position: \"fixed\", bottom: 0, left: 0, right: 0 }}\n      $animate={() => ({ y: -height.get() })}\n    >\n      <div ref={refInner}>{children}</div>\n    </MotionDiv$>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Setting up Typed Supabase Client\nDESCRIPTION: Basic setup for creating a typed Supabase client using generated database types.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/supabase.mdx#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createClient } from '@supabase/supabase-js'\nimport { Database } from './database.types'\n\nconst supabase = createClient<Database>(process.env.SUPABASE_URL, process.env.SUPABASE_ANON_KEY)\n```\n\n----------------------------------------\n\nTITLE: Creating Two-Way Linked Observables\nDESCRIPTION: Shows how to create linked observables that bind to both get and set functions, enabling two-way binding between observables. Example demonstrates a \"Select All\" checkbox implementation.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/usage/observable.mdx#2025-04-11_snippet_17\n\nLANGUAGE: javascript\nCODE:\n```\nimport { linked, observable } from \"@legendapp/state\"\n\nconst selected$ = observable([false, false, false])\nconst selectedAll$ = observable(linked({\n  // selectedAll is true when every element is selected\n  get: () => selected$.every((val$) => val$.get()),\n\n  // setting selectedAll sets the value of every element\n  set: (value) => selected$.forEach((val$) => val$.set(value))\n}))\n\nselectedAll$.set(true)\n// selected.get() === [true, true, true]\n```\n\n----------------------------------------\n\nTITLE: Using React Use Example (Deprecated)\nDESCRIPTION: Example showing how to use the deprecated use() method in components.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/usage/configuring.mdx#2025-04-11_snippet_9\n\nLANGUAGE: jsx\nCODE:\n```\nimport { observable } from \"@legendapp/state\"\nconst state$ = observable({ test: \"hi\" })\n\nfunction Component() {\n  // This makes this component responsive to test changing\n  const test = state$.test.use()\n\n  return <div>{test}</div>\n}\n```\n\n----------------------------------------\n\nTITLE: Syncing with a Remote Server using syncedFetch\nDESCRIPTION: Example demonstrating how to sync data with a remote server using the syncedFetch plugin. Shows both fetching data from the server and sending changes back to the server automatically when the observable changes.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/persist-sync.mdx#2025-04-11_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { observable, observe } from \"@legendapp/state\"\nimport { syncedFetch } from \"@legendapp/state/sync-plugins/fetch\"\n\n// Create an observable with \"users\" synced\nconst store$ = observable({\n    users: syncedFetch({\n        initial: [],\n        // When the fetch resolves it will update the observable\n        get: 'https://reqres.in/api/users',\n        // When the observable is changed it will send the changes back to the server.\n        set: 'https://reqres.in/api/users'\n    })\n})\n\nobserve(() => {\n    // The first get() activates the synced get function to fetch the data\n    // observe is re-run when the data comes in\n    const users = store$.users.get()\n    if (users) {\n        processUsers(users)\n    }\n})\n\n// Any changes will be saved\nstore$.users.push({ id: 0, name: 'name' })\n```\n\n----------------------------------------\n\nTITLE: Creating Computed Observables\nDESCRIPTION: Shows two ways to create computed observables: as functions within objects and as standalone observables. Computed functions are lazy and only evaluate when accessed.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/usage/observable.mdx#2025-04-11_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\nconst state$ = observable({\n    fname: 'Annyong',\n    lname: 'Bluth',\n    // A child is computed\n    fullName: () => state$.fname.get() + ' ' + state$.lname.get()\n})\n// An observable with a function is a computed\nconst name$ = observable(() => state$.fname.get() + ' ' + state$.lname.get())\n```\n\n----------------------------------------\n\nTITLE: Implementing TanStack Query with React Hook\nDESCRIPTION: Demonstrates how to use the useObservableSyncedQuery hook within a React component. This approach integrates with React's context system and allows direct binding to UI elements.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/tanstack-query.mdx#2025-04-11_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useObservableSyncedQuery } from '@legendapp/state/sync-plugins/tanstack-react-query';\nimport { useQueryClient } from '@tanstack/react-query';\nimport { use$ } from '@legendapp/state/react';\n\nfunction Component() {\n    const state$ = useObservableSyncedQuery({\n        query: {\n            queryKey: ['user'],\n            queryFn: async () => {\n                return fetch('https://reqres.in/api/users/1').then((v) => v.json())\n            },\n        },\n        mutation: {\n            mutationFn: async (variables) => {\n                return fetch(\n                    'https://reqres.in/api/users/1',\n                    { body: JSON.stringify(variables), method: 'POST' }\n                )\n            },\n        },\n    })\n\n    // get it with use$ to start the sync\n    const state = use$(state$)\n\n    // Or bind an input directly to a property, which will also start the sync\n    return (\n        <div>\n            <$React.input $value={state$.first_name} />\n        </div>\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Using when() with Async Observables\nDESCRIPTION: Shows how to pair asynchronous observables with the when() function to await Promise resolution and get the data in a convenient way.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/usage/observable.mdx#2025-04-11_snippet_15\n\nLANGUAGE: javascript\nCODE:\n```\n// Await the promise to resolve and then get the data from it\nconst data = await when(serverState$)\nconsole.log(data)\n```\n\n----------------------------------------\n\nTITLE: Using Optimized For Component in React\nDESCRIPTION: Demonstrates the use of the optimized prop in the For component for even further rendering optimizations. This approach updates React elements in place, reducing rendering time for operations like swapping or sorting array elements.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/guides/performance.mdx#2025-04-11_snippet_6\n\nLANGUAGE: jsx\nCODE:\n```\nimport { For } from \"@legendapp/state/react\"\n\n...\n\nfunction List() {\n    // Use the optimized prop\n    return <For each={list} item={Row} optimized />\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Shallow Listeners with get()\nDESCRIPTION: Shows how to create a shallow listener using the get() method with a parameter to track only when keys are added or removed, rather than tracking all value changes.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/usage/observable.mdx#2025-04-11_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nstate$.get(true) // Create a shallow listener\n```\n\n----------------------------------------\n\nTITLE: Advanced onChange with tracking options\nDESCRIPTION: Full example of using onChange with additional options for advanced use cases, including previous value tracking, change details, and immediate execution.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/usage/reactivity.mdx#2025-04-11_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\n// Full example\nstate$.onChange(\n  ({ value, getPrevious, changes }) => {\n    const prev = getPrevious();\n    changes.forEach(({ path, valueAtPath, prevAtPath }) => {\n      console.log(valueAtPath, \"changed at\", path, \"from\", prevAtPath);\n    });\n  },\n  { initial: true, trackingType: true }\n);\n```\n\n----------------------------------------\n\nTITLE: Creating Multiple Reactive Components with reactiveComponents\nDESCRIPTION: Shows how to use reactiveComponents to create multiple reactive components at once, useful for wrapping UI libraries with nested components.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/react/fine-grained-reactivity.mdx#2025-04-11_snippet_14\n\nLANGUAGE: js\nCODE:\n```\nimport { reactiveComponents } from \"@legendapp/state/react\";\nimport { motion } from \"framer-motion\";\n\nconst $Motion = reactiveComponents(motion);\n\nfunction Component() {\n  // This component renders only once\n  const width$ = useObservable(100);\n\n  return (\n    <$Motion.div\n      $animate={() => ({\n        x: width$.get(),\n      })}\n    >\n      ...\n    </$Motion.div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Updating onChange Usage in Legend-State\nDESCRIPTION: This code illustrates how to update the usage of onChange in Legend-State, which now takes an object parameter for the callback and an options object for configuration.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/other/migrating.mdx#2025-04-11_snippet_22\n\nLANGUAGE: javascript\nCODE:\n```\n// Old\nobs.onChange((value, getPrevious, changes) => {\n  // ...\n}, true);\n\n// New\nobs.onChange(\n  ({ value, getPrevious, changes }) => {\n    // ...\n  },\n  { trackingType: true }\n);\n```\n\n----------------------------------------\n\nTITLE: Updating Import Paths for Legend-State React Helpers\nDESCRIPTION: This snippet illustrates how to update import paths for observer, reactive, and reactiveObserver from react-components to the main react export in Legend-State.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/other/migrating.mdx#2025-04-11_snippet_19\n\nLANGUAGE: javascript\nCODE:\n```\n// Change this:\nimport {\n  observer,\n  reactive,\n  reactiveObserver,\n} from \"@legendapp/state/react-components\";\n// To this:\nimport { observer, reactive, reactiveObserver } from \"@legendapp/state/react\";\n```\n\n----------------------------------------\n\nTITLE: Batching to Prevent Excessive Renders\nDESCRIPTION: Shows how batching can be used to prevent multiple re-renders when making many changes to an observable, especially useful for large arrays or complex state changes.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/guides/performance.mdx#2025-04-11_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst state$ = observable({ items: [] });\n\nfunction addItems() {\n  for (let i = 0; i < 1000; i++) {\n    state$.items.push({ text: `Item ${i}` });\n  }\n}\n\n//  This can render 1000 times while pushing to the array\naddItems();\n\n//  Batching delays until complete and renders once\nbatch(addItems);\n```\n\n----------------------------------------\n\nTITLE: Setting Initial Values for Async Linked Observables\nDESCRIPTION: Shows how to set an initial default value for asynchronous linked observables until the Promise resolves, using the initial property to provide a placeholder value.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/usage/observable.mdx#2025-04-11_snippet_19\n\nLANGUAGE: javascript\nCODE:\n```\nimport { linked } from \"@legendapp/state\"\n\nconst state$ = observable(linked({\n    get: () => fetch('url').then(res => res.json()),\n    initial: { numUsers: 0, messages: [] }\n}))\n```\n\n----------------------------------------\n\nTITLE: Handling Asynchronous Loading with AsyncStorage in Legend State\nDESCRIPTION: Shows how to handle the asynchronous nature of AsyncStorage by waiting for persistence to load before proceeding with application logic using the syncState and when utilities.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/persist-sync.mdx#2025-04-11_snippet_21\n\nLANGUAGE: javascript\nCODE:\n```\nconst syncState$ = syncState(state$)\nawait when(syncState$.isPersistLoaded)\n// Continue with load\n```\n\n----------------------------------------\n\nTITLE: Observing Examples in Legend-State\nDESCRIPTION: Comprehensive examples of different ways to track observable changes, showing which operations do and don't trigger reactivity updates. The examples demonstrate various methods of accessing and tracking observable data.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/usage/reactivity.mdx#2025-04-11_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst state$ = observable({\n  settings: {\n    theme: \"dark\",\n  },\n  chats: {\n    messages: [{ id: 0, text: \"hi\" }],\n  },\n});\n\nobserve(() => {\n  const theme = state$.settings.theme.get();\n  //  Tracking [state$.settings.theme] because of get()\n\n  const theme = state$.settings.theme.peek();\n  //  Not tracking because of peek()\n\n  const theme = state$.settings.get(true);\n  //  Tracking [state$.settings (shallow)] because of get(true)\n\n  const settings$ = state$.settings;\n  //  Not tracking, just a reference to an observable\n\n  state$.chats.messages.map((m) => <Message key={m.peek().id} message={m} />);\n  //  Tracking [state$.chats.messages (shallow)] because of map()\n\n  const keys = Object.keys(state$.settings);\n  //  Tracking [state$.settings (shallow)] because of Object.keys\n});\n```\n\n----------------------------------------\n\nTITLE: Working with Selectors in Legend-State\nDESCRIPTION: Explains how to use selectors as either direct observables or functions that track observable changes, demonstrated with the when function.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/intro/getting-started.mdx#2025-04-11_snippet_3\n\nLANGUAGE: js\nCODE:\n```\nconst isSignedIn$ = observable(false);\nconst isOnline$ = observable(false);\n\n// A selector can be just an observable, which will be tracked for changes\nawait when(isSignedIn$);\n\n// Or selector can be a function which tracks all get() callschanges\nawait when(() => isSignedIn$.get() && isOnline$.get());\n```\n\n----------------------------------------\n\nTITLE: Enabling Peek Assignment in JavaScript\nDESCRIPTION: This snippet shows how to enable and use the _PeekAssign feature, which allows accessing and modifying observable values without tracking or notifying listeners.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/usage/configuring.mdx#2025-04-11_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { enable_PeekAssign } from \"@legendapp/state/config/enable_PeekAssign\";\nenable_PeekAssign();\n```\n\nLANGUAGE: javascript\nCODE:\n```\nimport { observable } from \"@legendapp/state\"\n\nconst state$ = observable({ test: \"hi\", num: 0 })\n\n// _ is a shorthand for peek()\nconst testValue = state$.test._\n\n// Assign to _ to modify the underlying object without notifying listeners\nstate$.test._ = \"hello\"\n\n// Assign objects too\nstate$._ = { test: \"hello\" }\n```\n\n----------------------------------------\n\nTITLE: Configuring Expo SQLite Persistence for React Native with Legend State\nDESCRIPTION: Instructions for setting up Expo SQLite persistence plugin for React Native applications using Legend State, which provides a SQL-based storage solution.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/persist-sync.mdx#2025-04-11_snippet_22\n\nLANGUAGE: javascript\nCODE:\n```\nimport { configureSynced, syncObservable } from '@legendapp/state/sync';\nimport { observablePersistSqlite } from '@legendapp/state/persist-plugins/expo-sqlite';\nimport Storage from 'expo-sqlite/kv-store';\n\n// Global configuration\nconst persistOptions = configureSynced({\n    persist: {\n        plugin: observablePersistSqlite(Storage)\n    },\n});\nsyncObservable(\n    state$,\n    persistOptions({\n        persist: {\n            name: 'store',\n        },\n    }),\n);\n```\n\n----------------------------------------\n\nTITLE: Using Lookup Tables with Observables (TypeScript)\nDESCRIPTION: Demonstrates how to use a function with a single string key as a lookup table in observables. This allows for dynamic property access and linking.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/usage/observable.mdx#2025-04-11_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nconst state$ = observable({\n    selector: 'text',\n    items: {\n        test1: { text: 'hi', othertext: 'bye' },\n        test2: { text: 'hello', othertext: 'goodbye' }\n    },\n    // Return a link to the [selector] property in the given item\n    texts: (key: string) => {\n        return state$.items[key][state$.selector.get()]\n    },\n})\n\n// Now these reference the same thing:\nstate$.items.test1.text.get()\nstate$.texts['test1'].get()\n\n// And setting a text goes through to the linked observable\nstate$.texts.test1.set('hello')\nstate$.items.test1.text.get() // 'hello'\n```\n\n----------------------------------------\n\nTITLE: Different Ways to Access Computed Functions\nDESCRIPTION: Demonstrates two ways to access computed functions: calling them directly as functions to get the current value, or using get() to activate them as reactive computed observables.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/usage/observable.mdx#2025-04-11_snippet_12\n\nLANGUAGE: javascript\nCODE:\n```\n// Calling it like a function returns the value and computes when called.\nconst fullName = state$.fullName()\n\n// Calling .get() activates it as a computed observable that recomputes itself on changes\nconst reactiveFullName = state$.fullName.get()\n```\n\n----------------------------------------\n\nTITLE: Waiting for IndexedDB Loading with Legend-State\nDESCRIPTION: Example of how to wait for asynchronous IndexedDB loading to complete before using the persisted observable in an application. This uses the returned status object to track loading state.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/guides/persistence.mdx#2025-04-11_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nconst status = persistObservable(state$, {\n    local: 'store' // IndexedDB table name\n})\nawait when(status.isLoadedLocal)\n...\n```\n\n----------------------------------------\n\nTITLE: Configuring MMKV Persistence in React Native\nDESCRIPTION: Configuration for using MMKV as the persistence layer in a React Native application with Legend-State. This sets up the global configuration for the ObservablePersistMMKV plugin.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/guides/persistence.mdx#2025-04-11_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { configureObservablePersistence } from '@legendapp/state/persist'\nimport { ObservablePersistMMKV } from '@legendapp/state/persist-plugins/mmkv'\n\n// Global configuration\nconfigureObservablePersistence({\n    // Use react-native-mmkv in React Native\n    pluginLocal: ObservablePersistMMKV\n})\n```\n\n----------------------------------------\n\nTITLE: Enabling React/React Native Components\nDESCRIPTION: Configuration for enabling reactive platform components in either React or React Native.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/usage/configuring.mdx#2025-04-11_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n// React\nimport { enableReactComponents } from \"@legendapp/state/config/enableReactComponents\"\nenableReactComponents()\n\n// React Native\nimport { enableReactNativeComponents } from \"@legendapp/state/config/enableReactNativeComponents\"\nenableReactNativeComponents()\n```\n\n----------------------------------------\n\nTITLE: Importing React Components\nDESCRIPTION: Import statements for various React components used throughout the examples, including persistence, forms, animations, and routing components.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/react/react-examples.mdx#2025-04-11_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport Persistence from \"../../../Components/React/Persistence.astro\";\nimport AutoSavingFormExample from \"../../../Components/React/AutoSavingFormExample.astro\";\nimport FormValidationExample from \"../../../Components/React/FormValidationExample.astro\";\nimport MessageListExample from \"../../../Components/React/MessageListExample.astro\";\nimport AnimatedSwitchExample from \"../../../Components/React/AnimatedSwitchExample.astro\";\nimport ModalExample from \"../../../Components/React/ModalExample.astro\";\nimport RouterExample from \"../../../Components/React/RouterExample.astro\";\n```\n\n----------------------------------------\n\nTITLE: Working with Observable Arrays\nDESCRIPTION: This snippet explains how observable arrays provide modified versions of standard array methods, with automatic shallow tracking and observable handling for array iteration methods.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/usage/observable.mdx#2025-04-11_snippet_14\n\n\n\n----------------------------------------\n\nTITLE: Basic Motion View Component with Animation Properties in React Native\nDESCRIPTION: Demonstrates a basic Motion.View component with various animation props including initial state, animate, hover and tap effects, and spring transition configuration.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/motion/src/content/docs/getting-started/introduction.mdx#2025-04-11_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\n<Motion.View\n  initial={{ y: -50 }}\n  animate={{ x: value * 100, y: 0 }}\n  whileHover={{ scale: 1.2 }}\n  whileTap={{ y: 20 }}\n  transition={{ type: \"spring\" }}\n/>\n```\n\n----------------------------------------\n\nTITLE: Using Direct Access Example\nDESCRIPTION: Example showing direct access patterns for getting and setting observable values.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/usage/configuring.mdx#2025-04-11_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport { observable } from \"@legendapp/state\"\n\nconst state$ = observable({ test: \"hi\", num: 0 })\n\n// $ is a shorthand for get()\nconst testValue = state$.test.$\n\n// Assign to $ as a shorthand for set()\nstate$.test.$ = \"hello\"\n\n// Assign objects too just like you can with set()\nstate$.$ = { test: \"hello\" }\n\n// Incrementing works as you'd expect\nstate$.num.$++\n```\n\n----------------------------------------\n\nTITLE: Switching from FlashList to LegendList in React Native\nDESCRIPTION: This code snippet demonstrates how to migrate from FlashList to LegendList. The key differences include renaming the component and adding the recycleItems prop to match FlashList's recycling behavior.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/api/gettingStarted.mdx#2025-04-11_snippet_0\n\nLANGUAGE: diff\nCODE:\n```\nreturn (\n-  <FlashList\n+  <LegendList\n      data={items}\n      renderItem={({ item }) => <Text>{item.title}</Text>}\n      estimatedItemSize={320}\n+      recycleItems\n  />\n)\n```\n\n----------------------------------------\n\nTITLE: Using useVerifyNotTracking() in React with Legend State\nDESCRIPTION: Demonstrates the usage of useVerifyNotTracking() to ensure components are not tracking observables unintentionally. This is useful for fine-grained reactivity and optimizing component rendering.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/react/tracing.mdx#2025-04-11_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useVerifyNotTracking } from \"@legendapp/state/trace\";\n\nconst Component = observer(function Component(props) {\n  // Call useVerifyNotTracking anywhere inside the component\n  useVerifyNotTracking();\n\n  // This will log an error because get() makes it track\n  return <div>{state.count.get()}</div>;\n});\nconst FineComponent = observer(function FineComponent(props) {\n  // Call useVerifyNotTracking anywhere inside the component\n  useVerifyNotTracking();\n\n  // This will not log because rendering the observable directly\n  // does not re-render this component\n  return <div>{state.count}</div>;\n});\n```\n\n----------------------------------------\n\nTITLE: Using useHover Hook with React Components\nDESCRIPTION: Example of using useHover hook to track element hover state and conditionally render tooltips.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/react/helpers-and-hooks.mdx#2025-04-11_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Show } from \"@legendapp/state/react\";\nimport { useHover } from \"@legendapp/state/react-hooks/useHover\";\nimport { useRef } from \"react\";\n\nfunction ButtonWithTooltip() {\n  const refButton = useRef();\n  const isHovered = useHover(refButton);\n\n  return (\n    <div>\n      <button ref={refButton}>Click me</button>\n      <Show if={isHovered}>\n        {() => <Tooltip text=\"Tooltip!\" target={refButton} />}\n      </Show>\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using useIsMounted Hook for Component Mount State\nDESCRIPTION: Demonstrates useIsMounted hook to track component mount state for safe async operations.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/react/helpers-and-hooks.mdx#2025-04-11_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useIsMounted } from \"@legendapp/state/react/useIsMounted\";\n\nfunction Component() {\n  const isMounted = useIsMounted();\n\n  const onClick = () => {\n    setTimeout(() => {\n      if (isMounted.get()) {\n        console.log(\"Debounced click\");\n      }\n    }, 100);\n  };\n\n  return <button onClick={onClick}>Click me</button>;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring IndexedDB Persistence in React\nDESCRIPTION: Configuration for using IndexedDB as the persistence layer in a React application with Legend-State. This sets up the global configuration for the ObservablePersistIndexedDB plugin.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/guides/persistence.mdx#2025-04-11_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { configureObservablePersistence } from '@legendapp/state/persist'\nimport { ObservablePersistIndexedDB } from '@legendapp/state/persist-plugins/indexeddb'\n\n// Global configuration\nconfigureObservablePersistence({\n    pluginLocal: ObservablePersistIndexedDB\n})\n```\n\n----------------------------------------\n\nTITLE: Enabling Direct Render (Deprecated)\nDESCRIPTION: Configuration and example of deprecated direct render functionality.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/usage/configuring.mdx#2025-04-11_snippet_10\n\nLANGUAGE: jsx\nCODE:\n```\nimport { observable } from '@legendapp/state';\nimport { enableReactDirectRender } from '@legendapp/state/config/enableReactDirectRender';\nenableReactDirectRender()\n\nconst state$ = observable({ test: 'hi' })\n\nfunction Component() {\n    // The observable can now be rendered directly to create a self-reactive elemtn\n    return <div>{state$.test}</div>\n}\n```\n\n----------------------------------------\n\nTITLE: Using keyExtractor Prop in Legend List (TypeScript)\nDESCRIPTION: The keyExtractor prop allows Legend List to save item layouts by key, enabling reuse of previous layout information when the data array changes. This significantly improves performance by only updating changed items rather than resetting all item sizes.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/api/performance.mdx#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nkeyExtractor?: (item: T, index: number) => string;\n```\n\n----------------------------------------\n\nTITLE: Transforming JSX with Legend State Babel Plugin\nDESCRIPTION: Demonstrates how the Legend State Babel plugin transforms JSX to make Computed, Memo, and Show components less verbose by converting inline elements to functions.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/react/fine-grained-reactivity.mdx#2025-04-11_snippet_8\n\nLANGUAGE: jsx\nCODE:\n```\n// You write\n<Computed><div>Count: {state$.count.get()}</div></Computed>\n<Memo><div>Count: {state$.count.get()}</div></Memo>\n<Show if={state$.visible}><Modal /></Show>\n\n// Babel transforms it to\n<Computed>{() => <div>Count: {state.count.get()}</div>}</Computed>\n<Memo>{() => <div>Count: {state$.count.get()}</div>}</Memo>\n<Show if={state$.visible}>{() => <Modal />}</Show>\n```\n\n----------------------------------------\n\nTITLE: Enabling React Use (Deprecated)\nDESCRIPTION: Example of deprecated React use() configuration and usage pattern.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/usage/configuring.mdx#2025-04-11_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nimport { enableReactUse } from \"@legendapp/state/config/enableReactUse\"\nenableReactUse()\n```\n\n----------------------------------------\n\nTITLE: Basic useMeasure Hook Implementation\nDESCRIPTION: Demonstrates basic usage of useMeasure hook to track element dimensions.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/react/helpers-and-hooks.mdx#2025-04-11_snippet_6\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useMeasure } from \"@legendapp/state/react-hooks/useMeasure\";\nimport { useRef } from \"react\";\n\nfunction Component() {\n  const ref = useRef();\n  const { width, height } = useMeasure(ref);\n\n  return (\n    <div ref={ref}>\n      Width: {width}, Height: {height}\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Controlling Observable Modifications with lockObservable in JavaScript\nDESCRIPTION: Demonstrates how to use lockObservable to ensure that observables are only modified within certain actions. This function is used internally by computed and allows for temporarily unlocking observables for modifications.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/usage/helper-functions.mdx#2025-04-11_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { lockObservable, observable } from '@legendapp/state'\n\nconst state$ = observable({ store: { ... } })\nlockObservable(state$, true)\n\nfunction safeAction() {\n    // Unlock it to modify it\n    lockObservable(state$, false)\n    // Modify it\n    state$.set({ store: { ... } })\n    // Lock it back\n    lockObservable(state$, true)\n}\n```\n\n----------------------------------------\n\nTITLE: Setting drawDistance Buffer for Rendering Performance\nDESCRIPTION: Defines the buffer size in pixels above and below the viewport that will be rendered in advance. This affects scrolling performance and memory usage.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/api/props.mdx#2025-04-11_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\ndrawDistance?: number;\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Sync Plugin for Legend State\nDESCRIPTION: Demonstrates how to create a custom synchronization plugin for Legend State that interacts with a REST API, including authentication handling, retry logic, and real-time subscription support.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/persist-sync.mdx#2025-04-11_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nimport { observable } from '@legendapp/state'\nimport { synced } from '@legendapp/state/sync'\n\nconst isAuthed$ = observable(false);\n\n// Create a custom synced that just needs a name in your API\nconst customSynced = ({ name }) => {\n    const basePath = 'https://url/api/v1/'\n    const doFetch = (path) => {\n        return fetch(basePath + path).then((res) => res.json())\n    }\n\n    return synced({\n        get: () => doFetch(`list-${name}s`),\n        set: ({ value }) => {\n            if (value === null || value === undefined) {\n                return doFetch('delete-' + name)\n            } else {\n                return doFetch('upsert-' + name)\n            }\n        },\n        retry: { infinite: true },\n        persist: {\n            name\n        },\n        waitFor: isAuthed$,\n        subscribe: ({ refresh }) => {\n            // Subscribe to realtime service\n        },\n    })\n}\n\nconst store$ = observable({\n    users: customSynced('user')\n})\n```\n\n----------------------------------------\n\nTITLE: Using pageHashParams Observable for URL Parameter Management\nDESCRIPTION: Shows usage of pageHashParams observable for managing URL hash parameters individually.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/react/helpers-and-hooks.mdx#2025-04-11_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nimport { pageHashParams, configurePageHash } from '@legendapp/state/helpers/pageHashParams'\n\nobserve(() => {\n    console.log('userid param changed to': pageHashParams.userid.get())\n})\n\npageHashParams.userid.set('newuser')\n// location.hash == \"#userid=newuser\"\n```\n\n----------------------------------------\n\nTITLE: Using Event Observables\nDESCRIPTION: This snippet shows how to create and use event observables, which act as observables without values. They are useful for simple events where only notification is needed, without passing data.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/usage/observable.mdx#2025-04-11_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\nimport { event } from \"@legendapp/state\"\n\nconst onClosed = event()\n\n// Simply pass a callback to the `on` function\nonClosed.on(() => { ... })\n\n// Or use it with 'onChange' like other observables\nonClosed.onChange(() => { ... })\n\n// Dispatch the event to call listeners\nonClosed.fire()\n```\n\n----------------------------------------\n\nTITLE: Implementing getEstimatedItemSize for Dynamic Sizing\nDESCRIPTION: Provides an estimated size for each item individually, which is used to estimate the list layout before items actually render. More precise than the global estimatedItemSize prop.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/api/props.mdx#2025-04-11_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\ngetEstimatedItemSize?: (index: number, item: ItemT) => number;\n```\n\n----------------------------------------\n\nTITLE: Creating Reactive Framer Motion Components with Legend State\nDESCRIPTION: Shows how to wrap Framer Motion components to make them reactive, allowing updates to animations based on observables without re-rendering.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/react/fine-grained-reactivity.mdx#2025-04-11_snippet_12\n\nLANGUAGE: js\nCODE:\n```\nimport { reactive } from \"@legendapp/state/react\";\nimport { motion } from \"framer-motion\";\n\nconst $MotionDiv = reactive(motion.div);\n\nfunction Component() {\n  // This component renders only once\n  const width$ = useObservable(100);\n\n  return (\n    <$MotionDiv\n      $animate={() => ({\n        x: width$.get(),\n      })}\n    >\n      ...\n    </$MotionDiv>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Observable Safety Features\nDESCRIPTION: This snippet explains the safety features of observables that prevent accidental direct assignment, which could overwrite state or introduce large objects unintentionally. It shows correct ways to modify observable state.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/usage/observable.mdx#2025-04-11_snippet_12\n\nLANGUAGE: javascript\nCODE:\n```\nconst state$ = observable({ text: \"hello\", num: 10, obj: {} }, /*safe*/ true);\n\nstate$.text = \"hi\";\n//  Can't set directly\n\nstate$.text.set(\"hi\");\n//  Calling set on a primitive works.\n\nstate$ = {};\n//  Error. This would delete the observable.\n\nstate$.obj = {};\n//  Error. Cannot assign to objects directly.\n\nstate$.set({ text: \"hi\", num: 20 });\n//  Calling set on an object works.\n\nstate$.assign({ text: \"hello there\" });\n//  Calling assign on an object works.\n\nstate$.text.assign({ value: \"hello there\" });\n//  Error. Cannot call assign on a primitive.\n```\n\n----------------------------------------\n\nTITLE: Using currentDate Observable in Legend-State\nDESCRIPTION: Demonstrates how to use the currentDate observable that automatically updates at midnight to track the current date.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/react/helpers-and-hooks.mdx#2025-04-11_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { currentDate } from \"@legendapp/state/helpers/time\"\n\nobserve(() => {\n    console.log('Today is': currentDate.get())\n})\n```\n\n----------------------------------------\n\nTITLE: Using WhenReady for Non-Empty Collections in Legend-State\nDESCRIPTION: Shows how to use whenReady to listen for arrays or objects becoming non-empty, executing a callback when the condition is met.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/usage/reactivity.mdx#2025-04-11_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport { whenReady } from \"@legendapp/state\";\n\nconst state$ = observable({ arr: [] });\n\nwhenReady(state$.arr, () => console.log(\"Array has some values\"));\n// Not ready yet\n\nstate$.arr.push(\"hello\");\n\n// \"Array has some values\"\n```\n\n----------------------------------------\n\nTITLE: Setting initialContainerPoolRatio for Item Pool\nDESCRIPTION: Ratio of initial container pool size to data length, which affects initial memory usage and rendering performance.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/api/props.mdx#2025-04-11_snippet_11\n\nLANGUAGE: TypeScript\nCODE:\n```\ninitialContainerPoolRatio?: number; // default: 1\n```\n\n----------------------------------------\n\nTITLE: Implementing Keel Audit Table Delete Tracking\nDESCRIPTION: Helper functions to track deletes using Keel's audit log table, retrieving both updated and deleted records since a specific timestamp to ensure sync operations can properly remove deleted items.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/keel.mdx#2025-04-11_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nexport async function listTableWithDeletes<T extends keyof ModelsAPI>(\n    tableName: T,\n    inputs: { where: { updatedAt?: TimestampQueryInput } },\n): Promise<Awaited<ReturnType<ModelsAPI[T]['create']>>[]> {\n    const ret = await models[tableName].findMany(inputs);\n\n    return ret.concat(await listDeletes(tableName, inputs)) as any;\n}\nasync function listDeletes(\n    tableName: keyof ModelsAPI,\n    inputs: { where: { updatedAt?: TimestampQueryInput } },\n): Promise<any[]> {\n    const {\n        where: { updatedAt },\n    } = inputs;\n    if (updatedAt) {\n        const db = useDatabase().withTables<{ keel_audit }>();\n        const res = await db\n            .selectFrom('keel_audit')\n            .selectAll()\n            .where('table_name', '=', camelCaseToSnakeCase(tableName))\n            .where('op', '=', 'delete')\n            .where('created_at', '>', updatedAt.after)\n            .execute();\n\n        return res.map((r) => ({ id: r.data.id, deleted: true }));\n    } else {\n        return [];\n    }\n}\nfunction camelCaseToSnakeCase(input: string) {\n    return input.replace(/([A-Z])/g, ' $1').split(' ').join('_').toLowerCase();\n}\n```\n\n----------------------------------------\n\nTITLE: Color Interpolation Animation\nDESCRIPTION: Demonstrates automatic color interpolation between two values.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/motion/src/content/docs/2-usage/1-overview.mdx#2025-04-11_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\n<Motion.View\n  animate={{\n    backgroundColor: value ? \"#F81FEC\" : \"#59B0F8\",\n  }}\n/>\n```\n\n----------------------------------------\n\nTITLE: Specifying initialScrollIndex for Starting Position\nDESCRIPTION: Begins the list scrolled with this item at the top. For accurate positioning with dynamically sized items, consider using maintainVisibleContentPosition.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/api/props.mdx#2025-04-11_snippet_12\n\nLANGUAGE: TypeScript\nCODE:\n```\ninitialScrollIndex?: number;\n```\n\n----------------------------------------\n\nTITLE: Creating Async Observables with Promises\nDESCRIPTION: Demonstrates creating asynchronous observables using Promises or async functions. The observable starts as undefined and updates when the Promise resolves, enabling reactive async data fetching.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/usage/observable.mdx#2025-04-11_snippet_14\n\nLANGUAGE: javascript\nCODE:\n```\nconst serverState$ = observable(() => fetch('url').then(res => res.json()))\n\nobserve(() => {\n    // Getting the value activates the observable to fetch, and it\n    // updates its value when it resolves.\n    const data = serverState$.get()\n    if (data) {\n        ...\n    }\n})\n```\n\n----------------------------------------\n\nTITLE: Setting initialScrollOffset for Starting Position\nDESCRIPTION: Starts the list scrolled to this specific pixel offset. An alternative to initialScrollIndex when exact positioning is needed.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/api/props.mdx#2025-04-11_snippet_13\n\nLANGUAGE: TypeScript\nCODE:\n```\ninitialScrollOffset?: number;\n```\n\n----------------------------------------\n\nTITLE: Creating Feature Highlight Cards using Astro Starlight in JSX\nDESCRIPTION: This code block creates a grid of cards highlighting the key features of Legend State. Each card contains a title, icon, and description of a specific feature or benefit of the library.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/index.mdx#2025-04-11_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n<CardGrid stagger>\n  <Card title=\"Easy to Use\" icon=\"pencil\">\n    You can start sprinkling legend state without worrying about how to setup\n  </Card>\n  <Card title=\"Built for the New Era\" icon=\"add-document\">\n    Legend State brings back reactivity from knockout with a cool API for React\n  </Card>\n  <Card title=\"Blazingly Fast\" icon=\"setting\">\n    Check the [Krausest benchmarks](./intro/fast)\n  </Card>\n  <Card title=\"Read the docs\" icon=\"open-book\">\n    Learn more in [the Legend Docs](./intro/introduction).\n  </Card>\n</CardGrid>\n```\n\n----------------------------------------\n\nTITLE: Enabling Component Recycling for Performance\nDESCRIPTION: When enabled, reuses the component rendered by the renderItem function instead of unmounting and creating new instances. Can improve performance but has limitations.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/api/props.mdx#2025-04-11_snippet_34\n\nLANGUAGE: TypeScript\nCODE:\n```\nrecycleItems?: boolean; // default: false\n```\n\n----------------------------------------\n\nTITLE: Styling Empty List Component Container\nDESCRIPTION: Applies styling to the internal View container that wraps the ListEmptyComponent.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/api/props.mdx#2025-04-11_snippet_16\n\nLANGUAGE: TypeScript\nCODE:\n```\nListEmptyComponentStyle?: StyleProp<ViewStyle> | undefined;\n```\n\n----------------------------------------\n\nTITLE: Astro Frontmatter Configuration\nDESCRIPTION: Frontmatter configuration for the documentation page, setting the title and sidebar order.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/react/react-examples.mdx#2025-04-11_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n---\ntitle: React Examples\nsidebar:\n    order: 5\n---\n```\n\n----------------------------------------\n\nTITLE: Running Legend Documentation Locally with Bun\nDESCRIPTION: Commands to set up and run the Legend documentation locally using Bun package manager. These commands navigate to the state package directory, install dependencies, and start the development server.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/README.md#2025-04-11_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncd packages/state\nbun i\nbun dev\n```\n\n----------------------------------------\n\nTITLE: Handling Item Size Changes with onItemSizeChanged\nDESCRIPTION: Called when an item's rendered size changes, providing information about the change. Can be used to adjust estimatedItemSize dynamically for improved performance.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/api/props.mdx#2025-04-11_snippet_26\n\nLANGUAGE: TypeScript\nCODE:\n```\nonItemSizeChanged?: (info: {\n        size: number;\n        previous: number;\n        index: number;\n        itemKey: string;\n        itemData: ItemT;\n    }) => void;\n```\n\n----------------------------------------\n\nTITLE: Importing Legend-Motion Library in React Native\nDESCRIPTION: Shows how to import the Motion component from the Legend-Motion library for use in React Native applications.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/motion/src/content/docs/getting-started/introduction.mdx#2025-04-11_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nimport {Motion} from \"@legendapp/motion\"\n```\n\n----------------------------------------\n\nTITLE: Disposing of Listeners in Legend-State\nDESCRIPTION: Shows how to properly clean up onChange listeners to prevent memory leaks by calling the dispose function returned when setting up the listener.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/usage/reactivity.mdx#2025-04-11_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nconst state$ = observable({ text: 'hello' })\n\nconst onChange = () => { ... }\n\nconst dispose = state$.text.onChange(onChange)\n\n// Cancel listening manually\ndispose()\n```\n\n----------------------------------------\n\nTITLE: Setting ViewabilityConfig in LegendList\nDESCRIPTION: Configures when to update the onViewableItemsChanged callback in the LegendList component. References React Native's FlatList viewabilityConfig documentation.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/api/props.mdx#2025-04-11_snippet_37\n\nLANGUAGE: typescript\nCODE:\n```\nviewabilityConfig?: ViewabilityConfig;\n```\n\n----------------------------------------\n\nTITLE: Switching from FlatList to LegendList in React Native\nDESCRIPTION: This code snippet shows how to migrate from FlatList to LegendList. The main requirement is adding the estimatedItemSize prop to help LegendList optimize layout performance.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/api/gettingStarted.mdx#2025-04-11_snippet_1\n\nLANGUAGE: diff\nCODE:\n```\nreturn (\n-  <FlatList\n+  <LegendList\n      data={items}\n      renderItem={({ item }) => <Text>{item.title}</Text>}\n+      estimatedItemSize={320}\n  />\n)\n```\n\n----------------------------------------\n\nTITLE: Using Computed Functions in React Components\nDESCRIPTION: Shows two ways to use computed functions in React components: calling them as functions or accessing them as observables, both within the use$ hook for reactive updates.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/usage/observable.mdx#2025-04-11_snippet_13\n\nLANGUAGE: jsx\nCODE:\n```\nfunction Name() {\n    // Use it as a function\n    const name1 = use$(() => state$.fullName())\n\n    // Use it as an observable\n    const name2 = use$(state$.fullName)\n\n    return <div>{name2}</div>\n}\n```\n\n----------------------------------------\n\nTITLE: Using scrollToIndex Method in LegendList\nDESCRIPTION: Scrolls to the item at the specified index. Accurate scrolling depends on either providing accurate item sizes or using maintainVisibleContentPosition.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/api/props.mdx#2025-04-11_snippet_40\n\nLANGUAGE: typescript\nCODE:\n```\nscrollToIndex: (params: {\n  index: number;\n  animated?: boolean;\n});\n```\n\n----------------------------------------\n\nTITLE: Accessing LegendList Methods with ref\nDESCRIPTION: Provides access to the list's imperative methods like scrollTo. Required for programmatically controlling the list's scroll position.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/api/props.mdx#2025-04-11_snippet_32\n\nLANGUAGE: TypeScript\nCODE:\n```\nref?: LegendListRef;\n```\n\n----------------------------------------\n\nTITLE: Implementing Persistence in Legend-State\nDESCRIPTION: Demonstrates how to use persistObservable with local storage providers to automatically persist state in web and React Native applications.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/intro/getting-started.mdx#2025-04-11_snippet_7\n\nLANGUAGE: js\nCODE:\n```\n// Global configuration\nconfigureObservablePersistence({\n    // Use Local Storage on web\n    pluginLocal: ObservablePersistLocalStorage\n    // Use react-native-mmkv in React Native\n    pluginLocal: ObservablePersistMMKV\n})\n\nconst state$ = observable({ store: { bigObject: { ... } } })\n\n// Persist this observable\npersistObservable(state$, {\n    local: 'store' // Unique name\n})\n```\n\n----------------------------------------\n\nTITLE: Using scrollToOffset Method in LegendList\nDESCRIPTION: Scrolls to a specific content pixel offset in the list. Parameters include the offset to scroll to and whether the scrolling should be animated.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/api/props.mdx#2025-04-11_snippet_41\n\nLANGUAGE: typescript\nCODE:\n```\nscrollToOffset(params: {\n  offset: number;\n  animated?: boolean;\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing onEndReached for Pagination\nDESCRIPTION: A callback triggered when scrolling within onEndReachedThreshold of the bottom. It resets when scrolling above the threshold. Typically used for loading more content.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/api/props.mdx#2025-04-11_snippet_24\n\nLANGUAGE: TypeScript\nCODE:\n```\nonEndReached?: ((info: { distanceFromEnd: number }) => void) | null | undefined;\n```\n\n----------------------------------------\n\nTITLE: Migrating Legend Components to Reactive Components in React\nDESCRIPTION: Shows how to update from the old Legend components to the new Reactive components in both React and React Native environments.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/other/migrating.mdx#2025-04-11_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n// React\nimport { enableReactComponents } from \"@legendapp/state/config/enableReactComponents\";\nenableReactComponents();\n\n// React Native\nimport { enableReactNativeComponents } from \"@legendapp/state/config/enableReactNativeComponents\";\nenableReactNativeComponents();\n\n// Now you can use them anywhere\nimport { Reactive } from \"@legendapp/state/react\";\n\nfunction Component() {\n  // React\n  return <Reactive.div>...</Reactive.div>;\n\n  // React Native\n  return <Reactive.View>...</Reactive.View>;\n}\n```\n\n----------------------------------------\n\nTITLE: Importing and Using CardGrid Component in JSX/Markdown\nDESCRIPTION: This snippet demonstrates how to import Card and CardGrid components from Astrojs Starlight and how to structure a feature highlight section with multiple cards. Each card includes a title, icon, and descriptive text about Legend State features.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/index.mdx#2025-04-11_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Card, CardGrid } from \"@astrojs/starlight/components\";\n\n## Why Legend State?\n\n<CardGrid stagger>\n  <Card title=\"Easy to Use\" icon=\"pencil\">\n    You can start sprinkling legend state without worrying about how to setup\n  </Card>\n  <Card title=\"Built for the New Era\" icon=\"add-document\">\n    Legend State brings back reactivity from knockout with a cool API for React\n  </Card>\n  <Card title=\"Blazingly Fast\" icon=\"setting\">\n    Check the [Krausest benchmarks](./intro/fast)\n  </Card>\n  <Card title=\"Read the docs\" icon=\"open-book\">\n    Learn more in [the Legend Docs](./intro/introduction).\n  </Card>\n</CardGrid>\n```\n\n----------------------------------------\n\nTITLE: Setting numColumns for Multi-Column Layout\nDESCRIPTION: Enables multi-column layout where items zig-zag like flexWrap. Rows take the maximum height of their columns, so items should be similar heights.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/api/props.mdx#2025-04-11_snippet_23\n\nLANGUAGE: TypeScript\nCODE:\n```\nnumColumns?: number;\n```\n\n----------------------------------------\n\nTITLE: Transforming Objects with Linked Observables (JavaScript)\nDESCRIPTION: Shows how to transform objects into a new shape while maintaining links to the original observable values. This allows for filtering and dynamic updates.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/usage/observable.mdx#2025-04-11_snippet_21\n\nLANGUAGE: javascript\nCODE:\n```\nconst state$ = observable({\n  items: {\n    id1: { id: 'id1', status: 'ready' },\n    id2: { id: 'id2', status: 'disabled' }\n  },\n  itemsReady: () => Object.values(state$.items)\n                    .filter(item => item.status.get() === 'ready')\n})\n\nobserve(() => {\n    console.log('observe:' + state$.itemsReady.get())\n})\n// observe: [{ id: 'id1', status: 'ready' }]\n\n// modifying the target object recomputes the computed array\nstate$.items.id2.status.set('ready')\n// observe: [{ id: 'id1', status: 'ready' }, { id: 'id2', status: 'ready' }]\n\n// set on the computed array goes into the target object\nstate$.itemsReady[0].status.set('disabled')\n// observe: [{ id: 'id2', status: 'ready' }]\n```\n\n----------------------------------------\n\nTITLE: Spring Transition Animation\nDESCRIPTION: Example of using spring transition with custom damping and stiffness parameters.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/motion/src/content/docs/2-usage/1-overview.mdx#2025-04-11_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\n<Motion.View\n  animate={{\n    x: value * 100,\n  }}\n  transition={{\n    type: \"spring\",\n    damping: 20,\n    stiffness: 400,\n  }}\n/>\n```\n\n----------------------------------------\n\nTITLE: Setting onStartReachedThreshold for Top Trigger\nDESCRIPTION: Defines how close to the start of the list (as a percentage of screen size) the user must scroll to trigger onStartReached. A value of 0.5 means half a screen away.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/api/props.mdx#2025-04-11_snippet_29\n\nLANGUAGE: TypeScript\nCODE:\n```\nonStartReachedThreshold?: number | null | undefined;\n```\n\n----------------------------------------\n\nTITLE: Using the get() Method with Observables\nDESCRIPTION: Shows how to use the get() method to retrieve the actual value from an observable. The get() method automatically tracks the observable in tracking contexts and can be modified with parameters to change tracking behavior.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/usage/observable.mdx#2025-04-11_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst profile = { name: \"Test user\" }\nconst state$ = observable({ profile, test: 0 })\n\n// get the underlying value from the observable\nconst name = state$.profile.name.get()\n```\n\n----------------------------------------\n\nTITLE: Text Animation with Color and Size\nDESCRIPTION: Example of animating text properties including color and font size.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/motion/src/content/docs/2-usage/1-overview.mdx#2025-04-11_snippet_6\n\nLANGUAGE: jsx\nCODE:\n```\n<Motion.Text\n  animate={{\n    color: value ? \"#F81FEC\" : \"#59B0F8\",\n    fontSize: value ? 48 : 24,\n  }}\n>\n  Text\n</Motion.Text>\n```\n\n----------------------------------------\n\nTITLE: Setting alignItemsAtEnd Prop for Bottom Alignment\nDESCRIPTION: When enabled, this prop aligns items to the end of the screen. Useful for chat interfaces where there are only a few items that should appear at the bottom.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/api/props.mdx#2025-04-11_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nalignItemsAtEnd?: boolean; // default: false\n```\n\n----------------------------------------\n\nTITLE: Implementing Exit Animations with AnimatePresence in React Native\nDESCRIPTION: Demonstrates how to use AnimatePresence to animate a view component before it unmounts. The example shows initial, animate, and exit states with different transition types for opacity and position properties. A key prop is required for proper component tracking.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/motion/src/content/docs/2-usage/9-animate-presence.mdx#2025-04-11_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\n<AnimatePresence>\n  {value ? (\n    <MotionStyled.View\n      key=\"A\"\n      initial={{ opacity: 0.1, x: 0 }}\n      animate={{ opacity: 1, x: 100 }}\n      exit={{ opacity: 0.2, x: 0 }}\n      transition={{\n        default: {\n          type: \"spring\",\n        },\n        opacity: {\n          type: \"timing\",\n        },\n      }}\n    />\n  ) : null}\n</AnimatePresence>\n```\n\n----------------------------------------\n\nTITLE: Gesture-Based Animation\nDESCRIPTION: Implementation of animations triggered by hover and tap gestures using Motion.Pressable.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/motion/src/content/docs/2-usage/1-overview.mdx#2025-04-11_snippet_8\n\nLANGUAGE: jsx\nCODE:\n```\n<Motion.Pressable>\n  <Motion.View\n    whileHover={{ scale: 1.2 }}\n    whileTap={{ y: 20 }}\n    transition={{\n      type: \"spring\",\n      damping: 20,\n      stiffness: 300,\n    }}\n  />\n</Motion.Pressable>\n```\n\n----------------------------------------\n\nTITLE: Mount Animation with Initial State\nDESCRIPTION: Animation that triggers on component mount with defined initial and final positions.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/motion/src/content/docs/2-usage/1-overview.mdx#2025-04-11_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\n<Motion.View initial={{ x: 0 }} animate={{ x: 100 }} />\n```\n\n----------------------------------------\n\nTITLE: Updating onChange Usage in JavaScript\nDESCRIPTION: Shows the new syntax for the onChange method, which now takes an object as its argument and uses an options object for the second parameter.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/other/migrating.mdx#2025-04-11_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\n// Old\nobs.onChange((value, getPrevious, changes) => {\n  // ...\n}, true);\n\n// New\nobs.onChange(\n  ({ value, getPrevious, changes }) => {\n    // ...\n  },\n  { trackingType: true }\n);\n```\n\n----------------------------------------\n\nTITLE: Importing MotionLinearGradient for Expo\nDESCRIPTION: Import statement for using MotionLinearGradient in an Expo project after installing expo-linear-gradient.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/motion/src/content/docs/2-usage/3-linear-gradient.mdx#2025-04-11_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { MotionLinearGradient } from \"@legendapp/motion/linear-gradient-expo\";\n```\n\n----------------------------------------\n\nTITLE: Animating SVG Rectangle Properties in React Native\nDESCRIPTION: This example demonstrates how to animate multiple properties of an SVG rectangle using Legend's MotionSvg components. It shows how to use different transition types for different properties, specifically using a tween animation for color and spring animations for position and size properties.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/motion/src/content/docs/2-usage/2-svg.mdx#2025-04-11_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\n<MotionSvg.Svg height=\"200\" width=\"200\">\n  <MotionSvg.Rect\n    stroke=\"#555\"\n    strokeWidth=\"1\"\n    animateProps={{\n      fill: value ? \"#F81FEC\" : \"#59B0F8\",\n      x: value ? \"60\" : \"0\",\n      y: value ? \"40\" : \"10\",\n      width: value ? \"140\" : \"50\",\n      height: value ? \"140\" : \"50\",\n    }}\n    transition={{\n      default: {\n        type: \"spring\",\n        damping: 20,\n        stiffness: 300,\n      },\n      fill: {\n        type: \"tween\",\n        duration: 800,\n      },\n    }}\n  />\n</MotionSvg.Svg>\n```\n\n----------------------------------------\n\nTITLE: Advanced Synced Observable Configuration\nDESCRIPTION: Shows advanced configuration options for synced observables including custom persistence plugins, retry logic, debouncing, and subscription handling.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/persist-sync.mdx#2025-04-11_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nimport { observable } from '@legendapp/state'\nimport { synced } from '@legendapp/state/sync'\nimport { ObservablePersistMMKV } from '@legendapp/state/persist-plugins/mmkv'\n\nconst state$ = observable(synced({\n    get: () => {\n        return fetch('https://url.to.get/page=' + page.get())\n                .then((res) => res.json())\n    },\n    set: ({ value }) => {\n        fetch('https://url.to.set', { method: 'POST', data: JSON.stringify(value) })\n    }\n    persist: {\n        name: 'test',\n        plugin: ObservablePersistMMKV,\n        retrySync: true,\n        options: {}\n    },\n    initial: {\n        numUsers: 0,\n        messages: []\n    },\n    mode: 'set' | 'assign' | 'merge' | 'append' | 'prepend',\n    subscribe: ({ refresh, update }) => {\n        const unsubscribe = pusher.subscribe({ /*...*/ }, (data) => {\n            update(data)\n            refresh()\n        })\n        return unsubscribe\n    },\n    retry: {\n        infinite: true,\n        backoff: 'exponential',\n        maxDelay: 30\n    },\n    debounceSet: 500,\n}))\n```\n\n----------------------------------------\n\nTITLE: Implementing Transform Origin in React Native with Legend-Motion\nDESCRIPTION: Demonstrates how to use transformOrigin prop to control the scaling origin point in Legend-Motion animations. Shows two examples: scaling from top-left (0,0) and bottom-right (100%,100%) origins.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/motion/src/content/docs/2-usage/5-transform-origin.mdx#2025-04-11_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\n<Motion.View\n  animate={{ scale: value ? 1 : 0.5 }}\n  transformOrigin={{ x: 0, y: 0 }}\n/>\n<Motion.View\n  animate={{ scale: value ? 1 : 0.5 }}\n  transformOrigin={{ x: \"100%\", y: \"100%\" }}\n/>\n```\n\n----------------------------------------\n\nTITLE: Using MotionLinearGradient with Animated Props\nDESCRIPTION: Example of using MotionLinearGradient component with animated props for colors, start, and end positions. The gradient changes based on a 'value' variable.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/motion/src/content/docs/2-usage/3-linear-gradient.mdx#2025-04-11_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\n<MotionLinearGradient\n  animateProps={{\n    colors: [value ? \"#F81FEC\" : \"blue\", value ? \"#59B0F8\" : \"yellow\"],\n    start: { x: 0, y: 0 },\n    end: { x: value ? 1 : 0, y: 1 },\n  }}\n/>\n```\n\n----------------------------------------\n\nTITLE: Configuring React Tracking with Legend-State\nDESCRIPTION: Example showing how to enable automatic React tracking for Legend-State observables using enableReactTracking configuration.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/react/react-introduction.mdx#2025-04-11_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport { observable } from \"@legendapp/state\";\nimport { enableReactTracking } from \"@legendapp/state/config/enableReactTracking\";\n\nenableReactTracking({\n    auto: true,\n});\n\nconst name$ = observable(\"Annyong\");\n\nfunction Component() {\n  // The component re-renders when name changes\n  const name = name$.get();\n\n  return <div>{name}</div>;\n}\n```\n\n----------------------------------------\n\nTITLE: Animating SVG Fill Property with Legend-Motion\nDESCRIPTION: This example demonstrates how to animate the fill color of an SVG rectangle using the animateProps property in Legend-Motion. The fill color transitions between pink (#F81FEC) and blue (#59B0F8) based on a value state, with a tween transition that lasts 500ms.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/motion/src/content/docs/2-usage/6-animate-props.mdx#2025-04-11_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\n<MotionSvg.Svg height=\"200\" width=\"200\">\n  <MotionSvg.Rect\n    stroke=\"#555\"\n    strokeWidth=\"1\"\n    x=\"0\"\n    y=\"10\"\n    width=\"150\"\n    height=\"150\"\n    animateProps={{\n      fill: value ? \"#F81FEC\" : \"#59B0F8\",\n    }}\n    transition={{\n      type: \"tween\",\n      duration: 500,\n    }}\n  />\n</MotionSvg.Svg>\n```\n\n----------------------------------------\n\nTITLE: Configuring Webpack for React Native Web Linear Gradient\nDESCRIPTION: Webpack configuration to alias react-native-linear-gradient for use with React Native Web.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/motion/src/content/docs/2-usage/3-linear-gradient.mdx#2025-04-11_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nresolve: {\n    alias: {\n        'react-native': 'react-native-web',\n        ...\n        'react-native-linear-gradient': 'react-native-web-linear-gradient',\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using useSelector Hook with Legend-State\nDESCRIPTION: Shows how to use the useSelector hook to track specific observable values and computed properties in React components.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/react/react-introduction.mdx#2025-04-11_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nimport { observable } from \"@legendapp/state\";\n\nconst state$ = observable({ fname: \"hello\", lname: \"there\" });\n\nfunction Component() {\n  // Re-render when fname changes\n  const fname = useSelector(state$.fname);\n  // Re-render when the computed value of fullname changes\n  const fullname = useSelector(\n    () => `${state$.fname.get()} ${state$.lname.get()}`\n  );\n\n  return (\n    <div>\n      {fname} {fullname}\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Timing Units in Legend-Motion\nDESCRIPTION: This snippet demonstrates how to configure the timing units in Legend-Motion. It allows switching between milliseconds (React Native's default) and seconds (Framer Motion's default) to ensure compatibility with your existing codebase.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/motion/src/content/docs/2-usage/7-configuration.mdx#2025-04-11_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { configureMotion } from \"@legendapp/motion\";\n\nconfigureMotion({ timing: \"s\" });\n```\n\n----------------------------------------\n\nTITLE: Configuring Legend-Motion with NativeWind\nDESCRIPTION: Steps to configure Legend-Motion to work with NativeWind's styled component system. This setup enables the use of Tailwind CSS classes in Motion components.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/motion/src/content/docs/2-usage/8-tailwind-CSS.mdx#2025-04-11_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nimport { styled } from \"nativewind\";\nimport { configureMotion } from \"@legendapp/motion\";\n\nconfigureMotion({ styled });\n```\n\n----------------------------------------\n\nTITLE: Using syncObservable for Post-Creation Sync Setup\nDESCRIPTION: Shows how to set up sync and persistence after observable creation using syncObservable.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state/src/content/docs/sync/persist-sync.mdx#2025-04-11_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nimport { observable } from '@legendapp/state'\nimport { syncObservable } from '@legendapp/state/sync'\n\nconst state$ = observable({ initialKey: 'initialValue' })\n\nsyncObservable(state$, {\n    get: () =>\n        fetch('https://url.to.get').then((res) => res.json()),\n    set: ({ value }) =>\n        fetch('https://url.to.set', { method: 'POST', data: JSON.stringify(value) }),\n    persist: {\n        name: 'test'\n    }\n})\n```\n\n----------------------------------------\n\nTITLE: Using Tailwind Classes with Motion Components in React Native\nDESCRIPTION: Example showing how to use Tailwind CSS classes with Legend-Motion components while applying animations. The example demonstrates using className for styling views and text with animations like animate, whileHover, and whileTap.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/motion/src/content/docs/2-usage/8-tailwind-CSS.mdx#2025-04-11_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\n<Motion.View\n  className=\"items-center justify-center p-4\"\n  animate={{ x: value * 50 }}\n>\n  <Motion.Text className=\"font-bold text-white\">RN View</Motion.Text>\n</Motion.View>\n<Motion.View\n  className=\"items-center justify-center p-4 mt-8\"\n  whileHover={{ scale: 1.1 }}\n  whileTap={{ x: 30 }}\n>\n  <Motion.Text className=\"font-bold text-white\">Press me</Motion.Text>\n</Motion.View>\n```\n\n----------------------------------------\n\nTITLE: Importing Styled Motion Components\nDESCRIPTION: How to import the styled version of Motion components after configuration. This import pattern gives access to Motion components that support Tailwind CSS classes.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/motion/src/content/docs/2-usage/8-tailwind-CSS.mdx#2025-04-11_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nimport { Motion } from \"@legendapp/motion/styled\";\n```\n\n----------------------------------------\n\nTITLE: Creating Computed Observables\nDESCRIPTION: This snippet demonstrates how to create a computed observable that automatically tracks dependencies and updates when they change. Computed values are lazy-evaluated the first time get() is called.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/usage/observable.mdx#2025-04-11_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nconst state$ = observable({ test: 10, test2: 20 });\n\n// Returning a function makes it computed from other observables\nconst computed$ = computed(() => state$.test.get() + state$.test2.get());\n// computed$.get() === 30\n\nstate$.test.set(5);\n// computed$.get() === 25\n```\n\n----------------------------------------\n\nTITLE: Importing Starlight Components in MDX\nDESCRIPTION: Imports Card and CardGrid components from the Starlight component library for use in the welcome page layout.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/motion/src/content/docs/index.mdx#2025-04-11_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Card, CardGrid } from '@astrojs/starlight/components';\n```\n\n----------------------------------------\n\nTITLE: Configuring Next.js Webpack for Legend-Motion Integration\nDESCRIPTION: Complete Next.js configuration setup that enables Legend-Motion functionality along with optional Linear Gradient and SVG feature support. The configuration includes module transpilation settings and webpack aliases for react-native-web compatibility.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/motion/src/content/docs/3-resources/3-next.js.mdx#2025-04-11_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst withTM = require(\"next-transpile-modules\")([\n  \"@legendapp/motion\",\n  // Only required for MotionLinearGradient:\n  \"react-native-linear-gradient\",\n  // Only required for MotionSvg:\n  \"react-native-svg\",\n]);\n\nmodule.exports = withTM({\n  webpack(cfg) {\n    cfg.resolve.alias = {\n      ...(cfg.resolve.alias || {}),\n      \"react-native$\": \"react-native-web\",\n      // Only required for MotionLinearGradient:\n      \"react-native-linear-gradient\": \"react-native-web-linear-gradient\",\n    };\n    // Only required for MotionSvg:\n    cfg.resolve.extensions = [\n      \".web.js\",\n      \".web.jsx\",\n      \".web.ts\",\n      \".web.tsx\",\n      ...cfg.resolve.extensions,\n    ];\n\n    return cfg;\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Importing Astro Starlight Components in JSX\nDESCRIPTION: This snippet imports the Card and CardGrid components from the Astro Starlight library, which are used to create a visually appealing grid layout for feature highlights.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/index.mdx#2025-04-11_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Card, CardGrid } from \"@astrojs/starlight/components\";\n```\n\n----------------------------------------\n\nTITLE: Using Recycling Hooks in LegendList\nDESCRIPTION: Defines two hooks for managing item recycling: useRecyclingEffect for handling side effects when items are recycled, and useRecyclingState for resetting state when items are recycled.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/list/src/content/docs/api/props.mdx#2025-04-11_snippet_44\n\nLANGUAGE: typescript\nCODE:\n```\nuseRecyclingEffect: (effect: (info: LegendListRecyclingState) => void | (() => void)) => void;\nuseRecyclingState: <T>(updateState: ((info: LegendListRecyclingState) => T) | T) => [T, Dispatch<T>];\n```\n\n----------------------------------------\n\nTITLE: Configuring Babel for Legend State Plugin\nDESCRIPTION: Shows how to add the Legend State Babel plugin to the babel.config.js file.\nSOURCE: https://github.com/legendapp/legend-docs/blob/main/packages/state-v2/src/content/docs/react/fine-grained-reactivity.mdx#2025-04-11_snippet_9\n\nLANGUAGE: js\nCODE:\n```\nmodule.exports = {\n  plugins: [\"@legendapp/state/babel\"],\n};\n```"
  }
]