[
  {
    "owner": "odin-lang",
    "repo": "odin.git",
    "content": "TITLE: Demonstrating Basic Odin Syntax and Features\nDESCRIPTION: This code snippet showcases basic Odin syntax, including package declaration, imports, procedure definition, string manipulation, and control flow. It processes a string of symbols to perform arithmetic operations on an accumulator.\nSOURCE: https://github.com/odin-lang/odin.git/blob/master/README.md#2025-04-21_snippet_0\n\nLANGUAGE: odin\nCODE:\n```\npackage main\n\nimport \"core:fmt\"\n\nmain :: proc() {\n\tprogram := \"+ + * ðŸ˜ƒ - /\"\n\taccumulator := 0\n\n\tfor token in program {\n\t\tswitch token {\n\t\tcase '+': accumulator += 1\n\t\tcase '-': accumulator -= 1\n\t\tcase '*': accumulator *= 2\n\t\tcase '/': accumulator /= 2\n\t\tcase 'ðŸ˜ƒ': accumulator *= accumulator\n\t\tcase: // Ignore everything else\n\t\t}\n\t}\n\n\tfmt.printf(\"The program \\\"%s\\\" calculates the value %d\\n\",\n\t           program, accumulator)\n}\n```\n\n----------------------------------------\n\nTITLE: Integrating Odin WebAssembly with HTML and JavaScript\nDESCRIPTION: A minimal example showing how to load and run Odin-compiled WebAssembly in a web page. The code references the odin.js utility which handles initialization and execution of the WASM module, with output directed to a console element.\nSOURCE: https://github.com/odin-lang/odin.git/blob/master/core/sys/wasm/README.md#2025-04-21_snippet_0\n\nLANGUAGE: html\nCODE:\n```\n<!-- Copy `core:sys/wasm/js/odin.js` into your web server -->\n<script type=\"text/javascript\" src=\"odin.js\"></script>\n<script type=\"text/javascript\">\n\todin.runWasm(pathToWasm, consolePreElement);\n</script>\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Window with Raylib in Odin\nDESCRIPTION: This example demonstrates how to create a basic window using raylib in Odin language. It initializes a window, runs a drawing loop until the window is closed, displays text, and properly cleans up resources.\nSOURCE: https://github.com/odin-lang/odin.git/blob/master/vendor/raylib/README.md#2025-04-21_snippet_0\n\nLANGUAGE: odin\nCODE:\n```\npackage example\n\nimport rl \"vendor:raylib\"\n\nmain :: proc() {\n    rl.InitWindow(800, 450, \"raylib [core] example - basic window\")\n\n    for !rl.WindowShouldClose() {\n        rl.BeginDrawing()\n            rl.ClearBackground(rl.RAYWHITE)\n            rl.DrawText(\"Congrats! You created your first window!\", 190, 200, 20, rl.LIGHTGRAY)\n        rl.EndDrawing()\n    }\n\n    rl.CloseWindow()\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Basic Syntax and Features in Odin\nDESCRIPTION: This snippet showcases a simple Odin program that processes a string of symbols, performing arithmetic operations based on each character. It demonstrates package declaration, importing, procedure definition, string manipulation, control flow, and formatted output.\nSOURCE: https://github.com/odin-lang/odin.git/blob/master/tests/core/assets/Shoco/README.md#2025-04-21_snippet_0\n\nLANGUAGE: odin\nCODE:\n```\npackage main\n\nimport \"core:fmt\"\n\nmain :: proc() {\n\tprogram := \"+ + * ðŸ˜ƒ - /\"\n\taccumulator := 0\n\n\tfor token in program {\n\t\tswitch token {\n\t\tcase '+': accumulator += 1\n\t\tcase '-': accumulator -= 1\n\t\tcase '*': accumulator *= 2\n\t\tcase '/': accumulator /= 2\n\t\tcase 'ðŸ˜ƒ': accumulator *= accumulator\n\t\tcase: // Ignore everything else\n\t\t}\n\t}\n\n\tfmt.printf(\"The program \\\"%s\\\" calculates the value %d\\n\",\n\t           program, accumulator)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Dynamic Buffer Operations in Odin\nDESCRIPTION: This snippet implements operations for dynamic buffer manipulation in Odin, including making, resizing, clearing, and deleting dynamic arrays. These procedures provide the core functionality for working with dynamic collections in the language.\nSOURCE: https://github.com/odin-lang/odin.git/blob/master/tests/core/os/dir/b.txt#2025-04-21_snippet_2\n\nLANGUAGE: odin\nCODE:\n```\nsbuffer_make :: proc(backing: rawptr, count, size: int, loc := #caller_location) -> [dynamic]byte {\n\t// _sbuffer_make may be nil in non-runtime builds\n\tassert(_sbuffer_make != nil)\n\n\treturn _sbuffer_make(backing, count, size, loc)\n}\n\nsbuffer_make_len_cap :: proc(backing: rawptr, length, capacity, size: int, loc := #caller_location) -> [dynamic]byte {\n\t// _sbuffer_make_len_cap may be nil in non-runtime builds\n\tassert(_sbuffer_make_len_cap != nil)\n\n\treturn _sbuffer_make_len_cap(backing, length, capacity, size, loc)\n}\n\nsbuffer_resize :: proc(buf: ^$T/#simd[N]$E/[dynamic]E, new_len: int, loc := #caller_location) -> [dynamic]E {\n\treturn _sbuffer_resize(buf, new_len, loc)\n}\n\nsbuffer_reserve :: proc(buf: ^$T/#simd[N]$E/[dynamic]E, new_cap: int, loc := #caller_location) -> [dynamic]E {\n\treturn _sbuffer_reserve(buf, new_cap, loc)\n}\n\nsbuffer_append :: proc(buf: ^$T/#simd[N]$E/[dynamic]E, item: E, loc := #caller_location) -> [dynamic]E {\n\treturn _sbuffer_append(buf, item, loc)\n}\n\nsbuffer_appendv :: proc(buf: ^$T/#simd[N]$E/[dynamic]E, items: ..E, loc := #caller_location) -> [dynamic]E {\n\treturn _sbuffer_appendv(buf, ..items, loc)\n}\n\nsbuffer_pop :: proc(buf: ^$T/#simd[N]$E/[dynamic]E, loc := #caller_location) -> E {\n\treturn _sbuffer_pop(buf, loc)\n}\n\nsbuffer_clear :: proc(buf: ^$T/#simd[N]$E/[dynamic]E, loc := #caller_location) -> [dynamic]E {\n\treturn _sbuffer_clear(buf, loc)\n}\n\nsbuffer_delete :: proc(buf: ^$T/#simd[N]$E/[dynamic]E, loc := #caller_location) {\n\t_sbuffer_delete(buf, loc)\n}\n\nsbuffer_init_string :: proc(backing: rawptr, len: int, loc := #caller_location) -> string {\n\treturn _sbuffer_init_string(backing, len, loc)\n}\n\nsbuffer_make_string :: proc(backing: rawptr, len: int, loc := #caller_location) -> string {\n\treturn _sbuffer_make_string(backing, len, loc)\n}\n\nsbuffer_make_string_allocation :: proc(len: int, loc := #caller_location) -> (string, rawptr) {\n\treturn _sbuffer_make_string_allocation(len, loc)\n}\n\n\n```\n\n----------------------------------------\n\nTITLE: Embedding and Running Odin-compiled WASM in HTML\nDESCRIPTION: This snippet demonstrates how to include the necessary JavaScript file and run a WASM module compiled from Odin in a web page. It uses the 'odin.js' file and the 'runWasm' function to execute the WASM code.\nSOURCE: https://github.com/odin-lang/odin.git/blob/master/vendor/wasm/README.md#2025-04-21_snippet_0\n\nLANGUAGE: html\nCODE:\n```\n<!-- Copy `core:sys/wasm/js/odin.js` into your web server -->\n<script type=\"text/javascript\" src=\"odin.js\"></script>\n<script type=\"text/javascript\">\n\todin.runWasm(pathToWasm, consolePreElement);\n</script>\n```\n\n----------------------------------------\n\nTITLE: Implementing Lua with Custom Memory Allocator in Odin\nDESCRIPTION: Example implementation showing how to initialize Lua state with a custom context-based allocator in Odin. Demonstrates memory management, state creation, and basic Lua string execution.\nSOURCE: https://github.com/odin-lang/odin.git/blob/master/vendor/lua/README.md#2025-04-21_snippet_0\n\nLANGUAGE: odin\nCODE:\n```\npackage lua_example_with_context\n\nimport \"core:fmt\"\nimport lua \"vendor:lua/5.4\" // or whatever version you want\nimport \"core:c\"\nimport \"base:runtime\"\n\nstate: ^lua.State\n\nlua_allocator :: proc \"c\" (ud: rawptr, ptr: rawptr, osize, nsize: c.size_t) -> (buf: rawptr) {\n\told_size := int(osize)\n\tnew_size := int(nsize)\n\tcontext = (^runtime.Context)(ud)^\n\n\tif ptr == nil {\n\t\tdata, err := runtime.mem_alloc(new_size)\n\t\treturn raw_data(data) if err == .None else nil\n\t} else {\n\t\tif nsize > 0 {\n\t\t\tdata, err := runtime.mem_resize(ptr, old_size, new_size)\n\t\t\treturn raw_data(data) if err == .None else nil\n\t\t} else {\n\t\t\truntime.mem_free(ptr)\n\t\t\treturn\n\t\t}\n\t}\n}\n\nmain :: proc() {\n\t_context := context\n\tstate = lua.newstate(lua_allocator, &_context)\n\tdefer lua.close(state)\n\n\tlua.L_dostring(state, \"return 'somestring'\")\n\tstr := lua.tostring(state, -1)\n\tfmt.println(str)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Runtime Allocation Wrappers in Odin\nDESCRIPTION: This snippet implements wrapper procedures for memory allocation and deallocation, providing a consistent interface to the core allocation functions. These wrappers handle default alignment and provide access to the underlying memory management system.\nSOURCE: https://github.com/odin-lang/odin.git/blob/master/tests/core/os/dir/b.txt#2025-04-21_snippet_1\n\nLANGUAGE: odin\nCODE:\n```\nruntime_assert :: proc(condition: bool, message: string, loc := #caller_location) -> bool {\n\treturn _assert(condition, message, loc)\n}\n\n// This is an implementation, the name comes from the core.Default_Allocator\nfree_all :: proc(allocator_data: rawptr) {\n\t// Default runtime allocator has no state\n}\n\n// The allocation procedure does not zero the memory\nalloc_non_zeroed :: proc(size, align: int, loc := #caller_location) -> rawptr {\n\tif size <= 0 {\n\t\treturn nil\n\t}\n\treturn _alloc_non_zeroed(size, align, loc)\n}\n\n// Free the pointer with default parameters\nfree :: proc(ptr: rawptr, loc := #caller_location) {\n\t_free(ptr, loc)\n}\n\n// Grow is effectively realloc_non_zeroed with some different semantics\ngrow :: proc(ptr: rawptr, old_size, new_size, align: int, loc := #caller_location) -> rawptr {\n\tif new_size <= 0 {\n\t\tfree(ptr)\n\t\treturn nil\n\t}\n\treturn _grow(ptr, old_size, new_size, align, loc)\n}\n\n// Default implementation for the realloc_non_zeroed procedure\n@(private=\"file\")\ndefault_resize :: proc(ptr: rawptr, old_size, new_size, align: int, loc := #caller_location) -> rawptr {\n\told_size, new_size := old_size, new_size\n\n\tif new_size == old_size {\n\t\treturn ptr\n\t}\n\n\tif ptr == nil {\n\t\treturn alloc_non_zeroed(new_size, align, loc)\n\t}\n\tif new_size <= 0 {\n\t\tfree(ptr, loc)\n\t\treturn nil\n\t}\n\n\tmem := alloc_non_zeroed(new_size, align, loc)\n\tif mem != nil {\n\t\tsize := old_size if old_size < new_size else new_size\n\t\tintrinsics.mem_copy_non_overlapping(mem, ptr, size)\n\t\tfree(ptr, loc)\n\t}\n\treturn mem\n}\n\n// Default implemenation for the resize allocation procedure\nresize :: proc(ptr: rawptr, old_size, new_size, align: int, loc := #caller_location) -> rawptr {\n\t_ = old_size\n\t_ = align\n\t\n\tif _resize == nil {\n\t\treturn default_resize(ptr, old_size, new_size, align, loc)\n\t}\n\tif new_size <= 0 {\n\t\tfree(ptr, loc)\n\t\treturn nil\n\t}\n\treturn _resize(ptr, old_size, new_size, align, loc)\n}\n\n```\n\n----------------------------------------\n\nTITLE: Loading OpenGL Function Pointers with GLFW in Odin\nDESCRIPTION: This snippet demonstrates how to load OpenGL function pointers using the gl.load_up_to procedure with a custom GetProcAddress function from GLFW.\nSOURCE: https://github.com/odin-lang/odin.git/blob/master/vendor/OpenGL/README.md#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ngl.load_up_to(4, 5, proc(p: rawptr, name: cstring) do (cast(^rawptr)p)^ = glfw.GetProcAddress(name); );\n```\n\n----------------------------------------\n\nTITLE: Loading OpenGL Function Pointers with GLFW Helper in Odin\nDESCRIPTION: This snippet shows a simplified way to load OpenGL function pointers using the gl.load_up_to procedure with a helper function provided by the glfw vendor package.\nSOURCE: https://github.com/odin-lang/odin.git/blob/master/vendor/OpenGL/README.md#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\ngl.load_up_to(4, 5, glfw.gl_set_proc_address);\n```\n\n----------------------------------------\n\nTITLE: Defining Core Package Hooks in Odin\nDESCRIPTION: This snippet declares the configuration hooks for Odin's core package. It defines override symbols for memory allocation, deallocation, and other runtime functions that can be customized by users of the language.\nSOURCE: https://github.com/odin-lang/odin.git/blob/master/tests/core/os/dir/b.txt#2025-04-21_snippet_0\n\nLANGUAGE: odin\nCODE:\n```\npackage core\n\n@(private=\"file\")\nforeign core {\n\t_alloc_non_zeroed :: proc(size, align: int, loc := #caller_location) -> rawptr ---\n\t_free             :: proc(ptr: rawptr, loc := #caller_location) ---\n\t_grow             :: proc(ptr: rawptr, old_size, new_size, new_align: int, loc := #caller_location) -> rawptr ---\n\t_resize           :: proc(ptr: rawptr, old_size, new_size, new_align: int, loc := #caller_location) -> rawptr ---\n\n\t_assert :: proc(condition: bool, message: string, loc: Source_Code_Location) -> bool ---\n\n\t_sbuffer_make                  :: proc(backing: rawptr, count, size: int, loc := #caller_location) -> [dynamic]byte ---\n\t_sbuffer_make_len_cap          :: proc(backing: rawptr, length, capacity, size: int, loc := #caller_location) -> [dynamic]byte ---\n\t_sbuffer_resize                :: proc(buf: ^$T/#simd[N]$E/[dynamic]E, new_len: int, loc := #caller_location) -> [dynamic]E ---\n\t_sbuffer_reserve               :: proc(buf: ^$T/#simd[N]$E/[dynamic]E, new_cap: int, loc := #caller_location) -> [dynamic]E ---\n\t_sbuffer_append                :: proc(buf: ^$T/#simd[N]$E/[dynamic]E, item: E, loc := #caller_location) -> [dynamic]E ---\n\t_sbuffer_appendv               :: proc(buf: ^$T/#simd[N]$E/[dynamic]E, items: ..E, loc := #caller_location) -> [dynamic]E ---\n\t_sbuffer_pop                   :: proc(buf: ^$T/#simd[N]$E/[dynamic]E, loc := #caller_location) -> E ---\n\t_sbuffer_clear                 :: proc(buf: ^$T/#simd[N]$E/[dynamic]E, loc := #caller_location) -> [dynamic]E ---\n\t_sbuffer_delete                :: proc(buf: ^$T/#simd[N]$E/[dynamic]E, loc := #caller_location) ---\n\n\t_sbuffer_init_string           :: proc(backing: rawptr, len: int, loc := #caller_location) -> string ---\n\t_sbuffer_make_string           :: proc(backing: rawptr, len: int, loc := #caller_location) -> string ---\n\t_sbuffer_make_string_allocation:: proc(len: int, loc := #caller_location) -> (string, rawptr) ---\n\n\t_array_quaternion_multiply_f16 :: proc(q0, q1: [4]f16) -> [4]f16 #optional ---\n\t_array_quaternion_multiply_f32 :: proc(q0, q1: [4]f32) -> [4]f32 #optional ---\n\t_array_quaternion_multiply_f64 :: proc(q0, q1: [4]f64) -> [4]f64 #optional ---\n}\n\n\n```\n\n----------------------------------------\n\nTITLE: Loading glTF File in Odin\nDESCRIPTION: Demonstrates how to load a glTF file using cgltf library. Initializes options, parses the file, and properly handles memory cleanup with defer.\nSOURCE: https://github.com/odin-lang/odin.git/blob/master/vendor/cgltf/README.md#2025-04-21_snippet_0\n\nLANGUAGE: odin\nCODE:\n```\npackage main\n\nimport \"vendor:cgltf\"\n\nmain :: proc() {\n\toptions: cgltf.options\n\tdata, result := cgltf.parse_file(&options, \"scene.gltf\")\n\tif result != .success {\n\t\t/* TODO handle error */\n\t}\n\tdefer cgltf.free(data)\n\t/* TODO make awesome stuff */\n}\n```\n\n----------------------------------------\n\nTITLE: Loading glTF from Memory in Odin\nDESCRIPTION: Shows how to load glTF data from memory buffer instead of file. Takes byte buffer as input and uses parse function with raw data pointer.\nSOURCE: https://github.com/odin-lang/odin.git/blob/master/vendor/cgltf/README.md#2025-04-21_snippet_1\n\nLANGUAGE: odin\nCODE:\n```\npackage main\n\nimport \"vendor:cgltf\"\n\nmain :: proc() {\n\tbuf: []byte = ... // data to glb or gltf file data\n\n\toptions: cgltf.options\n\tdata, result := cgltf.parse(&options, raw_data(buf), len(buf))\n\tif result != .success {\n\t\t/* TODO handle error */\n\t}\n\tdefer cgltf.free(data)\n\t/* TODO make awesome stuff */\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Metal Module in Odin\nDESCRIPTION: Shows how to import the Metal module in an Odin project. This is the first step to use metal-odin in your application.\nSOURCE: https://github.com/odin-lang/odin.git/blob/master/vendor/darwin/Metal/README.md#2025-04-21_snippet_0\n\nLANGUAGE: odin\nCODE:\n```\nimport MTL \"core:sys/darwin/Metal\"\n```\n\n----------------------------------------\n\nTITLE: Creating Metal Device in Odin\nDESCRIPTION: Illustrates how to create a Metal device using Odin with metal-odin. This example includes manual release of the device object, mirroring Objective-C manual memory management.\nSOURCE: https://github.com/odin-lang/odin.git/blob/master/vendor/darwin/Metal/README.md#2025-04-21_snippet_3\n\nLANGUAGE: odin\nCODE:\n```\ndevice := MTL.CreateSystemDefaultDevice()\n\n// ...\n\ndevice->release()\n```\n\n----------------------------------------\n\nTITLE: Implementing Quaternion Operations in Odin\nDESCRIPTION: This snippet implements quaternion multiplication operations for different floating-point precision levels. It provides convenience wrappers around optional core functionality for 16-bit, 32-bit, and 64-bit floating-point quaternion operations.\nSOURCE: https://github.com/odin-lang/odin.git/blob/master/tests/core/os/dir/b.txt#2025-04-21_snippet_3\n\nLANGUAGE: odin\nCODE:\n```\narray_quaternion_multiply_f16 :: proc(q0, q1: [4]f16) -> [4]f16 {\n\t#partial switch runtime.SIMD_INFO.f16.width {\n\tcase 0:\n\t\tif _array_quaternion_multiply_f16 != nil {\n\t\t\treturn _array_quaternion_multiply_f16(q0, q1)\n\t\t}\n\t}\n\n\ta1, b1, c1, d1 := q0.x, q0.y, q0.z, q0.w\n\ta2, b2, c2, d2 := q1.x, q1.y, q1.z, q1.w\n\n\treturn [4]f16{\n\t\td1*a2 + a1*d2 + b1*c2 - c1*b2,\n\t\td1*b2 + b1*d2 + c1*a2 - a1*c2,\n\t\td1*c2 + c1*d2 + a1*b2 - b1*a2,\n\t\td1*d2 - a1*a2 - b1*b2 - c1*c2,\n\t}\n}\n\narray_quaternion_multiply_f32 :: proc(q0, q1: [4]f32) -> [4]f32 {\n\t#partial switch runtime.SIMD_INFO.f32.width {\n\tcase 0:\n\t\tif _array_quaternion_multiply_f32 != nil {\n\t\t\treturn _array_quaternion_multiply_f32(q0, q1)\n\t\t}\n\t}\n\n\ta1, b1, c1, d1 := q0.x, q0.y, q0.z, q0.w\n\ta2, b2, c2, d2 := q1.x, q1.y, q1.z, q1.w\n\n\treturn [4]f32{\n\t\td1*a2 + a1*d2 + b1*c2 - c1*b2,\n\t\td1*b2 + b1*d2 + c1*a2 - a1*c2,\n\t\td1*c2 + c1*d2 + a1*b2 - b1*a2,\n\t\td1*d2 - a1*a2 - b1*b2 - c1*c2,\n\t}\n}\n\narray_quaternion_multiply_f64 :: proc(q0, q1: [4]f64) -> [4]f64 {\n\t#partial switch runtime.SIMD_INFO.f64.width {\n\tcase 0:\n\t\tif _array_quaternion_multiply_f64 != nil {\n\t\t\treturn _array_quaternion_multiply_f64(q0, q1)\n\t\t}\n\t}\n\n\ta1, b1, c1, d1 := q0.x, q0.y, q0.z, q0.w\n\ta2, b2, c2, d2 := q1.x, q1.y, q1.z, q1.w\n\n\treturn [4]f64{\n\t\td1*a2 + a1*d2 + b1*c2 - c1*b2,\n\t\td1*b2 + b1*d2 + c1*a2 - a1*c2,\n\t\td1*c2 + c1*d2 + a1*b2 - b1*a2,\n\t\td1*d2 - a1*a2 - b1*b2 - c1*c2,\n\t}\n}\n\n```\n\n----------------------------------------\n\nTITLE: OpenGL Debug Output Example in Odin\nDESCRIPTION: This snippet demonstrates the debug output format when using the OpenGL loader with debug mode enabled. It shows various OpenGL function calls and their corresponding error statuses.\nSOURCE: https://github.com/odin-lang/odin.git/blob/master/vendor/OpenGL/README.md#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nglGetError() returned NO_ERROR\n   call: glTexImage2D(GL_TEXTURE_2D=3553, 0, 34836, 1150, 1024, 0, GL_RGBA=6408, GL_FLOAT=5126, 0x0)\n   in:   C:/<snip>/texture.odin(156:23)\nglGetError() returned NO_ERROR\n   call: glEnable(GL_DEBUG_OUTPUT=37600)\n   in:   C:/<snip>/main.odin(185:6)\nglGetError() returned NO_ERROR\n   call: glGetError() -> 0 \n   in:   C:/<snip>/main.odin(193:5)\nglGetError() returned INVALID_ENUM\n   call: glEnable(INVALID_ENUM=123123123)\n   in:   C:/<snip>/main.odin(194:5)\nglGetError() returned INVALID_VALUE\n   call: glPointSize(-1.000)\n   in:   C:/<snip>/main.odin(195:5)\nglGetError() returned NO_ERROR\n   call: glDisable(GL_SCISSOR_TEST=3089)\n   in:   C:/<snip>/main.odin(270:6)\nglGetError() returned NO_ERROR\n   call: glViewport(0, 0, 1150, 1024)\n   in:   C:/<snip>/main.odin(271:6)\nglGetError() returned NO_ERROR\n   call: glClearColor(0.800, 0.800, 0.800, 1.000)\n   in:   C:/<snip>/main.odin(272:6)\n```\n\n----------------------------------------\n\nTITLE: Configuring Sampler State in Odin\nDESCRIPTION: Illustrates how to create and configure a Metal sampler state using Odin with metal-odin. This example sets various sampler properties, creates a sampler state, and includes manual release of both the descriptor and the resulting sampler state.\nSOURCE: https://github.com/odin-lang/odin.git/blob/master/vendor/darwin/Metal/README.md#2025-04-21_snippet_6\n\nLANGUAGE: odin\nCODE:\n```\nsamplerDescriptor := MTL.SamplerDescriptor.alloc()->init()\n\nsamplerDescriptor->setSAddressMode(.Repeat)\nsamplerDescriptor->setTAddressMode(.Repeat)\nsamplerDescriptor->setRAddressMode(.Repeat)\nsamplerDescriptor->setMagFilter(.Linear)\nsamplerDescriptor->setMinFilter(.Linear)\nsamplerDescriptor->setMipFilter(.Linear)\nsamplerDescriptor->setSupportArgumentBuffers(true)\n\nsamplerState := device->newSamplerState(samplerDescriptor)\n\nsamplerDescriptor->release()\n\n// ...\n\nsamplerState->release()\n```\n\n----------------------------------------\n\nTITLE: Creating Metal Device in Objective-C (ARC)\nDESCRIPTION: Demonstrates how to create a Metal device using Objective-C with Automatic Reference Counting (ARC). This is a basic setup step for Metal applications.\nSOURCE: https://github.com/odin-lang/odin.git/blob/master/vendor/darwin/Metal/README.md#2025-04-21_snippet_1\n\nLANGUAGE: objc\nCODE:\n```\nid< MTLDevice > device = MTLCreateSystemDefaultDevice();\n\n// ...\n```\n\n----------------------------------------\n\nTITLE: Writing glTF to File in Odin\nDESCRIPTION: Demonstrates writing glTF data to a file. Requires valid cgltf.data structure and handles error checking.\nSOURCE: https://github.com/odin-lang/odin.git/blob/master/vendor/cgltf/README.md#2025-04-21_snippet_2\n\nLANGUAGE: odin\nCODE:\n```\npackage main\n\nimport \"vendor:cgltf\"\n\nmain :: proc() {\n\toptions: cgltf.options\n\tdata: ^cgltf.data = /* TODO must be valid data */\n\tresult := cgltf.write_file(&options, \"out.gltf\", data)\n\tif result != .success {\n\t\t/* TODO handle error */\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Metal Device in Objective-C (Manual Memory Management)\nDESCRIPTION: Shows how to create a Metal device using Objective-C with manual memory management. This example includes explicit release of the device object.\nSOURCE: https://github.com/odin-lang/odin.git/blob/master/vendor/darwin/Metal/README.md#2025-04-21_snippet_2\n\nLANGUAGE: objc\nCODE:\n```\nid< MTLDevice > device = MTLCreateSystemDefaultDevice();\n\n// ...\n\n[device release];\n```\n\n----------------------------------------\n\nTITLE: Configuring Sampler State in Objective-C (Manual Memory Management)\nDESCRIPTION: Shows how to create and configure a Metal sampler state using Objective-C with manual memory management. This example includes explicit release of both the descriptor and the resulting sampler state.\nSOURCE: https://github.com/odin-lang/odin.git/blob/master/vendor/darwin/Metal/README.md#2025-04-21_snippet_5\n\nLANGUAGE: objc\nCODE:\n```\nMTLSamplerDescriptor* samplerDescriptor = [[MTLSamplerDescriptor alloc] init];\n\n[samplerDescriptor setSAddressMode: MTLSamplerAddressModeRepeat];\n[samplerDescriptor setTAddressMode: MTLSamplerAddressModeRepeat];\n[samplerDescriptor setRAddressMode: MTLSamplerAddressModeRepeat];\n[samplerDescriptor setMagFilter: MTLSamplerMinMagFilterLinear];\n[samplerDescriptor setMinFilter: MTLSamplerMinMagFilterLinear];\n[samplerDescriptor setMipFilter: MTLSamplerMipFilterLinear];\n[samplerDescriptor setSupportArgumentBuffers: YES];\n\nid< MTLSamplerState > samplerState = [device newSamplerStateWithDescriptor:samplerDescriptor];\n\n[samplerDescriptor release];\n\n// ...\n\n[samplerState release];\n```\n\n----------------------------------------\n\nTITLE: Configuring Sampler State in Objective-C (ARC)\nDESCRIPTION: Demonstrates how to create and configure a Metal sampler state using Objective-C with Automatic Reference Counting (ARC). This example sets various sampler properties and creates a sampler state.\nSOURCE: https://github.com/odin-lang/odin.git/blob/master/vendor/darwin/Metal/README.md#2025-04-21_snippet_4\n\nLANGUAGE: objc\nCODE:\n```\nMTLSamplerDescriptor* samplerDescriptor = [[MTLSamplerDescriptor alloc] init];\n\n[samplerDescriptor setSAddressMode: MTLSamplerAddressModeRepeat];\n[samplerDescriptor setTAddressMode: MTLSamplerAddressModeRepeat];\n[samplerDescriptor setRAddressMode: MTLSamplerAddressModeRepeat];\n[samplerDescriptor setMagFilter: MTLSamplerMinMagFilterLinear];\n[samplerDescriptor setMinFilter: MTLSamplerMinMagFilterLinear];\n[samplerDescriptor setMipFilter: MTLSamplerMipFilterLinear];\n[samplerDescriptor setSupportArgumentBuffers: YES];\n\nid< MTLSamplerState > samplerState = [device newSamplerStateWithDescriptor:samplerDescriptor];\n```\n\n----------------------------------------\n\nTITLE: Writing glTF to Memory in Odin\nDESCRIPTION: Shows how to write glTF data to memory buffer. First calculates required size, allocates buffer, then writes data with size verification.\nSOURCE: https://github.com/odin-lang/odin.git/blob/master/vendor/cgltf/README.md#2025-04-21_snippet_3\n\nLANGUAGE: odin\nCODE:\n```\npackage main\n\nimport \"vendor:cgltf\"\n\nmain :: proc() {\n\toptions: cgltf.options\n\tdata: ^cgltf.data = /* TODO must be valid data */\n\n\tsize := cgltf.write(&options, nil, 0, data)\n\n\tbuf := make([]byte, size)\n\n\twritten := cgltf.write(&options, raw_data(buf), size, data)\n\tif written != size {\n\t\t/* TODO handle error */\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Design Document Template for Odin Proposals in Markdown\nDESCRIPTION: Template to be used when creating a design document for a proposed change to the Odin project. The template includes sections for abstract, background, proposal details, rationale, compatibility considerations, and implementation plans.\nSOURCE: https://github.com/odin-lang/odin.git/blob/master/PROPOSAL-PROCESS.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Proposal: [Title]\n\nAuthor(s): [Author Name, Co-Author Name]\nLast updated: [Date ISO-8601]\nDiscussion at https://github.com/odin-lang/Odin/issues/######\n\n## Abstract\n\n## Background\n\n## Proposal\n\n## Rationale\n\n## Compatibility\n\n## Implementation\n\n```\n\n----------------------------------------\n\nTITLE: Data Type Safety Table in Markdown\nDESCRIPTION: A markdown table documenting which Odin data types are safe for transfer between compile-time execution and runtime, with safety indicators (Y/N/D/?) and explanations for each type.\nSOURCE: https://github.com/odin-lang/odin.git/blob/master/misc/compile_time_execution_problems.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n| Type      | Safe?                                                                  |\n|-----------|------------------------------------------------------------------------|\n| boolean   | Y                                                                      |\n| integer   | Y                                                                      |\n| float     | Y                                                                      |\n| pointer   | N - Maybe safe if never changed                                        |\n| string    | Y - Even though (ptr+int) interally, still safe to convert to constant |\n| any       | N - (ptr+ptr)                                                          |\n| array     | D                                                                      |\n| vector    | Y - Elements can only be boolean, integer, or float (thus safe)        |\n| slice     | N - Internally (ptr+int+int)                                           |\n| maybe     | D                                                                      |\n| struct    | D                                                                      |\n| enum      | Y                                                                      |\n| union     | N - (blob+int)                                                         |\n| raw_union | N - ^^^                                                                |\n| tuple     | D                                                                      |\n| proc      | ? - Need to solve the next problem                                     |\n```\n\n----------------------------------------\n\nTITLE: Example of Cyclic Type Definition in Odin\nDESCRIPTION: A code example demonstrating the problematic cyclic type definition pattern that should be made illegal in the Odin language checker. It shows two struct types that reference each other in a circular manner.\nSOURCE: https://github.com/odin-lang/odin.git/blob/master/misc/todo.md#2025-04-21_snippet_0\n\nLANGUAGE: odin\nCODE:\n```\ntype A: struct { b: B; }; type B: struct { a: A; };\n```\n\n----------------------------------------\n\nTITLE: Clang WASM Compilation Command\nDESCRIPTION: Command to compile C code to WebAssembly object files using clang with the custom libc implementation. The command specifies the WASM32 target and sets the sysroot to the vendor/libc directory in the Odin root.\nSOURCE: https://github.com/odin-lang/odin.git/blob/master/vendor/libc/README.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nclang -c --target=wasm32 --sysroot=$(odin root)/vendor/libc\n```\n\n----------------------------------------\n\nTITLE: Running the feature generation Python script\nDESCRIPTION: Command to execute the Python script that processes LLVM feature information and outputs the required data structures for the Odin compiler.\nSOURCE: https://github.com/odin-lang/odin.git/blob/master/misc/featuregen/README.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npython3 featuregen.py\n```\n\n----------------------------------------\n\nTITLE: Building the feature generation tool\nDESCRIPTION: A bash command to compile the C++ component of the feature generation toolchain. This must be run before executing the Python script.\nSOURCE: https://github.com/odin-lang/odin.git/blob/master/misc/featuregen/README.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./build_featuregen.sh\n```\n\n----------------------------------------\n\nTITLE: Linking LLVM Libraries for X86 Architecture in Batch\nDESCRIPTION: This snippet lists the LLVM libraries required for a project targeting X86 architecture. It includes libraries for disassembly, code generation, optimization, and core LLVM functionalities. Each library is specified with the '.lib' extension, indicating they are static libraries for Windows.\nSOURCE: https://github.com/odin-lang/odin.git/blob/master/misc/libs.txt#2025-04-21_snippet_0\n\nLANGUAGE: Batch\nCODE:\n```\nLLVMX86Disassembler.lib ^\nLLVMX86AsmParser.lib ^\nLLVMX86CodeGen.lib ^\nLLVMSelectionDAG.lib ^\nLLVMAsmPrinter.lib ^\nLLVMCodeGen.lib ^\nLLVMTarget.lib ^\nLLVMScalarOpts.lib ^\nLLVMInstCombine.lib ^\nLLVMInstrumentation.lib ^\nLLVMProfileData.lib ^\nLLVMTransformUtils.lib ^\nLLVMBitWriter.lib ^\nLLVMAnalysis.lib ^\nLLVMX86Desc.lib ^\nLLVMObject.lib ^\nLLVMMCParser.lib ^\nLLVMBitReader.lib ^\nLLVMMCDisassembler.lib ^\nLLVMX86Info.lib ^\nLLVMX86AsmPrinter.lib ^\nLLVMMC.lib ^\nLLVMX86Utils.lib ^\nLLVMCore.lib ^\nLLVMSupport.lib ^\n\n```\n\n----------------------------------------\n\nTITLE: C Header Dependencies\nDESCRIPTION: Lists the C standard library headers required by the cgltf implementation.\nSOURCE: https://github.com/odin-lang/odin.git/blob/master/vendor/cgltf/README.md#2025-04-21_snippet_4\n\nLANGUAGE: c\nCODE:\n```\n#include <stddef.h>\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <limits.h>\n#include <assert.h> // If asserts are enabled.\n```\n\n----------------------------------------\n\nTITLE: Displaying Copyright Information for C Standard Library Support in Odin\nDESCRIPTION: This code snippet shows the copyright information for the C standard library support in Odin. It specifies that all files in the directory are made available under Odin's BSD-2 license.\nSOURCE: https://github.com/odin-lang/odin.git/blob/master/core/c/libc/README.md#2025-04-21_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nCopyright 2021 Dale Weiler <weilercdale@gmail.com>.\n```\n\n----------------------------------------\n\nTITLE: SDL_net License Header\nDESCRIPTION: Copyright notice and license terms for the SDL_net library defining usage permissions and restrictions.\nSOURCE: https://github.com/odin-lang/odin.git/blob/master/vendor/sdl2/net/COPYING.txt#2025-04-21_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n/*\n  SDL_net:  An example cross-platform network library for use with SDL\n  Copyright (C) 1997-2021 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n```\n\n----------------------------------------\n\nTITLE: Applying Apache License 2.0 Boilerplate Notice\nDESCRIPTION: This snippet provides a boilerplate notice for applying the Apache License 2.0 to a work. It includes placeholders for the copyright year and owner, and instructions for its usage.\nSOURCE: https://github.com/odin-lang/odin.git/blob/master/vendor/sdl3/image/LICENSE.avif.txt#2025-04-21_snippet_0\n\nLANGUAGE: Text\nCODE:\n```\n   Copyright [yyyy] [name of copyright owner]\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n```\n\n----------------------------------------\n\nTITLE: Building and Running Tests in LibTomMath\nDESCRIPTION: Commands for building and running the test suite for LibTomMath. Demonstrates how to execute the stand-alone test binary and how to run the mtest opponent test that verifies behavior against test vectors.\nSOURCE: https://github.com/odin-lang/odin.git/blob/master/src/libtommath/README.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./mtest/mtest | ./mtest_opponent\n```"
  }
]