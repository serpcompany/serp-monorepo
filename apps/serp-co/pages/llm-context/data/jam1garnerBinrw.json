[
  {
    "owner": "jam1garner",
    "repo": "binrw",
    "content": "TITLE: Defining and Reading a Binary Structure with binrw in Rust\nDESCRIPTION: This code snippet demonstrates how to use binrw to define a 'Dog' struct with binary reading capabilities. It includes magic number validation, count-based vector parsing, alignment, and null-terminated string handling. The example also shows how to read the binary data into the struct.\nSOURCE: https://github.com/jam1garner/binrw/blob/master/README.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(BinRead)]\n#[br(magic = b\"DOG\", assert(name.len() != 0))]\nstruct Dog {\n    bone_pile_count: u8,\n\n    #[br(big, count = bone_pile_count)]\n    bone_piles: Vec<u16>,\n\n    #[br(align_before = 0xA)]\n    name: NullString\n}\n\nlet mut reader = Cursor::new(b\"DOG\\x02\\x00\\x01\\x00\\x12\\0\\0Rudy\\0\");\nlet dog: Dog = reader.read_ne().unwrap();\nassert_eq!(dog.bone_piles, &[0x1, 0x12]);\nassert_eq!(dog.name.into_string(), \"Rudy\")\n```\n\n----------------------------------------\n\nTITLE: Composite Shape Enum with Binary Reading\nDESCRIPTION: Shows how to compose more complex types using binrw, implementing a Shape enum that can represent either rectangles or ovals with magic number validation.\nSOURCE: https://github.com/jam1garner/binrw/blob/master/binrw/doc/index.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n# use binrw::{binrw, BinRead, BinWrite, io::Cursor};\n# #[binrw]\n# #[derive(Debug, PartialEq)]\n# #[br(little)]\n# struct Point(i16, i16);\n#\n# #[derive(Debug, PartialEq)]\n#[derive(BinRead)]\n#[br(big, magic = b\"SHAP\")]\nenum Shape {\n    #[br(magic(0u8))] Rect {\n        left: i16, top: i16, right: i16, bottom: i16\n    },\n    #[br(magic(1u8))] Oval { origin: Point, rx: u8, ry: u8 }\n}\n\nlet oval = Shape::read(&mut Cursor::new(b\"SHAP\\x01\\x80\\x02\\xe0\\x01\\x2a\\x15\")).unwrap();\nassert_eq!(oval, Shape::Oval { origin: Point(640, 480), rx: 42, ry: 21 });\n```\n\n----------------------------------------\n\nTITLE: Complex Structure with Binary Directives\nDESCRIPTION: Shows advanced usage of binrw directives including magic numbers, alignment, assertions, and dynamic sizing for complex data structures.\nSOURCE: https://github.com/jam1garner/binrw/blob/master/binrw/doc/index.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n# use binrw::{prelude::*, io::Cursor, NullString};\n#\n#[binrw]\n#[brw(big, magic = b\"DOG\", assert(name.len() != 0))]\nstruct Dog {\n    #[bw(try_calc(u8::try_from(bone_piles.len())))]\n    bone_pile_count: u8,\n\n    #[br(count = bone_pile_count)]\n    bone_piles: Vec<u16>,\n\n    #[br(align_before = 0xA)]\n    name: NullString\n}\n\nlet mut data = Cursor::new(b\"DOG\\x02\\x00\\x01\\x00\\x12\\0\\0Rudy\\0\");\nlet dog = Dog::read(&mut data).unwrap();\nassert_eq!(dog.bone_piles, &[0x1, 0x12]);\nassert_eq!(dog.name.to_string(), \"Rudy\")\n```\n\n----------------------------------------\n\nTITLE: Basic Point Structure with Binary Read/Write\nDESCRIPTION: Demonstrates basic usage of binrw for reading and writing a simple Point structure with x,y coordinates using little-endian encoding.\nSOURCE: https://github.com/jam1garner/binrw/blob/master/binrw/doc/index.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse binrw::{\n    binrw,    // #[binrw] attribute\n    BinRead,  // trait for reading\n    BinWrite, // trait for writing\n};\n# use binrw::io::Cursor;\n\n#[binrw]\n# #[derive(Debug, PartialEq)]\n#[brw(little)]\nstruct Point(i16, i16);\n\n// Read a point from bytes\nlet point = Point::read(&mut Cursor::new(b\"\\x80\\x02\\xe0\\x01\")).unwrap();\nassert_eq!(point, Point(640, 480));\n\n// Write the point back to bytes\nlet mut writer = Cursor::new(Vec::new());\npoint.write(&mut writer).unwrap();\nassert_eq!(writer.into_inner(), b\"\\x80\\x02\\xe0\\x01\");\n```\n\n----------------------------------------\n\nTITLE: Defining a Struct with BinRW Attributes in Rust\nDESCRIPTION: This snippet demonstrates how to define a struct using BinRW attributes for big-endian parsing, temporary fields, and dynamic array sizing. It also includes an assertion to test the parsing.\nSOURCE: https://github.com/jam1garner/binrw/blob/master/binrw/doc/attribute.md#2025-04-21_snippet_39\n\nLANGUAGE: rust\nCODE:\n```\n#[br(big)]\nstruct Test {\n    // Since `Vec` stores its own length, this field is redundant\n    #[br(temp)]\n    len: u32,\n\n    #[br(count = len)]\n    data: Vec<u8>\n}\n\nassert_eq!(\n    Test::read(&mut Cursor::new(b\"\\0\\0\\0\\x05ABCDE\")).unwrap(),\n    Test { data: b\"ABCDE\".to_vec() }\n);\n```\n\n----------------------------------------\n\nTITLE: Defining Packed Binary Data Structure in Rust\nDESCRIPTION: Defines a packed binary data structure using modular_bitfield and binrw, with assertions for validation. Includes bitfield definitions for status flags and reading binary data.\nSOURCE: https://github.com/jam1garner/binrw/blob/master/binrw/doc/attribute.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nuse binrw::{prelude::*, io::Cursor};\nuse modular_bitfield::prelude::*;\n\n#[bitfield]\n#[derive(BinRead)]\n#[br(assert(self.is_fast()), map = Self::from_bytes)]\npub struct PackedData {\n    status: B4,\n    is_fast: bool,\n    is_static: bool,\n    is_alive: bool,\n    is_good: bool,\n}\n\nlet data = Cursor::new(b\"\\x53\").read_le::<PackedData>().unwrap();\n```\n\n----------------------------------------\n\nTITLE: Writing a Checksum with Stream Manipulation in BinWrite\nDESCRIPTION: An example showing how to use map_stream to implement checksum calculation when writing binary data using a custom Checksum wrapper.\nSOURCE: https://github.com/jam1garner/binrw/blob/master/binrw/doc/attribute.md#2025-04-21_snippet_37\n\nLANGUAGE: rust\nCODE:\n```\nuse core::num::Wrapping;\nuse binrw::{binwrite, BinWrite, io::{Cursor, Write, Seek, SeekFrom}};\nstruct Checksum<T> {\n    inner: T,\n    check: Wrapping<u8>,\n}\n\nimpl<T> Checksum<T> {\n   fn new(inner: T) -> Self {\n        Self {\n            inner,\n            check: Wrapping(0),\n        }\n   }\n\n   fn check(&self) -> u8 {\n       self.check.0\n   }\n}\n\nimpl<T: Write> Write for Checksum<T> {\n    fn write(&mut self, buf: &[u8]) -> binrw::io::Result<usize> {\n        for b in buf {\n            self.check += b;\n        }\n        self.inner.write(buf)\n    }\n\n    fn flush(&mut self) -> binrw::io::Result<()> {\n        self.inner.flush()\n    }\n}\n\nimpl<T: Seek> Seek for Checksum<T> {\n    fn seek(&mut self, pos: SeekFrom) -> binrw::io::Result<u64> {\n        self.inner.seek(pos)\n    }\n}\n\n#[binwrite]\n#[bw(little, stream = w, map_stream = Checksum::new)]\nstruct Test {\n    a: u16,\n    b: u16,\n    #[bw(calc(w.check()))]\n    c: u8,\n}\n\nlet mut out = Cursor::new(Vec::new());\nTest { a: 0x201, b: 0x403 }.write(&mut out).unwrap();\n\nassert_eq!(out.into_inner(), b\"\\x01\\x02\\x03\\x04\\x0a\");\n```\n\n----------------------------------------\n\nTITLE: Stream Reading and Writing Extensions\nDESCRIPTION: Demonstrates usage of BinReaderExt and BinWriterExt traits for convenient reading and writing of binary data directly on stream objects.\nSOURCE: https://github.com/jam1garner/binrw/blob/master/binrw/doc/index.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse binrw::{BinReaderExt, BinWriterExt};\n# use binrw::io::Cursor;\n\nlet mut stream = Cursor::new(b\"\\x00\\x0a\".to_vec());\nlet val: u16 = stream.read_be().unwrap();\nassert_eq!(val, 0xa);\n\nlet val = val + 0x10;\nstream.write_be(&val).unwrap();\nassert_eq!(stream.into_inner(), b\"\\x00\\x0a\\x00\\x1a\");\n```\n\n----------------------------------------\n\nTITLE: Reading Encrypted Blocks with Stream Manipulation in BinRead\nDESCRIPTION: An example demonstrating how to use map_stream with a custom decryption wrapper to read encrypted binary data.\nSOURCE: https://github.com/jam1garner/binrw/blob/master/binrw/doc/attribute.md#2025-04-21_snippet_36\n\nLANGUAGE: rust\nCODE:\n```\nuse binrw::{binread, BinRead, io::{Cursor, Read, Seek, SeekFrom}, helpers::until_eof};\n\nstruct BadCrypt<T> {\n    inner: T,\n    key: u8,\n}\n\nimpl<T> BadCrypt<T> {\n    fn new(inner: T, key: u8) -> Self {\n        Self { inner, key }\n    }\n}\n\nimpl<T: Read> Read for BadCrypt<T> {\n    fn read(&mut self, buf: &mut [u8]) -> binrw::io::Result<usize> {\n        let size = self.inner.read(buf)?;\n        for b in &mut buf[0..size] {\n            *b ^= core::mem::replace(&mut self.key, *b);\n        }\n        Ok(size)\n    }\n}\n\nimpl<T: Seek> Seek for Checksum<T> {\n    fn seek(&mut self, pos: SeekFrom) -> binrw::io::Result<u64> {\n        self.inner.seek(pos)\n    }\n}\n\n#[binread]\n#[derive(Debug, PartialEq)]\n#[br(little)]\nstruct Test {\n    iv: u8,\n    #[br(parse_with = until_eof, map_stream = |reader| BadCrypt::new(reader, iv))]\n    data: Vec<u8>,\n}\n\nassert_eq!(\n    Test::read(&mut Cursor::new(b\"\\x01\\x03\\0\\x04\\x01\")).unwrap(),\n    Test {\n        iv: 1,\n        data: vec![2, 3, 4, 5],\n    }\n);\n```\n\n----------------------------------------\n\nTITLE: Writing Encrypted Blocks with Stream Manipulation in BinWrite\nDESCRIPTION: An example demonstrating how to use map_stream with a custom encryption wrapper to write encrypted binary data.\nSOURCE: https://github.com/jam1garner/binrw/blob/master/binrw/doc/attribute.md#2025-04-21_snippet_38\n\nLANGUAGE: rust\nCODE:\n```\nuse binrw::{binwrite, BinWrite, io::{Cursor, Write, Seek, SeekFrom}};\n\nstruct BadCrypt<T> {\n    inner: T,\n    key: u8,\n}\n\nimpl<T> BadCrypt<T> {\n    fn new(inner: T, key: u8) -> Self {\n        Self { inner, key }\n    }\n}\n\nimpl<T: Write> Write for BadCrypt<T> {\n    fn write(&mut self, buf: &[u8]) -> binrw::io::Result<usize> {\n        let mut w = 0;\n        for b in buf {\n            self.key ^= b;\n            w += self.inner.write(&[self.key])?;\n        }\n        Ok(w)\n    }\n\n    fn flush(&mut self) -> binrw::io::Result<()> {\n        self.inner.flush()\n    }\n}\n\nimpl<T: Seek> Seek for BadCrypt<T> {\n    fn seek(&mut self, pos: SeekFrom) -> binrw::io::Result<u64> {\n        self.inner.seek(pos)\n    }\n}\n\n#[binwrite]\n#[derive(Debug, PartialEq)]\n#[bw(little)]\nstruct Test {\n    iv: u8,\n    #[bw(map_stream = |writer| BadCrypt::new(writer, *iv))]\n    data: Vec<u8>,\n}\n\nlet mut out = Cursor::new(Vec::new());\nTest { iv: 1, data: vec![2, 3, 4, 5] }.write(&mut out).unwrap();\nassert_eq!(out.into_inner(), b\"\\x01\\x03\\0\\x04\\x01\");\n```\n\n----------------------------------------\n\nTITLE: Verifying a Checksum with Stream Manipulation in BinRead\nDESCRIPTION: An example showing how to use map_stream to implement checksum verification when reading binary data using a custom Checksum wrapper.\nSOURCE: https://github.com/jam1garner/binrw/blob/master/binrw/doc/attribute.md#2025-04-21_snippet_35\n\nLANGUAGE: rust\nCODE:\n```\nuse core::num::Wrapping;\nuse binrw::{binread, BinRead, io::{Cursor, Read, Seek, SeekFrom}};\n\nstruct Checksum<T> {\n    inner: T,\n    check: Wrapping<u8>,\n}\n\nimpl<T> Checksum<T> {\n   fn new(inner: T) -> Self {\n        Self {\n            inner,\n            check: Wrapping(0),\n        }\n   }\n\n   fn check(&self) -> u8 {\n       self.check.0\n   }\n}\n\nimpl<T: Read> Read for Checksum<T> {\n    fn read(&mut self, buf: &mut [u8]) -> binrw::io::Result<usize> {\n        let size = self.inner.read(buf)?;\n        for b in &buf[0..size] {\n            self.check += b;\n        }\n        Ok(size)\n    }\n}\n\nimpl<T: Seek> Seek for Checksum<T> {\n    fn seek(&mut self, pos: SeekFrom) -> binrw::io::Result<u64> {\n        self.inner.seek(pos)\n    }\n}\n\n#[binread]\n#[derive(Debug, PartialEq)]\n#[br(little, stream = r, map_stream = Checksum::new)]\nstruct Test {\n    a: u16,\n    b: u16,\n    #[br(temp, assert(c == r.check() - c, \"bad checksum: {:#x?} != {:#x?}\", c, r.check() - c))]\n    c: u8,\n}\n\nassert_eq!(\n    Test::read(&mut Cursor::new(b\"\\x01\\x02\\x03\\x04\\x0a\")).unwrap(),\n    Test {\n        a: 0x201,\n        b: 0x403,\n    }\n);\n```\n\n----------------------------------------\n\nTITLE: Using restore_position and seek_before in BinWrite for Relocations\nDESCRIPTION: A more complex example using binrw to implement an executable format with relocations, demonstrating position management with restore_position and seek_before.\nSOURCE: https://github.com/jam1garner/binrw/blob/master/binrw/doc/attribute.md#2025-04-21_snippet_34\n\nLANGUAGE: rust\nCODE:\n```\nuse binrw::{prelude::*, io::{Cursor, SeekFrom}};\n#[derive(BinWrite)]\n#[derive(Debug, PartialEq)]\n#[bw(big)]\nstruct Relocation {\n    #[bw(ignore)]\n    delta: u32,\n    #[bw(seek_before(SeekFrom::Current((*delta).into())))]\n    reloc: u32,\n}\n\n#[derive(BinWrite)]\n#[derive(Debug, PartialEq)]\n#[bw(big)]\nstruct Executable {\n    #[bw(restore_position)]\n    code: Vec<u8>,\n    relocations: Vec<Relocation>,\n}\n\nlet object = Executable {\n    code: vec![ 1, 2, 3, 4, 0, 0, 0, 0, 9, 10, 0, 0, 0, 0 ],\n    relocations: vec![\n        Relocation { delta: 4, reloc: 84281096 },\n        Relocation { delta: 2, reloc: 185339150 },\n    ]\n};\nlet mut output = Cursor::new(vec![]);\nobject.write(&mut output).unwrap();\nassert_eq!(\n  output.into_inner(),\n  b\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\"\n);\n```\n\n----------------------------------------\n\nTITLE: Writing Packed Binary Data with binrw and modular_bitfield in Rust\nDESCRIPTION: This snippet defines a PackedData struct using modular_bitfield to represent a packed byte. It then uses binrw to write the packed data to a byte stream and assert the written value.\nSOURCE: https://github.com/jam1garner/binrw/blob/master/binrw/doc/attribute.md#2025-04-21_snippet_31\n\nLANGUAGE: Rust\nCODE:\n```\nuse binrw::{prelude::*, io::Cursor};\nuse modular_bitfield::prelude::*;\n\n#[bitfield]\n#[derive(BinWrite, Clone, Copy)]\n#[bw(map = |&x| Self::into_bytes(x))]\npub struct PackedData {\n    status: B4,\n    is_fast: bool,\n    is_static: bool,\n    is_alive: bool,\n    is_good: bool,\n}\n\nlet object = PackedData::new()\n    .with_is_alive(true)\n    .with_is_fast(true)\n    .with_status(3);\nlet mut output = Cursor::new(vec![]);\noutput.write_le(&object).unwrap();\nassert_eq!(output.into_inner(), b\"\\x53\");\n```\n\n----------------------------------------\n\nTITLE: Reading Packed Binary Data with binrw and modular_bitfield in Rust\nDESCRIPTION: This snippet defines a PackedData struct using modular_bitfield to represent a packed byte. It then uses binrw to read the packed data from a byte stream and assert the parsed values.\nSOURCE: https://github.com/jam1garner/binrw/blob/master/binrw/doc/attribute.md#2025-04-21_snippet_30\n\nLANGUAGE: Rust\nCODE:\n```\nuse binrw::{prelude::*, io::Cursor};\nuse modular_bitfield::prelude::*;\n\n#[bitfield]\n#[derive(BinRead)]\n#[br(map = Self::from_bytes)]\npub struct PackedData {\n    status: B4,\n    is_fast: bool,\n    is_static: bool,\n    is_alive: bool,\n    is_good: bool,\n}\n\nlet data = Cursor::new(b\"\\x53\").read_le::<PackedData>().unwrap();\nassert_eq!(data.is_good(), false);\nassert_eq!(data.is_alive(), true);\nassert_eq!(data.is_static(), false);\nassert_eq!(data.is_fast(), true);\nassert_eq!(data.status(), 3);\n```\n\n----------------------------------------\n\nTITLE: Using magic Directive for Enum Variant Selection in BinRead\nDESCRIPTION: This example demonstrates how to use the magic directive to select enum variants based on magic numbers when reading binary data.\nSOURCE: https://github.com/jam1garner/binrw/blob/master/binrw/doc/attribute.md#2025-04-21_snippet_24\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(BinRead)]\n# #[derive(Debug, PartialEq)]\nenum Command {\n    #[br(magic = 0u8)] Nop,\n    #[br(magic = 1u8)] Jump { loc: u32 },\n    #[br(magic = 2u8)] Begin { var_count: u16, local_count: u16 }\n}\n\n# assert_eq!(\nCommand::read_le(&mut Cursor::new(b\"\\x01\\0\\0\\0\\0\"))\n# .unwrap(), Command::Jump { loc: 0 });\n```\n\n----------------------------------------\n\nTITLE: Using magic Directive for Enum Variant Selection in BinWrite\nDESCRIPTION: This example shows how to use the magic directive to write enum variants with appropriate magic numbers when writing binary data.\nSOURCE: https://github.com/jam1garner/binrw/blob/master/binrw/doc/attribute.md#2025-04-21_snippet_25\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(BinWrite)]\n# #[derive(Debug, PartialEq)]\nenum Command {\n    #[bw(magic = 0u8)] Nop,\n    #[bw(magic = 1u8)] Jump { loc: u32 },\n    #[bw(magic = 2u8)] Begin { var_count: u16, local_count: u16 }\n}\n\nlet object = Command::Jump { loc: 0 };\nlet mut output = Cursor::new(vec![]);\nobject.write_le(&mut output)\n# .unwrap();\n# assert_eq!(output.into_inner(), b\"\\x01\\0\\0\\0\\0\");\n```\n\n----------------------------------------\n\nTITLE: Custom Parser for HashMap Deserialization\nDESCRIPTION: Example of using a custom parser function to deserialize data into a HashMap. This demonstrates how to parse types that don't have a built-in BinRead implementation.\nSOURCE: https://github.com/jam1garner/binrw/blob/master/binrw/doc/attribute.md#2025-04-21_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\n# use binrw::{prelude::*, io::{prelude::*, Cursor}, Endian};\n# use std::collections::HashMap;\n#[binrw::parser(reader, endian)]\nfn custom_parser() -> BinResult<HashMap<u16, u16>> {\n    let mut map = HashMap::new();\n    map.insert(\n        <_>::read_options(reader, endian, ())?,\n        <_>::read_options(reader, endian, ())?,\n    );\n    Ok(map)\n}\n\n#[derive(BinRead)]\n#[br(big)]\nstruct MyType {\n    #[br(parse_with = custom_parser)]\n    offsets: HashMap<u16, u16>\n}\n\n# assert_eq!(Cursor::new(b\"\\0\\0\\0\\x01\").read_be::<MyType>().unwrap().offsets.get(&0), Some(&1));\n```\n\n----------------------------------------\n\nTITLE: Using FilePtr::parse for NullString Parsing\nDESCRIPTION: Example showing how to use FilePtr32::parse as a custom parser to read a NullString without storing the FilePtr itself. This demonstrates a common pattern for reading pointer-referenced data.\nSOURCE: https://github.com/jam1garner/binrw/blob/master/binrw/doc/attribute.md#2025-04-21_snippet_18\n\nLANGUAGE: rust\nCODE:\n```\n# use binrw::{prelude::*, io::Cursor, FilePtr32, NullString};\n#[derive(BinRead)]\nstruct MyType {\n    #[br(parse_with = FilePtr32::parse)]\n    some_string: NullString,\n}\n\n# let val: MyType = Cursor::new(b\"\\0\\0\\0\\x04Test\\0\").read_be().unwrap();\n# assert_eq!(val.some_string.to_string(), \"Test\");\n```\n\n----------------------------------------\n\nTITLE: Using the 'try' Directive for Optional Parsing in Rust\nDESCRIPTION: This example shows how to use the 'try' directive in BinRW to allow optional parsing of a field. If parsing fails, the field is set to its default value (None for Option<T>).\nSOURCE: https://github.com/jam1garner/binrw/blob/master/binrw/doc/attribute.md#2025-04-21_snippet_40\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(BinRead)]\nstruct MyType {\n    #[br(try)]\n    maybe_u32: Option<u32>\n}\n\nassert_eq!(Cursor::new(b\"\").read_be::<MyType>().unwrap().maybe_u32, None);\n```\n\n----------------------------------------\n\nTITLE: Custom Writer for BTreeMap Serialization\nDESCRIPTION: Example of using a custom writer function to serialize a BTreeMap. This demonstrates how to write types that don't have a built-in BinWrite implementation or when custom serialization is needed.\nSOURCE: https://github.com/jam1garner/binrw/blob/master/binrw/doc/attribute.md#2025-04-21_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\n# use binrw::{prelude::*, io::{prelude::*, Cursor}, Endian};\n# use std::collections::BTreeMap;\n#[binrw::writer(writer, endian)]\nfn custom_writer(\n    map: &BTreeMap<u16, u16>,\n) -> BinResult<()> {\n    for (key, val) in map.iter() {\n        key.write_options(writer, endian, ())?;\n        val.write_options(writer, endian, ())?;\n    }\n    Ok(())\n}\n\n#[derive(BinWrite)]\n#[bw(big)]\nstruct MyType {\n    #[bw(write_with = custom_writer)]\n    offsets: BTreeMap<u16, u16>\n}\n\nlet object = MyType {\n    offsets: BTreeMap::from([(0, 1), (2, 3)]),\n};\n\nlet mut output = Cursor::new(vec![]);\nobject.write(&mut output).unwrap();\nassert_eq!(output.into_inner(), b\"\\0\\0\\0\\x01\\0\\x02\\0\\x03\");\n```\n\n----------------------------------------\n\nTITLE: Using restore_position Attribute in BinRead for Position Management\nDESCRIPTION: A struct example using the restore_position attribute to read a value and then keep the original stream position for reading subsequent bytes.\nSOURCE: https://github.com/jam1garner/binrw/blob/master/binrw/doc/attribute.md#2025-04-21_snippet_32\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Debug, PartialEq)]\nstruct MyType {\n    #[br(restore_position)]\n    test: u32,\n    test_bytes: [u8; 4]\n}\n```\n\n----------------------------------------\n\nTITLE: Testing restore_position with Assertions in BinRead\nDESCRIPTION: An assertion example demonstrating how restore_position allows reading the same data twice - first as a u32 and then as raw bytes.\nSOURCE: https://github.com/jam1garner/binrw/blob/master/binrw/doc/attribute.md#2025-04-21_snippet_33\n\nLANGUAGE: rust\nCODE:\n```\nassert_eq!(\n  Cursor::new(b\"\\0\\0\\0\\x01\").read_be::<MyType>().unwrap(),\n  MyType { test: 1, test_bytes: [0,0,0,1]}\n);\n```\n\n----------------------------------------\n\nTITLE: Using Count Directive with Vec\nDESCRIPTION: Example of using the count directive to read a vector with a dynamic size specified by another field. The count directive is a shorthand for passing a count argument to Vector.\nSOURCE: https://github.com/jam1garner/binrw/blob/master/binrw/doc/attribute.md#2025-04-21_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\n# use binrw::{prelude::*, io::Cursor};\n#[derive(BinRead)]\nstruct Collection {\n    size: u32,\n    #[br(count = size)]\n    data: Vec<u8>,\n}\n\n# assert_eq!(\n#    Cursor::new(b\"\\0\\0\\0\\x04\\x01\\x02\\x03\\x04\").read_be::<Collection>().unwrap().data,\n#    &[1u8, 2, 3, 4]\n# );\n```\n\n----------------------------------------\n\nTITLE: Using Count with Vec of Parameterized Inner Types\nDESCRIPTION: Example showing how to use the count directive with a Vec containing parameterized inner types. This demonstrates passing arguments to the inner type while also specifying the vector's length.\nSOURCE: https://github.com/jam1garner/binrw/blob/master/binrw/doc/attribute.md#2025-04-21_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\n# use binrw::{prelude::*, io::Cursor};\n\n#[derive(BinRead)]\n# #[derive(Debug, PartialEq)]\n#[br(import(version: i16))]\nstruct Inner(#[br(if(version > 0))] u8);\n\n#[derive(BinRead)]\nstruct Collection {\n    version: i16,\n    size: u32,\n    #[br(count = size, args { inner: (version,) })]\n    data: Vec<Inner>,\n}\n\n# assert_eq!(\n#    Cursor::new(b\"\\0\\x01\\0\\0\\0\\x04\\x01\\x02\\x03\\x04\").read_be::<Collection>().unwrap().data,\n#    &[Inner(1), Inner(2), Inner(3), Inner(4)]\n# );\n```\n\n----------------------------------------\n\nTITLE: BinRW Assert Directive Examples\nDESCRIPTION: Shows how to use assertions for data validation with custom error handling and formatting.\nSOURCE: https://github.com/jam1garner/binrw/blob/master/binrw/doc/attribute.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n# use binrw::{prelude::*, io::Cursor};\\n#[derive(BinRead)]\\n# #[derive(Debug)]\\n#[br(assert(some_val > some_smaller_val, \"oops! {} <= {}\", some_val, some_smaller_val))]\\nstruct Test {\\n    some_val: u32,\\n    some_smaller_val: u32\\n}\\n\\nlet error = Cursor::new(b\"\\0\\0\\0\\x01\\0\\0\\0\\xFF\").read_be::<Test>();\\nassert!(error.is_err());\\nlet error = error.unwrap_err();\\nlet expected = \"oops! 1 <= 255\".to_string();\\nassert!(matches!(error, binrw::Error::AssertFail { message: expected, .. }));\n```\n\nLANGUAGE: rust\nCODE:\n```\n# use binrw::{prelude::*, io::Cursor};\\n#[derive(BinWrite)]\\n# #[derive(Debug)]\\n#[bw(assert(some_val > some_smaller_val, \"oops! {} <= {}\", some_val, some_smaller_val))]\\nstruct Test {\\n    some_val: u32,\\n    some_smaller_val: u32\\n}\\n\\nlet object = Test { some_val: 1, some_smaller_val: 255 };\\nlet error = object.write_le(&mut Cursor::new(vec![]));\\nassert!(error.is_err());\\nlet error = error.unwrap_err();\\nlet expected = \"oops! 1 <= 255\".to_string();\\nassert!(matches!(error, binrw::Error::AssertFail { message: expected, .. }));\n```\n\n----------------------------------------\n\nTITLE: Conditional Field Reading with if Directive\nDESCRIPTION: Example showing how to conditionally read an Option field based on a condition, without providing an alternate value. This demonstrates how Option fields can be read conditionally in BinRead.\nSOURCE: https://github.com/jam1garner/binrw/blob/master/binrw/doc/attribute.md#2025-04-21_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n# use binrw::{prelude::*, io::Cursor};\n#[derive(BinRead)]\nstruct MyType {\n    var: u32,\n\n    #[br(if(var == 1))]\n    original_byte: Option<u8>,\n\n    #[br(if(var != 1))]\n    other_byte: Option<u8>,\n}\n\n# assert_eq!(Cursor::new(b\"\\0\\0\\0\\x01\\x03\").read_be::<MyType>().unwrap().original_byte, Some(3));\n# assert_eq!(Cursor::new(b\"\\0\\0\\0\\x01\\x03\").read_be::<MyType>().unwrap().other_byte, None);\n```\n\n----------------------------------------\n\nTITLE: Conditional Field Reading with Alternate Values\nDESCRIPTION: Example showing how to conditionally read a scalar field with an explicit alternate value. If the condition fails, the alternate value will be used instead of reading from the input.\nSOURCE: https://github.com/jam1garner/binrw/blob/master/binrw/doc/attribute.md#2025-04-21_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\n# use binrw::{prelude::*, io::Cursor};\n#[derive(BinRead)]\nstruct MyType {\n    var: u32,\n\n    #[br(if(var == 1, 0))]\n    original_byte: u8,\n\n    #[br(if(var != 1, 42))]\n    other_byte: u8,\n}\n\n# assert_eq!(Cursor::new(b\"\\0\\0\\0\\x01\\x03\").read_be::<MyType>().unwrap().original_byte, 3);\n# assert_eq!(Cursor::new(b\"\\0\\0\\0\\x01\\x03\").read_be::<MyType>().unwrap().other_byte, 42);\n```\n\n----------------------------------------\n\nTITLE: Using Try_Calc for Calculated Values in BinWrite\nDESCRIPTION: Example of using the try_calc directive with BinWrite to calculate a field's value from another field during serialization, with error handling via the Try trait.\nSOURCE: https://github.com/jam1garner/binrw/blob/master/binrw/doc/attribute.md#2025-04-21_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n# use binrw::{prelude::*, io::Cursor};\n#[binwrite] // ← must be before other attributes that use struct fields\n#[bw(big)]\nstruct MyType {\n    var: u32,\n    #[bw(try_calc = u16::try_from(var - 3))]\n    var_minus_3: u16,\n}\n\nlet object = MyType { var: 4 };\n\nlet mut output = Cursor::new(vec![]);\nobject.write(&mut output).unwrap();\nassert_eq!(output.into_inner(), b\"\\0\\0\\0\\x04\\0\\x01\");\n```\n\n----------------------------------------\n\nTITLE: BinRW Struct and Enum Examples\nDESCRIPTION: Example code demonstrating the usage and placement of binrw attributes in different Rust struct and enum contexts.\nSOURCE: https://github.com/jam1garner/binrw/blob/master/binrw/doc/attribute.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n#[brw(…)]               // ← struct\nstruct NamedStruct {\n    #[brw(…)]           // ← field\n    field: Type\n}\n\n#[brw(…)]               // ← struct\nstruct TupleStruct(\n    #[brw(…)]           // ← field\n    Type,\n);\n\n#[brw(…)]               // ← struct\nstruct UnitStruct;\n\n#[brw(…)]               // ← non-unit enum\nenum NonUnitEnum {\n    #[brw(…)]           // ← data variant\n    StructDataVariant {\n        #[brw(…)]       // ← field\n        field: Type\n    },\n\n    #[brw(…)]           // ← data variant\n    TupleDataVariant(\n        #[brw(…)]       // ← field\n        Type\n    ),\n\n    #[brw(…)]           // ← unit variant\n    UnitVariant\n}\n\n#[brw(…)]               // ← unit-like enum\nenum UnitLikeEnum {\n    #[brw(…)]           // ← unit variant\n    UnitVariantA,\n    …\n    #[brw(…)]           // ← unit variant\n    UnitVariantN\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating return_all_errors Directive for Enum Parsing in Rust\nDESCRIPTION: This snippet shows how to use the return_all_errors directive to collect and return errors when parsing enum variants fails. It defines a Test enum with three variants and demonstrates error handling when no variants parse successfully.\nSOURCE: https://github.com/jam1garner/binrw/blob/master/binrw/doc/attribute.md#2025-04-21_snippet_20\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(BinRead)]\n# #[derive(Debug)]\n#[br(return_all_errors)]\nenum Test {\n    #[br(magic(0u8))]\n    A { a: u8 },\n    B { b: u32 },\n    C { #[br(assert(c != 1))] c: u8 },\n}\n\nlet error = Test::read_le(&mut Cursor::new(b\"\\x01\")).unwrap_err();\nif let binrw::Error::EnumErrors { pos, variant_errors } = error {\n    assert_eq!(pos, 0);\n    assert!(matches!(variant_errors[0], (\"A\", binrw::Error::BadMagic { .. })));\n    assert!(matches!(\n        (variant_errors[1].0, variant_errors[1].1.root_cause()),\n        (\"B\", binrw::Error::Io(..))\n    ));\n    assert!(matches!(variant_errors[2], (\"C\", binrw::Error::AssertFail { .. })));\n}\n# else {\n#    panic!(\"wrong error type\");\n# }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating return_unexpected_error Directive for Enum Parsing in Rust\nDESCRIPTION: This snippet illustrates the use of the return_unexpected_error directive to return a generic NoVariantMatch error when all enum variants fail to parse. It avoids extra memory allocations but provides less detailed error information.\nSOURCE: https://github.com/jam1garner/binrw/blob/master/binrw/doc/attribute.md#2025-04-21_snippet_21\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(BinRead)]\n# #[derive(Debug)]\n#[br(return_unexpected_error)]\nenum Test {\n    #[br(magic(0u8))]\n    A { a: u8 },\n    B { b: u32 },\n    C { #[br(assert(c != 1))] c: u8 },\n}\n\nlet error = Test::read_le(&mut Cursor::new(b\"\\x01\")).unwrap_err();\nif let binrw::Error::NoVariantMatch { pos } = error {\n    assert_eq!(pos, 0);\n}\n# else {\n#    panic!(\"wrong error type\");\n# }\n```\n\n----------------------------------------\n\nTITLE: Error Handling Backtrace Example\nDESCRIPTION: Demonstrates error handling with backtraces using nested structs and custom error contexts.\nSOURCE: https://github.com/jam1garner/binrw/blob/master/binrw/doc/attribute.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(BinRead)]\nstruct InnerMostStruct {\n    #[br(little)]\n    len: u32,\n\n    #[br(count = len, err_context(\"len = {}\", len))]\n    items: Vec<u32>,\n}\n\n#[derive(BinRead)]\nstruct MiddleStruct {\n    #[br(little)]\n    #[br(err_context(\"While parsing the innerest most struct\"))]\n    inner: InnerMostStruct,\n}\n\n#[derive(Debug, Clone)]\nstruct Oops(u32);\n\n#[derive(BinRead)]\nstruct OutermostStruct {\n    #[br(little, err_context(Oops(3 + 1)))]\n    middle: MiddleStruct,\n}\n```\n\n----------------------------------------\n\nTITLE: Using map Directive on a Field for BinRead in Rust\nDESCRIPTION: This example demonstrates how to use the map directive to transform the read data from one type to another when implementing BinRead.\nSOURCE: https://github.com/jam1garner/binrw/blob/master/binrw/doc/attribute.md#2025-04-21_snippet_26\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(BinRead)]\nstruct MyType {\n    #[br(map = |x: u8| x.to_string())]\n    int_str: String\n}\n\n# assert_eq!(Cursor::new(b\"\\0\").read_be::<MyType>().unwrap().int_str, \"0\");\n```\n\n----------------------------------------\n\nTITLE: Using map Directive on a Field for BinWrite in Rust\nDESCRIPTION: This example shows how to use the map directive to transform the field value before writing when implementing BinWrite.\nSOURCE: https://github.com/jam1garner/binrw/blob/master/binrw/doc/attribute.md#2025-04-21_snippet_27\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(BinWrite)]\nstruct MyType {\n    #[bw(map = |x| x.parse::<u8>().unwrap())]\n    int_str: String\n}\n\nlet object = MyType { int_str: String::from(\"1\") };\nlet mut output = Cursor::new(vec![]);\nobject.write_le(&mut output).unwrap();\nassert_eq!(output.into_inner(), b\"\\x01\");\n```\n\n----------------------------------------\n\nTITLE: Using try_map Directive on a Field for BinRead in Rust\nDESCRIPTION: This example demonstrates how to use the try_map directive to attempt a fallible transformation on the read data when implementing BinRead.\nSOURCE: https://github.com/jam1garner/binrw/blob/master/binrw/doc/attribute.md#2025-04-21_snippet_28\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(BinRead)]\nstruct MyType {\n    #[br(try_map = |x: i8| x.try_into())]\n    value: u8\n}\n\n# assert_eq!(Cursor::new(b\"\\0\").read_be::<MyType>().unwrap().value, 0);\n# assert!(Cursor::new(b\"\\xff\").read_be::<MyType>().is_err());\n```\n\n----------------------------------------\n\nTITLE: Using try_map Directive on a Field for BinWrite in Rust\nDESCRIPTION: This example shows how to use the try_map directive to attempt a fallible transformation on the field value before writing when implementing BinWrite.\nSOURCE: https://github.com/jam1garner/binrw/blob/master/binrw/doc/attribute.md#2025-04-21_snippet_29\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(BinWrite)]\nstruct MyType {\n    #[bw(try_map = |x| { i8::try_from(*x) })]\n    value: u8\n}\n\nlet mut writer = Cursor::new(Vec::new());\nwriter.write_be(&MyType { value: 3 });\nassert_eq!(writer.into_inner(), b\"\\x03\")\n```\n\n----------------------------------------\n\nTITLE: Conditional Field Writing without Alternate Values\nDESCRIPTION: Example of conditionally writing a scalar field with no alternate value. If the condition evaluates to false, the field won't be written at all.\nSOURCE: https://github.com/jam1garner/binrw/blob/master/binrw/doc/attribute.md#2025-04-21_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\n# use binrw::{prelude::*, io::Cursor};\n#[derive(BinWrite)]\nstruct Test {\n    x: u8,\n    #[bw(if(*x > 1))]\n    y: u8,\n}\n\nlet mut output = Cursor::new(vec![]);\noutput.write_be(&Test { x: 1, y: 3 }).unwrap();\nassert_eq!(output.into_inner(), b\"\\x01\");\n\nlet mut output = Cursor::new(vec![]);\noutput.write_be(&Test { x: 2, y: 3 }).unwrap();\nassert_eq!(output.into_inner(), b\"\\x02\\x03\");\n```\n\n----------------------------------------\n\nTITLE: Conditional Field Writing with Alternate Values\nDESCRIPTION: Example of conditionally writing a scalar field with an explicit alternate value. If the condition evaluates to false, the alternate value will be written instead.\nSOURCE: https://github.com/jam1garner/binrw/blob/master/binrw/doc/attribute.md#2025-04-21_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\n# use binrw::{prelude::*, io::Cursor};\n#[derive(BinWrite)]\nstruct Test {\n    x: u8,\n    #[bw(if(*x > 1, 0))]\n    y: u8,\n}\n\nlet mut output = Cursor::new(vec![]);\noutput.write_be(&Test { x: 1, y: 3 }).unwrap();\nassert_eq!(output.into_inner(), b\"\\x01\\0\");\n\nlet mut output = Cursor::new(vec![]);\noutput.write_be(&Test { x: 2, y: 3 }).unwrap();\nassert_eq!(output.into_inner(), b\"\\x02\\x03\");\n```\n\n----------------------------------------\n\nTITLE: Using ignore Directive for BinRead in Rust\nDESCRIPTION: This example demonstrates how to use the ignore directive (alias: default) in BinRead to set a field's value to its Default instead of reading from the input data.\nSOURCE: https://github.com/jam1garner/binrw/blob/master/binrw/doc/attribute.md#2025-04-21_snippet_22\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(BinRead)]\n# #[derive(Debug, PartialEq)]\nstruct Test {\n    #[br(ignore)]\n    path: Option<std::path::PathBuf>,\n}\n\nassert_eq!(\n    Test::read_le(&mut Cursor::new(b\"\")).unwrap(),\n    Test { path: None }\n);\n```\n\n----------------------------------------\n\nTITLE: Using ignore Directive for BinWrite in Rust\nDESCRIPTION: This example shows how to use the ignore directive in BinWrite to skip writing a specific field to the output.\nSOURCE: https://github.com/jam1garner/binrw/blob/master/binrw/doc/attribute.md#2025-04-21_snippet_23\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(BinWrite)]\nstruct Test {\n    a: u8,\n    #[bw(ignore)]\n    b: u8,\n    c: u8,\n}\n\nlet object = Test { a: 1, b: 2, c: 3 };\nlet mut output = Cursor::new(vec![]);\nobject.write_le(&mut output).unwrap();\nassert_eq!(\n    output.into_inner(),\n    b\"\\x01\\x03\"\n);\n```\n\n----------------------------------------\n\nTITLE: Using Debug Directive for Field Inspection\nDESCRIPTION: Example of using the dbg directive to print field values and offsets during parsing for debugging purposes. This shows how to inspect values during binary reading operations.\nSOURCE: https://github.com/jam1garner/binrw/blob/master/binrw/doc/attribute.md#2025-04-21_snippet_19\n\nLANGUAGE: rust\nCODE:\n```\n# #[cfg(not(feature = \"std\"))] fn main() {}\n# #[cfg(feature = \"std\")]\n# fn main() {\n# use binrw::{prelude::*, io::Cursor};\n#[derive(BinRead, Debug)]\n# #[derive(PartialEq)]\n#[br(little)]\nstruct Inner {\n    #[br(dbg)]\n    a: u32,\n    #[br(dbg)]\n    b: u32,\n}\n\n#[derive(BinRead, Debug)]\n# #[derive(PartialEq)]\n#[br(little)]\nstruct Test {\n    first: u16,\n    #[br(dbg)]\n    inner: Inner,\n}\n\n// prints:\n//\n// [file.rs:5 | offset 0x2] a = 0x10\n// [file.rs:7 | offset 0x6] b = 0x40302010\n// [file.rs:15 | offset 0x2] inner = Inner {\n//     a: 0x10,\n//     b: 0x40302010,\n// }\n# assert_eq!(\nTest::read(&mut Cursor::new(b\"\\x01\\0\\x10\\0\\0\\0\\x10\\x20\\x30\\x40\")).unwrap(),\n# Test { first: 1, inner: Inner { a: 0x10, b: 0x40302010 } }\n# );\n# }\n```\n\n----------------------------------------\n\nTITLE: BinRW Named Arguments Implementation\nDESCRIPTION: Demonstrates practical use of named arguments with optional values and field init shorthand.\nSOURCE: https://github.com/jam1garner/binrw/blob/master/binrw/doc/attribute.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n# use binrw::prelude::*;\\n#[derive(BinRead)]\\n#[br(import {\\n    count: u32,\\n    other: u16 = 0 // ← optional argument\\n})]\\nstruct Child {\\n    // ...\\n}\\n\\n#[derive(BinRead)]\\nstruct Parent {\\n    count: u32,\\n\\n    #[br(args {\\n        count, // ← field init shorthand\\n        other: 5\\n    })]\\n    test: Child,\\n\\n    #[br(args { count: 3 })]\\n    test2: Child,\\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\n# use binrw::prelude::*;\\n#[derive(BinWrite)]\\n#[bw(import {\\n    count: u32,\\n    other: u16 = 0 // ← optional argument\\n})]\\nstruct Child {\\n    // ...\\n}\\n\\n#[derive(BinWrite)]\\nstruct Parent {\\n    count: u32,\\n\\n    #[bw(args {\\n        count: *count,\\n        other: 5\\n    })]\\n    test: Child,\\n\\n    #[bw(args { count: 3 })]\\n    test2: Child,\\n}\n```\n\n----------------------------------------\n\nTITLE: BinRW Tuple-Style Arguments Example\nDESCRIPTION: Shows practical implementation of tuple-style arguments with Parent and Child structs using BinRead and BinWrite traits.\nSOURCE: https://github.com/jam1garner/binrw/blob/master/binrw/doc/attribute.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n# use binrw::prelude::*;\\n#[derive(BinRead)]\\n#[br(import(val1: u32, val2: &str))]\\nstruct Child {\\n    // ...\\n}\\n\\n#[derive(BinRead)]\\nstruct Parent {\\n    val: u32,\\n    #[br(args(val + 3, \"test\"))]\\n    test: Child\\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\n# use binrw::prelude::*;\\n#[derive(BinWrite)]\\n#[bw(import(val1: u32, val2: &str))]\\nstruct Child {\\n    // ...\\n}\\n\\n#[derive(BinWrite)]\\nstruct Parent {\\n    val: u32,\\n    #[bw(args(val + 3, \"test\"))]\\n    test: Child\\n}\n```\n\n----------------------------------------\n\nTITLE: BinRW Named Arguments Syntax\nDESCRIPTION: Shows the syntax for named arguments using curly brace notation with optional default values.\nSOURCE: https://github.com/jam1garner/binrw/blob/master/binrw/doc/attribute.md#2025-04-21_snippet_4\n\nLANGUAGE: text\nCODE:\n```\n#[br(import { $($ident:ident : $ty:ty $(= $default:expr)?),* $(,)? })]\\n#[br(args { $($name:ident $(: $value:expr)?),* $(,)? } )]\n```\n\nLANGUAGE: text\nCODE:\n```\n#[bw(import { $($ident:ident : $ty:ty $(= $default:expr)?),* $(,)? })]\\n#[bw(args { $($name:ident $(: $value:expr)?),* $(,)? } )]\n```\n\n----------------------------------------\n\nTITLE: BinRW Tuple-Style Argument Syntax\nDESCRIPTION: Demonstrates the syntax for tuple-style (ordered) arguments using br/bw import and args attributes.\nSOURCE: https://github.com/jam1garner/binrw/blob/master/binrw/doc/attribute.md#2025-04-21_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n#[br(import($($ident:ident : $ty:ty),* $(,)?))]\\n#[br(args($($value:expr),* $(,)?))]\n```\n\nLANGUAGE: text\nCODE:\n```\n#[bw(import($($ident:ident : $ty:ty),* $(,)?))]\\n#[bw(args($($value:expr),* $(,)?))]\n```\n\n----------------------------------------\n\nTITLE: Optimized Types for Block I/O in Rust\nDESCRIPTION: Lists the specific Rust types that BinRW optimizes for block I/O operations through fake specialization. Shows which types support optimized reading and writing operations.\nSOURCE: https://github.com/jam1garner/binrw/blob/master/binrw/doc/performance.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nVec<u8>            // Read + Write\nVec<i8>            // Read + Write\nVec<u16>           // Read only\nVec<i16>           // Read only\nVec<u32>           // Read only\nVec<i32>           // Read only\nVec<u64>           // Read only\nVec<i64>           // Read only\nVec<u128>          // Read only\nVec<i128>          // Read only\n[u8; N]            // Write only\nBox<[u8]>          // Write only\n```\n\n----------------------------------------\n\nTITLE: Directory Structure Reference for BinRW Implementation\nDESCRIPTION: Key file paths and modules where changes need to be made when implementing a new directive, including parser locations, code generation paths, and test directories.\nSOURCE: https://github.com/jam1garner/binrw/blob/master/binrw_derive/README.md#2025-04-21_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nbinrw::parser::keywords\nbinrw::parser::attrs\nbinrw::parser::meta_types\nbinrw::parser::types\nbinrw::parser::top_level_attrs\nbinrw::parser::field_level_attrs\nbinrw::codegen::read_options\nbinrw::codegen::write_options\nbinrw/tests\nbinrw/tests/ui\n```\n\n----------------------------------------\n\nTITLE: Running All Rust Tests\nDESCRIPTION: Command to run all tests in the Rust project using cargo\nSOURCE: https://github.com/jam1garner/binrw/blob/master/CONTRIBUTING.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncargo test\n```\n\n----------------------------------------\n\nTITLE: Running Clippy Linter\nDESCRIPTION: Command to run the Clippy linter on all targets without default features\nSOURCE: https://github.com/jam1garner/binrw/blob/master/CONTRIBUTING.md#2025-04-21_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ncargo clippy --all-targets --no-default-features\n```\n\n----------------------------------------\n\nTITLE: Running Code Formatting Check\nDESCRIPTION: Command to verify code formatting using rustfmt before committing changes\nSOURCE: https://github.com/jam1garner/binrw/blob/master/CONTRIBUTING.md#2025-04-21_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ncargo fmt -- --checK\n```\n\n----------------------------------------\n\nTITLE: Running Rust Documentation Tests\nDESCRIPTION: Command to execute documentation tests in the Rust project using cargo\nSOURCE: https://github.com/jam1garner/binrw/blob/master/CONTRIBUTING.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncargo test --doc\n```\n\n----------------------------------------\n\nTITLE: CSS Styling for Documentation Layout\nDESCRIPTION: CSS styles defining the layout and appearance of the documentation page, including flexbox containers and table displays.\nSOURCE: https://github.com/jam1garner/binrw/blob/master/binrw/doc/index.md#2025-04-21_snippet_0\n\nLANGUAGE: css\nCODE:\n```\n.intro { display: flex; flex-direction: column-reverse; }\n.ql { display: table; border-bottom: thin solid var(--color-border, #ddd); margin-bottom: .75em; padding-bottom: .75em; }\n.ql_h.ql_h.ql_h { border: initial; font: inherit; font-size: 1em; font-weight: bold; padding: 0 .75em 0 0; white-space: nowrap; width: 0; }\n.ql > * { display: table-row; }\n.ql > *     > * { display: table-cell; }\n.ql > * + * > *,\n.ql > * + * > .ql_h.ql_h { padding-top: .25em; }\n.ql p { display: inline; margin: 0 .75em 0 0; }\n.ql p:last-child { margin-right: 0; }\n.ql code { white-space: nowrap; }\n```\n\n----------------------------------------\n\nTITLE: CSS Styling for Read/Write Toggle Display\nDESCRIPTION: CSS styles for controlling the visibility and appearance of read/write directive documentation sections using radio button toggles.\nSOURCE: https://github.com/jam1garner/binrw/blob/master/binrw/doc/attribute.md#2025-04-21_snippet_0\n\nLANGUAGE: css\nCODE:\n```\n.show-rw {\n    background: var(--main-background-color, #fff);\n    border: thin solid #ddd;\n    box-shadow: -0.25rem 0.25rem 0 var(--main-background-color, #fff);\n    display: flex;\n    list-style: none;\n    margin: 0 0 -2.25rem auto;\n    gap: 0.5rem;\n    padding: 0.25rem 1rem 0.75rem;\n    position: sticky;\n    top: 2rem;\n    width: fit-content;\n    z-index: 1;\n}\n```"
  }
]