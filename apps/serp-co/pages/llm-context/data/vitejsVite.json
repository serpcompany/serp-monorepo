[
  {
    "owner": "vitejs",
    "repo": "vite",
    "content": "TITLE: Defining Default Vite npm Scripts in package.json\nDESCRIPTION: Shows the typical `scripts` object within a `package.json` file for a Vite project. It defines standard commands: `dev` to start the development server (aliased by `vite dev` or `vite serve`), `build` to create a production bundle, and `preview` to serve the production build locally for testing.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/index.md#2025-04-22_snippet_18\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"scripts\": {\n    \"dev\": \"vite\", // start dev server, aliases: `vite dev`, `vite serve`\n    \"build\": \"vite build\", // build for production\n    \"preview\": \"vite preview\" // locally preview production build\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting Vite Dev Server via CLI using Yarn\nDESCRIPTION: Starts the Vite development server by invoking the `vite` binary directly using Yarn. This assumes `vite` is installed as a dependency in the project.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/index.md#2025-04-22_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\n$ yarn vite\n```\n\n----------------------------------------\n\nTITLE: Consuming Named CSS Module Exports with camelCase in Vite (JavaScript)\nDESCRIPTION: This snippet illustrates how to use named imports from a CSS module file in Vite, utilizing camelCase export names when css.modules.localsConvention is set to 'camelCaseOnly'. This enables importing CSS classes as named exports corresponding to the camelized name. The input is the camelCase-named class, and the output is applying it to an element. Requires proper CSS module configuration in Vite config.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/features.md#2025-04-22_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nimport 'vite/client'\\n// ---cut---\\n// .apply-color -> applyColor\\nimport { applyColor } from './example.module.css'\\ndocument.getElementById('foo').className = applyColor\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Bare Module Import in JavaScript\nDESCRIPTION: This snippet shows a bare module import that Vite will detect and process. Vite pre-bundles dependencies and rewrites imports to valid URLs for proper browser importing.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/features.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { someMethod } from 'my-dep'\n```\n\n----------------------------------------\n\nTITLE: Creating Minimal index.html for Vite\nDESCRIPTION: A basic HTML structure containing a single paragraph element. This file serves as the minimal entry point (`index.html`) when manually setting up a Vite project. Vite treats this file as source code and serves it during development.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/index.md#2025-04-22_snippet_13\n\nLANGUAGE: html\nCODE:\n```\n<p>Hello Vite!</p>\n```\n\n----------------------------------------\n\nTITLE: Declaring Environment Variables using .env Files - ENV\nDESCRIPTION: Demonstrates how to declare environment variables in .env files for use in Vite projects. Only variables prefixed with `VITE_` are exposed to client code via `import.meta.env`. Other variables, such as database passwords, remain unavailable in browser-side code. These files require no dependencies and should follow the pattern shown for their respective environments. Input is key=value pairs; exposed output is limited to prefixed variables.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/env-and-mode.md#2025-04-22_snippet_0\n\nLANGUAGE: env\nCODE:\n```\nVITE_SOME_KEY=123\\nDB_PASSWORD=foobar\n```\n\n----------------------------------------\n\nTITLE: Defining Global Constants in Vite Configuration\nDESCRIPTION: Example of configuring global constant replacements in Vite using the define option. This shows how to define version strings and API URLs that will be statically replaced during build.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/config/shared-options.md#2025-04-22_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nexport default defineConfig({\n  define: {\n    __APP_VERSION__: JSON.stringify('v1.0.0'),\n    __API_URL__: 'window.__backend_api_url',\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Creating a Vite Project with Yarn\nDESCRIPTION: This snippet demonstrates how to scaffold a new Vite project using Yarn as the package manager. Follow the interactive setup prompts after executing the command.\nSOURCE: https://github.com/vitejs/vite/blob/main/packages/create-vite/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn create vite\n```\n\n----------------------------------------\n\nTITLE: Transforming Custom File Types Plugin\nDESCRIPTION: A simple example of a Vite plugin that transforms custom file types. It uses the transform hook to compile files with a specific extension to JavaScript.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-plugin.md#2025-04-22_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst fileRegex = /\\.(my-file-ext)$/\n\nexport default function myPlugin() {\n  return {\n    name: 'transform-file',\n\n    transform(src, id) {\n      if (fileRegex.test(id)) {\n        return {\n          code: compileFileToJS(src),\n          map: null, // provide source map if available\n        }\n      }\n    },\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Scaffolding Specific Vite Project Template using pnpm\nDESCRIPTION: Creates a new Vite project named 'my-vue-app' using the 'vue' template directly via command-line arguments with pnpm. Requires Node.js 18+/20+.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/index.md#2025-04-22_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ pnpm create vite my-vue-app --template vue\n```\n\n----------------------------------------\n\nTITLE: Custom Hot Module Replacement Handling in Vite with JavaScript\nDESCRIPTION: This code snippet shows how to implement custom HMR (Hot Module Replacement) handling using the `handleHotUpdate` hook within a Vite plugin. The hook allows filtering and modifying affected modules or performing a full reload by sending specific messages to the client. The provided code demonstrates both module invalidation and custom event handling strategies.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-plugin.md#2025-04-22_snippet_10\n\nLANGUAGE: TypeScript\nCODE:\n```\ninterface HmrContext {\n  file: string\n  timestamp: number\n  modules: Array<ModuleNode>\n  read: () => string | Promise<string>\n  server: ViteDevServer\n}\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\nhandleHotUpdate({ server, modules, timestamp }) {\n  // Invalidate modules manually\n  const invalidatedModules = new Set()\n  for (const mod of modules) {\n    server.moduleGraph.invalidateModule(\n      mod,\n      invalidatedModules,\n      timestamp,\n      true\n    )\n  }\n  server.ws.send({ type: 'full-reload' })\n  return []\n}\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\nhandleHotUpdate({ server }) {\n  server.ws.send({\n    type: 'custom',\n    event: 'special-update',\n    data: {}\n  })\n  return []\n}\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\nif (import.meta.hot) {\n  import.meta.hot.on('special-update', (data) => {\n    // perform custom update\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Vite with NPM\nDESCRIPTION: Command to scaffold a new Vite application using NPM.\nSOURCE: https://github.com/vitejs/vite/blob/main/packages/create-vite/CHANGELOG.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ npm init vite@latest\n```\n\n----------------------------------------\n\nTITLE: Configuring package.json for Vite Build and Preview Scripts\nDESCRIPTION: Basic package.json configuration with build and preview scripts for a Vite application. These scripts allow building the production version and previewing it locally.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/static-deploy.md#2025-04-22_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"scripts\": {\n    \"build\": \"vite build\",\n    \"preview\": \"vite preview\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Plugins in Vite\nDESCRIPTION: Example of how to configure plugins in a Vite project's configuration file. It demonstrates adding both Vite-specific and Rollup plugins.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-plugin.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport vitePlugin from 'vite-plugin-feature'\nimport rollupPlugin from 'rollup-plugin-feature'\n\nexport default defineConfig({\n  plugins: [vitePlugin(), rollupPlugin()],\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Application Entry HTML in Vite (HTML)\nDESCRIPTION: This HTML snippet illustrates a standard Vite entry HTML file, including favicon and stylesheet references in the <head> section, an image asset, and a module-based script import for the application entry. External assets referenced by src or href will be processed and bundled by Vite. Relevant dependencies include the referenced CSS and JavaScript files, as well as image assets. Inputs include typical HTML attributes for resource linking; output is a complete, Vite-compatible static HTML file. Ensure paths match your actual project structure.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/features.md#2025-04-22_snippet_3\n\nLANGUAGE: html\nCODE:\n```\n<!doctype html>\\n<html>\\n  <head>\\n    <link rel=\\\"icon\\\" href=\\\"/favicon.ico\\\" />\\n    <link rel=\\\"stylesheet\\\" href=\\\"/src/styles.css\\\" />\\n  </head>\\n  <body>\\n    <img src=\\\"/src/images/logo.svg\\\" alt=\\\"logo\\\" />\\n    <script type=\\\"module\\\" src=\\\"/src/main.js\\\"></script>\\n  </body>\\n</html>\n```\n\n----------------------------------------\n\nTITLE: Using Vite's Build Function in TypeScript\nDESCRIPTION: Shows how to use Vite's build function to create a production build. It includes configuration options such as setting the root directory, base URL, and Rollup options.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-javascript.md#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport path from 'node:path'\nimport { fileURLToPath } from 'node:url'\nimport { build } from 'vite'\n\nconst __dirname = fileURLToPath(new URL('.', import.meta.url))\n\nawait build({\n  root: path.resolve(__dirname, './project'),\n  base: '/foo/',\n  build: {\n    rollupOptions: {\n      // ...\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Importing Web Workers in Vite (JavaScript)\nDESCRIPTION: This JavaScript snippet demonstrates importing a JavaScript module as a Web Worker by appending ?worker to the import path. Vite bundles and returns the worker constructor. Input is the import with ?worker; output is a Worker instance ready for use. Requires Vite's built-in worker loader.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/features.md#2025-04-22_snippet_15\n\nLANGUAGE: javascript\nCODE:\n```\nimport 'vite/client'\\n// ---cut---\\n// Load Web Workers\\nimport Worker from './worker.js?worker'\n```\n\n----------------------------------------\n\nTITLE: Scaffolding Specific Vite Project Template using npm\nDESCRIPTION: Creates a new Vite project named 'my-vue-app' using the 'vue' template directly via command-line arguments with npm. The extra double-dash (`--`) is required for npm 7+ to pass arguments to the underlying `create-vite` script. Requires Node.js 18+/20+.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/index.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n# npm 7+, extra double-dash is needed:\n$ npm create vite@latest my-vue-app -- --template vue\n```\n\n----------------------------------------\n\nTITLE: Extending ImportMetaEnv Interface for IntelliSense - TypeScript Declaration\nDESCRIPTION: Augments the standard `ImportMetaEnv` interface in a custom declaration file (e.g., `vite-env.d.ts`) to enable TypeScript IntelliSense for user-defined `VITE_` env variables. Assumes placement within a module using Vite. No runtime output, but allows the developer to catch usage errors and gain type information. Includes instructions for making the environment shape strict.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/env-and-mode.md#2025-04-22_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n/// <reference types=\\\"vite/client\\\" />\\n\\ninterface ViteTypeOptions {\\n  // By adding this line, you can make the type of ImportMetaEnv strict\\n  // to disallow unknown keys.\\n  // strictImportMetaEnv: unknown\\n}\\n\\ninterface ImportMetaEnv {\\n  readonly VITE_APP_TITLE: string\\n  // more env variables...\\n}\\n\\ninterface ImportMeta {\\n  readonly env: ImportMetaEnv\\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Vite for Backend Integration\nDESCRIPTION: Sets up Vite configuration for backend integration, enabling CORS, build manifest, and custom entry point.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/backend-integration.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nexport default defineConfig({\n  server: {\n    cors: {\n      // the origin you will be accessing via browser\n      origin: 'http://my-backend.example.com',\n    },\n  },\n  build: {\n    // generate .vite/manifest.json in outDir\n    manifest: true,\n    rollupOptions: {\n      // overwrite default .html entry\n      input: '/path/to/main.js',\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Installing Project Dependencies with npm\nDESCRIPTION: This command installs all project dependencies using npm as the package manager. Alternatively, pnpm or yarn can be used. It is a prerequisite to ensure all necessary packages are available for development and production.\nSOURCE: https://github.com/vitejs/vite/blob/main/packages/create-vite/template-solid/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ npm install # or pnpm install or yarn install\n```\n\n----------------------------------------\n\nTITLE: Searching for Workspace Root in TypeScript\nDESCRIPTION: This function searches for the root of the potential workspace if it meets certain conditions. It checks for a 'workspaces' field in 'package.json' or the presence of 'lerna.json' or 'pnpm-workspace.yaml' files. If conditions are not met, it falls back to a specified root.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-javascript.md#2025-04-22_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction searchForWorkspaceRoot(\n  current: string,\n  root = searchForPackageRoot(current),\n): string\n```\n\n----------------------------------------\n\nTITLE: Configuring Vite Dev Server with Custom Middleware in JavaScript\nDESCRIPTION: This snippet outlines using the `configureServer` hook to add custom middleware to the Vite development server. It shows how to insert middleware to handle requests and store the server instance for use in other hooks. It also provides an example of injecting middleware after internal middlewares are installed by returning a closure. Vite's development server and relevant plugins are dependencies.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-plugin.md#2025-04-22_snippet_7\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst myPlugin = () => ({\n  name: 'configure-server',\n  configureServer(server) {\n    server.middlewares.use((req, res, next) => {\n      // custom handle request...\n    })\n  },\n})\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst myPlugin = () => ({\n  name: 'configure-server',\n  configureServer(server) {\n    // return a post hook that is called after internal middlewares are\n    // installed\n    return () => {\n      server.middlewares.use((req, res, next) => {\n        // custom handle request...\n      })\n    }\n  },\n})\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst myPlugin = () => {\n  let server\n  return {\n    name: 'configure-server',\n    configureServer(_server) {\n      server = _server\n    },\n    transform(code, id) {\n      if (server) {\n        // use server...\n      }\n    },\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Self-Accepting Module with HMR in JavaScript\nDESCRIPTION: This example shows how to create a self-accepting module using import.meta.hot.accept with a callback that receives the updated module.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-hmr.md#2025-04-22_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nexport const count = 1\n\nif (import.meta.hot) {\n  import.meta.hot.accept((newModule) => {\n    if (newModule) {\n      // newModule is undefined when SyntaxError happened\n      console.log('updated: count is now ', newModule.count)\n    }\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Vite Dev Server in TypeScript\nDESCRIPTION: Demonstrates how to create and start a Vite dev server using the createServer function. It includes configuration options and shows how to listen for connections and print server URLs.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-javascript.md#2025-04-22_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fileURLToPath } from 'node:url'\nimport { createServer } from 'vite'\n\nconst __dirname = fileURLToPath(new URL('.', import.meta.url))\n\nconst server = await createServer({\n  // any valid user config options, plus `mode` and `configFile`\n  configFile: false,\n  root: __dirname,\n  server: {\n    port: 1337,\n  },\n})\nawait server.listen()\n\nserver.printUrls()\nserver.bindCLIShortcuts({ print: true })\n```\n\n----------------------------------------\n\nTITLE: Importing JSON Files and Named Fields in Vite (JavaScript)\nDESCRIPTION: This snippet demonstrates how to import JSON files as modules in a Vite project, including importing the entire object or just named fields for tree-shaking efficiency. Inputs are .json files; outputs are JavaScript objects or destructured fields. No special Vite configuration is required beyond the default setup.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/features.md#2025-04-22_snippet_17\n\nLANGUAGE: javascript\nCODE:\n```\nimport 'vite/client'\\n// ---cut---\\n// import the entire object\\nimport json from './example.json'\\n// import a root field as named exports - helps with tree-shaking!\\nimport { field } from './example.json'\n```\n\n----------------------------------------\n\nTITLE: Building for Production with npm\nDESCRIPTION: This command builds the Vite application for production by generating optimized bundles in the `dist` directory. It ensures Solid components are minified and the build is optimized for performance, ready for deployment.\nSOURCE: https://github.com/vitejs/vite/blob/main/packages/create-vite/template-solid/README.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm run build\n```\n\n----------------------------------------\n\nTITLE: Implementing Server-to-Client Communication in Vite\nDESCRIPTION: Shows how to configure a plugin to send messages from server to client using WebSocket.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-plugin.md#2025-04-22_snippet_13\n\nLANGUAGE: javascript\nCODE:\n```\nexport default defineConfig({\n  plugins: [\n    {\n      // ...\n      configureServer(server) {\n        server.ws.on('connection', () => {\n          server.ws.send('my:greetings', { msg: 'hello' })\n        })\n      },\n    },\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Modifying npm Scripts for Vite SSR Development and Production Builds (Diff Format, JSON)\nDESCRIPTION: This 'diff' and JSON snippet illustrates changes to the npm scripts in `package.json` to support SSR development and build workflows with Vite. The change replaces the default 'vite' dev command with a Node script launch and demonstrates how to configure separate client and server builds including the use of the `--ssr` flag. Prerequisites: npm, Node.js, and Vite CLI.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/ssr.md#2025-04-22_snippet_4\n\nLANGUAGE: diff\nCODE:\n```\n\"scripts\": {\\n-   \\\"dev\\\": \\\"vite\\\"\\n+   \\\"dev\\\": \\\"node server\\\"\\n  }\n```\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \\\"scripts\\\": {\\n    \\\"dev\\\": \\\"node server\\\",\\n    \\\"build:client\\\": \\\"vite build --outDir dist/client\\\",\\n    \\\"build:server\\\": \\\"vite build --outDir dist/server --ssr src/entry-server.js\\\"\\n  }\\n}\n```\n\n----------------------------------------\n\nTITLE: Injecting JSX Helpers Automatically in Vite (JavaScript)\nDESCRIPTION: This snippet showcases how to inject JSX helpers (such as React imports) globally across all JSX files in a Vite project, by using the jsxInject property of esbuild configuration within vite.config.js. This avoids repetitive imports in each file. Input is the configuration object, where jsxInject is a string of code to inject; output is that the specified code is prepended to all transpiled files. Dependencies are Vite (with esbuild) and the imported package (e.g. React).\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/features.md#2025-04-22_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport { defineConfig } from 'vite'\\n\\nexport default defineConfig({\\n  esbuild: {\\n    jsxInject: `import React from 'react'`,\\n  },\\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring JSX Factory and Fragment in Vite with esbuild (JavaScript)\nDESCRIPTION: This JavaScript snippet demonstrates how to customize the JSX factory and fragment elements for a Vite project, using the esbuild configuration in vite.config.js. This is useful when integrating frameworks such as Preact that use custom JSX pragma. It relies on the Vite and esbuild libraries, and is intended for use in the project's Vite configuration file. Key parameters are jsxFactory and jsxFragment; input is the defineConfig function, and output is an exportable Vite config object. Requires the relevant framework and proper package setup.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/features.md#2025-04-22_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport { defineConfig } from 'vite'\\n\\nexport default defineConfig({\\n  esbuild: {\\n    jsxFactory: 'h',\\n    jsxFragment: 'Fragment',\\n  },\\n})\n```\n\n----------------------------------------\n\nTITLE: Scaffolding Vite Project using pnpm\nDESCRIPTION: Initializes a new Vite project interactively using pnpm's `create` command. It prompts the user for project name, framework selection, and variant (e.g., TypeScript). Requires Node.js 18+/20+.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/index.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ pnpm create vite\n```\n\n----------------------------------------\n\nTITLE: Importing Assets as Raw Strings in Vite (JavaScript)\nDESCRIPTION: This code example shows how to import an asset (such as a GLSL shader file) as a plain string by adding ?raw to the import path. This is helpful for assets that you want to process or parse as text at runtime. Input is the import with ?raw; output is a string variable containing the file contents. Depends on Vite asset loader configuration.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/features.md#2025-04-22_snippet_14\n\nLANGUAGE: javascript\nCODE:\n```\nimport 'vite/client'\\n// ---cut---\\n// Load assets as strings\\nimport assetAsString from './shader.glsl?raw'\n```\n\n----------------------------------------\n\nTITLE: Running Vite Preview Command in Bash\nDESCRIPTION: This snippet provides the command to locally preview the production build using Vite. The user can specify various options like hostname, port, output directory, and more. The command should not be used as a production server due to its limitations in production settings.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/cli.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nvite preview [root]\n```\n\n----------------------------------------\n\nTITLE: Vite Config Hook Plugin Example\nDESCRIPTION: Examples of plugins using the Vite-specific 'config' hook to modify the Vite configuration. It shows both returning a partial config and directly mutating the config object.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-plugin.md#2025-04-22_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n// return partial config (recommended)\nconst partialConfigPlugin = () => ({\n  name: 'return-partial',\n  config: () => ({\n    resolve: {\n      alias: {\n        foo: 'bar',\n      },\n    },\n  }),\n})\n\n// mutate the config directly (use only when merging doesn't work)\nconst mutateConfigPlugin = () => ({\n  name: 'mutate-config',\n  config(config, { command }) {\n    if (command === 'build') {\n      config.root = 'foo'\n    }\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Vite Library Mode for a Single Entry Point in JavaScript\nDESCRIPTION: Defines a Vite configuration (`vite.config.js`) for building a library with a single entry point (`lib/main.js`). It specifies the library name (`MyLib`), output filename (`my-lib`), and externalizes the 'vue' dependency using `rollupOptions`. It also configures global variables (`globals`) for the UMD build format to ensure external dependencies like Vue are correctly referenced.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/build.md#2025-04-22_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\n```js twoslash [vite.config.js (single entry)]\nimport { dirname, resolve } from 'node:path'\nimport { fileURLToPath } from 'node:url'\nimport { defineConfig } from 'vite'\n\nconst __dirname = dirname(fileURLToPath(import.meta.url))\n\nexport default defineConfig({\n  build: {\n    lib: {\n      entry: resolve(__dirname, 'lib/main.js'),\n      name: 'MyLib',\n      // the proper extensions will be added\n      fileName: 'my-lib',\n    },\n    rollupOptions: {\n      // make sure to externalize deps that shouldn't be bundled\n      // into your library\n      external: ['vue'],\n      output: {\n        // Provide global variables to use in the UMD build\n        // for externalized deps\n        globals: {\n          vue: 'Vue',\n        },\n      },\n    },\n  },\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a Framework Plugin Preset\nDESCRIPTION: Example of creating a plugin preset that combines multiple plugins for a framework integration. This allows users to add multiple related plugins as a single element in the configuration.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-plugin.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// framework-plugin\nimport frameworkRefresh from 'vite-plugin-framework-refresh'\nimport frameworkDevtools from 'vite-plugin-framework-devtools'\n\nexport default function framework(config) {\n  return [frameworkRefresh(config), frameworkDevTools(config)]\n}\n```\n\nLANGUAGE: javascript\nCODE:\n```\nimport { defineConfig } from 'vite'\nimport framework from 'vite-plugin-framework'\n\nexport default defineConfig({\n  plugins: [framework()],\n})\n```\n\n----------------------------------------\n\nTITLE: Conditionally Running SSR-Specific Logic in Vite (JavaScript)\nDESCRIPTION: This snippet shows how to use Vite's environment variables to execute code only during server-side rendering. By checking `import.meta.env.SSR`, you can isolate server-only logic, which allows build-time tree-shaking of unused branches. Prerequisite: the 'vite/client' type system must be imported for proper typing.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/ssr.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport 'vite/client'\\n// ---cut---\\nif (import.meta.env.SSR) {\\n  // ... server only logic\\n}\n```\n\n----------------------------------------\n\nTITLE: Defining HTML Entry-Point Structure for SSR with Vite (HTML)\nDESCRIPTION: This snippet demonstrates the structure of the HTML entry point (`index.html`) for a Vite-based SSR application. It shows how to provide a mounting point (with a customizable placeholder, i.e. `<!--ssr-outlet-->`) for server-rendered HTML and script inclusion for the client-side entry. Required as the top-level template, this file must reference the correct entry point and serve as the main target for server-side content injection.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/ssr.md#2025-04-22_snippet_0\n\nLANGUAGE: html\nCODE:\n```\n<div id=\\\"app\\\"><!--ssr-outlet--></div>\\n<script type=\\\"module\\\" src=\\\"/src/entry-client.js\\\"></script>\n```\n\n----------------------------------------\n\nTITLE: Vite Config using defineConfig Helper\nDESCRIPTION: Using the defineConfig helper function to provide intellisense without JSDoc annotations in JavaScript.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/config/index.md#2025-04-22_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  // ...\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing SSR with RunnableDevEnvironment in JavaScript\nDESCRIPTION: Demonstrates a complete SSR implementation using Vite's Environment API in middleware mode, including HTML template handling and server-side rendering.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-environment-frameworks.md#2025-04-22_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport fs from 'node:fs'\nimport path from 'node:path'\nimport { fileURLToPath } from 'node:url'\nimport { createServer } from 'vite'\n\nconst __dirname = path.dirname(fileURLToPath(import.meta.url))\n\nconst server = await createServer({\n  server: { middlewareMode: true },\n  appType: 'custom',\n  environments: {\n    server: {\n      // by default, modules are run in the same process as the vite server\n    },\n  },\n})\n\n// You might need to cast this to RunnableDevEnvironment in TypeScript or\n// use isRunnableDevEnvironment to guard the access to the runner\nconst environment = server.environments.node\n\napp.use('*', async (req, res, next) => {\n  const url = req.originalUrl\n\n  // 1. Read index.html\n  const indexHtmlPath = path.resolve(__dirname, 'index.html')\n  let template = fs.readFileSync(indexHtmlPath, 'utf-8')\n\n  // 2. Apply Vite HTML transforms. This injects the Vite HMR client,\n  //    and also applies HTML transforms from Vite plugins, e.g. global\n  //    preambles from @vitejs/plugin-react\n  template = await server.transformIndexHtml(url, template)\n\n  // 3. Load the server entry. import(url) automatically transforms\n  //    ESM source code to be usable in Node.js! There is no bundling\n  //    required, and provides full HMR support.\n  const { render } = await environment.runner.import('/src/entry-server.js')\n\n  // 4. render the app HTML. This assumes entry-server.js's exported\n  //     `render` function calls appropriate framework SSR APIs,\n  //    e.g. ReactDOMServer.renderToString()\n  const appHtml = await render(url)\n\n  // 5. Inject the app-rendered HTML into the template.\n  const html = template.replace(`<!--ssr-outlet-->`, appHtml)\n\n  // 6. Send the rendered HTML back.\n  res.status(200).set({ 'Content-Type': 'text/html' }).end(html)\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Multi-Page Applications in Vite\nDESCRIPTION: Shows how to set up multiple HTML entry points for a multi-page application in Vite. This configuration uses Node.js path utilities to resolve file paths and specifies multiple HTML files as entry points for the build process.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/build.md#2025-04-22_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { dirname, resolve } from 'node:path'\nimport { fileURLToPath } from 'node:url'\nimport { defineConfig } from 'vite'\n\nconst __dirname = dirname(fileURLToPath(import.meta.url))\n\nexport default defineConfig({\n  build: {\n    rollupOptions: {\n      input: {\n        main: resolve(__dirname, 'index.html'),\n        nested: resolve(__dirname, 'nested/index.html'),\n      },\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Loading Vite Configuration from a File in TypeScript\nDESCRIPTION: Manually loads a Vite configuration file using esbuild. It processes configuration details, allowing direct manipulation or inspection by developers.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-javascript.md#2025-04-22_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nasync function loadConfigFromFile(\n  configEnv: ConfigEnv,\n  configFile?: string,\n  configRoot: string = process.cwd(),\n  logLevel?: LogLevel,\n  customLogger?: Logger,\n): Promise<{\n  path: string\n  config: UserConfig\n  dependencies: string[]\n} | null>\n```\n\n----------------------------------------\n\nTITLE: Initializing Express Dev Server in Middleware Mode with Vite (JavaScript)\nDESCRIPTION: This JavaScript snippet demonstrates the initialization of an Express development server using Vite in middleware mode for SSR. It sets up middleware configuration by disabling Vite's native HTML handling (`appType: 'custom'`) and attaching Vite's middleware stack to the Express app. The snippet also sets up a wildcard route and starts listening on port 5173. Dependencies: 'express', 'vite', Node.js built-in modules ('fs', 'path', 'url').\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/ssr.md#2025-04-22_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport fs from 'node:fs'\\nimport path from 'node:path'\\nimport { fileURLToPath } from 'node:url'\\nimport express from 'express'\\nimport { createServer as createViteServer } from 'vite'\\n\\nconst __dirname = path.dirname(fileURLToPath(import.meta.url))\\n\\nasync function createServer() {\\n  const app = express()\\n\\n  // Create Vite server in middleware mode and configure the app type as\\n  // 'custom', disabling Vite's own HTML serving logic so parent server\\n  // can take control\\n  const vite = await createViteServer({\\n    server: { middlewareMode: true },\\n    appType: 'custom'\\n  })\\n\\n  // Use vite's connect instance as middleware. If you use your own\\n  // express router (express.Router()), you should use router.use\\n  // When the server restarts (for example after the user modifies\\n  // vite.config.js), `vite.middlewares` is still going to be the same\\n  // reference (with a new internal stack of Vite and plugin-injected\\n  // middlewares). The following is valid even after restarts.\\n  app.use(vite.middlewares)\\n\\n  app.use('*', async (req, res) => {\\n    // serve index.html - we will tackle this next\\n  })\\n\\n  app.listen(5173)\\n}\\n\\ncreateServer()\n```\n\n----------------------------------------\n\nTITLE: Installing CSS Pre-Processors for Vite Projects (Bash)\nDESCRIPTION: This set of bash commands shows how to install various CSS pre-processors (Sass embedded, Less, Stylus) needed for Vite to handle .scss, .sass, .less, .styl, and .stylus files. Each command installs the dev-dependency required for that pre-processor. No additional Vite plugin is needed; these packages must be present in your node_modules. Input is npm add commands, output is the installation of the pre-processor.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/features.md#2025-04-22_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n# .scss and .sass\\nnpm add -D sass-embedded # or sass\\n\\n# .less\\nnpm add -D less\\n\\n# .styl and .stylus\\nnpm add -D stylus\n```\n\n----------------------------------------\n\nTITLE: Async Vite Config with defineConfig\nDESCRIPTION: Using an async function with defineConfig for asynchronous configuration setup in Vite.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/config/index.md#2025-04-22_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nexport default defineConfig(async ({ command, mode }) => {\n  const data = await asyncFunction()\n  return {\n    // vite config\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Basic Glob Import in Vite\nDESCRIPTION: Demonstrates how to use import.meta.glob to import multiple modules from a directory. The code shows both the input pattern and how Vite transforms it into lazy-loaded dynamic imports.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/features.md#2025-04-22_snippet_18\n\nLANGUAGE: javascript\nCODE:\n```\nconst modules = import.meta.glob('./dir/*.js')\n```\n\nLANGUAGE: javascript\nCODE:\n```\n// code produced by vite\nconst modules = {\n  './dir/bar.js': () => import('./dir/bar.js'),\n  './dir/foo.js': () => import('./dir/foo.js')\n}\n```\n\n----------------------------------------\n\nTITLE: Loading Environment Variables in TypeScript\nDESCRIPTION: This function loads '.env' files from a given directory. By default, it only loads environment variables prefixed with 'VITE_', but this can be altered by specifying different prefixes.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-javascript.md#2025-04-22_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction loadEnv(\n  mode: string,\n  envDir: string,\n  prefixes: string | string[] = 'VITE_',\n): Record<string, string>\n```\n\n----------------------------------------\n\nTITLE: Serving Rendered SSR HTML with Error Handling in Express + Vite (JavaScript)\nDESCRIPTION: This snippet implements the Express `*` route handler for dynamic SSR with Vite in development. It loads and transforms the HTML template, dynamically imports the SSR entry (`entry-server.js`), renders the application HTML with a framework-specific render function, injects it into the template at `<!--ssr-outlet-->`, and serves the result to the client. Errors in the SSR process have their stack traces fixed using Vite utilities for better debugging. Dependencies: 'fs', 'path', 'express', 'vite'.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/ssr.md#2025-04-22_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n// @noErrors\\nimport fs from 'node:fs'\\nimport path from 'node:path'\\nimport { fileURLToPath } from 'node:url'\\n\\n/** @type {import('express').Express} */\\nvar app\\n/** @type {import('vite').ViteDevServer}  */\\nvar vite\\n\\n// ---cut---\\napp.use('*', async (req, res, next) => {\\n  const url = req.originalUrl\\n\\n  try {\\n    // 1. Read index.html\\n    let template = fs.readFileSync(\\n      path.resolve(__dirname, 'index.html'),\\n      'utf-8',\\n    )\\n\\n    // 2. Apply Vite HTML transforms. This injects the Vite HMR client,\\n    //    and also applies HTML transforms from Vite plugins, e.g. global\\n    //    preambles from @vitejs/plugin-react\\n    template = await vite.transformIndexHtml(url, template)\\n\\n    // 3. Load the server entry. ssrLoadModule automatically transforms\\n    //    ESM source code to be usable in Node.js! There is no bundling\\n    //    required, and provides efficient invalidation similar to HMR.\\n    const { render } = await vite.ssrLoadModule('/src/entry-server.js')\\n\\n    // 4. render the app HTML. This assumes entry-server.js's exported\\n    //     `render` function calls appropriate framework SSR APIs,\\n    //    e.g. ReactDOMServer.renderToString()\\n    const appHtml = await render(url)\\n\\n    // 5. Inject the app-rendered HTML into the template.\\n    const html = template.replace(`<!--ssr-outlet-->`, () => appHtml)\\n\\n    // 6. Send the rendered HTML back.\\n    res.status(200).set({ 'Content-Type': 'text/html' }).end(html)\\n  } catch (e) {\\n    // If an error is caught, let Vite fix the stack trace so it maps back\\n    // to your actual source code.\\n    vite.ssrFixStacktrace(e)\\n    next(e)\\n  }\\n})\n```\n\n----------------------------------------\n\nTITLE: Explicit Asset Inclusion Pattern Configuration in Vite - JavaScript\nDESCRIPTION: This snippet adds a custom file extension match pattern to assetsInclude using defineConfig so that .gltf files are processed as static assets by Vite. Requires Vite and picomatch. Useful for including 3D model files and other custom assets in the build pipeline.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/config/shared-options.md#2025-04-22_snippet_7\n\nLANGUAGE: js\nCODE:\n```\nexport default defineConfig({\n  assetsInclude: ['**/*.gltf'],\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring a Rollup Plugin in Vite\nDESCRIPTION: Shows how to augment an existing Rollup plugin with Vite-specific properties using the defineConfig function.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-plugin.md#2025-04-22_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\nimport example from 'rollup-plugin-example'\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  plugins: [\n    {\n      ...example(),\n      enforce: 'post',\n      apply: 'build',\n    },\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Preprocessing CSS Files in TypeScript\nDESCRIPTION: Pre-processes various CSS file types into plain CSS. This step is needed before using in browsers or further parsing by tools. The pre-processor is chosen based on the file extension, supporting formats like '.scss', '.less', etc.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-javascript.md#2025-04-22_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nasync function preprocessCSS(\n  code: string,\n  filename: string,\n  config: ResolvedConfig,\n): Promise<PreprocessCSSResult>\n\ninterface PreprocessCSSResult {\n  code: string\n  map?: SourceMapInput\n  modules?: Record<string, string>\n  deps?: Set<string>\n}\n```\n\n----------------------------------------\n\nTITLE: Using hot.invalidate for Forceful Update Propagation in JavaScript\nDESCRIPTION: This example shows how to use hot.invalidate within the accept callback to forcefully propagate updates to importers when a module can't handle an HMR update.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-hmr.md#2025-04-22_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nimport.meta.hot.accept((module) => {\n  // You may use the new module instance to decide whether to invalidate.\n  if (cannotHandleUpdate(module)) {\n    import.meta.hot.invalidate()\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Customizing Rollup Options in Vite Build Configuration\nDESCRIPTION: Demonstrates how to customize the build by adjusting Rollup options in the Vite configuration file. This allows developers to fine-tune the bundling process according to their specific needs.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/build.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nexport default defineConfig({\n  build: {\n    rollupOptions: {\n      // https://rollupjs.org/configuration-options/\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Defining a CSS Module with Custom Class in Vite (CSS)\nDESCRIPTION: This CSS snippet demonstrates how to define a CSS module in Vite by using the .module.css extension. The example illustrates a single class named .red which sets the text color to red. To use this, import the CSS module in your JavaScript files. The primary dependency is the Vite build tool which enables CSS modules processing. Input is a standard CSS file and output is a JavaScript object mapping class names.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/features.md#2025-04-22_snippet_6\n\nLANGUAGE: css\nCODE:\n```\n.red {\\n  color: red;\\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Proxy Rules in Vite Server\nDESCRIPTION: Sets up custom proxy rules for the Vite development server. The example demonstrates various proxy configurations including string shorthand, options with target and rewrite functions, RegExp matching, and WebSocket proxying.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/config/server-options.md#2025-04-22_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nexport default defineConfig({\n  server: {\n    proxy: {\n      // string shorthand:\n      // http://localhost:5173/foo\n      //   -> http://localhost:4567/foo\n      '/foo': 'http://localhost:4567',\n      // with options:\n      // http://localhost:5173/api/bar\n      //   -> http://jsonplaceholder.typicode.com/bar\n      '/api': {\n        target: 'http://jsonplaceholder.typicode.com',\n        changeOrigin: true,\n        rewrite: (path) => path.replace(/^\\/api/, ''),\n      },\n      // with RegExp:\n      // http://localhost:5173/fallback/\n      //   -> http://jsonplaceholder.typicode.com/\n      '^/fallback/.*': {\n        target: 'http://jsonplaceholder.typicode.com',\n        changeOrigin: true,\n        rewrite: (path) => path.replace(/^\\/fallback/, ''),\n      },\n      // Using the proxy instance\n      '/api': {\n        target: 'http://jsonplaceholder.typicode.com',\n        changeOrigin: true,\n        configure: (proxy, options) => {\n          // proxy will be an instance of 'http-proxy'\n        },\n      },\n      // Proxying websockets or socket.io:\n      // ws://localhost:5173/socket.io\n      //   -> ws://localhost:5174/socket.io\n      // Exercise caution using `rewriteWsOrigin` as it can leave the\n      // proxying open to CSRF attacks.\n      '/socket.io': {\n        target: 'ws://localhost:5174',\n        ws: true,\n        rewriteWsOrigin: true,\n      },\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Consuming CSS Modules in Vite Projects (JavaScript)\nDESCRIPTION: This JavaScript snippet demonstrates importing a CSS module and applying a defined class to an HTML element by assigning classes.red to className. It is dependent on the Vite CSS modules loader and assumes an HTML element with the id 'foo' exists in the DOM. Input is the imported module and its class names; output is dynamic style assignment at runtime.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/features.md#2025-04-22_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nimport 'vite/client'\\n// ---cut---\\nimport classes from './example.module.css'\\ndocument.getElementById('foo').className = classes.red\n```\n\n----------------------------------------\n\nTITLE: Configuring Vite Library Mode for Multiple Entry Points in JavaScript\nDESCRIPTION: Demonstrates a Vite configuration (`vite.config.js`) for building a library with multiple entry points (`lib/main.js` and `lib/secondary.js`). It sets the library name (`MyLib`) and externalizes 'vue' via `rollupOptions`, providing globals for the UMD build. The `entry` option is an object mapping entry names to their file paths.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/build.md#2025-04-22_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n```js twoslash [vite.config.js (multiple entries)]\nimport { dirname, resolve } from 'node:path'\nimport { fileURLToPath } from 'node:url'\nimport { defineConfig } from 'vite'\n\nconst __dirname = dirname(fileURLToPath(import.meta.url))\n\nexport default defineConfig({\n  build: {\n    lib: {\n      entry: {\n        'my-lib': resolve(__dirname, 'lib/main.js'),\n        secondary: resolve(__dirname, 'lib/secondary.js'),\n      },\n      name: 'MyLib',\n    },\n    rollupOptions: {\n      // make sure to externalize deps that shouldn't be bundled\n      // into your library\n      external: ['vue'],\n      output: {\n        // Provide global variables to use in the UMD build\n        // for externalized deps\n        globals: {\n          vue: 'Vue',\n        },\n      },\n    },\n  },\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Specifying JavaScript Module Type in Vite Load Hook (JavaScript)\nDESCRIPTION: This snippet demonstrates how to correctly handle content transformation to JavaScript within a Vite plugin's `load` hook when using `rolldown-vite`. It shows reading a `.txt` file and returning its content as a JavaScript module, explicitly setting `moduleType: 'js'` to ensure Rolldown correctly interprets the output, as it supports non-JavaScript module types.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/rolldown.md#2025-04-22_snippet_9\n\nLANGUAGE: js\nCODE:\n```\nconst plugin = {\n  name: 'txt-loader',\n  load(id) {\n    if (id.endsWith('.txt')) {\n      const content = fs.readFile(id, 'utf-8')\n      return {\n        code: `export default ${JSON.stringify(content)}`,\n        moduleType: 'js', // [!code ++]\n      }\n    }\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Registering New Environment in Config Hook (TypeScript)\nDESCRIPTION: Shows how to register a new environment (e.g., RSC) in a plugin's config hook. This snippet adds an 'rsc' environment if it doesn't already exist.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-environment-plugins.md#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconfig(config: UserConfig) {\n  config.environments.rsc ??= {}\n}\n```\n\n----------------------------------------\n\nTITLE: Using Environment Variables in Vite Config\nDESCRIPTION: Loading environment variables using the loadEnv helper and using them in the Vite configuration.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/config/index.md#2025-04-22_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nimport { defineConfig, loadEnv } from 'vite'\n\nexport default defineConfig(({ mode }) => {\n  // Load env file based on `mode` in the current working directory.\n  // Set the third parameter to '' to load all env regardless of the\n  // `VITE_` prefix.\n  const env = loadEnv(mode, process.cwd(), '')\n  return {\n    // vite config\n    define: {\n      __APP_ENV__: JSON.stringify(env.APP_ENV),\n    },\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Transforming HTML Entry Points in Vite Using JavaScript\nDESCRIPTION: This example utilizes the `transformIndexHtml` hook for altering HTML entry files like `index.html`. The hook allows asynchronous transformations of the HTML, providing modified HTML as a string or injecting new tags. It supports both pre-processing and post-processing orders in the transformation pipeline.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-plugin.md#2025-04-22_snippet_9\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst htmlPlugin = () => {\n  return {\n    name: 'html-transform',\n    transformIndexHtml(html) {\n      return html.replace(\n        /<title>(.*?)<\\/title>/,\n        `<title>Title replaced!<\\/title>`,\n      )\n    },\n  }\n}\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\ntype IndexHtmlTransformHook = (\n  html: string,\n  ctx: {\n    path: string\n    filename: string\n    server?: ViteDevServer\n    bundle?: import('rollup').OutputBundle\n    chunk?: import('rollup').OutputChunk\n  },\n) =>\n  | IndexHtmlTransformResult\n  | void\n  | Promise<IndexHtmlTransformResult | void>\n\ntype IndexHtmlTransformResult =\n  | string\n  | HtmlTagDescriptor[]\n  | {\n      html: string\n      tags: HtmlTagDescriptor[]\n    }\n\ninterface HtmlTagDescriptor {\n  tag: string\n  attrs?: Record<string, string | boolean>\n  children?: string | HtmlTagDescriptor[]\n  /**\n   * default: 'head-prepend'\n   */\n  injectTo?: 'head' | 'body' | 'head-prepend' | 'body-prepend'\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring package.json for a Single-Entry Vite Library\nDESCRIPTION: Recommended `package.json` structure for a library built with Vite using a single entry point. It specifies the package name, sets `type` to `module`, lists distributable files (`dist`), and defines `main` (for CJS/UMD), `module` (for ESM), and `exports` fields pointing to the generated UMD and ES module bundles produced by the Vite build.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/build.md#2025-04-22_snippet_7\n\nLANGUAGE: json\nCODE:\n```\n```json [package.json (single entry)]\n{\n  \"name\": \"my-lib\",\n  \"type\": \"module\",\n  \"files\": [\"dist\"],\n  \"main\": \"./dist/my-lib.umd.cjs\",\n  \"module\": \"./dist/my-lib.js\",\n  \"exports\": {\n    \".\": {\n      \"import\": \"./dist/my-lib.js\",\n      \"require\": \"./dist/my-lib.umd.cjs\"\n    }\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: EnvironmentModuleGraph Class in TypeScript\nDESCRIPTION: Defines the EnvironmentModuleGraph class representing the module graph for an environment. It includes methods for managing modules, resolving URLs, and handling file changes and invalidations.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-environment-instances.md#2025-04-22_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport class EnvironmentModuleGraph {\n  environment: string\n\n  urlToModuleMap = new Map<string, EnvironmentModuleNode>()\n  idToModuleMap = new Map<string, EnvironmentModuleNode>()\n  etagToModuleMap = new Map<string, EnvironmentModuleNode>()\n  fileToModulesMap = new Map<string, Set<EnvironmentModuleNode>>()\n\n  constructor(\n    environment: string,\n    resolveId: (url: string) => Promise<PartialResolvedId | null>,\n  )\n\n  async getModuleByUrl(\n    rawUrl: string,\n  ): Promise<EnvironmentModuleNode | undefined>\n\n  getModuleById(id: string): EnvironmentModuleNode | undefined\n\n  getModulesByFile(file: string): Set<EnvironmentModuleNode> | undefined\n\n  onFileChange(file: string): void\n\n  onFileDelete(file: string): void\n\n  invalidateModule(\n    mod: EnvironmentModuleNode,\n    seen: Set<EnvironmentModuleNode> = new Set(),\n    timestamp: number = Date.now(),\n    isHmr: boolean = false,\n  ): void\n\n  invalidateAll(): void\n\n  async ensureEntryFromUrl(\n    rawUrl: string,\n    setIsSelfAccepting = true,\n  ): Promise<EnvironmentModuleNode>\n\n  createFileOnlyEntry(file: string): EnvironmentModuleNode\n\n  async resolveUrl(url: string): Promise<ResolvedUrl>\n\n  updateModuleTransformResult(\n    mod: EnvironmentModuleNode,\n    result: TransformResult | null,\n  ): void\n\n  getModuleByEtag(etag: string): EnvironmentModuleNode | undefined\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Virtual Module Plugin\nDESCRIPTION: An example of a plugin that creates a virtual module. This demonstrates how to use the resolveId and load hooks to create a module that doesn't exist on the file system.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-plugin.md#2025-04-22_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nexport default function myPlugin() {\n  const virtualModuleId = 'virtual:my-module'\n  const resolvedVirtualModuleId = '\\0' + virtualModuleId\n\n  return {\n    name: 'my-plugin', // required, will show up in warnings and errors\n    resolveId(id) {\n      if (id === virtualModuleId) {\n        return resolvedVirtualModuleId\n      }\n    },\n    load(id) {\n      if (id === resolvedVirtualModuleId) {\n        return `export const msg = \"from virtual module\"`\n      }\n    },\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Dynamic URL Generation with Template Literals in JavaScript\nDESCRIPTION: Shows how to create a function that generates dynamic URLs using template literals and the new URL constructor with import.meta.url.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/assets.md#2025-04-22_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nfunction getImageUrl(name) {\n  // note that this does not include files in subdirectories\n  return new URL(`./dir/${name}.png`, import.meta.url).href\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Resolved Configuration in Vite Plugin (JavaScript)\nDESCRIPTION: This snippet illustrates how to access the final resolved Vite configuration within the `configResolved` hook of a plugin. It specifically logs the `optimizeDeps` and `oxc` configuration objects, which can be useful for inspecting options potentially modified by the `rolldown-vite` compatibility layer.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/rolldown.md#2025-04-22_snippet_8\n\nLANGUAGE: js\nCODE:\n```\nconst plugin = {\n  name: 'log-config',\n  configResolved(config) {\n    console.log('options', config.optimizeDeps, config.oxc)\n  },\n},\n```\n\n----------------------------------------\n\nTITLE: Implementing FetchableDevEnvironment in TypeScript\nDESCRIPTION: Shows how to create and use a FetchableDevEnvironment for handling HTTP requests in development environments using the Fetch API interface.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-environment-frameworks.md#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  createServer,\n  createFetchableDevEnvironment,\n  isFetchableDevEnvironment,\n} from 'vite'\n\nconst server = await createServer({\n  server: { middlewareMode: true },\n  appType: 'custom',\n  environments: {\n    custom: {\n      dev: {\n        createEnvironment(name, config) {\n          return createFetchableDevEnvironment(name, config, {\n            handleRequest(request: Request): Promise<Response> | Response {\n              // handle Request and return a Response\n            },\n          })\n        },\n      },\n    },\n  },\n})\n\n// Any consumer of the environment API can now call `dispatchFetch`\nif (isFetchableDevEnvironment(server.environments.custom)) {\n  const response: Response = await server.environments.custom.dispatchFetch(\n    new Request('/request-to-handle'),\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Config Resolved Hook in Vite with JavaScript\nDESCRIPTION: This snippet demonstrates how to handle the `configResolved` hook in a Vite plugin to store the final resolved configuration for further actions within other hooks. The plugin checks the 'command' configuration to determine if it is in serve (development) or build (Rollup) mode, affecting behavior accordingly. Dependencies are assumed to be Vite and any related plugins.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-plugin.md#2025-04-22_snippet_6\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst examplePlugin = () => {\n  let config\n\n  return {\n    name: 'read-config',\n\n    configResolved(resolvedConfig) {\n      // store the resolved config\n      config = resolvedConfig\n    },\n\n    // use stored config in other hooks\n    transform(code, id) {\n      if (config.command === 'serve') {\n        // dev: plugin invoked by dev server\n      } else {\n        // build: plugin invoked by Rollup\n      }\n    },\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Preload Errors in Vite Applications\nDESCRIPTION: Shows how to handle dynamic import failures by listening to the 'vite:preloadError' event. This is useful for managing scenarios where assets from previous deployments are deleted, causing import errors for users with outdated assets.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/build.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nwindow.addEventListener('vite:preloadError', (event) => {\n  window.location.reload() // for example, refresh the page\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring package.json for a Multi-Entry Vite Library\nDESCRIPTION: Recommended `package.json` structure for a library built with Vite using multiple entry points. It includes `main` and `module` fields for the primary entry point, and the `exports` field is configured to expose both the primary entry (`.`) and any secondary entries (e.g., `./secondary`) via their respective CJS and ES module builds generated by Vite.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/build.md#2025-04-22_snippet_8\n\nLANGUAGE: json\nCODE:\n```\n```json [package.json (multiple entries)]\n{\n  \"name\": \"my-lib\",\n  \"type\": \"module\",\n  \"files\": [\"dist\"],\n  \"main\": \"./dist/my-lib.cjs\",\n  \"module\": \"./dist/my-lib.js\",\n  \"exports\": {\n    \".\": {\n      \"import\": \"./dist/my-lib.js\",\n      \"require\": \"./dist/my-lib.cjs\"\n    },\n    \"./secondary\": {\n      \"import\": \"./dist/secondary.js\",\n      \"require\": \"./dist/secondary.cjs\"\n    }\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing a Basic Plugin Counter in JavaScript\nDESCRIPTION: This snippet demonstrates a simple Vite plugin that counts the number of transformed modules across all environments. It initializes a counter, increments it during transformation, and logs the total at the end of the build.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/changes/shared-plugins-during-build.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction CountTransformedModulesPlugin() {\n  let transformedModules\n  return {\n    name: 'count-transformed-modules',\n    buildStart() {\n      transformedModules = 0\n    },\n    transform(id) {\n      transformedModules++\n    },\n    buildEnd() {\n      console.log(transformedModules)\n    },\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Injecting Vite Scripts in HTML Template for Development\nDESCRIPTION: Adds necessary script tags to the HTML template for development, including Vite client and main entry point.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/backend-integration.md#2025-04-22_snippet_2\n\nLANGUAGE: html\nCODE:\n```\n<!-- if development -->\n<script type=\"module\" src=\"http://localhost:5173/@vite/client\"></script>\n<script type=\"module\" src=\"http://localhost:5173/main.js\"></script>\n```\n\n----------------------------------------\n\nTITLE: Type Definitions for Custom Vite Events\nDESCRIPTION: Shows how to define TypeScript types for custom events by extending the CustomEventMap interface.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-plugin.md#2025-04-22_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nimport 'vite/types/customEvent.d.ts'\n\ndeclare module 'vite/types/customEvent.d.ts' {\n  interface CustomEventMap {\n    'custom:foo': { msg: string }\n    // 'event-key': payload\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Accepting Updates from Dependencies in JavaScript\nDESCRIPTION: This snippet demonstrates how a module can accept updates from its direct dependencies without reloading itself, using import.meta.hot.accept with dependency paths.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-hmr.md#2025-04-22_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { foo } from './foo.js'\n\nfoo()\n\nif (import.meta.hot) {\n  import.meta.hot.accept('./foo.js', (newFoo) => {\n    // the callback receives the updated './foo.js' module\n    newFoo?.foo()\n  })\n\n  // Can also accept an array of dep modules:\n  import.meta.hot.accept(\n    ['./foo.js', './bar.js'],\n    ([newFooModule, newBarModule]) => {\n      // The callback receives an array where only the updated module is\n      // non null. If the update was not successful (syntax error for ex.),\n      // the array is empty\n    },\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Env Variables in Browser Code - Vite JavaScript\nDESCRIPTION: Illustrates the safe access pattern for environment variables in Vite client-side JavaScript code. `import.meta.env.VITE_SOME_KEY` returns the string value defined in the .env file, whereas unexposed variables like `DB_PASSWORD` return undefined. This snippet assumes Vite has processed the variables as described; it works directly in any JS file run in the Vite context.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/env-and-mode.md#2025-04-22_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nconsole.log(import.meta.env.VITE_SOME_KEY) // \"123\"\\nconsole.log(import.meta.env.DB_PASSWORD) // undefined\n```\n\n----------------------------------------\n\nTITLE: Using new URL with import.meta.url in JavaScript\nDESCRIPTION: Demonstrates how to use the new URL constructor with import.meta.url to obtain the full, resolved URL of a static asset using a relative path.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/assets.md#2025-04-22_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nconst imgUrl = new URL('./img.png', import.meta.url).href\n\ndocument.getElementById('hero-img').src = imgUrl\n```\n\n----------------------------------------\n\nTITLE: Illustrating Type-Only Imports and Exports in TypeScript\nDESCRIPTION: This TypeScript example demonstrates the use of type-only imports and exports to avoid potential bundling issues with type information. This syntax is recommended when working with TypeScript in Vite.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/features.md#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { T } from 'only/types'\nexport type { T }\n```\n\n----------------------------------------\n\nTITLE: Disabling Automatic CSS Injection in Vite (JavaScript)\nDESCRIPTION: This code snippet illustrates how to import a CSS file to inject styles automatically and how to import a CSS file with ?inline to avoid style injection, obtaining a processed CSS string at runtime instead. This relies on Vite's handling of the ?inline query. Inputs are import statements with and without the query; output is injected style or imported CSS string.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/features.md#2025-04-22_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\nimport 'vite/client'\\n// ---cut---\\nimport './foo.css' // will be injected into the page\\nimport otherStyles from './bar.css?inline' // will not be injected\n```\n\n----------------------------------------\n\nTITLE: Web Worker Import in Vite\nDESCRIPTION: Shows different methods of importing Web Workers in Vite, including using the Worker constructor and query suffixes for both basic and inline workers.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/features.md#2025-04-22_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nconst worker = new Worker(new URL('./worker.js', import.meta.url))\n```\n\nLANGUAGE: javascript\nCODE:\n```\nimport MyWorker from './worker?worker'\n\nconst worker = new MyWorker()\n```\n\n----------------------------------------\n\nTITLE: Injecting Global JSX Helper with ESBuild in Vite - JavaScript\nDESCRIPTION: This snippet demonstrates adding a jsxInject option to the esbuild configuration in Vite, causing every ESBuild-processed file to automatically import React. This is useful to reduce repetitive imports in large codebases. Requires Vite, ESBuild, and React as dependencies; input is a string of import code.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/config/shared-options.md#2025-04-22_snippet_6\n\nLANGUAGE: js\nCODE:\n```\nexport default defineConfig({\n  esbuild: {\n    jsxInject: `import React from 'react'`,\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Dependency Optimization in Vite (JavaScript)\nDESCRIPTION: Example of configuring Vite's dependency optimization options. It shows how to include specific dependencies for pre-bundling and set esbuild options.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/config/dep-optimization-options.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  optimizeDeps: {\n    include: ['esm-dep > cjs-dep'],\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Firebase Hosting Configuration for Vite\nDESCRIPTION: Firebase hosting configuration file (firebase.json) that sets up hosting for a Vite application, including SPA-style routing via the rewrites section.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/static-deploy.md#2025-04-22_snippet_9\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"hosting\": {\n    \"public\": \"dist\",\n    \"ignore\": [],\n    \"rewrites\": [\n      {\n        \"source\": \"**\",\n        \"destination\": \"/index.html\"\n      }\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Exposing Environment Variables via Define Option in Vite - JavaScript\nDESCRIPTION: This snippet shows how to expose an unprefixed environment variable to client-side code by using the define option in Vite's configuration. It leverages JSON.stringify for serialization. Inputs are environment variable values from process.env; outputs are replacements accessible at compile time. Ensures sensitive variables are not accidentally exposed.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/config/shared-options.md#2025-04-22_snippet_12\n\nLANGUAGE: js\nCODE:\n```\ndefine: {\n  'import.meta.env.ENV_VARIABLE': JSON.stringify(process.env.ENV_VARIABLE)\n}\n```\n\n----------------------------------------\n\nTITLE: Explicit Inline and No-Inline Asset Imports in JavaScript\nDESCRIPTION: Shows how to use the ?inline and ?no-inline suffixes to explicitly control whether assets are inlined or not during import.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/assets.md#2025-04-22_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport imgUrl1 from './img.svg?no-inline'\nimport imgUrl2 from './img.png?inline'\n```\n\n----------------------------------------\n\nTITLE: Implementing SSR-Specific Logic in Vite Plugins using JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates creating a Vite plugin named 'my-ssr'. It utilizes the `transform` hook, checking the `options.ssr` boolean property (passed by Vite) to conditionally apply transformations specifically for Server-Side Rendering builds. This pattern allows plugins to adapt their behavior based on the rendering context. It relies on the Vite Plugin API.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/ssr.md#2025-04-22_snippet_7\n\nLANGUAGE: js\nCODE:\n```\n/** @type {() => import('vite').Plugin} */\n// ---cut---\nexport function mySSRPlugin() {\n  return {\n    name: 'my-ssr',\n    transform(code, id, options) {\n      if (options?.ssr) {\n        // perform ssr-specific transform...\n      }\n    },\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: WebAssembly Import in Vite\nDESCRIPTION: Demonstrates how to import and initialize WebAssembly modules in Vite using the ?init suffix. Shows both basic initialization and passing import objects.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/features.md#2025-04-22_snippet_20\n\nLANGUAGE: javascript\nCODE:\n```\nimport init from './example.wasm?init'\n\ninit().then((instance) => {\n  instance.exports.test()\n})\n```\n\nLANGUAGE: javascript\nCODE:\n```\nimport init from './example.wasm?init'\n\ninit({\n  imports: {\n    someFunc: () => {\n      /* ... */\n    },\n  },\n}).then(() => {\n  /* ... */\n})\n```\n\n----------------------------------------\n\nTITLE: Network Request Flow in Vite's Optimized Async Chunk Loading\nDESCRIPTION: Demonstrates how Vite rewrites code-split dynamic import calls with a preload step to fetch chunk A and common chunk C in parallel, eliminating extra network roundtrips.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/features.md#2025-04-22_snippet_23\n\nLANGUAGE: plaintext\nCODE:\n```\nEntry ---> (A + C)\n```\n\n----------------------------------------\n\nTITLE: Customizing Asset URLs Based on Type with renderBuiltUrl in TypeScript\nDESCRIPTION: Shows an advanced usage of the experimental `experimental.renderBuiltUrl` option in a TypeScript Vite configuration (`vite.config.ts`). It differentiates URL generation based on the asset `type` and `hostId`. Public files (`type === 'public'`) are prefixed with a static domain. Assets referenced from JavaScript files (`path.extname(hostId) === '.js'`) generate runtime code (`window.__assetsPath(...)`) for dynamic URL resolution. Other assets (like CSS referenced from HTML) are prefixed with a separate CDN URL.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/build.md#2025-04-22_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n```ts twoslash\nimport type { UserConfig } from 'vite'\nimport path from 'node:path'\n// prettier-ignore\nconst config: UserConfig = {\n// ---cut-before---\nexperimental: {\n  renderBuiltUrl(filename, { hostId, hostType, type }) {\n    if (type === 'public') {\n      return 'https://www.domain.com/' + filename\n    } else if (path.extname(hostId) === '.js') {\n      return {\n        runtime: `window.__assetsPath(${JSON.stringify(filename)})`\n      }\n    } else {\n      return 'https://cdn.domain.com/assets/' + filename\n    }\n  },\n},\n// ---cut-after---\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Basic SPA/MPA Environment in Vite\nDESCRIPTION: Example of a basic Vite configuration for a single-page or multi-page application. This configuration implicitly applies to the 'client' environment.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-environment.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nexport default defineConfig({\n  build: {\n    sourcemap: false,\n  },\n  optimizeDeps: {\n    include: ['lib'],\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Legacy Browser Support Plugin in Vite\nDESCRIPTION: This code demonstrates how to configure the @vitejs/plugin-legacy plugin in the vite.config.js file to target specific browser versions.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/using-plugins.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport legacy from '@vitejs/plugin-legacy'\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  plugins: [\n    legacy({\n      targets: ['defaults', 'not IE 11'],\n    }),\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Defining ViteHotContext Interface in TypeScript\nDESCRIPTION: This snippet defines the TypeScript interface for the ViteHotContext, which is exposed via the import.meta.hot object. It includes methods for accepting updates, disposing of modules, and handling custom events.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-hmr.md#2025-04-22_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface ImportMeta {\n  readonly hot?: ViteHotContext\n}\n\ninterface ViteHotContext {\n  readonly data: any\n\n  accept(): void\n  accept(cb: (mod: ModuleNamespace | undefined) => void): void\n  accept(dep: string, cb: (mod: ModuleNamespace | undefined) => void): void\n  accept(\n    deps: readonly string[],\n    cb: (mods: Array<ModuleNamespace | undefined>) => void,\n  ): void\n\n  dispose(cb: (data: any) => void): void\n  prune(cb: (data: any) => void): void\n  invalidate(message?: string): void\n\n  on<T extends CustomEventName>(\n    event: T,\n    cb: (payload: InferCustomEventPayload<T>) => void,\n  ): void\n  off<T extends CustomEventName>(\n    event: T,\n    cb: (payload: InferCustomEventPayload<T>) => void,\n  ): void\n  send<T extends CustomEventName>(\n    event: T,\n    data?: InferCustomEventPayload<T>,\n  ): void\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating Vite Plugin to Use this.environment API\nDESCRIPTION: This snippet demonstrates how to migrate a Vite plugin from using the `options.ssr` argument to the new `this.environment.name` property in the `resolveId` hook. It checks if the current environment is not 'client' to determine if it's an SSR context.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/changes/this-environment-in-hooks.md#2025-04-22_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Plugin } from 'vite'\n\nexport function myPlugin(): Plugin {\n  return {\n    name: 'my-plugin',\n    resolveId(id, importer, options) {\n      const isSSR = options.ssr // [!code --]\n      const isSSR = this.environment.name !== 'client' // [!code ++]\n\n      if (isSSR) {\n        // SSR specific logic\n      } else {\n        // Client specific logic\n      }\n    },\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Exporting Bundled CSS from a Vite Library in package.json\nDESCRIPTION: Illustrates how to update the `exports` field in `package.json` to include an entry for the bundled CSS file (`dist/my-lib.css`) generated during the Vite library build. This allows consumers of the library to directly import the styles using an explicit path like `my-lib/style.css`.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/build.md#2025-04-22_snippet_9\n\nLANGUAGE: json\nCODE:\n```\n```json {12}\n{\n  \"name\": \"my-lib\",\n  \"type\": \"module\",\n  \"files\": [\"dist\"],\n  \"main\": \"./dist/my-lib.umd.cjs\",\n  \"module\": \"./dist/my-lib.js\",\n  \"exports\": {\n    \".\": {\n      \"import\": \"./dist/my-lib.js\",\n      \"require\": \"./dist/my-lib.umd.cjs\"\n    },\n    \"./style.css\": \"./dist/my-lib.css\"\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Using Env Variables in Vite HTML Files - HTML Constant Replacement\nDESCRIPTION: Shows how to reference environment constants in HTML files processed by Vite. The special `%CONST_NAME%` syntax allows values from `import.meta.env` to be injected at build time. Input is HTML with placeholders; output is HTML with the placeholders replaced if values exist. Unresolvable variables are removed from the output, providing a declarative mechanism for dynamic HTML configuration.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/env-and-mode.md#2025-04-22_snippet_6\n\nLANGUAGE: html\nCODE:\n```\n<h1>Vite is running in %MODE%</h1>\\n<p>Using data from %VITE_API_URL%</p>\n```\n\n----------------------------------------\n\nTITLE: Handling Client Messages on the Server Side\nDESCRIPTION: Shows how to listen for client messages and respond to them in a Vite plugin.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-plugin.md#2025-04-22_snippet_16\n\nLANGUAGE: javascript\nCODE:\n```\nexport default defineConfig({\n  plugins: [\n    {\n      // ...\n      configureServer(server) {\n        server.ws.on('my:from-client', (data, client) => {\n          console.log('Message from client:', data.msg) // Hey!\n          // reply only to the client (if needed)\n          client.send('my:ack', { msg: 'Hi! I got your message!' })\n        })\n      },\n    },\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Server Warmup for Frequently Used Files in Vite\nDESCRIPTION: Configuration example showing how to use the server.warmup option to pre-transform frequently used files, reducing request waterfalls and improving loading times.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/performance.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nexport default defineConfig({\n  server: {\n    warmup: {\n      clientFiles: [\n        './src/components/BigComponent.vue',\n        './src/utils/big-utils.js',\n      ],\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Importing Asset as String in JavaScript\nDESCRIPTION: Demonstrates how to import an asset as a string using the ?raw suffix, which is useful for importing text-based assets like shaders.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/assets.md#2025-04-22_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport shaderString from './shader.glsl?raw'\n```\n\n----------------------------------------\n\nTITLE: Implementing Shared Plugin During Build (JavaScript)\nDESCRIPTION: Shows how to implement a shared plugin that maintains state across all environments during both dev and build. This example uses the sharedDuringBuild flag to opt-in to sharing.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-environment-plugins.md#2025-04-22_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nfunction myPlugin() {\n  // Share state among all environments in dev and build\n  const sharedState = ...\n  return {\n    name: 'shared-plugin',\n    transform(code, id) { ... },\n\n    // Opt-in into a single instance for all environments\n    sharedDuringBuild: true,\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Injecting Additional Data for CSS Pre-Processor in Vite - JavaScript\nDESCRIPTION: This snippet shows how to inject extra CSS, such as variable declarations, into every SCSS file processed by Vite using the additionalData option. It utilizes defineConfig and expects Vite and SCSS dependencies. Input is a string of SCSS code; result is injection at build-time into all processed SCSS files.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/config/shared-options.md#2025-04-22_snippet_4\n\nLANGUAGE: js\nCODE:\n```\nexport default defineConfig({\n  css: {\n    preprocessorOptions: {\n      scss: {\n        additionalData: `$injectedColor: orange;`,\n      },\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Creating Environment Factory in TypeScript\nDESCRIPTION: Example of creating a workerd environment factory that configures dev and build environments with custom hot reloading.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-environment-runtimes.md#2025-04-22_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nfunction createWorkerdEnvironment(\n  userConfig: EnvironmentOptions,\n): EnvironmentOptions {\n  return mergeConfig(\n    {\n      resolve: {\n        conditions: [\n          /*...*/\n        ],\n      },\n      dev: {\n        createEnvironment(name, config) {\n          return createWorkerdDevEnvironment(name, config, {\n            hot: true,\n            transport: customHotChannel(),\n          })\n        },\n      },\n      build: {\n        createEnvironment(name, config) {\n          return createWorkerdBuildEnvironment(name, config)\n        },\n      },\n    },\n    userConfig,\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing RunnableDevEnvironment in TypeScript\nDESCRIPTION: Demonstrates the structure and usage of RunnableDevEnvironment class for module running capabilities in development environments. Includes ModuleRunner class definition with import functionality.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-environment-frameworks.md#2025-04-22_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport class RunnableDevEnvironment extends DevEnvironment {\n  public readonly runner: ModuleRunner\n}\n\nclass ModuleRunner {\n  /**\n   * URL to execute.\n   * Accepts file path, server path, or id relative to the root.\n   * Returns an instantiated module (same as in ssrLoadModule)\n   */\n  public async import(url: string): Promise<Record<string, any>>\n  /**\n   * Other ModuleRunner methods...\n   */\n}\n\nif (isRunnableDevEnvironment(server.environments.ssr)) {\n  await server.environments.ssr.runner.import('/entry-point.js')\n}\n```\n\n----------------------------------------\n\nTITLE: Enforcing Plugin Order in Vite Configuration\nDESCRIPTION: This snippet shows how to enforce the order of a plugin in the Vite configuration by using the 'enforce' property, in this case applying the @rollup/plugin-image plugin before Vite core plugins.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/using-plugins.md#2025-04-22_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport image from '@rollup/plugin-image'\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  plugins: [\n    {\n      ...image(),\n      enforce: 'pre',\n    },\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Transforming Code with Esbuild in TypeScript\nDESCRIPTION: Transforms JavaScript or TypeScript code using esbuild. This function helps plugins align with Vite's internal transformations, enhancing consistency across tools.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-javascript.md#2025-04-22_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nasync function transformWithEsbuild(\n  code: string,\n  filename: string,\n  options?: EsbuildTransformOptions,\n  inMap?: object,\n): Promise<ESBuildTransformResult>\n```\n\n----------------------------------------\n\nTITLE: Custom HMR Handling in HotUpdate Hook (JavaScript)\nDESCRIPTION: Shows how to implement custom HMR handling in the hotUpdate hook. This example sends a custom 'special-update' event to the client for the client environment.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-environment-plugins.md#2025-04-22_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nhotUpdate() {\n  if (this.environment.name !== 'client')\n    return\n\n  this.environment.hot.send({\n    type: 'custom',\n    event: 'special-update',\n    data: {}\n  })\n  return []\n}\n```\n\n----------------------------------------\n\nTITLE: Explicit URL Import for Paint Worklet in JavaScript\nDESCRIPTION: Demonstrates how to explicitly import a file as a URL using the ?url suffix, which is useful for importing special assets like Houdini Paint Worklets.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/assets.md#2025-04-22_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport workletURL from 'extra-scalloped-border/worklet.js?url'\nCSS.paintWorklet.addModule(workletURL)\n```\n\n----------------------------------------\n\nTITLE: Vite Config in TypeScript with satisfies Operator\nDESCRIPTION: Using TypeScript for Vite configuration with the satisfies operator for type checking.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/config/index.md#2025-04-22_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { UserConfig } from 'vite'\n\nexport default {\n  // ...\n} satisfies UserConfig\n```\n\n----------------------------------------\n\nTITLE: Building and Linking Vite Locally using Git and pnpm (Bash)\nDESCRIPTION: This sequence of commands details how to clone the Vite repository, install its dependencies using pnpm, build the `vite` package, and then link it globally using pnpm (or another preferred package manager). This allows developers to use a locally built version of Vite in their projects by subsequently running `pnpm link --global vite` (or the equivalent) within their project directory. This method requires Git and pnpm to be installed.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/index.md#2025-04-22_snippet_23\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/vitejs/vite.git\ncd vite\npnpm install\ncd packages/vite\npnpm run build\npnpm link --global # use your preferred package manager for this step\n```\n\n----------------------------------------\n\nTITLE: Migration Example: Custom HMR Events\nDESCRIPTION: Example showing how to migrate from handleHotUpdate to hotUpdate when sending custom events to the client. The key change is using this.environment.hot.send instead of server.ws.send to send custom events.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/changes/hotupdate-hook.md#2025-04-22_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nhandleHotUpdate({ server }) {\n  server.ws.send({\n    type: 'custom',\n    event: 'special-update',\n    data: {}\n  })\n  return []\n}\n\n// Migrate to...\n\nhotUpdate() {\n  this.environment.hot.send({\n    type: 'custom',\n    event: 'special-update',\n    data: {}\n  })\n  return []\n}\n```\n\n----------------------------------------\n\nTITLE: Vite Config with TypeScript Intellisense using JSDoc\nDESCRIPTION: Using JSDoc type hints to leverage IDE intellisense for Vite configuration in JavaScript.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/config/index.md#2025-04-22_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n/** @type {import('vite').UserConfig} */\nexport default {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Multiple Environments in Vite\nDESCRIPTION: Example of configuring multiple environments (client, server, and edge) in Vite. This demonstrates how to use the new 'environments' configuration option.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-environment.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nexport default {\n  build: {\n    sourcemap: false,\n  },\n  optimizeDeps: {\n    include: ['lib'],\n  },\n  environments: {\n    server: {},\n    edge: {\n      resolve: {\n        noExternal: true,\n      },\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Allowing File System Access Outside Project Root in Vite\nDESCRIPTION: This JavaScript snippet configures the Vite development server's file system (`server.fs`) options. It sets the `allow` property to `['..']`, explicitly permitting the server to serve files located one directory level above the project root. This is useful when needing access to files outside the immediate workspace while `server.fs.strict` is enabled.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/config/server-options.md#2025-04-22_snippet_5\n\nLANGUAGE: js\nCODE:\n```\nexport default defineConfig({\n  server: {\n    fs: {\n      // Allow serving files from one level up to the project root\n      allow: ['..'],\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Preview and Server Ports in Vite\nDESCRIPTION: This snippet demonstrates how to set different ports for the Vite development server and the preview server using the defineConfig function.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/config/preview-options.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nexport default defineConfig({\n  server: {\n    port: 3030,\n  },\n  preview: {\n    port: 8080,\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Adding Vite Client Types to TypeScript Project\nDESCRIPTION: This snippet shows how to add Vite's client-side type definitions to a TypeScript project. It uses a triple-slash directive to reference the Vite client types, providing type information for Vite-specific features.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/features.md#2025-04-22_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n/// <reference types=\"vite/client\" />\n```\n\n----------------------------------------\n\nTITLE: Installing Specific Vite Commit using Bun (Bash)\nDESCRIPTION: This command illustrates adding a specific, unreleased commit of Vite as a development dependency using Bun. Substitute `SHA` with the relevant commit hash found in the Vite repository (e.g., https://github.com/vitejs/vite/commits/main/). The installation uses the `pkg.pr.new` service, and availability is restricted to recent commits (within the last month).\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/index.md#2025-04-22_snippet_22\n\nLANGUAGE: bash\nCODE:\n```\n$ bun add -D https://pkg.pr.new/vite@SHA\n```\n\n----------------------------------------\n\nTITLE: Importing Module Preload Polyfill in Vite Entry\nDESCRIPTION: Imports the module preload polyfill at the beginning of the app entry if not disabled in the configuration.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/backend-integration.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// add the beginning of your app entry\nimport 'vite/modulepreload-polyfill'\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Dev Environment\nDESCRIPTION: Example of creating a custom development environment with hot reload transport implementation.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-environment-runtimes.md#2025-04-22_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nfunction createWorkerdDevEnvironment(\n  name: string,\n  config: ResolvedConfig,\n  context: DevEnvironmentContext\n) {\n  const connection = /* ... */\n  const transport: HotChannel = {\n    on: (listener) => { connection.on('message', listener) },\n    send: (data) => connection.send(data),\n  }\n\n  const workerdDevEnvironment = new DevEnvironment(name, config, {\n    options: {\n      resolve: { conditions: ['custom'] },\n      ...context.options,\n    },\n    hot: true,\n    transport,\n  })\n  return workerdDevEnvironment\n}\n```\n\n----------------------------------------\n\nTITLE: Building the Project for Production via Vite CLI - Bash\nDESCRIPTION: This snippet shows how to build a Vite project for production using the CLI. Node.js and Vite must be installed before running this command. The command takes an optional [root] parameter to define the working directory and offers various CLI options for customizing the build (output directory, minification, etc.). Input: optional [root] parameter; Output: production-ready build assets in the output directory (default: dist).\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/cli.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nvite build [root]\n```\n\n----------------------------------------\n\nTITLE: Importing Asset as URL in JavaScript\nDESCRIPTION: Demonstrates how to import an image asset as a URL and set it as the source of an img element. The imported URL will be resolved to the correct path during development and production.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/assets.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport imgUrl from './img.png'\ndocument.getElementById('hero-img').src = imgUrl\n```\n\n----------------------------------------\n\nTITLE: Configuring Dependency Optimization in Vite\nDESCRIPTION: Shows how to configure Vite for handling linked dependencies in a monorepo setup, including them in the optimization and commonjs processes.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/dep-pre-bundling.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { defineConfig } from 'vite'\n// ---cut---\nexport default defineConfig({\n  optimizeDeps: {\n    include: ['linked-dep'],\n  },\n  build: {\n    commonjsOptions: {\n      include: [/linked-dep/, /node_modules/],\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Sending Messages from Client to Server in Vite\nDESCRIPTION: Demonstrates how to send events from the client to the server using the HMR API.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-plugin.md#2025-04-22_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\n// client side\nif (import.meta.hot) {\n  import.meta.hot.send('my:from-client', { msg: 'Hey!' })\n}\n```\n\n----------------------------------------\n\nTITLE: Starting the Vite Dev Server via CLI - Bash\nDESCRIPTION: This snippet demonstrates how to start the Vite development server from the command line, optionally specifying a root directory. It assumes Node.js and Vite are installed in the environment. The command can be run as shown to serve the project in the current directory or another folder, and supports multiple CLI options for customization. Input: optional [root] parameter specifying the project directory; Output: Vite dev server running locally.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/cli.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nvite [root]\n```\n\n----------------------------------------\n\nTITLE: Configuring Qwik CSR Mode in Vite - TypeScript\nDESCRIPTION: This TypeScript snippet configures Vite to use the Qwik plugin with client-side rendering (CSR) enabled. It uses 'defineConfig' to export the configuration object, where the 'qwikVite' plugin is initialized with 'csr: true'. Dependencies include Vite, the Qwik Vite plugin, and the project's environment must support TypeScript. Key parameter 'csr: true' enables CSR, making the application fully browser-bootstrapped. The output of this configuration enables development or build of a pure client-rendered Qwik app; server-side rendering features are not enabled here.\nSOURCE: https://github.com/vitejs/vite/blob/main/packages/create-vite/template-qwik-ts/README.md#2025-04-22_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport default defineConfig({\n  plugins: [\n    qwikVite({\n      csr: true,\n    }),\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: DevEnvironment Class Structure in TypeScript\nDESCRIPTION: Defines the structure of the DevEnvironment class used in Vite. It includes properties like name, hot channel, module graph, plugins, and methods for transforming and warming up requests.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-environment-instances.md#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nclass DevEnvironment {\n  /**\n   * Unique identifier for the environment in a Vite server.\n   * By default Vite exposes 'client' and 'ssr' environments.\n   */\n  name: string\n  /**\n   * Communication channel to send and receive messages from the\n   * associated module runner in the target runtime.\n   */\n  hot: NormalizedHotChannel\n  /**\n   * Graph of module nodes, with the imported relationship between\n   * processed modules and the cached result of the processed code.\n   */\n  moduleGraph: EnvironmentModuleGraph\n  /**\n   * Resolved plugins for this environment, including the ones\n   * created using the per-environment `create` hook\n   */\n  plugins: Plugin[]\n  /**\n   * Allows to resolve, load, and transform code through the\n   * environment plugins pipeline\n   */\n  pluginContainer: EnvironmentPluginContainer\n  /**\n   * Resolved config options for this environment. Options at the server\n   * global scope are taken as defaults for all environments, and can\n   * be overridden (resolve conditions, external, optimizedDeps)\n   */\n  config: ResolvedConfig & ResolvedDevEnvironmentOptions\n\n  constructor(\n    name: string,\n    config: ResolvedConfig,\n    context: DevEnvironmentContext,\n  )\n\n  /**\n   * Resolve the URL to an id, load it, and process the code using the\n   * plugins pipeline. The module graph is also updated.\n   */\n  async transformRequest(url: string): Promise<TransformResult | null>\n\n  /**\n   * Register a request to be processed with low priority. This is useful\n   * to avoid waterfalls. The Vite server has information about the\n   * imported modules by other requests, so it can warmup the module graph\n   * so the modules are already processed when they are requested.\n   */\n  async warmupRequest(url: string): Promise<void>\n}\n```\n\n----------------------------------------\n\nTITLE: Handling HMR for SSR-only Modules in Vite with TypeScript\nDESCRIPTION: This snippet demonstrates a custom Vite plugin for handling hot module replacement (HMR) updates. The plugin specifically targets SSR-only modules to prevent unnecessary client-side reloading. It requires the 'vite' library, and uses the Plugin and EnvironmentModuleNode types from Vite. Inputs include a list of modules, and the server and timestamp context. The output is a server-sent 'full-reload' signal if SSR-only modules are invalidated.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/migration.md#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { Plugin, EnvironmentModuleNode } from 'vite'\\n\\nfunction hmrReload(): Plugin {\\n  return {\\n    name: 'hmr-reload',\\n    enforce: 'post',\\n    hotUpdate: {\\n      order: 'post',\\n      handler({ modules, server, timestamp }) {\\n        if (this.environment.name !== 'ssr') return\\n\\n        let hasSsrOnlyModules = false\\n\\n        const invalidatedModules = new Set<EnvironmentModuleNode>()\\n        for (const mod of modules) {\\n          if (mod.id == null) continue\\n          const clientModule =\\n            server.environments.client.moduleGraph.getModuleById(mod.id)\\n          if (clientModule != null) continue\\n\\n          this.environment.moduleGraph.invalidateModule(\\n            mod,\\n            invalidatedModules,\\n            timestamp,\\n            true,\\n          )\\n          hasSsrOnlyModules = true\\n        }\\n\\n        if (hasSsrOnlyModules) {\\n          server.ws.send({ type: 'full-reload' })\\n          return []\\n        }\\n      },\\n    },\\n  }\\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Script as Web Worker in JavaScript\nDESCRIPTION: Shows how to import scripts as web workers using the ?worker suffix. The imported worker will be in a separate chunk in the production build.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/assets.md#2025-04-22_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport Worker from './shader.js?worker'\nconst worker = new Worker()\n```\n\n----------------------------------------\n\nTITLE: Vite Plugin for Virtual Index HTML Transformation\nDESCRIPTION: Illustrates creating a Vite plugin for transforming the virtual index HTML file. It utilizes server APIs for file watching and index HTML transformation, demonstrating dependency on a Vite development server.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-environment-frameworks.md#2025-04-22_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nfunction vitePluginVirtualIndexHtml(): Plugin {\n  let server: ViteDevServer | undefined\n  return {\n    name: vitePluginVirtualIndexHtml.name,\n    configureServer(server_) {\n      server = server_\n    },\n    resolveId(source) {\n      return source === 'virtual:index-html' ? '\\0' + source : undefined\n    },\n    async load(id) {\n      if (id === '\\0' + 'virtual:index-html') {\n        let html: string\n        if (server) {\n          this.addWatchFile('index.html')\n          html = fs.readFileSync('index.html', 'utf-8')\n          html = await server.transformIndexHtml('/', html)\n        } else {\n          html = fs.readFileSync('dist/client/index.html', 'utf-8')\n        }\n        return `export default ${JSON.stringify(html)}`\n      }\n      return\n    },\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Cleaning Up Side Effects with hot.dispose in JavaScript\nDESCRIPTION: This example shows how to use hot.dispose to clean up any persistent side effects created by a module when it's about to be replaced.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-hmr.md#2025-04-22_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nfunction setupSideEffect() {}\n\nsetupSideEffect()\n\nif (import.meta.hot) {\n  import.meta.hot.dispose((data) => {\n    // cleanup side effect\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Scaffolding Vite Project using npm\nDESCRIPTION: Initializes a new Vite project interactively using npm's `create` command. It prompts the user for project name, framework selection, and variant (e.g., TypeScript). Requires Node.js 18+/20+.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/index.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ npm create vite@latest\n```\n\n----------------------------------------\n\nTITLE: Integrating Vite Middleware Mode with Express\nDESCRIPTION: This JavaScript snippet shows how to set up Vite in middleware mode and integrate it with an Express server. It involves creating an Express application, initializing Vite using `createViteServer` with `server: { middlewareMode: true }` and `appType: 'custom'`, and then using `vite.middlewares` within the Express app. A placeholder route demonstrates where custom response handling would be needed when `appType` is 'custom'.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/config/server-options.md#2025-04-22_snippet_4\n\nLANGUAGE: js\nCODE:\n```\nimport express from 'express'\nimport { createServer as createViteServer } from 'vite'\n\nasync function createServer() {\n  const app = express()\n\n  // Create Vite server in middleware mode\n  const vite = await createViteServer({\n    server: { middlewareMode: true },\n    // don't include Vite's default HTML handling middlewares\n    appType: 'custom',\n  })\n  // Use vite's connect instance as middleware\n  app.use(vite.middlewares)\n\n  app.use('*', async (req, res) => {\n    // Since `appType` is `'custom'`, should serve response here.\n    // Note: if `appType` is `'spa'` or `'mpa'`, Vite includes middlewares\n    // to handle HTML requests and 404s so user middlewares should be added\n    // before Vite's middlewares to take effect instead\n  })\n}\n\ncreateServer()\n```\n\n----------------------------------------\n\nTITLE: Accessing Environment in Server Code\nDESCRIPTION: Demonstrates how to access the SSR environment from the server context.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-environment-runtimes.md#2025-04-22_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst ssrEnvironment = server.environments.ssr\n```\n\n----------------------------------------\n\nTITLE: Eager Glob Import in Vite\nDESCRIPTION: Shows how to use eager loading with glob imports by passing the eager:true option. This causes Vite to transform the imports into direct module imports rather than lazy-loaded chunks.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/features.md#2025-04-22_snippet_19\n\nLANGUAGE: javascript\nCODE:\n```\nconst modules = import.meta.glob('./dir/*.js', { eager: true })\n```\n\nLANGUAGE: javascript\nCODE:\n```\n// code produced by vite\nimport * as __vite_glob_0_0 from './dir/bar.js'\nimport * as __vite_glob_0_1 from './dir/foo.js'\nconst modules = {\n  './dir/bar.js': __vite_glob_0_0,\n  './dir/foo.js': __vite_glob_0_1\n}\n```\n\n----------------------------------------\n\nTITLE: Previewing a Built Vite Application Locally\nDESCRIPTION: Command to preview the production build locally using Vite's built-in preview server, which serves the static files from the dist directory.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/static-deploy.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ npm run preview\n```\n\n----------------------------------------\n\nTITLE: Including Deep Imports for Pre-bundling in Vite (JavaScript)\nDESCRIPTION: Demonstrates how to use glob patterns to include deep imports from a library for pre-bundling in Vite. This can improve performance by avoiding constant pre-bundling of new deep imports.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/config/dep-optimization-options.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  optimizeDeps: {\n    include: ['my-lib/components/**/*.vue'],\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Watch Options for Vite Build\nDESCRIPTION: Demonstrates how to enable and configure Rollup's watcher options in the Vite configuration file. This allows developers to set up automatic rebuilds when source files change.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/build.md#2025-04-22_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nexport default defineConfig({\n  build: {\n    watch: {\n      // https://rollupjs.org/configuration-options/#watch\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Registering Cleanup Callback with hot.prune in JavaScript\nDESCRIPTION: This snippet demonstrates how to use hot.prune to register a callback that will be called when the module is no longer imported on the page, useful for cleaning up side effects.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-hmr.md#2025-04-22_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nfunction setupOrReuseSideEffect() {}\n\nsetupOrReuseSideEffect()\n\nif (import.meta.hot) {\n  import.meta.hot.prune((data) => {\n    // cleanup side effect\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing an Environment-Aware Plugin Counter Using Vite Helper in JavaScript\nDESCRIPTION: This snippet demonstrates the use of Vite's 'perEnvironmentState' helper to simplify the implementation of an environment-aware plugin. It provides a more concise way to manage state across different environments.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/changes/shared-plugins-during-build.md#2025-04-22_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nfunction PerEnvironmentCountTransformedModulesPlugin() {\n  const state = perEnvironmentState<{ count: number }>(() => ({ count: 0 }))\n  return {\n    name: 'count-transformed-modules',\n    perEnvironmentStartEndDuringDev: true,\n    buildStart() {\n      state(this).count = 0\n    }\n    transform(id) {\n      state(this).count++\n    },\n    buildEnd() {\n      console.log(this.environment.name, state(this).count)\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Module Preload Dependencies Resolution in Vite\nDESCRIPTION: This configuration example demonstrates how to use the experimental resolveDependencies function to control module preloading behavior in Vite.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/config/build-options.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n/** @type {import('vite').UserConfig} */\nconst config = {\n  // prettier-ignore\n  build: {\nmodulePreload: {\n  resolveDependencies: (filename, deps, { hostId, hostType }) => {\n    return deps.filter(condition)\n  },\n},\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Using perEnvironmentPlugin Helper (JavaScript)\nDESCRIPTION: Demonstrates the use of the perEnvironmentPlugin helper to simplify creating per-environment plugins. This example creates a new instance of a non-shareable plugin for each environment.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-environment-plugins.md#2025-04-22_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nimport { nonShareablePlugin } from 'non-shareable-plugin'\n\nexport default defineConfig({\n  plugins: [\n    perEnvironmentPlugin('per-environment-plugin', (environment) =>\n      nonShareablePlugin({ outputName: environment.name }),\n    ),\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Adding React-Specific ESLint Plugins in Vite\nDESCRIPTION: This snippet demonstrates the integration of React-specific ESLint plugins `eslint-plugin-react-x` and `eslint-plugin-react-dom` in a Vite project. The configuration file imports these plugins and includes their recommended rules for TypeScript. The setup enhances linting with React-specific guidelines. It requires the installation of the plugins via NPM or similar package management systems.\nSOURCE: https://github.com/vitejs/vite/blob/main/packages/create-vite/template-react-ts/README.md#2025-04-22_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\n// eslint.config.js\nimport reactX from 'eslint-plugin-react-x'\nimport reactDom from 'eslint-plugin-react-dom'\n\nexport default tseslint.config({\n  plugins: {\n    // Add the react-x and react-dom plugins\n    'react-x': reactX,\n    'react-dom': reactDom,\n  },\n  rules: {\n    // other rules...\n    // Enable its recommended typescript rules\n    ...reactX.configs['recommended-typescript'].rules,\n    ...reactDom.configs.recommended.rules,\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Starting Vite Dev Server via CLI using npx\nDESCRIPTION: Starts the Vite development server using `npx`, which executes the `vite` command either from the local `node_modules/.bin` directory or by fetching it temporarily. This is used after manually installing Vite or in projects where Vite is a dependency.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/index.md#2025-04-22_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\n$ npx vite\n```\n\n----------------------------------------\n\nTITLE: Configuring CSS Pre-Processor Options in Vite - JavaScript\nDESCRIPTION: This snippet demonstrates how to use defineConfig to customize options for CSS pre-processors in Vite, such as less, styl, and scss. It sets options like Less math parsing, Stylus color definitions, and SCSS API mode and importers list. Requires Vite as a dependency and relevant pre-processor packages installed. Inputs are pre-processor option objects, output is a config object passed to Vite.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/config/shared-options.md#2025-04-22_snippet_3\n\nLANGUAGE: js\nCODE:\n```\nexport default defineConfig({\n  css: {\n    preprocessorOptions: {\n      less: {\n        math: 'parens-division',\n      },\n      styl: {\n        define: {\n          $specialColor: new stylus.nodes.RGBA(51, 197, 255, 1),\n        },\n      },\n      scss: {\n        api: 'modern-compiler', // or \"modern\", \"legacy\"\n        importers: [\n          // ...\n        ],\n      },\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Guarding HMR API Usage in JavaScript\nDESCRIPTION: This snippet demonstrates how to conditionally guard HMR API usage to ensure the code can be tree-shaken in production builds.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-hmr.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nif (import.meta.hot) {\n  // HMR code\n}\n```\n\n----------------------------------------\n\nTITLE: Importing and Initializing WebAssembly Modules with Vite - JavaScript\nDESCRIPTION: This snippet demonstrates how to import and initialize a WebAssembly (WASM) module using Vite's revised import API with the '?init' query. The 'init' function asynchronously loads the compiled WASM asset and provides an instance with exported functions, such as 'test'. To use this, ensure you have a compatible wasm module and Vite 3 or later. The main parameter is the path to the WASM file, and the output is an instance with accessible WASM exports. This approach avoids future specification conflicts and improves flexibility, but requires the project's build system to be Vite with relevant WASM plugin support.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/blog/announcing-vite3.md#2025-04-22_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport init from './example.wasm?init'\n\ninit().then((instance) => {\n  instance.exports.test()\n})\n```\n\n----------------------------------------\n\nTITLE: Production Mode Env Variable Declaration - ENV\nDESCRIPTION: Defines a mode-specific environment variable for use when running `vite build` in production mode. Only applies during production-mode builds and is accessed by name (e.g., `VITE_APP_TITLE`). Useful for customizing output or behavior based on the build target.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/env-and-mode.md#2025-04-22_snippet_7\n\nLANGUAGE: env\nCODE:\n```\nVITE_APP_TITLE=My App\n```\n\n----------------------------------------\n\nTITLE: Handling Virtual Modules in Vite\nDESCRIPTION: Demonstrates how to create a virtual module in Vite using its plugin system. It bypasses the need for traditional imports by leveraging Vite's virtual module feature and runtime checks.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-environment-frameworks.md#2025-04-22_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// code using the Vite's APIs\nimport { createServer } from 'vite'\n\nconst server = createServer({\n  plugins: [\n    // a plugin that handles `virtual:entrypoint`\n    {\n      name: 'virtual-module',\n      /* plugin implementation */\n    },\n  ],\n})\nconst ssrEnvironment = server.environment.ssr\nconst input = {}\n\n// use exposed functions by each environment factories that runs the code\n// check for each environment factories what they provide\nif (ssrEnvironment instanceof RunnableDevEnvironment) {\n  ssrEnvironment.runner.import('virtual:entrypoint')\n} else if (ssrEnvironment instanceof CustomDevEnvironment) {\n  ssrEnvironment.runEntrypoint('virtual:entrypoint')\n} else {\n  throw new Error(`Unsupported runtime for ${ssrEnvironment.name}`)\n}\n\nconst { createHandler } = await import('./entrypoint.js')\nconst handler = createHandler(input)\nconst response = handler(new Request('/'))\n\n// -------------------------------------\n// ./entrypoint.js\nexport function createHandler(input) {\n  return function handler(req) {\n    return new Response('hello')\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting Vite Dev Server via CLI using pnpm\nDESCRIPTION: Starts the Vite development server by invoking the `vite` binary directly using pnpm. This assumes `vite` is installed as a dependency in the project.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/index.md#2025-04-22_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\n$ pnpm vite\n```\n\n----------------------------------------\n\nTITLE: Accessing Environment Config in Transform Hook (TypeScript)\nDESCRIPTION: Demonstrates how to access the environment configuration within a plugin's transform hook. This snippet shows how to log the resolve conditions for the current environment.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-environment-plugins.md#2025-04-22_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntransform(code, id) {\n  console.log(this.environment.config.resolve.conditions)\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Web Workers as Inlined Base64 Strings in Vite (JavaScript)\nDESCRIPTION: This code snippet imports a Web Worker but instructs Vite to inline the worker code as a base64 string at build time by appending both ?worker and &inline to the import path. The result is a Worker initialized from an inlined script, useful for optimizing bundle size and loading behavior. Inputs and outputs are similar to the worker import. Ensure this pattern fits browser memory/bundle limitations.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/features.md#2025-04-22_snippet_16\n\nLANGUAGE: javascript\nCODE:\n```\nimport 'vite/client'\\n// ---cut---\\n// Web Workers inlined as base64 strings at build time\\nimport InlineWorker from './worker.js?worker&inline'\n```\n\n----------------------------------------\n\nTITLE: Normalizing Paths in TypeScript\nDESCRIPTION: This function normalizes file paths so they can be used smoothly across different Vite plugins, ensuring compatibility.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-javascript.md#2025-04-22_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction normalizePath(id: string): string\n```\n\n----------------------------------------\n\nTITLE: Specifying Named Imports in import.meta.glob for Tree-Shaking\nDESCRIPTION: Illustrates how to use named imports in import.meta.glob to improve tree-shaking by importing only specific exports from matched modules.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/blog/announcing-vite3.md#2025-04-22_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport.meta.glob('./dir/*.js', { import: 'setup' })\n```\n\n----------------------------------------\n\nTITLE: Staging Mode Env Variable Declaration - ENV\nDESCRIPTION: Specifies a staging-specific environment variable configuration for use when building with `vite build --mode staging`. Configures the app's title or other behavior for the staging environment, maintaining separation from production values.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/env-and-mode.md#2025-04-22_snippet_9\n\nLANGUAGE: env\nCODE:\n```\nVITE_APP_TITLE=My App (staging)\n```\n\n----------------------------------------\n\nTITLE: Configuring Build Command and Publish Directory for Render Deployment\nDESCRIPTION: Specifies the necessary build command and publish directory settings when deploying a Vite application as a Static Site on Render. The build command uses npm to install dependencies and run the build script defined in `package.json`. The publish directory indicates that the built static assets are located in the `dist` folder.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/static-deploy.md#2025-04-22_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\n# Build Command for Render\nnpm install && npm run build\n```\n\nLANGUAGE: plaintext\nCODE:\n```\n# Publish Directory for Render\ndist\n```\n\n----------------------------------------\n\nTITLE: Scaffolding Specific Vite Project Template using Yarn\nDESCRIPTION: Creates a new Vite project named 'my-vue-app' using the 'vue' template directly via command-line arguments with Yarn. Requires Node.js 18+/20+.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/index.md#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ yarn create vite my-vue-app --template vue\n```\n\n----------------------------------------\n\nTITLE: Managing Preview Server Configuration in Vite with JavaScript\nDESCRIPTION: This snippet demonstrates the `configurePreviewServer` hook, which parallels `configureServer` but targets the Vite preview server. It allows injecting middleware before or after other middlewares by returning a function. The snippet highlights adding post-middlewares, depending on whether they should run before or after server setup.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-plugin.md#2025-04-22_snippet_8\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst myPlugin = () => ({\n  name: 'configure-preview-server',\n  configurePreviewServer(server) {\n    // return a post hook that is called after other middlewares are\n    // installed\n    return () => {\n      server.middlewares.use((req, res, next) => {\n        // custom handle request...\n      })\n    }\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Defining UserConfig Interface in TypeScript\nDESCRIPTION: TypeScript interface definition for UserConfig, extending EnvironmentOptions and including the new 'environments' configuration option.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-environment.md#2025-04-22_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ninterface UserConfig extends EnvironmentOptions {\n  environments: Record<string, EnvironmentOptions>\n  // other options\n}\n```\n\n----------------------------------------\n\nTITLE: Using TypeScript Type Inference for Custom Events\nDESCRIPTION: Demonstrates how to use TypeScript type inference for custom event payloads in Vite HMR API.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-plugin.md#2025-04-22_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\ntype CustomFooPayload = InferCustomEventPayload<'custom:foo'>\nimport.meta.hot?.on('custom:foo', (payload) => {\n  // The type of payload will be { msg: string }\n})\nimport.meta.hot?.on('unknown:event', (payload) => {\n  // The type of payload will be any\n})\n```\n\n----------------------------------------\n\nTITLE: Enabling Eager Imports in import.meta.glob\nDESCRIPTION: Shows how to use the new eager flag in import.meta.glob to perform eager imports of matched modules.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/blog/announcing-vite3.md#2025-04-22_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport.meta.glob('./dir/*.js', { eager: true })\n```\n\n----------------------------------------\n\nTITLE: Setting Custom Development Server Origin in Vite\nDESCRIPTION: This JavaScript snippet shows how to configure the `server.origin` option in `vite.config.js`. It sets a specific origin ('http://127.0.0.1:8080') that will be used for generating asset URLs during development, overriding the default behavior which typically derives the origin from the server's host and port.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/config/server-options.md#2025-04-22_snippet_7\n\nLANGUAGE: js\nCODE:\n```\nexport default defineConfig({\n  server: {\n    origin: 'http://127.0.0.1:8080',\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Environment in ConfigEnvironment Hook (TypeScript)\nDESCRIPTION: Illustrates how to configure a specific environment using the configEnvironment hook. This example sets resolve conditions for the 'rsc' environment.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-environment-plugins.md#2025-04-22_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconfigEnvironment(name: string, options: EnvironmentOptions) {\n  if (name === 'rsc') {\n    options.resolve.conditions = // ...\n\n```\n\n----------------------------------------\n\nTITLE: Updating package.json CSS file reference for library mode\nDESCRIPTION: Example showing how to update the CSS file reference in package.json exports field when migrating from Vite 5 to Vite 6. In Vite 6, CSS output filenames in library mode are based on the package name rather than the fixed 'style.css'.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/migration.md#2025-04-22_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"name\": \"my-lib\",\n  \"exports\": {\n    \"./style.css\": \"./dist/style.css\" // [!code --]\n    \"./style.css\": \"./dist/my-lib.css\" // [!code ++]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Establishing Worker-Based DevEnvironment Communication in Vite using JavaScript\nDESCRIPTION: Demonstrates creating an environment in Vite through a DevEnvironment, where communication with a worker is handled via message passing using worker.on and worker.postMessage. A custom hot channel is created for managing event listeners and sending data between server and worker contexts using Node.js BroadcastChannel and worker_threads. The code requires Vite server APIs and manages event subscriptions and clean-up for hot-module reload scenarios.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-environment-runtimes.md#2025-04-22_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nimport { BroadcastChannel } from 'node:worker_threads'\\nimport { createServer, RemoteEnvironmentTransport, DevEnvironment } from 'vite'\\n\\nfunction createWorkerEnvironment(name, config, context) {\\n  const worker = new Worker('./worker.js')\\n  const handlerToWorkerListener = new WeakMap()\\n\\n  const workerHotChannel = {\\n    send: (data) => worker.postMessage(data),\\n    on: (event, handler) => {\\n      if (event === 'connection') return\\n\\n      const listener = (value) => {\\n        if (value.type === 'custom' && value.event === event) {\\n          const client = {\\n            send(payload) {\\n              worker.postMessage(payload)\\n            },\\n          }\\n          handler(value.data, client)\\n        }\\n      }\\n      handlerToWorkerListener.set(handler, listener)\\n      worker.on('message', listener)\\n    },\\n    off: (event, handler) => {\\n      if (event === 'connection') return\\n      const listener = handlerToWorkerListener.get(handler)\\n      if (listener) {\\n        worker.off('message', listener)\\n        handlerToWorkerListener.delete(handler)\\n      }\\n    },\\n  }\\n\\n  return new DevEnvironment(name, config, {\\n    transport: workerHotChannel,\\n  })\\n}\\n\\nawait createServer({\\n  environments: {\\n    worker: {\\n      dev: {\\n        createEnvironment: createWorkerEnvironment,\\n      },\\n    },\\n  },\\n})\n```\n\n----------------------------------------\n\nTITLE: Custom Logger Filtering in Vite Configuration - TypeScript\nDESCRIPTION: This snippet customizes Vite's logging behavior using the createLogger API; it overrides the warn method to suppress warnings about empty CSS files. The config is returned via defineConfig. Inputs include warning messages; output is filtered console logging. Requires Vite's TypeScript types and APIs.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/config/shared-options.md#2025-04-22_snippet_8\n\nLANGUAGE: ts\nCODE:\n```\nimport { createLogger, defineConfig } from 'vite'\n\nconst logger = createLogger()\nconst loggerWarn = logger.warn\n\nlogger.warn = (msg, options) => {\n  // Ignore empty CSS files warning\n  if (msg.includes('vite:css') && msg.includes(' is empty')) return\n  loggerWarn(msg, options)\n}\n\nexport default defineConfig({\n  customLogger: logger,\n})\n```\n\n----------------------------------------\n\nTITLE: Example Barrel File in JavaScript\nDESCRIPTION: An example of a barrel file that re-exports APIs from multiple files in the same directory. This pattern can cause performance issues as it loads all files even when only one export is needed.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/performance.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nexport * from './color.js'\nexport * from './dom.js'\nexport * from './slash.js'\n```\n\n----------------------------------------\n\nTITLE: Cloudflare Pages Deployment with Wrangler CLI\nDESCRIPTION: Series of commands to set up and deploy a Vite application to Cloudflare Pages using the Wrangler CLI.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/static-deploy.md#2025-04-22_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n# Install Wrangler CLI\n$ npm install -g wrangler\n\n# Login to Cloudflare account from CLI\n$ wrangler login\n\n# Run your build command\n$ npm run build\n\n# Create new deployment\n$ npx wrangler pages deploy dist\n```\n\n----------------------------------------\n\nTITLE: Defining EnvironmentOptions Interface in TypeScript\nDESCRIPTION: TypeScript interface definition for EnvironmentOptions, showing the structure of environment-specific configuration options in Vite.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-environment.md#2025-04-22_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ninterface EnvironmentOptions {\n  define?: Record<string, any>\n  resolve?: EnvironmentResolveOptions\n  optimizeDeps: DepOptimizationOptions\n  consumer?: 'client' | 'server'\n  dev: DevOptions\n  build: BuildOptions\n}\n```\n\n----------------------------------------\n\nTITLE: Reverse Order Variable Expansion in .env Files - ENV\nDESCRIPTION: Demonstrates that Vite (via dotenv-expand) supports reverse-order variable expansion, unlike most shells and other tools. `VITE_FOO` references `VITE_BAR` which is defined later in the file; Vite expands this as expected. This is a Vite-specific behavior and should not be relied on for maximum portability.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/env-and-mode.md#2025-04-22_snippet_3\n\nLANGUAGE: env\nCODE:\n```\nVITE_FOO=foo${VITE_BAR}\\nVITE_BAR=bar\n```\n\n----------------------------------------\n\nTITLE: Creating a Vite Project with NPM\nDESCRIPTION: This snippet demonstrates how to scaffold a new Vite project using NPM. Ensure Node.js version 18+ is installed. Follow the prompts after running the command to complete the setup.\nSOURCE: https://github.com/vitejs/vite/blob/main/packages/create-vite/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm create vite@latest\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Environment Instances in Vite\nDESCRIPTION: Example of using a custom environment provider to configure a specific environment (SSR in this case) with custom build options.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-environment.md#2025-04-22_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport { customEnvironment } from 'vite-environment-provider'\n\nexport default {\n  build: {\n    outDir: '/dist/client',\n  },\n  environments: {\n    ssr: customEnvironment({\n      build: {\n        outDir: '/dist/ssr',\n      },\n    }),\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Scaffolding Vite Project using Bun\nDESCRIPTION: Initializes a new Vite project interactively using Bun's `create` command. It prompts the user for project name, framework selection, and variant (e.g., TypeScript). Requires Node.js 18+/20+.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/index.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ bun create vite\n```\n\n----------------------------------------\n\nTITLE: Netlify CLI Commands for Deployment\nDESCRIPTION: Sequence of Netlify CLI commands to install the CLI, initialize a new site, and deploy a Vite application to Netlify.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/static-deploy.md#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n# Install the Netlify CLI\n$ npm install -g netlify-cli\n\n# Create a new site in Netlify\n$ ntl init\n\n# Deploy to a unique preview URL\n$ ntl deploy\n```\n\n----------------------------------------\n\nTITLE: Inlining SVG URL in JavaScript\nDESCRIPTION: Shows how to use an imported SVG URL within a manually constructed url() function for setting a background style. The URL needs to be wrapped in double quotes.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/assets.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport imgUrl from './img.svg'\ndocument.getElementById('hero-img').style.background = `url(\"${imgUrl}\")`\n```\n\n----------------------------------------\n\nTITLE: Development Mode Declaration in Testing Env - ENV\nDESCRIPTION: Sets the `NODE_ENV` to development in a `.env.testing` file. This can be used to force development-mode behaviors when running Vite builds with `--mode testing`. `NODE_ENV` is used internally and can be accessed by backend code or Vite plugins/config.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/env-and-mode.md#2025-04-22_snippet_10\n\nLANGUAGE: env\nCODE:\n```\nNODE_ENV=development\n```\n\n----------------------------------------\n\nTITLE: Handling HTTP Invoke Requests on Vite Server in TypeScript\nDESCRIPTION: Shows a server handler in Vite that listens for HTTP requests to the '/invoke' endpoint, parses the request body as HotPayload, hands it off to the DevEnvironment's hot channel, and returns the result as a JSON response. Expects a Request object (from Node.js or web framework), and relies on DevEnvironment and its hot.handleInvoke method. For non-invoke paths, a generic error response is returned. This code is intended for environments using the HTTP-based runner transport.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-environment-runtimes.md#2025-04-22_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nconst customEnvironment = new DevEnvironment(name, config, context)\\n\\nserver.onRequest((request: Request) => {\\n  const url = new URL(request.url)\\n  if (url.pathname === '/invoke') {\\n    const payload = (await request.json()) as HotPayload\\n    const result = customEnvironment.hot.handleInvoke(payload)\\n    return new Response(JSON.stringify(result))\\n  }\\n  return Response.error()\\n})\n```\n\n----------------------------------------\n\nTITLE: Collecting Used Modules in Vue SSR Render Context (JavaScript)\nDESCRIPTION: This snippet, for use with `@vitejs/plugin-vue`, demonstrates how to gather the set of module IDs used during a Vue SSR render by checking `ctx.modules` after calling the framework's `renderToString` method. This enables advanced asset manifest usage, such as generating HTTP preload headers in production.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/ssr.md#2025-04-22_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nconst ctx = {}\\nconst html = await vueServerRenderer.renderToString(app, ctx)\\n// ctx.modules is now a Set of module IDs that were used during the render\n```\n\n----------------------------------------\n\nTITLE: Configuring Server File Warming in Vite\nDESCRIPTION: This JavaScript snippet demonstrates how to configure the `server.warmup` option within a Vite configuration file (`vite.config.js`). It specifies arrays of file paths or glob patterns for `clientFiles` and `ssrFiles` to be pre-transformed and cached by the Vite dev server upon startup, improving initial load performance.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/config/server-options.md#2025-04-22_snippet_3\n\nLANGUAGE: js\nCODE:\n```\nexport default defineConfig({\n  server: {\n    warmup: {\n      clientFiles: ['./src/components/*.vue', './src/utils/big-utils.js'],\n      ssrFiles: ['./src/server/modules/*.js'],\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Using Environment Factory in Vite Config\nDESCRIPTION: Shows how to use the workerd environment factory in a Vite configuration file to set up SSR and RSC environments.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-environment-runtimes.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createWorkerdEnvironment } from 'vite-environment-workerd'\n\nexport default {\n  environments: {\n    ssr: createWorkerdEnvironment({\n      build: {\n        outDir: '/dist/ssr',\n      },\n    }),\n    rsc: createWorkerdEnvironment({\n      build: {\n        outDir: '/dist/rsc',\n      },\n    }),\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Netlify Production Deployment Command\nDESCRIPTION: Command to deploy a Vite application to production on Netlify using the CLI with the --prod flag.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/static-deploy.md#2025-04-22_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n# Deploy the site into production\n$ ntl deploy --prod\n```\n\n----------------------------------------\n\nTITLE: Testing Asset Import and DOM Manipulation in Vitest - JavaScript\nDESCRIPTION: This Vitest test asserts that importing an SVG as raw text and writing it to the page results in the DOM containing the expected 'SVG' substring. It uses async/await to retrieve the text content of a .raw element as setup in the HTML, integrating Playwright to interface with the browser. Dependencies: Vitest, Playwright, and a properly set up test scenario. Inputs: Rendered environment with injected SVG contents. Outputs: Test passes if injection succeeded.\nSOURCE: https://github.com/vitejs/vite/blob/main/CONTRIBUTING.md#2025-04-22_snippet_6\n\nLANGUAGE: js\nCODE:\n```\ntest('?raw import', async () => {\n  expect(await page.textContent('.raw')).toMatch('SVG')\n})\n```\n\n----------------------------------------\n\nTITLE: Scaffolding Vite + Vue Project\nDESCRIPTION: These commands show how to scaffold a Vite project with a Vue template using different package managers. Ensure that Node.js version 18+ is installed.\nSOURCE: https://github.com/vitejs/vite/blob/main/packages/create-vite/README.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n# npm 7+, extra double-dash is needed:\nnpm create vite@latest my-vue-app -- --template vue\n\n# yarn\nyarn create vite my-vue-app --template vue\n\n# pnpm\npnpm create vite my-vue-app --template vue\n\n# Bun\nbun create vite my-vue-app --template vue\n```\n\n----------------------------------------\n\nTITLE: EnvironmentModuleNode Class in TypeScript\nDESCRIPTION: Defines the EnvironmentModuleNode class representing a module in the environment's module graph. It includes properties for module identification, imports, exports, and HMR-related information.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-environment-instances.md#2025-04-22_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nclass EnvironmentModuleNode {\n  environment: string\n\n  url: string\n  id: string | null = null\n  file: string | null = null\n\n  type: 'js' | 'css'\n\n  importers = new Set<EnvironmentModuleNode>()\n  importedModules = new Set<EnvironmentModuleNode>()\n  importedBindings: Map<string, Set<string>> | null = null\n\n  info?: ModuleInfo\n  meta?: Record<string, any>\n  transformResult: TransformResult | null = null\n\n  acceptedHmrDeps = new Set<EnvironmentModuleNode>()\n  acceptedHmrExports: Set<string> | null = null\n  isSelfAccepting?: boolean\n  lastHMRTimestamp = 0\n  lastInvalidationTimestamp = 0\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SSR External Dependencies in Vite\nDESCRIPTION: Specifies how to externalize dependencies for SSR. Can be an array of strings or true to externalize all dependencies. Takes precedence over noExternal for explicitly listed dependencies.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/config/ssr-options.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n## ssr.external\n\n- **Type:** `string[] | true`\n- **Related:** [SSR Externals](/guide/ssr#ssr-externals)\n```\n\n----------------------------------------\n\nTITLE: Receiving Server Messages in Client-Side Code\nDESCRIPTION: Shows how to listen for custom events sent from the server in client-side code using the Hot Module Replacement API.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-plugin.md#2025-04-22_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\n// client side\nif (import.meta.hot) {\n  import.meta.hot.on('my:greetings', (data) => {\n    console.log(data.msg) // hello\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Asset Links in HTML Template for Production\nDESCRIPTION: Demonstrates how to use the manifest file to render proper asset links in the HTML template for production builds.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/backend-integration.md#2025-04-22_snippet_5\n\nLANGUAGE: html\nCODE:\n```\n<!-- if production -->\n\n<!-- for cssFile of manifest[name].css -->\n<link rel=\"stylesheet\" href=\"/{{ cssFile }}\" />\n\n<!-- for chunk of importedChunks(manifest, name) -->\n<!-- for cssFile of chunk.css -->\n<link rel=\"stylesheet\" href=\"/{{ cssFile }}\" />\n\n<script type=\"module\" src=\"/{{ manifest[name].file }}\"></script>\n\n<!-- for chunk of importedChunks(manifest, name) -->\n<link rel=\"modulepreload\" href=\"/{{ chunk.file }}\" />\n```\n\n----------------------------------------\n\nTITLE: Enabling SSR Manifest Generation in Vite Client Build (Diff Format)\nDESCRIPTION: This diff shows how to add the `--ssrManifest` flag to the Vite client build script in `package.json`. Enabling this flag ensures that the client build outputs a manifest mapping server module IDs to client assets, which is essential for generating correct preload directives and advanced asset management in production SSR scenarios.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/ssr.md#2025-04-22_snippet_5\n\nLANGUAGE: diff\nCODE:\n```\n- \\\"build:client\\\": \\\"vite build --outDir dist/client\\\",\\n+ \\\"build:client\\\": \\\"vite build --outDir dist/client --ssrManifest\\\",\n```\n\n----------------------------------------\n\nTITLE: TypeScript Interface for HotUpdateOptions in hotUpdate Hook\nDESCRIPTION: TypeScript interface that defines the structure of the HotUpdateOptions object passed to the hotUpdate hook, which extends the previous context with a type field indicating the watch event type (create, update, or delete) and environment-specific module nodes.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/changes/hotupdate-hook.md#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ninterface HotUpdateOptions {\n  type: 'create' | 'update' | 'delete'\n  file: string\n  timestamp: number\n  modules: Array<EnvironmentModuleNode>\n  read: () => string | Promise<string>\n  server: ViteDevServer\n}\n```\n\n----------------------------------------\n\nTITLE: Scaffolding a Vite App using PNPM\nDESCRIPTION: This command uses pnpm to execute the `create-vite` package, which interactively scaffolds a new Vite project. It allows users to choose a framework and variant to set up a basic development environment for testing Vite or starting a new application.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/blog/announcing-vite6.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npnpm create vite\n```\n\n----------------------------------------\n\nTITLE: DevEnvironmentContext Interface in TypeScript\nDESCRIPTION: Defines the DevEnvironmentContext interface used in the DevEnvironment class constructor. It includes properties for hot reloading, transport, options, remote runner, and dependencies optimizer.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-environment-instances.md#2025-04-22_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ninterface DevEnvironmentContext {\n  hot: boolean\n  transport?: HotChannel | WebSocketServer\n  options?: EnvironmentOptions\n  remoteRunner?: {\n    inlineSourceMap?: boolean\n  }\n  depsOptimizer?: DepsOptimizer\n}\n```\n\n----------------------------------------\n\nTITLE: Detecting rolldown-vite via Plugin Context in JavaScript\nDESCRIPTION: This snippet demonstrates how a Vite plugin can detect if it's running within the `rolldown-vite` environment by checking for the presence of `this.meta.rolldownVersion` within a plugin hook like `resolveId`. This allows for conditional logic execution based on whether Rolldown or Rollup is being used.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/rolldown.md#2025-04-22_snippet_6\n\nLANGUAGE: js\nCODE:\n```\nconst plugin = {\n  resolveId() {\n    if (this.meta.rolldownVersion) {\n      // logic for rolldown-vite\n    } else {\n      // logic for rollup-vite\n    }\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Using renderBuiltUrl for Runtime Asset URL Generation in TypeScript\nDESCRIPTION: Demonstrates the experimental `experimental.renderBuiltUrl` Vite configuration option in TypeScript (`vite.config.ts`). This function customizes how asset URLs are rendered in the built output based on context. For JavaScript files (`hostType === 'js'`), it returns an object with a `runtime` property containing JavaScript code (`window.__toCdnUrl(...)`) to dynamically determine the URL at runtime. For other asset types, it returns `{ relative: true }` to use relative paths.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/build.md#2025-04-22_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n```ts twoslash\nimport type { UserConfig } from 'vite'\n// prettier-ignore\nconst config: UserConfig = {\n// ---cut-before---\nexperimental: {\n  renderBuiltUrl(filename, { hostType }) {\n    if (hostType === 'js') {\n      return { runtime: `window.__toCdnUrl(${JSON.stringify(filename)})` }\n    } else {\n      return { relative: true }\n    }\n  },\n},\n// ---cut-after---\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Building Multiple Environments with Vite\nDESCRIPTION: Explains how to use the ViteBuilder to build multiple environments simultaneously using a custom build function. It leverages Vite's CLI options and requires a Vite setup in the project.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-environment-frameworks.md#2025-04-22_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nexport default {\n  builder: {\n    buildApp: async (builder) => {\n      const environments = Object.values(builder.environments)\n      return Promise.all(\n        environments.map((environment) => builder.build(environment)),\n      )\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Exporting Components from a JavaScript Library Entry File\nDESCRIPTION: Example of a library entry file (`lib/main.js`) that imports components (`Foo.vue`, `Bar.vue`) from other files within the library and exports them. This makes the components available for consumption by users importing the library. This file corresponds to the `entry` path specified in the Vite build configuration.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/build.md#2025-04-22_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\n```js [lib/main.js]\nimport Foo from './Foo.vue'\nimport Bar from './Bar.vue'\nexport { Foo, Bar }\n```\n```\n\n----------------------------------------\n\nTITLE: Basic Vite Configuration in JavaScript\nDESCRIPTION: The most basic Vite config file structure using JavaScript. It exports a default object with configuration options.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/config/index.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nexport default {\n  // config options\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Vite Project with PNPM\nDESCRIPTION: This snippet shows how to use PNPM for scaffolding a Vite project. After running the command, respond to the prompts to configure the project.\nSOURCE: https://github.com/vitejs/vite/blob/main/packages/create-vite/README.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npnpm create vite\n```\n\n----------------------------------------\n\nTITLE: Using withFilter to Optimize Plugin Performance\nDESCRIPTION: Demonstrates how to use the withFilter wrapper to reduce communication overhead between Rust and JavaScript runtimes by filtering plugin hooks to only process relevant files.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/rolldown.md#2025-04-22_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n// In your vite.config.ts\nimport { withFilter, defineConfig } from 'vite'\nimport svgr from 'vite-plugin-svgr'\n\nexport default defineConfig({\n  plugins: [\n    // Load the `svgr` plugin only for files which end in `.svg?react`\n    withFilter(\n      svgr({\n        /*...*/\n      }),\n      { load: { id: /\\.svg\\?react$/ } },\n    ),\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Installing Specific Vite Commit using npm (Bash)\nDESCRIPTION: This command demonstrates how to install a specific, unreleased commit of Vite as a development dependency using npm. Replace `SHA` with the desired commit hash obtained from the Vite repository (e.g., from https://github.com/vitejs/vite/commits/main/). The `pkg.pr.new` service facilitates installing package versions directly from commits, but only recent commits (within the last month) are available.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/index.md#2025-04-22_snippet_19\n\nLANGUAGE: bash\nCODE:\n```\n$ npm install -D https://pkg.pr.new/vite@SHA\n```\n\n----------------------------------------\n\nTITLE: Adapting Non-Shareable Plugin for Per-Environment Use (JavaScript)\nDESCRIPTION: Illustrates how to adapt a non-shareable plugin for per-environment use using the applyToEnvironment hook. This example creates a new instance of the plugin for each environment.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-environment-plugins.md#2025-04-22_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nimport { nonShareablePlugin } from 'non-shareable-plugin'\n\nexport default defineConfig({\n  plugins: [\n    {\n      name: 'per-environment-plugin',\n      applyToEnvironment(environment) {\n        return nonShareablePlugin({ outputName: environment.name })\n      },\n    },\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing importedChunks Function in TypeScript\nDESCRIPTION: Provides a TypeScript implementation of the importedChunks function to recursively retrieve imported chunks from the manifest.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/backend-integration.md#2025-04-22_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { Manifest, ManifestChunk } from 'vite'\n\nexport default function importedChunks(\n  manifest: Manifest,\n  name: string,\n): ManifestChunk[] {\n  const seen = new Set<string>()\n\n  function getImportedChunks(chunk: ManifestChunk): ManifestChunk[] {\n    const chunks: ManifestChunk[] = []\n    for (const file of chunk.imports ?? []) {\n      const importee = manifest[file]\n      if (seen.has(file)) {\n        continue\n      }\n      seen.add(file)\n\n      chunks.push(...getImportedChunks(importee))\n      chunks.push(importee)\n    }\n\n    return chunks\n  }\n\n  return getImportedChunks(manifest[name])\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing a Vite Project with npm\nDESCRIPTION: Command to create a new Vite-powered project using npm. This command initializes a new project with Vite 2.0, allowing developers to quickly start building their application.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/blog/announcing-vite2.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm init @vitejs/app\n```\n\n----------------------------------------\n\nTITLE: Configuring Server Open Option in Vite\nDESCRIPTION: Configures the server.open option to automatically open a specific path in the browser when the server starts. This example opens the '/docs/index.html' path.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/config/server-options.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nexport default defineConfig({\n  server: {\n    open: '/docs/index.html',\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: ModuleEvaluator Interface Definition\nDESCRIPTION: TypeScript interface definition for custom module evaluators that handle code execution in different contexts.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-environment-runtimes.md#2025-04-22_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface ModuleEvaluator {\n  startOffset?: number\n  runInlinedModule(\n    context: ModuleRunnerContext,\n    code: string,\n    id: string,\n  ): Promise<any>\n  runExternalModule(file: string): Promise<any>\n}\n```\n\n----------------------------------------\n\nTITLE: Detecting rolldown-vite via Module Export in JavaScript\nDESCRIPTION: This snippet shows how to detect `rolldown-vite` by checking for the `rolldownVersion` property exported directly from the `vite` module. This method is useful when `vite` is a direct dependency and detection is needed outside the specific context of plugin hooks.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/rolldown.md#2025-04-22_snippet_7\n\nLANGUAGE: js\nCODE:\n```\nimport * as vite from 'vite'\n\nif (vite.rolldownVersion) {\n  // logic for rolldown-vite\n} else {\n  // logic for rollup-vite\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Specific Vite Commit using pnpm (Bash)\nDESCRIPTION: This command explains how to add a specific, unreleased commit of Vite as a development dependency using pnpm. Users must replace `SHA` with the actual commit hash from the Vite repository (e.g., https://github.com/vitejs/vite/commits/main/). The installation relies on the `pkg.pr.new` service, which only supports recent commits (within the last month).\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/index.md#2025-04-22_snippet_21\n\nLANGUAGE: bash\nCODE:\n```\n$ pnpm add -D https://pkg.pr.new/vite@SHA\n```\n\n----------------------------------------\n\nTITLE: Configuring Server Sourcemap Ignore List in Vite\nDESCRIPTION: This JavaScript snippet demonstrates how to configure the `server.sourcemapIgnoreList` option in Vite's configuration. It defines a function that receives the absolute source path (`sourcePath`) and the sourcemap path (`sourcemapPath`) and returns `true` if the source path should be added to the `x_google_ignoreList` sourcemap extension. The example replicates the default behavior, ignoring files whose paths contain 'node_modules'.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/config/server-options.md#2025-04-22_snippet_8\n\nLANGUAGE: js\nCODE:\n```\nexport default defineConfig({\n  server: {\n    // This is the default value, and will add all files with node_modules\n    // in their paths to the ignore list.\n    sourcemapIgnoreList(sourcePath, sourcemapPath) {\n      return sourcePath.includes('node_modules')\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Running Vite with Custom Config File\nDESCRIPTION: Command to run Vite with a custom configuration file specified using the --config CLI option.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/config/index.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nvite --config my-config.js\n```\n\n----------------------------------------\n\nTITLE: Importing CSS Inline to Avoid Double Load - Vite - TypeScript\nDESCRIPTION: This code demonstrates how to import a CSS file as a string using the '?inline' modifier in Vite 4 and later. The '?inline' query ensures that the imported CSS string is not emitted as a separate stylesheet, thus avoiding the double loading issue present in earlier approaches. Applicable when you need programmatic access to CSS content, such as injecting it through JavaScript.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/blog/announcing-vite4.md#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport stuff from './global.css?inline'\n\n```\n\n----------------------------------------\n\nTITLE: Setting DNS Order in Vite Configuration\nDESCRIPTION: Configures DNS resolution order to 'verbatim' to avoid address reordering in Node.js versions below v17. This helps ensure Vite listens on the correct address when 'localhost' is used.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/config/server-options.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { defineConfig } from 'vite'\nimport dns from 'node:dns'\n\ndns.setDefaultResultOrder('verbatim')\n\nexport default defineConfig({\n  // omit\n})\n```\n\n----------------------------------------\n\nTITLE: Starting Vite Dev Server via CLI using Bun\nDESCRIPTION: Starts the Vite development server using `bunx`, Bun's equivalent of `npx`, which executes the `vite` command. This assumes `vite` is installed or can be fetched by Bun.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/index.md#2025-04-22_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\n$ bunx vite\n```\n\n----------------------------------------\n\nTITLE: Implementing Per-Environment Plugin (JavaScript)\nDESCRIPTION: Shows how to implement a per-environment plugin using the applyToEnvironment function. This example demonstrates initializing per-environment state and applying the plugin selectively.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-environment-plugins.md#2025-04-22_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nconst UnoCssPlugin = () => {\n  // shared global state\n  return {\n    buildStart() {\n      // init per-environment state with WeakMap<Environment,Data>\n      // using this.environment\n    },\n    configureServer() {\n      // use global hooks normally\n    },\n    applyToEnvironment(environment) {\n      // return true if this plugin should be active in this environment,\n      // or return a new plugin to replace it.\n      // if the hook is not used, the plugin is active in all environments\n    },\n    resolveId(id, importer) {\n      // only called for environments this plugin apply to\n    },\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Issue Triaging Workflow Visualization - Mermaid\nDESCRIPTION: This Mermaid diagram visualizes the decision process for triaging issues in the Vite project, including checks for duplicate reports, proper reproduction steps, bug validity, and priority assignment. The flowchart graphically documents reviewer actions, including when to close, label, or escalate issues. No runtime dependencies; interpreted by Markdown or tools supporting Mermaid. Inputs: Issue report status per node. Outputs: Visual workflow.\nSOURCE: https://github.com/vitejs/vite/blob/main/CONTRIBUTING.md#2025-04-22_snippet_7\n\nLANGUAGE: mermaid\nCODE:\n```\nflowchart TD\n    start{Followed issue\n        template?}\n    start --NO--> close1[\"Close and ask to\n        follow template\"]\n    start --YES--> dupe{Is duplicate?}\n    dupe --YES--> close2[Close and point\n        to duplicate]\n    dupe --NO--> repro{Has proper\n      reproduction?}\n    repro --NO--> close3[Label: 'needs reproduction'\n        bot will auto close if no update\n        has been made in 3 days]\n    repro --YES--> real{Is actually a bug?}\n    real --NO--> intended{Is the intended\n        behaviour?}\n    intended --YES--> explain[Explain and close\n        point to docs if needed]\n    intended --NO--> open[Keep open for discussion\n        Remove 'pending triage' label]\n    real --YES--> real2[\"① Remove 'pending triage' label\n        ② Add related feature label if applicable\n        (e.g. 'feat: ssr')\n        ③ Add priority and meta labels (see below)\"]\n    real2 --> unusable{Does the\n        bug make Vite\n        unusable?}\n    unusable --YES--> maj{Does the bug\n        affect the majority\n        of Vite users?}\n    maj --YES--> p5[p5: urgent]\n    maj --NO--> p4[p4: important]\n    unusable --NO--> workarounds{Are there\n        workarounds for\n        the bug?}\n    workarounds --NO--> p3[p3: minor bug]\n    workarounds --YES--> p2[p2: edge case\n        has workaround]\n```\n\n----------------------------------------\n\nTITLE: Escaping Dollar Signs and Expanding Variables - ENV\nDESCRIPTION: Shows correct syntax for escaping dollar signs and referencing other variables when defining environment values in .env files. Dollar signs must be escaped with a backslash to be interpreted literally, and variables are expanded using dotenv-expand conventions. Input is raw text in .env files; expansion happens automatically by Vite/dotenv-expand. The output variables reflect expanded/escaped values as documented.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/env-and-mode.md#2025-04-22_snippet_2\n\nLANGUAGE: env\nCODE:\n```\nKEY=123\\nNEW_KEY1=test$foo   # test\\nNEW_KEY2=test\\$foo  # test$foo\\nNEW_KEY3=test$KEY   # test123\n```\n\n----------------------------------------\n\nTITLE: Conditional Vite Config based on Command and Mode\nDESCRIPTION: Exporting a function to conditionally determine Vite options based on the command, mode, and other factors.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/config/index.md#2025-04-22_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nexport default defineConfig(({ command, mode, isSsrBuild, isPreview }) => {\n  if (command === 'serve') {\n    return {\n      // dev specific config\n    }\n  } else {\n    // command === 'build'\n    return {\n      // build specific config\n    }\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Explicitly Loading Assets as URL in Vite (JavaScript)\nDESCRIPTION: This snippet shows how to explicitly import a JavaScript file (or other resource) as a URL by appending ?url to the import path. Vite treats the import as a URL string rather than attempting to process it as a module. The input is the import with query; the output is the resource's public URL.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/features.md#2025-04-22_snippet_13\n\nLANGUAGE: javascript\nCODE:\n```\nimport 'vite/client'\\n// ---cut---\\n// Explicitly load assets as URL\\nimport assetAsURL from './asset.js?url'\n```\n\n----------------------------------------\n\nTITLE: Conditionally Applying Plugins in Vite Configuration\nDESCRIPTION: This code example demonstrates how to conditionally apply a plugin only during the build process using the 'apply' property in the Vite configuration file.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/using-plugins.md#2025-04-22_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport typescript2 from 'rollup-plugin-typescript2'\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  plugins: [\n    {\n      ...typescript2(),\n      apply: 'build',\n    },\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Executing Vite in Custom Mode Using Bash\nDESCRIPTION: Demonstrates the command for running a Vite build with a specific mode via the CLI, overriding the default production mode. The `--mode` flag determines which `.env` file is loaded. Requires Vite installed and available on the command-line.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/env-and-mode.md#2025-04-22_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nvite build --mode staging\n```\n\n----------------------------------------\n\nTITLE: Installing Vite Dependency using pnpm\nDESCRIPTION: Adds the `vite` package as a development dependency (`-D`) to the current project using pnpm. This is part of the manual setup process.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/index.md#2025-04-22_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n$ pnpm add -D vite\n```\n\n----------------------------------------\n\nTITLE: Importing Inlined Web Worker in JavaScript\nDESCRIPTION: Shows how to import a web worker that will be inlined as a base64 string using both the ?worker and ?inline suffixes.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/assets.md#2025-04-22_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nimport InlineWorker from './shader.js?worker&inline'\n```\n\n----------------------------------------\n\nTITLE: Customizing ESBuild Transform Options for JSX in Vite - JavaScript\nDESCRIPTION: This snippet customizes the ESBuild transform options in Vite through defineConfig, specifically altering JSX factory and fragment identifiers. Useful for projects not using React's default createElement/Fragment symbols (e.g., Preact). Requires Vite and ESBuild. Input parameters alter how JSX is compiled in the build process.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/config/shared-options.md#2025-04-22_snippet_5\n\nLANGUAGE: js\nCODE:\n```\nexport default defineConfig({\n  esbuild: {\n    jsxFactory: 'h',\n    jsxFragment: 'Fragment',\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Injecting React Refresh Runtime for Development\nDESCRIPTION: Adds React Refresh runtime script to the HTML template when using @vitejs/plugin-react in development.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/backend-integration.md#2025-04-22_snippet_3\n\nLANGUAGE: html\nCODE:\n```\n<script type=\"module\">\n  import RefreshRuntime from 'http://localhost:5173/@react-refresh'\n  RefreshRuntime.injectIntoGlobalHook(window)\n  window.$RefreshReg$ = () => {}\n  window.$RefreshSig$ = () => (type) => type\n  window.__vite_plugin_react_preamble_installed__ = true\n</script>\n```\n\n----------------------------------------\n\nTITLE: Configuring Non-External SSR Dependencies in Vite\nDESCRIPTION: Prevents listed dependencies from being externalized for SSR. Can be a string, RegExp, array of either, or true to prevent all externalization. Takes precedence over external when set to true.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/config/ssr-options.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n## ssr.noExternal\n\n- **Type:** `string | RegExp | (string | RegExp)[] | true`\n- **Related:** [SSR Externals](/guide/ssr#ssr-externals)\n```\n\n----------------------------------------\n\nTITLE: Implementing an Environment-Aware Plugin Counter in JavaScript\nDESCRIPTION: This snippet shows how to modify the plugin to count transformed modules for each environment separately. It uses a Map to store counts for different environments and accesses the current environment through 'this.environment'.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/changes/shared-plugins-during-build.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction PerEnvironmentCountTransformedModulesPlugin() {\n  const state = new Map<Environment, { count: number }>()\n  return {\n    name: 'count-transformed-modules',\n    perEnvironmentStartEndDuringDev: true,\n    buildStart() {\n      state.set(this.environment, { count: 0 })\n    }\n    transform(id) {\n      state.get(this.environment).count++\n    },\n    buildEnd() {\n      console.log(this.environment.name, state.get(this.environment).count)\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Lightning CSS Configuration Type Imports for Vite - JavaScript\nDESCRIPTION: This snippet imports type definitions (such as CSSModulesConfig, Features, etc.) from the lightningcss package for TypeScript type safety in Lightning CSS configuration. Requires Vite and lightningcss as dependencies; used to ensure correct configuration shapes in Lightning CSS integration with Vite. This block is purely for typing and not runtime code.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/config/shared-options.md#2025-04-22_snippet_10\n\nLANGUAGE: js\nCODE:\n```\nimport type {\n  CSSModulesConfig,\n  Drafts,\n  Features,\n  NonStandard,\n  PseudoClasses,\n  Targets,\n} from 'lightningcss'\n```\n\n----------------------------------------\n\nTITLE: Installing Vite Dependency using npm\nDESCRIPTION: Installs the `vite` package as a development dependency (`-D`) in the current project using npm. This is part of the manual setup process.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/index.md#2025-04-22_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n$ npm install -D vite\n```\n\n----------------------------------------\n\nTITLE: Configuring Library Build in Vite\nDESCRIPTION: This configuration snippet shows how to set up a library build in Vite, specifying entry points, file naming, and CSS output.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/config/build-options.md#2025-04-22_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  build: {\n    lib: {\n      entry: ['src/main.js'],\n      fileName: (format, entryName) => `my-lib-${entryName}.${format}.js`,\n      cssFileName: 'my-lib-style',\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Starting a Vite Preview Server in TypeScript\nDESCRIPTION: Demonstrates how to start a Vite preview server using the preview function. It includes configuration options for port and automatic browser opening.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-javascript.md#2025-04-22_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { preview } from 'vite'\n\nconst previewServer = await preview({\n  // any valid user config options, plus `mode` and `configFile`\n  preview: {\n    port: 8080,\n    open: true,\n  },\n})\n\npreviewServer.printUrls()\npreviewServer.bindCLIShortcuts({ print: true })\n```\n\n----------------------------------------\n\nTITLE: Configuring Preview Port in package.json\nDESCRIPTION: Modified package.json that sets a custom port (8080) for the Vite preview server using the --port flag.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/static-deploy.md#2025-04-22_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"scripts\": {\n    \"preview\": \"vite preview --port 8080\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Importing a Virtual Module\nDESCRIPTION: Example of how to import and use a virtual module created by a plugin in a JavaScript file.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-plugin.md#2025-04-22_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport { msg } from 'virtual:my-module'\n\nconsole.log(msg)\n```\n\n----------------------------------------\n\nTITLE: Configuring a Worker Thread Transport for Module Runner in JavaScript\nDESCRIPTION: Implements a ModuleRunnerTransport for Vite using worker threads, where the transport object passes messages between the parent thread and the worker using Node.js worker APIs. Requires 'node:worker_threads', 'node:url', and Vite's module-runner and is used for isolated evaluation or hot-reloading within a process. Handlers are attached for message and close events, and the runner is instantiated using the configured transport and ESModulesEvaluator.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-environment-runtimes.md#2025-04-22_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nimport { parentPort } from 'node:worker_threads'\\nimport { fileURLToPath } from 'node:url'\\nimport { ESModulesEvaluator, ModuleRunner } from 'vite/module-runner'\\n\\n/** @type {import('vite/module-runner').ModuleRunnerTransport} */\\nconst transport = {\\n  connect({ onMessage, onDisconnection }) {\\n    parentPort.on('message', onMessage)\\n    parentPort.on('close', onDisconnection)\\n  },\\n  send(data) {\\n    parentPort.postMessage(data)\\n  },\\n}\\n\\nconst runner = new ModuleRunner(\\n  {\\n    transport,\\n  },\\n  new ESModulesEvaluator(),\\n)\n```\n\n----------------------------------------\n\nTITLE: Building the Application for Production using NPM (Bash)\nDESCRIPTION: Executes the `build` script defined in the `package.json`, which bundles the SolidJS application for production using Vite. This process optimizes the code for performance, minifies it, and outputs the final assets (including hashed filenames) to the `dist` folder, ready for deployment.\nSOURCE: https://github.com/vitejs/vite/blob/main/packages/create-vite/template-solid-ts/README.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm run build\n```\n\n----------------------------------------\n\nTITLE: Using Degit with Main Branch\nDESCRIPTION: This snippet shows how to scaffold a project using degit when the repository uses 'main' as the default branch. Modify 'user/project' with the actual user and project names.\nSOURCE: https://github.com/vitejs/vite/blob/main/packages/create-vite/README.md#2025-04-22_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nnpx degit user/project#main my-project\n```\n\n----------------------------------------\n\nTITLE: Scaffolding Vite Project using degit and npm\nDESCRIPTION: Uses `npx degit` to clone a specific branch ('main') of a project template from a GitHub repository (`user/project`) into a local directory (`my-project`). It then navigates into the directory, installs dependencies using npm, and starts the Vite development server using `npm run dev`. This is an alternative method for using community templates.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/index.md#2025-04-22_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nnpx degit user/project#main my-project\ncd my-project\n\nnpm install\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Configuring Future Deprecation Warnings in Vite\nDESCRIPTION: Configuration options to enable warning messages for deprecated server methods that will be removed in Vite v7.0. Sets warnings for server.moduleGraph and server.transformRequest usage.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/changes/per-environment-apis.md#2025-04-22_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nfuture: {\n  removeServerModuleGraph: 'warn',\n  removeServerTransformRequest: 'warn',\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Script as Shared Worker in JavaScript\nDESCRIPTION: Demonstrates how to import a script as a shared worker using the ?sharedworker suffix.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/assets.md#2025-04-22_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nimport SharedWorker from './shader.js?sharedworker'\nconst sharedWorker = new SharedWorker()\n```\n\n----------------------------------------\n\nTITLE: Migration Example: Filtering Modules for HMR\nDESCRIPTION: Example showing how to migrate from handleHotUpdate to hotUpdate when filtering affected modules. The basic pattern remains the same, but the context of the modules changes to be environment-specific.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/changes/hotupdate-hook.md#2025-04-22_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nhandleHotUpdate({ modules }) {\n  return modules.filter(condition)\n}\n\n// Migrate to:\n\nhotUpdate({ modules }) {\n  return modules.filter(condition)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ModuleRunnerTransport Interface in TypeScript\nDESCRIPTION: Defines the interface for transport objects that interact with the Vite module runner, specifying optional asynchronous methods for connecting, disconnecting, sending, or invoking using hot payloads. Requires TypeScript and expects dependencies from 'vite/module-runner'. The primary input/output is the HotPayload object, and certain methods (like send or invoke) must be implemented depending on the intended use, especially for HMR support.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-environment-runtimes.md#2025-04-22_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { ModuleRunnerTransportHandlers } from 'vite/module-runner'\\n/** an object */\\ntype HotPayload = unknown\\n// ---cut---\\ninterface ModuleRunnerTransport {\\n  connect?(handlers: ModuleRunnerTransportHandlers): Promise<void> | void\\n  disconnect?(): Promise<void> | void\\n  send?(data: HotPayload): Promise<void> | void\\n  invoke?(data: HotPayload): Promise<{ result: any } | { error: any }>\\n  timeout?: number\\n}\n```\n\n----------------------------------------\n\nTITLE: Building a Vite Application for Production\nDESCRIPTION: Command to build a Vite application for production. This generates optimized static files in the dist directory by default.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/static-deploy.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ npm run build\n```\n\n----------------------------------------\n\nTITLE: Running the Development Server using NPM (Bash)\nDESCRIPTION: Executes the `dev` script defined in the `package.json` file, typically using Vite. This command starts the application in development mode with features like hot module replacement. The application becomes accessible in the browser, usually at `http://localhost:5173`.\nSOURCE: https://github.com/vitejs/vite/blob/main/packages/create-vite/template-solid-ts/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Attaching Custom Queries to import.meta.glob\nDESCRIPTION: Demonstrates how to pass custom queries to import.meta.glob, allowing for the attachment of metadata to glob imports.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/blog/announcing-vite3.md#2025-04-22_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport.meta.glob('./dir/*.js', { query: { custom: 'data' } })\n```\n\n----------------------------------------\n\nTITLE: Firebase Project Configuration\nDESCRIPTION: Firebase project configuration file (.firebaserc) that specifies which Firebase project to use for deployment.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/static-deploy.md#2025-04-22_snippet_10\n\nLANGUAGE: js\nCODE:\n```\n{\n  \"projects\": {\n    \"default\": \"<YOUR_FIREBASE_ID>\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Static Assets as URLs in Vite (JavaScript)\nDESCRIPTION: This snippet demonstrates importing an image from the local filesystem, which returns a resolved URL string suitable for use in HTML (e.g., as an <img src> attribute). Vite processes and provides the optimized URL at runtime. Inputs are the static file and import path; output is a string URL assigned to a DOM element. Requires Vite asset handling.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/features.md#2025-04-22_snippet_12\n\nLANGUAGE: javascript\nCODE:\n```\nimport 'vite/client'\\n// ---cut---\\nimport imgUrl from './img.png'\\ndocument.getElementById('hero-img').src = imgUrl\n```\n\n----------------------------------------\n\nTITLE: TypeScript Interface for HmrContext in handleHotUpdate Hook\nDESCRIPTION: TypeScript interface that defines the structure of the HmrContext object passed to the handleHotUpdate hook, which includes information about the changed file, timestamp, affected modules, a read function, and the ViteDevServer instance.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/changes/hotupdate-hook.md#2025-04-22_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface HmrContext {\n  file: string\n  timestamp: number\n  modules: Array<ModuleNode>\n  read: () => string | Promise<string>\n  server: ViteDevServer\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring HTTP-Based Transport for ModuleRunner Using TypeScript\nDESCRIPTION: Implements a ModuleRunner transport in Vite that uses HTTP requests for invoking actions on the server, disabling HMR as it requires connect/send. The code depends on Vite's module-runner and the browser 'fetch' API. It posts the HotPayload as JSON and expects a response of either a result or error, to be passed back to the ModuleRunner. The runner is then used to import an entry JavaScript module from the server.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-environment-runtimes.md#2025-04-22_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ESModulesEvaluator, ModuleRunner } from 'vite/module-runner'\\n\\nexport const runner = new ModuleRunner(\\n  {\\n    transport: {\\n      async invoke(data) {\\n        const response = await fetch(`http://my-vite-server/invoke`, {\\n          method: 'POST',\\n          body: JSON.stringify(data),\\n        })\\n        return response.json()\\n      },\\n    },\\n    hmr: false, // disable HMR as HMR requires transport.connect\\n  },\\n  new ESModulesEvaluator(),\\n)\\n\\nawait runner.import('/entry.js')\n```\n\n----------------------------------------\n\nTITLE: Setting SSR External Resolve Conditions in Vite\nDESCRIPTION: Specifies conditions used during SSR import of externalized direct dependencies. Requires matching Node --conditions flag for consistent behavior in dev and build.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/config/ssr-options.md#2025-04-22_snippet_4\n\nLANGUAGE: markdown\nCODE:\n```\n## ssr.resolve.externalConditions\n\n- **Type:** `string[]`\n- **Default:** `['node']`\n```\n\n----------------------------------------\n\nTITLE: Running Development Server with npm\nDESCRIPTION: Runs the Vite application in development mode. The server is hosted locally at port 5173, allowing developers to test their applications during development. It requires a functional npm environment.\nSOURCE: https://github.com/vitejs/vite/blob/main/packages/create-vite/template-solid/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: ModuleRunnerOptions Interface Definition\nDESCRIPTION: TypeScript interface definition for ModuleRunner configuration options including transport, sourcemap handling, and HMR settings.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-environment-runtimes.md#2025-04-22_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\ninterface ModuleRunnerOptions {\n  transport: ModuleRunnerTransport\n  sourcemapInterceptor?: false | 'node' | 'prepareStackTrace' | InterceptorOptions\n  hmr?: boolean | ModuleRunnerHmr\n  evaluatedModules?: EvaluatedModules\n}\n```\n\n----------------------------------------\n\nTITLE: Vercel CLI Installation and Project Setup\nDESCRIPTION: Commands to install Vercel CLI globally and initialize a new Vite project for deployment to Vercel.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/static-deploy.md#2025-04-22_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$ npm i -g vercel\n$ vercel init vite\nVercel CLI\n> Success! Initialized \"vite\" example in ~/your-folder.\n- To deploy, `cd vite` and run `vercel`.\n```\n\n----------------------------------------\n\nTITLE: Registering Custom HMR Handler in Client Code (JavaScript)\nDESCRIPTION: Demonstrates how to register a custom HMR handler in client-side code using the HMR API. This snippet listens for the 'special-update' event.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-environment-plugins.md#2025-04-22_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nif (import.meta.hot) {\n  import.meta.hot.on('special-update', (data) => {\n    // perform custom update\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Package.json Conditional Exports Example\nDESCRIPTION: JSON configuration example showing how to set up conditional exports in a package.json file, demonstrating module format selection based on import conditions.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/config/shared-options.md#2025-04-22_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"exports\": {\n    \".\": {\n      \"import\": \"./index.mjs\",\n      \"require\": \"./index.js\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Full Reload in HotUpdate Hook (JavaScript)\nDESCRIPTION: Demonstrates how to implement a full reload in the hotUpdate hook for the client environment. This snippet invalidates modules and sends a full-reload event.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-environment-plugins.md#2025-04-22_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nhotUpdate({ modules, timestamp }) {\n  if (this.environment.name !== 'client')\n    return\n\n  // Invalidate modules manually\n  const invalidatedModules = new Set()\n  for (const mod of modules) {\n    this.environment.moduleGraph.invalidateModule(\n      mod,\n      invalidatedModules,\n      timestamp,\n      true\n    )\n  }\n  this.environment.hot.send({ type: 'full-reload' })\n  return []\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring VitePress Page with Vue Component for Blog Index\nDESCRIPTION: This snippet configures a VitePress page to display the Vite blog posts. It imports and uses the BlogIndex component while disabling standard VitePress features like sidebar, edit links, and outline.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/blog.md#2025-04-22_snippet_0\n\nLANGUAGE: vue\nCODE:\n```\n<script setup>\nimport BlogIndex from './.vitepress/theme/components/BlogIndex.vue'\n</script>\n\n# Latest From the Vite Blog\n\n<BlogIndex/>\n```\n\n----------------------------------------\n\nTITLE: Initializing Svelte Store in JavaScript\nDESCRIPTION: This snippet demonstrates how to create a very simple writable store in Svelte, using the 'writable' function from 'svelte/store'. It exports a store with an initial value of 0, allowing components to interact with the shared state. No additional dependencies are required beyond what Svelte provides. This store setup is crucial when local component state needs to be preserved outside of HMR (Hot Module Replacement) sessions.\nSOURCE: https://github.com/vitejs/vite/blob/main/packages/create-vite/template-svelte/README.md#2025-04-22_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\n// store.js\n// An extremely simple external store\nimport { writable } from 'svelte/store'\nexport default writable(0)\n```\n\n----------------------------------------\n\nTITLE: Network Request Flow in Unoptimized Async Chunk Loading\nDESCRIPTION: Illustrates the network request pattern in an unoptimized scenario where async chunk A is imported and the browser must request and parse A before discovering it needs the common chunk C, resulting in an extra network roundtrip.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/features.md#2025-04-22_snippet_22\n\nLANGUAGE: plaintext\nCODE:\n```\nEntry ---> A ---> C\n```\n\n----------------------------------------\n\nTITLE: Using import.meta.glob with Multiple Patterns in JavaScript\nDESCRIPTION: Demonstrates how to use import.meta.glob with multiple file patterns passed as an array. This new feature allows for more flexible glob imports.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/blog/announcing-vite3.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport.meta.glob(['./dir/*.js', './another/*.js'])\n```\n\n----------------------------------------\n\nTITLE: Configuring qwikVite Plugin for CSR Mode in TypeScript\nDESCRIPTION: This TypeScript snippet shows how to configure the Vite build tool using `defineConfig`. It specifically demonstrates enabling Client-Side Rendering (CSR) for a Qwik application by passing `{ csr: true }` as an option to the `qwikVite` plugin within the `plugins` array. This setup ensures the application is fully bootstrapped in the browser.\nSOURCE: https://github.com/vitejs/vite/blob/main/packages/create-vite/template-qwik/README.md#2025-04-22_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nexport default defineConfig({\n  plugins: [\n    qwikVite({\n      csr: true,\n    }),\n  ],\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Lightning CSS Configuration Object Example for Vite - JavaScript\nDESCRIPTION: This partial snippet supplies a typed shape for configuring Lightning CSS in Vite. The object shows available options—including targets, features, drafts, and modules—matching Lightning CSS documentation. Useful for guiding users in constructing their configuration object, ensures valid fields are supplied.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/config/shared-options.md#2025-04-22_snippet_11\n\nLANGUAGE: js\nCODE:\n```\n{\n  targets?: Targets\n  include?: Features\n  exclude?: Features\n  drafts?: Drafts\n  nonStandard?: NonStandard\n  pseudoClasses?: PseudoClasses\n  unusedSymbols?: string[]\n  cssModules?: CSSModulesConfig,\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Vite Project with Bun\nDESCRIPTION: This snippet outlines the command to scaffold a new Vite project using Bun. Once executed, you will need to follow the prompts to complete the project setup.\nSOURCE: https://github.com/vitejs/vite/blob/main/packages/create-vite/README.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nbun create vite\n```\n\n----------------------------------------\n\nTITLE: Worker Plugins Type Definition\nDESCRIPTION: Type definition for worker-specific plugins that return either a single plugin or an array of plugins. These plugins are specifically applied to worker bundles during build.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/config/worker-options.md#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n() => (Plugin | Plugin[])[]\n```\n\n----------------------------------------\n\nTITLE: Importing Vue Components for Vite Landing Page\nDESCRIPTION: This script imports various Vue components that make up the different sections of the Vite landing page. Each component represents a specific section like hero, features, frameworks, community, sponsors, and getting started.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/index.md#2025-04-22_snippet_0\n\nLANGUAGE: vue\nCODE:\n```\n<script setup>\nimport Hero from '.vitepress/theme/components/landing/1. hero-section/HeroSection.vue'\nimport FeatureSection from './.vitepress/theme/components/landing/2. feature-section/FeatureSection.vue'\nimport FrameworksSection from './.vitepress/theme/components/landing/3. frameworks-section/FrameworksSection.vue'\nimport CommunitySection from './.vitepress/theme/components/landing/4. community-section/CommunitySection.vue'\nimport SponsorSection from './.vitepress/theme/components/landing/5. sponsor-section/SponsorSection.vue'\nimport GetStartedSection from '.vitepress/theme/components/landing/6. get-started-section/GetStartedSection.vue'\nimport FeatureInstantServerStart from './.vitepress/theme/components/landing/2. feature-section/FeatureInstantServerStart.vue'\nimport FeatureHMR from './.vitepress/theme/components/landing/2. feature-section/FeatureHMR.vue'\nimport FeatureRichFeatures from './.vitepress/theme/components/landing/2. feature-section/FeatureRichFeatures.vue'\nimport FeatureOptimizedBuild from './.vitepress/theme/components/landing/2. feature-section/FeatureOptimizedBuild.vue'\nimport FeatureFlexiblePlugins from './.vitepress/theme/components/landing/2. feature-section/FeatureFlexiblePlugins.vue'\nimport FeatureTypedAPI from './.vitepress/theme/components/landing/2. feature-section/FeatureTypedAPI.vue'\nimport FeatureSSRSupport from './.vitepress/theme/components/landing/2. feature-section/FeatureSSRSupport.vue'\nimport FeatureCI from './.vitepress/theme/components/landing/2. feature-section/FeatureCI.vue'\n</script>\n```\n\n----------------------------------------\n\nTITLE: Importing React Components in JavaScript\nDESCRIPTION: Demonstrates how Vite's CommonJS conversion allows named imports from CommonJS modules to work as expected, even with dynamically assigned exports.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/dep-pre-bundling.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// works as expected\nimport React, { useState } from 'react'\n```\n\n----------------------------------------\n\nTITLE: Implementing Negative Patterns in import.meta.glob\nDESCRIPTION: Shows how to use negative patterns (prefixed with !) in import.meta.glob to exclude specific files from the glob import.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/blog/announcing-vite3.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport.meta.glob(['./dir/*.js', '!**/bar.js'])\n```\n\n----------------------------------------\n\nTITLE: Overriding Vite with rolldown-vite in Yarn\nDESCRIPTION: Shows how to override the vite dependency with rolldown-vite using Yarn's resolutions configuration for projects where Vite is a peer dependency.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/rolldown.md#2025-04-22_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"resolutions\": {\n    \"vite\": \"npm:rolldown-vite@latest\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: TransformResult Interface in TypeScript\nDESCRIPTION: Defines the TransformResult interface returned by the transformRequest method. It includes properties for transformed code, source map, etag, and dependencies.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-environment-instances.md#2025-04-22_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ninterface TransformResult {\n  code: string\n  map: SourceMap | { mappings: '' } | null\n  etag?: string\n  deps?: string[]\n  dynamicDeps?: string[]\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Vite Dependency using Bun\nDESCRIPTION: Adds the `vite` package as a development dependency (`-D`) to the current project using Bun. This is part of the manual setup process.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/index.md#2025-04-22_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\n$ bun add -D vite\n```\n\n----------------------------------------\n\nTITLE: CSS Post Processing Optional Chaining Fix\nDESCRIPTION: Adds optional chaining operator to getModuleInfo call in vite:css-post plugin to prevent potential errors\nSOURCE: https://github.com/vitejs/vite/blob/main/packages/vite/CHANGELOG.md#2025-04-22_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nthis.getModuleInfo?.\n```\n\n----------------------------------------\n\nTITLE: Building the Application for Production using npm in Bash\nDESCRIPTION: This Bash command executes the `build` script defined in the project's `package.json` file using npm. This script typically compiles and bundles the application's assets (JavaScript, CSS, etc.) into an optimized format suitable for deployment. The output is usually placed in a `dist` directory.\nSOURCE: https://github.com/vitejs/vite/blob/main/packages/create-vite/template-qwik/README.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n### `npm run build`\n```\n\n----------------------------------------\n\nTITLE: TypeScript Declaration for Global Constants\nDESCRIPTION: Example of adding type declarations for globally defined constants in TypeScript environment declaration file to enable type checking and IntelliSense support.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/config/shared-options.md#2025-04-22_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\n// vite-env.d.ts\ndeclare const __APP_VERSION__: string\n```\n\n----------------------------------------\n\nTITLE: Rendering SVG Images in Vue Template\nDESCRIPTION: This Vue template code renders the imported SVG images using a custom 'svg-image' component. It shows how to use imported assets in a Vue template with Vite.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/why.md#2025-04-22_snippet_1\n\nLANGUAGE: html\nCODE:\n```\n<svg-image :svg=\"bundlerSvg\" />\n<svg-image :svg=\"esmSvg\" />\n```\n\n----------------------------------------\n\nTITLE: Quoting Environment Variables with Special Characters - Vite - Diff\nDESCRIPTION: This diff snippet illustrates the change required in .env files for Vite 4 when environment variable values contain characters like '#' or backticks. With dotenv 16 and dotenv-expand 9, such values must be wrapped in quotes to be parsed correctly. The diff shows both the old, incompatible syntax and the new, compliant format.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/blog/announcing-vite4.md#2025-04-22_snippet_2\n\nLANGUAGE: diff\nCODE:\n```\n-VITE_APP=ab#cd`ef\n+VITE_APP=\"ab#cd`ef\"\n\n```\n\n----------------------------------------\n\nTITLE: Setting SSR Build Target in Vite\nDESCRIPTION: Specifies the build target for the SSR server. Can be either 'node' or 'webworker'. Defaults to 'node'.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/config/ssr-options.md#2025-04-22_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n## ssr.target\n\n- **Type:** `'node' | 'webworker'`\n- **Default:** `node`\n```\n\n----------------------------------------\n\nTITLE: VS Code Debug Configuration for Vite Config\nDESCRIPTION: VS Code settings to enable breakpoint debugging in the Vite config file by resolving source map locations.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/config/index.md#2025-04-22_snippet_8\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"debug.javascript.terminalOptions\": {\n    \"resolveSourceMapLocations\": [\n      \"${workspaceFolder}/**\",\n      \"!**/node_modules/**\",\n      \"**/node_modules/.vite-temp/**\"\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Environment Variables for Vite Project - Shell\nDESCRIPTION: This snippet demonstrates how to declare an environment variable (KEY) with the value 'safe' using shell script syntax. Such declarations are typically placed in .env files for Vite, enabling the build process to inject or utilize environment-specific values. Dependencies include the node environment for reading .env files; no input or output is processed directly by this snippet. KEY can be accessed in Vite configuration or source code via process.env.KEY. No complex parameters or logic are present.\nSOURCE: https://github.com/vitejs/vite/blob/main/playground/fs-serve/root/src/special characters åäö/safe.txt#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nKEY=safe\n```\n\n----------------------------------------\n\nTITLE: TypeScript Logger Interface for Vite CustomLogger Option - TypeScript\nDESCRIPTION: This code block declares the Logger interface used by Vite for the customLogger configuration option. It defines the shape of the logger object along with all supported logging methods and properties. Intended for advanced users extending or typing custom loggers; no runtime code, only type/interface declaration.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/config/shared-options.md#2025-04-22_snippet_9\n\nLANGUAGE: ts\nCODE:\n```\ninterface Logger {\n  info(msg: string, options?: LogOptions): void\n  warn(msg: string, options?: LogOptions): void\n  warnOnce(msg: string, options?: LogOptions): void\n  error(msg: string, options?: LogErrorOptions): void\n  clearScreen(type: LogType): void\n  hasErrorLogged(error: Error | RollupError): boolean\n  hasWarned: boolean\n}\n```\n\n----------------------------------------\n\nTITLE: Importing SVG Images in Vue Component\nDESCRIPTION: This Vue component setup script imports SVG images as raw strings for use in the template. It demonstrates how Vite handles asset imports in Vue components.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/why.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n<script setup>\nimport bundlerSvg from '../images/bundler.svg?raw'\nimport esmSvg from '../images/esm.svg?raw'\n</script>\n```\n\n----------------------------------------\n\nTITLE: Installing Specific Vite Commit using Yarn (Bash)\nDESCRIPTION: This command shows how to add a specific, unreleased commit of Vite as a development dependency using Yarn. `SHA` needs to be replaced with the target commit hash from the Vite repository (e.g., https://github.com/vitejs/vite/commits/main/). It leverages the `pkg.pr.new` service for direct commit installation, limited to recent commits (within the last month).\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/index.md#2025-04-22_snippet_20\n\nLANGUAGE: bash\nCODE:\n```\n$ yarn add -D https://pkg.pr.new/vite@SHA\n```\n\n----------------------------------------\n\nTITLE: Configuring SSR Resolve Conditions in Vite\nDESCRIPTION: Sets conditions used in the plugin pipeline for non-externalized dependencies during SSR build. Defaults vary based on the ssr.target setting.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/config/ssr-options.md#2025-04-22_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n## ssr.resolve.conditions\n\n- **Type:** `string[]`\n- **Default:** `['module', 'node', 'development|production']` (`defaultServerConditions`) (`['module', 'browser', 'development|production']` (`defaultClientConditions`) for `ssr.target === 'webworker'`)\n- **Related:** [Resolve Conditions](./shared-options.md#resolve-conditions)\n```\n\n----------------------------------------\n\nTITLE: Configuring Package Overrides for Testing Local Vite Changes\nDESCRIPTION: JSON configuration for package.json to use a locally modified version of Vite in another project using pnpm overrides.\nSOURCE: https://github.com/vitejs/vite/blob/main/CONTRIBUTING.md#2025-04-22_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"dependencies\": {\n    \"vite\": \"^6.0.0\"\n  },\n  \"pnpm\": {\n    \"overrides\": {\n      \"vite\": \"link:../path/to/vite/packages/vite\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Visualizing the Forked Deadlock Loop (Text Diagram)\nDESCRIPTION: This diagram visually represents the circular wait condition forming the deadlock. Module [X] waits for [Y], which waits for [A], which waits for [B], which in turn waits for [X], completing the cycle. This visualization helps understand the chain of dependencies leading to the deadlock.\nSOURCE: https://github.com/vitejs/vite/blob/main/playground/ssr/src/forked-deadlock/README.md#2025-04-22_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n[X] is waiting for [Y] to resolve\n ↑                  ↳ is waiting for [A] to resolve\n │                                    ↳ is waiting for [B] to resolve\n │                                                      ↳ is waiting for [X] to resolve\n └────────────────────────────────────────────────────────────────────────┘\n```\n\n----------------------------------------\n\nTITLE: Overriding Vite with rolldown-vite in pnpm\nDESCRIPTION: Demonstrates how to override the vite dependency with rolldown-vite using pnpm's overrides configuration for projects where Vite is a peer dependency.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/rolldown.md#2025-04-22_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"pnpm\": {\n    \"overrides\": {\n      \"vite\": \"npm:rolldown-vite@latest\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Experimental Lightning CSS in Vite (Bash)\nDESCRIPTION: This one-line bash command allows installation of Lightning CSS as a devDependency, enabling experimental support for an alternative CSS transformer/minifier in Vite. Requires additional configuration in vite.config.js to activate related options. Input is the npm add command; output is Lightning CSS installed in node_modules.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/features.md#2025-04-22_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nnpm add -D lightningcss\n```\n\n----------------------------------------\n\nTITLE: Configuring SSR Package.json Main Fields in Vite\nDESCRIPTION: Lists fields in package.json to try when resolving a package's entry point for non-externalized dependencies. Takes lower precedence than conditional exports resolved from the exports field.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/config/ssr-options.md#2025-04-22_snippet_5\n\nLANGUAGE: markdown\nCODE:\n```\n### ssr.resolve.mainFields\n\n- **Type:** `string[]`\n- **Default:** `['module', 'jsnext:main', 'jsnext']`\n```\n\n----------------------------------------\n\nTITLE: GitLab CI/CD Configuration for Vite Deployment\nDESCRIPTION: GitLab CI/CD configuration file (.gitlab-ci.yml) that sets up automated building and deployment of a Vite application to GitLab Pages.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/static-deploy.md#2025-04-22_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\nimage: node:lts\npages:\n  stage: deploy\n  cache:\n    key:\n      files:\n        - package-lock.json\n      prefix: npm\n    paths:\n      - node_modules/\n  script:\n    - npm install\n    - npm run build\n    - cp -a dist/. public/\n  artifacts:\n    paths:\n      - public\n  rules:\n    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH\n```\n\n----------------------------------------\n\nTITLE: Configuring Git Blame to Ignore Formatting Revisions\nDESCRIPTION: Command to configure git to ignore formatting changes when using git blame by using the .git-blame-ignore-revs file.\nSOURCE: https://github.com/vitejs/vite/blob/main/CONTRIBUTING.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ngit config --local blame.ignoreRevsFile .git-blame-ignore-revs\n```\n\n----------------------------------------\n\nTITLE: Pre-bundling Dependencies with Vite Optimize (Deprecated) - Bash\nDESCRIPTION: This code snippet shows how to invoke the (now deprecated) `vite optimize` command to manually pre-bundle dependencies. Pre-bundling is now handled automatically by Vite, so this command is typically unnecessary. Input: optional [root] parameter; Output: pre-bundled dependencies (behavior subject to deprecation, and this feature may be removed in future versions).\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/cli.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nvite optimize [root]\n```\n\n----------------------------------------\n\nTITLE: Accessing Extra Vite Templates using PNPM\nDESCRIPTION: This command uses pnpm to run the `create-vite-extra` package. It provides access to additional community and framework templates beyond the default ones offered by `create-vite`, including options for different runtimes like Solid, Deno, SSR setups, and library starters.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/blog/announcing-vite6.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npnpm create vite-extra\n```\n\n----------------------------------------\n\nTITLE: Example Vite Manifest JSON Structure\nDESCRIPTION: Shows the structure of the manifest.json file generated by Vite build, including file mappings and dependencies.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/backend-integration.md#2025-04-22_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"_shared-B7PI925R.js\": {\n    \"file\": \"assets/shared-B7PI925R.js\",\n    \"name\": \"shared\",\n    \"css\": [\"assets/shared-ChJ_j-JJ.css\"]\n  },\n  \"_shared-ChJ_j-JJ.css\": {\n    \"file\": \"assets/shared-ChJ_j-JJ.css\",\n    \"src\": \"_shared-ChJ_j-JJ.css\"\n  },\n  \"baz.js\": {\n    \"file\": \"assets/baz-B2H3sXNv.js\",\n    \"name\": \"baz\",\n    \"src\": \"baz.js\",\n    \"isDynamicEntry\": true\n  },\n  \"views/bar.js\": {\n    \"file\": \"assets/bar-gkvgaI9m.js\",\n    \"name\": \"bar\",\n    \"src\": \"views/bar.js\",\n    \"isEntry\": true,\n    \"imports\": [\"_shared-B7PI925R.js\"],\n    \"dynamicImports\": [\"baz.js\"]\n  },\n  \"views/foo.js\": {\n    \"file\": \"assets/foo-BRBmoGS9.js\",\n    \"name\": \"foo\",\n    \"src\": \"views/foo.js\",\n    \"isEntry\": true,\n    \"imports\": [\"_shared-B7PI925R.js\"],\n    \"css\": [\"assets/foo-5UjPuW-k.css\"]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Migration Example: Full Page Reload Implementation\nDESCRIPTION: Example showing how to migrate from handleHotUpdate to hotUpdate when needing to perform a full page reload. The key difference is using this.environment to access the moduleGraph and hot APIs instead of using the server directly.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/changes/hotupdate-hook.md#2025-04-22_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nhandleHotUpdate({ server, modules, timestamp }) {\n  // Invalidate modules manually\n  const invalidatedModules = new Set()\n  for (const mod of modules) {\n    server.moduleGraph.invalidateModule(\n      mod,\n      invalidatedModules,\n      timestamp,\n      true\n    )\n  }\n  server.ws.send({ type: 'full-reload' })\n  return []\n}\n\n// Migrate to:\n\nhotUpdate({ modules, timestamp }) {\n  // Invalidate modules manually\n  const invalidatedModules = new Set()\n  for (const mod of modules) {\n    this.environment.moduleGraph.invalidateModule(\n      mod,\n      invalidatedModules,\n      timestamp,\n      true\n    )\n  }\n  this.environment.hot.send({ type: 'full-reload' })\n  return []\n}\n```\n\n----------------------------------------\n\nTITLE: Scaffolding Vite Project using Yarn\nDESCRIPTION: Initializes a new Vite project interactively using Yarn's `create` command. It prompts the user for project name, framework selection, and variant (e.g., TypeScript). Requires Node.js 18+/20+.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/index.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ yarn create vite\n```\n\n----------------------------------------\n\nTITLE: Overriding Vite with rolldown-vite in Bun\nDESCRIPTION: Shows how to override the vite dependency with rolldown-vite using Bun's overrides configuration for projects where Vite is a peer dependency.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/rolldown.md#2025-04-22_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"overrides\": {\n    \"vite\": \"npm:rolldown-vite@latest\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Commit Reference Formatting in Markdown\nDESCRIPTION: Example of how commit references and issue links are formatted in the changelog using Markdown.\nSOURCE: https://github.com/vitejs/vite/blob/main/packages/create-vite/CHANGELOG.md#2025-04-22_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n* chore: enable prettier trailing commas (#11167) ([134ce68](https://github.com/vitejs/vite/commit/134ce6817984bad0f5fb043481502531fee9b1db)), closes [#11167](https://github.com/vitejs/vite/issues/11167)\n```\n\n----------------------------------------\n\nTITLE: Installing Vite with Yarn\nDESCRIPTION: Command to scaffold a new Vite application using Yarn.\nSOURCE: https://github.com/vitejs/vite/blob/main/packages/create-vite/CHANGELOG.md#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ yarn create vite\n```\n\n----------------------------------------\n\nTITLE: Using Path Normalization in Vite\nDESCRIPTION: Demonstrates how to use Vite's path normalization utility to convert Windows-style paths to POSIX format.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-plugin.md#2025-04-22_snippet_12\n\nLANGUAGE: javascript\nCODE:\n```\nimport { normalizePath } from 'vite'\n\nnormalizePath('foo\\\\bar') // 'foo/bar'\nnormalizePath('foo/bar') // 'foo/bar'\n```\n\n----------------------------------------\n\nTITLE: Running the Development Server using npm in Bash\nDESCRIPTION: This Bash command executes the `dev` script defined in the project's `package.json` file using npm. This typically starts a local development server (often on http://localhost:5173 for Vite projects) with features like hot module replacement, allowing developers to view and test the application in a browser during development.\nSOURCE: https://github.com/vitejs/vite/blob/main/packages/create-vite/template-qwik/README.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n### `npm run dev`\n```\n\n----------------------------------------\n\nTITLE: Node.js-Based Communication in Vite Environment\nDESCRIPTION: This code snippet shows using Node.js APIs with Vite to communicate between user modules and code using Vite's APIs through hot module replacement (HMR), highlighting message passing between environments.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-environment-frameworks.md#2025-04-22_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n// code using the Vite's APIs\nimport { createServer } from 'vite'\n\nconst server = createServer({\n  plugins: [\n    // a plugin that handles `virtual:entrypoint`\n    {\n      name: 'virtual-module',\n      /* plugin implementation */\n    },\n  ],\n})\nconst ssrEnvironment = server.environment.ssr\nconst input = {}\n\n// use exposed functions by each environment factories that runs the code\n// check for each environment factories what they provide\nif (ssrEnvironment instanceof RunnableDevEnvironment) {\n  ssrEnvironment.runner.import('virtual:entrypoint')\n} else if (ssrEnvironment instanceof CustomDevEnvironment) {\n  ssrEnvironment.runEntrypoint('virtual:entrypoint')\n} else {\n  throw new Error(`Unsupported runtime for ${ssrEnvironment.name}`)\n}\n\nconst req = new Request('/')\n\nconst uniqueId = 'a-unique-id'\nssrEnvironment.send('request', serialize({ req, uniqueId }))\nconst response = await new Promise((resolve) => {\n  ssrEnvironment.on('response', (data) => {\n    data = deserialize(data)\n    if (data.uniqueId === uniqueId) {\n      resolve(data.res)\n    }\n  })\n})\n\nconst { createHandler } = await import('./entrypoint.js')\nconst handler = createHandler(input)\n\nimport.meta.hot.on('request', (data) => {\n  const { req, uniqueId } = deserialize(data)\n  const res = handler(req)\n  import.meta.hot.send('response', serialize({ res: res, uniqueId }))\n})\n\nconst response = handler(new Request('/'))\n\n// -------------------------------------\n// ./entrypoint.js\nexport function createHandler(input) {\n  return function handler(req) {\n    return new Response('hello')\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Project Dependencies using npm/pnpm/yarn in Bash\nDESCRIPTION: This Bash command is used to install the project's dependencies defined in the `package.json` file. It shows the command using `npm`, but mentions that `pnpm install` or `yarn install` can be used as alternatives depending on the package manager chosen for the project.\nSOURCE: https://github.com/vitejs/vite/blob/main/packages/create-vite/template-qwik/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n```bash\n$ npm install # or pnpm install or yarn install\n```\n```\n\n----------------------------------------\n\nTITLE: Importing Module Preload Polyfill in JavaScript\nDESCRIPTION: This snippet shows how to manually import the module preload polyfill in a custom entry point when not using HTML entries.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/config/build-options.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport 'vite/modulepreload-polyfill'\n```\n\n----------------------------------------\n\nTITLE: Specifying WebWorker Types for TypeScript - JSON Config\nDESCRIPTION: Configures the TypeScript project to include type definitions for WebWorker APIs by updating the `lib` field in `tsconfig.json`. This is useful when code depends on browser/WebWorker globals and ensures proper IntelliSense and type checking. Requires manual edit to `tsconfig.json`, and affects the TypeScript compilation environment.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/env-and-mode.md#2025-04-22_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \\\"lib\\\": [\\\"WebWorker\\\"]\\n}\n```\n\n----------------------------------------\n\nTITLE: Module Runner Implementation Example\nDESCRIPTION: Shows how to create and use a ModuleRunner instance with custom transport and evaluator.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-environment-runtimes.md#2025-04-22_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport { ModuleRunner, ESModulesEvaluator } from 'vite/module-runner'\nimport { transport } from './rpc-implementation.js'\n\nconst moduleRunner = new ModuleRunner(\n  {\n    transport,\n  },\n  new ESModulesEvaluator(),\n)\n\nawait moduleRunner.import('/src/entry-point.js')\n```\n\n----------------------------------------\n\nTITLE: Installing Legacy Browser Support Plugin for Vite\nDESCRIPTION: This snippet shows how to install the @vitejs/plugin-legacy package using npm to add support for legacy browsers in a Vite project.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/using-plugins.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ npm add -D @vitejs/plugin-legacy\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for Qwik Project - Bash\nDESCRIPTION: This shell command installs all necessary dependencies for a Qwik project using the package manager specified (npm, pnpm, or yarn). The command must be executed in the project root directory. No external dependencies beyond a Node-compatible package manager are required. Input is the project directory; output is a ready environment with all packages installed, suitable for running and building the Qwik app. This step is a prerequisite before using any of the npm scripts (`dev`, `build`, etc.).\nSOURCE: https://github.com/vitejs/vite/blob/main/packages/create-vite/template-qwik-ts/README.md#2025-04-22_snippet_1\n\nLANGUAGE: Bash\nCODE:\n```\n$ npm install # or pnpm install or yarn install\n```\n\n----------------------------------------\n\nTITLE: Pull Request Review Workflow Visualization - Mermaid\nDESCRIPTION: This Mermaid diagram details the workflow for reviewing pull requests in the Vite project, clarifying how bug fixes and feature requests are triaged, reviewed, labeled, and merged. It distinguishes between 'strict fixes' and broader changes, with different approval and merging paths required for each. The flowchart serves as onboarding/reference documentation for maintainers. No runtime dependencies. Inputs: PR status. Outputs: Visual graph.\nSOURCE: https://github.com/vitejs/vite/blob/main/CONTRIBUTING.md#2025-04-22_snippet_8\n\nLANGUAGE: mermaid\nCODE:\n```\nflowchart TD\n    start{Bug fix\n        or\n        feature}\n    start --BUG FIX--> strict_bug{\"Is this a 'strict fix'?\n        i.e. fixes an obvious oversight with no side effects\"}\n    start --FEATURE--> feature[• Discuss feature necessity\n        • Is there a better way to address the need?\n        • Review code quality\n        • Add labels\n        • Add to milestone\n        • Add to Team Board]\n    feature -.-> approve_non_strict[• Run vite-ecosystem-ci if needed\n        • Approve if you feel strongly that the PR is needed and add to milestone]\n    strict_bug --YES--> strict[• Verify the fix locally\n        • Review code quality\n        • Require test case if applicable\n        • Request changes if necessary\n        • Add labels]\n    strict_bug --NO--> non_strict[Discuss the potential side effects of the fix, e.g.\n        • Could it introduce implicit behavior changes in other cases?\n        • Does it introduce too much changes?\n        • Add labels\n        • Add to Team Board]\n    non_strict -.-> approve_non_strict\n    strict --> approve_strict[Approve if ready to be merged]\n    approve_strict --> merge_strict[Merge if approved by 2 or more team members]\n    approve_non_strict -.-> merge_non_strict[Merge if approved by 2 or more team members and the PR has been discussed in a team meeting]\n    merge_non_strict -.-> merge_extra\n    merge_strict --> merge_extra[\"• Use 'Squash and Merge'\n        • Edit commit message to follow convention\n        • In commit message body, list relevant issues being fixed e.g. 'fix #1234, fix #1235'\"]\n```\n\n----------------------------------------\n\nTITLE: Extending Vite File System Allow List with Workspace Root\nDESCRIPTION: This JavaScript snippet demonstrates an advanced configuration for `server.fs.allow` in Vite. It uses the `searchForWorkspaceRoot` utility to automatically detect and allow access to the project's workspace root, while also adding custom paths (`/path/to/custom/allow_directory`, `/path/to/custom/allow_file.demo`) to the allowed list. This allows combining automatic workspace detection with specific directory/file permissions.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/config/server-options.md#2025-04-22_snippet_6\n\nLANGUAGE: js\nCODE:\n```\nimport { defineConfig, searchForWorkspaceRoot } from 'vite'\n\nexport default defineConfig({\n  server: {\n    fs: {\n      allow: [\n        // search up for workspace root\n        searchForWorkspaceRoot(process.cwd()),\n        // your custom rules\n        '/path/to/custom/allow_directory',\n        '/path/to/custom/allow_file.demo',\n      ],\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Importing CSS Modules as Strings with Inline Query - Vite - TypeScript\nDESCRIPTION: This snippet illustrates how to import a CSS file as a string using the deprecated default export in Vite 3. Importing as shown may cause the CSS to be loaded twice when the framework or runtime also injects styles, leading to redundancy issues. The import demonstrates the previous pattern now discouraged in Vite 4 and above.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/blog/announcing-vite4.md#2025-04-22_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport cssString from './global.css'\n\n```\n\n----------------------------------------\n\nTITLE: Scaffolding Specific Vite Project Template using Bun\nDESCRIPTION: Creates a new Vite project named 'my-vue-app' using the 'vue' template directly via command-line arguments with Bun. Requires Node.js 18+/20+.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/index.md#2025-04-22_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$ bun create vite my-vue-app --template vue\n```\n\n----------------------------------------\n\nTITLE: Worker Format Configuration Type Definition\nDESCRIPTION: Type definition for the worker bundle output format option. Can be set to either 'es' (ECMAScript modules) or 'iife' (Immediately Invoked Function Expression), with 'iife' as the default.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/config/worker-options.md#2025-04-22_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n'es' | 'iife'\n```\n\n----------------------------------------\n\nTITLE: Worker Rollup Options Type Reference\nDESCRIPTION: Type reference to Rollup configuration options for building worker bundles, linking to the full Rollup options documentation.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/config/worker-options.md#2025-04-22_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nRollupOptions\n```\n\n----------------------------------------\n\nTITLE: Accessing Environments in Vite Dev Server\nDESCRIPTION: Demonstrates how to access and use environment instances in a Vite dev server. It shows creating a server, accessing client and SSR environments, and using environment methods.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-environment-instances.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// create the server, or get it from the configureServer hook\nconst server = await createServer(/* options */)\n\nconst environment = server.environments.client\nenvironment.transformRequest(url)\nconsole.log(server.environments.ssr.moduleGraph)\n```\n\n----------------------------------------\n\nTITLE: Referencing Future Options in Vite Config\nDESCRIPTION: This snippet demonstrates how to reference the 'future' option in the Vite configuration file. The 'future' option is used to opt-in to breaking changes.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/changes/index.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n[`future` option](/config/shared-options.html#future)\n```\n\n----------------------------------------\n\nTITLE: Using the 'create-vite' Scaffolding Tool\nDESCRIPTION: Refers to the `create-vite` scaffolding tool, typically invoked via package managers like npm, yarn, or pnpm (e.g., `pnpm create vite`). It sets up a Vite project, offering choices for frameworks (like Vue, React, Svelte) and providing access to extra templates (including those from `create-vite-extra`) under an 'Others' option. It also provides shortcuts to setup official starters from frameworks like `create-vue`, `Nuxt 3`, `SvelteKit`, etc.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/blog/announcing-vite6.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncreate vite\n```\n\n----------------------------------------\n\nTITLE: Setting VitePress Frontmatter Options\nDESCRIPTION: This YAML frontmatter configuration disables common VitePress features including sidebar, edit links, and outline for this specific page.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/blog.md#2025-04-22_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n---\nsidebar: false\neditLink: false\noutline: false\n---\n```\n\n----------------------------------------\n\nTITLE: Displaying Import Stack for Module [A] (Text)\nDESCRIPTION: This snippet details the import stack for module [A], indicating it was directly imported by the entry module [H]. Comparing this stack with others helps illustrate the 'forked' import path.\nSOURCE: https://github.com/vitejs/vite/blob/main/playground/ssr/src/forked-deadlock/README.md#2025-04-22_snippet_4\n\nLANGUAGE: text\nCODE:\n```\n[A] stack:\n\t[H]\n```\n\n----------------------------------------\n\nTITLE: Importing VitePress Components and Team Data in Vue Setup\nDESCRIPTION: This JavaScript code block, within a Vue `<script setup>` context, imports specific UI components (`VPTeamPage`, `VPTeamPageTitle`, `VPTeamPageSection`, `VPTeamMembers`) from the `vitepress/theme` library and team member data arrays (`core`, `emeriti`) from a local relative path `./_data/team`. These imports make the components and data available for use within the component's template.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/team.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n<script setup>\nimport {\n  VPTeamPage,\n  VPTeamPageTitle,\n  VPTeamPageSection,\n  VPTeamMembers\n} from 'vitepress/theme'\nimport { core, emeriti } from './_data/team'\n</script>\n```\n\n----------------------------------------\n\nTITLE: Structuring Team Page Layout with Vue and VitePress Components\nDESCRIPTION: This HTML template code, part of a Vue component, uses imported VitePress components (`VPTeamPage`, `VPTeamPageTitle`, `VPTeamMembers`, `VPTeamPageSection`) to structure a 'Meet the Team' page. It sets the main title and lead text, displays the core team members by passing the `core` data array to `VPTeamMembers`, and creates a separate section for emeritus members, similarly passing the `emeriti` data array.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/team.md#2025-04-22_snippet_1\n\nLANGUAGE: html\nCODE:\n```\n<VPTeamPage>\n  <VPTeamPageTitle>\n    <template #title>Meet the Team</template>\n    <template #lead>\n      The development of Vite is guided by an international team, some of whom\n      have chosen to be featured below.\n    </template>\n  </VPTeamPageTitle>\n  <VPTeamMembers :members=\"core\" />\n  <VPTeamPageSection>\n    <template #title>Team Emeriti</template>\n    <template #lead>\n      Here we honor some no-longer-active team members who have made valuable\n      contributions in the past.\n    </template>\n    <template #members>\n      <VPTeamMembers size=\"small\" :members=\"emeriti\" />\n    </template>\n  </VPTeamPageSection>\n</VPTeamPage>\n```\n\n----------------------------------------\n\nTITLE: Installing rolldown-vite as a Direct Dependency\nDESCRIPTION: Shows how to alias the vite package to rolldown-vite in your project's direct dependencies for a drop-in replacement.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/rolldown.md#2025-04-22_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"dependencies\": {\n    \"vite\": \"npm:rolldown-vite@latest\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Linking to Experimental Features Discussion on GitHub\nDESCRIPTION: This markdown link points to the GitHub Discussions page for Vite, filtered to show experimental features. It's used to provide users with more information about potential future changes.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/changes/index.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n[Experimental Label in Vite GitHub Discussions](https://github.com/vitejs/vite/discussions/categories/feedback?discussions_q=label%3Aexperimental+category%3AFeedback)\n```\n\n----------------------------------------\n\nTITLE: Displaying Import Stack for Module [B] (Text)\nDESCRIPTION: This snippet presents the import stack for module [B]. It shows that [B] was imported by [A], which was imported by [H]. This stack, particularly the presence of [H], is key to identifying the potential deadlock when [B] waits for [X].\nSOURCE: https://github.com/vitejs/vite/blob/main/playground/ssr/src/forked-deadlock/README.md#2025-04-22_snippet_5\n\nLANGUAGE: text\nCODE:\n```\n[B] stack:\n\t[A]\n\t[H]\n```\n\n----------------------------------------\n\nTITLE: Installing Project Dependencies using NPM (Bash)\nDESCRIPTION: This command installs all the necessary project dependencies defined in the `package.json` file using the Node Package Manager (NPM). The surrounding text notes that `pnpm install` or `yarn install` can be used as alternatives depending on the preferred package manager.\nSOURCE: https://github.com/vitejs/vite/blob/main/packages/create-vite/template-solid-ts/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ npm install # or pnpm install or yarn install\n```\n\n----------------------------------------\n\nTITLE: Quick Start with Vite 5 using pnpm\nDESCRIPTION: Command to scaffold a Vite project using pnpm create vite or pnpm create vite-extra for additional templates.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/blog/announcing-vite5.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npnpm create vite\n```\n\nLANGUAGE: shell\nCODE:\n```\npnpm create vite-extra\n```\n\n----------------------------------------\n\nTITLE: Overriding Vite with rolldown-vite in npm\nDESCRIPTION: Demonstrates how to override the vite dependency with rolldown-vite using npm's overrides configuration when Vite is used as a peer dependency.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/rolldown.md#2025-04-22_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"overrides\": {\n    \"vite\": \"npm:rolldown-vite@latest\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Expanding ESLint Configuration for TypeScript in Vite\nDESCRIPTION: This code snippet expands the ESLint configuration to enable type-aware lint rules in a React and TypeScript Vite project. It utilizes the `tseslint.config` function with options for recommended, strict, and stylistic type-checked rules. The configuration requires a proper setup of `tsconfig.node.json` and `tsconfig.app.json` files. Inputs include TypeScript configuration files, and it outputs enhanced ESLint settings. External dependencies include `@vitejs/eslint` packages for recommended configurations.\nSOURCE: https://github.com/vitejs/vite/blob/main/packages/create-vite/template-react-ts/README.md#2025-04-22_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport default tseslint.config({\n  extends: [\n    // Remove ...tseslint.configs.recommended and replace with this\n    ...tseslint.configs.recommendedTypeChecked,\n    // Alternatively, use this for stricter rules\n    ...tseslint.configs.strictTypeChecked,\n    // Optionally, add this for stylistic rules\n    ...tseslint.configs.stylisticTypeChecked,\n  ],\n  languageOptions: {\n    // other options...\n    parserOptions: {\n      project: ['./tsconfig.node.json', './tsconfig.app.json'],\n      tsconfigRootDir: import.meta.dirname,\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Environment Variable Host Configuration\nDESCRIPTION: Example of allowed hosts configuration using environment variables\nSOURCE: https://github.com/vitejs/vite/blob/main/packages/vite/CHANGELOG.md#2025-04-22_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nallowedHosts: process.env.VITE_ALLOWED_HOSTS\n```\n\n----------------------------------------\n\nTITLE: Updating Text Content in the DOM Utility Function - JavaScript\nDESCRIPTION: This snippet defines a utility function for updating a DOM element's text content. It receives a selector and a text string, then assigns the textContent property accordingly. Designed for test environments or runtime manipulations of test UIs. Dependencies: Standard DOM APIs. Inputs: el (selector string), text (string to insert). Outputs: DOM updated. Limitations: Assumes the element exists in DOM.\nSOURCE: https://github.com/vitejs/vite/blob/main/CONTRIBUTING.md#2025-04-22_snippet_5\n\nLANGUAGE: js\nCODE:\n```\nfunction text(el, text) {\n  document.querySelector(el).textContent = text\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Vite Dependency using Yarn\nDESCRIPTION: Adds the `vite` package as a development dependency (`-D`) to the current project using Yarn. This is part of the manual setup process.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/index.md#2025-04-22_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n$ yarn add -D vite\n```\n\n----------------------------------------\n\nTITLE: Depicting Two-File Cyclic Import with Entry using Mermaid (mermaid)\nDESCRIPTION: This Mermaid code snippet presents another cyclic import situation, contrasting two JavaScript modules (dep1.js and dep2.js) that import each other, with a final import into a main module (index.js). The diagram is designed to visualize potential issues from sustained cycles and dependencies in the module graph. Rendering requires Mermaid support; no other runtime dependencies are required. The expected output is a flowchart diagram showing the bidirectional link and the entry path.\nSOURCE: https://github.com/vitejs/vite/blob/main/packages/vite/src/node/ssr/runtime/__tests__/fixtures/cyclic2/README.md#2025-04-22_snippet_1\n\nLANGUAGE: mermaid\nCODE:\n```\nflowchart TD\\n    A(dep1.js) -->|dep1| B\\n    B(dep2.js) -->|dep2| A\\n    A -->|dep1| C(index.js)\n```\n\n----------------------------------------\n\nTITLE: Creating an External Svelte Store in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates how to create a simple external Svelte store using the `writable` function from the `svelte/store` module. This approach is suggested as a way to maintain state across Hot Module Replacement (HMR) updates, as component-local state might be lost. The store is initialized with the value 0 and exported as the default export from `store.ts`.\nSOURCE: https://github.com/vitejs/vite/blob/main/packages/create-vite/template-svelte-ts/README.md#2025-04-22_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// store.ts\n// An extremely simple external store\nimport { writable } from 'svelte/store'\nexport default writable(0)\n```\n\n----------------------------------------\n\nTITLE: Version Header Formatting in Markdown\nDESCRIPTION: Example of version header formatting using Markdown syntax for the changelog.\nSOURCE: https://github.com/vitejs/vite/blob/main/packages/create-vite/CHANGELOG.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n## 4.0.0-beta.0 (2022-12-07)\n```\n\n----------------------------------------\n\nTITLE: Writing Browser-Based Playwright Tests in Vitest - JavaScript\nDESCRIPTION: This snippet demonstrates a basic asynchronous Vitest test that uses Playwright's page object (imported from ~utils) to check the text content of an element in the DOM. Dependencies: Vitest for the test runner, Playwright for browser automation, and test utilities provided by the Vite playground/test-utils.ts file. The test expects the .foo element to have text 'foo', and showcases the use of the expect API and async/await. Inputs: DOM rendered in the test environment. Outputs: Passes or fails based on DOM content.\nSOURCE: https://github.com/vitejs/vite/blob/main/CONTRIBUTING.md#2025-04-22_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nimport { page } from '~utils'\n\ntest('should work', async () => {\n  expect(await page.textContent('.foo')).toMatch('foo')\n})\n```\n\n----------------------------------------\n\nTITLE: Importing and Rendering Raw SVG Asset in Vite Playground - JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates importing a raw SVG asset using Vite's ?raw import feature and rendering its content into a DOM element with the .raw class. The imported rawSvg variable contains the file's raw string content, and the text utility function is used to update the UI. Dependencies: Vite's asset import processing, working browser DOM, and the text utility function. Inputs: SVG file; Outputs: SVG string forcibly injected into the page.\nSOURCE: https://github.com/vitejs/vite/blob/main/CONTRIBUTING.md#2025-04-22_snippet_4\n\nLANGUAGE: js\nCODE:\n```\nimport rawSvg from './nested/fragment.svg?raw'\ntext('.raw', rawSvg)\n```\n\n----------------------------------------\n\nTITLE: Commit Message Style Changelog\nDESCRIPTION: A list of commit messages in conventional commit format documenting various maintenance tasks, dependency updates, refactoring efforts and documentation improvements in the Vite repository.\nSOURCE: https://github.com/vitejs/vite/blob/main/packages/vite/CHANGELOG.md#2025-04-22_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n### Chore\n\n* chore: add 5.4.x changelogs (#18768)\n* chore: add some comments about mimes (#18705)\n* chore(deps): update all non-major dependencies (#18746)\n* docs: rename `HotUpdateContext` to `HotUpdateOptions` (#18718)\n* test: simplify `playground/json/__tests__/ssr` (#18701)\n...\n```\n\n----------------------------------------\n\nTITLE: Using Vite's SSR with JavaScript Import\nDESCRIPTION: This snippet demonstrates how to use Vite's SSR environment to import external JavaScript modules dynamically, integrating user modules in a runtime-agnostic manner. It requires Vite as a dependency.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/guide/api-environment-frameworks.md#2025-04-22_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// code using the Vite's APIs\nimport { createServer } from 'vite'\n\nconst server = createServer()\nconst ssrEnvironment = server.environment.ssr\nconst input = {}\n\nconst { createHandler } = await ssrEnvironment.runner.import('./entry.js')\nconst handler = createHandler(input)\nconst response = handler(new Request('/'))\n\n// -------------------------------------\n// ./entrypoint.js\nexport function createHandler(input) {\n  return function handler(req) {\n    return new Response('hello')\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Representing Module Dependencies and Wait States (Text Diagram)\nDESCRIPTION: This textual diagram illustrates the relationships between different modules (H, X, Y, A, B) involved in a potential deadlock scenario. 'A -> B' signifies that B is imported by A and B has A in its import stack. 'A ... B' indicates that module A is waiting for module B to complete its `ssrLoadModule()` execution.\nSOURCE: https://github.com/vitejs/vite/blob/main/playground/ssr/src/forked-deadlock/README.md#2025-04-22_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nA -> B means: B is imported by A and B has A in its stack\nA ... B means: A is waiting for B to ssrLoadModule()\n\nH -> X ... Y\nH -> X -> Y ... B\nH -> A ... B\nH -> A -> B ... X\n```\n\n----------------------------------------\n\nTITLE: Installing Vite with PNPM\nDESCRIPTION: Command to scaffold a new Vite application using PNPM.\nSOURCE: https://github.com/vitejs/vite/blob/main/packages/create-vite/CHANGELOG.md#2025-04-22_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ pnpm dlx create-vite\n```\n\n----------------------------------------\n\nTITLE: Defining HTML Sections for Testing Static Asset Imports - HTML\nDESCRIPTION: This HTML snippet defines a section of an index.html file used to test the ?raw import feature in the Vite assets playground. The <h2> heading denotes the feature, and a <code> element (with class 'raw') is present to be filled during the test; it acts as a placeholder for dynamically inserted content. This structure enables automated tests to locate and verify injected file contents. No dependencies other than a browser environment. Inputs: Any runtime JavaScript can write to .raw element. Outputs: Section in rendered HTML.\nSOURCE: https://github.com/vitejs/vite/blob/main/CONTRIBUTING.md#2025-04-22_snippet_3\n\nLANGUAGE: html\nCODE:\n```\n<h2>?raw import</h2>\n<code class=\"raw\"></code>\n```\n\n----------------------------------------\n\nTITLE: Displaying Import Stack for Module [X] (Text)\nDESCRIPTION: This snippet shows the import stack for module [X] at the point of the deadlock analysis. It indicates that [X] was initially imported by [H]. This specific stack configuration is crucial for understanding the 'forked' nature of the deadlock.\nSOURCE: https://github.com/vitejs/vite/blob/main/playground/ssr/src/forked-deadlock/README.md#2025-04-22_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n[X] stack:\n\t[H]\n```\n\n----------------------------------------\n\nTITLE: Markdown Release Notes Entries\nDESCRIPTION: Changelog entries detailing version releases, bug fixes, features, and dependency updates for create-vite. Includes commit hashes and issue references.\nSOURCE: https://github.com/vitejs/vite/blob/main/packages/create-vite/CHANGELOG.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n## 4.3.0 (2023-04-20)\n\n* fix(create-vite): update template-lit-ts tsconfig (fix #12854) (#12855) ([c186815])\n* feat(create-vite): add eslint to React templates (#12801) ([d84460a])\n* feat(create-vite): move TypeScript ones up (#12057) ([313712d])\n* chore(create-vite): remove unnecessary App class Reference (#12771) ([1607f4a])\n* chore(create-vite): remove wrapper div for react template (#12867) ([3679bd7])\n* chore(deps): update dependency @tsconfig/svelte to v4 (#12879) ([79619a9])\n* docs: update link to svelte-hmr (#12893) ([2ddeead])\n```\n\nLANGUAGE: markdown\nCODE:\n```\n## 4.3.0-beta.0 (2023-04-06)\n\n* chore: use @vitejs/release-scripts (#12682) ([9c37cc1])\n* feat(create-vite): lit templates will create application instead of library (#12459) ([8186b9b])\n* feat(create-vite): stricter TS configs in templates (#12604) ([4ffaeee])\n* feat(create-vite): use typescript 5.0 in templates (#12481) ([8582e2d])\n* fix(create-vite): skip lib check in tsconfig templates (#12591) ([a59914c])\n```\n\n----------------------------------------\n\nTITLE: Structuring the Vite Landing Page with Vue Components\nDESCRIPTION: This HTML structure defines the layout of the Vite landing page. It uses the imported Vue components to create a structured page with multiple sections, including feature sections with different themes and content.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/index.md#2025-04-22_snippet_1\n\nLANGUAGE: vue\nCODE:\n```\n<div class=\"VPHome\">\n  <Hero/>\n  <FeatureSection title=\"Redefining developer experience\" description=\"Vite makes web development simple again\" type=\"blue\">\n    <FeatureInstantServerStart />\n    <FeatureHMR />\n    <FeatureRichFeatures />\n    <FeatureOptimizedBuild />\n  </FeatureSection>\n  <FeatureSection title=\"A shared foundation to build upon\" type=\"pink\" class=\"feature-section--flip\">\n    <FeatureFlexiblePlugins />\n    <FeatureTypedAPI />\n    <FeatureSSRSupport />\n    <FeatureCI />\n  </FeatureSection>\n  <FrameworksSection />\n  <CommunitySection />\n  <SponsorSection />\n  <GetStartedSection />\n</div>\n```\n\n----------------------------------------\n\nTITLE: Displaying Import Stack for Module [Y] (Text)\nDESCRIPTION: This snippet displays the import stack for module [Y]. It shows that [Y] was imported by [X], which was imported by [H]. This stack provides context for the dependencies shown in the deadlock diagrams.\nSOURCE: https://github.com/vitejs/vite/blob/main/playground/ssr/src/forked-deadlock/README.md#2025-04-22_snippet_3\n\nLANGUAGE: text\nCODE:\n```\n[Y] stack:\n\t[X]\n\t[H]\n```\n\n----------------------------------------\n\nTITLE: Small Version Header Formatting\nDESCRIPTION: Example of version header formatting for minor releases using Markdown small text syntax.\nSOURCE: https://github.com/vitejs/vite/blob/main/packages/create-vite/CHANGELOG.md#2025-04-22_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n## <small>3.2.1 (2022-11-07)</small>\n```\n\n----------------------------------------\n\nTITLE: Visualizing Cyclic Imports with Mermaid in JavaScript (mermaid)\nDESCRIPTION: This Mermaid diagram models a cyclic dependency scenario involving three JavaScript modules (dep1.js, dep2.js, index.js) and an entry point (entry.js). It demonstrates how cyclical relationships arise when modules reference each other directly or indirectly. No extra dependencies are needed, but viewing requires rendering the diagram with Mermaid. Inputs are the depicted modules and their relationships; output is a flowchart visual. The snippet highlights the risk of import cycles affecting module graph traversal or bundling.\nSOURCE: https://github.com/vitejs/vite/blob/main/packages/vite/src/node/ssr/runtime/__tests__/fixtures/cyclic2/README.md#2025-04-22_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\nflowchart TD\\n    B(dep1.js) -->|dep1| A(index.js)\\n    A -->|dep1| C(dep2.js)\\n    C -->|dep2| A\\n    A -->|dep1, dep2| entry.js\n```\n\n----------------------------------------\n\nTITLE: Dynamic Worker Options Implementation\nDESCRIPTION: Support for dynamic worker option fields in web worker configurations\nSOURCE: https://github.com/vitejs/vite/blob/main/packages/vite/CHANGELOG.md#2025-04-22_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nworker: {\n  format: \"dynamic\",\n  options: {}\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Terser for Vite Build Minification\nDESCRIPTION: This shell command installs the Terser JavaScript minifier as a development dependency using npm. This installation is required if you configure Vite's `build.minify` option to use `'terser'` instead of the default 'esbuild'.\nSOURCE: https://github.com/vitejs/vite/blob/main/docs/config/build-options.md#2025-04-22_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\nnpm add -D terser\n```\n\n----------------------------------------\n\nTITLE: Scaffolding a Project with Community Templates using Degit\nDESCRIPTION: This snippet details how to use degit for setting up projects with Vite community templates. Ensure that tools like degit and Node.js are installed.\nSOURCE: https://github.com/vitejs/vite/blob/main/packages/create-vite/README.md#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nnpx degit user/project my-project\ncd my-project\n\nnpm install\nnpm run dev\n```"
  }
]