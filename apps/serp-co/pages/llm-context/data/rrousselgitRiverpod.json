[
  {
    "owner": "rrousselgit",
    "repo": "riverpod",
    "content": "TITLE: Initializing ProviderScope in Flutter Application\nDESCRIPTION: Demonstrates the proper way to set up a ProviderScope at the root of a Flutter application, versus the incorrect approach of creating a standalone ProviderContainer.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/scopes.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nfinal valueProvider = StateProvider((ref) => 0);\n\n// DO this\nvoid main() {\n  runApp(ProviderScope(child: MyApp()));\n}\n\n//DON'T do this:\nfinal myProviderContainer = ProviderContainer();\nvoid main(){\n  runApp(MyApp());\n}\n```\n\n----------------------------------------\n\nTITLE: ConsumerWidget içinde ref.watch Kullanma (Dart)\nDESCRIPTION: Bu kod parçacığı, bir ConsumerWidget'in 'build' yönteminde 'ref.watch' kullanarak bir sağlayıcıyı ('counterProvider') nasıl dinlediğini gösterir. Sağlayıcının durumu değiştiğinde, widget otomatik olarak yeniden oluşturularak kullanıcı arayüzünü günceller.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/tr/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_7\n\nLANGUAGE: dart\nCODE:\n```\nfinal counterProvider = StateProvider((ref) => 0);\n\nclass HomeView extends ConsumerWidget {\n  const HomeView({Key? key}): super(key: key);\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // provider'ı dinlemek için ref'i kullanın\n    final counter = ref.watch(counterProvider);\n\n    return Text('$counter');\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing a Flutter App with Riverpod ProviderScope (Dart)\nDESCRIPTION: This snippet shows the correct way to initialize a Flutter application using Riverpod by wrapping the root widget (`MyApp`) with a `ProviderScope`. It also contrasts this with the incorrect approach of using a standalone `ProviderContainer` directly in the `main` function for Flutter apps, which should only be done for testing or Dart-only scenarios. `StateProvider` is used as an example provider.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/scopes.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nfinal valueProvider = StateProvider((ref) => 0);\n\n// DO this\nvoid main() {\n  runApp(ProviderScope(child: MyApp()));\n}\n\n//DON'T do this:\nfinal myProviderContainer = ProviderContainer();\nvoid main(){\n  runApp(MyApp());\n}\n```\n\n----------------------------------------\n\nTITLE: Using ref.watch to Reactively Monitor Providers in Dart\nDESCRIPTION: Demonstrates using ref.watch to monitor provider values reactively inside providers or widgets, enabling automatic UI or provider updates upon relevant value changes. An example combines multiple providers to compute a filtered todo list, showing efficiency in change tracking and recalculation.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_6\n\nLANGUAGE: Dart\nCODE:\n```\n<CodeBlock>{trimSnippet(watch)}</CodeBlock>\n```\n\n----------------------------------------\n\nTITLE: Creating a Filtered Todo List Provider with ref.watch\nDESCRIPTION: Shows how to combine multiple providers using ref.watch to create a filtered todo list that automatically updates when dependencies change.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/reading.mdx#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nfinal filteredTodoListProvider = Provider<List<Todo>>((ref) {\n  final filter = ref.watch(filterTypeProvider);\n  final todos = ref.watch(todosProvider);\n\n  switch (filter) {\n    case FilterType.none:\n      return todos;\n    case FilterType.completed:\n      return todos.where((todo) => todo.completed).toList();\n    case FilterType.uncompleted:\n      return todos.where((todo) => !todo.completed).toList();\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: AsyncNotifier with Family and AutoDispose in Dart (New Syntax)\nDESCRIPTION: Example of an AsyncNotifier using family and autoDispose modifiers with the new syntax in Dart. This snippet demonstrates how these modifiers are explicitly stated in the class definition with the new API.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/migration/from_state_notifier.mdx#2025-04-23_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nfinal bugsEncounteredProvider = AsyncNotifierProviderFamily<BugsEncounteredNotifier, List<String>, String>(\n  () => BugsEncounteredNotifier(),\n);\n\nclass BugsEncounteredNotifier extends AutoDisposeFamilyAsyncNotifier<List<String>, String> {\n  @override\n  Future<List<String>> build(String feature) async {\n    return ref.read(bugsRepositoryProvider).fetchBugs(feature);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Metodi ref.listen per monitorare provider in Dart\nDESCRIPTION: Descrizione del metodo ref.listen, che permette di ascoltare gli aggiornamenti di un provider e attivare una callback ogni volta che il suo stato cambia. Può essere usato durante la fase di build e consente di aggiungere comportamenti reattivi senza refactoring complessi.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/essentials/combining_requests.mdx#_snippet_4\n\nLANGUAGE: Dart\nCODE:\n```\n<AutoSnippet {...listenExample} />\n```\n\n----------------------------------------\n\nTITLE: Wrapping Flutter App with ProviderScope in Dart\nDESCRIPTION: This snippet shows the mandatory setup step for using Riverpod in a Flutter application. The root widget (`MyApp`) must be wrapped with a `ProviderScope` widget. This scope is essential for storing the state of all providers and enabling them to work correctly within the application. Requires the `flutter_riverpod` package and a root Flutter widget (`MyApp`).\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/providers.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Assuming MyApp is your root widget\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: Text('My App')),\n        body: Center(child: Text('Hello Riverpod')),\n      ),\n    );\n  }\n}\n\nvoid main() {\n  runApp(ProviderScope(child: MyApp()));\n}\n```\n\n----------------------------------------\n\nTITLE: Wrapping the Root Widget with ProviderScope in Flutter\nDESCRIPTION: Shows the necessary setup for using Riverpod in a Flutter application. The root widget of the application (`MyApp`) must be wrapped with `ProviderScope` to make providers accessible throughout the widget tree.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/providers.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nvoid main() {\n  runApp(ProviderScope(child: MyApp()));\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a ChangeNotifier and Provider in Dart with Riverpod\nDESCRIPTION: This snippet defines a `Todo` model class and a `TodosNotifier` class extending Flutter's `ChangeNotifier`. The `TodosNotifier` manages a list of todos and provides methods (`addTodo`, `removeTodo`, `toggle`) to modify the list, notifying listeners upon changes using `notifyListeners()`. It also defines `todosProvider`, a `ChangeNotifierProvider` that creates and exposes an instance of `TodosNotifier` for use within a Riverpod application.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/providers/change_notifier_provider.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nimport 'package:flutter/foundation.dart';\nimport 'package:riverpod/riverpod.dart';\n\n/// A PODO class representing the data for a single todo.\nclass Todo {\n  Todo({\n    required this.id,\n    required this.description,\n    required this.completed,\n  });\n\n  final String id;\n  final String description;\n  final bool completed;\n\n  Todo copyWith({\n    String? id,\n    String? description,\n    bool? completed,\n  }) {\n    return Todo(\n      id: id ?? this.id,\n      description: description ?? this.description,\n      completed: completed ?? this.completed,\n    );\n  }\n}\n\n/// The notifier for our todos list. It uses [ChangeNotifier] as extension.\nclass TodosNotifier extends ChangeNotifier {\n  final List<Todo> _todos = [];\n\n  /// An unmodifiable view of the list of todos.\n  List<Todo> get todos => List.unmodifiable(_todos);\n\n  /// Adds a new todo to the list.\n  void addTodo(Todo todo) {\n    _todos.add(todo);\n    // This call tells the widgets that are listening to this model to rebuild.\n    notifyListeners();\n  }\n\n  /// Removes a todo from the list.\n  void removeTodo(String todoId) {\n    _todos.removeWhere((todo) => todo.id == todoId);\n    // This call tells the widgets that are listening to this model to rebuild.\n    notifyListeners();\n  }\n\n  /// Marks a todo as completed or not.\n  void toggle(String todoId) {\n    for (final todo in _todos) {\n      if (todo.id == todoId) {\n        todo.copyWith(completed: !todo.completed);\n        // This call tells the widgets that are listening to this model to rebuild.\n        notifyListeners();\n      }\n    }\n  }\n}\n\n/// Finally, we are using StateNotifierProvider to allow the UI to interact with\n/// our TodosNotifier class.\nfinal todosProvider = ChangeNotifierProvider<TodosNotifier>((ref) {\n  return TodosNotifier();\n});\n\n```\n\n----------------------------------------\n\nTITLE: Creating a Filtered Todo List Provider using ref.watch in Dart\nDESCRIPTION: Defines a `filteredTodoListProvider` that combines the `filterProvider` and an assumed `todoListProvider`. It uses `ref.watch` to react to changes in both the filter state and the todo list, returning a new list filtered according to the selected filter. This demonstrates creating a computed state based on multiple dependencies.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\n/// A provider that combines the filter and the list of todos\n/// to return a filtered list of todos\nfinal filteredTodoListProvider = Provider((ref) {\n  final filter = ref.watch(filterProvider);\n  final todos = ref.watch(todoListProvider);\n\n  switch (filter) {\n    case Filter.none:\n      return todos;\n    case Filter.completed:\n      return todos.where((todo) => todo.completed).toList();\n    case Filter.uncompleted:\n      return todos.where((todo) => !todo.completed).toList();\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Reading a Provider using Consumer Widget with Riverpod\nDESCRIPTION: Illustrates using Riverpod's `Consumer` widget. The builder function receives `BuildContext`, a `WidgetRef`, and an optional `child`. `ref.watch` is used within the builder to access the provider's value.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/from_provider/provider_vs_riverpod.mdx#_snippet_7\n\nLANGUAGE: dart\nCODE:\n```\nConsumer(\n  builder: (BuildContext context, WidgetRef ref, Widget? child) {\n    Model model = ref.watch(modelProvider);\n\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Defining a TodoList Notifier in Dart\nDESCRIPTION: This snippet defines a TodoList class extending Notifier to manage a list of todos. It includes methods to add, remove, and toggle todos.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/providers/provider.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n@notifier\nclass TodoList extends Notifier<List<Todo>> {\n  @override\n  List<Todo> build() => [];\n\n  void addTodo(Todo todo) {\n    state = [...state, todo];\n  }\n\n  void removeTodo(String todoId) {\n    state = [\n      for (final todo in state)\n        if (todo.id != todoId) todo,\n    ];\n  }\n\n  void toggle(String todoId) {\n    state = [\n      for (final todo in state)\n        if (todo.id == todoId)\n          todo.copyWith(completed: !todo.completed)\n        else\n          todo,\n    ];\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Consuming Riverpod State in Flutter UI with Loading/Error Handling\nDESCRIPTION: This example shows how to use a Riverpod provider in a Flutter widget. It demonstrates pattern matching on the AsyncValue to handle different states (loading, error, data) elegantly using Dart's switch expressions.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod/README.md#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nclass Home extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final boredSuggestion = ref.watch(boredSuggestionProvider);\n    // Perform a switch-case on the result to handle loading/error states\n    return switch (boredSuggestion) {\n      AsyncData(:final value) => Text('data: $value'),\n      AsyncError(:final error) => Text('error: $error'),\n      _ => const Text('loading'),\n    };\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Full Search Implementation with StackExchange API (Riverpod and Flutter, Dart)\nDESCRIPTION: Delivers a complete Flutter app setup demonstrating real-time search using Riverpod providers. This snippet includes: setup of providers for input and results, asynchronous HTTP querying of StackExchange, disposal of HTTP clients with ref.onDispose, and error/loading state handling in the UI. Dependencies include flutter, flutter_riverpod, and http package. Inputs are user text via TextField; outputs are fetched question titles as a list. Limitations: actual result items are limited to question titles, no explicit debouncing (can be added), and network errors are shown simply as text.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/cookbooks/search_as_we_type.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n// Copyright (c) 2019, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:http/http.dart' as http;\nimport 'dart:convert';\n\nfinal searchFieldProvider = StateProvider<String>((ref) => '');\nfinal questionsProvider = FutureProvider<List>((ref) async {\n  final client = http.Client();\n  ref.onDispose(client.close);\n\n  final search = ref.watch(searchFieldProvider);\n\n  Uri uri;\n\n  if (search.isEmpty) {\n    uri = Uri.parse(\n      'https://api.stackexchange.com/2.3/questions?order=desc&sort=activity&site=stackoverflow',\n    );\n  } else {\n    final encodedQuery = Uri.encodeComponent(search);\n    uri = Uri.parse(\n      'https://api.stackexchange.com/2.3/search?order=desc&sort=activity&intitle=$encodedQuery&site=stackoverflow',\n    );\n  }\n\n  final response = await client.get(uri);\n  final questions = jsonDecode(response.body);\n\n  return questions['items'].map((question) => question['title']).toList();\n});\n\nvoid main() => runApp(const ProviderScope(child: MyApp()));\n\nclass MyApp extends StatelessWidget {\n  const MyApp({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(home: MyHomePage());\n  }\n}\n\nclass MyHomePage extends ConsumerWidget {\n  const MyHomePage({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final questions = ref.watch(questionsProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Questions')),\n      body: Column(\n        children: [\n          TextField(\n            onChanged: (value) =>\n                ref.read(searchFieldProvider.notifier).state = value,\n          ),\n          Expanded(\n            child: switch (questions) {\n              AsyncData(:final value) => ListView.builder(\n                  itemCount: value.length,\n                  itemBuilder: (context, index) {\n                    final question = value[index];\n\n                    return ListTile(\n                      title: Text(\n                        question.toString(),\n                      ),\n                    );\n                  },\n                );,\n              AsyncError(:final error) => Center(child: Text('Error $error')),\n              _ => const Center(child: CircularProgressIndicator()),\n            },\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Complete Implementation of Search as We Type in Flutter with Riverpod\nDESCRIPTION: Demonstrates a full implementation of a search feature that queries the Stack Overflow API. It includes providers for search input and questions, as well as a Flutter UI with a search field and results list.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/bn/docusaurus-plugin-content-docs/current/cookbooks/search_as_we_type.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\n// Copyright (c) 2019, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:http/http.dart' as http;\nimport 'dart:convert';\n\nfinal searchFieldProvider = StateProvider<String>((ref) => '');\nfinal questionsProvider = FutureProvider<List>((ref) async {\n  final client = http.Client();\n  ref.onDispose(client.close);\n\n  final search = ref.watch(searchFieldProvider);\n\n  Uri uri;\n\n  if (search.isEmpty) {\n    uri = Uri.parse(\n      'https://api.stackexchange.com/2.3/questions?order=desc&sort=activity&site=stackoverflow',\n    );\n  } else {\n    final encodedQuery = Uri.encodeComponent(search);\n    uri = Uri.parse(\n      'https://api.stackexchange.com/2.3/search?order=desc&sort=activity&intitle=$encodedQuery&site=stackoverflow',\n    );\n  }\n\n  final response = await client.get(uri);\n  final questions = jsonDecode(response.body);\n\n  return questions['items'].map((question) => question['title']).toList();\n});\n\nvoid main() => runApp(const ProviderScope(child: MyApp()));\n\nclass MyApp extends StatelessWidget {\n  const MyApp({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(home: MyHomePage());\n  }\n}\n\nclass MyHomePage extends ConsumerWidget {\n  const MyHomePage({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final questions = ref.watch(questionsProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Questions')),\n      body: Column(\n        children: [\n          TextField(\n            onChanged: (value) =>\n                ref.read(searchFieldProvider.notifier).state = value,\n          ),\n          Expanded(\n            child: questions.when(\n              loading: () => const Center(child: CircularProgressIndicator()),\n              error: (error, stack) => Center(child: Text('Error $error')),\n              data: (questions) {\n                return ListView.builder(\n                  itemCount: questions.length,\n                  itemBuilder: (context, index) {\n                    final question = questions[index];\n\n                    return ListTile(\n                      title: Text(\n                        question.toString(),\n                      ),\n                    );\n                  },\n                );\n              },\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching and Managing Packages List Using Riverpod in Dart\nDESCRIPTION: This Dart snippet demonstrates the implementation of business logic for a Pub.dev client app using Riverpod. It covers fetching a list of packages asynchronously with error and loading state management, supporting features like type-ahead search, pull-to-refresh, and infinite scrolling. Dependencies include Riverpod and a networking package such as Dio. The snippet illustrates declarative and reactive programming practices by automatically caching and refreshing data, handling asynchronous API requests, decoding JSON responses into Dart classes, and managing UI state accordingly.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/Introduction/why_riverpod.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n// pub.devからパッケージのリストを取得します。\n// APIを取得します。ここではpackage:dioを使用していますが、他のものを使用することもできます。\n// JSONレスポンスをDartクラスにデコードします。\n// このスニペットは、タイプしながらの検索、pull to refresh、無限リストのビジネスロジックとエラー/ローディング状態処理をすべて含みます。\n```\n\n----------------------------------------\n\nTITLE: Handling Loading and Error States - Dart\nDESCRIPTION: This snippet enhances the UI to handle loading and error states using `AsyncValue` from Riverpod. It uses pattern matching to show a spinner during the initial load and the refresh indicator during updates, while also handling potential errors. It uses the `valueOrNull` property to avoid exceptions when the data isn't available.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/case_studies/pull_to_refresh.mdx#_snippet_5\n\nLANGUAGE: Dart\nCODE:\n```\n/* code for displayActivity4 not provided in the text */\n```\n\n----------------------------------------\n\nTITLE: Combining FutureProvider.autoDispose with .family for memory-safe Dart providers\nDESCRIPTION: Defines a FutureProvider that uses both .family for parameterization and autoDispose to automatically clean up state when no longer used. This is important for providers with frequently changing parameters like search filters to prevent memory leaks. It accepts a string filter parameter and asynchronously fetches filtered characters.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/concepts/modifiers/family.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nfinal characters = FutureProvider.autoDispose.family<List<Character>, String>((ref, filter) async {\n  return fetchCharacters(filter: filter);\n});\n```\n\n----------------------------------------\n\nTITLE: Optimized User Name Display with Select\nDESCRIPTION: Optimized version using select to only listen to name changes and avoid unnecessary rebuilds\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/reading.mdx#2025-04-23_snippet_17\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, WidgetRef ref) {\n  String name = ref.watch(userProvider.select((user) => user.name));\n  return Text(name);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Provider with Ref Parameter in Dart\nDESCRIPTION: Shows how to create a provider that receives a ref parameter, which allows the provider to interact with other providers.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/reading.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nfinal myProvider = Provider<String>((ref) {\n  // Use ref to interact with other providers\n  return 'Hello world';\n});\n```\n\n----------------------------------------\n\nTITLE: Consuming Todo State with StateNotifierProvider in Riverpod Widgets (Dart)\nDESCRIPTION: This snippet demonstrates the consumption of a StateNotifierProvider for a Todo list within a Flutter widget using Riverpod in Dart. It shows how to watch the provider in the widget's build method, display the list of todos, and interact with the state via UI controls, such as updating or deleting items. Dependencies include riverpod and flutter packages. Expected usage involves passing the provider to Consumer widgets and handling state updates through user interaction. The main limitation is that this approach follows the standard hooks/patterns of Riverpod consumer widgets in Dart.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/providers/state_notifier_provider.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n/* Contents of todos_consumer.dart, implementing widget-level consumption of the Todo StateNotifierProvider. */\n```\n\n----------------------------------------\n\nTITLE: Avoid Using Riverpod Providers for Local Widget State - Dart\nDESCRIPTION: Explains why providers should not be used for local widget state such as form fields, selected items, animations, or controllers like TextEditingController. The snippet recommends using flutter_hooks for local state management. This prevents issues like breaking app navigation as local UI state is often scoped to specific routes only, preventing unintended state overrides when navigating between pages.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/essentials/do_dont.mdx#_snippet_1\n\n\n\n----------------------------------------\n\nTITLE: 코드 생성 기반 자동 상태 소멸 방지 (KeepAlive) - Dart\nDESCRIPTION: Provider에 'keepAlive' 어노테이션을 지정해서 코드 생성 시 자동 상태 소멸을 방지하는 방법을 보여줍니다. 이 기법은 provider가 전체 프레임에 대한 활성 리스너가 없을 때 상태가 소멸되는 것을 차단하는 데 유용하며, 자동폐기 활성화 여부와 관련 설정을 명확히 설명합니다. dependencies: code-gen, autoDispose, Dart 언어. 핵심 파라미터: keepAlive를 주석으로 설명.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/essentials/auto_dispose.mdx#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\n```dart\n// 어노테이션에 \"keepAlive\"를 지정하여 자동 상태 소멸을 비활성화할 수 있습니다.\n// 코드 생성 시, provider가 수신이 중단되면 상태가 파괴되지 않도록 합니다.\n```\n```\n\n----------------------------------------\n\nTITLE: Updating provider to accept parameters using family modifier in Dart Riverpod\nDESCRIPTION: This snippet demonstrates how to modify a Riverpod provider by adding the .family modifier, allowing it to accept external parameters such as activity type. It highlights the use of the type parameter and the benefits of parameterized providers for dynamic data fetching.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/essentials/passing_args.mdx#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\n// Using .family modifier on a provider to accept parameters\nfinal activityProvider = Provider.family<String, String>((ref, activityType) {\n  // TODO: Implement network request to fetch activity based on activityType\n});\n```\n\n----------------------------------------\n\nTITLE: ConsumerStatefulWidget Implementation\nDESCRIPTION: This snippet shows a `ConsumerStatefulWidget` and its corresponding `ConsumerState`. The `ref` is available within the `ConsumerState` class as a property.  This enables stateful widgets to access and react to provider changes. This allows the state to read and watch providers.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_2\n\nLANGUAGE: Dart\nCODE:\n```\nclass MyConsumerStatefulWidget extends ConsumerStatefulWidget {\n  const MyConsumerStatefulWidget({super.key});\n\n  @override\n  ConsumerState<MyConsumerStatefulWidget> createState() => _MyConsumerStatefulWidgetState();\n}\n\nclass _MyConsumerStatefulWidgetState extends ConsumerState<MyConsumerStatefulWidget> {\n  @override\n  Widget build(BuildContext context) {\n    // use ref here to interact with providers\n    return const Text('Hello World');\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized Select Provider Example\nDESCRIPTION: Demonstrates proper usage of select to watch specific properties.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/combining_providers.mdx#2025-04-23_snippet_7\n\nLANGUAGE: dart\nCODE:\n```\nfinal productsProvider = FutureProvider((ref) {\n  final host = ref.watch(configProvider.select((config) => config.host));\n  return fetchProducts(host);\n});\n```\n\n----------------------------------------\n\nTITLE: Combining Providers Easily in Riverpod (Dart)\nDESCRIPTION: This placeholder represents a Dart code snippet demonstrating how easily providers can be combined in Riverpod using mechanisms like `ref.watch` and `ref.listen`. This contrasts with Provider's more cumbersome and potentially unreliable `ProxyProvider` or using `context.watch` within `create`, offering a more natural and reactive way to build complex state from simpler pieces.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/from_provider/motivation/motivation.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet language=\"dart\" {...combine}></AutoSnippet>\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of List as Provider Argument\nDESCRIPTION: This snippet demonstrates a common mistake of passing a new List instance as an argument to a Riverpod provider, which can lead to infinite network requests due to inconsistent equality.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/passing_args.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nclass Example extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // Don't do this\n    final activity = ref.watch(activityProvider(['recreational', 'cooking']));\n    // ...\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Consuming and Mutating State for Notifier, AsyncNotifier, and StateNotifier in Dart\nDESCRIPTION: Shows that consumers can use the same syntax to obtain and mutate state from Notifier, AsyncNotifier, and StateNotifier. This snippet is useful for easing migration as it confirms that state access and mutation methods remain consistent across these providers. It requires Dart with Riverpod providers.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/migration/from_state_notifier.mdx#_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet raw={consumersDontChange}></AutoSnippet>\n```\n\n----------------------------------------\n\nTITLE: Consolidating Disposal Logic using Notifier and ref.onDispose (Dart)\nDESCRIPTION: Details the unified approach to lifecycle management in Riverpod 2.0 Notifiers, leveraging ref.onDispose within the build method for all clean-up logic. Makes lifecycle side-effects explicit and localized, eliminating the need for disposal logic outside build. Assumes Riverpod 2.0+. Inputs include all dependencies via ref; output is tightly-scoped disposal logic. Addresses prior pitfalls regarding over-scattered lifecycle management.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/migration/from_state_notifier.mdx#_snippet_7\n\nLANGUAGE: dart\nCODE:\n```\n<!-- oldLifecycles.dart content placeholder -->\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Riverpod Provider in Dart\nDESCRIPTION: Demonstrates the basic syntax for creating a Riverpod provider. A `final` variable holds the provider instance (here, a simple `Provider` that exposes an unchanging value). The creation function receives a `ref` object for accessing other providers or lifecycle methods. Providers declared this way are global, immutable, and testable.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/providers.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet language=\"dart\" {...creatingProvider}></AutoSnippet>\n```\n\n----------------------------------------\n\nTITLE: Complete Flutter Widget Test with Riverpod Provider Override (Dart)\nDESCRIPTION: This Dart code snippet showcases a complete widget test for a Flutter application using Riverpod. It defines data models (`Todo`), a data fetching abstraction (`Repository`), Riverpod providers (`repositoryProvider`, `todoListProvider`), a `FakeRepository` for testing, and a simple UI (`TodoItem`, `MaterialApp` with `Consumer`). The `testWidgets` function demonstrates overriding the `repositoryProvider` using `ProviderScope`'s `overrides` property to inject the `FakeRepository`, allowing the test to control the data fetched by `todoListProvider` and verify the widget's behavior during loading and data display states. Dependencies include `flutter`, `flutter_riverpod`, and `flutter_test`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/tr/docusaurus-plugin-content-docs/current/cookbooks/testing.mdx#_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:flutter_test/flutter_test.dart';\n\nclass Repository {\n  Future<List<Todo>> fetchTodos() async {}\n}\n\nclass Todo {\n  Todo({\n    required this.id,\n    required this.label,\n    required this.completed,\n  });\n\n  final String id;\n  final String label;\n  final bool completed;\n}\n\n// Repository örneğimizi bir provider'da kullanıma sunuyoruz\nfinal repositoryProvider = Provider((ref) => Repository());\n\n/// Görev listesi. Burada basitçe sunucudan şunu kullanarak alıyoruz:\n/// [Repository] ve başka hiçbir şey yapmıyoruz.\nfinal todoListProvider = FutureProvider((ref) async {\n  // Repository örneğini alın\n  final repository = ref.read(repositoryProvider);\n\n  // Görevleri alın ve bunları kullanıcı arayüzüne gösterin.\n  return repository.fetchTodos();\n});\n\n/// Önceden tanımlanmış bir görev listesi döndüren sahte Repository uygulaması\nclass FakeRepository implements Repository {\n  @override\n  Future<List<Todo>> fetchTodos() async {\n    return [\n      Todo(id: '42', label: 'Hello world', completed: false),\n    ];\n  }\n}\n\nclass TodoItem extends StatelessWidget {\n  const TodoItem({Key? key, required this.todo}) : super(key: key);\n  final Todo todo;\n  @override\n  Widget build(BuildContext context) {\n    return Text(todo.label);\n  }\n}\n\nvoid main() {\n  testWidgets('override repositoryProvider', (tester) async {\n    await tester.pumpWidget(\n      ProviderScope(\n        overrides: [\n          repositoryProvider.overrideWithValue(FakeRepository())\n        ],\n        // Yapılacaklar listesini görüntülemek için todoListProvider'dan okuyacak uygulamamız.\n        // Bunu muhtemelen bir Uygulamam widget'ına çekeceksiniz\n        child: MaterialApp(\n          home: Scaffold(\n            body: Consumer(builder: (context, ref, _) {\n              final todos = ref.watch(todoListProvider);\n              // Görev listesi yükleniyor veya hatalı\n              if (todos.asData  == null) {\n                return const CircularProgressIndicator();\n              }\n              return ListView(\n                children: [\n                  for (final todo in todos.asData!.value) TodoItem(todo: todo)\n                ],\n              );\n            }),\n          ),\n        ),\n      ),\n    );\n\n    // İlk çerçeve bir yükleme durumudur.\n    expect(find.byType(CircularProgressIndicator), findsOneWidget);\n\n    // Yeniden oluştur. TodoListProvider'ın tüm görevleri zaten getirmiş olması gerekirdi.\n    await tester.pump();\n\n    // Yükleme durumu yok.\n    expect(find.byType(CircularProgressIndicator), findsNothing);\n\n    // FakeRepository tarafından döndürülen verilerle bir görev oluşturuldu\n    expect(tester.widgetList(find.byType(TodoItem)), [\n      isA<TodoItem>()\n          .having((s) => s.todo.id, 'todo.id', '42')\n          .having((s) => s.todo.label, 'todo.label', 'Hello world')\n          .having((s) => s.todo.completed, 'todo.completed', false),\n    ]);\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Optimizing Riverpod Provider Updates using ref.watch and select (Dart)\nDESCRIPTION: Demonstrates the optimized approach using `ref.watch` combined with `selectAsync` (or `select` for synchronous providers). `productsProvider` now only watches the `host` field of the `Configuration` object from `configProvider`. This ensures the provider only rebuilds and re-fetches data when the `host` field actually changes, improving performance. Requires `dio` or similar HTTP client, and `Configuration` and `Product` classes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#2025-04-23_snippet_11\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nfinal configProvider = StreamProvider<Configuration>(...);\n\nfinal productsProvider = FutureProvider<List<Product>>((ref) async {\n  // Осуществляется наблюдение только за полем host. Изменение какого-либо\n  // другого поля Configuration не вызовет пересоздание провайдера.\n  final host = await ref.watch(configProvider.selectAsync((config) => config.host));\n\n  return dio.get('$host/products');\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Todo List Operations with AsyncNotifier in Dart\nDESCRIPTION: Demonstrates a fully migrated AsyncNotifier for a Todo list, including initialization and mutation methods. It showcases simplified error handling and state management compared to ChangeNotifier.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/migration/from_change_notifier.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\nclass TodosNotifier extends AsyncNotifier<List<Todo>> {\n  @override\n  Future<List<Todo>> build() async {\n    return fetchTodos();\n  }\n\n  Future<void> addTodo(Todo todo) async {\n    final previousState = state;\n    state = AsyncValue.loading();\n    state = await AsyncValue.guard(() async {\n      final newTodo = await addTodoAPI(todo);\n      return [...previousState.value ?? [], newTodo];\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using ref.keepAlive with FutureProvider.autoDispose in Dart\nDESCRIPTION: This snippet demonstrates using `ref.keepAlive()` inside an `async` function within a `FutureProvider.autoDispose`. Calling `ref.keepAlive()` after a successful asynchronous operation (like an HTTP request) prevents the provider's state from being disposed even if listeners are removed, preserving the result.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/modifiers/auto_dispose.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nfinal myProvider = FutureProvider.autoDispose((ref) async {\n  final response = await httpClient.get(...);\n  ref.keepAlive();\n  return response;\n});\n```\n\n----------------------------------------\n\nTITLE: Full Application Example with Flutter\nDESCRIPTION: This snippet contains the full source code of the application that puts together the concepts discussed previously. It is meant to demonstrate how the different components interact, including data fetching, UI update with AsyncValue and Riverpod state management. It represents the culmination of the prior snippets and describes how to use all the elements in a cohesive implementation.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/case_studies/pull_to_refresh.mdx#_snippet_6\n\nLANGUAGE: Dart\nCODE:\n```\n\n```\n\n----------------------------------------\n\nTITLE: Cancelling HTTP Requests Using autoDispose with FutureProvider and ref.onDispose in Dart\nDESCRIPTION: Illustrates combining .autoDispose with FutureProvider to perform HTTP requests that can be canceled if the provider is disposed (e.g., user leaves the screen before request finishes). It uses a CancelToken from the dio package to enable canceling the in-flight HTTP request. The ref.onDispose callback cancels the request when the provider is disposed. The ref.keepAlive() call preserves the successful response state. This pattern avoids unnecessary network load and preserves state only when applicable.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/bn/docusaurus-plugin-content-docs/current/concepts/modifiers/auto_dispose.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nfinal myProvider = FutureProvider.autoDispose((ref) async {\n  // package:dio থেকে একটি অবজেক্ট যা HTTP রিকুয়েস্টগুলি বাতিল করার অনুমতি দেয়\n  final cancelToken = CancelToken();\n  // প্রভাইডার ধ্বংস হয়ে গেলে, http রিকুয়েস্টটি বাতিল করুন\n  ref.onDispose(() => cancelToken.cancel());\n\n  // আমাদের ডেটা ফেচ করুন এবং বাতিলকরণ এর জন্য আমাদের `cancelToken` পাস করুন\n  final response = await dio.get('path', cancelToken: cancelToken);\n  // অনুরোধ সফলভাবে সম্পন্ন হলে, স্টেট রাখুন\n  ref.keepAlive();\n  return response;\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing ConsumerWidget in Flutter with Riverpod\nDESCRIPTION: Example showing how to use ConsumerWidget as an alternative to Consumer to reduce code indentation while accessing providers. ConsumerWidget fuses StatelessWidget with Consumer functionality for cleaner code.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/essentials/first_request.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet {...consumerWidget} />\n```\n\n----------------------------------------\n\nTITLE: Combining Multiple Riverpod Modifiers (.autoDispose.family) in Dart\nDESCRIPTION: This snippet shows that multiple Riverpod modifiers can be chained together. Here, `.autoDispose` and `.family` are combined on a `FutureProvider`. This creates a provider that fetches a `User` asynchronously based on a `userId`, and its state will be automatically disposed of when no longer needed. Requires the Riverpod package and an async function `fetchUser`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/providers.mdx#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\n// Assuming User class and fetchUser function are defined elsewhere\nclass User { final String name; User(this.name); }\nFuture<User> fetchUser(int userId) async { \n  // Simulate network request\n  await Future.delayed(Duration(seconds: 1));\n  return User('User $userId'); \n}\n\nfinal userProvider = FutureProvider.autoDispose.family<User, int>((ref, userId) async {\n  return fetchUser(userId);\n});\n```\n\n----------------------------------------\n\nTITLE: Incorrect Read Usage Example\nDESCRIPTION: Shows an anti-pattern of using ref.read inside a provider body.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/combining_providers.mdx#2025-04-23_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nfinal myProvider = Provider((ref) {\n  // Bad: Using ref.read inside the body of a provider\n  final value = ref.read(anotherProvider);\n  return Something(value);\n});\n```\n\n----------------------------------------\n\nTITLE: Passing multiple parameters to .family using Equatable (Dart)\nDESCRIPTION: This code shows how to pass multiple parameters to a `.family` provider by encapsulating them within an Equatable class. Requires the Equatable and Riverpod packages. Assumes the existence of a Something type.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/modifiers/family.mdx#_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nclass MyParameter extends Equatable  {\n  MyParameter({\n    required this.userId,\n    required this.locale,\n  });\n\n  final int userId;\n  final Locale locale;\n\n  @override\n  List<Object> get props => [userId, locale];\n}\n\nfinal exampleProvider = Provider.family<Something, MyParameter>((ref, myParameter) {\n  print(myParameter.userId);\n  print(myParameter.locale);\n  // userId と locale を使って何かする\n});\n\n@override\nWidget build(BuildContext context, WidgetRef ref) {\n  int userId; // ユーザ ID をどこかで取得する\n  final locale = Localizations.localeOf(context);\n\n  final something = ref.watch(\n    exampleProvider(MyParameter(userId: userId, locale: locale)),\n  );\n\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Asynchronous Values Gracefully in Riverpod (Dart)\nDESCRIPTION: This placeholder represents a Dart code snippet showcasing Riverpod's `AsyncValue` API. It illustrates how Riverpod can manage and expose multiple states of an asynchronous operation simultaneously (e.g., previous data alongside a new loading state or error), which is difficult to achieve with Provider. This allows for smoother UI experiences when dealing with data fetching.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/from_provider/motivation/motivation.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet language=\"dart\" {...asyncValues}></AutoSnippet>\n```\n\n----------------------------------------\n\nTITLE: Installing Riverpod Package in pubspec.yaml\nDESCRIPTION: This snippet shows how to add the Riverpod dependency to the pubspec.yaml file for both Flutter and Dart projects.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/introduction/getting_started.mdx#2025-04-23_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\ndependencies:\n  flutter:\n    sdk: flutter\n  flutter_riverpod: ^2.4.9\n  riverpod_annotation: ^2.3.3\n\ndev_dependencies:\n  build_runner:\n  riverpod_generator: ^2.3.9\n  custom_lint:\n  riverpod_lint: ^2.3.7\n```\n\n----------------------------------------\n\nTITLE: Consuming a FutureProvider with AsyncValue pattern in Flutter\nDESCRIPTION: This snippet shows how to consume a FutureProvider in the UI by watching it and handling the different states (loading, error, data) of the returned AsyncValue. It demonstrates proper error and loading state handling when working with asynchronous data.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/providers/future_provider.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n...\n```\n\n----------------------------------------\n\nTITLE: Creating a Configuration Provider with FutureProvider in Dart\nDESCRIPTION: This snippet demonstrates how to create a FutureProvider that reads a configuration file asynchronously from Flutter assets. It returns a Future that resolves to a Configuration object parsed from JSON data.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/providers/future_provider.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nimport 'dart:convert';\n\nimport 'package:flutter/services.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass Configuration {\n  Configuration({required this.host});\n\n  factory Configuration.fromJson(Map<String, Object?> json) {\n    return Configuration(host: json['host']! as String);\n  }\n\n  final String host;\n}\n\nfinal configProvider = FutureProvider<Configuration>((ref) async {\n  // Load the configuration file using Flutter's asset bundle\n  final content = await rootBundle.loadString('assets/configurations.json');\n  \n  // Parse the JSON content\n  final map = jsonDecode(content) as Map<String, Object?>;\n  \n  // Convert the JSON to a Configuration object\n  return Configuration.fromJson(map);\n});\n```\n\n----------------------------------------\n\nTITLE: Multiple Locale Translation with Family Provider\nDESCRIPTION: Example showing how to use a family provider with different parameters simultaneously for translations.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/modifiers/family.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\n@override\nWidget build(BuildContext context, WidgetRef ref) {\n  final frenchTitle = ref.watch(titleFamily(const Locale('fr')));\n  final englishTitle = ref.watch(titleFamily(const Locale('en')));\n\n  return Text('fr: $frenchTitle en: $englishTitle');\n}\n```\n\n----------------------------------------\n\nTITLE: Setting up ProviderScope in Flutter main Function (Dart)\nDESCRIPTION: This snippet demonstrates the essential setup for using Riverpod in a Flutter application. The root widget (`MyApp`) must be wrapped with `ProviderScope` within the `main` function to make providers accessible throughout the widget tree.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/providers.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nvoid main() {\n  runApp(ProviderScope(child: MyApp()));\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Search Functionality with FutureProvider in Dart\nDESCRIPTION: This snippet demonstrates the implementation of a FutureProvider that handles API requests to Stack Overflow based on the search input.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/de/docusaurus-plugin-content-docs/current/cookbooks/search_as_we_type.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nfinal searchFieldProvider = StateProvider<String>((ref) => '');\nfinal questionsProvider = FutureProvider<List>((ref) async {\n  final client = http.Client();\n  ref.onDispose(client.close);\n\n  final search = ref.watch(searchFieldProvider);\n\n  Uri uri;\n\n  if (search.isEmpty) {\n    uri = Uri.parse(\n      'https://api.stackexchange.com/2.3/questions?order=desc&sort=activity&site=stackoverflow',\n    );\n  } else {\n    final encodedQuery = Uri.encodeComponent(search);\n    uri = Uri.parse(\n      'https://api.stackexchange.com/2.3/search?order=desc&sort=activity&intitle=$encodedQuery&site=stackoverflow',\n    );\n  }\n\n  final response = await client.get(uri);\n  final questions = jsonDecode(response.body);\n\n  return questions['items'].map((question) => question['title']).toList();\n});\n```\n\n----------------------------------------\n\nTITLE: Handling Async Values with Riverpod\nDESCRIPTION: Shows how Riverpod can emit multiple values simultaneously, allowing for better handling of asynchronous operations like API calls.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/from_provider/motivation/motivation.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nfinal evenItemsProvider = FutureProvider<List<Item>>((ref) async {\n  final items = await fetchItems();\n  return AsyncValue.guard(() {\n    if (items.isEmpty) return [Item(id: -1)];\n    return items.where((i) => i.id.isEven).toList();\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Immutable Settings State with Riverpod Notifier and Freezed (Dart)\nDESCRIPTION: This Dart code demonstrates creating an immutable settings class using the Freezed package and managing its state with a Riverpod `Notifier`. The `Settings` class uses `@freezed` for immutability and features like `copyWith`. The `SettingsNotifier` extends `Notifier<Settings>` (or generated `_$SettingsNotifier` if using riverpod_generator), providing methods like `setThemeMode` and `setLocale` that update the state by creating new instances. This approach ensures state predictability and separation of concerns. It requires `freezed_annotation`, `riverpod` (or `riverpod_annotation`), and running `build_runner` for code generation.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/why_immutability.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n// Assuming the content imported from whyImmutability looks similar to this:\nimport 'package:flutter/material.dart';\nimport 'package:freezed_annotation/freezed_annotation.dart';\nimport 'package:riverpod_annotation/riverpod_annotation.dart';\n\npart 'settings.freezed.dart';\npart 'settings.g.dart'; // If using riverpod_generator\n\n// 1. Define the immutable state class using freezed\n@freezed\nclass Settings with _$Settings {\n  const factory Settings({\n    @Default(ThemeMode.system) ThemeMode themeMode,\n    String? locale, // Example: 'en', 'es'\n  }) = _Settings;\n}\n\n// 2. Create a Notifier to manage the state\n@riverpod\nclass SettingsNotifier extends _$SettingsNotifier {\n  // The build method initializes the state.\n  // It could load settings from persistence here.\n  @override\nSettings build() {\n    return const Settings(); // Default settings\n  }\n\n  // Method to update the theme mode\n  void setThemeMode(ThemeMode newThemeMode) {\n    // Create a new state object instead of mutating the existing one.\n    state = state.copyWith(themeMode: newThemeMode);\n  }\n\n  // Method to update the locale\n  void setLocale(String newLocale) {\n    state = state.copyWith(locale: newLocale);\n  }\n}\n\n// Usage example (assuming riverpod_generator is used):\n// Widget build(BuildContext context, WidgetRef ref) {\n//   final settings = ref.watch(settingsNotifierProvider);\n//   final settingsNotifier = ref.read(settingsNotifierProvider.notifier);\n//\n//   return Switch(\n//     value: settings.themeMode == ThemeMode.dark,\n//     onChanged: (isDark) {\n//       settingsNotifier.setThemeMode(isDark ? ThemeMode.dark : ThemeMode.light);\n//     },\n//   );\n// }\n\n// If not using riverpod_generator, the provider definition would be:\n// final settingsNotifierProvider = NotifierProvider<SettingsNotifier, Settings>(() {\n//   return SettingsNotifier();\n// });\n```\n\n----------------------------------------\n\nTITLE: Avoiding Side Effects in Provider Initialization (Anti-pattern)\nDESCRIPTION: This example shows an anti-pattern where a provider performs side effects (API POST request) during initialization. Providers should represent read operations, not write operations, as side effects may not execute reliably.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/essentials/do_dont.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nfinal submitProvider = FutureProvider((ref) async {\n  final formState = ref.watch(formState);\n\n  // Sbagliato, i provider non dovrebbero essere usati per operazioni di scrittura\n  return http.post('https://my-api.com', body: formState.toJson());\n});\n```\n\n----------------------------------------\n\nTITLE: Replacing context.read with ref.read\nDESCRIPTION: This code illustrates how to replace `context.read` with `ref.read` when accessing providers outside of the build method in Riverpod. The `StatelessWidget` is changed to `ConsumerWidget` to gain access to the `ref` object.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/migration/0.14.0_to_1.0.0.mdx#_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nclass Example extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    SomeButton(\n      onPressed: () => context.read(provider.notifier).doSomething(),\n    );\n  }\n}\n```\n\nLANGUAGE: dart\nCODE:\n```\nclass Example extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    SomeButton(\n      onPressed: () => ref.read(provider.notifier).doSomething(),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using ref.watch in a Widget Build Method\nDESCRIPTION: Shows how to use ref.watch in a widget to display provider state and update the UI automatically when the state changes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/reading.mdx#2025-04-23_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nclass HomeScreen extends ConsumerWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // Watch the provider and rebuild when its state changes\n    final count = ref.watch(counterProvider);\n\n    return Scaffold(\n      body: Center(\n        // UI that depends on the state\n        child: Text('$count'),\n      ),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Example: Dart-only 'Hello World' with Riverpod\nDESCRIPTION: Sample Dart code illustrating the creation of a Riverpod provider that holds a 'Hello world' string, along with usage to read and print the value in a console application. Demonstrates setting up a provider container, reading the provider's value, and printing it to console.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/Introduction/getting_started.mdx#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\n// Providerを作成します\nfinal provider = Provider<String>((ref) => 'Hello world');\n\nvoid main() {\n  final container = ProviderContainer();\n  final message = container.read(provider);\n  print(message);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Complete Search as You Type Example with Riverpod and Flutter in Dart\nDESCRIPTION: This comprehensive code demonstrates building a fully functional live search interface using Riverpod and Flutter. It defines StateProvider and FutureProvider instances to handle user input and asynchronously fetch data from the StackExchange API using HTTP requests. The widgets, including MyApp and MyHomePage, construct the UI with a search input, networked results list, and error/loading states. The implementation manages disposal of HTTP clients, dynamically switching API endpoints based on user input, and decoding JSON responses. Dependencies include Flutter, flutter_riverpod, http, and dart:convert. Inputs consist of user keystrokes; outputs are StackOverflow question titles matching the query.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/cookbooks/search_as_we_type.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n/*\n// Copyright (c) 2019, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:http/http.dart' as http;\nimport 'dart:convert';\n\nfinal searchFieldProvider = StateProvider<String>((ref) => '');\nfinal questionsProvider = FutureProvider<List>((ref) async {\n  final client = http.Client();\n  ref.onDispose(client.close);\n\n  final search = ref.watch(searchFieldProvider);\n\n  Uri uri;\n\n  if (search.isEmpty) {\n    uri = Uri.parse(\n      'https://api.stackexchange.com/2.3/questions?order=desc&sort=activity&site=stackoverflow',\n    );\n  } else {\n    final encodedQuery = Uri.encodeComponent(search);\n    uri = Uri.parse(\n      'https://api.stackexchange.com/2.3/search?order=desc&sort=activity&intitle=$encodedQuery&site=stackoverflow',\n    );\n  }\n\n  final response = await client.get(uri);\n  final questions = jsonDecode(response.body);\n\n  return questions['items'].map((question) => question['title']).toList();\n});\n\nvoid main() => runApp(const ProviderScope(child: MyApp()));\n\nclass MyApp extends StatelessWidget {\n  const MyApp({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(home: MyHomePage());\n  }\n}\n\nclass MyHomePage extends ConsumerWidget {\n  const MyHomePage({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final questions = ref.watch(questionsProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Questions')),\n      body: Column(\n        children: [\n          TextField(\n            onChanged: (value) =>\n                ref.read(searchFieldProvider.notifier).state = value,\n          ),\n          Expanded(\n            child: switch (questions) {\n              AsyncData(:final value) => ListView.builder(\n                  itemCount: value.length,\n                  itemBuilder: (context, index) {\n                    final question = value[index];\n\n                    return ListTile(\n                      title: Text(\n                        question.toString(),\n                      ),\n                    );\n                  },\n                );,\n              AsyncError(:final error) => Center(child: Text('Error $error')),\n              _ => const Center(child: CircularProgressIndicator()),\n            },\n          ),\n        ],\n      ),\n    );\n  }\n}\n*/\n```\n\n----------------------------------------\n\nTITLE: Fetching packages from pub.dev using Riverpod\nDESCRIPTION: This snippet demonstrates how to create a Riverpod provider that fetches a list of packages from the pub.dev API. It handles pagination and search functionality while Riverpod automatically manages caching, loading states, and error handling.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/introduction.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n// Récupère la liste des packages depuis pub.dev\n@riverpod\nFuture<List<Package>> fetchPackages(\n  Ref ref, {\n  required int page,\n  String search = '',\n}) async {\n  final dio = Dio();\n  // Requête d'une API. Ici, nous utilisons le package dio, mais on pourrait utiliser n'importe quoi d'autre.\n  final response = await dio.get(\n    'https://pub.dartlang.org/api/search?page=$page&q=${Uri.encodeQueryComponent(search)}',\n  );\n\n  // Decode la réponse JSON en une classe Dart.\n  final json = response.data as List;\n  return json.map(Package.fromJson).toList();\n}\n```\n\n----------------------------------------\n\nTITLE: Full Widget Test Using Provider Overrides - Riverpod - Dart\nDESCRIPTION: Presents a complete working example of a Flutter widget test with a provider override, wrapping up all the discussed patterns into a single test. Used as a practical end-to-end test of integrating provider setup with testing strategies. Dependencies: flutter_test, flutter_riverpod, a test FakeRepository implementation, a basic widget (MyApp) under test. Inputs: provider overrides and widget to render and verify. Output: full test flow including provider injection and widget interaction.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/cookbooks/testing.mdx#2025-04-23_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\ntestWidgets('Full widget test with provider overrides', (tester) async {\n  await tester.pumpWidget(\n    ProviderScope(\n      overrides: [\n        repositoryProvider.overrideWithValue(FakeRepository()),\n      ],\n      child: MyApp(),\n    ),\n  );\n\n  await tester.pump();\n  expect(find.text('foo'), findsOneWidget);\n  expect(find.text('bar'), findsOneWidget);\n});\n\n```\n\n----------------------------------------\n\nTITLE: Using ref.watch in Widget Build Method to Update UI (Dart)\nDESCRIPTION: Shows how to use ref.watch inside the build method of a widget (such as ConsumerWidget) to listen for changes in a provider and update the UI reactively. Requires only Riverpod. Inputs: build context and ref; outputs: UI reflecting the latest provider state.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\n// Example: ref.watch in build\nclass MyCountWidget extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final count = ref.watch(countProvider);\n    return Text('Count: $count');\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding a repository provider for testing with Riverpod (Dart and Flutter)\nDESCRIPTION: Illustrates how to override a provider managing a Repository dependency during tests using the overrides parameter on ProviderScope (Flutter) or ProviderContainer (Dart). Enables injecting a mock repository to control responses and isolate tests from external HTTP calls. Requires Riverpod and test packages, with a mock Repository implementation. Inputs: original repositoryProvider and mock implementation; outputs: tested providers receiving overridden behavior.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/cookbooks/testing.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nclass Repository {\n  Future<String> fetchData() async {\n    // real HTTP call\n    return 'Real Data';\n  }\n}\n\nfinal repositoryProvider = Provider<Repository>((ref) => Repository());\n\nfinal todoListProvider = FutureProvider<List<String>>((ref) async {\n  final repo = ref.watch(repositoryProvider);\n  final data = await repo.fetchData();\n  return [data];\n});\n\n// In test:\nfinal mockRepository =\n    Provider<Repository>((_) => MockRepository());\n\nclass MockRepository extends Repository {\n  @override\n  Future<String> fetchData() async {\n    return 'Mock Data';\n  }\n}\n\nvoid main() {\n  testWidgets('uses mock repository', (tester) async {\n    await tester.pumpWidget(\n      ProviderScope(\n        overrides: [repositoryProvider.overrideWithProvider(mockRepository)],\n        child: MyApp(),\n      ),\n    );\n\n    // Test that mock data is used\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Consuming FutureProvider AsyncValue in Flutter UI with Riverpod (Dart)\nDESCRIPTION: This Dart snippet shows how to listen to a FutureProvider in a Flutter widget using ref.watch, which returns an AsyncValue representing the asynchronous state. The example handles loading, error, and data states accordingly to display appropriate user interface feedback. The snippet depends on Riverpod's widget framework and the previously defined FutureProvider. Inputs are asynchronous configuration data, and outputs are conditional UI widgets that automatically rebuild on data changes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/es/docusaurus-plugin-content-docs/current/providers/future_provider.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nclass ConfigurationWidget extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final configAsync = ref.watch(configProvider);\n    return configAsync.when(\n      data: (config) => Text('Settings: \\\\${config.someSetting}'),\n      loading: () => CircularProgressIndicator(),\n      error: (error, stack) => Text('Error: \\\\$error'),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Writing Widget Tests with Riverpod and Flutter testWidgets in Dart\nDESCRIPTION: This snippet presents how to write widget tests that incorporate Riverpod by wrapping the widget tree with a `ProviderScope` in `tester.pumpWidget`. It registers the Riverpod environment during widget testing, allowing interaction with providers and widgets. The snippet also demonstrates retrieving `ProviderContainer` from widget contexts using `ProviderScope.containerOf`. It relies on the `flutter_test` package and the Riverpod Flutter integration.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/essentials/testing.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Synchronous Todo List with NotifierProvider\nDESCRIPTION: Example of implementing a synchronous todo list using NotifierProvider in Riverpod. Shows how to define a Notifier class with state management methods like addTodo for managing a list of todos.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/providers/notifier_provider.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet language=\"dart\" {...todos}></AutoSnippet>\n```\n\nLANGUAGE: dart\nCODE:\n```\n{trimSnippet(todosConsumer)}\n```\n\n----------------------------------------\n\nTITLE: Prefer Statically Known Providers With ref.watch/read/listen - Dart\nDESCRIPTION: Emphasizes the usage of statically declared providers as top-level final variables to maximize linting effectiveness and enable static analysis by Riverpod tools. Dynamically created or instance member providers reduce code analyzability and increase false positives or missed bugs. The snippet contrasts proper static provider declaration versus passing providers as instance variables to widgets, which breaks static analysis.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/essentials/do_dont.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nfinal provider = Provider((ref) => 42);\n\n...\n\n// 好的，因为提供者程序是静态已知的\nref.watch(provider);\n```\n\nLANGUAGE: dart\nCODE:\n```\nclass Example extends ConsumerWidget {\n  Example({required this.provider});\n  final Provider<int> provider;\n\n  @override\n  Widget build(context, ref) {\n    // 不好，因为静态分析无法知道 `provider` 是什么\n    ref.watch(provider);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Sorting Products using a Derived Provider in Riverpod (Dart)\nDESCRIPTION: This snippet demonstrates implementing a computed or derived provider that sorts the product list based on the chosen sort type from StateProvider. By watching both the base product list and the sort type provider, this approach enables automatic recomputation and UI refresh when either changes. Requires: Riverpod. Inputs: base products provider, sort type provider. Outputs: sorted product list. Suitable for building reactive UIs where derived state changes as dependencies do.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/providers/state_provider.mdx#_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\n/* Example Dart code for a sorted product provider. See sorted_product_provider.dart for the full implementation. */\n```\n\n----------------------------------------\n\nTITLE: Mocking Riverpod Notifiers by Subclassing Base Classes in Dart\nDESCRIPTION: This code explains the recommended approach to mocking Riverpod Notifiers: subclassing the base Notifier class instead of implementing the Notifier interface. This practice prevents interface breakage due to Riverpod internal behavior. The snippet warns against using typical mockito interface mocks, provides example subclass mock code, and suggests placing mocks in the same file as the Notifier to enable access to generated classes. It also covers overriding providers with mock notifiers and using them in tests.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/essentials/testing.mdx#_snippet_8\n\nLANGUAGE: dart\nCODE:\n```\n// モックはNotifierのベースクラスをサブクラス化する必要があります。\n```\n\n----------------------------------------\n\nTITLE: Invalidating Provider to Reload Data in Riverpod (Italian)\nDESCRIPTION: This snippet shows how to use `ref.invalidateSelf()` to force a re-execution of the GET request associated with a provider after a POST request. This ensures the UI reflects the latest server state, regardless of server implementation details. However, it involves an additional GET request.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/essentials/side_effects.mdx#_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\ninvalidateSelfAddTodo\n```\n\n----------------------------------------\n\nTITLE: Using ref.read to read\nDESCRIPTION: This code shows how to use `ref.read` to read the current value of a provider.  It's typically used in event handlers, like the `onPressed` of a button, to perform an action based on the provider's current state.  It should be used sparingly and with caution.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_9\n\nLANGUAGE: Dart\nCODE:\n```\nElevatedButton(\n  onPressed: () {\n    final count = ref.read(counterProvider);\n    ref.read(counterProvider.notifier).increment();\n  },\n  child: const Text('Increment'),\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Detail Page in Flutter using Riverpod (Dart)\nDESCRIPTION: This snippet details the implementation of the activity detail page in the app. It demonstrates fetching remote data (from the Bored API) and integrating optional pull-to-refresh functionality. This example assumes a Riverpod provider is used for managing network requests. Required dependencies: flutter, flutter_riverpod, http. Inputs: page navigation events and refresh triggers; outputs: activity data displayed asynchronously. Limitations: No debouncing or cancellation logic at this point.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/case_studies/cancel.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n/* code from detailScreen (lib/src/detail_screen.dart) */\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple City Provider in Dart\nDESCRIPTION: Demonstrates the creation of a basic Riverpod `Provider` named `cityProvider` that exposes a static string value representing a city name ('London'). This provider serves as a dependency for other providers that might need access to the current city.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n/// A provider that exposes the current city\nfinal cityProvider = Provider<String>((ref) {\n  return 'London';\n});\n```\n\n----------------------------------------\n\nTITLE: Debouncing Requests in Riverpod using ref.onDispose (Dart)\nDESCRIPTION: This snippet demonstrates debouncing network requests in Riverpod by delaying execution with a Future.delayed, combined with ref.onDispose to abort pending requests if the provider is disposed before the delay completes. If repeated refreshes occur within the debounce interval (e.g., 500ms), only the latest request is sent, reducing bandwidth and server load. Dependencies: flutter_riverpod, http, async. Inputs: user-triggered refreshes; outputs: a single API request after debouncing. Limitation: The debounce interval is hardcoded and must be tuned as needed.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/case_studies/cancel.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\n/* code from detailScreenDebounce */\n```\n\n----------------------------------------\n\nTITLE: Example implementation of todos with ChangeNotifierProvider\nDESCRIPTION: This code snippet demonstrates a typical use case where ChangeNotifierProvider manages a list of todos. It exposes methods such as addTodo for UI interaction, aiding in mutable state management within Flutter using Riverpod. The snippet assumes the existence of a ChangeNotifier class managing the todos.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/providers/change_notifier_provider.mdx#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\n<CodeBlock>{trimSnippet(todos)}</CodeBlock>\n```\n\n----------------------------------------\n\nTITLE: Initializing AsyncNotifier State in Riverpod (Dart)\nDESCRIPTION: This snippet illustrates initialization of the AsyncNotifier by providing the data-loading logic directly within the build method. Dependencies include Riverpod for Dart and any required network/data fetching services. The build method drops any explicit isLoading or hasError flags, returning a Future<List<Todo>> instead. Inputs are handled implicitly, and Riverpod provides error/loading/data state via AsyncValue. This design encourages concise code and eliminates boilerplate associated with manual async state management.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/migration/from_change_notifier.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n/* ... code from /docs/migration/from_change_notifier/initialization ... */\n```\n\n----------------------------------------\n\nTITLE: Overriding Providers for Testing in Riverpod (Dart)\nDESCRIPTION: This snippet shows how easily providers can be overridden in Riverpod for testing purposes using the 'override' utility.  This simplifies testing stateful logic, offering a more convenient collection of tools than Provider.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/from_provider/motivation/motivation.mdx#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nimport override from \"/docs/from_provider/motivation/override\";\n```\n\n----------------------------------------\n\nTITLE: Defining a StateProvider for Sort Type in Riverpod\nDESCRIPTION: Creates a StateProvider to manage the selected sort type state. This provider will store the current sort option (by name or by price) that can be changed by the UI.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/providers/state_provider.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nenum ProductSortType {\n  name,\n  price,\n}\n\nfinal productSortTypeProvider = StateProvider<ProductSortType>((ref) {\n  // Default value\n  return ProductSortType.name;\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Immutable Settings with Freezed and Riverpod\nDESCRIPTION: This example demonstrates how to create an immutable Settings class using Freezed and implement a SettingsNotifier with Riverpod to manage theme changes. The code shows proper state handling with immutable objects including the use of copyWith methods for state updates.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/why_immutability.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nimport 'package:freezed_annotation/freezed_annotation.dart';\nimport 'package:riverpod_annotation/riverpod_annotation.dart';\n\npart 'settings.freezed.dart';\npart 'settings.g.dart';\n\n@freezed\nclass Settings with _$Settings {\n  factory Settings({\n    /// The current theme mode\n    required ThemeMode themeMode,\n  }) = _Settings;\n}\n\nenum ThemeMode {\n  light,\n  dark,\n  system,\n}\n\n@riverpod\nclass SettingsNotifier extends _$SettingsNotifier {\n  @override\n  Settings build() {\n    return Settings(themeMode: ThemeMode.system);\n  }\n\n  /// Change the theme mode\n  void setThemeMode(ThemeMode themeMode) {\n    state = state.copyWith(themeMode: themeMode);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Refresh Logic with Flutter\nDESCRIPTION: This snippet shows how to add refresh logic by handling the `onRefresh` callback of the `RefreshIndicator`. It refreshes a provider by using `ref.refresh`. It then reads the '.future' property of the provider to await its completion, ensuring that the refresh indicator remains visible until the data is updated. This ties the user interaction of pulling down with the action of refetching data.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/case_studies/pull_to_refresh.mdx#_snippet_4\n\nLANGUAGE: Dart\nCODE:\n```\n        // \\\"activityProvider.future\\\"를 새로 고치고 해당 결과를 반환합니다,\n        // 새 활동을 가져올 때까지 새로 고침 표시기가 계속 표시됩니다.\n```\n\n----------------------------------------\n\nTITLE: Defining AsyncNotifierProvider for Remote Todo List in Dart\nDESCRIPTION: This snippet demonstrates defining an `AsyncNotifier` subclass (`RemoteTodosNotifier`) to manage an asynchronous list of `Todo` objects, typically fetched from a remote source. The `build` method is asynchronous and returns a `Future` or `FutureOr` of the initial state. Methods like `addTodo` likely involve asynchronous operations as well. An `AsyncNotifierProvider` (`remoteTodosProvider`) exposes the `RemoteTodosNotifier`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/providers/notifier_provider.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n// Code dynamically loaded via <AutoSnippet language=\"dart\" {...remoteTodos}>\n// This typically defines an AsyncNotifier class and an AsyncNotifierProvider.\n\n// Example structure:\n// class Todo { ... }\n// \n// @riverpod\n// class RemoteTodosNotifier extends _$RemoteTodosNotifier {\n//   Future<List<Todo>> _fetchTodos() async {\n//     // API call logic\n//     return []; \n//   }\n//\n//   @override\n//   FutureOr<List<Todo>> build() async {\n//     // Load initial state asynchronously\n//     return _fetchTodos();\n//   }\n// \n//   Future<void> addTodo(Todo todo) async {\n//     // Update state optimistically or after API call\n//     state = const AsyncValue.loading();\n//     try {\n//       // Call API to add todo\n//       // await api.addTodo(todo);\n//       // Refetch or update state locally\n//       final updatedTodos = await _fetchTodos(); \n//       state = AsyncValue.data(updatedTodos);\n//     } catch (e, s) {\n//       state = AsyncValue.error(e, s);\n//     }\n//   }\n//   // Other async methods...\n// }\n//\n// // The generated provider would be:\n// final remoteTodosProvider = AsyncNotifierProvider<RemoteTodosNotifier, List<Todo>>(/* ... */);\n```\n\n----------------------------------------\n\nTITLE: Accessing ProviderContainer in Widget Test - Dart\nDESCRIPTION: This snippet explains how to obtain a `ProviderContainer` within a widget test to interact with providers. It leverages `ProviderScope.containerOf(buildContext)` to access the container associated with a specific widget's context, allowing for provider reads, listens and overrides. Requires Riverpod and Flutter.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/essentials/testing.mdx#_snippet_3\n\nLANGUAGE: Dart\nCODE:\n```\nfinal container = ProviderScope.containerOf(context);\nfinal value = container.read(myProvider);\n```\n\n----------------------------------------\n\nTITLE: Simultaneous Consumption of .family Providers With Different Parameters (Dart)\nDESCRIPTION: This snippet illustrates reading from the same family provider with different arguments in a Flutter widget, a common scenario for multi-locale translation or dynamic queries. Both French and English titles are fetched by passing different Locale parameters. Input: two Locale values; output: two different title values. Relies on Riverpod, Flutter's Locale, and a pre-defined titleFamily provider.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/modifiers/family.mdx#2025-04-23_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\n@override\nWidget build(BuildContext context, WidgetRef ref) {\n  final frenchTitle = ref.watch(titleFamily(const Locale('fr')));\n  final englishTitle = ref.watch(titleFamily(const Locale('en')));\n\n  return Text('fr: $frenchTitle en: $englishTitle');\n}\n```\n\n----------------------------------------\n\nTITLE: pubspec.yaml for Dart-only Riverpod\nDESCRIPTION: YAML snippet to add the Riverpod package in pubspec.yaml for Dart-only projects, facilitating dependency inclusion without Flutter.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/getting_started.mdx#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n<AutoSnippet title=\"pubspec.yaml\" language=\"yaml\" {...dartPubspec}></AutoSnippet>\n```\n\n----------------------------------------\n\nTITLE: Convert Provider to Notifier\nDESCRIPTION: This snippet demonstrates converting a simple provider into a notifier. It showcases the use of `AsyncNotifierProvider` due to the asynchronous nature of the logic, and also mentions the use of `autoDispose` modifier. The `build` method contains the logic previously present in a `FutureProvider`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/essentials/side_effects.mdx#_snippet_3\n\nLANGUAGE: Dart\nCODE:\n```\n// 이제 FutureProvider 대신 AsyncNotifierProvider를 사용합니다.\n    // 로직이 비동기식이기 때문에 AsyncNotifier를 사용합니다.\n    // 더 구체적으로 말하자면, \"autoDispose\" 한정자(Modifier) 때문에\n    // AutoDisposeAsyncNotifier가 필요합니다.\n    // 이전에 FutureProvider에 있던 로직이 이제 build 메서드에 있습니다.\n```\n\n----------------------------------------\n\nTITLE: Defining a NotifierProvider for Todos in Riverpod (Dart)\nDESCRIPTION: This snippet illustrates the creation of a NotifierProvider that manages a list of todos using Riverpod in Dart. The provider can be watched by other providers or widgets, allowing for centralized state management. It requires Riverpod as a dependency and expects a Todo model to be defined elsewhere; its output is the current list of todos as managed by the notifier.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/providers/provider.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n// Assume Todo is a custom class representing a todo item\nfinal todosProvider = NotifierProvider<TodosNotifier, List<Todo>>(TodosNotifier.new);\n```\n\n----------------------------------------\n\nTITLE: Migrating StreamProvider from Manual to Code-Generated in Dart\nDESCRIPTION: The example demonstrates switching from a manually declared stream provider to a code-generated stream-based async function. It highlights the key change to streamline stream handling with code generation.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/about_code_generation.mdx#_snippet_9\n\nLANGUAGE: dart\nCODE:\n```\n{trimSnippet(streamProvider)}\n```\n\n----------------------------------------\n\nTITLE: Migrated AsyncNotifier implementation with simplified mutations and side effects in Dart\nDESCRIPTION: This snippet fully migrates the example ChangeNotifier to an AsyncNotifier in Riverpod, demonstrating concise handling of asynchronous mutations such as addTodo without excess try/catch/finally blocks or explicit boolean flags. State modifications are made by reassigning the immutable state property, and error handling is managed implicitly via AsyncValue. The snippet embodies Riverpod's class-based API benefits with reduced boilerplate and more declarative asynchronous state management.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/migration/from_change_notifier.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nimport migrated from \"/docs/migration/from_change_notifier/migrated\";\n```\n\n----------------------------------------\n\nTITLE: Implementing and Utilizing AsyncNotifierProvider for Remote Data in Dart\nDESCRIPTION: This snippet illustrates the use of AsyncNotifierProvider in Riverpod to handle asynchronous state, such as fetching remote data. It shows how to expose methods like addTodo to modify remote task lists and provides code snippets using auto-generation and code blocks for interaction with the asynchronous data store.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/providers/notifier_provider.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet language=\"dart\" {...remoteTodos}></AutoSnippet>\n\n<CodeBlock>{trimSnippet(remoteTodosConsumer)}</CodeBlock>\n```\n\n----------------------------------------\n\nTITLE: Creating a FutureProvider in Dart\nDESCRIPTION: 이 코드 스니펫은 Bored API에서 Activity를 _GET_하는 `activityProvider`라는 provider를 정의합니다.  `FutureProvider`를 사용하여 비동기 연산을 처리하고, UI가 이 provider를 읽을 때까지 네트워크 요청이 실행되지 않으며, 이후 읽기는 캐시된 값을 반환합니다. 또한 오류 처리가 기본적으로 처리됩니다.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/essentials/first_request.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n { ...provider} \n```\n\n----------------------------------------\n\nTITLE: Defining Product Class - Dart\nDESCRIPTION: This code defines a `Product` class, including properties like `name`, `price`, and `isFavorite`. This class is used in the examples to demonstrate StateProvider functionality. It doesn't have any dependencies other than the standard Dart library.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/providers/state_provider.mdx#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\n// Code for Product Class Definition (product.dart)\n```\n\n----------------------------------------\n\nTITLE: Handling AsyncValue with ref.watch in Flutter (Dart)\nDESCRIPTION: Illustrates consuming an asynchronous provider (like `StreamProvider` or `FutureProvider`) within a Flutter widget's `build` method using `ref.watch`. It uses a `switch` expression to pattern-match on the `AsyncValue` state (`AsyncData`, `AsyncError`, or loading) and render the appropriate UI. Depends on `BuildContext`, `WidgetRef`, and the `userProvider`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_12\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, WidgetRef ref) {\n  AsyncValue<User> user = ref.watch(userProvider);\n\n  return switch (user) {\n    AsyncData(:final value) => Text(value.name),\n    AsyncError(:final error) => const Text('Oops $error'),\n    _ => const CircularProgressIndicator(),\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Todo StateNotifierProvider with Riverpod in Dart\nDESCRIPTION: This snippet defines a StateNotifier for managing a list of todos using Riverpod in Dart. It establishes a StateNotifier subclass to encapsulate the application logic for adding, removing, or updating todos, and exposes a StateNotifierProvider to make the notifier accessible throughout the app. Dependencies include the state_notifier and riverpod packages. The primary input is event-driven UI interactions; the output is an updated immutable state. Key parameters are the todo objects/fields and the add/remove/update methods in the notifier. The snippet must be placed at a global or provider layer for consumption by the UI.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/providers/state_notifier_provider.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nclass Todo {\n  final String description;\n  final bool completed;\n\n  Todo({required this.description, this.completed = false});\n\n  Todo copyWith({String? description, bool? completed}) {\n    return Todo(\n      description: description ?? this.description,\n      completed: completed ?? this.completed,\n    );\n  }\n}\n\nclass TodosNotifier extends StateNotifier<List<Todo>> {\n  TodosNotifier() : super([]);\n\n  void addTodo(String description) {\n    state = [...state, Todo(description: description)];\n  }\n\n  void toggle(int index) {\n    final todo = state[index];\n    state = [\n      for (int i = 0; i < state.length; i++)\n        if (i == index) todo.copyWith(completed: !todo.completed) else state[i]\n    ];\n  }\n}\n\nfinal todosProvider = StateNotifierProvider<TodosNotifier, List<Todo>>((ref) {\n  return TodosNotifier();\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing a Remote Todo List State with AsyncNotifierProvider in Dart\nDESCRIPTION: This Dart snippet demonstrates the implementation of a remote todo list using Riverpod's AsyncNotifierProvider. It handles asynchronous initialization and exposes methods like `addTodo` for modifying the list. This snippet requires Riverpod and illustrates managing state that may change asynchronously, such as fetching data from a remote source.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/providers/notifier_provider.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n/// Example snippet for asynchronous remote todo list with AsyncNotifierProvider\n// Manages async state and updates for todos fetched or synchronized remotely.\n\n```\n\n----------------------------------------\n\nTITLE: Defining AsyncNotifier with autoDispose and family (Dart)\nDESCRIPTION: Demonstrates Streamlined declaration of AsyncNotifier using autoDispose and family modifiers in Riverpod 2.0+. Inputs (family arguments) are injected into build method, centralizing initialization logic. Relies on Riverpod 2.0+. Improves readability and reduces likelihood of parameter mismanagement present in older APIs.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/migration/from_state_notifier.mdx#_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\n<!-- familyAndDispose.dart content placeholder -->\n```\n\n----------------------------------------\n\nTITLE: Parameterized Provider using Freezed data class with .family in Dart\nDESCRIPTION: Illustrates how to pass complex multiple parameters to a family provider using a Freezed immutable data class. The example defines a MyParameter class with userId and locale fields, which are then passed to the provider to obtain customized data. This requires dependencies on Freezed and Riverpod packages, with generated code support.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/concepts/modifiers/family.mdx#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\n@freezed\nabstract class MyParameter with _$MyParameter {\n  factory MyParameter({\n    required int userId,\n    required Locale locale,\n  }) = _MyParameter;\n}\n\nfinal exampleProvider = Provider.autoDispose.family<Something, MyParameter>((ref, myParameter) {\n  print(myParameter.userId);\n  print(myParameter.locale);\n  // Faire quelque chose avec userId/locale.\n});\n\n@override\nWidget build(BuildContext context, WidgetRef ref) {\n  int userId; // Lire le user ID de quelque part\n  final locale = Localizations.localeOf(context);\n\n  final something = ref.watch(\n    exampleProvider(MyParameter(userId: userId, locale: locale)),\n  );\n\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Passing Multiple Parameters with Freezed - Dart\nDESCRIPTION: This example uses the `Freezed` package to create an immutable class `MyParameter` with `userId` and `locale` properties. This class is then used as the parameter for a `Provider.autoDispose.family`. This approach allows passing multiple related values to a provider while ensuring proper `hashCode` and `==` implementations.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/bn/docusaurus-plugin-content-docs/current/concepts/modifiers/family.mdx#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\n@freezed\nabstract class MyParameter with _$MyParameter {\n  factory MyParameter({\n    required int userId,\n    required Locale locale,\n  }) = _MyParameter;\n}\n\nfinal exampleProvider = Provider.autoDispose.family<Something, MyParameter>((ref, myParameter) {\n  print(myParameter.userId);\n  print(myParameter.locale);\n  // userId/locale দিয়ে কিছু করুন\n});\n\n@override\nWidget build(BuildContext context, WidgetRef ref) {\n  int userId; // userId অন্য কোথাও থেকে পড়ুন\n  final locale = Localizations.localeOf(context);\n\n  final something = ref.watch(\n    exampleProvider(MyParameter(userId: userId, locale: locale)),\n  );\n\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Consuming Async Data with Riverpod in Flutter UI\nDESCRIPTION: This snippet shows how to consume the asynchronous data from a Riverpod provider in a Flutter widget. It demonstrates handling different states (loading, error, data) using Dart's pattern matching with switch expressions, providing a clean and declarative way to manage UI states.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/flutter_riverpod/README.md#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nclass Home extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final boredSuggestion = ref.watch(boredSuggestionProvider);\n    // Perform a switch-case on the result to handle loading/error states\n    return switch (boredSuggestion) {\n      AsyncData(:final value) => Text('data: $value'),\n      AsyncError(:final error) => Text('error: $error'),\n      _ => const Text('loading'),\n    };\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Dart 3 Records for Multiple Provider Arguments\nDESCRIPTION: This example shows how to use Dart 3 records to pass multiple arguments (activity type and maximum price) to a Riverpod provider, leveraging natural equality override.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/passing_args.mdx#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nfinal activityProvider = FutureProvider.autoDispose.family<Activity, (String, double)>((ref, params) async {\n  final (type, maxPrice) = params;\n  final activity = await http.get(Uri.https(\n    'www.boredapi.com',\n    '/api/activity',\n    {'type': type, 'maxprice': maxPrice.toString()},\n  ));\n\n  return Activity.fromJson(jsonDecode(activity.body));\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing a ConsumerStatefulWidget in Dart for Riverpod\nDESCRIPTION: This snippet demonstrates how to create a ConsumerStatefulWidget and its corresponding ConsumerState. The ConsumerState has a 'ref' property that can be used to interact with providers.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/de/docusaurus-plugin-content-docs/current/concepts/reading.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nclass HomeView extends ConsumerStatefulWidget {\n  const HomeView({Key? key}): super(key: key);\n\n  @override\n  HomeViewState createState() => HomeViewState();\n}\n\nclass HomeViewState extends ConsumerState<HomeView> {\n  @override\n  Widget build(BuildContext context) {\n    // We can use ref here\n    return Container();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using ref.listen to react to provider changes in Dart Riverpod\nDESCRIPTION: This snippet demonstrates how to use ref.listen within a Provider or within a widget's build method to observe changes in a provider, enabling execution of side effects (e.g., logging or showing a snackbar) when the provider's state updates. It highlights that ref.listen should not be called asynchronously or within initState, emphasizing proper placement within build or provider contexts.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/es/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\nfinal counterProvider = StateNotifierProvider<Counter, int>((ref) => Counter());\n\nfinal anotherProvider = Provider((ref) {\n  ref.listen<int>(counterProvider, (int? previousCount, int newCount) {\n    print('The counter changed $newCount');\n  });\n  // ...\n});\n```\n\nLANGUAGE: Dart\nCODE:\n```\nfinal counterProvider = StateNotifierProvider<Counter, int>((ref) => Counter());\n\nclass HomeView extends ConsumerWidget {\n  const HomeView({Key? key}): super(key: key);\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    ref.listen<int>(counterProvider, (int? previousCount, int newCount) {\n      print('The counter changed $newCount');\n    });\n\n    return Container();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Migration of Provider from Non-code Generation to Code-Generated in Dart\nDESCRIPTION: This snippet demonstrates how to transition a basic Provider from its manual, non-code generated form to an auto-generated version in Dart using Riverpod. It details the before and after implementations, highlighting the use of type annotations and the advantages of code generation for maintainability and clarity.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/about_code_generation.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nBefore: <code snippet of original provider definition in non-code gen style>\n```\n\nLANGUAGE: dart\nCODE:\n```\nAfter: <code snippet of updated provider using code generation in Dart>\n```\n\n----------------------------------------\n\nTITLE: Optimized State Update Using update Function\nDESCRIPTION: Demonstrates a more efficient way to update state based on previous value using the update function.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/providers/state_provider.mdx#2025-04-23_snippet_7\n\nLANGUAGE: dart\nCODE:\n```\nref.read(counter.notifier).update((state) => state + 1);\n```\n\n----------------------------------------\n\nTITLE: Full Flutter Widget Test with Provider Overrides (Dart)\nDESCRIPTION: This is a complete Flutter widget test that combines provider overriding, dependency injection, and widget interaction. It uses ProviderScope to inject a fake repository and verifies the widget's behavior with assertions. Suitable as a blueprint for large-scale integration tests. Dependencies: flutter_riverpod, flutter_test, any mock/fake used. Inputs: widget tester; Outputs: widget expectations.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/cookbooks/testing.mdx#2025-04-23_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nvoid main() {\n  testWidgets('Full widget test with provider overrides', (tester) async {\n    final fakeRepository = FakeRepository();\n    await tester.pumpWidget(\n      ProviderScope(\n        overrides: [\n          repositoryProvider.overrideWithValue(fakeRepository),\n        ],\n        child: MyApp(),\n      ),\n    );\n    // further test logic...\n  });\n}\n\n```\n\n----------------------------------------\n\nTITLE: Consuming a FutureProvider in a Flutter Widget\nDESCRIPTION: This code shows how to consume a FutureProvider in a Flutter widget. It demonstrates handling of loading, error, and data states using AsyncValue, and automatically rebuilds the UI when the Future completes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/providers/future_provider.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nConsumer(\n  builder: (context, ref, child) {\n    final config = ref.watch(configProvider);\n    return config.when(\n      loading: () => const CircularProgressIndicator(),\n      error: (err, stack) => Text('Error: $err'),\n      data: (config) {\n        return Text('The config is ${config.toString()}');\n      },\n    );\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Reading provider values without triggering rebuilds using ref.read\nDESCRIPTION: Illustrates how to access provider data statically within an object like a Repository class, without subscribing to updates that cause rebuilds. Uses ref.read to fetch current values explicitly.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/es/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#_snippet_4\n\nLANGUAGE: Dart\nCODE:\n```\nfinal userTokenProvider = StateProvider<String>((ref) => null);\n\nfinal repositoryProvider = Provider((ref) => Repository(ref.read));\n\nclass Repository {\n  Repository(this.read);\n  final Reader read;\n\n  Future<Catalog> fetchCatalog() async {\n    String token = read(userTokenProvider);\n    final response = await dio.get('/path', queryParameters: {\n      'token': token,\n    });\n    return Catalog.fromJson(response.data);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using HookConsumerWidget to Combine Providers and Hooks (Dart)\nDESCRIPTION: This pattern is for flutter_hooks users who want to combine hooks with Riverpod providers. By extending HookConsumerWidget, a widget can both use Flutter hooks and obtain a 'ref' in its build method. Requires the hooks_riverpod package, and optionally flutter_hooks. Expects context and ref as parameters, and outputs widgets that leverage provider and hook functionality.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\n// Example: HookConsumerWidget pattern\nclass MyHookWidget extends HookConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final count = ref.watch(counterProvider);\n    final controller = useTextEditingController();\n    return Column(\n      children: [Text('$count'), TextField(controller: controller)],\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a ConsumerWidget to Access ref - Riverpod Dart\nDESCRIPTION: This snippet illustrates creating a ConsumerWidget, Riverpod's drop-in replacement for StatelessWidget that adds a 'ref' parameter to the build method. This enables the widget to watch or read provider states reactively. No extra dependencies are required beyond Riverpod/Flutter; inputs are the build context and ref, while outputs are the constructed widget tree.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/reading.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nclass MyConsumerWidget extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final value = ref.watch(myProvider);\n    return Text('$value');\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Combining Riverpod State, Stream, and Future Providers for Dynamic Data Fetching (Dart)\nDESCRIPTION: Demonstrates combining multiple providers (`StateProvider` for search, `StreamProvider` for config, `FutureProvider` for results) for dynamic data fetching. The `charactersProvider` watches the search query and awaits the latest configuration, re-fetching characters when either dependency changes. Requires `dio` or a similar HTTP client, and `Configuration` and `Character` classes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#2025-04-23_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\n```dart\n// Текущий поисковый запрос\nfinal searchProvider = StateProvider((ref) => '');\n\n/// Конфигурация, которая может меняться со временем\nfinal configsProvider = StreamProvider<Configuration>(...);\n\nfinal charactersProvider = FutureProvider<List<Character>>((ref) async {\n  final search = ref.watch(searchProvider);\n  final configs = await ref.watch(configsProvider.future);\n  final response = await dio.get('${configs.host}/characters?search=$search');\n\n  return response.data.map((json) => Character.fromJson(json)).toList();\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Todo List Provider Implementation\nDESCRIPTION: Implements a NotifierProvider for managing a todo list with state updates.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/combining_providers.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nclass TodoList extends Notifier<List<Todo>> {\n  @override\n  List<Todo> build() => [];\n\n  void addTodo(Todo todo) {\n    state = [...state, todo];\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating an autoDispose StreamProvider in Riverpod (Dart)\nDESCRIPTION: This code demonstrates how to define a Riverpod StreamProvider with the autoDispose modifier in Dart. By appending .autoDispose, the userProvider's state will be destroyed automatically when it is no longer observed. No dependencies are shown here, but typically a type such as User would be imported or defined. The function receives a ProviderReference (ref) as a parameter, granting access to provider lifecycle APIs.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/modifiers/auto_dispose.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nfinal userProvider = StreamProvider.autoDispose<User>((ref) {\n\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling riverpod_lint custom analysis options in analysis_options.yaml\nDESCRIPTION: Sample configuration to activate custom lint rules for Riverpod by adding a plugin section to analysis_options.yaml. This setup helps IDEs and analysis tools warn about incorrect usage and offer refactoring suggestions for Riverpod code.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/Introduction/getting_started.mdx#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nanalyzer:\n  plugins:\n    - custom_lint\n```\n\n----------------------------------------\n\nTITLE: Initializing FutureProvider for Asynchronous Configuration Loading in Dart\nDESCRIPTION: This Dart snippet demonstrates defining a FutureProvider that asynchronously reads a JSON configuration file using Flutter's asset system. The provider encapsulates the async/await logic to fetch and parse the configuration, allowing the result to be cached and shared across widgets. It requires access to Flutter's asset bundle and typical Dart async/await constructs. The output is a Future-wrapped Configuration object, suitable for use with Riverpod's ref.watch for reactive UI updates.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/es/docusaurus-plugin-content-docs/current/providers/future_provider.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nfinal configProvider = FutureProvider<Configuration>((ref) async {\n  final jsonString = await rootBundle.loadString('assets/config.json');\n  final jsonMap = jsonDecode(jsonString) as Map<String, dynamic>;\n  return Configuration.fromJson(jsonMap);\n});\n```\n\n----------------------------------------\n\nTITLE: Caching Completed Todos with Provider - Dart\nDESCRIPTION: This code snippet utilizes a Provider to create a cached, filtered list of completed todo items. It depends on the `todoListProvider` to access the main todo list and uses `ref.watch` to automatically update when the todo list changes, ensuring that the filtering is only re-calculated when necessary.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/es/docusaurus-plugin-content-docs/current/providers/provider.mdx#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nimport 'todo.dart';\n\nfinal completedTodosProvider = Provider<List<Todo>>((ref) {\n  final todos = ref.watch(todoListProvider);\n  return todos.where((todo) => todo.completed).toList();\n});\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Riverpod StateProvider for Filter State (Dart)\nDESCRIPTION: Defines an enumeration `Filter` with possible filter values (`none`, `completed`, `uncompleted`) and a `StateProvider` named `filterProvider` to manage the currently selected filter state.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nenum Filter {\n  none,\n  completed,\n  uncompleted,\n}\n\nfinal filterProvider = StateProvider((ref) => Filter.none);\n```\n```\n\n----------------------------------------\n\nTITLE: Multiple Parameters with Freezed\nDESCRIPTION: Implementation of a family provider that accepts multiple parameters using Freezed package.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/modifiers/family.mdx#2025-04-23_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\n@freezed\nabstract class MyParameter with _$MyParameter {\n  factory MyParameter({\n    required int userId,\n    required Locale locale,\n  }) = _MyParameter;\n}\n\nfinal exampleProvider = Provider.autoDispose.family<Something, MyParameter>((ref, myParameter) {\n  print(myParameter.userId);\n  print(myParameter.locale);\n  // Do something with userId/locale\n});\n\n@override\nWidget build(BuildContext context, WidgetRef ref) {\n  int userId; // Read the user ID from somewhere\n  final locale = Localizations.localeOf(context);\n\n  final something = ref.watch(\n    exampleProvider(MyParameter(userId: userId, locale: locale)),\n  );\n\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Riverpod Provider (Dart)\nDESCRIPTION: Creates a basic `Provider` named `cityProvider` using Riverpod. It returns a constant string value 'London' and serves as a dependency for other providers.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nfinal cityProvider = Provider((ref) => 'London');\n```\n```\n\n----------------------------------------\n\nTITLE: Consuming a ChangeNotifierProvider in a Flutter Widget using Dart (Riverpod)\nDESCRIPTION: Demonstrates how to use a `ConsumerWidget` from `flutter_riverpod` to interact with the `todosProvider` (a `ChangeNotifierProvider`). It uses `ref.watch` to access the `TodoNotifier` and rebuild the widget when the list changes. It also uses `ref.read` within callbacks (like `onTap`, `onSubmitted`) to call methods on the `TodoNotifier` (e.g., `addTodo`, `toggle`, `remove`) without triggering unnecessary rebuilds for those specific actions.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/providers/change_notifier_provider.mdx#2025-04-23_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_hooks/flutter_hooks.dart';\nimport 'package:hooks_riverpod/hooks_riverpod.dart';\n\nimport 'todos.dart';\n\nclass TodoListView extends HookConsumerWidget {\n  const TodoListView({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // Rebuild the widget when the todo list changes.\n    final todoNotifier = ref.watch(todosProvider);\n    final todos = todoNotifier.todos;\n\n    // Use a TextEditingController to manage the input field's text.\n    final newTodoController = useTextEditingController();\n\n    return ListView(\n      padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 40),\n      children: [\n        const Text(\n          'Todos',\n          style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),\n        ),\n        const SizedBox(height: 20),\n        TextField(\n          controller: newTodoController,\n          decoration: const InputDecoration(\n            labelText: 'Add a new todo',\n          ),\n          // Use ref.read for actions that don't need to trigger rebuilds directly.\n          onSubmitted: (value) {\n            ref.read(todosProvider.notifier).addTodo(value);\n            newTodoController.clear();\n          },\n        ),\n        const SizedBox(height: 20),\n        if (todos.isEmpty)\n          const Text('No todos yet!', textAlign: TextAlign.center)\n        else\n          // Display the list of todos.\n          ...todos.map((todo) => TodoItem(\n                todo: todo,\n              )),\n      ],\n    );\n  }\n}\n\nclass TodoItem extends ConsumerWidget {\n  const TodoItem({required this.todo, super.key});\n\n  final Todo todo;\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    return Card(\n      elevation: 2,\n      margin: const EdgeInsets.symmetric(vertical: 4),\n      child: ListTile(\n        leading: Checkbox(\n          value: todo.completed,\n          // Use ref.read to call the toggle method on the notifier.\n          onChanged: (value) => ref.read(todosProvider.notifier).toggle(todo.id),\n        ),\n        title: Text(\n          todo.description,\n          style: TextStyle(\n            decoration: todo.completed ? TextDecoration.lineThrough : null,\n          ),\n        ),\n        trailing: IconButton(\n          icon: const Icon(Icons.delete, color: Colors.red),\n          // Use ref.read to call the removeTodo method on the notifier.\n          onPressed: () => ref.read(todosProvider.notifier).removeTodo(todo.id),\n        ),\n        // Use ref.read for the toggle action on tapping the tile itself.\n        onTap: () => ref.read(todosProvider.notifier).toggle(todo.id),\n      ),\n    );\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Handling Same Type Providers with Riverpod (Dart)\nDESCRIPTION: This snippet demonstrates how Riverpod handles multiple providers of the same type, overcoming a limitation of Provider where only the closest ancestor provider of the same type can be accessed. Riverpod allows for more flexible logic separation.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/from_provider/motivation/motivation.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nimport sameType from \"/docs/from_provider/motivation/same_type\";\n```\n\n----------------------------------------\n\nTITLE: Overriding Providers in Dart-only Tests\nDESCRIPTION: Shows how to override a provider implementation in a Dart-only context using ProviderContainer. This enables using fake repositories or mock implementations when testing provider logic.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/cookbooks/testing.mdx#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\ntest('override repositoryProvider', () async {\n  final container = ProviderContainer(\n    overrides: [\n      // Override the behavior of repositoryProvider to return\n      // a fake implementation of Repository instead of the real one\n      repositoryProvider.overrideWithValue(\n        FakeRepository(),\n      ),\n    ],\n  );\n  addTearDown(container.dispose);\n\n  // The first read if asyncValue is loading\n  expect(\n    container.read(todoListProvider),\n    const AsyncValue<List<Todo>>.loading(),\n  );\n\n  /// Wait for request to complete\n  await container.read(todoListProvider.future);\n\n  // Exposes the fake response\n  expect(\n    container.read(todoListProvider),\n    const AsyncValue<List<Todo>>.data([Todo(id: '42', label: 'Hello world')]),\n  );\n});\n```\n\n----------------------------------------\n\nTITLE: Incorrectly Watching a Family Provider in Dart\nDESCRIPTION: Demonstrates the incorrect usage of `ref.watch` with a provider defined using `.family`. Attempting to watch `messagesFamily` directly without supplying the required parameter will result in a compile-time or runtime error because `messagesFamily` itself is not a standard provider.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/modifiers/family.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, WidgetRef ref) {\n  // Error – messagesFamily is not a provider\n  final response = ref.watch(messagesFamily);\n}\n```\n\n----------------------------------------\n\nTITLE: Configura ProviderScope nel main.dart\nDESCRIPTION: Imposta il widget ProviderScope come radice dell'app Flutter per abilitare Riverpod a livello globale, permettendo ai provider di essere accessibili in tutta l'interfaccia utente.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/essentials/first_request.mdx#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\nvoid main() {\n  runApp(\n    ProviderScope(\n      child: MyApp(),\n    ),\n  );\n}\n\n```\n\n----------------------------------------\n\nTITLE: Optimized Provider Pattern: Watching Only Required Properties in Dart\nDESCRIPTION: This example demonstrates the recommended approach where an intermediate provider is created to expose only the host property from the Configuration object, preventing unnecessary updates when other configuration properties change.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#_snippet_11\n\nLANGUAGE: dart\nCODE:\n```\nfinal configsProvider = StreamProvider<Configuration>(...);\n\n/// Un provider qui n'expose que l'hôte actuel.\nfinal _hostProvider = FutureProvider<String>((ref) async {\n  final config = await ref.watch(configsProvider.future);\n  return config.host;\n});\n\nfinal productsProvider = FutureProvider<List<Product>>((ref) async {\n  // Écoute uniquement le host. Si quelque chose d'autre dans les configurations change, \n  // cela ne réévaluera pas inutilement notre provider.\n  final host = await ref.watch(_hostProvider.future);\n\n  return dio.get('$host/products');\n});\n```\n\n----------------------------------------\n\nTITLE: Watch Notifier Provider Example - Dart\nDESCRIPTION: This example demonstrates how to watch a Notifier Provider.  It implies watching a provider instance that emits a change notification, causing rebuilds or updates in related parts of your application.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_14\n\nLANGUAGE: dart\nCODE:\n```\n/* ... content of reading_watch_notifier_build.dart ... */\n```\n\n----------------------------------------\n\nTITLE: Example of provider with multiple parameters using Dart 3 records\nDESCRIPTION: This snippet illustrates defining a Riverpod provider that accepts multiple parameters using Dart 3's record feature, enabling the provider to handle complex input data such as activity type and maximum price, and simplifies equality checks.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/essentials/passing_args.mdx#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\n// Define a record for multiple parameters\ntypedef ActivityParams = ({String activityType, int maxPrice});\n\n// Use the record as the provider's argument type\nfinal tupleFamilyProvider = Provider.family<ResponseType, ActivityParams>((ref, params) {\n  // Access parameters with destructuring or dot notation\n  final activityType = params.activityType;\n  final maxPrice = params.maxPrice;\n  // TODO: Implement network request using parameters\n});\n```\n\n----------------------------------------\n\nTITLE: Migrating ConsumerWidget/Consumer build method\nDESCRIPTION: This code demonstrates how to migrate the `build` method of `ConsumerWidget` and the `builder` of `Consumer` in Riverpod. The `ScopedReader watch` parameter is replaced with `WidgetRef ref`, and `watch(provider)` is replaced with `ref.watch(provider)`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/migration/0.14.0_to_1.0.0.mdx#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nclass Example extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, ScopedReader watch) {\n    int count = watch(counterProvider);\n    ...\n  }\n}\n\nConsumer(\n  builder: (context, watch, child) {\n    int count = watch(counterProvider);\n    ...\n  }\n)\n```\n\nLANGUAGE: dart\nCODE:\n```\nclass Example extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    int count = ref.watch(counterProvider);\n    ...\n  }\n}\n\nConsumer(\n  builder: (context, ref, child) {\n    int count = ref.watch(counterProvider);\n    ...\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Consuming Notifier and StateNotifier in Dart\nDESCRIPTION: Example showing how both Notifier and StateNotifier can be consumed in the same way in Dart. This snippet demonstrates that the consumption syntax remains the same for both APIs.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/migration/from_state_notifier.mdx#2025-04-23_snippet_9\n\nLANGUAGE: dart\nCODE:\n```\nclass CounterConsumer extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final count = ref.watch(counterProvider);\n    return ElevatedButton(\n      onPressed: () => ref.read(counterProvider.notifier).increment(),\n      child: Text('$count'),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Consumer Widget to Render Network Request Results in Flutter\nDESCRIPTION: This snippet demonstrates how to use a Consumer widget to read an activityProvider and display the activity in the UI. It handles loading and error states gracefully.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/first_request.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nConsumer(\n  builder: (context, ref, child) {\n    final activity = ref.watch(activityProvider);\n    return switch (activity) {\n      AsyncData(:final value) => Text(value.activity),\n      AsyncError() => const Text('Oops, something unexpected happened'),\n      _ => const CircularProgressIndicator(),\n    };\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Declaring AsyncNotifier for Todo List in Dart\nDESCRIPTION: Demonstrates the declaration of an AsyncNotifier class for managing a list of Todos. This snippet shows the basic structure and required methods for the notifier.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/migration/from_change_notifier.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\nclass TodosNotifier extends AsyncNotifier<List<Todo>> {\n  @override\n  Future<List<Todo>> build() async {\n    // TODO: implement initialization\n  }\n\n  Future<void> addTodo(Todo todo) async {\n    // TODO: implement mutation\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Consumer Widget to Read Riverpod Provider (Flutter)\nDESCRIPTION: This snippet demonstrates how to use a `Consumer` widget to read the state of an `activityProvider` and display the activity in a Flutter UI. It handles loading and error states gracefully. The `Consumer` provides a `ref` object to access providers.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/essentials/first_request.mdx#_snippet_3\n\nLANGUAGE: Flutter\nCODE:\n```\n<AutoSnippet title=\"consumer.dart\" {...consumer} />\n```\n\n----------------------------------------\n\nTITLE: Migrating a Notifier to Riverpod NotifierProvider\nDESCRIPTION: This code snippet illustrates the migration of a `MyNotifier` to Riverpod's `Notifier` and `NotifierProvider`.  It replaces the `ChangeNotifier` with a `Notifier` for state management and adapts the provider accordingly. Prerequisites include the successful implementation of the earlier snippets that introduce Riverpod and its core concepts.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/from_provider/quickstart.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nclass MyNotifier extends Notifier<int> {\n  @override\n  int build() => 0;\n\n  void increment() => state++;\n}\n\nfinal myNotifierProvider = NotifierProvider<MyNotifier, int>(MyNotifier.new);\n```\n\n----------------------------------------\n\nTITLE: Using StreamProvider.family with .autoDispose in Dart\nDESCRIPTION: This example shows combining the .autoDispose modifier with the family modifier on a StreamProvider. The family modifier allows parameterizing the provider with an external value (String id). When the provider is no longer read, its state will be automatically disposed of. Use this pattern when you need multiple distinct instances of a provider keyed by parameters while still benefiting from automatic disposal.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/bn/docusaurus-plugin-content-docs/current/concepts/modifiers/auto_dispose.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nfinal userProvider = StreamProvider.autoDispose.family<User, String>((ref, id) {\n\n});\n```\n\n----------------------------------------\n\nTITLE: Combining .autoDispose and .family Modifiers in Dart\nDESCRIPTION: This example illustrates how to chain the `.autoDispose` modifier with the `.family` modifier in Riverpod. This allows creating auto-disposing providers that accept parameters, combining the features of both modifiers.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/modifiers/auto_dispose.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nfinal userProvider = StreamProvider.autoDispose.family<User, String>((ref, id) {\n\n});\n```\n\n----------------------------------------\n\nTITLE: Overriding Providers in Tests with ProviderContainer (Dart Only) - Riverpod - Dart\nDESCRIPTION: Describes usage of ProviderContainer to override providers outside of Flutter widget tree (Dart-only context). Helpful for pure unit testing where you want independent provider graphs and to inject fakes/mocks. Dependencies: riverpod. Inputs are global provider and the overridden value. Outputs: containers manually instantiated and test logic on result.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/cookbooks/testing.mdx#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nfinal container = ProviderContainer(\n  overrides: [\n    repositoryProvider.overrideWithValue(FakeRepository()),\n  ],\n);\nfinal todos = container.read(todoListProvider.future);\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Filtered Todo List Provider in Dart\nDESCRIPTION: Defines a Riverpod `Provider` named `filteredTodoListProvider` that combines `filterProvider` and `todoListProvider` (assumed to be defined elsewhere). It uses `ref.watch` on both dependencies to get the current filter and the full todo list, then returns a filtered list based on the selected filter. The provider automatically updates if either the filter or the todo list changes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nfinal filteredTodoListProvider = Provider((ref) {\n  // obtain the filter and the list of todos\n  final filter = ref.watch(filterProvider);\n  final todos = ref.watch(todoListProvider);\n\n  switch (filter) {\n    case Filter.none:\n      // The user selected 'All', no need to filter.\n      return todos;\n    case Filter.completed:\n      // Return the list of completed todos\n      return todos.where((todo) => todo.isCompleted).toList();\n    case Filter.uncompleted:\n      // Return the list of uncompleted todos\n      return todos.where((todo) => !todo.isCompleted).toList();\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Overriding Provider Dependency in Dart Tests\nDESCRIPTION: This Dart unit test shows how to override `repositoryProvider` using `ProviderContainer`. Similar to the Flutter example, it passes a list of `Override` objects (containing the `FakeRepository`) to the `overrides` parameter when creating the `ProviderContainer`. This isolates the test and forces dependent providers like `todoListProvider` to use the mocked dependency.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/cookbooks/testing.mdx#2025-04-23_snippet_4\n\nLANGUAGE: Dart\nCODE:\n```\nclass FakeRepository implements Repository {\n  @override\n  Future<List<Object?>> fetchTodos() async {\n    return [{'id': 42, 'label': 'Hello world'}];\n  }\n}\n\nvoid main() {\n  test('Override repositoryProvider', () async {\n    // Create a ProviderContainer with the override.\n    final container = ProviderContainer(\n      overrides: [\n        // Override repositoryProvider to return FakeRepository\n        repositoryProvider.overrideWithValue(FakeRepository())\n      ],\n    );\n    addTearDown(container.dispose);\n\n    // The first read if the loading state\n    expect(\n      container.read(todoListProvider),\n      const AsyncValue<List<Object?>>.loading(),\n    );\n\n    // Wait for the request to finish\n    await container.read(todoListProvider.future);\n\n    // Exposes the data fetched\n    expect(container.read(todoListProvider).value, [\n      {'id': 42, 'label': 'Hello world'}\n    ]);\n  });\n}\n\n```\n\n----------------------------------------\n\nTITLE: Code Generated Riverpod Provider Definition\nDESCRIPTION: Example showing the code generation approach to defining a provider using annotations.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/about_code_generation.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\nFuture<User> fetchUser(FetchUserRef ref) async {\n  final user = await fetchUser();\n  return user;\n}\n```\n\n----------------------------------------\n\nTITLE: Final Riverpod Code Generation Implementation\nDESCRIPTION: Shows the final form of a fully migrated provider using Riverpod's code generation.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/from_provider/quickstart.mdx#2025-04-23_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\nclass MyNotifier extends _$MyNotifier {\n  @override\n  int build() => 0;\n\n  void increment() => state++;\n}\n```\n\n----------------------------------------\n\nTITLE: Filtering Widget Rebuilds with 'select' in Riverpod\nDESCRIPTION: This snippet demonstrates how to use the 'select' function in Riverpod to filter widget rebuilds. By selecting only the 'firstName' property of a User object, the widget will only rebuild when the 'firstName' changes, rather than any property of the User object. The snippet shows how to watch specific property.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/advanced/select.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n    // 아래처럼 작성하는 대신:\n    // String name = ref.watch(provider).firstName!;\n    // 이렇게 작성할 수 있습니다:\n    // 그러면 위젯이 'firstName'에 대한 변경 사항만 수신하게 됩니다.\n```\n\n----------------------------------------\n\nTITLE: Using NotifierProvider for a Todo List in Dart\nDESCRIPTION: This example demonstrates how to implement a todo-list using NotifierProvider. It shows how to define a Todo class, a TodosNotifier class that extends Notifier to manage the state, and how to expose methods like addTodo to modify the list of todos on user interactions.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/providers/notifier_provider.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n// This code is referenced via an import and not directly shown in the text\n```\n\n----------------------------------------\n\nTITLE: Creating a Provider for Completed Todos in Dart\nDESCRIPTION: This snippet creates a Provider that filters the list of todos to show only completed ones. It uses ref.watch to listen for changes in the todo list.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/providers/provider.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nfinal completedTodosProvider = Provider<List<Todo>>((ref) {\n  final todos = ref.watch(todoListProvider);\n  return todos.where((todo) => todo.completed).toList();\n});\n```\n\n----------------------------------------\n\nTITLE: Migrating Asynchronous StateNotifier to AsyncNotifier (Dart)\nDESCRIPTION: Illustrates the refactoring of an asynchronous StateNotifier to an AsyncNotifier, simplifying async logic and enabling better support for futures and side-effects. Requires Riverpod 2.0+ for AsyncNotifier and associated AsyncNotifierProvider. Inputs include async parameters or context; outputs and async state are managed transparently. De-emphasizes manual use of AsyncValue/guard and centralizes asynchronous mutation logic.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/migration/from_state_notifier.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n<!-- asyncNotifierOld.dart content placeholder -->\n```\n\n----------------------------------------\n\nTITLE: Complete Widget Test Example - Dart\nDESCRIPTION: This snippet provides a complete example of a widget test using Riverpod. It builds upon previous examples, demonstrating how to use `ProviderScope` and interact with providers.  The snippet also illustrates how to perform operations on a widget.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/essentials/testing.mdx#_snippet_4\n\nLANGUAGE: Dart\nCODE:\n```\n    testWidgets('My widget test', (tester) async {\n      await tester.pumpWidget(\n        ProviderScope(child: MyWidget()),\n      );\n\n      // TODO: providers와 상호 작용\n    });\n```\n\n----------------------------------------\n\nTITLE: Defining and Using a FutureProvider with Riverpod Generator in Dart\nDESCRIPTION: This snippet demonstrates how to define a FutureProvider using the @riverpod annotation and how to consume it in a widget. It includes handling of async states and passing parameters to the provider.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_generator/README.md#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nimport 'package:riverpod_annotation/riverpod_annotation.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:dio/dio.dart';\n\npart 'my_file.g.dart';\n\n@riverpod\nFuture<List<Product>> fetchProducts(Ref ref, {required int page, int limit = 50}) async {\n  final dio = Dio();\n  final response = await dio.get('https://my-api/products?page=$page&limit=$limit');\n  final json = response.data! as List;\n  return json.map((item) => Product.fromJson(item)).toList();\n}\n\n\nConsumer(\n  builder: (context, ref, child) {\n    AsyncValue<List<Product>> products = ref.watch(fetchProductProvider(page: 1));\n\n    return products.when(\n      loading: () => CircularProgressIndicator(),\n      error: (err, stack) => Text('error: $err'),\n      data: (products) {\n        return ListView(\n          children: [\n            for (final product in products)\n              Text(product.name),\n          ],\n        );\n      },\n    );\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Notifier Pattern Example with Legend\nDESCRIPTION: Demonstrates the syntax structure for defining a Notifier in Riverpod, including provider type, modifiers, and class implementation.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/side_effects.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nfinal name = SomeNotifierProvider.someModifier<MyNotifier, Result>(MyNotifier.new);\n\nclass MyNotifier extends SomeNotifier<Result> {\n  @override\n  Result build() {\n    <your logic here>\n  }\n\n  <your methods here>\n}\n```\n\n----------------------------------------\n\nTITLE: Consuming .family Provider - Dart\nDESCRIPTION: This snippet shows how to consume a `.family` provider within a `Widget`.  It demonstrates passing a parameter to the provider and watching its value using `ref.watch`.  Note that `messagesFamily('id')` creates a new Provider instance with the provided parameter.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/bn/docusaurus-plugin-content-docs/current/concepts/modifiers/family.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, WidgetRef ref) {\n  final response = ref.watch(messagesFamily('id'));\n}\n```\n\n----------------------------------------\n\nTITLE: Consuming ChangeNotifierProvider in UI (Dart)\nDESCRIPTION: This snippet exemplifies how to consume a previously defined `ChangeNotifierProvider` within a Flutter UI. It explains the process of accessing and reacting to the state changes of the `ChangeNotifier` managed by the provider.  Dependencies: flutter_riverpod or hooks_riverpod and Flutter framework libraries. Input: The previously defined `ChangeNotifierProvider`. Output: UI components that react to the changes in the Todo list's state. Uses the provider to read and interact with the data.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/providers/change_notifier_provider.mdx#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\n// Code from /i18n/ja/docusaurus-plugin-content-docs/current/providers/change_notifier_provider/todos_consumer.dart\n// Placeholder for the code snippet demonstrating consuming the ChangeNotifierProvider in the UI.\n// The actual code would create a UI that reads the Todos from the provider,\n// displays them, and allows for interaction (e.g., adding or removing todos).\n// The specifics of the UI implementation are not given in the document.\n\n```\n\n----------------------------------------\n\nTITLE: Sort Type Dropdown Implementation\nDESCRIPTION: Creates a dropdown menu for selecting product sort type using Flutter's DropdownButton.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/providers/state_provider.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nenum SortType {\n  name,\n  price,\n}\n\nDropdownButton<SortType>(\n  value: SortType.name,\n  onChanged: (value) {},\n  items: const [\n    DropdownMenuItem(\n      value: SortType.name,\n      child: Text('Sort by name'),\n    ),\n    DropdownMenuItem(\n      value: SortType.price,\n      child: Text('Sort by price'),\n    ),\n  ],\n)\n```\n\n----------------------------------------\n\nTITLE: Consuming a Family Provider in a Flutter Widget using Dart\nDESCRIPTION: Demonstrates the usage pattern for consuming a provider defined with .family. Instead of directly watching the provider, a parameter must be passed to the provider function, in this case a String ID. This enables dynamic subscription to different states depending on the parameter. It uses Flutter's WidgetRef to listen to providers inside widget builds.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/concepts/modifiers/family.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, WidgetRef ref) {\n  final response = ref.watch(messagesFamily('id'));\n}\n```\n\n----------------------------------------\n\nTITLE: StreamNotifierProvider Migration\nDESCRIPTION: Shows migration from StreamNotifierProvider to code-generated stream class provider. Uses @riverpod annotation with a class returning a Stream.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/about_code_generation.mdx#2025-04-23_snippet_10\n\nLANGUAGE: dart\nCODE:\n```\nfinal counterProvider = StreamNotifierProvider<Counter, int>(() => Counter());\n\nclass Counter extends StreamNotifier<int> {\n  @override\n  Stream<int> build() => Stream.value(0);\n}\n```\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\nclass Counter extends _$Counter {\n  @override\n  Stream<int> build() => Stream.value(0);\n}\n```\n\n----------------------------------------\n\nTITLE: Passing parameters to providers via main function convention\nDESCRIPTION: Describes how to pass parameters to providers using the main function method, allowing multiple arguments, including named, optional, and default values, without relying on family modifiers. Emphasizes the importance of consistent equality comparisons for cached providers.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/about_code_generation.mdx#_snippet_5\n\nLANGUAGE: Dart\nCODE:\n```\n{trimSnippet(familyFn)}\n```\n\nLANGUAGE: Dart\nCODE:\n```\n{trimSnippet(familyClass)}\n```\n\n----------------------------------------\n\nTITLE: Passing Parameters to Riverpod Providers without the `family` Modifier in Dart\nDESCRIPTION: Shows how to pass parameters directly to code-generated Riverpod providers by defining them as function parameters instead of relying on the `family` modifier. Both functional and class-based provider examples are provided, emphasizing that parameters should implement coherent equality (`==`) for proper caching. Dependencies include the Riverpod code generation package and Dart's equality semantics for custom types.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/about_code_generation.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n/// Functional approach to parameterized provider\n@riverpod\nString greetingProvider(GreetingProviderRef ref, String name) {\n  return 'Hello, $name!';\n}\n```\n\nLANGUAGE: dart\nCODE:\n```\n/// Class-based parameterized provider\n@riverpod\nclass GreetingProvider extends _$GreetingProvider {\n  String build(String name) {\n    return 'Hello, $name!';\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Updating StateProvider Using the update Method in Riverpod (Dart)\nDESCRIPTION: This snippet exemplifies using the StateProvider's .update method to mutate state based on the previous value with a concise, callback-based syntax. It avoids multiple reads and ensures the latest state is provided to the callback. Requires: Riverpod. Inputs: updater function; output: new provider state. This method is preferred for atomic, concise, and clear state changes when the next value depends on the previous state.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/providers/state_provider.mdx#_snippet_7\n\nLANGUAGE: dart\nCODE:\n```\n/* Example Dart code using update method on StateProvider. See update_read_once.dart for actual code. */\n```\n\n----------------------------------------\n\nTITLE: Implementing FadeIn with StatefulWidget - Dart\nDESCRIPTION: This snippet demonstrates the implementation of a fade-in animation using `StatefulWidget`. It shows the setup of an `AnimationController`, its initialization in `initState`, and its disposal in `dispose`.  The `AnimatedBuilder` widget is used to rebuild the UI based on the animation's value.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/about_hooks.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nclass FadeIn extends StatefulWidget {\n  const FadeIn({Key? key, required this.child}) : super(key: key);\n\n  final Widget child;\n\n  @override\n  State<FadeIn> createState() => _FadeInState();\n}\n\nclass _FadeInState extends State<FadeIn> with SingleTickerProviderStateMixin {\n  late final AnimationController animationController = AnimationController(\n    vsync: this,\n    duration: const Duration(seconds: 2),\n  );\n\n  @override\n  void initState() {\n    super.initState();\n    animationController.forward();\n  }\n\n  @override\n  void dispose() {\n    animationController.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return AnimatedBuilder(\n      animation: animationController,\n      builder: (context, child) {\n        return Opacity(\n          opacity: animationController.value,\n          child: widget.child,\n        );\n      },\n    );\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Awaiting Asynchronous Provider Values\nDESCRIPTION: This code snippet demonstrates how to await the result of a provider that returns a `Future` or `Stream`.  The `.future` property is used to access the future associated with the provider. The output is the resolved value of the asynchronous operation.  This is important when testing providers that perform async operations.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/essentials/testing.mdx#_snippet_7\n\nLANGUAGE: Dart\nCODE:\n```\nimport \"package:flutter_riverpod/flutter_riverpod.dart\";\nimport \"package:flutter_test/flutter_test.dart\";\n\nfinal myProvider = FutureProvider((ref) async => 42);\n\nvoid main() {\n  test(\"myProvider\", () async {\n    final container = ProviderContainer();\n\n    final result = await container.read(myProvider.future);\n\n    expect(result, 42);\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a StateNotifierProvider with filtering logic\nDESCRIPTION: Creates a StateNotifier to manage a list of todos and a StateProvider for the current filter. Combines these to produce a filtered list, enabling the UI to react to changes dynamically.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/es/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#_snippet_2\n\nLANGUAGE: Dart\nCODE:\n```\nclass TodoList extends StateNotifier<List<Todo>> {\n  TodoList(): super(const []);\n}\n\nfinal todoListProvider = StateNotifierProvider((ref) => TodoList());\n```\n\nLANGUAGE: Dart\nCODE:\n```\nenum Filter {\n  none,\n  completed,\n  uncompleted,\n}\n\nfinal filterProvider = StateProvider((ref) => Filter.none);\n```\n\nLANGUAGE: Dart\nCODE:\n```\nfinal filteredTodoListProvider = Provider<List<Todo>>((ref) {\n  final filter = ref.watch(filterProvider);\n  final todos = ref.watch(todoListProvider);\n  switch (filter) {\n    case Filter.none:\n      return todos;\n    case Filter.completed:\n      return todos.where((todo) => todo.completed).toList();\n    case Filter.uncompleted:\n      return todos.where((todo) => !todo.completed).toList();\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Installing Riverpod for Dart\nDESCRIPTION: This snippet defines the `pubspec.yaml` file configurations for integrating Riverpod into a Dart project. It specifies the necessary dependencies, including `riverpod`, and Dart SDK. The code targets a Dart project with version constraints.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/getting_started.mdx#_snippet_2\n\nLANGUAGE: YAML\nCODE:\n```\nenvironment:\n  sdk: \">=2.12.0-0 <4.0.0\"\n\ndependencies:\n  riverpod: ^1.0.0-dev.10\n```\n\n----------------------------------------\n\nTITLE: Defining a Notifier Structure in Riverpod (Codegen)\nDESCRIPTION: Shows the structure of a Notifier in Riverpod using code generation with the @riverpod annotation. This approach simplifies the notifier definition by automatically generating the correct provider types.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/essentials/side_effects.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\nclass MyNotifier extends _$MyNotifier {\n  @override\n  Result build() {\n    <your logic here>\n  }\n\n  <your methods here>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Todo List with StateNotifierProvider in Dart\nDESCRIPTION: This snippet demonstrates how to use StateNotifierProvider to implement a todo list. It defines a Todo class, a TodosNotifier class extending StateNotifier, and a StateNotifierProvider for managing the todos state.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/providers/state_notifier_provider.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nimport 'package:riverpod/riverpod.dart';\n\n// A todo item\nclass Todo {\n  Todo({required this.description, required this.completed});\n\n  final String description;\n  final bool completed;\n\n  Todo copyWith({String? description, bool? completed}) {\n    return Todo(\n      description: description ?? this.description,\n      completed: completed ?? this.completed,\n    );\n  }\n}\n\n// The state notifier which will manage the todos\nclass TodosNotifier extends StateNotifier<List<Todo>> {\n  // Initialize with empty list of todos\n  TodosNotifier(): super([]);\n\n  // Method to add a todo\n  void addTodo(Todo todo) {\n    state = [...state, todo];\n  }\n\n  // Other methods like removeTodo, markAsCompleted, etc.\n}\n\n// The provider which will be used to access the state\nfinal todosProvider = StateNotifierProvider<TodosNotifier, List<Todo>>((ref) {\n  return TodosNotifier();\n});\n```\n\n----------------------------------------\n\nTITLE: Widget ref.read Example - Dart\nDESCRIPTION: Shows how a widget utilizes `ref.read`. It is used to read the value of a provider without subscribing to changes.  This is particularly useful within event handlers where a one-time retrieval of the provider's value is sufficient.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_12\n\nLANGUAGE: dart\nCODE:\n```\n/* ... content of reading_read_build.dart ... */\n```\n\n----------------------------------------\n\nTITLE: Defining a Parameterized FutureProvider with .family in Riverpod (Dart)\nDESCRIPTION: This snippet demonstrates how to use the FutureProvider.family constructor to fetch a Message object based on a String id parameter. It requires Riverpod and a dio instance for HTTP requests. The provider allows clients to query messages by id, making dynamic data fetching straightforward; the parameter must have a meaningful hashCode and == implementation, and the provider returns a Future<Message> corresponding to the id.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/modifiers/family.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nfinal messagesFamily = FutureProvider.family<Message, String>((ref, id) async {\n  return dio.get('http://my_api.dev/messages/$id');\n});\n```\n\n----------------------------------------\n\nTITLE: Using MultiProvider to integrate Riverpod (Dart)\nDESCRIPTION: Shows how to use MultiProvider from the provider package to make a Riverpod ChangeNotifier accessible to existing widgets. This approach allows incremental migration where only the root widget needs to be converted to a ConsumerWidget initially. The ref.watch method reads the MyNotifier instance from the Riverpod provider.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/from_provider/quickstart.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nMultiProvider(\n  providers: [\n    ChangeNotifierProvider.value(value: ref.watch(myNotifierProvider.notifier)),\n  ]\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Providers with Riverpod Package in Dart\nDESCRIPTION: This snippet shows how to define providers using the Riverpod package. It demonstrates the creation of a global final variable for the provider and the use of ProviderScope widget.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/from_provider/provider_vs_riverpod.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n// Providers are now top-level variables\nfinal counterProvider = ChangeNotifierProvider<Counter>((ref) => Counter());\n\nvoid main() {\n  runApp(\n    // This widget enables Riverpod for the entire project\n    ProviderScope(\n      child: MyApp(),\n    ),\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Providers in Tests with ProviderScope (Flutter) - Riverpod - Dart\nDESCRIPTION: Shows how to override a provider during Flutter widget tests using ProviderScope\\'s overrides argument. Used for injecting test doubles, such as a fake Repository, into dependent providers. Meant for widget-level testing where isolation between real and mocked dependencies is required. Dependencies: flutter_test, flutter_riverpod, flutter. Inputs: ProviderScope, test fake implementations. Output: widgets consuming overridden provider values during tests.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/cookbooks/testing.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\ntestWidgets('uses fake repository', (tester) async {\n  await tester.pumpWidget(\n    ProviderScope(\n      overrides: [\n        repositoryProvider.overrideWithValue(FakeRepository()),\n      ],\n      child: MyApp(),\n    ),\n  );\n});\n\n```\n\n----------------------------------------\n\nTITLE: Migrating from StateProvider to Notifier in Riverpod (Dart)\nDESCRIPTION: These snippets present the migration from the deprecated StateProvider to the new Notifier-based API in Riverpod. The first snippet declares and uses a StateProvider with inline state management. The migrated version defines a Notifier class and a provider for it, following modern Riverpod practices. This change may require more code but unlocks more extensibility. To use, Riverpod must be installed. Input is typically none; output is a provider holding state, accessed via ref.watch or ref.read.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/migration/from_state_notifier.mdx#2025-04-23_snippet_12\n\nLANGUAGE: dart\nCODE:\n```\n// OLD: StateProvider usage\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\n// ...later, in a Widget\nfinal count = ref.watch(counterProvider);\n```\n\nLANGUAGE: dart\nCODE:\n```\n// NEW: Notifier-based provider\nclass Counter extends Notifier<int> {\n  @override\n  int build() => 0;\n\n  void increment() => state++;\n}\n\nfinal counterProvider = NotifierProvider<Counter, int>(Counter.new);\n\n// ...later, in a Widget\nfinal count = ref.watch(counterProvider);\n\n```\n\n----------------------------------------\n\nTITLE: Accessing Notifier Methods from Widgets with Riverpod in Dart\nDESCRIPTION: Pattern for accessing logic encapsulated in a Notifier from widgets. This approach keeps business logic in the Notifier layer rather than mixing it with UI code, following Riverpod's recommended architecture.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/faq.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nref.read(yourNotifierProvider.notifier).yourMethod();\n```\n\n----------------------------------------\n\nTITLE: Defining a Provider with ref Parameter - Riverpod Dart\nDESCRIPTION: This snippet demonstrates the definition of a provider in Riverpod. The provider function receives a 'ref' parameter, which grants access to other providers or allows advanced provider interactions. This is foundational for provider setup in Riverpod and has no dependencies beyond the Riverpod package itself. Expected input is the reference context 'ref', and the output is the value managed by the provider.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/reading.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nfinal myProvider = Provider<int>((ref) {\n  // Logic using ref\n  return 0;\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Network Requests with Riverpod in Dart\nDESCRIPTION: This snippet demonstrates how to define a network request using Riverpod's @riverpod annotation. It fetches a random activity suggestion from the Bored API and returns it as a string, showcasing Riverpod's approach to handling asynchronous data fetching.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/flutter_riverpod/README.md#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\nFuture<String> boredSuggestion(Ref ref) async {\n  final response = await http.get(\n    Uri.https('boredapi.com', '/api/activity'),\n  );\n  final json = jsonDecode(response.body);\n  return json['activity']! as String;\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Providers Creating Ref-Dependent Objects using ProviderContainer in Dart\nDESCRIPTION: Illustrates how to unit test a provider (`repositoryProvider`) whose created object (`Repository`) depends on `Ref`. It uses `ProviderContainer` to instantiate and read the provider within a test environment, allowing interaction with the `Repository` instance and assertion of its behavior, such as verifying the result of `fetchCatalog`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#2025-04-23_snippet_7\n\nLANGUAGE: dart\nCODE:\n```\nfinal repositoryProvider = Provider((ref) => Repository(ref));\n\ntest('fetches catalog', () async {\n  final container = ProviderContainer();\n  addTearDown(container.dispose);\n\n  Repository repository = container.read(repositoryProvider);\n\n  await expectLater(\n    repository.fetchCatalog(),\n    completion(Catalog()),\n  );\n});\n```\n\n----------------------------------------\n\nTITLE: Shared ChangeNotifier Integration Logic in Riverpod with Dart\nDESCRIPTION: Shows how to extract and reuse the logic for connecting ChangeNotifier to Riverpod by leveraging the composable ref object for cleaner code organization.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/essentials/websockets_sync.mdx#_snippet_3\n\nLANGUAGE: Dart\nCODE:\n```\n// Composable logic for listening to a ChangeNotifier\nvoid useChangeNotifier(Ref ref, ChangeNotifier notifier, VoidCallback onChange) {\n  // Start listening to the notifier\n  notifier.addListener(onChange);\n  // When the provider is destroyed or needs to refresh, dispose the notifier\n  ref.onDispose(() {\n    notifier.removeListener(onChange);\n    notifier.dispose();\n  });\n}\n\n@riverpod\nString counter(CounterRef ref) {\n  // Create a ChangeNotifier\n  final notifier = MyChangeNotifier();\n  // Use our composable logic\n  useChangeNotifier(\n    ref,\n    notifier,\n    () => ref.state = notifier.value,\n  );\n  // Return the current value\n  return notifier.value;\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized Previous Button Logic with Provider - Dart\nDESCRIPTION: This code snippet demonstrates an optimized way to determine if a 'previous' button should be enabled by extracting the logic into a Provider. The `canGoToPreviousPageProvider` only updates the `PreviousButton` widget when the value actually changes, reducing unnecessary rebuilds. It depends on `currentPageIndexProvider`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/es/docusaurus-plugin-content-docs/current/providers/provider.mdx#_snippet_3\n\nLANGUAGE: Dart\nCODE:\n```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal currentPageIndexProvider = StateProvider((_) => 0);\n\nfinal canGoToPreviousPageProvider = Provider<bool>((ref) {\n  final currentPageIndex = ref.watch(currentPageIndexProvider);\n  return currentPageIndex > 0;\n});\n\nclass OptimizedPreviousButton extends ConsumerWidget {\n  const OptimizedPreviousButton({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final canGoToPreviousPage = ref.watch(canGoToPreviousPageProvider);\n\n    return ElevatedButton(\n      onPressed: canGoToPreviousPage ? () {} : null,\n      child: const Text('Previous'),\n    );\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Correct Family Provider Usage Example\nDESCRIPTION: Example showing the correct way to use a family provider by passing a parameter.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/modifiers/family.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, WidgetRef ref) {\n  final response = ref.watch(messagesFamily('id'));\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Network Request with Riverpod Provider\nDESCRIPTION: Shows how to create a Riverpod provider for making HTTP requests to an external API. Uses the @riverpod annotation to define an asynchronous function that fetches activity suggestions from the Bored API.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/hooks_riverpod/README.md#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\nFuture<String> boredSuggestion(Ref ref) async {\n  final response = await http.get(\n    Uri.https('boredapi.com', '/api/activity'),\n  );\n  final json = jsonDecode(response.body);\n  return json['activity']! as String;\n}\n```\n\n----------------------------------------\n\nTITLE: Hello World Example with Riverpod in Dart\nDESCRIPTION: This snippet demonstrates a basic 'Hello World' example using Riverpod in a Dart-only application. It shows how to create a provider and use it in a console application.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/introduction/getting_started.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nimport 'package:riverpod/riverpod.dart';\n\n// We create a \"provider\", which will store a value (here \"Hello world\").\n// By using a provider, this allows us to mock/override the value exposed.\nfinal helloWorldProvider = Provider((_) => 'Hello world');\n\nvoid main() {\n  // Creating a container allows us to override providers for unit-testing\n  final container = ProviderContainer();\n\n  // Reading the value of our provider is safe.\n  // If \"helloWorldProvider\" threw, the error would be caught and handled.\n  final value = container.read(helloWorldProvider);\n\n  print(value); // \"Hello world\"\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Providers in Flutter Tests with ProviderScope (Dart)\nDESCRIPTION: This snippet shows how to override a provider with a mock implementation in a Flutter widget test using ProviderScope's overrides parameter. A fake repository is created, injected into the ProviderScope, and used in place of the production dependency, allowing for controlled test outcomes. Dependencies: flutter_riverpod, flutter_test. Key parameters: overrides. Input: testWidget; Output: asserts on mocked responses.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/cookbooks/testing.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\ntestWidgets('overrides repositoryProvider', (tester) async {\n  final fakeRepository = FakeRepository();\n  await tester.pumpWidget(\n    ProviderScope(\n      overrides: [\n        repositoryProvider.overrideWithValue(fakeRepository),\n      ],\n      child: MyApp(),\n    ),\n  );\n  // ... rest of test code\n});\n\n```\n\n----------------------------------------\n\nTITLE: Reading a Provider using WidgetRef with Riverpod\nDESCRIPTION: Demonstrates the Riverpod equivalent of reading a provider. It uses a `ConsumerWidget` which provides a `WidgetRef` object in its build method. `ref.watch(modelProvider)` is used to read the provider and establish a dependency.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/from_provider/provider_vs_riverpod.mdx#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nfinal modelProvider = Provider<Model>(...);\n\nclass Example extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    Model model = ref.watch(modelProvider);\n\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Consuming Riverpod State in Flutter UI\nDESCRIPTION: Demonstrates how to use a Riverpod provider in a Flutter widget, including handling loading, error, and success states using pattern matching with switch expressions.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/hooks_riverpod/README.md#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nclass Home extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final boredSuggestion = ref.watch(boredSuggestionProvider);\n    // Perform a switch-case on the result to handle loading/error states\n    return switch (boredSuggestion) {\n      AsyncData(:final value) => Text('data: $value'),\n      AsyncError(:final error) => Text('error: $error'),\n      _ => const Text('loading'),\n    };\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding providers with AsyncValue in tests (Riverpod Dart)\nDESCRIPTION: Shows how to override asynchronous providers such as FutureProvider with a predefined AsyncValue in tests using overrideWithValue. This allows forced states like loading, error, or data without executing the original asynchronous logic. Requires Riverpod package and test framework. Inputs are original FutureProvider and desired AsyncValue; output is predictable test states.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/cookbooks/testing.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nfinal exampleFutureProvider = FutureProvider<int>((ref) async {\n  return 42;\n});\n\nvoid main() {\n  test('override FutureProvider with AsyncValue', () async {\n    final container = ProviderContainer(overrides: [\n      exampleFutureProvider.overrideWithValue(AsyncValue.data(99)),\n    ]);\n    \n    expect(container.read(exampleFutureProvider).value, 99);\n    container.dispose();\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Fully Migrated AsyncNotifier Implementation\nDESCRIPTION: Complete implementation of the Todos AsyncNotifier after migration from ChangeNotifier, showing the build method and addTodo mutation with simplified state management.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/migration/from_change_notifier.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\nclass Todos extends _$Todos {\n  @override\n  Future<List<Todo>> build() {\n    return fetchTodos();\n  }\n\n  Future<void> addTodo(Todo todo) async {\n    // Update optimistically\n    state = AsyncData([...state.value ?? [], todo]);\n    \n    try {\n      // Make the request\n      await saveTodo(todo);\n    } catch (e, stack) {\n      // If the request fails, revert and expose the error\n      state = AsyncError(\n        e, \n        stack, \n        // Restore the previous value\n        [...state.value ?? []..removeLast()],\n      );\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Full Widget Test Example with Riverpod Providers in Dart\nDESCRIPTION: This code snippet illustrates a complete widget test setup with Riverpod providers, including the creation of a `ProviderScope` as root, interactions with providers, and assertions on widget behavior realistically integrated with Riverpod state management. It demonstrates how unit and widget testing paradigms combine in a Flutter environment with Riverpod.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/essentials/testing.mdx#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\n    // TODO: providersと対話する\n```\n\n----------------------------------------\n\nTITLE: Utilizzo di ref.watch per creare provider reattivi in Dart\nDESCRIPTION: Esempio di come usare ref.watch per osservare e reagire alle modifiche di un provider (esempio: posizione utente). La funzione restituisce uno stato aggiornato automaticamente quando il provider osservato cambia, mantenendo lo stato precedente durante le richieste in corso.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/essentials/combining_requests.mdx#_snippet_2\n\nLANGUAGE: Dart\nCODE:\n```\n<AutoSnippet {...watchExample} />\n```\n\n----------------------------------------\n\nTITLE: Initializing ProviderScope and ProviderContainer in Riverpod (Dart)\nDESCRIPTION: This snippet demonstrates the recommended and discouraged ways to initialize and use ProviderScope and ProviderContainer in a Flutter/Riverpod application. The correct method involves using ProviderScope as the root of your widget tree, enabling proper provider state management. The discouraged pattern initializes a raw ProviderContainer without ProviderScope, risking isolated states and difficult debugging. Required dependencies include the riverpod and flutter_riverpod packages. Key parameters include the provider initializers and widget tree root.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/scopes.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nfinal valueProvider = StateProvider((ref) => 0);\n\n// DO this\nvoid main() {\n  runApp(ProviderScope(child: MyApp()));\n}\n\n//DON'T do this:\nfinal myProviderContainer = ProviderContainer();\nvoid main(){\n  runApp(MyApp());\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Riverpod Provider State in a Subtree using Scopes (Dart)\nDESCRIPTION: Illustrates how to use nested `ProviderScope` widgets to override the state or behavior of a specific Riverpod provider for a particular subtree of the UI. This allows different parts of the application to use distinct instances or configurations of the same provider, similar to `InheritedWidget` but managed within the Riverpod framework. This approach is suggested when provider families are not the right fit.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/scopes.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\n// Example showing Riverpod subtree scoping\n// (Content loaded from subtree_scope.dart)\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// A simple counter provider\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Subtree Scope Example')),\n        body: Column(\n          crossAxisAlignment: CrossAxisAlignment.stretch,\n          children: [\n            // Section using the root ProviderScope\n            const RootCounterDisplay(),\n            const Divider(),\n            // Introduce a new ProviderScope to override the counterProvider\n            ProviderScope(\n              overrides: [\n                // Override the counterProvider for this specific subtree.\n                // The state will start at 100 instead of 0.\n                counterProvider.overrideWith((ref) => 100),\n              ],\n              // Section using the overridden ProviderScope\n              child: const ScopedCounterDisplay(),\n            ),\n            const Divider(),\n            // Another section using the root ProviderScope\n            const RootCounterDisplay(),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Widget displaying and interacting with the counter from the root scope\nclass RootCounterDisplay extends ConsumerWidget {\n  const RootCounterDisplay({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final count = ref.watch(counterProvider);\n    final source = ref.read(counterProvider.notifier).hashCode;\n\n    return Padding(\n      padding: const EdgeInsets.all(8.0),\n      child: Column(\n        children: [\n          Text('Root Scope Counter: $count (Notifier: $source)'),\n          ElevatedButton(\n            onPressed: () => ref.read(counterProvider.notifier).state++,\n            child: const Text('Increment Root Counter'),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n// Widget displaying and interacting with the counter from the overridden scope\nclass ScopedCounterDisplay extends ConsumerWidget {\n  const ScopedCounterDisplay({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // This watch will get the state from the nearest ProviderScope, which is the overridden one.\n    final count = ref.watch(counterProvider);\n    // Get the unique hash code of the StateNotifier instance for demonstration\n    final source = ref.read(counterProvider.notifier).hashCode; \n\n    return Padding(\n      padding: const EdgeInsets.all(8.0),\n      child: Column(\n        children: [\n          Text('Scoped Counter: $count (Notifier: $source)'),\n          ElevatedButton(\n            onPressed: () {\n              // This read/modification affects the counterProvider state within the nearest (overridden) scope.\n              ref.read(counterProvider.notifier).state++;\n            },\n            child: const Text('Increment Scoped Counter'),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Unit Test Setup with ProviderContainer - Dart\nDESCRIPTION: This snippet demonstrates how to set up a unit test using a `ProviderContainer` in Dart to test a Riverpod provider.  It explains the importance of creating a new `ProviderContainer` for each test and the usage of `container.read` and `container.listen` to interact with providers.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/essentials/testing.mdx#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\n// 이 테스트에 대한 ProviderContainer를 생성합니다.\n    // 테스트 간에 ProviderContainer를 공유하지 마세요.\n    final container = ProviderContainer();\n\n    // TODO: 컨테이너를 사용하여 애플리케이션을 테스트합니다.\n```\n\n----------------------------------------\n\nTITLE: Consuming a Filtered Todos Provider in a Flutter Widget (Dart)\nDESCRIPTION: This snippet shows a Flutter widget that consumes the completedTodosProvider by using ref.watch to obtain the filtered list of completed todos. It demonstrates the pattern for reading provider values inside a build method and displaying them in a UI ListView. Dependencies include Flutter, Riverpod, and the previously defined completedTodosProvider; input comes from provider state and outputs are widget tree updates.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/providers/provider.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nclass CompletedTodosList extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final completedTodos = ref.watch(completedTodosProvider);\n    return ListView(\n      children: [\n        for (final todo in completedTodos)\n          ListTile(\n            title: Text(todo.description),\n          ),\n      ],\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Interacting with Todo List State Using NotifierProvider in Dart\nDESCRIPTION: This Dart snippet shows how to consume and interact with the todo list state exposed by a NotifierProvider. It demonstrates how the UI can call exposed methods like `addTodo` to modify the todo list in response to user actions. The snippet depends on the previously defined NotifierProvider and Riverpod's consumer widgets or hooks.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/providers/notifier_provider.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n/// Example snippet illustrating usage of NotifierProvider consumer for todos\n// Shows UI integration for updating and displaying the todo list state synchronously.\n\n```\n\n----------------------------------------\n\nTITLE: Using ref.read for event handling in Dart with Riverpod\nDESCRIPTION: Demonstrates the proper use case for ref.read - in event handlers like button press callbacks. This example shows reading a counter provider's notifier to call its increment method.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/tr/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_10\n\nLANGUAGE: dart\nCODE:\n```\nfinal counterProvider = StateNotifierProvider<Counter, int>((ref) => Counter());\n\nclass HomeView extends ConsumerWidget {\n  const HomeView({Key? key}): super(key: key);\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    return Scaffold(\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {\n          // 'Counter' sınıfının 'increment()'ını çağırın.\n          ref.read(counterProvider.notifier).increment();\n        },\n      ),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementazione di un metodo side-effect in Notifier per richieste POST\nDESCRIPTION: Introduce un metodo `addTodo` nel Notifier per eseguire richieste POST, permettendo di modificare lo stato del listato to-do. Si utilizza `ref.read` per invocare il metodo, favorendo un aggiornamento che mantiene sincronizzata la cache locale con lo stato del server.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/essentials/side_effects.mdx#_snippet_3\n\nLANGUAGE: Dart\nCODE:\n```\nvoid addTodo(String newTodo) {\n  // Esempio di richiesta POST per aggiungere un elemento\n  final result = ref.read(todoListProvider.notifier).addTodo(newTodo);\n  // Viene aggiornato lo stato o gestito il risultato\n}\n```\n\n----------------------------------------\n\nTITLE: Different Value Types Obtainable from a StreamProvider in Riverpod Dart\nDESCRIPTION: Describes the various synchronous and asynchronous value types that can be obtained from a Riverpod StreamProvider including AsyncValue, Stream, and Future, with code examples showing usage in Flutter widget build methods for handling loading, error, and data states.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_13\n\nLANGUAGE: Dart\nCODE:\n```\nfinal userProvider = StreamProvider<User>(...);\n\nWidget build(BuildContext context, WidgetRef ref) {\n  AsyncValue<User> user = ref.watch(userProvider);\n\n  return user.when(\n    loading: () => const CircularProgressIndicator(),\n    error: (error, stack) => const Text('Oops'),\n    data: (user) => Text(user.name),\n  );\n}\n```\n\nLANGUAGE: Dart\nCODE:\n```\nWidget build(BuildContext context, WidgetRef ref) {\n  Stream<User> user = ref.watch(userProvider.stream);\n}\n```\n\nLANGUAGE: Dart\nCODE:\n```\nWidget build(BuildContext context, WidgetRef ref) {\n  Future<User> user = ref.watch(userProvider.future);\n}\n```\n\n----------------------------------------\n\nTITLE: Disallowing dynamic provider creation inside classes\nDESCRIPTION: This snippet shows that creating providers as class instance variables is unsupported and can lead to memory leaks or unpredictable behavior. Providers should be defined at the top level as final variables for consistency and reliability.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/essentials/do_dont.mdx#_snippet_5\n\nLANGUAGE: Dart\nCODE:\n```\nclass Example {\n  // サポートされていない操作。\n  final provider = Provider<String>((ref) => 'Hello world');\n}\n```\n\n----------------------------------------\n\nTITLE: Using a ProviderObserver in Dart\nDESCRIPTION: This code snippet demonstrates how to integrate a custom `ProviderObserver` into a `ProviderScope` or a `ProviderContainer`. It involves creating an instance of the observer class and passing it to the `observers` parameter when initializing either the `ProviderScope` (for an entire application) or `ProviderContainer` (for more fine-grained control).  This ensures that the observer is notified of provider events.  Requires the Riverpod package.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/essentials/provider_observer.mdx#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\nrunApp(\n  ProviderScope(\n    observers: [\n      MyObserver(),\n    ],\n    child: MyApp(),\n  )\n);\n\n```\n\nLANGUAGE: Dart\nCODE:\n```\nfinal container = ProviderContainer(\n  observers: [\n    MyObserver(),\n  ],\n);\n\n```\n\n----------------------------------------\n\nTITLE: Using HookConsumerWidget\nDESCRIPTION: This snippet shows how to use `HookConsumerWidget` to combine `HookWidget` and `ConsumerWidget`. This allows using both hooks and Riverpod providers within a single widget. This class simplifies the combination of hooks and Riverpod, extending functionality for state management and consumption.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/about_hooks.mdx#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\n\n```\n\n----------------------------------------\n\nTITLE: Refactoring Hook Logic into Reusable Function - Dart\nDESCRIPTION: This code snippet shows how to refactor hook logic into a reusable function. It defines a function `useFadeIn` that encapsulates the animation controller and its lifecycle, allowing it to be easily reused in different HookWidget instances, promoting code reusability. The snippet also shows the use of the `useAnimation` hook to trigger rebuilds on animation changes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/about_hooks.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\n```dart\ndouble useFadeIn() {\n  final animationController = useAnimationController(\n    duration: const Duration(seconds: 2),\n  );\n  useEffect(() {\n    animationController.forward();\n    return null;\n  }, const []);\n  useAnimation(animationController);\n  return animationController.value;\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Isolating Provider State in testWidgets with Riverpod (Dart)\nDESCRIPTION: This snippet demonstrates how provider state is isolated between tests in Flutter using testWidgets and Riverpod. It declares providers as globals yet guarantees that each test runs with its own state, thanks to ProviderScope which creates a separate ProviderContainer for each test. Dependencies: riverpod, flutter_test. Inputs are widget test functions; outputs are assertions about provider state isolation.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/cookbooks/testing.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal counterProvider = StateProvider((ref) => 0);\n\nvoid main() {\n  testWidgets('first test', (tester) async {\n    await tester.pumpWidget(\n      ProviderScope(\n        child: Container(),\n      ),\n    );\n    expect(\n      ProviderScope.containerOf(\n        tester.element(find.byType(Container)),\n      ).read(counterProvider).state,\n      0,\n    );\n  });\n\n  testWidgets('second test', (tester) async {\n    await tester.pumpWidget(\n      ProviderScope(\n        child: Container(),\n      ),\n    );\n    expect(\n      ProviderScope.containerOf(\n        tester.element(find.byType(Container)),\n      ).read(counterProvider).state,\n      0,\n    );\n  });\n}\n\n```\n\n----------------------------------------\n\nTITLE: ConsumerWidget Implementation\nDESCRIPTION: This snippet demonstrates how to implement a `ConsumerWidget`.  `ConsumerWidget` extends `StatelessWidget` and offers a `ref` object via the `build` method's argument, enabling the widget to interact with providers. This allows the widget to read and watch providers.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\nclass MyConsumerWidget extends ConsumerWidget {\n  const MyConsumerWidget({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // use ref here to interact with providers\n    return const Text('Hello World');\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Initialisation d'un Provider avec ProviderScope dans Flutter\nDESCRIPTION: Ce snippet montre la configuration correcte pour initialiser un provider dans un environnement Flutter en utilisant ProviderScope. Il souligne l'importance d'envelopper l'application avec ProviderScope pour permettre à tous les providers d'être accessibles tout au long de l'arbre de widgets. La première version utilise runApp avec ProviderScope, tandis que la seconde montre un exemple incorrect sans ProviderScope.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/concepts/scopes.mdx#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\nfinal valueProvider = StateProvider((ref) => 0);\n\n// FAITES ceci\nvoid main() {\n  runApp(ProviderScope(child: MyApp()));\n}\n\n// Ne FAITES PAS ceci\nfinal myProviderContainer = ProviderContainer();\nvoid main(){\n  runApp(MyApp());\n}\n```\n\n----------------------------------------\n\nTITLE: Using ProviderObserver with ProviderScope in Flutter\nDESCRIPTION: Demonstrates how to register a custom ProviderObserver with ProviderScope when initializing a Flutter application. This setup enables the observer to monitor all providers in the application.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/essentials/provider_observer.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nrunApp(\n  ProviderScope(\n    observers: [\n      MyObserver(),\n    ],\n    child: MyApp(),\n  )\n);\n```\n\n----------------------------------------\n\nTITLE: Defining NotifierProvider for Local Todo List in Dart\nDESCRIPTION: This snippet demonstrates defining a `Notifier` subclass (`TodosNotifier`) to manage a synchronous list of `Todo` objects. It includes a `build` method to initialize the state and methods like `addTodo` to modify it. A `NotifierProvider` (`todosProvider`) is defined to expose the `TodosNotifier` and its state.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/providers/notifier_provider.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n// Code dynamically loaded via <AutoSnippet language=\"dart\" {...todos}>\n// This typically defines a Notifier class and a NotifierProvider.\n\n// Example structure:\n// class Todo { ... }\n// \n// @riverpod\n// class TodosNotifier extends _$TodosNotifier {\n//   @override\n//   List<Todo> build() {\n//     return []; // Initial state\n//   }\n// \n//   void addTodo(Todo todo) {\n//     state = [...state, todo];\n//   }\n//   // Other methods like removeTodo, toggleTodo...\n// }\n// \n// // The generated provider would be:\n// final todosProvider = NotifierProvider<TodosNotifier, List<Todo>>(/* ... */);\n```\n\n----------------------------------------\n\nTITLE: Cleaning up Resources with onDispose in Riverpod Provider (Dart)\nDESCRIPTION: This snippet demonstrates how to use the `ref.onDispose` callback within a Riverpod provider definition to perform cleanup actions when the provider's state is destroyed. In this example, it's used to safely close a `StreamController` to prevent memory leaks.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/provider_lifecycles.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n// Example based on the description of using onDispose to close a StreamController\n// Assuming this is inside a provider, like StreamProvider.autoDispose\n\nfinal myStreamProvider = StreamProvider.autoDispose<String>((ref) {\n  final controller = StreamController<String>();\n\n  controller.add('Hello');\n  controller.add('World');\n\n  // Register a cleanup callback for when the provider is disposed.\n  ref.onDispose(() {\n    print('Provider disposed, closing StreamController...');\n    controller.close();\n  });\n\n  // Return the stream for consumers to listen to.\n  return controller.stream;\n});\n```\n\n----------------------------------------\n\nTITLE: ChangeNotifier Integration with Riverpod\nDESCRIPTION: Demonstrates how to pipe ChangeNotifier notifications into Riverpod's state management system.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/websockets_sync.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\nclass Counter extends _$Counter {\n  @override\n  int build() {\n    final notifier = ChangeNotifier();\n    ref.onDispose(notifier.dispose);\n    notifier.addListener(notifyListeners);\n    return 0;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Implementation with Error Handling\nDESCRIPTION: Final implementation including loading states, error handling, and proper refresh indicator behavior using AsyncValue and pattern matching.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/case_studies/pull_to_refresh.mdx#2025-04-23_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nclass ActivityPage extends ConsumerWidget {\n  const ActivityPage({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final asyncActivity = ref.watch(activityProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Activity suggestions')),\n      body: RefreshIndicator(\n        onRefresh: () => ref.refresh(activityProvider.future),\n        child: Center(\n          child: switch (asyncActivity) {\n            AsyncData(:final valueOrNull?) => ListView(\n                children: [Text(valueOrNull.activity)],\n              ),\n            AsyncError(:final error) => ListView(\n                children: [Text(error.toString())],\n              ),\n            _ => const Center(child: CircularProgressIndicator()),\n          },\n        ),\n      ),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Converting ChangeNotifier to Riverpod Provider\nDESCRIPTION: Shows how to convert a basic ChangeNotifier class to work with Riverpod while maintaining the same functionality. This represents the first step in migration.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/from_provider/quickstart.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n// If you have this...\nclass MyNotifier extends ChangeNotifier {\n  int state = 0;\n\n  void increment() {\n    state++;\n    notifyListeners();\n  }\n}\n\n// ... just add this!\nfinal myNotifierProvider = ChangeNotifierProvider<MyNotifier>((ref) {\n  return MyNotifier();\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a FutureProvider that depends on another provider in Dart\nDESCRIPTION: Creates a FutureProvider that watches the existing cityProvider to retrieve the current city value, then fetches weather data asynchronously based on that city. This demonstrates how to compose providers with dependencies in Riverpod.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\nfinal weatherProvider = FutureProvider((ref) async {\n  final city = ref.watch(cityProvider);\n  return fetchWeather(city: city);\n});\n```\n\n----------------------------------------\n\nTITLE: Naive Previous Button Widget using ref.watch in Riverpod (Dart)\nDESCRIPTION: This example presents a Flutter widget for a 'previous' button that reads the current page index via ref.watch and disables itself if the index is zero. The widget rebuilds whenever the page index changes, which may be suboptimal. Requires Riverpod, a pageIndexProvider, and Flutter's UI library; input is the current page index and output is a button's enabled/disabled state.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/providers/provider.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nclass PreviousButton extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final pageIndex = ref.watch(pageIndexProvider);\n    return ElevatedButton(\n      onPressed: pageIndex == 0 ? null : () {\n        // Implement previous button logic\n      },\n      child: Text('Previous'),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Todo List State with NotifierProvider in Dart\nDESCRIPTION: This Dart snippet demonstrates the implementation of a todo list using Riverpod's NotifierProvider. It centralizes the state management and business logic for modifying todos, exposing methods like `addTodo` for UI interaction. The snippet requires the Riverpod package and shows how synchronous state changes can be managed effectively.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/providers/notifier_provider.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n/// Example snippet for synchronous todo list with NotifierProvider\n// Provides state and methods to manage a todo list synchronously using Riverpod.\n\n```\n\n----------------------------------------\n\nTITLE: StateProvider API Migration from StateController to direct state watch - Dart\nDESCRIPTION: This snippet highlights the changes in how `StateProvider` is used in Riverpod 1.0.0. The return value of `ref.watch(StateProvider)` now directly returns the state value instead of a StateController instance, simplifying state reads. For backwards-compatible behavior, developers can use `provider.state` to get the StateController explicitly. This snippet shows both the old usage returning a StateController and the updated direct state watching approach.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/bn/docusaurus-plugin-content-docs/current/migration/0.14.0_to_1.0.0.mdx#_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nfinal provider = StateProvider<int>(...);\n\nConsumer(\n  builder: (context, ref, child) {\n    StateController<int> count = ref.watch(provider);\n\n    return Text('\\${count.state}');\n  }\n)\n\n```\n\nLANGUAGE: dart\nCODE:\n```\nfinal provider = StateProvider<int>(...);\n\nConsumer(\n  builder: (context, ref, child) {\n    int count = ref.watch(provider);\n\n    return Text('\\${count}');\n  }\n)\n\n```\n\nLANGUAGE: dart\nCODE:\n```\nfinal provider = StateProvider<int>(...);\n\nConsumer(\n  builder: (context, ref, child) {\n    StateController<int> count = ref.watch(provider.state);\n\n    return Text('\\${count.state}');\n  }\n)\n\n```\n\n----------------------------------------\n\nTITLE: Updating StateProvider Value by Reading Twice in Riverpod (Dart)\nDESCRIPTION: This example shows how to update the value of a StateProvider by first reading its current state, computing the new value, and then assigning it back. Requires: Riverpod. Relevant when needing the previous state to inform the next value. Inputs: provider and intended state transformation; outputs: new provider state. Not as concise as using the .update method and may suffer from reading slightly outdated state under concurrency.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/providers/state_provider.mdx#_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\n/* Example code for reading and writing StateProvider manually. See update_read_twice.dart for details. */\n```\n\n----------------------------------------\n\nTITLE: Obtaining Notifier Instance during Testing in Riverpod (Dart)\nDESCRIPTION: This Dart snippet illustrates how to properly obtain a Notifier instance for accessing its state during tests. It replaces direct instantiation or using .debugState with ref.read, adhering to Riverpod's recommendation for correct provider scope. Dependencies include having a test environment set up with Riverpod providers, and ref appropriately mocked or provided. Input is a provider reference; output is access to the Notifier instance, which exposes the .state field.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/migration/from_state_notifier.mdx#2025-04-23_snippet_11\n\nLANGUAGE: dart\nCODE:\n```\n// Obtain Notifier instance in tests using ref.read\nfinal notifier = ref.read(myNotifierProvider.notifier);\nexpect(notifier.state, /* expected state value */);\n```\n\n----------------------------------------\n\nTITLE: Migrating Mutations to AsyncNotifier in Riverpod (Dart)\nDESCRIPTION: This migrated snippet shows side-effect methods, such as addTodo, directly updating notifier state and handling asynchrony using the AsyncNotifier paradigm in Riverpod (Dart). Dependencies include Riverpod and type definitions for Todo. Mutations now simply reassign state and perform asynchronous operations without manually tracking error or loading flags. Expected input is the new todo item, and the output is an updated immutable list automatically reflected by the provider. There are minimal constraints: state is exposed only via AsyncValue, and error handling is implicitly managed.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/migration/from_change_notifier.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\n/* ... code from /docs/migration/from_change_notifier/migrated ... */\n```\n\n----------------------------------------\n\nTITLE: Defining Providers as Top-level Variables\nDESCRIPTION: This snippet demonstrates the correct way to define providers as top-level final variables, which is the recommended approach for provider creation in Riverpod.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/essentials/do_dont.mdx#_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nfinal provider = Provider<String>((ref) => 'Hello world');\n```\n\n----------------------------------------\n\nTITLE: Waiting for Async Providers in Tests - Dart\nDESCRIPTION: This snippet shows how to handle asynchronous providers (providers that return `Future` or `Stream`) in tests. It describes using the provider's `.future` property to wait for the asynchronous operation to complete before making assertions.  It highlights the need to use `expectLater` for asynchronous expectations.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/essentials/testing.mdx#_snippet_8\n\nLANGUAGE: Dart\nCODE:\n```\n    // TODO: 컨테이너를 사용하여 애플리케이션을 테스트합니다.\n    // 기대(expectation)가 비동기적이므로 \"expectLater\"를 사용해야 합니다.\n    expectLater(\n      container.read(myFutureProvider.future),\n      completion(42),\n    );\n\n    // \"provider\" 대신 \"provider.future\"를 읽습니다.\n    // 이는 비동기 providers에서 가능하며, provider의 값으로 해결(resolve)될 future를 반환합니다.\n\n    // future가 예상한 값으로 resolve되는지 확인할 수 있습니다.\n    // 또는 오류에 \"throwsA\"를 사용할 수 있습니다.\n```\n\n----------------------------------------\n\nTITLE: Adding Riverpod dependency using pub add\nDESCRIPTION: Demonstrates how to add the Flutter Riverpod or Riverpod dependency to a Flutter or Dart project using the `pub add` command. It shows the specific command for each environment.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/introduction/getting_started.mdx#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nflutter pub add flutter_riverpod\n```\n\n----------------------------------------\n\nTITLE: Using ref.watch in Widget build Method to Monitor Providers in Dart\nDESCRIPTION: Shows how to use ref.watch inside a widget's build method to rebuild the UI reactively when the provider's value changes, demonstrated with a simple counter example. Important usage notes include avoiding ref.watch in asynchronous callbacks or lifecycle methods like initState.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_7\n\nLANGUAGE: Dart\nCODE:\n```\n<CodeBlock>{trimSnippet(watchBuild)}</CodeBlock>\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Notifier in Dart (New AsyncNotifier Syntax)\nDESCRIPTION: Example of an asynchronous Notifier using the new AsyncNotifier syntax in Dart. This snippet demonstrates the simplified handling of asynchronous state with AsyncNotifier.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/migration/from_state_notifier.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nfinal todosProvider = AsyncNotifierProvider<TodosNotifier, List<String>>(() {\n  return TodosNotifier();\n});\n\nclass TodosNotifier extends AsyncNotifier<List<String>> {\n  @override\n  Future<List<String>> build() async {\n    await Future.delayed(const Duration(seconds: 1));\n    return ['Buy milk', 'Buy eggs'];\n  }\n\n  Future<void> addTodo(String todo) async {\n    state = const AsyncValue.loading();\n    state = await AsyncValue.guard(() async {\n      await Future.delayed(const Duration(milliseconds: 500));\n      return [...state.value!, todo];\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Marvel API Credentials in JSON\nDESCRIPTION: Configuration file structure for storing Marvel API credentials. The file should be placed in the assets folder and contains the public and private API keys obtained from the Marvel developer portal.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/examples/marvel/README.md#2025-04-23_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"public_key\": \"1234\",\n  \"private_key\": \"5678\"\n}\n```\n\n----------------------------------------\n\nTITLE: Using ref.watch - Dart\nDESCRIPTION: This code shows how to use `ref.watch` to observe and react to changes in another provider from within a widget's `build` method or a provider body. When the observed provider's state changes, the widget or the observing provider will rebuild or recalculate respectively.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_7\n\nLANGUAGE: dart\nCODE:\n```\n/* ... content of reading_watch.dart ... */\n```\n\n----------------------------------------\n\nTITLE: Awaiting Asynchronous Providers - Dart\nDESCRIPTION: This snippet shows how to wait for an asynchronous provider (returning a `Future` or `Stream`) to complete within a test. It does this by using the `.future` property of the provider to await its completion, ensuring the test waits until the asynchronous operation finishes. Requires Riverpod.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/essentials/testing.mdx#_snippet_9\n\nLANGUAGE: Dart\nCODE:\n```\nfinal result = await container.read(myFutureProvider.future);\n```\n\n----------------------------------------\n\nTITLE: Testing Provider Isolation with test - Riverpod - Dart\nDESCRIPTION: Shows how to use standard test (non-Flutter) for testing Riverpod providers, demonstrating that provider state does not persist between tests. Sets up a ProviderContainer fresh for each test and asserts isolation. Dependencies: test, riverpod. Key parameter is the provider setup and the expectation of initial state on each test run. Inputs are global provider definition. Output: passing test with no state leakage.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/cookbooks/testing.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nimport 'package:test/test.dart';\nimport 'package:riverpod/riverpod.dart';\n\nfinal counterProvider = StateProvider((ref) => 0);\n\nvoid main() {\n  test('Each test has its own ProviderContainer', () {\n    final container = ProviderContainer();\n    expect(container.read(counterProvider), 0);\n    container.read(counterProvider.notifier).state++;\n    expect(container.read(counterProvider), 1);\n  });\n\n  test('State is reset between tests', () {\n    final container = ProviderContainer();\n    expect(container.read(counterProvider), 0);\n  });\n}\n\n```\n\n----------------------------------------\n\nTITLE: Combining Providers with Riverpod (Dart)\nDESCRIPTION: This snippet illustrates how Riverpod simplifies combining providers using `ref.watch` and `ref.listen`, offering a more straightforward and less error-prone approach compared to Provider's `ProxyProvider`. It enables reactive combination and caching of values without added overhead.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/from_provider/motivation/motivation.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nimport combine from \"/docs/from_provider/motivation/combine\";\n```\n\n----------------------------------------\n\nTITLE: Filtrare i rebuild dei provider con select in Riverpod - JavaScript/TypeScript\nDESCRIPTION: Questo snippet mostra come utilizzare la funzionalità 'select' di Riverpod per osservare solo specifiche proprietà di un provider, evitando ricostruzioni inutili del consumer quando altre proprietà cambiano. Utilizza 'ref.watch' con 'select' per restituire esclusivamente i dati selezionati, migliorando le performance. Richiede che le proprietà selezionate siano immutabili per azionare correttamente i rebuild. È possibile chiamare 'select' più volte per scegliere le proprietà di interesse.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/advanced/select.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { useProvider } from 'riverpod';\nconst userName = useProvider(userProvider.select((user) => user.name));\n```\n\n----------------------------------------\n\nTITLE: Correctly Watching a Riverpod Family Provider in Dart\nDESCRIPTION: Shows the correct syntax for watching a provider created with `.family`. The required parameter ('id' in this example) must be passed to the family function (`messagesFamily('id')`) when calling `ref.watch` within a widget's `build` method.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/modifiers/family.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nWidget build(BuildContext context, WidgetRef ref) {\n  final response = ref.watch(messagesFamily('id'));\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Listening to Provider Changes - Dart\nDESCRIPTION: This snippet illustrates how to listen to a provider's changes using `container.listen` within a test. This enables you to observe updates to a provider's state and verify the expected behavior. Requires Riverpod.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/essentials/testing.mdx#_snippet_8\n\nLANGUAGE: Dart\nCODE:\n```\ncontainer.listen(\n  myProvider,\n  (String? previous, String? next) {\n    // ...\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Avoid listening to entire objects in Dart\nDESCRIPTION: An auto-generated snippet advising against listening to entire configuration objects, which can cause unnecessary rebuilds when any property changes. Instead, use select when only a specific property is needed.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#_snippet_9\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet language=\"dart\" {...wholeObjectProvider}></AutoSnippet>\n```\n\n----------------------------------------\n\nTITLE: Testing Counter App with Dart and Riverpod\nDESCRIPTION: This snippet demonstrates testing a counter application using only Dart and Riverpod, without Flutter dependencies. It defines a `counterProvider` using `StateProvider` and uses Mockito to verify that listeners are notified when the counter value changes.  It also demonstrates that the counter state is not shared between tests by creating a new `ProviderContainer` for each test.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/tr/docusaurus-plugin-content-docs/current/cookbooks/testing.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n// Yalnızca Dart ile uygulanan ve test edilen bir sayaç (Flutter'a bağımlı olmadan)\n\n// Global olarak bir provider ilan ediyoruz ve bunu iki testte kullanacağız.\n// durum testler arasında doğru şekilde \"0\"a sıfırlanırsa.\n\nfinal counterProvider = StateProvider((ref) => 0);\n\n// Bir provider'ın dinleyicilerine ne zaman bildirimde bulunduğunu izlemek için Mockito'yu kullanma\nclass Listener extends Mock {\n  void call(int? previous, int value);\n}\n\nvoid main() {\n  test('defaults to 0 and notify listeners when value changes', () {\n    // provider'ları okumamızı sağlayacak bir nesne\n    // Bunu testler arasında paylaşmayın.\n    final container = ProviderContainer();\n    addTearDown(container.dispose);\n    final listener = Listener();\n\n    // Bir provider'ı gözlemleyin ve değişiklikleri gözetleyin.\n    container.listen<int>(\n      counterProvider,\n      listener,\n      fireImmediately: true,\n    );\n\n    // dinleyici hemen varsayılan değer olan 0 ile çağrılır\n    verify(listener(null, 0)).called(1);\n    verifyNoMoreInteractions(listener);\n\n    // Değeri arttırıyoruz\n    container.read(counterProvider.notifier).state++;\n\n    // Dinleyici tekrar arandı ama bu sefer 1\n    verify(listener(0, 1)).called(1);\n    verifyNoMoreInteractions(listener);\n  });\n\n  test('the counter state is not shared between tests', () {\n    // provider'ımızı okumak için farklı bir ProviderContainer kullanıyoruz.\n    // Bu, testler arasında hiçbir durumun yeniden kullanılmamasını sağlar\n    final container = ProviderContainer();\n    addTearDown(container.dispose);\n    final listener = Listener();\n\n    container.listen<int>(\n      counterProvider,\n      listener,\n      fireImmediately: true,\n    );\n\n    // Bilgisayar 0'da yeni\n    verify(listener(null, 0)).called(1);\n    verifyNoMoreInteractions(listener);\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing AsyncNotifier state asynchronously in Riverpod with Dart\nDESCRIPTION: This snippet demonstrates how to initialize the state of an AsyncNotifier class by implementing the build method which asynchronously fetches the list of todos. This replaces prior initialization functions and eliminates the need for explicit isLoading or hasError flags by leveraging Riverpod's AsyncValue. The initialization is thus simplified and better integrated with Riverpod's state management paradigm, avoiding manual state manipulation and redundant boilerplate.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/migration/from_change_notifier.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nimport initialization from \"/docs/migration/from_change_notifier/initialization\";\n```\n\n----------------------------------------\n\nTITLE: Migrating from StreamNotifierProvider to Code Generation (Dart)\nDESCRIPTION: This snippet shows the 'before' state using a non-code-generation `StreamNotifierProvider`. The 'after' state uses an asynchronous (Stream) class-based provider with code generation.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/about_code_generation.mdx#_snippet_16\n\nLANGUAGE: dart\nCODE:\n```\n{trimSnippet(streamNotifierProvider)}\n```\n\n----------------------------------------\n\nTITLE: Accessing StateNotifier Instance via Provider in Dart (Riverpod ^0.13.0)\nDESCRIPTION: Prior Riverpod versions accessed the StateNotifier directly by watching the provider itself. This example shows how to obtain the MyStateNotifier instance in the widget build method by watching the provider without the .notifier suffix.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, ScopedReader watch) {\n  MyStateNotifier notifier = watch(provider);\n}\n```\n\n----------------------------------------\n\nTITLE: Sorting Product List using ref.watch - Dart\nDESCRIPTION: This snippet demonstrates using `ref.watch` to observe the `sortProvider` and sort the product list accordingly. It uses the sort type selected by the user. This will update the UI and show the sorted data. Depends on the product definition, and `sortProvider`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/providers/state_provider.mdx#_snippet_5\n\nLANGUAGE: Dart\nCODE:\n```\n// Code for Sorted Product Provider (sorted_product_provider.dart)\n```\n\n----------------------------------------\n\nTITLE: Combining Multiple Modifiers on a Riverpod Provider in Dart\nDESCRIPTION: This snippet shows that multiple Riverpod modifiers can be combined by chaining them. In this example, `.autoDispose` and `.family` are used together on a `FutureProvider` to create a provider that takes a parameter (`userId`) and automatically disposes its state when no longer listened to.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/providers.mdx#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nfinal userProvider = FutureProvider.autoDispose.family<User, int>((ref, userId) async {\n  return fetchUser(userId);\n});\n```\n\n----------------------------------------\n\nTITLE: Migrating StateProvider usage\nDESCRIPTION: This code demonstrates how to migrate `StateProvider` usage in Riverpod after version 1.0.0. Previously, `ref.watch(StateProvider)` returned a `StateController`. Now, it returns the state directly. To access the `StateController`, use `provider.state`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/migration/0.14.0_to_1.0.0.mdx#_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\nfinal provider = StateProvider<int>(...);\n\nConsumer(\n  builder: (context, ref, child) {\n    StateController<int> count = ref.watch(provider);\n\n    return Text('${count.state}');\n  }\n)\n```\n\nLANGUAGE: dart\nCODE:\n```\nfinal provider = StateProvider<int>(...);\n\nConsumer(\n  builder: (context, ref, child) {\n    int count = ref.watch(provider);\n\n    return Text('${count}');\n  }\n)\n```\n\nLANGUAGE: dart\nCODE:\n```\nfinal provider = StateProvider<int>(...);\n\nConsumer(\n  builder: (context, ref, child) {\n    StateController<int> count = ref.watch(provider.state);\n\n    return Text('${count.state}');\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Obtaining ref in HookConsumerWidget (with flutter_hooks) - Riverpod Dart\nDESCRIPTION: This example shows extending HookConsumerWidget, combining both hooks and provider consumption. It's for use with the flutter_hooks and hooks_riverpod packages, allowing access to hooks and a provider 'ref' within the build method. Requires Riverpod, flutter_hooks, and hooks_riverpod; inputs are build context, WidgetRef ref, and hooks context. Outputs are typically widgets utilizing provider states combined with hooks.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/reading.mdx#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nclass MyHookConsumerWidget extends HookConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final value = ref.watch(myProvider);\n    final controller = useTextEditingController();\n    return TextField(controller: controller, decoration: InputDecoration(helperText: '$value'));\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Counter StateNotifier with Ref in Dart\nDESCRIPTION: Demonstrates passing a ref object to a StateNotifier class, allowing the Counter to read providers and manage state.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/reading.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nclass Counter extends StateNotifier<int> {\n  Counter(this.ref) : super(0);\n\n  final Ref ref;\n\n  void increment() => state++;\n}\n\nfinal counterProvider = StateNotifierProvider<Counter, int>((ref) {\n  return Counter(ref);\n});\n```\n\n----------------------------------------\n\nTITLE: Migration of AsyncNotifierProvider from Manual to Generated in Dart\nDESCRIPTION: This snippet details transitioning an AsyncNotifierProvider from a manual setup to a generated class in Dart, aiding in organized asynchronous state management. It contrasts the before and after implementations, focusing on class-based providers.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/about_code_generation.mdx#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nBefore: <original AsyncNotifierProvider code in non-generation style>\n```\n\nLANGUAGE: dart\nCODE:\n```\nAfter: <generated AsyncNotifierProvider class implementation in Dart>\n```\n\n----------------------------------------\n\nTITLE: Consuming Todo List with ChangeNotifierProvider - Dart\nDESCRIPTION: This snippet illustrates how to interact with a todo list managed by a ChangeNotifierProvider.  It uses the provider to access and manipulate the todo list within the user interface. It is dependent on the `todos` provider defined elsewhere, enabling the UI to react to changes in the todo list.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/providers/change_notifier_provider.mdx#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\n// Code for consuming todo list using ChangeNotifierProvider in UI.\n```\n\n----------------------------------------\n\nTITLE: Updating UI to Consume Provider with Arguments\nDESCRIPTION: This code snippet shows how to update the UI to consume a provider which accepts an argument, specifically a provider defined using the `.family` modifier and code generation.  The provider is now a function expecting the argument, a string which represents the activity type, passed to the provider when calling the provider. In the context of code-gen, the parameters passed to the provider are equivalent to the parameters of the annotated function, excluding the 'ref' parameter.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/essentials/passing_args.mdx#_snippet_2\n\nLANGUAGE: Dart\nCODE:\n```\n      // 이제 provider는 activity type을 기대하는 함수입니다.\n      // 단순화를 위해 지금은 상수 문자열을 전달하겠습니다.\n```\n\n----------------------------------------\n\nTITLE: Initializing AsyncNotifier for Todo List in Dart\nDESCRIPTION: Shows how to implement the build method in an AsyncNotifier to initialize the Todo list. It demonstrates fetching todos from an API without manually handling loading states.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/migration/from_change_notifier.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n@override\nFuture<List<Todo>> build() async {\n  // No need to set isLoading = true\n  // No need for try/catch\n  return fetchTodos();\n}\n```\n\n----------------------------------------\n\nTITLE: Proper Navigation-based Initialization\nDESCRIPTION: Shows the recommended approach for initialization logic that depends on external factors by placing it in a navigation button's onPressed callback.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/do_dont.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nElevatedButton(\n  onPressed: () {\n    ref.read(provider).init();\n    Navigator.of(context).push(...);\n  },\n  child: Text('Navigate'),\n)\n```\n\n----------------------------------------\n\nTITLE: Testing Dart-only Applications with Riverpod\nDESCRIPTION: Example demonstrating how Riverpod maintains test isolation in a Dart-only context without Flutter. It shows how ProviderContainer isolates provider state between separate test cases.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/cookbooks/testing.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n// A Counter example implemented with riverpod\n\nfinal counterProvider = StateProvider((ref) => 0);\n\nvoid main() {\n  test('update the counter state', () {\n    final container = ProviderContainer();\n    addTearDown(container.dispose);\n\n    // The default value is `0`, as declared in our provider\n    expect(container.read(counterProvider), 0);\n\n    // We can update the state\n    container.read(counterProvider.notifier).state++;\n\n    // The new value is now visible\n    expect(container.read(counterProvider), 1);\n  });\n\n  test('counter state is not shared between tests', () {\n    final container = ProviderContainer();\n    addTearDown(container.dispose);\n\n    // The state is `0` once again, with no tearDown/setUp needed\n    expect(container.read(counterProvider), 0);\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Connecting a Dropdown to StateProvider in Riverpod\nDESCRIPTION: Converts a stateful dropdown into a stateless consumer widget that reads and updates the sort type through a StateProvider. Shows how to sync UI state with Riverpod state.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/providers/state_provider.mdx#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nclass ProductSort extends ConsumerWidget {\n  const ProductSort({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // Obtain the current sort type\n    final sortType = ref.watch(productSortTypeProvider);\n\n    return DropdownButton<ProductSortType>(\n      value: sortType,\n      onChanged: (value) {\n        // When the user selects a new sort type, update the state\n        if (value != null) {\n          ref.read(productSortTypeProvider.notifier).state = value;\n        }\n      },\n      items: const [\n        DropdownMenuItem(\n          value: ProductSortType.name,\n          child: Text('Sort by name'),\n        ),\n        DropdownMenuItem(\n          value: ProductSortType.price,\n          child: Text('Sort by price'),\n        ),\n      ],\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using ref.keepAlive() to preserve provider state after disposal\nDESCRIPTION: This example illustrates how to utilize 'ref.keepAlive()' within an autoDispose provider to keep its state alive across different parts of the app, such as after an HTTP request completes. It allows controlling whether the provider's state should be maintained even when it's no longer active.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/tr/docusaurus-plugin-content-docs/current/concepts/modifiers/auto_dispose.mdx#_snippet_2\n\nLANGUAGE: Dart\nCODE:\n```\nfinal myProvider = FutureProvider.autoDispose((ref) async {\n  final response = await httpClient.get(...);\n  ref.keepAlive();\n  return response;\n});\n```\n\n----------------------------------------\n\nTITLE: Defining User class with name and age properties in Dart\nDESCRIPTION: This snippet defines an abstract User class with name and age properties, used to demonstrate selective watching of properties.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/reading.mdx#2025-04-23_snippet_8\n\nLANGUAGE: dart\nCODE:\n```\nabstract class User {\n  String get name;\n  int get age;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Live Chat StreamProvider in Dart\nDESCRIPTION: This snippet demonstrates how to create a StreamProvider for handling live chat messages. It uses a Socket instance to receive messages and converts them into a stream of ChatMessage objects.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/providers/stream_provider.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nfinal chatProvider = StreamProvider.autoDispose<List<ChatMessage>>((ref) {\n  final socket = Socket('wss://echo.websocket.org');\n\n  ref.onDispose(() {\n    socket.dispose();\n  });\n\n  return socket.messages.map((message) => ChatMessage.fromJson(message));\n});\n```\n\n----------------------------------------\n\nTITLE: Defining an Asynchronous (Stream) Functional Provider (Dart)\nDESCRIPTION: This snippet shows defining an asynchronous Riverpod provider returning a Stream using an annotated async* function. Riverpod handles stream events and exposes them via AsyncValue.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/about_code_generation.mdx#_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\n{trimSnippet(asyncFnStream)}\n```\n\n----------------------------------------\n\nTITLE: Defining a Synchronous Functional Provider (Dart)\nDESCRIPTION: This snippet demonstrates defining a synchronous Riverpod provider using an annotated function with code generation. This approach is suitable for simple state that doesn't require external modification methods.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/about_code_generation.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n{trimSnippet(syncFn)}\n```\n\n----------------------------------------\n\nTITLE: Unoptimized Previous Button Using Direct State Access (Riverpod, Dart)\nDESCRIPTION: This snippet shows a naive implementation of a PreviousButton widget that directly fetches pageIndex state, enabling or disabling itself based on whether the user is at the first page. As a result, the widget rebuilds on every pageIndex change, even if its enabled state does not need to change. Dependencies: Riverpod, pageIndexProvider. Input: BuildContext, WidgetRef; Output: Previous button (Widget) with enabled/disabled state. This demonstrates a sub-optimal pattern leading to unnecessary UI rebuilds.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/providers/provider.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nclass UnoptimizedPreviousButton extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final pageIndex = ref.watch(pageIndexProvider);\n    return IconButton(\n      icon: Icon(Icons.arrow_back),\n      onPressed: pageIndex == 0 ? null : () => ref.read(pageControllerProvider).previousPage(),\n    );\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Definizione di Ref come proprietà in Provider Notifier in Dart\nDESCRIPTION: Mostra come ottenere l'accesso all'oggetto Ref all'interno di una classe Notifier in Riverpod. Questa proprietà consente di leggere altri provider e di ascoltarne le variazioni nel contesto di classi con stati complessi.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/essentials/combining_requests.mdx#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\n<AutoSnippet {...notifierRef} />\n```\n\n----------------------------------------\n\nTITLE: Combining Providers (Riverpod)\nDESCRIPTION: This snippet shows how to combine providers in Riverpod. It defines a UserIdNotifierProvider and then creates a labelProvider that depends on it. The ref.watch(userIdNotifierProvider) call tells Riverpod to recompute labelProvider whenever the UserIdNotifier's value changes. This creates a dynamic string based on the user ID.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/from_provider/provider_vs_riverpod.mdx#_snippet_7\n\nLANGUAGE: dart\nCODE:\n```\nclass UserIdNotifier extends ChangeNotifier {\n  String? userId;\n}\n\n// ...\n\nfinal userIdNotifierProvider = ChangeNotifierProvider<UserIdNotifier>(\n  (ref) => UserIdNotifier(),\n);\n\nfinal labelProvider = Provider<String>((ref) {\n  UserIdNotifier userIdNotifier = ref.watch(userIdNotifierProvider);\n  return 'The user ID of the the user is ${userIdNotifier.userId}';\n});\n```\n\n----------------------------------------\n\nTITLE: Reading Multiple Providers using Consumer Widget with Riverpod\nDESCRIPTION: Demonstrates how Riverpod's `Consumer` widget simplifies reading multiple providers compared to Provider's `ConsumerN`. Multiple `ref.watch` calls can be made within the same builder function.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/from_provider/provider_vs_riverpod.mdx#_snippet_8\n\nLANGUAGE: dart\nCODE:\n```\nConsumer(\n  builder: (context, ref, child) {\n    Model1 model = ref.watch(model1Provider);\n    Model2 model = ref.watch(model2Provider);\n    Model3 model = ref.watch(model3Provider);\n    // ...\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Defining AsyncNotifier for Asynchronous State (Dart)\nDESCRIPTION: Presents the recommended way to define an AsyncNotifier for handling asynchronous state in Riverpod 2.0+. Relies on AsyncNotifierProvider to expose futures, update methods, and utilities such as .future and .update. Key input is the ref for dependencies; outputs are updated asynchronously, and side effects are cleanly implemented. Deprecates explicit AsyncValue. Limitations: expects Riverpod 2.0+.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/migration/from_state_notifier.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\n<!-- asyncNotifier.dart content placeholder -->\n```\n\n----------------------------------------\n\nTITLE: Watching FutureProvider Future From 0.6.0 (Dart)\nDESCRIPTION: Shows the new pattern introduced in Riverpod 0.6.0 for obtaining the `Future<T>` from a `FutureProvider`. Use `ref.watch(futureProvider.future)`. Note that `ref.read(futureProvider)` now returns an `AsyncValue<T>`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod/CHANGELOG.md#2025-04-23_snippet_13\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nfinal futureProvider = FutureProvider<T>(...);\nfinal example = Provider((ref) {\n  Future<T> future = ref.watch(futureProvider.future);\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Example: Flutter + flutter_riverpod 'Hello World' Application\nDESCRIPTION: Defines a provider that supplies the string 'Hello world' and a widget that reads and displays this value using Riverpod's 'ConsumerWidget'. The app is wrapped in ProviderScope for provider state management. Demonstrates usage of Riverpod in standard Flutter applications.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/es/docusaurus-plugin-content-docs/current/getting_started.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Creates a provider that supplies 'Hello world'.\nfinal helloWorldProvider = Provider((_) => 'Hello world');\n\nvoid main() {\n  runApp(\n    // Wraps entire app in ProviderScope for Riverpod state management.\n    ProviderScope(\n      child: MyApp(),\n    ),\n  );\n}\n\n// Main widget extending Riverpod's ConsumerWidget.\nclass MyApp extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final String value = ref.watch(helloWorldProvider);\n\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: Text('Example')),\n        body: Center(\n          child: Text(value),\n        ),\n      ),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Riverpod Migration Tool\nDESCRIPTION: Command to run the migration tool, which will scan your project for code requiring updates and suggest changes according to the new syntax requirements.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/es/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\nriverpod migrate\n```\n\n----------------------------------------\n\nTITLE: Cache behavior and parameter equality considerations in Riverpod\nDESCRIPTION: This snippet explains the caching semantics when passing parameters to providers. It highlights the importance of parameter's equality, advising against using mutable objects like lists unless they are const, to prevent redundant network requests and infinite loops.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/essentials/passing_args.mdx#_snippet_4\n\nLANGUAGE: Dart\nCODE:\n```\n// Avoid mutable list objects for parameters to ensure proper caching\nfinal activities = ['recreational', 'cooking']; // Problematic\n// Better approach:\nfinal activitiesConst = const ['recreational', 'cooking']; // Ensures proper == behavior\n\n// Or, implement custom equality or use record types (Dart 3) for complex parameters\n```\n\n----------------------------------------\n\nTITLE: Invalidating Family Providers with Specific Parameters\nDESCRIPTION: Demonstrates how to invalidate providers that accept parameters, either targeting specific parameter combinations or invalidating all instances at once.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/auto_dispose.mdx#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\n// Creating a provider that depends on a parameter\nfinal userProvider = FutureProvider.family<User, int>((ref, userId) async {\n  return fetchUser(userId);\n});\n\nvoid example(WidgetRef ref) {\n  // Invalidating a specific user\n  ref.invalidate(userProvider(42));\n\n  // Invalidating all users at once\n  ref.invalidate(userProvider);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Stream Provider Implementation for WebSockets\nDESCRIPTION: Demonstrates how to create a provider that handles Stream-based data sources like WebSockets.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/websockets_sync.mdx#2025-04-23_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\nStream<int> counter(CounterRef ref) async* {\n  yield 0;\n  await Future.delayed(const Duration(seconds: 1));\n  yield 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Usage of ref.watch with StateNotifier in Flutter\nDESCRIPTION: This snippet demonstrates the correct way to use ref.watch with a StateNotifier, allowing for proper state management and updates.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/reading.mdx#2025-04-23_snippet_11\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet language=\"dart\" {...watchNotifierBuild}></AutoSnippet>\n```\n\n----------------------------------------\n\nTITLE: Defining an Asynchronous (Stream) Class-Based Provider (Dart)\nDESCRIPTION: This snippet illustrates defining an asynchronous Riverpod provider managing a Stream using an annotated class. It allows methods for side-effects while handling stream state via AsyncValue.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/about_code_generation.mdx#_snippet_7\n\nLANGUAGE: dart\nCODE:\n```\n{trimSnippet(asyncClassStream)}\n```\n\n----------------------------------------\n\nTITLE: Defining Todo State Management with StateNotifierProvider in Riverpod (Dart)\nDESCRIPTION: This snippet defines a StateNotifierProvider for a Todo list using the Riverpod package in Dart. It creates a StateNotifier subclass for managing the immutable state of the Todo list and exposes methods such as addTodo for updating the list. Dependencies include the riverpod and state_notifier packages. Key parameters include the initial state of the Todo list, and the provider exposes an immutable state with public modification methods. The provider can be consumed by widgets to react to state updates, and is limited to the patterns supported by Riverpod/StateNotifier.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/providers/state_notifier_provider.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n/* Contents of todos.dart, implementing StateNotifier and StateNotifierProvider for Todo management. */\n```\n\n----------------------------------------\n\nTITLE: 테스트 시 상태 액세스 방법 변경\nDESCRIPTION: 기존 `StateNotifier`는 `.debugState`를 통해 상태를 외부에서 검증할 수 있었으나, 새 `Notifier`와 `AsyncNotifier`에서는 이 속성이 제거되고 `.state` 또는 `@visibleForTesting`으로 대체됩니다. 테스트 내에서 수집 또는 검증할 경우 `ref.read()`를 통해 인스턴스를 얻거나, 인스턴스화된 경우 `.state`를 안전하게 사용할 수 있음을 안내합니다. 이로써 테스트작성 방식을 표준화하며, reactively 접근하는 방법도 설명합니다.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/migration/from_state_notifier.mdx#_snippet_9\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet raw={obtainNotifierOnTests} ... />\n```\n\n----------------------------------------\n\nTITLE: Declaring an Auto-Dispose StreamProvider in Dart\nDESCRIPTION: Shows the basic syntax for creating a `StreamProvider` that automatically disposes its state when no longer listened to using the `.autoDispose` modifier in Riverpod. Note the generic type parameter `<User>` is placed after `.autoDispose`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/modifiers/auto_dispose.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nfinal userProvider = StreamProvider.autoDispose<User>((ref) {\n\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Repository and Todo Models in Dart\nDESCRIPTION: This snippet defines the Repository class with an asynchronous method fetchTodos, the Todo data model class with required fields, establishing the data layer structure for fetching and representing TODO items.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/cookbooks/testing.mdx#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\nclass Repository {\n  Future<List<Todo>> fetchTodos() async {}\n}\n\nclass Todo {\n  Todo({\n    required this.id,\n    required this.label,\n    required this.completed,\n  });\n\n  final String id;\n  final String label;\n  final bool completed;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Provider with Multiple Arguments using Records\nDESCRIPTION: This code demonstrates how to define a provider using records in Dart 3 to pass multiple arguments. The snippet defines a record to represent parameters and uses it as the argument type in a provider, which helps to pass the arguments as part of a tuple. The record's `==` operator is automatically implemented, so it can be used to directly create records in the `watch` calls, which is better than using lists in some cases.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/essentials/passing_args.mdx#_snippet_4\n\nLANGUAGE: Dart\nCODE:\n```\n// provider에 전달할 매개변수를 나타내는 레코드를 정의합니다.\n// 타입 정의는 선택 사항이지만 코드를 더 읽기 쉽게 만들 수 있습니다.\n```\n\nLANGUAGE: Dart\nCODE:\n```\n    // 이제 새로 정의된 레코드를 인수 유형으로 사용합니다.\n```\n\nLANGUAGE: Dart\nCODE:\n```\n        // 마지막으로 인수를 사용하여 쿼리 매개변수를 업데이트할 수 있습니다.\n```\n\n----------------------------------------\n\nTITLE: StateNotifier Lifecycles in Dart (Old Syntax)\nDESCRIPTION: Example of StateNotifier lifecycles using the old syntax in Dart. This snippet shows how dispose and other lifecycle events were handled in StateNotifier.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/migration/from_state_notifier.mdx#2025-04-23_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\nfinal myProvider = StateNotifierProvider<MyNotifier, int>((ref) {\n  final duration = ref.watch(durationProvider);\n  ref.onDispose(() {\n    print('Provider disposed');\n  });\n  return MyNotifier(duration);\n});\n\nclass MyNotifier extends StateNotifier<int> {\n  MyNotifier(this.duration) : super(0) {\n    _startTimer();\n  }\n\n  final Duration duration;\n  Timer? _timer;\n\n  void _startTimer() {\n    _timer = Timer.periodic(duration, (_) {\n      if (mounted) {\n        state++;\n      }\n    });\n  }\n\n  @override\n  void dispose() {\n    _timer?.cancel();\n    print('Notifier disposed');\n    super.dispose();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Fetched Activity Data with Riverpod in Flutter/Dart\nDESCRIPTION: Shows a simple Flutter `ConsumerWidget` that listens to an `activityProvider` (not shown). It displays the fetched activity's description when the data is available, without handling loading or error states initially. This serves as the basic UI structure before adding refresh capabilities.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/case_studies/pull_to_refresh.mdx#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nimport 'activity.dart';\nimport 'provider.dart';\n\nclass ActivityCard extends ConsumerWidget {\n  const ActivityCard({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // Read the activityProvider. This will start the network request\n    // if it wasn't already started.\n    // By using \"watch\", this widget will rebuild whenever the provider state changes.\n    final AsyncValue<Activity> activity = ref.watch(activityProvider);\n\n    // Use pattern matching to handle the different states of the provider.\n    return Card(\n      child: Container(\n        padding: const EdgeInsets.all(16),\n        child: Column(\n          children: [\n            Text(\n              // Show the fetched activity\n              activity.valueOrNull?.activity ?? '',\n              style: Theme.of(context).textTheme.headlineSmall,\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Install Riverpod CLI - Shell\nDESCRIPTION: This snippet shows how to install the Riverpod command-line interface (CLI) tool using the Dart package manager. This tool is used to automate the migration process from Riverpod 0.14.x to 1.0.0.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/migration/0.14.0_to_1.0.0.mdx#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ndart pub global activate riverpod_cli\n```\n\n----------------------------------------\n\nTITLE: Implementing a Fade-In Animation with HookWidget in Dart\nDESCRIPTION: Equivalent implementation of a fade-in animation using HookWidget and flutter_hooks. This approach simplifies state management by using hooks like useAnimationController, useEffect, and useAnimation to handle the animation lifecycle.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/about_hooks.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nclass FadeIn extends HookWidget {\n  const FadeIn({Key? key, required this.child}) : super(key: key);\n\n  final Widget child;\n\n  @override\n  Widget build(BuildContext context) {\n    // Crea un AnimationController. Il controller sarà automaticamente distrutto \n    // quando il widget verrà smontato.\n    final animationController = useAnimationController(\n      duration: const Duration(seconds: 2),\n    );\n\n    // useEffect è l'equivalente di initState + didUpdateWidget + dispose.\n    // La callback passata all'useEffect è eseguita la prima volta che l'hook è invocato, \n    // e poi ogni volta che la lista passata come secondo parametro cambia.\n    // Siccome in questo caso passiamo una lista const vuota, è strettamente equivalente a \"initState\".\n    useEffect(() {\n      // inizia l'animazione quando il widget viene renderizzato per la prima volta.\n      animationController.forward();\n      // Potremmo opzionalmente restituire della logica \"dispose\" qui\n      return null;\n    }, const []);\n\n    // Informa Flutter di ricostruire questo widget quando l'animazione si aggiorna.\n    // Questo è equivalente ad AnimatedBuilder\n    useAnimation(animationController);\n\n    return Opacity(\n      opacity: animationController.value,\n      child: child,\n    );\n  }\n```\n\n----------------------------------------\n\nTITLE: Overriding Flutter Theme for a Widget Subtree (Dart)\nDESCRIPTION: This snippet demonstrates the standard Flutter mechanism for overriding theme data. By wrapping a part of the widget tree (e.g., a `Scaffold`) with a `Theme` widget and providing new `ThemeData` via the `data` property, all descendant widgets within that scope will use the overridden theme instead of the application's default theme. This illustrates the concept of subtree-specific configuration, similar to what Riverpod scopes can achieve for providers.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/scopes.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nimport 'package:flutter/material.dart';\n\nclass ThemeOverrideExample extends StatelessWidget {\n  const ThemeOverrideExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData.light(), // Default theme\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Default Theme')),\n        body: Center(\n          child: Theme(\n            // Override theme for this subtree\n            data: ThemeData.dark(),\n            child: Builder(\n              // Use Builder to get context with new theme\n              builder: (context) {\n                return Card(\n                  color: Theme.of(context).cardColor,\n                  child: const Padding(\n                    padding: EdgeInsets.all(16.0),\n                    child: Text(\n                      'This card uses the overridden dark theme',\n                      style: TextStyle(color: Colors.white),\n                    ),\n                  ),\n                );\n              },\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Notifier in Dart\nDESCRIPTION: This snippet outlines the general structure of a Notifier using the `NotifierProvider`. It highlights the necessary components: the provider variable, the provider type, optional modifiers, the Notifier constructor, the Notifier class itself, the Notifier type, and the `build` method. Key functionality focuses on how to modify the state within the provider, detailing the syntax for defining the Notifier.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/essentials/side_effects.mdx#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\nfinal name = SomeNotifierProvider.someModifier<MyNotifier, Result>(MyNotifier.new);\n \nclass MyNotifier extends SomeNotifier<Result> {\n  @override\n  Result build() {\n    <your logic here>\n  }\n\n  <your methods here>\n}\n```\n\n----------------------------------------\n\nTITLE: Connecting StateProvider to TextField using Consumer - Riverpod (Dart)\nDESCRIPTION: Shows how to bind a TextField's onChanged callback to update a Riverpod StateProvider with user input. The Consumer widget grants access to the provider reference. Requires flutter, flutter_riverpod, and a defined searchInputProvider. Takes the new input value from the user, updates the provider's state, and allows further providers to reactively consume changes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/cookbooks/search_as_we_type.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nConsumer(\n  builder: (context, ref, child) {\n    return TextField(\n      onChanged: (value) => ref.read(searchInputProvider.notifier).state = value,\n    );\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Illustrating improper use of ref.read within build method in Dart Riverpod\nDESCRIPTION: This snippet shows an anti-pattern where ref.read is used inside a widget's build method to get a provider's notifier, which can lead to bugs because the widget will not rebuild on state changes. Using ref.watch instead ensures the widget rebuilds when the provider's state updates. Emphasizes the importance of choosing the correct method based on desired rebuild behavior.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/es/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_2\n\nLANGUAGE: Dart\nCODE:\n```\nfinal counterProvider = StateProvider((ref) => 0);\n\nWidget build(BuildContext context, WidgetRef ref) {\n  // Using 'read' to ignore provider updates\n  final counter = ref.read(counterProvider.notifier);\n  return ElevatedButton(\n    onPressed: () => counter.state++,\n    child: const Text('button'),\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using ref.keepAlive with an Auto-Dispose FutureProvider in Dart\nDESCRIPTION: Example of using `ref.keepAlive()` within an `FutureProvider.autoDispose` to prevent the provider state from being disposed even when not listened to, typically used after a successful asynchronous operation like an HTTP request. This ensures the result is cached.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/modifiers/auto_dispose.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nfinal myProvider = FutureProvider.autoDispose((ref) async {\n  final response = await httpClient.get(...);\n  ref.keepAlive();\n  return response;\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a Provider with Arguments (code-gen)\nDESCRIPTION: This code snippet shows how to define a provider that accepts arguments using code generation in Riverpod. The parameters can be added directly to the annotated function. The type of the parameters can be specified and can be used inside the provider.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/essentials/passing_args.mdx#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\n// provider에 인수를 추가할 수 있습니다.\n// 매개변수의 유형은 원하는 대로 지정할 수 있습니다.\n```\n\nLANGUAGE: Dart\nCODE:\n```\n// \"activityType\" 인수를 사용하여 URL을 작성할 수 있습니다.\n// \"https://boredapi.com/api/activity?type=<activityType>\"을 가리키게 됩니다.\n```\n\nLANGUAGE: Dart\nCODE:\n```\n      // 쿼리 매개변수를 수동으로 인코딩할 필요 없이 \"Uri\" 클래스가 자동으로 인코딩합니다.\n```\n\nLANGUAGE: Dart\nCODE:\n```\n  /// Notifier arguments는 build 메서드에 지정됩니다.\n  /// 원하는 개수만큼 지정할 수 있고, 이름도 지정할 수 있으며, optional/named도 지정할 수 있습니다.\n```\n\nLANGUAGE: Dart\nCODE:\n```\n    // 인수는 \"this.<argumentName>\"으로도 사용할 수 있습니다.\n```\n\n----------------------------------------\n\nTITLE: Accessing State from StateNotifierProvider Directly in Dart (Riverpod ^0.14.0)\nDESCRIPTION: Highlights the current recommended method to access the state managed by a StateNotifierProvider by watching the provider directly. The .state property is deprecated and accessing provider yields the current state.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, ScopedReader watch) {\n  MyModel state = watch(provider);\n}\n```\n\n----------------------------------------\n\nTITLE: Updating StateProvider State Efficiently in Dart\nDESCRIPTION: Demonstrates the recommended approach to update a StateProvider's state based on its previous value using the update method, which is more concise and avoids reading the provider twice.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/providers/state_provider.mdx#_snippet_7\n\nLANGUAGE: dart\nCODE:\n```\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\nWidget build(BuildContext context, WidgetRef ref) {\n  return ElevatedButton(\n    onPressed: () {\n      // Use the \"update\" method to atomically update the state\n      ref.read(counterProvider.notifier).update((state) => state + 1);\n    },\n    child: const Text('Increment'),\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Consuming State (0.14.0+) in a Widget (Dart)\nDESCRIPTION: Replaces provider.state with simply provider to access the current state in Riverpod >=0.14.0. The snippet relies on prior provider configuration and expects MyModel as the output. Facilitates a cleaner, more explicit API for state consumption.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#2025-04-23_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, ScopedReader watch) {\n  MyModel state = watch(provider);\n}\n```\n\n----------------------------------------\n\nTITLE: Avoid Dynamically Creating Providers in Riverpod - Dart\nDESCRIPTION: Providers should be declared exclusively as top-level final variables to avoid memory leaks and unintended behavior. Creating providers as instance variables within classes is unsupported and discouraged. While static final declarations inside classes are permitted, they are not supported by Riverpod code generation tools, which prefer top-level declarations for provider discovery and analysis.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/essentials/do_dont.mdx#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nfinal provider = Provider<String>((ref) => 'Hello world');\n```\n\nLANGUAGE: dart\nCODE:\n```\nclass Example {\n  // 不支持的操作。可能导致内存泄漏和意外行为。\n  final provider = Provider<String>((ref) => 'Hello world');\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a StateProvider for sorting options\nDESCRIPTION: Defines a StateProvider named sortProvider to manage the current sorting type in a product list application. Enables simple state modifications for the sorting mode (e.g., by name or price).\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/es/docusaurus-plugin-content-docs/current/providers/state_provider.mdx#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\n<CodeBlock>{trimSnippet(sortProvider)}</CodeBlock>\n```\n\n----------------------------------------\n\nTITLE: StateProvider for filtering todos in Dart\nDESCRIPTION: Defines a StateProvider to manage the selected filter state for a todo list, with enumeration options for none, completed, and uncompleted. Facilitates reactive updates in the UI based on filter changes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nenum Filter {\n  none,\n  completed,\n  uncompleted,\n}\n\nfinal filterProvider = StateProvider((ref) => Filter.none);\n```\n\n----------------------------------------\n\nTITLE: Using ref.read - Dart\nDESCRIPTION: Demonstrates the use of `ref.read` to read a provider's value once without subscribing to changes. This method is often used inside event handlers, like button presses, to get the current value of a provider at that specific moment.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_11\n\nLANGUAGE: dart\nCODE:\n```\n/* ... content of reading_read.dart ... */\n```\n\n----------------------------------------\n\nTITLE: Defining Network Requests with Riverpod Annotation\nDESCRIPTION: This snippet demonstrates how to define a network request using the @riverpod annotation. The function fetches a random activity suggestion from the Bored API, parses the JSON response, and returns the activity string.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod/README.md#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\nFuture<String> boredSuggestion(Ref ref) async {\n  final response = await http.get(\n    Uri.https('boredapi.com', '/api/activity'),\n  );\n  final json = jsonDecode(response.body);\n  return json['activity']! as String;\n}\n```\n\n----------------------------------------\n\nTITLE: Optimizing Rebuilds with ref.watch and select in Flutter (Dart)\nDESCRIPTION: Demonstrates using the `select` modifier with `ref.watch` to optimize widget rebuilds. It specifies a function `(user) => user.name` to only listen for changes in the `name` property of the `User` object provided by `userProvider`. The widget will only rebuild if the `name` changes, ignoring changes to other properties like `age`. Depends on `BuildContext`, `WidgetRef`, and the `userProvider`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_17\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, WidgetRef ref) {\n  String name = ref.watch(userProvider.select((user) => user.name));\n  return Text(name);\n}\n```\n\n----------------------------------------\n\nTITLE: ডার্টে প্রোভাইডার তৈরি ও অন্য তা উপকারিতা ব্যবহার\nDESCRIPTION: প্রোভাইডারকে তৈরি ও ব্যবহার করার মৌলিক উদাহরণ যেখানে একটি সরল প্রোভাইডার দিয়ে একটি শহরের নাম পাঠানো হয়, এবং পরবর্তী প্রোভাইডারটি এই শহরের উপর নির্ভরশীল। এই উদাহরণটি দেখায় কিভাবে একটি প্রোভাইডার অন্য প্রোভাইডারকে রিড করে এবং এটি কিভাবে অ্যাসিঙ্ক্রোনাস ডেটা ফেচ করতে ব্যবহৃত হয়।\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/bn/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nfinal cityProvider = Provider((ref) => 'London');\n```\n\nLANGUAGE: dart\nCODE:\n```\nfinal weatherProvider = FutureProvider((ref) async {\n  final city = ref.watch(cityProvider);\n  return fetchWeather(city: city);\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Pull-to-Refresh Logic\nDESCRIPTION: Adds refresh functionality using RefreshIndicator and ref.refresh to update the activity data when pulled down.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/case_studies/pull_to_refresh.mdx#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nclass ActivityPage extends ConsumerWidget {\n  const ActivityPage({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final activity = ref.watch(activityProvider).value;\n    if (activity == null) return const SizedBox.shrink();\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Activity suggestions')),\n      body: RefreshIndicator(\n        onRefresh: () => ref.refresh(activityProvider.future),\n        child: Center(\n          child: ListView(\n            children: [Text(activity.activity)],\n          ),\n        ),\n      ),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Consuming Riverpod Provider with Arguments in UI\nDESCRIPTION: This snippet shows how to update a Flutter widget to consume a Riverpod provider that accepts arguments. It passes a hardcoded 'recreational' activity type to the provider.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/passing_args.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nclass Example extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final activity = ref.watch(activityProvider('recreational'));\n    return activity.when(\n      loading: () => const CircularProgressIndicator(),\n      error: (error, stack) => Text('Oops, something unexpected happened'),\n      data: (activity) => Text(activity.type),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Gestione di Valori Asincroni con AsyncValue in Riverpod\nDESCRIPTION: Mostra come Riverpod, tramite AsyncValue, possa gestire stati asincroni complessi, come mostrare dati precedenti mentre si caricano nuovi dati. Questo esempio illustra il flusso di stati (loading, data, error, reloading) osservando un provider derivato.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/from_provider/motivation/motivation.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n// Code imported from /docs/from_provider/motivation/async_values\n// Placeholder: Actual code snippet not provided in the input text.\n// Example using AsyncValue to handle asynchronous data fetching and states.\n```\n\n----------------------------------------\n\nTITLE: প্রোভাইডারকে টেস্ট করা ও প্র্যাক্টিস মানানসই উপায়\nDESCRIPTION: প্রোভাইডার দ্বারা তৈরি অবজেক্টের টেস্টিং এর জন্য [ProviderContainer] ব্যবহার এবং প্রোভাইডারকে সরাসরি কিভাবে টেস্ট করবেন, তা বিস্তারিত দেখানো হয়েছে। এর মাধ্যমে অবজেক্টের ইনস্ট্যান্স থেকে নির্ভরতা মুক্ত টেস্টিং সম্ভব।\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/bn/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nfinal repositoryProvider = Provider((ref) => Repository(ref.read));\n\ntest('fetches catalog', () async {\n  final container = ProviderContainer();\n  addTearDown(container.dispose);\n\n  Repository repository = container.read(repositoryProvider);\n  await expectLater(\n    repository.fetchCatalog(),\n    completion(Catalog()),\n  );\n});\n```\n\n----------------------------------------\n\nTITLE: Correct Provider Scope Implementation\nDESCRIPTION: Example of correctly implementing ProviderScope at the root of a Flutter app.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint/README.md#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nvoid main() {\n  runApp(ProviderScope(child: MyApp()));\n}\n```\n\n----------------------------------------\n\nTITLE: Using ConsumerStatefulWidget and ConsumerState in Flutter Dart\nDESCRIPTION: Illustrates how to replace StatefulWidget and State with ConsumerStatefulWidget and ConsumerState to gain access to the ref property for Riverpod provider interaction in stateful widgets. Unlike ConsumerWidget, ref is a property of ConsumerState rather than an argument to build, providing flexibility with stateful lifecycle methods.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_2\n\nLANGUAGE: Dart\nCODE:\n```\n<CodeBlock>{trimSnippet(consumerStatefulWidget)}</CodeBlock>\n```\n\n----------------------------------------\n\nTITLE: Consuming Filtered Todos in Flutter Widget with Riverpod (Dart)\nDESCRIPTION: This snippet demonstrates how a Flutter widget consumes the completedTodosProvider to display a list of completed todos using Riverpod in Dart. It utilizes ConsumerWidget or ref.watch to access the filtered todo list inside the widget's build method. The widget reacts to updates to the completed list and displays relevant UI elements, requiring Riverpod dependencies and the completedTodosProvider to be set up.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/providers/provider.mdx#_snippet_2\n\nLANGUAGE: Dart\nCODE:\n```\n@override\nWidget build(BuildContext context, WidgetRef ref) {\n  final completedTodos = ref.watch(completedTodosProvider);\n  return ListView(\n    children: [\n      for (final todo in completedTodos)\n        ListTile(\n          title: Text(todo.title),\n        ),\n    ],\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Defining StateNotifier Class in Dart\nDESCRIPTION: Basic example of a StateNotifier class with a custom state model that will be used as context for the migration examples that follow.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/es/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nclass MyModel {}\n\nclass MyStateNotifier extends StateNotifier<MyModel> {\n  MyStateNotifier(): super(MyModel());\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Asynchronous Remote Todo List with AsyncNotifierProvider\nDESCRIPTION: Example of implementing an asynchronous remote todo list using AsyncNotifierProvider in Riverpod. Demonstrates how to handle asynchronous state management with remote data fetching.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/providers/notifier_provider.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet language=\"dart\" {...remoteTodos}></AutoSnippet>\n```\n\nLANGUAGE: dart\nCODE:\n```\n{trimSnippet(remoteTodosConsumer)}\n```\n\n----------------------------------------\n\nTITLE: Handling Async Operations with Mounted Check in Riverpod Consumer Widgets\nDESCRIPTION: Demonstrates the proper way to handle asynchronous operations in Riverpod consumer widgets to prevent the \"Cannot use ref after the widget was disposed\" error. Shows an incorrect implementation that can cause errors.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/faq.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nElevatedButton(\n  onPressed: () async {\n    await future;\n    ref.read(...); // May throw \"Cannot use \"ref\" after the widget was disposed\"\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Obtaining Notifier Instances in Tests Using ref.read in Dart\nDESCRIPTION: Explains how to access the state and Notifier instances appropriately in tests by using ref.read rather than instantiating Notifiers manually. Since Notifier/AsyncNotifier expose .state marked with @visibleForTesting instead of .debugState, this approach maintains proper initialization of ref and family parameters and avoids breaking the notifier. This snippet assumes testing context with Dart and Riverpod.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/migration/from_state_notifier.mdx#_snippet_8\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet raw={obtainNotifierOnTests}/>\n```\n\n----------------------------------------\n\nTITLE: Using Mocked Notifiers in Tests - Dart\nDESCRIPTION: This snippet provides a clear example on how to utilize a mocked Notifier in tests.  It shows how to override a provider to use a mock Notifier. This allows for testing the functionality of classes that depend on the Notifier by controlling the Notifier's behavior.  It demonstrates how to retrieve the mock Notifier from the container for interaction.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/essentials/testing.mdx#_snippet_10\n\nLANGUAGE: Dart\nCODE:\n```\n    final container = ProviderContainer(\n      // provider를 Override하여 Mock Notifier를 생성하도록 합니다.\n      overrides: [myNotifierProvider.overrideWith((ref) => mock)],\n    );\n\n    // 그런 다음 컨테이너를 통해 Mock Notifier를 가져옵니다:\n    final mock = container.read(myNotifierProvider);\n\n    // 그러면 실제 notifier와 마찬가지로 notifier와 상호 작용할 수 있습니다:\n    mock.myMethod();\n```\n\n----------------------------------------\n\nTITLE: 패밀리 (family) 및 autoDispose 대응 구조\nDESCRIPTION: 패밀리와 자동폐기(autoDispose) 지원이 새 API에서는 매개변수를 `build` 메서드 내에서 선언하는 방식으로 변경됨을 보여줍니다. 기존 `StateNotifierProvider.family` 구조와 달리, `build`에 매개변수를 선언하여 가독성과 안전성을 높였습니다. 예제에서 패밀리 프로바이더를 선언하는 방법과 이를 사용하는 팁을 설명하며, 새 API에서 매개변수 활용 방식이 간결하다는 점에 대해 설명합니다.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/migration/from_state_notifier.mdx#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet raw={familyAndDisposeOld}/>\n```\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet language=\"dart\" {...familyAndDispose}></AutoSnippet>\n```\n\n----------------------------------------\n\nTITLE: Defining TodoList StateNotifier in Dart\nDESCRIPTION: Creates a StateNotifier for managing a list of todos, with methods for adding and toggling todo items.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/bn/docusaurus-plugin-content-docs/current/providers/provider.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nfinal todoListProvider = StateNotifierProvider<TodoList, List<Todo>>((ref) {\n  return TodoList([\n    Todo(id: '1', description: 'Buy milk', completed: false),\n    Todo(id: '2', description: 'Buy eggs', completed: false),\n    Todo(id: '3', description: 'Buy bread', completed: false),\n  ]);\n});\n\nclass TodoList extends StateNotifier<List<Todo>> {\n  TodoList(List<Todo> initialTodos) : super(initialTodos);\n\n  void addTodo(Todo todo) {\n    state = [...state, todo];\n  }\n\n  void toggleTodo(String todoId) {\n    state = [\n      for (final todo in state)\n        if (todo.id == todoId)\n          todo.copyWith(completed: !todo.completed)\n        else\n          todo,\n    ];\n  }\n}\n\nclass Todo {\n  Todo({\n    required this.id,\n    required this.description,\n    required this.completed,\n  });\n\n  final String id;\n  final String description;\n  final bool completed;\n\n  Todo copyWith({bool? completed}) {\n    return Todo(\n      id: id,\n      description: description,\n      completed: completed ?? this.completed,\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Correctly Watching a Family Provider with Parameter in Dart\nDESCRIPTION: Illustrates the correct syntax for watching a Riverpod provider defined with `.family`. The required parameter (in this case, a string `'id'`) must be passed to the family (`messagesFamily('id')`) when calling `ref.watch` to get the specific provider instance.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/modifiers/family.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, WidgetRef ref) {\n  final response = ref.watch(messagesFamily('id'));\n}\n```\n\n----------------------------------------\n\nTITLE: 기존 `addListener` 및 `.stream` API의 대체\nDESCRIPTION: `StateNotifier`의 `.addListener`와 `.stream` API는 새 API에서는 사용이 권장되지 않으며, 대신 `ref.listen()`으로 대체됩니다. 예전과 동일한 리스닝 패턴을 유지하면서, 새 구조에서는 `Notifier` 또는 `AsyncNotifier`를 대상으로 하는 수신 방식을 보여줍니다. 이로써 API 일관성을 유지하고, 개발자는 더 간단한 수신 방식을 사용할 수 있습니다.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/migration/from_state_notifier.mdx#_snippet_8\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet raw={addListenerOld} ... />\n```\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet language=\"dart\" {...addListener}></AutoSnippet>\n```\n\n----------------------------------------\n\nTITLE: Detecting BuildContext in Provider Build Method (Dart)\nDESCRIPTION: This snippet shows a build method in a provider class where BuildContext is passed as both a positional and named parameter. Both instances are flagged by the linter as violations of the 'avoid_build_context_in_providers' rule.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/avoid_build_context_in_providers/avoid_build_context_in_providers_lint.md#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n  int build(\n    // expect_lint: avoid_build_context_in_providers\n    BuildContext context1, {\n    // expect_lint: avoid_build_context_in_providers\n    required BuildContext context2,\n\n```\n\n----------------------------------------\n\nTITLE: Keep State Alive with Codegen - Dart\nDESCRIPTION: Demonstrates how to use code generation with the `keepAlive: true` annotation to prevent a provider's state from being automatically disposed of when there are no active listeners.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/essentials/auto_dispose.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n// stateが自動破棄されることを無効にするため、アノテーションに\"keepAlive: true\"を指定します。\n```\n\n----------------------------------------\n\nTITLE: Running Riverpod migrate command\nDESCRIPTION: This command executes the Riverpod migration tool on the current project. It analyzes the project and suggests changes to migrate to the latest Riverpod syntax.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/migration/0.14.0_to_1.0.0.mdx#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nriverpod migrate\n```\n\n----------------------------------------\n\nTITLE: pubspec.yaml for Flutter Riverpod\nDESCRIPTION: YAML configuration snippet for including the Flutter Riverpod package in pubspec.yaml, enabling dependency management for Flutter projects using Riverpod.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/getting_started.mdx#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n<AutoSnippet title=\"pubspec.yaml\" language=\"yaml\" {...pubspec}></AutoSnippet>\n```\n\n----------------------------------------\n\nTITLE: Listening to Provider Changes with ProviderContainer in Dart\nDESCRIPTION: Presents the updated method for subscribing to provider changes using ProviderContainer.listen, replacing the previous Provider.watchOwner approach. This method requires a ProviderContainer instance and a provider, and allows registration of callbacks for mayHaveChanged and didChange events. The returned subscription can be closed to remove the listener.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/hooks_riverpod/CHANGELOG.md#_snippet_25\n\nLANGUAGE: dart\nCODE:\n```\nProviderContainer container;\nfinal provider = Provider((ref) => 0);\n\nfinal subscription = container.listen(\n  provider,\n  mayHaveChanged: (sub) {},\n  didChange: (sub) {}.\n);\n\nsubscription.close();\n```\n\n----------------------------------------\n\nTITLE: Optimized Previous Button Implementation in Dart\nDESCRIPTION: This snippet shows an optimized implementation of a 'previous' button using a separate Provider to compute the button's enabled state, reducing unnecessary rebuilds.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/providers/provider.mdx#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nfinal canGoToPreviousPageProvider = Provider<bool>((ref) {\n  return ref.watch(pageIndexProvider) > 0;\n});\n\nclass PreviousButton extends ConsumerWidget {\n  const PreviousButton({Key? key}): super(key: key);\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final canGoToPreviousPage = ref.watch(canGoToPreviousPageProvider);\n    return ElevatedButton(\n      onPressed: canGoToPreviousPage\n          ? () => ref.read(pageIndexProvider.notifier).update((state) => state - 1)\n          : null,\n      child: const Text('previous'),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic AutoDispose Usage with StreamProvider in Dart\nDESCRIPTION: Demonstrates how to add the .autoDispose modifier to a StreamProvider to enable automatic state cleanup when the provider is no longer used.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/modifiers/auto_dispose.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nfinal userProvider = StreamProvider.autoDispose<User>((ref) {\n\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a ConsumerStatefulWidget in Riverpod\nDESCRIPTION: Demonstrates creating a stateful widget that can read providers by using ConsumerStatefulWidget and ConsumerState, where ref is a property of the state.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/reading.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nclass MyWidget extends ConsumerStatefulWidget {\n  const MyWidget({super.key});\n\n  @override\n  ConsumerState<MyWidget> createState() => _MyWidgetState();\n}\n\nclass _MyWidgetState extends ConsumerState<MyWidget> {\n  @override\n  void initState() {\n    super.initState();\n    // We can use ref here\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // We can also use ref here\n    return Container();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Combining AutoDispose and Family\nDESCRIPTION: This snippet combines the `autoDispose` and `family` modifiers on a `FutureProvider`.  It shows how to create a `FutureProvider` that fetches user data based on a `userId` and automatically disposes its state when no longer needed.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/tr/docusaurus-plugin-content-docs/current/concepts/providers.mdx#_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nfinal userProvider = FutureProvider.autoDispose.family<User, int>((ref, userId) async {\n  return fetchUser(userId);\n});\n```\n\n----------------------------------------\n\nTITLE: Linting Missing Ref Parameter in Riverpod Functional Provider (Dart)\nDESCRIPTION: This snippet shows a functional provider without the required 'ref' parameter. The linter warns that functional providers must receive a ref matching the provider name as their first positional parameter.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/functional_ref/failing_functional_ref_lint.md#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\n// expect_lint: functional_ref\nint refless() {\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Flutter Widget Test with Provider Overriding\nDESCRIPTION: This provides a full example of a Flutter widget test using Riverpod. It includes defining a mock repository (`FakeRepository`), setting up the test environment with `ProviderScope` and `overrides` to inject the mock, and asserting the expected UI state based on the mocked data. It combines the concepts of test setup, provider overriding, and widget interaction/assertion.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/cookbooks/testing.mdx#2025-04-23_snippet_7\n\nLANGUAGE: Dart\nCODE:\n```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:flutter_test/flutter_test.dart';\n\n// The code from the previous snippets\nclass Repository {\n  Future<List<Map<String, Object?>>> fetchTodos() async => [];\n}\n\nfinal repositoryProvider = Provider<Repository>((ref) => Repository());\n\nfinal todoListProvider = FutureProvider<List<Map<String, Object?>>>((ref) async {\n  final repository = ref.watch(repositoryProvider);\n  return repository.fetchTodos();\n});\n\nclass MyApp extends StatelessWidget {\n  const MyApp({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: HomePage(),\n    );\n  }\n}\n\nclass HomePage extends ConsumerWidget {\n  const HomePage({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final todos = ref.watch(todoListProvider);\n\n    return Scaffold(\n      body: todos.when(\n        loading: () => const CircularProgressIndicator(),\n        error: (err, stack) => const Text('error'),\n        data: (todos) {\n          return ListView(\n            children: [\n              for (final todo in todos)\n                Text(todo['label']! as String),\n            ],\n          );\n        },\n      ),\n    );\n  }\n}\n\n// The mocked implementation of Repository\nclass FakeRepository implements Repository {\n  @override\n  Future<List<Map<String, Object?>>> fetchTodos() async {\n    return [\n      {'id': 42, 'label': 'Hello world'}\n    ];\n  }\n}\n\nvoid main() {\n  testWidgets('Override repositoryProvider', (tester) async {\n    await tester.pumpWidget(\n      ProviderScope(\n        overrides: [\n          repositoryProvider.overrideWithValue(FakeRepository())\n        ],\n        child: const MyApp(),\n      ),\n    );\n\n    // The first frame is a loading state.\n    expect(find.byType(CircularProgressIndicator), findsOneWidget);\n\n    // Re-render. TodoListProvider should have finished fetching the todos by now\n    await tester.pump();\n\n    // No longer loading\n    expect(find.byType(CircularProgressIndicator), findsNothing);\n\n    // Rendered the fake todo list instead of the real one.\n    expect(find.text('Hello world'), findsOneWidget);\n  });\n}\n\n```\n\n----------------------------------------\n\nTITLE: Manually Updating Mutable Local Cache in Dart\nDESCRIPTION: This code demonstrates an alternative approach to manually updating the local cache using mutable state instead of immutable state.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/side_effects.mdx#2025-04-23_snippet_8\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet raw={mutableManualAddTodo} />\n```\n\n----------------------------------------\n\nTITLE: Migrating context.read to ref.read in Dart\nDESCRIPTION: Example of updating from context.read to ref.read, changing StatelessWidget to ConsumerWidget.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/migration/0.14.0_to_1.0.0.mdx#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nclass Example extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    SomeButton(\n      onPressed: () => context.read(provider.notifier).doSomething(),\n    );\n  }\n}\n```\n\nLANGUAGE: dart\nCODE:\n```\nclass Example extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    SomeButton(\n      onPressed: () => ref.read(provider.notifier).doSomething(),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using AsyncValue.requireValue in Riverpod for Simplified Data Access\nDESCRIPTION: This code demonstrates how to use AsyncValue.requireValue to simplify access to AsyncValue data in widgets, avoiding repeated pattern matching for loading/error states. This approach throws an exception with a clear message if the data is not available.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/eager_initialization.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nclass MyWidget extends ConsumerWidget {\n  const MyWidget({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // This will throw if the AsyncValue is in loading/error state\n    // But this is fine because we handle those states in _EagerInitialization\n    final value = ref.watch(someAsyncProvider).requireValue;\n\n    return Text(value);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Definizione del modello di dati Activity\nDESCRIPTION: Il modello rappresenta la struttura dei dati restituiti dall'API e include metodi per decodificare l'oggetto JSON in un'istanza Dart. È consigliato usare code-generator come json_serializable o Freezed per la generazione automatica.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/essentials/first_request.mdx#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\n<AutoSnippet title=\"activity.dart\" {...activity} />\n```\n\n----------------------------------------\n\nTITLE: Using StatefulHookConsumerWidget for Stateful Hooks with Riverpod in Dart\nDESCRIPTION: Demonstrates replacing a HookWidget with StatefulHookConsumerWidget to leverage both flutter_hooks and StatefulWidget lifecycle methods alongside Riverpod's ref functionality. This allows hooks usage with stateful lifecycle management for more complex widget behavior.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_4\n\nLANGUAGE: Dart\nCODE:\n```\n<CodeBlock>{trimSnippet(statefulHookConsumerWidget)}</CodeBlock>\n```\n\n----------------------------------------\n\nTITLE: Using Dart code snippets in Riverpod documentation\nDESCRIPTION: This snippet demonstrates how code snippets are embedded within the documentation using the CodeBlock component, showcasing syntax highlighting and proper presentation of Dart code for clarity.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/about_code_generation.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n{trimSnippet(rawFetchUser)}\n```\n\nLANGUAGE: dart\nCODE:\n```\n{trimSnippet(fetchUser)}\n```\n\n----------------------------------------\n\nTITLE: Defining a Notifier in Dart (New Notifier Syntax)\nDESCRIPTION: Example of defining a Notifier using the new syntax in Dart. This snippet demonstrates how the new Notifier API centralizes logic in the build method and simplifies initialization.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/migration/from_state_notifier.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nfinal counterProvider = NotifierProvider<Counter, int>(() {\n  return Counter();\n});\n\nclass Counter extends Notifier<int> {\n  @override\n  int build() {\n    return ref.watch(initialCountProvider);\n  }\n\n  void increment() => state++;\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Help for Riverpod CLI Migration Tool in Shell\nDESCRIPTION: Command to show available commands and options for the Riverpod CLI. Useful to understand usage before running migration procedures.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_8\n\nLANGUAGE: sh\nCODE:\n```\nriverpod --help\n```\n\n----------------------------------------\n\nTITLE: Testing a Provider Using ProviderContainer in Dart\nDESCRIPTION: Shows how to test a Riverpod provider (`repositoryProvider`) that depends on `ref.read`. It uses `ProviderContainer` to create an isolated environment for the provider, reads the provider's instance using `container.read`, and then calls methods on the instance (`repository.fetchCatalog()`) for testing.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#2025-04-23_snippet_7\n\nLANGUAGE: dart\nCODE:\n```\nfinal repositoryProvider = Provider((ref) => Repository(ref.read));\n\ntest('fetches catalog', () async {\n  final container = ProviderContainer();\n  addTearDown(container.dispose);\n\n  Repository repository = container.read(repositoryProvider);\n\n  await expectLater(\n    repository.fetchCatalog(),\n    completion(Catalog()),\n  );\n});\n```\n\n----------------------------------------\n\nTITLE: Using ref.listen in a Provider\nDESCRIPTION: Demonstrates how to use ref.listen inside a provider to react to changes in another provider, such as showing notifications when state changes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/reading.mdx#2025-04-23_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\nfinal anotherProvider = Provider<void>((ref) {\n  ref.listen<int>(counterProvider, (previous, next) {\n    if (next == 5) {\n      // Maybe show a notification\n    }\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Detecting Unused Dependencies in Annotations (Dart)\nDESCRIPTION: This snippet demonstrates the lint detecting unused dependencies in the @Dependencies annotation. The 'dep' dependency is declared but not used in the function.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/provider_dependencies/missing_dependencies_lint.md#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n// expect_lint: provider_dependencies\n@Dependencies([dep])\nvoid depFn() {}\n```\n\n----------------------------------------\n\nTITLE: Combining Todo List and Filter to produce a filtered list in Dart\nDESCRIPTION: Creates a provider that listens to both the todo list and filter state providers to generate a filtered list of todos. The provider updates reactively when either source changes, enabling dynamic UI filtering.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#_snippet_4\n\nLANGUAGE: Dart\nCODE:\n```\nfinal filteredTodoListProvider = Provider<List<Todo>>((ref) {\n  final filter = ref.watch(filterProvider);\n  final todos = ref.watch(todoListProvider);\n\n  switch (filter) {\n    case Filter.none:\n      return todos;\n    case Filter.completed:\n      return todos.where((todo) => todo.completed).toList();\n    case Filter.uncompleted:\n      return todos.where((todo) => !todo.completed).toList();\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Transforming State with ref.watch and select in Dart\nDESCRIPTION: Illustrates using `select` with `ref.watch` not only to extract data but also to transform it. The example watches `userProvider` but selects and transforms the user's name into a formatted string `'Mr ${user.name}'`. The widget or listener using this will only react when the *result* of this transformation changes, which depends on the equality comparison (`==`) of the returned value.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_19\n\nLANGUAGE: dart\nCODE:\n```\nfinal label = ref.watch(userProvider.select((user) => 'Mr ${user.name}'));\n```\n\n----------------------------------------\n\nTITLE: Keeping Provider Alive in Code Generation - Riverpod/Dart\nDESCRIPTION: This snippet demonstrates how to prevent automatic state disposal for a provider when using Riverpod's code generation. By adding `keepAlive: true` to the `@riverpod` annotation, the provider's state will not be destroyed even when it no longer has active listeners.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/essentials/auto_dispose.mdx#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\n@riverpod(keepAlive: true)\nString keepAliveExample(KeepAliveExampleRef ref) {\n  // The state will never be disposed\n  return 'Hello World';\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Widget Test Example\nDESCRIPTION: A full example showing widget testing with providers, including setup, interaction, and state verification.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/testing.mdx#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\ntestWidgets('Counter increments smoke test', (tester) async {\n  // Build our app and trigger a frame.\n  await tester.pumpWidget(\n    const ProviderScope(child: MyApp()),\n  );\n\n  // Verify that our counter starts at 0.\n  expect(find.text('0'), findsOneWidget);\n  expect(find.text('1'), findsNothing);\n\n  // Tap the '+' icon and trigger a frame.\n  await tester.tap(find.byIcon(Icons.add));\n  await tester.pump();\n\n  // Verify that our counter has incremented.\n  expect(find.text('0'), findsNothing);\n  expect(find.text('1'), findsOneWidget);\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Provider in Dart\nDESCRIPTION: Demonstrates how to create a basic provider using the Provider class. The provider exposes a String value 'Hello world' that never changes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/providers.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nfinal myProvider = Provider<String>((ref) => 'Hello world');\n```\n\n----------------------------------------\n\nTITLE: Implementing a Filtered Todo List Provider in Dart with Riverpod\nDESCRIPTION: This example shows how to use ref.watch to create a provider that combines and filters data from other providers. It creates a filtered todo list based on a filter type and a list of todos.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/de/docusaurus-plugin-content-docs/current/concepts/reading.mdx#2025-04-23_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nfinal filteredTodoListProvider = Provider((ref) {\n  final FilterType filter = ref.watch(filterTypeProvider);\n  final List<Todo> todos = ref.watch(todosProvider);\n\n  switch (filter) {\n    case FilterType.none:\n      return todos;\n    case FilterType.completed:\n      return todos.where((todo) => todo.completed).toList();\n    case FilterType.uncompleted:\n      return todos.where((todo) => !todo.completed).toList();\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Testing a provider that uses ref.read in Dart\nDESCRIPTION: Demonstrates how to write a test for a provider-dependent object by using ProviderContainer to instantiate the provider and calling its methods directly. Facilitates unit testing without triggering UI rebuilds.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/es/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#_snippet_7\n\nLANGUAGE: Dart\nCODE:\n```\nfinal repositoryProvider = Provider((ref) => Repository(ref.read));\n\ntest('fetches catalog', () async {\n  final container = ProviderContainer();\n  addTearDown(container.dispose);\n\n  Repository repository = container.read(repositoryProvider);\n\n  await expectLater(\n    repository.fetchCatalog(),\n    completion(Catalog()),\n  );\n});\n```\n\n----------------------------------------\n\nTITLE: Using Riverpod Provider Modifiers (.autoDispose, .family) in Dart\nDESCRIPTION: Demonstrates how to apply modifiers to Riverpod providers to add extra functionality. `.autoDispose` makes the provider destroy its state when no longer listened to, and `.family` allows passing external parameters during provider creation. The syntax resembles named constructors.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/providers.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nfinal myAutoDisposeProvider = StateProvider.autoDispose<int>((ref) => 0);\nfinal myFamilyProvider = Provider.family<String, int>((ref, id) => '$id');\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Providers with Riverpod\nDESCRIPTION: This snippet shows how to define a provider using Riverpod. Instead of widgets, providers are defined as top-level final variables. A ProviderScope widget is required at the root of the application to enable Riverpod functionality. The counterProvider is created as a ChangeNotifierProvider, similar to Provider, but it's a global variable outside of the widget tree.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/from_provider/provider_vs_riverpod.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n// I provider sono ora variabili top-level\nfinal counterProvider = ChangeNotifierProvider<Counter>((ref) => Counter());\n\nvoid main() {\n  runApp(\n    // Questo widget attiva Riverpod sull'intero progetto\n    ProviderScope(\n      child: MyApp(),\n    ),\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Repository Pattern with Riverpod\nDESCRIPTION: Implementation of a repository pattern using Riverpod for API communication. This snippet shows how to create a repository provider and a dependent todo list provider that fetches data from the repository.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/cookbooks/testing.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n// A provider that creates a Repository\nfinal repositoryProvider = Provider((ref) => Repository());\n\n// A provider that creates a Repository and exposes the list of todos\nfinal todoListProvider = FutureProvider((ref) async {\n  // We obtain the Repository instance\n  final repository = ref.watch(repositoryProvider);\n\n  // Then we use it to fetch the list of todos\n  return repository.fetchTodos();\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Refresh Logic to RefreshIndicator - Dart\nDESCRIPTION: This snippet adds the refresh logic to the `RefreshIndicator`. The `onRefresh` callback uses `ref.refresh` to refresh the provider. This ensures that the data is updated when the user pulls down to refresh. The future property ensures the future completes once refreshing is done.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/case_studies/pull_to_refresh.mdx#_snippet_4\n\nLANGUAGE: Dart\nCODE:\n```\n/* code for displayActivity3 not provided in the text */\n```\n\n----------------------------------------\n\nTITLE: Installing Riverpod CLI Migration Tool\nDESCRIPTION: Commands to install the Riverpod CLI migration tool using dart pub global activate.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/migration/0.14.0_to_1.0.0.mdx#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ndart pub global activate riverpod_cli\n```\n\nLANGUAGE: sh\nCODE:\n```\nriverpod --help\n```\n\n----------------------------------------\n\nTITLE: Watching Future from StreamProvider in Dart with Riverpod\nDESCRIPTION: Demonstrates accessing a Future that resolves to the latest emitted value from a StreamProvider using the .future modifier with ref.watch.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/tr/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_15\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, WidgetRef ref) {\n  Future<User> user = ref.watch(userProvider.future);\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect AutoDispose Provider Usage in Dart\nDESCRIPTION: Example showing incorrect usage where an autoDispose provider is watched by a non-autoDispose provider, causing a compilation error.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/modifiers/auto_dispose.mdx#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nfinal firstProvider = Provider.autoDispose((ref) => 0);\n\nfinal secondProvider = Provider((ref) {\n  ref.watch(firstProvider);\n});\n```\n\n----------------------------------------\n\nTITLE: Interacting with Remote Todo List State Using AsyncNotifierProvider in Dart\nDESCRIPTION: This Dart snippet explains how to consume and interact with the remote todo list state exposed by an AsyncNotifierProvider. It shows the UI usage pattern for calling methods like `addTodo` asynchronously, allowing users to modify remote todo lists. It depends on the remote AsyncNotifierProvider definition and Riverpod consumer mechanisms.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/providers/notifier_provider.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\n/// Example snippet illustrating usage of AsyncNotifierProvider consumer for remote todos\n// Enables UI integration for asynchronous state updates and interactions with remote todo list.\n\n```\n\n----------------------------------------\n\nTITLE: Detecting Missing ProviderScope in Non-main Function in Dart\nDESCRIPTION: Example of code that triggers the 'missing_provider_scope' linting warning in a non-main function when calling runApp without wrapping the app in a ProviderScope widget.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/missing_provider_scope/missing_provider_scope_lint.md#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nvoid definitelyNotAMain() {\n  // expect_lint: missing_provider_scope\n  runApp(\n    MyApp(),\n  );\n```\n\n----------------------------------------\n\nTITLE: Using ref.listen to React to Provider Changes\nDESCRIPTION: Demonstrates using ref.listen to react to provider changes. This alternative to ref.watch uses a callback approach to handle changes in the provider state.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/combining_requests.mdx#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\nclass RestaurantsNearUser extends _$RestaurantsNearUser {\n  @override\n  Future<List<Restaurant>> build() async {\n    // Initially, we don't have any restaurants\n    Coordinates? currentLocation;\n    List<Restaurant> restaurants = [];\n\n    // Add a listener to the location provider.\n    // Whenever the location changes, update the restaurants.\n    ref.listen<AsyncValue<Coordinates>>(\n      locationProvider,\n      (previous, next) {\n        // If the location is loading or has an error, do nothing.\n        // We could handle those cases here if we wanted to.\n        if (!next.hasValue) return;\n\n        // Update the location and fetch the restaurants\n        currentLocation = next.value;\n        _fetchRestaurants();\n      },\n    );\n\n    // Fetch the initial location if available\n    final locationValue = ref.read(locationProvider);\n    if (locationValue.hasValue) {\n      currentLocation = locationValue.value;\n      restaurants = await _fetchRestaurants();\n    }\n\n    return restaurants;\n  }\n\n  Future<List<Restaurant>> _fetchRestaurants() async {\n    if (currentLocation == null) return [];\n\n    // Use a provider to fetch the restaurants near the location\n    final result = await ref.read(\n      restaurantsNearLocationProvider(currentLocation!).future,\n    );\n\n    // Update the state with the new restaurants\n    state = AsyncData(result);\n    return result;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: AutoDispose Listen Example - Dart\nDESCRIPTION: This snippet shows how to use `container.listen` to observe a provider that might be automatically disposed within a test. This prevents the provider from being destroyed during the test. It allows you to read the current value and ensures the provider remains active during the test execution.  Dependencies include Riverpod.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/essentials/testing.mdx#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\ncontainer.listen(\n  myAutoDisposeProvider.select((s) => s.value),\n  (String? previous, String? next) {\n    // ...\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Extending Ref for Listening and Disposing ChangeNotifier with Riverpod in Dart\nDESCRIPTION: Defines a Dart extension method on Riverpod's Ref to manage ChangeNotifier lifecycle by adding and removing listeners, and disposing of the notifier. This utility helps overcome the limitation where @riverpod code generation does not support ChangeNotifierProvider directly. It ensures that the ChangeNotifier's listeners are notified and properly cleaned up when the provider is disposed.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/from_provider/quickstart.mdx#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\nextension ChangeNotifierWithCodeGenExtension on Ref {\n  T listenAndDisposeChangeNotifier<T extends ChangeNotifier>(T notifier) {\n    notifier.addListener(notifyListeners);\n    onDispose(() => notifier.removeListener(notifyListeners));\n    onDispose(notifier.dispose);\n    return notifier;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing a provider-dependent object with ProviderContainer in Dart\nDESCRIPTION: Demonstrates how to test a class that depends on provider references by creating an isolated ProviderContainer and reading the provider instance directly. Facilitates unit testing without UI components.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#_snippet_9\n\nLANGUAGE: Dart\nCODE:\n```\ntest('fetches catalog', () async {\n  final container = ProviderContainer();\n  addTearDown(container.dispose);\n\n  Repository repository = container.read(repositoryProvider);\n\n  await expectLater(\n    repository.fetchCatalog(),\n    completion(Catalog()),\n  );\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Stream-based Provider for Websockets in Dart\nDESCRIPTION: Demonstrates how to create a Riverpod provider that returns a Stream for websocket connections, which automatically converts the Stream to AsyncValue for convenient state handling.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/essentials/websockets_sync.mdx#_snippet_5\n\nLANGUAGE: Dart\nCODE:\n```\n// Stream-based provider definition\n```\n\n----------------------------------------\n\nTITLE: Using keepAlive with Code Generation in Riverpod\nDESCRIPTION: Example showing how to prevent automatic state disposal with code generation by setting the keepAlive parameter to true.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/auto_dispose.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod(keepAlive: true)\nString example(ExampleRef ref) => 'Hello world';\n\n```\n\n----------------------------------------\n\nTITLE: HTTP Request Cancellation with AutoDispose in Dart\nDESCRIPTION: Complete example showing how to implement HTTP request cancellation using .autoDispose, FutureProvider, and ref.onDispose.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/modifiers/auto_dispose.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nfinal myProvider = FutureProvider.autoDispose((ref) async {\n  final cancelToken = CancelToken();\n  ref.onDispose(() => cancelToken.cancel());\n\n  final response = await dio.get('path', cancelToken: cancelToken);\n  ref.keepAlive();\n  return response;\n});\n```\n\n----------------------------------------\n\nTITLE: Migrating NotifierProvider from Manual to Code-Generation in Dart\nDESCRIPTION: The example illustrates transitioning a NotifierProvider to a code-generated class, reducing boilerplate and improving type safety. It compares the previous explicit provider declaration with the new generated notifier class.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/about_code_generation.mdx#_snippet_7\n\nLANGUAGE: dart\nCODE:\n```\n{trimSnippet(notifierProvider)}\n```\n\n----------------------------------------\n\nTITLE: Migrating from HookWidget to HookConsumerWidget\nDESCRIPTION: This code demonstrates how to migrate from using `HookWidget` and `useProvider` to `HookConsumerWidget` and `ref.watch` in Riverpod. The `useProvider` hook is replaced with `ref.watch` to access provider values.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/migration/0.14.0_to_1.0.0.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nclass Example extends HookWidget {\n  @override\n  Widget build(BuildContext context) {\n    useState(...);\n    int count = useProvider(counterProvider);\n    ...\n  }\n}\n```\n\nLANGUAGE: dart\nCODE:\n```\nclass Example extends HookConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    useState(...);\n    int count = ref.watch(counterProvider);\n    ...\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Canceling HTTP Requests with Auto-Dispose FutureProvider in Dart\nDESCRIPTION: Demonstrates combining `FutureProvider.autoDispose` with `ref.onDispose` to cancel an ongoing operation (like an HTTP request using `dio` and `CancelToken`) when the provider is disposed. It also uses `ref.keepAlive` to retain the state upon successful completion.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/modifiers/auto_dispose.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nfinal myProvider = FutureProvider.autoDispose((ref) async {\n  // An object from package:dio that allows cancelling http requests\n  final cancelToken = CancelToken();\n  // When the provider is destroyed, cancel the http request\n  ref.onDispose(() => cancelToken.cancel());\n\n  // Fetch our data and pass our `cancelToken` for cancellation to work\n  final response = await dio.get('path', cancelToken: cancelToken);\n  // If the request completed successfully, keep the state\n  ref.keepAlive();\n  return response;\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Public Getter Implementation in Dart Notifier\nDESCRIPTION: Example of a public getter that violates the avoid_public_notifier_properties lint rule. The code shows an implementation that should instead expose the value through the state property.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/avoid_public_notifier_properties/avoid_public_notifier_properties_lint.md#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nint get publicGetter => _privateGetter;\n```\n\n----------------------------------------\n\nTITLE: Reacting to State Disposal with ref.onDispose\nDESCRIPTION: Example of using ref.onDispose to properly clean up resources when a provider's state is destroyed, in this case closing a StreamController.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/auto_dispose.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nfinal chatProvider = StreamProvider.autoDispose<Message>((ref) {\n  // Create a StreamController that will be used to send messages\n  final controller = StreamController<Message>();\n\n  // When the provider is disposed, close the StreamController\n  ref.onDispose(() {\n    controller.close();\n  });\n\n  return controller.stream;\n});\n\n```\n\n----------------------------------------\n\nTITLE: Enabling autoDispose in generated providers\nDESCRIPTION: Demonstrates how to activate or deactivate autoDispose in providers by including the autoDispose parameter in the annotation. AutoDispose ensures providers are disposed of automatically when they have no listeners, aligning with Riverpod's memory management model.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/about_code_generation.mdx#_snippet_4\n\nLANGUAGE: Dart\nCODE:\n```\n{trimSnippet(autoDisposeCodeGen)}\n```\n\n----------------------------------------\n\nTITLE: Implementing Immutable State with Freezed and Riverpod Notifier in Dart\nDESCRIPTION: This Dart code snippet illustrates defining an immutable state class (e.g., for settings) using the `freezed` package and managing its state using a Riverpod `Notifier`. It showcases the use of `freezed` annotations to generate immutable classes with `copyWith` methods and demonstrates how a `Notifier` updates state immutably by creating new instances. Dependencies include `freezed_annotation`, `riverpod`, and require code generation using `build_runner`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/why_immutability.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet language=\"dart\" {...whyImmutability}></AutoSnippet>\n```\n\n----------------------------------------\n\nTITLE: Provider Mocking Using Overrides - Dart\nDESCRIPTION: This snippet explains how to mock providers using the `overrides` parameter of `ProviderScope` or `ProviderContainer`. This method allows you to replace a provider's implementation with a mock implementation. It showcases how to mock providers at different levels (unit tests and widget tests).\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/essentials/testing.mdx#_snippet_5\n\nLANGUAGE: Dart\nCODE:\n```\n// 이른 초기화된 provider\n```\n\n----------------------------------------\n\nTITLE: Implementing a Sorted Products Provider in Riverpod\nDESCRIPTION: Creates a Provider that sorts a list of products based on the currently selected sort type. Uses ref.watch to automatically react to changes in the sort type and recompute the sorted list.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/providers/state_provider.mdx#_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nfinal productsProvider = Provider<List<Product>>((ref) {\n  // Get the sort type\n  final sortType = ref.watch(productSortTypeProvider);\n  // Make a copy of the list to avoid modifying the original list\n  final productList = [...products];\n\n  switch (sortType) {\n    case ProductSortType.name:\n      // Sort the copy by name\n      productList.sort((a, b) => a.name.compareTo(b.name));\n    case ProductSortType.price:\n      // Sort the copy by price\n      productList.sort((a, b) => a.price.compareTo(b.price));\n  }\n\n  return productList;\n});\n```\n\n----------------------------------------\n\nTITLE: Obtaining Ref in Notifier-based Providers\nDESCRIPTION: Shows how to access the Ref object in a class-based Notifier provider. The Ref is available as a property of the Notifier class.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/combining_requests.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\nclass Example extends _$Example {\n  @override\n  String build() {\n    // We can use \"ref\" here\n    return 'Hello world';\n  }\n\n  void someMethod() {\n    // We can also use \"ref\" here\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Mocking Providers using Overrides\nDESCRIPTION: This snippet demonstrates how to mock a provider using the `overrides` parameter in either the `ProviderScope` or `ProviderContainer`. This is a core testing technique that allows replacing a provider's implementation with a mock for testing purposes. The `overrides` parameter accepts a list of provider overrides.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/essentials/testing.mdx#_snippet_5\n\nLANGUAGE: Dart\nCODE:\n```\nimport \"package:flutter_riverpod/flutter_riverpod.dart\";\nimport \"package:flutter_test/flutter_test.dart\";\n\nfinal myProvider = Provider((ref) => 42);\n\nvoid main() {\n  test(\"myProvider\", () {\n    final container = ProviderContainer(\n      overrides: [myProvider.overrideWithProvider((_) => const AlwaysAliveProvider(43))],\n    );\n\n    expect(container.read(myProvider), 43);\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Todo List with ChangeNotifierProvider - Dart\nDESCRIPTION: This code snippet demonstrates the implementation of a todo list using ChangeNotifierProvider. It defines a `ChangeNotifier` to manage the todo list. This is an example of how to expose methods such as `addTodo` to modify the list in response to user interactions.  It requires the flutter_riverpod package and is meant to be used in conjunction with the consumer code.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/providers/change_notifier_provider.mdx#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\n// Code for todo list implementation with ChangeNotifierProvider.\n```\n\n----------------------------------------\n\nTITLE: Define Notifier with Code Generation\nDESCRIPTION: This code snippet shows the structure of a notifier when using code generation with Riverpod. The `@riverpod` annotation is required to annotate the class or a global function, while the class extends `_$MyNotifier`.  Within the class, there's a `build` method, and it is responsible for the provider's state modification methods.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/essentials/side_effects.mdx#_snippet_2\n\nLANGUAGE: Dart\nCODE:\n```\n@riverpod\nclass MyNotifier extends _$MyNotifier {\n  @override\n  Result build() {\n    <your logic here>\n  }\n\n  <your methods here>\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Dependent Riverpod FutureProvider using ref.watch (Dart)\nDESCRIPTION: Defines a `FutureProvider` named `weatherProvider` that asynchronously fetches weather data. It uses `ref.watch(cityProvider)` to get the current city value and automatically re-executes when `cityProvider` changes. Depends on an external `fetchWeather` function.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nfinal weatherProvider = FutureProvider((ref) async {\n  // Мы используем `ref.watch`, чтобы следить за другим провайдером.\n  // В `ref.watch` мы передаем провайдер, за которым хотим наблюдать.\n  // В данном случае это cityProvider\n  final city = ref.watch(cityProvider);\n\n  // Теперь мы можем делать что-либо, основываясь на полученном состоянии `cityProvider`\n  return fetchWeather(city: city);\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Full widget test example with Riverpod provider overrides (Flutter)\nDESCRIPTION: A comprehensive example that demonstrates full widget testing with Riverpod showing how to configure ProviderScope with overrides, simulate user interactions, and verify expected UI and state changes. Requires Flutter test package, Riverpod, and mock or test-specific implementations. Inputs include widget tree and overridden providers; outputs include test assertions on UI and data.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/cookbooks/testing.mdx#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nvoid main() {\n  testWidgets('full widget test with overrides', (tester) async {\n    await tester.pumpWidget(\n      ProviderScope(\n        overrides: [\n          repositoryProvider.overrideWithValue(MockRepository()),\n        ],\n        child: MyApp(),\n      ),\n    );\n\n    // Perform interactions and verify results\n  });\n}\n\nclass MockRepository extends Repository {\n  @override\n  Future<String> fetchData() async => 'Mocked Data';\n}\n```\n\n----------------------------------------\n\nTITLE: Consuming Todos StateNotifierProvider in a Flutter UI (Dart)\nDESCRIPTION: This snippet demonstrates how to access and interact with the Todos StateNotifierProvider within a Flutter widget using Riverpod. It shows reading the list of todos, responding to UI events (like button presses to add or toggle todos), and updating the UI accordingly. Dependencies include flutter, flutter_riverpod, and state_notifier packages. Developers must ensure that widgets are wrapped with the necessary Riverpod providers. Input involves user interactions, and output is a dynamically updated UI. The approach ensures that UI stays in sync with source-of-truth state.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/providers/state_notifier_provider.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n// todos_consumer.dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass TodosList extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final todos = ref.watch(todosProvider);\n    return ListView.builder(\n      itemCount: todos.length,\n      itemBuilder: (context, index) {\n        final todo = todos[index];\n        return ListTile(\n          title: Text(todo.description),\n          trailing: Checkbox(\n            value: todo.completed,\n            onChanged: (_) => ref.read(todosProvider.notifier).toggleTodo(index),\n          ),\n        );\n      },\n    );\n  }\n}\n\nclass AddTodoButton extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    return FloatingActionButton(\n      onPressed: () {\n        ref.read(todosProvider.notifier).addTodo('A new todo');\n      },\n      child: Icon(Icons.add),\n    );\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Updating StateProvider State Using the Update Method (More Concise)\nDESCRIPTION: Demonstrates the preferred way to update a `StateProvider`'s state based on its previous value using the `.update` method. This method takes a callback that receives the current state and returns the new state, simplifying the syntax and potentially improving efficiency by accessing the provider only once for the update operation.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/providers/state_provider.mdx#2025-04-23_snippet_7\n\nLANGUAGE: dart\nCODE:\n```\nfinal counterProvider = StateProvider((ref) => 0);\n\nclass MyHomePage extends ConsumerWidget {\n  const MyHomePage({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    return Scaffold(\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {\n          ref.read(counterProvider.notifier).update((count) => count + 1);\n        },\n      ),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Flutter Test with Riverpod Overrides\nDESCRIPTION: A full widget test example demonstrating how to set up a Flutter application with Riverpod, override the repository provider, and test the UI based on the mocked repository response.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/cookbooks/testing.mdx#2025-04-23_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:flutter_test/flutter_test.dart';\n\nclass Repository {\n  Future<List<Todo>> fetchTodos() async {\n    // Simulating network delay\n    await Future.delayed(const Duration(seconds: 1));\n    // Simulating network error\n    throw UnimplementedError();\n  }\n}\n\nclass Todo {\n  const Todo({required this.id, required this.label, this.completed = false});\n\n  final String id;\n  final String label;\n  final bool completed;\n}\n\n// A provider that creates Repository\nfinal repositoryProvider = Provider((ref) => Repository());\n\n// A provider that creates Repository and exposes the list of todos\nfinal todoListProvider = FutureProvider((ref) async {\n  // We obtain the Repository instance\n  final repository = ref.watch(repositoryProvider);\n\n  // Then we use it to fetch the list of todos\n  return repository.fetchTodos();\n});\n\nvoid main() {\n  testWidgets('fetches and renders todos correctly', (tester) async {\n    // A typical test would use a real Repository subclass with faked functionatlity\n    // But for simplicity, we'll just create an object that implements Repository\n    final fakeTodos = [Todo(id: '42', label: 'Hello world')];\n\n    // Creating a fake implementation of Repository that returns fake todos\n    final fakeRepository = _FakeRepository(todos: fakeTodos);\n\n    await tester.pumpWidget(\n      ProviderScope(\n        overrides: [\n          // Override the behavior of repositoryProvider to return\n          // a fake implementation of Repository instead of the real one\n          repositoryProvider.overrideWithValue(fakeRepository),\n        ],\n        child: MaterialApp(\n          home: Scaffold(\n            body: Consumer(builder: (context, watch, _) {\n              final todos = watch(todoListProvider);\n              // The fake repository will cause todoListProvider to emit\n              // AsyncValue.data(fakeTodos)\n              return todos.when(\n                data: (todos) => ListView.builder(\n                  itemCount: todos.length,\n                  itemBuilder: (context, index) => Text(todos[index].label),\n                ),\n                loading: () => const Center(child: CircularProgressIndicator()),\n                error: (err, stack) => Text('Error: $err'),\n              );\n            }),\n          ),\n        ),\n      ),\n    );\n\n    // Initially, the todoListProvider is loading\n    expect(find.byType(CircularProgressIndicator), findsOneWidget);\n\n    // Wait for the todoListProvider to finish loading\n    await tester.pump();\n\n    // todoListProvider has finished loading and the todos are displayed\n    expect(find.text('Hello world'), findsOneWidget);\n  });\n}\n\n// A fake Repository implementation for tests\nclass _FakeRepository implements Repository {\n  _FakeRepository({required this.todos});\n\n  final List<Todo> todos;\n\n  @override\n  Future<List<Todo>> fetchTodos() async {\n    return todos;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a StreamProvider in Riverpod (Dart)\nDESCRIPTION: Shows the basic syntax for defining a `StreamProvider` in Riverpod. This example declares a provider named `userProvider` that is expected to expose a stream of `User` objects. The actual stream creation logic (`...`) is omitted but would typically involve returning a `Stream<User>`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_11\n\nLANGUAGE: dart\nCODE:\n```\nfinal userProvider = StreamProvider<User>(...);\n```\n\n----------------------------------------\n\nTITLE: AsyncNotifier Declaration\nDESCRIPTION: Defining the AsyncNotifier class structure that will replace the ChangeNotifier implementation, showing type definitions and core methods.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/migration/from_change_notifier.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\nclass Todos extends _$Todos {\n  @override\n  FutureOr<List<Todo>> build() {\n    // initialization will be here\n  }\n  \n  // mutations will be here\n}\n```\n\n----------------------------------------\n\nTITLE: Using ref.watch in a Widget's build Method in Dart with Riverpod\nDESCRIPTION: This snippet demonstrates how to use ref.watch within a widget's build method to listen to a provider and rebuild the widget when the provider's state changes. It shows a counter value from a provider.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/de/docusaurus-plugin-content-docs/current/concepts/reading.mdx#2025-04-23_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\n@override\nWidget build(BuildContext context, WidgetRef ref) {\n  final count = ref.watch(counterProvider);\n\n  return Text('$count');\n}\n```\n\n----------------------------------------\n\nTITLE: Consuming a .family Provider with different parameters simultaneously (Dart)\nDESCRIPTION: Demonstrates how a family provider can be passed different arguments at the same time, to generate different values. In this case, translated titles for different locales are retrieved by passing `Locale` objects.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/modifiers/family.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n@override\nWidget build(BuildContext context, WidgetRef ref) {\n  final frenchTitle = ref.watch(titleFamily(const Locale('fr')));\n  final englishTitle = ref.watch(titleFamily(const Locale('en')));\n\n  return Text('fr: $frenchTitle en: $englishTitle');\n}\n```\n\n----------------------------------------\n\nTITLE: Using a Mocked Notifier with Provider Overrides in Dart\nDESCRIPTION: This snippet shows how to override a provider with a mocked Notifier instance in tests and how to interact with the mocked notifier through the container. It demonstrates typical usage patterns including retrieving the mock from the provider container and invoking notifier methods within test cases. This approach facilitates testing notifier-dependent logic with controlled behaviors.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/essentials/testing.mdx#_snippet_9\n\nLANGUAGE: dart\nCODE:\n```\n      // providerをオーバーライドして、モックNotifierを作成します。\n    // 次にContainerを通してモックNotifierを取得します:\n    // 本物のNotifierと同じようにやりとりできます:\n\n```\n\n----------------------------------------\n\nTITLE: Installing Riverpod using YAML\nDESCRIPTION: This snippet defines the `pubspec.yaml` file configurations for integrating Riverpod into a Flutter project that utilizes `flutter_hooks`. It specifies the necessary dependencies, including `flutter_hooks`, `hooks_riverpod`, and the Flutter SDK. The code targets a Flutter project with version constraints.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/getting_started.mdx#_snippet_0\n\nLANGUAGE: YAML\nCODE:\n```\nenvironment:\n  sdk: \">=2.12.0 <4.0.0\"\n  flutter: \">=2.0.0\"\n\ndependencies:\n  flutter:\n    sdk: flutter\n  flutter_hooks:\n  hooks_riverpod: ^1.0.0-dev.11\n```\n\n----------------------------------------\n\nTITLE: Implementing ProviderObserver in Flutter App\nDESCRIPTION: This snippet shows how to use a custom ProviderObserver in a Flutter app by passing it to ProviderScope. This allows for observing provider events throughout the app.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/provider_observer.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nrunApp(\n  ProviderScope(\n    observers: [\n      MyObserver(),\n    ],\n    child: MyApp(),\n  )\n);\n```\n\n----------------------------------------\n\nTITLE: Using Lifecycle Methods in Riverpod Providers\nDESCRIPTION: Demonstrates how to use onCancel and onDispose lifecycle methods in Riverpod providers to track when a provider has no listeners and when it's disposed.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/from_provider/provider_vs_riverpod.mdx#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nref.onCancel((){\n  print(\"我一个监听程序都没有了！\");\n});\nref.onDispose((){\n  print(\"如果我已经被定义为 `.autoDispose`，我将被处置！\");\n});\n```\n\n----------------------------------------\n\nTITLE: Canceling HTTP Requests with ref.onDispose (Dart)\nDESCRIPTION: This snippet combines `autoDispose`, `FutureProvider`, and `ref.onDispose` to cancel HTTP requests when a component is disposed. It uses a `CancelToken` from the `dio` package for cancellation. The `ref.onDispose` is called when the provider is destroyed to cancel the request. This depends on `dio` and a valid path for the HTTP request.  Input is the http request, and the output is the response or a cancelled request.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/es/docusaurus-plugin-content-docs/current/concepts/modifiers/auto_dispose.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nfinal myProvider = FutureProvider.autoDispose((ref) async {\n  // Un objeto de package:dio que permite cancelar solicitudes http\n  final cancelToken = CancelToken();\n  // Cuando se destruye el provider, cancelar la solicitud http\n  ref.onDispose(() => cancelToken.cancel());\n\n  // Obtener nuestros datos y pasar nuestro `cancelToken` para que la cancelación funcione\n  final response = await dio.get('path', cancelToken: cancelToken);\n  // Si la solicitud se completó con éxito, mantenga el estado\n  ref.keepAlive();\n  return response;\n});\n```\n\n----------------------------------------\n\nTITLE: Example ConsumerWidget build - Dart\nDESCRIPTION: This snippet illustrates the changes in the `build` method signature of `ConsumerWidget` and the `builder` method of `Consumer`.  It highlights the change from using `watch` to `ref.watch` within the context of these widgets.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/migration/0.14.0_to_1.0.0.mdx#_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\n  class Example extends ConsumerWidget {\n    @override\n    Widget build(BuildContext context, ScopedReader watch) {\n      int count = watch(counterProvider);\n      ...\n    }\n  }\n\n  Consumer(\n    builder: (context, watch, child) {\n      int count = watch(counterProvider);\n      ...\n    }\n  )\n```\n\nLANGUAGE: dart\nCODE:\n```\n  class Example extends ConsumerWidget {\n    @override\n    Widget build(BuildContext context, WidgetRef ref) {\n      int count = ref.watch(counterProvider);\n      ...\n    }\n  }\n\n  Consumer(\n    builder: (context, ref, child) {\n      int count = ref.watch(counterProvider);\n      ...\n    }\n  )\n```\n\n----------------------------------------\n\nTITLE: Migrating Old Dispose Logic to Riverpod 2.0 Notifier Lifecycle in Dart\nDESCRIPTION: Demonstrates how to migrate from the old lifecycle management using the dispose method in StateNotifier to the new lifecycle handling in Riverpod 2.0's Notifier and AsyncNotifier. It shows using ref.onDispose within the build method to register callbacks before internal state rebuilds. This snippet explains how the new API centralizes lifecycle management to improve developer experience and reduce ambiguity. The snippet requires Dart and Riverpod 2.0.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/migration/from_state_notifier.mdx#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet language=\\\"dart\\\" {...oldLifecycles}></AutoSnippet>\n```\n\n----------------------------------------\n\nTITLE: Example of Riverpod Migration Tool Suggestion\nDESCRIPTION: Diff output showing a suggested change by the Riverpod migration tool, demonstrating the removal of .state when accessing a provider's state.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/migration/0.13.0_to_0.14.0.mdx#2025-04-23_snippet_6\n\nLANGUAGE: diff\nCODE:\n```\nWidget build(BuildContext context, ScopedReader watch) {\n-  MyModel state = watch(provider.state);\n+  MyModel state = watch(provider);\n}\n\nAccept change (y = yes, n = no [default], A = yes to all, q = quit)?\n```\n\n----------------------------------------\n\nTITLE: Combining autoDispose and family Modifiers in a StreamProvider (Dart)\nDESCRIPTION: This snippet demonstrates how to define a parameterized StreamProvider in Riverpod using both autoDispose and family modifiers in Dart. This enables the creation of userProvider instances that are automatically disposed and uniquely keyed by an ID string. The provider function receives both ref and id as arguments. Dependencies would include the User type and any necessary business logic.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/modifiers/auto_dispose.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nfinal userProvider = StreamProvider.autoDispose.family<User, String>((ref, id) {\n\n});\n```\n\n----------------------------------------\n\nTITLE: Testing Riverpod Providers - Widget Test Setup\nDESCRIPTION: This snippet shows how to set up a widget test using `flutter_test` with a `ProviderScope` to enable Riverpod within the widget tree.  This ensures that providers are accessible and function correctly within the widget being tested. It is the necessary for testing widgets that use providers.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/essentials/testing.mdx#_snippet_2\n\nLANGUAGE: Dart\nCODE:\n```\nimport \"package:flutter/material.dart\";\nimport \"package:flutter_riverpod/flutter_riverpod.dart\";\nimport \"package:flutter_test/flutter_test.dart\";\n\nvoid main() {\n  testWidgets(\"myWidget\", (tester) async {\n    await tester.pumpWidget(\n      const ProviderScope(\n        child: MaterialApp(home: MyWidget()),\n      ),\n    );\n\n    // ...\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Replacing ref.dependOn with ref.watch for Streams - Riverpod - Dart\nDESCRIPTION: Migrates deprecated usage of ref.dependOn for streams to the ref.watch API in Riverpod, showing how to access the last value from a StreamProvider. Inputs are provider instances, outputs are results from the watched stream. Requires Riverpod dependency.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/flutter_riverpod/CHANGELOG.md#2025-04-23_snippet_26\n\nLANGUAGE: dart\nCODE:\n```\nfinal streamProvider = StreamProvider<T>(...);\nfinal example = Provider((ref) {\n  Future<T> last = ref.dependOn(streamProvider).last;\n});\n```\n\nLANGUAGE: dart\nCODE:\n```\nfinal streamProvider = StreamProvider<T>(...);\nfinal example = Provider((ref) {\n  Future<T> last = ref.watch(streamProvider.last);\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a basic Provider in Riverpod (Dart)\nDESCRIPTION: Defines a simple Provider that supplies a string value representing a city name. This provider serves as a dependency for other providers requiring city data.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/de/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nfinal cityProvider = Provider((ref) => 'London');\n```\n\n----------------------------------------\n\nTITLE: Example StatelessWidget - Dart\nDESCRIPTION: This snippet showcases the use of `context.read` before the migration and its replacement with `ref.read` after migrating to Riverpod 1.0.0.  It details changes in accessing providers within a `StatelessWidget`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/migration/0.14.0_to_1.0.0.mdx#_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\n  class Example extends StatelessWidget {\n    @override\n    Widget build(BuildContext context) {\n      SomeButton(\n        onPressed: () => context.read(provider.notifier).doSomething(),\n      );\n    }\n  }\n\n```\n\nLANGUAGE: dart\nCODE:\n```\n  class Example extends ConsumerWidget {\n    @override\n    Widget build(BuildContext context, WidgetRef ref) {\n      SomeButton(\n        onPressed: () => ref.read(provider.notifier).doSomething(),\n      );\n    }\n  }\n\n```\n\n----------------------------------------\n\nTITLE: Old syntax for declaring a StateNotifierProvider in Dart\nDESCRIPTION: Creates a provider for MyStateNotifier without specifying the state type explicitly, based on pre-0.14.0 Riverpod syntax.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\nfinal provider = StateNotifierProvider<MyStateNotifier>((ref) {\n  return MyStateNotifier();\n});\n```\n\n----------------------------------------\n\nTITLE: Watching Future from StreamProvider in Dart build method\nDESCRIPTION: This code demonstrates how to watch and obtain a Future that resolves with the latest value from a StreamProvider in a Flutter build method.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/reading.mdx#2025-04-23_snippet_7\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, WidgetRef ref) {\n  Future<User> user = ref.watch(userProvider.future);\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Static Provider Usage\nDESCRIPTION: Demonstrates the recommended way to use providers with statically known references for better lint support.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/do_dont.mdx#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nfinal provider = Provider((ref) => 42);\n\n...\n\n// OK because the provider is known statically\nref.watch(provider);\n```\n\n----------------------------------------\n\nTITLE: Migrating StateNotifierProvider.family to AsyncNotifier with Parameters (Dart)\nDESCRIPTION: Shows how to translate a StateNotifierProvider.family instance to the new AsyncNotifier pattern, simplifying management of families and autoDispose in Riverpod 2.0+. All family parameters are passed directly to the build method, improving type safety and reducing boilerplate. Requires Riverpod 2.0+, and expects migration from StateNotifierProvider's family/autoDispose to AsyncNotifier's equivalents.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/migration/from_state_notifier.mdx#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\n<!-- familyAndDisposeOld.dart content placeholder -->\n```\n\n----------------------------------------\n\nTITLE: Connecting Dropdown to StateProvider in Flutter with Riverpod\nDESCRIPTION: Updates the `SortDropdown` widget to be a `ConsumerWidget`. It uses `ref.watch` to get the current sort type from `sortTypeProvider` and display it in the `DropdownButton`. It also uses `ref.read(sortTypeProvider.notifier).state` within `onChanged` to update the provider's state when a new sort type is selected.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/providers/state_provider.mdx#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nclass SortDropdown extends ConsumerWidget {\n  const SortDropdown({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final sortType = ref.watch(sortTypeProvider);\n    return DropdownButton<SortType>(\n      value: sortType,\n      onChanged: (value) => ref.read(sortTypeProvider.notifier).state = value!,\n      items: [\n        for (final sortType in SortType.values)\n          DropdownMenuItem(\n            value: sortType,\n            child: Text(sortType.name),\n          )\n      ],\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Riverpod Providers and Data Models in Dart\nDESCRIPTION: This snippet defines the data models Todo and Repository as well as the Riverpod providers repositoryProvider and todoListProvider. The repositoryProvider exposes an instance of Repository, and todoListProvider asynchronously fetches a list of todo items using the repository. It also includes a fake repository implementation, FakeRepository, returning predefined todos for testing.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/es/docusaurus-plugin-content-docs/current/cookbooks/testing.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass Repository {\n  Future<List<Todo>> fetchTodos() async {}\n}\n\nclass Todo {\n  Todo({\n    required this.id,\n    required this.label,\n    required this.completed,\n  });\n\n  final String id;\n  final String label;\n  final bool completed;\n}\n\n// Exponemos nuestra instancia de Repository en un provider\nfinal repositoryProvider = Provider((ref) => Repository());\n\n/// La lista de tareas. Aquí, simplemente la estamos obteniendo del servidor usando \n/// [Repository] y no hacemos nada más.\nfinal todoListProvider = FutureProvider((ref) async {\n  // Obtiene la instancia del Repository\n  final repository = ref.read(repositoryProvider);\n\n  // Obtenga las tareas y expóngalos a la interfaz de usuario.\n  return repository.fetchTodos();\n});\n\n/// Una implementación simulada de Repository que devuelve una lista predefinida de tareas\nclass FakeRepository implements Repository {\n  @override\n  Future<List<Todo>> fetchTodos() async {\n    return [\n      Todo(id: '42', label: 'Hello world', completed: false),\n    ];\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Synchronous Repository Provider in Dart\nDESCRIPTION: Demonstrates how to create a provider that synchronously returns a Repository object without using Future. The code shows the basic pattern for synchronous providers in Riverpod.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/essentials/websockets_sync.mdx#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\n// Synchronous provider definition\n```\n\n----------------------------------------\n\nTITLE: Request Cancellation Implementation in Riverpod\nDESCRIPTION: Demonstrates how to implement request cancellation using ref.onDispose when navigating away from a screen. Uses package:http client for network requests.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/case_studies/cancel.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\nFuture<Activity> activity(ActivityRef ref) async {\n  final client = Client();\n  ref.onDispose(() => client.close());\n\n  final response = await client.get(\n    Uri.https('www.boredapi.com', '/api/activity'),\n  );\n  return Activity.fromJson(\n    jsonDecode(response.body) as Map<String, Object?>,\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Provider Change Listening Test\nDESCRIPTION: Demonstrates how to listen to and verify provider state changes in tests.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/testing.mdx#2025-04-23_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\ntest('Counter increments', () {\n  final container = ProviderContainer();\n  addTearDown(container.dispose);\n\n  container.listen(\n    counterProvider,\n    (previous, next) {\n      // We have access to the previous and new value\n      print('Changed from $previous to $next');\n    },\n  );\n});\n```\n\n----------------------------------------\n\nTITLE: Using ref.watch for observing\nDESCRIPTION: This code demonstrates the use of `ref.watch` to listen to a provider and update the UI when the provider's value changes. It combines two other providers (`filterTypeProvider` and `todosProvider`) to create a filtered todo list. This example shows how to make a provider reactive to changes in other providers.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_5\n\nLANGUAGE: Dart\nCODE:\n```\nfinal filteredTodoListProvider = Provider((ref) {\n  final filter = ref.watch(filterTypeProvider);\n  final todos = ref.watch(todosProvider);\n\n  switch (filter) {\n    case Filter.none:\n      return todos;\n    case Filter.completed:\n      return todos.where((todo) => todo.completed).toList();\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Migrating Asynchronous StateNotifier to AsyncNotifier in Flutter Riverpod with Dart\nDESCRIPTION: This snippet illustrates the migration from an asynchronous StateNotifier managing AsyncValue<T> states to the new AsyncNotifier API. In the old pattern, async operations and error handling were done explicitly with AsyncValue.guard and try/catch blocks. The new AsyncNotifier simplifies this by centralizing async initialization logic into the build method without try/catch, returning a Future<T>. AsyncNotifier exposes utilities like future and update for managing async state cleanly. The output is an async state managed uniformly with less boilerplate and improved developer experience.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/migration/from_state_notifier.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n/* Old async StateNotifier pattern */\nclass AsyncCounterNotifier extends StateNotifier<AsyncValue<int>> {\n  AsyncCounterNotifier() : super(const AsyncValue.loading()) {\n    _init();\n  }\n\n  Future<void> _init() async {\n    try {\n      final value = await fetchCounter();\n      state = AsyncValue.data(value);\n    } catch (e, st) {\n      state = AsyncValue.error(e, st);\n    }\n  }\n\n  Future<int> fetchCounter() async {\n    // async fetch logic\n  }\n}\n\nfinal asyncCounterProvider = StateNotifierProvider<AsyncCounterNotifier, AsyncValue<int>>((ref) => AsyncCounterNotifier());\n```\n\nLANGUAGE: dart\nCODE:\n```\n/* New AsyncNotifier API pattern */\nclass AsyncCounterNotifier extends AsyncNotifier<int> {\n  @override\n  Future<int> build() async {\n    return fetchCounter();\n  }\n\n  Future<int> fetchCounter() async {\n    // async fetch logic\n  }\n\n  Future<void> refreshCounter() async {\n    state = const AsyncValue.loading();\n    state = await AsyncValue.guard(() => fetchCounter());\n  }\n}\n\nfinal asyncCounterProvider = AsyncNotifierProvider<AsyncCounterNotifier, int>(AsyncCounterNotifier.new);\n```\n\n----------------------------------------\n\nTITLE: Combining Hooks and Consumer Widget\nDESCRIPTION: This snippet demonstrates how to use both a `HookBuilder` and a `Consumer` widget together within a `StatelessWidget` to combine hook and consumer functionality.  It leverages both the `HookBuilder` and `Consumer` to mix the state management and provider access.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/about_hooks.mdx#_snippet_3\n\nLANGUAGE: Dart\nCODE:\n```\n\n```\n\n----------------------------------------\n\nTITLE: Manually Updating Local Cache in Riverpod (Italian)\nDESCRIPTION: This snippet illustrates manually updating the local cache to mirror the backend's behavior after a POST request. This approach requires understanding the server-side logic and could lead to inconsistencies if the client logic deviates from the server. It avoids extra network requests but increases complexity.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/essentials/side_effects.mdx#_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\nmanualAddTodo\n```\n\n----------------------------------------\n\nTITLE: Defining StateNotifierProvider Pre-0.14.0 (Dart)\nDESCRIPTION: Demonstrates the older syntax for defining a `StateNotifierProvider` and watching both the notifier and its state within a widget's build method, prior to Riverpod version 0.14.0. Requires the `riverpod` package and a `StateNotifier` implementation.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod/CHANGELOG.md#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nclass MyStateNotifier extends StateNotifier<MyModel> {...}\n\nfinal provider = StateNotifierProvider<MyStateNotifier>((ref) => MyStateNotifier());\n\n...\nWidget build(context, watch) {\n  MyStateNotifier notifier = watch(provider);\n  MyModel model = watch(provider.state);\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Accessing Notifier.state Property Outside Its Class in Dart\nDESCRIPTION: Examples of code that violates the Riverpod lint rule 'protected_notifier_properties'. The rule prevents accessing or modifying Notifier.state outside its own class, which breaks encapsulation. The examples show various access patterns including direct assignment, increments, and property access.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/protected_notifier_properties/protected_notifier_properties_lint.md#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n// expect_lint: protected_notifier_properties\nref.read(aProvider.notifier).state = 42;\n\n// expect_lint: protected_notifier_properties\n```\n\nLANGUAGE: dart\nCODE:\n```\n// expect_lint: protected_notifier_properties\nref.read(aProvider.notifier).state++;\n// expect_lint: protected_notifier_properties\nref.read(a2Provider.notifier).state++;\n```\n\nLANGUAGE: dart\nCODE:\n```\nref.read(aProvider.notifier).state++;\n// expect_lint: protected_notifier_properties\nref.read(a2Provider.notifier).state++;\n// expect_lint: protected_notifier_properties\nref.read(a3Provider(42).notifier).state++;\n```\n\nLANGUAGE: dart\nCODE:\n```\nref.read(a2Provider.notifier).state++;\n// expect_lint: protected_notifier_properties\nref.read(a3Provider(42).notifier).state++;\n// expect_lint: protected_notifier_properties\nref.read(a4Provider(42).notifier).state++;\n```\n\nLANGUAGE: dart\nCODE:\n```\nref.read(a3Provider(42).notifier).state++;\n// expect_lint: protected_notifier_properties\nref.read(a4Provider(42).notifier).state++;\n// expect_lint: protected_notifier_properties\nref.read(a5Provider(42).notifier).state = AsyncData(42);\n```\n\nLANGUAGE: dart\nCODE:\n```\nref.read(a4Provider(42).notifier).state++;\n// expect_lint: protected_notifier_properties\nref.read(a5Provider(42).notifier).state = AsyncData(42);\n// expect_lint: protected_notifier_properties\nref.read(a6Provider(42).notifier).state = AsyncData(42);\n```\n\nLANGUAGE: dart\nCODE:\n```\nref.read(a5Provider(42).notifier).state = AsyncData(42);\n// expect_lint: protected_notifier_properties\nref.read(a6Provider(42).notifier).state = AsyncData(42);\n// expect_lint: protected_notifier_properties\nref.read(a7Provider(42).notifier).state = AsyncData(42);\n```\n\nLANGUAGE: dart\nCODE:\n```\nref.read(a6Provider(42).notifier).state = AsyncData(42);\n// expect_lint: protected_notifier_properties\nref.read(a7Provider(42).notifier).state = AsyncData(42);\n// expect_lint: protected_notifier_properties\nref.read(a8Provider(42).notifier).state = AsyncData(42);\n```\n\nLANGUAGE: dart\nCODE:\n```\nref.read(a7Provider(42).notifier).state = AsyncData(42);\n// expect_lint: protected_notifier_properties\nref.read(a8Provider(42).notifier).state = AsyncData(42);\n// expect_lint: protected_notifier_properties\nref.read(a8Provider(42).notifier).state;\n```\n\nLANGUAGE: dart\nCODE:\n```\nref.read(a8Provider(42).notifier).state = AsyncData(42);\n// expect_lint: protected_notifier_properties\nref.read(a8Provider(42).notifier).state;\n\n// expect_lint: protected_notifier_properties\n```\n\nLANGUAGE: dart\nCODE:\n```\n// expect_lint: protected_notifier_properties\nref.read(a8Provider(42).notifier).future;\n// expect_lint: protected_notifier_properties\nref.read(a8Provider(42).notifier).ref;\n```\n\nLANGUAGE: dart\nCODE:\n```\nref.read(a8Provider(42).notifier).future;\n// expect_lint: protected_notifier_properties\nref.read(a8Provider(42).notifier).ref;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom ProviderObserver in Dart\nDESCRIPTION: This snippet demonstrates how to create a custom ProviderObserver class in Dart. It overrides methods to listen to various provider events such as addition, update, disposal, and failure.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/provider_observer.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nclass MyObserver extends ProviderObserver {\n  @override\n  void didAddProvider(ProviderBase provider, Object? value, ProviderContainer container) {\n    print('Provider $provider was added');\n  }\n\n  @override\n  void didUpdateProvider(ProviderBase provider, Object? previousValue, Object? newValue, ProviderContainer container) {\n    print('Provider $provider was updated');\n  }\n\n  @override\n  void didDisposeProvider(ProviderBase provider, ProviderContainer container) {\n    print('Provider $provider was disposed');\n  }\n\n  @override\n  void providerDidFail(ProviderBase provider, Object error, StackTrace stackTrace, ProviderContainer container) {\n    print('Provider $provider threw $error');\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Combining Providers (Stateless) using ref.watch (Riverpod)\nDESCRIPTION: Illustrates the Riverpod equivalent of `ProxyProvider` for creating derived stateless values. A new `Provider` uses `ref.watch` to depend on `userIdNotifierProvider`. The `labelProvider` automatically recalculates when `userIdNotifierProvider` changes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/from_provider/provider_vs_riverpod.mdx#_snippet_12\n\nLANGUAGE: dart\nCODE:\n```\nfinal labelProvider = Provider<String>((ref) {\n  UserIdNotifier userIdNotifier = ref.watch(userIdNotifierProvider);\n  return 'The user ID of the the user is ${userIdNotifier.userId}';\n});\n```\n\n----------------------------------------\n\nTITLE: Using ChangeNotifierProvider with Riverpod (Dart)\nDESCRIPTION: Demonstrates how to integrate ChangeNotifier with Riverpod using ChangeNotifierProvider, a compatibility layer for easing the migration from pkg:Provider.  This allows you to continue using existing ChangeNotifier implementations while adopting Riverpod. It shows how to define a MyNotifier class extending ChangeNotifier and then expose it as a provider using ChangeNotifierProvider.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/from_provider/quickstart.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n// 아래와 같은 코드를 가지고 있다면\nclass MyNotifier extends ChangeNotifier {\n  int state = 0;\n\n  void increment() {\n    state++;\n    notifyListeners();\n  }\n}\n\n// ... 이것만 추가하세요!\nfinal myNotifierProvider = ChangeNotifierProvider<MyNotifier>((ref) {\n  return MyNotifier();\n});\n```\n\n----------------------------------------\n\nTITLE: Manually Invalidating Provider State - Riverpod/Dart\nDESCRIPTION: This snippet demonstrates how to manually force the destruction of a provider's current state using `ref.invalidate`. This can be called from another provider or a widget. If the provider is currently being listened to, a new state will be created; otherwise, the provider will be fully disposed.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/essentials/auto_dispose.mdx#_snippet_3\n\nLANGUAGE: Dart\nCODE:\n```\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal counterProvider = StateProvider((ref) => 0);\n\nclass MyWidget extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // Call ref.invalidate to force the counterProvider to be re-created\n    return ElevatedButton(\n      onPressed: () => ref.invalidate(counterProvider),\n      child: Text('Invalidate counter'),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Providers with Riverpod Package in Dart\nDESCRIPTION: Example showing how to define a provider using Riverpod where providers are global final variables defined outside the widget tree, and require a ProviderScope widget at the application root.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/from_provider/provider_vs_riverpod.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n// Provider는 이제 최상위 변수\nfinal counterProvider = ChangeNotifierProvider<Counter>((ref) => Counter());\n\nvoid main() {\n  runApp(\n    // 이 위젯은 전체 프로젝트에서 Riverpod을 사용할 수 있게 합니다\n    ProviderScope(\n      child: MyApp(),\n    ),\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using ref.listen in a Widget Build Method\nDESCRIPTION: Shows how to use ref.listen in a widget to react to provider changes by executing a function, like showing a snackbar when an error occurs.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/reading.mdx#2025-04-23_snippet_7\n\nLANGUAGE: dart\nCODE:\n```\nclass HomeScreen extends ConsumerWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    ref.listen<int>(counterProvider, (previous, next) {\n      if (next == 5) {\n        showDialog(\n          context: context,\n          builder: (context) {\n            return AlertDialog(\n              title: const Text('Alert'),\n              content: const Text('Counter is 5'),\n              actions: [\n                TextButton(\n                  onPressed: () => Navigator.pop(context),\n                  child: const Text('OK'),\n                ),\n              ],\n            );\n          },\n        );\n      }\n    });\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Counter')),\n      body: Center(\n        child: Text('Value: ${ref.watch(counterProvider)}'),\n      ),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding POST Method to TodoListNotifier in Dart\nDESCRIPTION: This snippet shows how to add an 'addTodo' method to a TodoListNotifier to perform a POST request for adding a new todo item.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/side_effects.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet {...todoListNotifierAddTodo} />\n```\n\n----------------------------------------\n\nTITLE: Esempio di metodo build nel Notifier\nDESCRIPTION: Tutti i Notifiers devono sovrascrivere il metodo `build`, che rappresenta il punto di inserimento della logica di inizializzazione dello stato. Questo metodo non è chiamato direttamente, ma è essenziale per configurare lo stato iniziale del Notifier.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/essentials/side_effects.mdx#_snippet_2\n\nLANGUAGE: Dart\nCODE:\n```\n  @override\n  Result build() {\n    <your logic here>\n  }\n```\n\n----------------------------------------\n\nTITLE: AutoDispose Family Provider for Search\nDESCRIPTION: Example of combining .family with .autoDispose to prevent memory leaks when handling search inputs.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/modifiers/family.mdx#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nfinal characters = FutureProvider.autoDispose.family<List<Character>, String>((ref, filter) async {\n  return fetchCharacters(filter: filter);\n});\n```\n\n----------------------------------------\n\nTITLE: Avoiding unnecessary provider rebuilds by refining dependencies in Riverpod (Dart)\nDESCRIPTION: Shows how to prevent a provider from rebuilding caused by unrelated property changes in a configuration object. Demonstrates creating a dedicated provider for specific data (like `host`) instead of depending on the entire configuration object.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/de/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#_snippet_7\n\nLANGUAGE: dart\nCODE:\n```\nfinal configsProvider = StreamProvider<Configuration>(...);\n\n// Bad approach: listening to entire configuration object\nfinal productsProvider = FutureProvider<List<Product>>((ref) async {\n  final configs = await ref.watch(configsProvider.future);\n  return dio.get('${configs.host}/products');\n});\n\n// Better approach: listen only to relevant property\nfinal _hostProvider = FutureProvider<String>((ref) async {\n  final config = await ref.watch(configsProvider.future);\n  return config.host;\n});\n\nfinal productsProvider = FutureProvider<List<Product>>((ref) async {\n  final host = await ref.watch(_hostProvider.future);\n  return dio.get('$host/products');\n});\n```\n\n----------------------------------------\n\nTITLE: Definizione di Ref in provider funzionali in Dart\nDESCRIPTION: Mostra come ottenere l'oggetto Ref nei provider funzionali di Riverpod in Dart. Questo Ref permette di leggere altri provider e di ascoltarne le variazioni, facilitando la composizione reattiva dei provider.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/essentials/combining_requests.mdx#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\n<AutoSnippet {...functionalRef} />\n```\n\n----------------------------------------\n\nTITLE: Defining a Filter Enum and StateProvider in Dart\nDESCRIPTION: Defines a Dart enum `Filter` with possible values for filtering a list (none, completed, uncompleted). It also defines a Riverpod `StateProvider` named `filterProvider` to hold the currently selected filter value, initialized to `Filter.none`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nenum Filter {\n  none,\n  completed,\n  uncompleted,\n}\n\nfinal filterProvider = StateProvider((ref) => Filter.none);\n```\n\n----------------------------------------\n\nTITLE: Definizione di un Notifier con sintassi manuale in Dart\nDESCRIPTION: Mostra come definire un Notifier estendendo `SomeNotifier<Result>` e utilizzando `final` per la variabile del provider. Include dettagli su come specificare il tipo di provider e i modificatori opzionali come autoDispose e family.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/essentials/side_effects.mdx#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\nfinal name = SomeNotifierProvider.someModifier<MyNotifier, Result>(MyNotifier.new);\n\nclass MyNotifier extends SomeNotifier<Result> {\n  @override\n  Result build() {\n    <your logic here>\n  }\n\n  <your methods here>\n}\n```\n\n----------------------------------------\n\nTITLE: Watching Stream from StreamProvider in Dart build method\nDESCRIPTION: This snippet shows how to watch and obtain the Stream directly from a StreamProvider in a Flutter build method.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/reading.mdx#2025-04-23_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, WidgetRef ref) {\n  Stream<User> user = ref.watch(userProvider.stream);\n}\n```\n\n----------------------------------------\n\nTITLE: Running Riverpod Graph Generator for Mermaid.js Output\nDESCRIPTION: This command runs the Riverpod graph generator tool, analyzing a specified folder and producing output in Mermaid.js markup format. It assumes you are in the riverpod_graph directory.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_graph/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndart run riverpod_graph path/to/folder\n```\n\n----------------------------------------\n\nTITLE: Using StreamNotifier with riverpod_generator in Dart\nDESCRIPTION: Example of how to use the new StreamNotifier class with code generation via riverpod_generator by extending a generated class to build a Stream of a Model.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod/CHANGELOG.md#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\nclass Example extends _$Example {\n  @override\n  Stream<Model> build() {\n    // TODO return some stream\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Analyzing Missing Dependencies in Riverpod Provider Function (Dart)\nDESCRIPTION: This snippet demonstrates a Riverpod provider function with missing dependencies. It calls a function that has dependencies without declaring them in the provider.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/provider_dependencies/missing_dependencies2_lint.md#2025-04-23_snippet_8\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\nint foo(Ref ref) {\n  fn();\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Consuming a StreamProvider in a Flutter Widget using ref.watch\nDESCRIPTION: This Flutter `ConsumerWidget` demonstrates how to consume the `liveStreamChatProvider`. It uses `ref.watch` to listen to the provider's state, which is an `AsyncValue`. The `when` method is used to handle the different states of the stream: displaying the data when available (`data`), showing a loading indicator while waiting (`loading`), and presenting an error message if the stream fails (`error`).\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/providers/stream_provider.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nimport 'live_stream_chat_provider.dart'; // Assuming the provider is in this file\n\nclass LiveStreamChatView extends ConsumerWidget {\n  const LiveStreamChatView({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // Watch the provider to listen to the stream's state.\n    final liveStream = ref.watch(liveStreamChatProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Live Chat Stream')),\n      body: Center(\n        // Use .when to handle the different states of the AsyncValue\n        child: liveStream.when(\n          // Data is available, display it\n          data: (data) => Text('Latest message: $data'),\n          // An error occurred, display the error message\n          error: (error, stackTrace) => Text('Error: $error'),\n          // The stream is loading, show a progress indicator\n          loading: () => const CircularProgressIndicator(),\n        ),\n      ),\n    );\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Initializing ProviderScope in Dart\nDESCRIPTION: 이 코드 스니펫은 애플리케이션의 루트에 `ProviderScope`를 추가하여 전체 애플리케이션에 대해 Riverpod를 활성화하는 방법을 보여줍니다. `ProviderScope`는 다른 모든 위젯 위에 추가해야 하며 `runApp`에 직접 파라미터로 전달됩니다.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/essentials/first_request.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nvoid main() {\n  runApp(\n    // Riverpod을 설치하려면 다른 모든 위젯 위에 이 위젯을 추가해야 합니다.\n    // 이 위젯은 \"MyApp\" 내부가 아니라 \"runApp\"에 직접 파라미터로 추가해야 합니다.\n    ProviderScope(\n      child: MyApp(),\n    ),\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Provider Parameter Equality in Riverpod\nDESCRIPTION: Collection of test cases verifying provider parameter behavior with different reference types including lists, maps, objects and custom classes. The tests demonstrate proper and improper usage of provider parameters with respect to equality comparisons.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/provider_parameters/provider_parameters_lint.md#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n  ref.read(legacy(list));\n  // expect_lint: provider_parameters\n  ref.read(legacy([42]));\n  ref.listen(legacy(42), (prev, next) {});\n  // expect_lint: provider_parameters\n```\n\nLANGUAGE: dart\nCODE:\n```\n  ref.read(legacy(42));\n  // expect_lint: provider_parameters\n  ref.read(legacy([42]));\n  ref.listen(legacy(42), (prev, next) {});\n  // expect_lint: provider_parameters\n```\n\nLANGUAGE: dart\nCODE:\n```\n  ref.watch(legacy(42));\n  // expect_lint: provider_parameters\n  ref.watch(legacy([42]));\n  // expect_lint: provider_parameters\n  ref.watch(legacy({'string': 42}));\n```\n\nLANGUAGE: dart\nCODE:\n```\n  ref.watch(legacy([42]));\n  // expect_lint: provider_parameters\n  ref.watch(legacy({'string': 42}));\n  // expect_lint: provider_parameters\n  ref.watch(legacy({42}));\n```\n\nLANGUAGE: dart\nCODE:\n```\n  ref.watch(legacy({'string': 42}));\n  // expect_lint: provider_parameters\n  ref.watch(legacy({42}));\n  ref.watch(legacy(const [42]));\n  ref.watch(legacy(const {'string': 42}));\n```\n\nLANGUAGE: dart\nCODE:\n```\n  ref.watch(legacy(null));\n  // expect_lint: provider_parameters\n  ref.watch(legacy(Object()));\n  ref.watch(legacy(const Object()));\n  ref.watch(legacy(FreezedExample()));\n```\n\nLANGUAGE: dart\nCODE:\n```\n\n  // expect_lint: provider_parameters\n  ref.watch(provider(() {}));\n  ref.watch(provider(fn));\n\n```\n\n----------------------------------------\n\nTITLE: Sample 'Hello World' Flutter app with Riverpod (Dart code)\nDESCRIPTION: This snippet illustrates creating a simple Flutter 'Hello World' application using Riverpod providers. It involves defining providers, wrapping the app with 'ProviderScope', and utilizing 'ConsumerWidget' to access provider values. Requires dependencies like 'flutter_riverpod'.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/introduction/getting_started.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\n// 예제 'Hello World' Flutter 앱\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal helloProvider = Provider<String>((ref) => \"Hello world\");\n\nvoid main() {\n  runApp(ProviderScope(child: MyApp()));\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: Text('Riverpod Hello World')), \n        body: Center(child: ConsumerWidget()),\n      ),\n    );\n  }\n}\n\nclass ConsumerWidget extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final message = ref.read(helloProvider);\n    return Text(message);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding ProviderScope to Flutter App\nDESCRIPTION: Demonstrates how to add ProviderScope at the root of a Flutter application, which is necessary for providers to work.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/providers.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nvoid main() {\n  runApp(ProviderScope(child: MyApp()));\n}\n```\n\n----------------------------------------\n\nTITLE: Creating \"Hello World\" with hooks_riverpod\nDESCRIPTION: This Dart snippet demonstrates a basic \"Hello World\" implementation using Riverpod within a Flutter application that utilizes `flutter_hooks`. It defines a `helloWorldProvider` to store the string \"Hello world\". The `main` function initializes the application within a `ProviderScope`, and the `MyApp` widget uses `HookConsumerWidget` to access and display the provider's value using the `ref.watch` method. It uses `flutter run` command to execute it. Requires `hooks_riverpod`, `flutter` and `flutter_hooks` dependencies.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/getting_started.mdx#_snippet_3\n\nLANGUAGE: Dart\nCODE:\n```\nimport 'package:flutter/material.dart';\nimport 'package:hooks_riverpod/hooks_riverpod.dart';\nimport 'package:flutter_hooks/flutter_hooks.dart';\n\n// Nous créons un \"provider\", qui va stocker une valeur (ici \"Hello world\").\n// En utilisant un provider, cela permet de mocker/changer la valeur exposée.\nfinal helloWorldProvider = Provider((_) => 'Hello world');\n\nvoid main() {\n  runApp(\n    // Pour que les widgets soient capables de lire des providers, nous\n    // devons encapsuler l'entièreté de notre application dans le\n    // widget \"ProviderScope\".\n    // C'est dans celui-ci que sera stocké l'état de nos providers.\n    ProviderScope(\n      child: MyApp(),\n    ),\n  );\n}\n\n// Note: MyApp est un HookConsumerWidget, exposé par hooks_riverpod.\nclass MyApp extends HookConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // Pour lire note provider, nous pouvons utiliser l'objet \"ref\"\n    // Cet objet est fourni par HookConsumerWidget.\n    final String value = ref.watch(helloWorldProvider);\n\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: Text('Example')),\n        body: Center(\n          child: Text(value),\n        ),\n      ),\n    );\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Optimized Previous Button Logic Using Provider in Riverpod (Dart)\nDESCRIPTION: This code refactors the 'can go to previous page' logic into a dedicated Provider in Riverpod (Dart), improving performance and readability. The Provider exposes a boolean value indicating if the Previous button should be enabled, and the widget only listens to this value, reducing unnecessary rebuilds. Requires Riverpod and the current page index provider, and should be used wherever this logic is shared between widgets or business logic.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/providers/provider.mdx#_snippet_4\n\nLANGUAGE: Dart\nCODE:\n```\nfinal canGoToPreviousPageProvider = Provider<bool>((ref) {\n  final pageIndex = ref.watch(pageIndexProvider);\n  return pageIndex > 0;\n});\n\n@override\nWidget build(BuildContext context, WidgetRef ref) {\n  final canGoToPrevious = ref.watch(canGoToPreviousPageProvider);\n  return ElevatedButton(\n    onPressed: canGoToPrevious ? () => goToPreviousPage() : null,\n    child: Text('Previous'),\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Combining filter and todo list providers in Dart\nDESCRIPTION: An auto-generated snippet demonstrating how to create a provider that combines a filter StateProvider with a todo list provider, enabling UI to listen to filtered todos. The setup automatically updates the list when either source changes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet language=\"dart\" {...filteredTodoListProvider}></AutoSnippet>\n```\n\n----------------------------------------\n\nTITLE: Installazione di Riverpod per Flutter via pubspec.yaml\nDESCRIPTION: Configurazione del file pubspec.yaml per aggiungere Riverpod a un'applicazione Flutter.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/introduction/getting_started.mdx#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nanalyzer:\n  plugins:\n    - custom_lint\n```\n\n----------------------------------------\n\nTITLE: Reading Providers with Consumer (Riverpod)\nDESCRIPTION: This snippet illustrates how to read a provider using the Consumer widget in Riverpod.  Similar to Provider, Consumer allows for targeted rebuilds.  The builder function receives a BuildContext, a WidgetRef (similar to ConsumerWidget), and an optional child widget. The ref.watch(modelProvider) method is used to access the Model.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/from_provider/provider_vs_riverpod.mdx#_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nfinal modelProvider = Provider<Model>(...);\n\nConsumer(\n  builder: (BuildContext context, WidgetRef ref, Widget? child) {\n    Model model = ref.watch(modelProvider);\n\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Provider with Riverpod\nDESCRIPTION: Example of defining a basic `Provider` using the Riverpod package as a global final variable.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/from_provider/provider_vs_riverpod.mdx#_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\nfinal modelProvider = Provider<Model>(...);\n```\n\n----------------------------------------\n\nTITLE: Mocking a Notifier - Dart\nDESCRIPTION: This snippet demonstrates how to create a mock for a `Notifier`. Crucially, the mock must subclass the generated `_$MyNotifier` class, not simply implement it. This is due to limitations in how Riverpod generates the internal classes. Requires Riverpod and Mockito or other mocking libraries.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/essentials/testing.mdx#_snippet_10\n\nLANGUAGE: Dart\nCODE:\n```\nclass MyNotifierMock extends _$MyNotifier {\n  @override\n  MyModel build() {\n    // ...\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Filtering Completed Todos Using Provider (Riverpod, Dart)\nDESCRIPTION: This snippet implements a Provider that derives the list of completed todos from the main todosProvider. It encapsulates synchronous computation (filtering) while leveraging Riverpod’s built-in caching and dependency tracing to avoid redundant work unless the underlying list changes. Dependencies: Riverpod, todosProvider. The provider returns a filtered list containing only completed todos. Input: List<Todo> via ref.watch; Output: List<Todo> with completed=true. Optimized for caching and non-intrusive updates.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/providers/provider.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nfinal completedTodosProvider = Provider<List<Todo>>((ref) {\n  final todos = ref.watch(todosProvider);\n  return todos.where((todo) => todo.completed).toList();\n});\n\n```\n\n----------------------------------------\n\nTITLE: Combining Providers with Riverpod for Stateless Objects in Dart\nDESCRIPTION: Example showing how to combine providers using Riverpod to create a new provider that depends on another provider's value, using ref.watch to automatically update when the dependency changes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/from_provider/provider_vs_riverpod.mdx#_snippet_8\n\nLANGUAGE: dart\nCODE:\n```\nclass UserIdNotifier extends ChangeNotifier {\n  String? userId;\n}\n\n// ...\n\nfinal userIdNotifierProvider = ChangeNotifierProvider<UserIdNotifier>(\n  (ref) => UserIdNotifier(),\n);\n```\n\nLANGUAGE: dart\nCODE:\n```\nfinal labelProvider = Provider<String>((ref) {\n  UserIdNotifier userIdNotifier = ref.watch(userIdNotifierProvider);\n  return 'The user ID of the the user is ${userIdNotifier.userId}';\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Search, Pull-to-Refresh, and Infinite List with Riverpod in Dart\nDESCRIPTION: This code snippet demonstrates how to use Riverpod to implement a search feature with pull-to-refresh and infinite list functionality, while handling error and loading states. It's a simplified version of the Pub.dev client application.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/introduction/why_riverpod.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:pub_api_client/pub_api_client.dart';\n\nfinal pubClient = PubClient();\n\nfinal searchProvider = StateProvider((ref) => '');\n\nfinal searchResultProvider = FutureProvider.autoDispose((ref) async {\n  // Debounce searches\n  await Future.delayed(const Duration(milliseconds: 250));\n  final search = ref.watch(searchProvider);\n  if (search.isEmpty) return PackageSearchResult(packages: []);\n\n  return pubClient.search(search);\n});\n\nfinal packageListingProvider = FutureProvider.autoDispose((ref) async {\n  // Combine search + pagination\n  final search = ref.watch(searchProvider);\n  final page = ref.state;\n\n  final result = await pubClient.listPackages(\n    page: page,\n    // Using `query` makes this both a search and a listing.\n    query: search.isEmpty ? null : search,\n  );\n\n  ref.keepAlive();\n  return result;\n});\n\nclass MyWidget extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final searchResult = ref.watch(searchResultProvider);\n    return searchResult.when(\n      loading: () => const CircularProgressIndicator(),\n      error: (err, stack) => Text('Error: $err'),\n      data: (packages) {\n        return ListView.builder(\n          itemCount: packages.length + 1,\n          itemBuilder: (context, index) {\n            if (index >= packages.length) {\n              // reached the end, load more packages\n              ref.read(packageListingProvider.notifier).state++;\n              return const CircularProgressIndicator();\n            }\n\n            final package = packages[index];\n            return ListTile(title: Text(package.name));\n          },\n        );\n      },\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Updating StateProvider State by Reading Twice (Less Efficient)\nDESCRIPTION: Illustrates a way to update a `StateProvider`'s state based on its previous value. This involves reading the current state using `ref.read`, calculating the new state, and then assigning it back using the `.state` property. This requires accessing the provider twice.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/providers/state_provider.mdx#2025-04-23_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\nfinal counterProvider = StateProvider((ref) => 0);\n\nclass MyHomePage extends ConsumerWidget {\n  const MyHomePage({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    return Scaffold(\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {\n          final count = ref.read(counterProvider);\n          ref.read(counterProvider.notifier).state = count + 1;\n        },\n      ),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Riverpod Providers - Unit Test Setup\nDESCRIPTION: This snippet shows how to set up a basic unit test for a Riverpod provider. It involves importing the necessary dependencies and creating a `ProviderContainer` to interact with providers within the test.  The `ProviderContainer` allows reading and listening to providers, crucial for testing their behavior.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/essentials/testing.mdx#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\nimport \"package:flutter_riverpod/flutter_riverpod.dart\";\nimport \"package:flutter_test/flutter_test.dart\";\n\nvoid main() {\n  test(\"myProvider\", () {\n    final container = ProviderContainer();\n\n    // ...\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating Traditional Riverpod Providers to Code-Generated Variants in Dart\nDESCRIPTION: Presents before-and-after examples for migrating standard Riverpod provider types—such as Provider, NotifierProvider, FutureProvider, StreamProvider, AsyncNotifierProvider, and StreamNotifierProvider—from manual declaration to their code-generated equivalents. Each snippet pairs the original provider declaration with its updated, generator-friendly version, aiding developers in transitioning codebases seamlessly. Dependencies include Riverpod with code generation enabled and understanding of provider lifecycle differences.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/about_code_generation.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n/// Before migration: simple Provider\nfinal provider = Provider<int>((ref) => 42);\n```\n\nLANGUAGE: dart\nCODE:\n```\n/// After migration: code-generated synchronous function provider\n@riverpod\nint syncFn(SyncFnRef ref) {\n  return 42;\n}\n```\n\nLANGUAGE: dart\nCODE:\n```\n/// Before migration: NotifierProvider\nfinal notifierProvider = NotifierProvider<MyNotifier, int>(() => MyNotifier());\n\nclass MyNotifier extends Notifier<int> {\n  @override\n  int build() {\n    return 0;\n  }\n}\n```\n\nLANGUAGE: dart\nCODE:\n```\n/// After migration: code-generated Notifier class\n@riverpod\nclass SyncClass extends _$SyncClass {\n  @override\n  int build() {\n    return 0;\n  }\n}\n```\n\nLANGUAGE: dart\nCODE:\n```\n/// Before migration: FutureProvider\nfinal futureProvider = FutureProvider<int>((ref) async {\n  return await fetchData();\n});\n```\n\nLANGUAGE: dart\nCODE:\n```\n/// After migration: code-generated async function provider\n@riverpod\nFuture<int> asyncFnFuture(AsyncFnFutureRef ref) async {\n  return await fetchData();\n}\n```\n\nLANGUAGE: dart\nCODE:\n```\n/// Before migration: StreamProvider\nfinal streamProvider = StreamProvider<int>((ref) {\n  return streamData();\n});\n```\n\nLANGUAGE: dart\nCODE:\n```\n/// After migration: code-generated async stream function provider\n@riverpod\nStream<int> asyncFnStream(AsyncFnStreamRef ref) {\n  return streamData();\n}\n```\n\nLANGUAGE: dart\nCODE:\n```\n/// Before migration: AsyncNotifierProvider\nfinal asyncNotifierProvider = AsyncNotifierProvider<MyAsyncNotifier, int>(() => MyAsyncNotifier());\n\nclass MyAsyncNotifier extends AsyncNotifier<int> {\n  @override\n  Future<int> build() async {\n    return await fetchData();\n  }\n}\n```\n\nLANGUAGE: dart\nCODE:\n```\n/// After migration: code-generated async notifier class\n@riverpod\nclass AsyncClassFuture extends _$AsyncClassFuture {\n  @override\n  Future<int> build() async {\n    return await fetchData();\n  }\n}\n```\n\nLANGUAGE: dart\nCODE:\n```\n/// Before migration: StreamNotifierProvider\nfinal streamNotifierProvider = StreamNotifierProvider<MyStreamNotifier, int>(() => MyStreamNotifier());\n\nclass MyStreamNotifier extends StreamNotifier<int> {\n  @override\n  Stream<int> build() {\n    return streamData();\n  }\n}\n```\n\nLANGUAGE: dart\nCODE:\n```\n/// After migration: code-generated async stream notifier class\n@riverpod\nclass AsyncClassStream extends _$AsyncClassStream {\n  @override\n  Stream<int> build() {\n    return streamData();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Fine-Tuning Provider Cache with ref.keepAlive\nDESCRIPTION: Example of selectively keeping a provider's state alive based on certain conditions, in this case preserving successful API responses while discarding errors.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/auto_dispose.mdx#2025-04-23_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nfinal myAutoDisposeProvider = FutureProvider.autoDispose((ref) async {\n  try {\n    final result = await apiCall();\n    \n    // Keep the state alive indefinitely if the request succeeded\n    ref.keepAlive();\n    return result;\n  } catch (err) {\n    // The state will be disposed as soon as it's no longer used since\n    // we didn't call ref.keepAlive()\n    throw err;\n  }\n});\n\n```\n\n----------------------------------------\n\nTITLE: Watching AsyncValue from StreamProvider in Dart build method\nDESCRIPTION: This code demonstrates how to watch and handle the AsyncValue state from a StreamProvider in a Flutter build method.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/reading.mdx#2025-04-23_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, WidgetRef ref) {\n  AsyncValue<User> user = ref.watch(userProvider);\n\n  return switch (user) {\n    AsyncData(:final value) => Text(value.name),\n    AsyncError(:final error) => const Text('Oops $error'),\n    _ => const CircularProgressIndicator(),\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Using ref in Provider\nDESCRIPTION: This snippet shows how to obtain a 'ref' object within a provider.  The 'ref' allows access to other providers. It is used to watch a 'repositoryProvider' and then return a `SomeValue` object constructed using data from the repository.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\nfinal provider = Provider((ref) {\n  // utiliser ref pour obtenir d'autres providers\n  final repository = ref.watch(repositoryProvider);\n\n  return SomeValue(repository);\n})\n```\n\n----------------------------------------\n\nTITLE: Flutter Widget Test with ProviderScope and Async Data (Dart)\nDESCRIPTION: This test widget demonstrates overriding the repositoryProvider with a FakeRepository, rendering a widget tree that consumes todoListProvider, and verifying loading and data states including UI updates and item content.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/cookbooks/testing.mdx#_snippet_4\n\nLANGUAGE: Dart\nCODE:\n```\nvoid main() {\n  testWidgets('override repositoryProvider', (tester) async {\n    await tester.pumpWidget(\n      ProviderScope(\n        overrides: [\n          repositoryProvider.overrideWithValue(FakeRepository())\n        ],\n        // Notre application, qui va utiliser todoListProvider pour acchifer une liste de taches.\n        // À potentiellement extraire dans un widget \"MyApp\".\n        child: MaterialApp(\n          home: Scaffold(\n            body: Consumer(builder: (context, ref, _) {\n              final todos = ref.watch(todoListProvider);\n              // La liste de tache est en chargement ou erreur\n              if (todos.asData == null) {\n                return const CircularProgressIndicator();\n              }\n              return ListView(\n                children: [\n                  for (final todo in todos.asData!.value) TodoItem(todo: todo)\n                ],\n              );\n            }),\n          ),\n        ),\n      ),\n    );\n\n    // On verifie l'etat de chargement de la liste\n    expect(find.byType(CircularProgressIndicator), findsOneWidget);\n\n    // Maintenant que la liste des tâches est obtenue, on rafraichit l'UI\n    await tester.pump();\n\n    // L'UI n'affiche plus un indicateur de chargement\n    expect(find.byType(CircularProgressIndicator), findsNothing);\n\n    // L'UI affiche la tache qui à été retournée par FakeRepository\n    expect(tester.widgetList(find.byType(TodoItem)), [\n      isA<TodoItem>()\n          .having((s) => s.todo.id, 'todo.id', '42')\n          .having((s) => s.todo.label, 'todo.label', 'Hello world')\n          .having((s) => s.todo.completed, 'todo.completed', false),\n    ]);\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Simple Provider in Dart (Riverpod)\nDESCRIPTION: Defines a basic provider that supplies a string value representing a city name. It serves as a dependency for other providers and demonstrates the fundamental creation of a provider using Riverpod.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\nfinal cityProvider = Provider((ref) => 'London');\n```\n\n----------------------------------------\n\nTITLE: Testing Counter App with Flutter and Riverpod\nDESCRIPTION: This snippet demonstrates testing a simple counter application implemented with Flutter and Riverpod. It defines a `counterProvider` using `StateProvider` and a `MyApp` widget that increments the counter using an `ElevatedButton`. The tests verify that the UI updates correctly when the button is tapped and that the counter state is not shared between different tests.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/tr/docusaurus-plugin-content-docs/current/cookbooks/testing.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n// Flutter kullanılarak uygulanan ve test edilen bir Sayaç\n\n// Global olarak bir provider ilan ediyoruz ve bunu görmek için iki testte kullanacağız.\n// testler arasında durum başarılı bir şekilde \"0\"a sıfırlanırsa.\nfinal counterProvider = StateProvider((ref) => 0);\n\n// Mevcut durumu ve durumu artırmanıza izin veren bir düğmeyi temsil eder\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Consumer(builder: (context, ref, _) {\n        final counter = ref.watch(counterProvider);\n        return ElevatedButton(\n          onPressed: () => ref.read(counterProvider.notifier).state++,\n          child: Text('${counter.state}'),\n        );\n      }),\n    );\n  }\n}\n\nvoid main() {\n  testWidgets('update the UI when incrementing the state', (tester) async {\n    await tester.pumpWidget(ProviderScope(child: MyApp()));\n\n    // provider'ımızın bildirdiği gibi varsayılan değer `0`dır\n    expect(find.text('0'), findsOneWidget);\n    expect(find.text('1'), findsNothing);\n\n    // Durumu artır ve yeniden oluştur\n    await tester.tap(find.byType(ElevatedButton));\n    await tester.pump();\n\n    // Durum uygun şekilde arttı\n    expect(find.text('1'), findsOneWidget);\n    expect(find.text('0'), findsNothing);\n  });\n\n  testWidgets('the counter state is not shared between tests', (tester) async {\n    await tester.pumpWidget(ProviderScope(child: MyApp()));\n\n    // Durum bir kez daha '0' oldu, sökmeye/kurmaya gerek yok\n    expect(find.text('0'), findsOneWidget);\n    expect(find.text('1'), findsNothing);\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Loading and Error States in Eagerly Initialized Async Providers\nDESCRIPTION: This code shows how to handle loading and error states for asynchronous providers that are eagerly initialized. It displays a loading indicator or error message when appropriate, ensuring a good user experience while the provider data is being fetched.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/eager_initialization.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nclass _EagerInitialization extends ConsumerWidget {\n  const _EagerInitialization({required this.child});\n\n  final Widget child;\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // Eagerly initialize providers by watching them\n    final value = ref.watch(someAsyncProvider);\n\n    // Handle loading and error states\n    return value.when(\n      loading: () => const MaterialApp(\n        home: Scaffold(\n          body: Center(\n            child: CircularProgressIndicator(),\n          ),\n        ),\n      ),\n      error: (error, stackTrace) => MaterialApp(\n        home: Scaffold(\n          body: Center(\n            child: Text('Error: $error'),\n          ),\n        ),\n      ),\n      data: (_) => child,\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying StateProvider State Dart\nDESCRIPTION: Demonstrates the recommended way to modify the state of a StateProvider by reading its notifier and setting the state property. This replaces direct state modification via the deprecated StateProvider.state.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/hooks_riverpod/CHANGELOG.md#_snippet_7\n\nLANGUAGE: Dart\nCODE:\n```\nref.read(stateProvider.notifier).state =\n```\n\n----------------------------------------\n\nTITLE: Connecting StateProvider to TextField via Consumer (Flutter with Riverpod, Dart)\nDESCRIPTION: Showcases how to bind a Riverpod StateProvider to a Flutter TextField using a Consumer widget. This reacts to user input and sets the provider state accordingly so that the search query remains in sync with user typing. Requires flutter_riverpod and Flutter's framework. Key parameter is 'onChanged', which updates the provider's state. The TextField expects user input; output is the updated provider state.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/cookbooks/search_as_we_type.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nConsumer(\n  builder: (context, ref, child) {\n    return TextField(\n      onChanged: (value) => ref.read(searchInputProvider.notifier).state = value,\n    );\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Reading StreamProvider Pre-0.6.0 (Dart)\nDESCRIPTION: Demonstrates the old behavior (before Riverpod 0.6.0) where `ref.read(streamProvider)` directly returned the underlying `Stream<T>`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod/CHANGELOG.md#2025-04-23_snippet_10\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nfinal streamProvider = StreamProvider<T>(...);\nfinal example = Provider((ref) {\n  Stream<T> stream = ref.read(streamProvider);\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Hello World with Flutter Riverpod\nDESCRIPTION: Presents a simple \"Hello world\" example using Flutter Riverpod. It demonstrates how to create a `Provider` and display its value in a `Text` widget within a Flutter application.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/introduction/getting_started.mdx#_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// A [Provider] that returns the current time\nfinal helloWorldProvider = Provider((_) => 'Hello world');\n\nvoid main() {\n  runApp(\n    // Adding [ProviderScope] enables Riverpod for the entire application\n    const ProviderScope(\n      child: MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: HomePage(),\n    );\n  }\n}\n\nclass HomePage extends ConsumerWidget {\n  const HomePage({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final helloWorldValue = ref.watch(helloWorldProvider);\n    return Scaffold(\n      body: Center(\n        child: Text(helloWorldValue),\n      ),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Riverpod CLI Migration Tool via Dart Pub\nDESCRIPTION: Provides the shell command to globally activate the Riverpod CLI migration tool using `dart pub global activate`. This tool assists developers in upgrading their projects from older Riverpod syntax to the 0.14.0 syntax by analyzing source code and suggesting fixes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/tr/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_7\n\nLANGUAGE: sh\nCODE:\n```\ndart pub global activate riverpod_cli\n```\n\n----------------------------------------\n\nTITLE: Obtaining ProviderContainer During Widget Tests in Flutter using Dart\nDESCRIPTION: This example shows how to access the `ProviderContainer` instance from the root widget inside a widget test by using `ProviderScope.containerOf(buildContext)`. This enables direct interaction with providers during widget testing, such as reading or overriding provider values dynamically. It complements widget testing by providing test code access to the Riverpod container managing the application state.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/essentials/testing.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\n\n```\n\n----------------------------------------\n\nTITLE: Scoped Providers Dependencies Example in Dart\nDESCRIPTION: Demonstrates proper scoping of providers with and without dependencies in ProviderScope hierarchy.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint/README.md#2025-04-23_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\n@Riverpod(dependencies: [])\nint scoped(Ref ref) => 0;\n\n@riverpod\nint root(Ref ref) => 0;\n```\n\nLANGUAGE: dart\nCODE:\n```\nvoid main() {\n  runApp(\n    ProviderScope(\n      overrides: [\n        rootProvider.overrideWith(...),\n        scopedProvider.overrideWith(...),\n      ],\n      child: MyApp(),\n    ),\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Filtering Completed Todos using Provider in Riverpod (Dart)\nDESCRIPTION: This code defines a Provider that exposes a filtered list of completed todos by listening to todosProvider, employing ref.watch for reactivity. It demonstrates caching of a filtered result to prevent unnecessary recomputation or UI rebuilds when unrelated changes occur. Requires the previously defined todosProvider and a List<Todo> model with an isCompleted property.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/providers/provider.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nfinal completedTodosProvider = Provider<List<Todo>>((ref) {\n  final todos = ref.watch(todosProvider);\n  return todos.where((todo) => todo.isCompleted).toList();\n});\n```\n\n----------------------------------------\n\nTITLE: Accessing ProviderContainer in Widget Tests\nDESCRIPTION: This code demonstrates how to retrieve a `ProviderContainer` within a widget test, allowing interaction with providers.  `ProviderScope.containerOf(context)` is used to obtain the container, enabling reading, and listening to providers within the widget's context.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/essentials/testing.mdx#_snippet_3\n\nLANGUAGE: Dart\nCODE:\n```\nimport \"package:flutter/material.dart\";\nimport \"package:flutter_riverpod/flutter_riverpod.dart\";\nimport \"package:flutter_test/flutter_test.dart\";\n\nvoid main() {\n  testWidgets(\"myWidget\", (tester) async {\n    await tester.pumpWidget(\n      const ProviderScope(\n        child: MaterialApp(home: MyWidget()),\n      ),\n    );\n\n    final container = ProviderScope.containerOf(tester.element);\n\n    // ...\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing FadeIn with Hooks - Dart\nDESCRIPTION: This snippet presents the equivalent implementation of the fade-in animation using hooks from the `flutter_hooks` package. It utilizes `useAnimationController`, `useEffect`, and `useAnimation` to manage the animation lifecycle and trigger UI updates when the animation's value changes. It manages the `AnimationController` automatically and avoids memory leaks.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/about_hooks.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nclass FadeIn extends HookWidget {\n  const FadeIn({Key? key, required this.child}) : super(key: key);\n\n  final Widget child;\n\n  @override\n  Widget build(BuildContext context) {\n    // Crée un AnimationController. Le contrôleur sera automatiquement libéré \n    // lorsque le widget sera démonté.\n    final animationController = useAnimationController(\n      duration: const Duration(seconds: 2),\n    );\n\n    // useEffect est l'équivalent de initState + didUpdateWidget + dispose.\n    // Le callback passée à useEffect est exécutée la première fois que le hook\n    // est invoqué, puis à chaque fois que la liste passée en second paramètre est modifiée..\n    // Puisque nous passons une liste vide ici, c'est strictement équivalent à `initState`.\n    useEffect(() {\n      // démarre l'animation lorsque le widget est rendu pour la première fois.\n      animationController.forward();\n      // Nous pourrions éventuellement renvoyer une logique de \"dispose\" ici.\n      return null;\n    }, const []);\n\n    // Indique à Flutter de reconstruire ce widget lorsque l'animation se met à jour.\n    // Ceci est équivalent à AnimatedBuilder\n    useAnimation(animationController);\n\n    return Opacity(\n      opacity: animationController.value,\n      child: child,\n    );\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a Todo List StateNotifierProvider in Riverpod (Dart)\nDESCRIPTION: This snippet creates a StateNotifierProvider that manages the state of a list of todos using Riverpod in Dart. The provider encapsulates logic for adding, updating, and removing todo items, serving as the source of truth for the todo list. No special dependencies are required beyond Riverpod and standard Dart collections. Expected input and output types are List<Todo> and StateNotifier, and it is best suited for use as a dependency in other providers or widgets requiring access to the editable todo list state.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/providers/provider.mdx#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal todoListProvider = StateNotifierProvider<TodoList, List<Todo>>((ref) {\n  // Implementation details for TodoList, add, update, remove methods etc.\n  return TodoList();\n});\n```\n\n----------------------------------------\n\nTITLE: Parameterized Provider using Equatable class with .family in Dart\nDESCRIPTION: Provides an example of defining a parameter class implementing Equatable to enable value equality for parameters passed to a family provider. The MyParameter class includes userId and locale fields with overridden props. The provider then uses this parameter type, demonstrating an alternative to Freezed for immutable data structures supporting comparison.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/concepts/modifiers/family.mdx#_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nclass MyParameter extends Equatable  {\n  MyParameter({\n    required this.userId,\n    required this.locale,\n  });\n\n  final int userId;\n  final Locale locale;\n\n  @override\n  List<Object> get props => [userId, locale];\n}\n\nfinal exampleProvider = Provider.family<Something, MyParameter>((ref, myParameter) {\n  print(myParameter.userId);\n  print(myParameter.locale);\n  // Faire quelque chose avec userId/locale.\n});\n\n@override\nWidget build(BuildContext context, WidgetRef ref) {\n  int userId; // Lire le user ID de quelque part\n  final locale = Localizations.localeOf(context);\n\n  final something = ref.watch(\n    exampleProvider(MyParameter(userId: userId, locale: locale)),\n  );\n\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Linting Missing Ref with Named Parameters in Riverpod Functional Provider (Dart)\nDESCRIPTION: This snippet shows a functional provider that has named parameters but is missing the required 'ref' parameter. The linter warns about this issue, reinforcing that the 'ref' parameter is mandatory even when other parameters are present.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/functional_ref/failing_functional_ref_lint.md#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\n// expect_lint: functional_ref\nint noRefButArgs({int a = 42}) {\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Using ref.listen in a ConsumerWidget build method in Dart with Riverpod\nDESCRIPTION: Shows how to implement ref.listen inside a Flutter widget's build method to react to state changes without rebuilding the entire widget. The callback receives both previous and new values.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/tr/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_9\n\nLANGUAGE: dart\nCODE:\n```\nfinal counterProvider = StateNotifierProvider<Counter, int>((ref) => Counter());\n\nclass HomeView extends ConsumerWidget {\n  const HomeView({Key? key}): super(key: key);\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    ref.listen<int>(counterProvider, (int? previousCount, int newCount) {\n      print('The counter changed $newCount');\n    });\n\n    return Container();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Asynchronous StateNotifier in Dart (Old Syntax)\nDESCRIPTION: Example of an asynchronous StateNotifier using the old syntax in Dart. This snippet shows how asynchronous state was handled with StateNotifier.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/migration/from_state_notifier.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nfinal todosProvider = StateNotifierProvider<TodosNotifier, AsyncValue<List<String>>>((ref) {\n  return TodosNotifier();\n});\n\nclass TodosNotifier extends StateNotifier<AsyncValue<List<String>>> {\n  TodosNotifier() : super(const AsyncValue.loading()) {\n    _fetchTodos();\n  }\n\n  Future<void> _fetchTodos() async {\n    state = const AsyncValue.loading();\n    try {\n      await Future.delayed(const Duration(seconds: 1));\n      state = AsyncValue.data(['Buy milk', 'Buy eggs']);\n    } catch (e, stack) {\n      state = AsyncValue.error(e, stack);\n    }\n  }\n\n  Future<void> addTodo(String todo) async {\n    state = const AsyncValue.loading();\n    try {\n      await Future.delayed(const Duration(milliseconds: 500));\n      state = AsyncValue.data([...state.value!, todo]);\n    } catch (e, stack) {\n      state = AsyncValue.error(e, stack);\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ScopedProvider with Null and Unimplemented Handler - Riverpod - Dart\nDESCRIPTION: Shows two equivalent ways to declare a ScopedProvider: passing null as the creation function, or providing a function that throws UnimplementedError. Used to signal intentionally unimplemented or delegated provider values. Requires Riverpod and Dart SDK. The provider is of type int; usage will throw if accessed unless overridden.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/flutter_riverpod/CHANGELOG.md#2025-04-23_snippet_22\n\nLANGUAGE: dart\nCODE:\n```\nfinal example = ScopedProvider<int>(null);\n```\n\nLANGUAGE: dart\nCODE:\n```\nfinal example = ScopedProvider<int>((watch) => throw UnimplementedError(''));\n```\n\n----------------------------------------\n\nTITLE: Example Migration Diff Output (Diff)\nDESCRIPTION: Displays a typical diff produced by the riverpod_cli migration command. Illustrates the exact code change from the pre- to post-0.14.0 state consumption syntax. Not executable, meant for instructional reference.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#2025-04-23_snippet_10\n\nLANGUAGE: diff\nCODE:\n```\nWidget build(BuildContext context, ScopedReader watch) {\n-  MyModel state = watch(provider.state);\n+  MyModel state = watch(provider);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Full Search Functionality with Riverpod and Flutter\nDESCRIPTION: A complete implementation of the search functionality, including state management, API calls, and UI rendering. It uses Riverpod's providers to manage search input and results, and Flutter widgets to display the interface.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/cookbooks/search_as_we_type.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\n// Copyright (c) 2019, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:http/http.dart' as http;\nimport 'dart:convert';\n\nfinal searchFieldProvider = StateProvider<String>((ref) => '');\nfinal questionsProvider = FutureProvider<List>((ref) async {\n  final client = http.Client();\n  ref.onDispose(client.close);\n\n  final search = ref.watch(searchFieldProvider);\n\n  Uri uri;\n\n  if (search.isEmpty) {\n    uri = Uri.parse(\n      'https://api.stackexchange.com/2.3/questions?order=desc&sort=activity&site=stackoverflow',\n    );\n  } else {\n    final encodedQuery = Uri.encodeComponent(search);\n    uri = Uri.parse(\n      'https://api.stackexchange.com/2.3/search?order=desc&sort=activity&intitle=$encodedQuery&site=stackoverflow',\n    );\n  }\n\n  final response = await client.get(uri);\n  final questions = jsonDecode(response.body);\n\n  return questions['items'].map((question) => question['title']).toList();\n});\n\nvoid main() => runApp(const ProviderScope(child: MyApp()));\n\nclass MyApp extends StatelessWidget {\n  const MyApp({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(home: MyHomePage());\n  }\n}\n\nclass MyHomePage extends ConsumerWidget {\n  const MyHomePage({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final questions = ref.watch(questionsProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Questions')),\n      body: Column(\n        children: [\n          TextField(\n            onChanged: (value) =>\n                ref.read(searchFieldProvider.notifier).state = value,\n          ),\n          Expanded(\n            child: switch (questions) {\n              AsyncData(:final value) => ListView.builder(\n                  itemCount: value.length,\n                  itemBuilder: (context, index) {\n                    final question = value[index];\n\n                    return ListTile(\n                      title: Text(\n                        question.toString(),\n                      ),\n                    );\n                  },\n                );,\n              AsyncError(:final error) => Center(child: Text('Error $error')),\n              _ => const Center(child: CircularProgressIndicator()),\n            },\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Full Widget Test Example - Dart\nDESCRIPTION: This is a complete example showcasing a widget test using Riverpod. The example includes the setup with `ProviderScope`, the usage of the `tester` to interact with the widget, and the interaction with providers using `container.read`. Requires Flutter and Riverpod.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/essentials/testing.mdx#_snippet_4\n\nLANGUAGE: Dart\nCODE:\n```\ntestWidgets('...', (tester) async {\n  await tester.pumpWidget(\n    ProviderScope(\n      child: MaterialApp(\n        home: MyWidget(),\n      ),\n    ),\n  );\n\n  final container = ProviderScope.containerOf(context);\n  final value = container.read(myProvider);\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Unit Tests with Riverpod ProviderContainer in Dart\nDESCRIPTION: This snippet demonstrates the setup of unit tests for Riverpod providers using the `ProviderContainer` object. It shows creating a fresh container per test to avoid state sharing, reading provider values via `container.read`, and interacting with providers in an isolated environment without Flutter dependencies. The snippet depends on the `test` package and Riverpod's core APIs and is intended for testing provider logic independently of UI widgets.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/essentials/testing.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n    // このテストのためにProviderContainerを作成します。\n    // テスト間でのProviderContainerの共有はしてはいけません。\n\n```\n\n----------------------------------------\n\nTITLE: Defining a StateNotifier and StateNotifierProvider in Riverpod (Dart)\nDESCRIPTION: This snippet demonstrates defining a `TodosNotifier` class that extends `StateNotifier` to manage an immutable list of `Todo` objects. It includes methods for adding, removing, and toggling todos. A `StateNotifierProvider` named `todosProvider` is then declared to make the `TodosNotifier` accessible throughout the application.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/providers/state_notifier_provider.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n<CodeBlock>{trimSnippet(todos)}</CodeBlock>\n```\n\n----------------------------------------\n\nTITLE: Implementing Dynamic Data Fetching with FutureProvider and ref.watch in Dart\nDESCRIPTION: Shows a `FutureProvider` named `charactersProvider` that fetches characters based on a search query and configuration. It uses `ref.watch` to monitor both `searchQueryProvider` and `searchConfigurationProvider`, automatically re-fetching data when either dependency changes, suitable for implementing live search features.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nfinal searchQueryProvider = StateProvider<String>((ref) => '');\n\nfinal searchConfigurationProvider = Provider<SearchConfiguration>((ref) => ...);\n\nfinal charactersProvider = FutureProvider<List<Character>>((ref) async {\n  // Obtains the search query and the configuration using `watch`.\n  // This will automatically fetch the characters again when the query or configuration changes.\n  final query = ref.watch(searchQueryProvider);\n  final searchConfig = ref.watch(searchConfigurationProvider);\n\n  // Performs the HTTP request\n  return dio.get('http://my_api.dev/characters?q=$query&filter=${searchConfig.filter}');\n});\n```\n\n----------------------------------------\n\nTITLE: Creazione di un provider Future con Riverpod\nDESCRIPTION: Definisce un provider `activityProvider` che gestisce una richiesta di rete asincrona per ottenere un'attività casuale dall'API Bored. Il provider restituisce un Future di tipo `Activity` e permette di beneficiare di caching e gestione dell'errore integrata.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/essentials/first_request.mdx#_snippet_2\n\nLANGUAGE: Dart\nCODE:\n```\nfinal activityProvider = FutureProvider<Activity>((ref) async {\n  final response = await http.get(Uri.parse('https://boredapi.com/api/activity'));\n  if (response.statusCode == 200) {\n    final data = jsonDecode(response.body);\n    return Activity.fromJson(data);\n  } else {\n    throw Exception('Failed to load activity');\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Applying Modifiers (.autoDispose, .family) to Riverpod Providers in Dart\nDESCRIPTION: This code illustrates how to use provider modifiers in Riverpod. Modifiers like `.autoDispose` (destroys state when unused) and `.family` (creates provider with external parameters) are appended to the provider type using a syntax similar to named constructors.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/providers.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nfinal myAutoDisposeProvider = StateProvider.autoDispose<int>((ref) => 0);\nfinal myFamilyProvider = Provider.family<String, int>((ref, id) => '$id');\n```\n\n----------------------------------------\n\nTITLE: Inefficient Riverpod Provider Update due to Watching Full Object (Dart)\nDESCRIPTION: Shows an inefficient pattern where `productsProvider` watches the entire `configProvider`'s state. Any change to the `Configuration` object, even unrelated fields, will cause `productsProvider` to rebuild and re-fetch data unnecessarily. Requires `dio` or similar HTTP client, and `Configuration` and `Product` classes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#2025-04-23_snippet_10\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nfinal configProvider = StreamProvider<Configuration>(...);\n\nfinal productsProvider = FutureProvider<List<Product>>((ref) async {\n  // Любое изменение Configuration заставит productsProvider\n  // повторно осуществить запрос\n  final configs = await ref.watch(configProvider.future);\n\n  return dio.get('${configs.host}/products');\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Detecting Unused Dependencies in Riverpod Provider (Dart)\nDESCRIPTION: This code shows a Riverpod provider with unused dependencies. It includes a dependency that is not a scoped provider and is not used within the provider function.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/provider_dependencies/missing_dependencies2_lint.md#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\n@Riverpod(\n  dependencies: [\n    generatedRoot,\n  ],\n)\nint watchGeneratedRootAndContainsDependency(\n  Ref ref,\n) {\n  // Provider implementation\n}\n```\n\n----------------------------------------\n\nTITLE: Using StateController.update in Dart\nDESCRIPTION: Demonstrates the use of the new StateController.update method, which simplifies updating the state based on its previous value.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/flutter_riverpod/CHANGELOG.md#2025-04-23_snippet_7\n\nLANGUAGE: dart\nCODE:\n```\nfinal provider = StateController((ref) => 0);\n...\nref.read(provider).update((state) => state + 1);\n```\n\n----------------------------------------\n\nTITLE: Using read instead of watch in Dart\nDESCRIPTION: Demonstrates reading a provider without subscribing to its updates using ref.read. Useful for objects like repositories that need to access provider data without triggering rebuilds.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nfinal userTokenProvider = StateProvider<String>((ref) => null);\n\nfinal repositoryProvider = Provider(Repository.new);\n\nclass Repository {\n  Repository(this.ref);\n\n  final Ref ref;\n\n  Future<Catalog> fetchCatalog() async {\n    String token = ref.read(userTokenProvider);\n    final response = await dio.get('/path', queryParameters: {\n      'token': token,\n    });\n    return Catalog.fromJson(response.data);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Widget Test Setup with ProviderScope - Dart\nDESCRIPTION: This snippet shows the basic setup for a widget test when using Riverpod. It highlights that a `ProviderScope` must be added to the root of the widget tree using `tester.pumpWidget` to activate Riverpod within the test environment.  This is analogous to how Riverpod is enabled in a Flutter app.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/essentials/testing.mdx#_snippet_2\n\nLANGUAGE: Dart\nCODE:\n```\n    testWidgets('My widget test', (tester) async {\n      await tester.pumpWidget(\n        ProviderScope(child: MyWidget()),\n      );\n    });\n```\n\n----------------------------------------\n\nTITLE: Declaring StateNotifierProvider with old Dart Riverpod Syntax\nDESCRIPTION: Shows the old syntax for declaring a StateNotifierProvider in Riverpod prior to version 0.14.0. The provider only takes the notifier type as a generic parameter and uses a single closure returning the notifier. This approach lacks explicit state type information in the provider definition, which the newer version addresses.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/tr/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nfinal provider = StateNotifierProvider<MyStateNotifier>((ref) {\n  return MyStateNotifier();\n});\n```\n\n----------------------------------------\n\nTITLE: Basic Todo List Provider Implementation\nDESCRIPTION: A basic provider for fetching a list of todos using a GET request.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/side_effects.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nfinal todoListProvider = AsyncNotifierProvider<TodoList, List<Todo>>(TodoList.new);\n\nclass TodoList extends AsyncNotifier<List<Todo>> {\n  @override\n  Future<List<Todo>> build() async {\n    return http.get('/api/todos').then((value) => value.json());\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating Message Fetcher with FutureProvider.family in Dart\nDESCRIPTION: Example showing how to create a FutureProvider with family modifier to fetch messages by ID from an API.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/modifiers/family.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nfinal messagesFamily = FutureProvider.family<Message, String>((ref, id) async {\n  return dio.get('http://my_api.dev/messages/$id');\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing a StateProvider for Sort Type in Riverpod (Dart)\nDESCRIPTION: This snippet details how to create a StateProvider in Riverpod to store the currently selected sort type for products. It declares the provider at module or global scope, specifying the state type (commonly an enum or string). Requires: Riverpod. There are no required inputs; output is a provider that holds and exposes mutable state. This provider can be watched or updated throughout the widget tree.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/providers/state_provider.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\n/* Example Riverpod StateProvider declaration. See sort_provider.dart for full code. */\n```\n\n----------------------------------------\n\nTITLE: Async StateNotifier Provider with Arrow Syntax\nDESCRIPTION: Shows an async arrow function implementation of an unsupported StateNotifier provider\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/unsupported_provider_value/unsupported_provider_value_lint.md#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\n// expect_lint: unsupported_provider_value\nFuture<MyStateNotifier> stateNotifierAsync(Ref ref) async => MyStateNotifier();\n\n// Regression tests for https://github.com/rrousselGit/riverpod/issues/2302\n```\n\n----------------------------------------\n\nTITLE: Implementing FakeRepository for Testing in Dart\nDESCRIPTION: This snippet implements a FakeRepository class that overrides fetchTodos to return a predefined list of Todo objects, enabling testing of UI and logic independently of real data sources.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/cookbooks/testing.mdx#_snippet_2\n\nLANGUAGE: Dart\nCODE:\n```\nclass FakeRepository implements Repository {\n  @override\n  Future<List<Todo>> fetchTodos() async {\n    return [\n      Todo(id: '42', label: 'Hello world', completed: false),\n    ];\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Invoking POST Method in UI with Consumer Widget in Dart\nDESCRIPTION: This code demonstrates how to call the 'addTodo' method in the UI using a Consumer widget. It uses 'ref.read' for event handlers like 'onPressed'.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/side_effects.mdx#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet raw={consumerAddTodoCall} />\n```\n\n----------------------------------------\n\nTITLE: Using ref.listen in Widget Build Method (Dart)\nDESCRIPTION: Demonstrates how to use ref.listen inside a widget build method to perform side effects when provider state changes. Callback has access to both previous and new state. Requires Riverpod and a relevant provider. Not suitable for asynchronous triggers or widget initialization methods.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_8\n\nLANGUAGE: dart\nCODE:\n```\n// Example: ref.listen in build\nclass MyListenerWidget extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    ref.listen<AsyncValue<int>>(someProvider, (previous, next) {\n      if (next.value == 0) {\n        Navigator.of(context).pop();\n      }\n    });\n    return Container();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Mocking Riverpod Providers using ProviderScope Overrides in Dart\nDESCRIPTION: This snippet shows how to mock a Riverpod provider by overriding it within a `ProviderContainer` or `ProviderScope` using the `overrides` parameter. It demonstrates replacing the provider's default implementation with a custom mock producing controlled values, allowing isolated testing of dependent logic. This requires knowledge of the provider to be mocked and setup of the override list.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/essentials/testing.mdx#_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\n    // ユニットテストでは以前の \"createContainer\" ユーティリティを再利用します。\n      //  モックするproviderのリストを指定することができる:\n        // この場合 \"exampleProvider\"をモック(mock)化しています\n          // この関数はproviderの典型的な初期化関数です。\n          // ここで通常は \"ref.watch\"を呼び出し、初期状態を返します。\n\n          // デフォルトの \"Hello world \"をカスタム値に置き換えてみましょう。\n          // 次に `exampleProvider`とやりとりするとこの値が返されます。\n    // ProviderScopeを使ったウィジェットテストでも同じことができます:\n        // ProviderScopesには、まったく同じ \"overrides \"パラメーターがあります。\n          // 前述と同じです。\n```\n\n----------------------------------------\n\nTITLE: Creating Weather Provider with Dependencies\nDESCRIPTION: Shows how to create a provider that depends on another provider using ref.watch().\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/combining_providers.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nfinal weatherProvider = Provider((ref) {\n  final city = ref.watch(cityProvider);\n  return 'Weather in $city: Cloudy';\n});\n```\n\n----------------------------------------\n\nTITLE: Consuming a Parameterized Provider by Passing the Argument (Dart)\nDESCRIPTION: This snippet shows the correct usage of a .family provider by passing the required argument to messagesFamily. It is a Dart/Flutter widget build function using ref.watch to subscribe to a provider for a specific id. The input is the id to be fetched, and the output is the FutureProvider's result for that particular value.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/modifiers/family.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, WidgetRef ref) {\n  final response = ref.watch(messagesFamily('id'));\n}\n```\n\n----------------------------------------\n\nTITLE: Testing a provider with a reference parameter in Dart\nDESCRIPTION: Shows how to test a provider that passes the ref object to the object being created, by using ProviderContainer to instantiate and evaluate the provider, ensuring proper dependency injection and avoiding rebuilds during tests.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\nfinal repositoryProvider = Provider((ref) => Repository(ref));\n\nclass Repository {\n  Repository(this.ref);\n  final Ref ref;\n}\n```\n\n----------------------------------------\n\nTITLE: Consuming a StateNotifierProvider in a Flutter Widget (Dart)\nDESCRIPTION: This snippet illustrates how to interact with the previously defined `todosProvider` within a Flutter UI using a `ConsumerWidget`. It uses `ref.watch` to listen to changes in the todo list state and rebuild the UI accordingly. It also uses `ref.read(todosProvider.notifier)` to access the `TodosNotifier` instance and call its methods (like `addTodo`) in response to user interactions.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/providers/state_notifier_provider.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n<CodeBlock>{trimSnippet(todosConsumer)}</CodeBlock>\n```\n\n----------------------------------------\n\nTITLE: Defining a ChangeNotifierProvider with Provider\nDESCRIPTION: Demonstrates defining a `ChangeNotifierProvider` using the Provider package. The provider is declared within a `MultiProvider` widget, which is part of the widget tree, typically above `MyApp`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/from_provider/provider_vs_riverpod.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nclass Counter extends ChangeNotifier {\n ...\n}\n\nvoid main() {\n  runApp(\n    MultiProvider(\n      providers: [\n        ChangeNotifierProvider<Counter>(create: (context) => Counter()),\n      ],\n      child: MyApp(),\n    )\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Applying .autoDispose to a StreamProvider in Dart\nDESCRIPTION: Demonstrates the basic syntax for applying the `.autoDispose` modifier to a `StreamProvider`. This ensures the provider's state is automatically disposed of when it's no longer being listened to. Note the generic type parameter `<User>` comes after `autoDispose`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/concepts/modifiers/auto_dispose.mdx#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\nfinal userProvider = StreamProvider.autoDispose<User>((ref) {\n\n});\n```\n\n----------------------------------------\n\nTITLE: Defining a simple autoDispose StreamProvider in Dart\nDESCRIPTION: This snippet demonstrates how to declare a StreamProvider with the '.autoDispose' modifier, enabling automatic disposal of the provider when it's no longer actively used, which helps manage resources efficiently.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/tr/docusaurus-plugin-content-docs/current/concepts/modifiers/auto_dispose.mdx#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\nfinal userProvider = StreamProvider.autoDispose<User>((ref) {\n\n});\n```\n\n----------------------------------------\n\nTITLE: Combining Multiple Provider Modifiers in Dart\nDESCRIPTION: Shows how to use multiple provider modifiers together, combining autoDispose and family on a FutureProvider.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/providers.mdx#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nfinal userProvider = FutureProvider.autoDispose.family<User, int>((ref, userId) async {\n  return fetchUser(userId);\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing NotifierProvider for Todo List State (Riverpod, Dart)\nDESCRIPTION: This snippet defines a NotifierProvider to manage the list of todos within a Riverpod state management setup. It establishes a source of truth for todo data, allowing other providers and widgets to observe or mutate the todo state. Dependencies: Riverpod package. The provider exposes a list of todos, supports add/update/delete operations, and serves as the basis for further computed providers. Input: none; Output: todo list state. This is foundational for subsequent consumers and derived providers.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/providers/provider.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nfinal todosProvider = NotifierProvider<TodosNotifier, List<Todo>>(\n  TodosNotifier.new,\n);\n\n```\n\n----------------------------------------\n\nTITLE: Canceling HTTP Requests with FutureProvider.autoDispose in Dart\nDESCRIPTION: This example combines `FutureProvider.autoDispose` with `ref.onDispose` and `ref.keepAlive` to manage HTTP requests. It uses a `CancelToken` (e.g., from the `dio` package) to cancel the request if the provider is disposed before completion (`ref.onDispose`). If the request succeeds, `ref.keepAlive` preserves the state. Requires a mechanism for cancellable requests like `dio`'s `CancelToken`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/modifiers/auto_dispose.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nfinal myProvider = FutureProvider.autoDispose((ref) async {\n  // An object from package:dio that allows cancelling http requests\n  final cancelToken = CancelToken();\n  // When the provider is destroyed, cancel the http request\n  ref.onDispose(() => cancelToken.cancel());\n\n  // Fetch our data and pass our `cancelToken` for cancellation to work\n  final response = await dio.get('path', cancelToken: cancelToken);\n  // If the request completed successfully, keep the state\n  ref.keepAlive();\n  return response;\n});\n```\n\n----------------------------------------\n\nTITLE: Testing Flutter Applications with Riverpod\nDESCRIPTION: Example showing how Riverpod isolates state between tests in Flutter applications. The test verifies that the counter provider's state is independent across test cases, demonstrating that no global state is shared between tests.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/cookbooks/testing.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n// A Counter example implemented with riverpod\n\nfinal counterProvider = StateProvider((ref) => 0);\n\nvoid main() {\n  testWidgets('update the UI when incrementing the state', (tester) async {\n    await tester.pumpWidget(\n      ProviderScope(\n        child: MyApp(),\n      ),\n    );\n\n    // The default value is `0`, as declared in our provider\n    expect(find.text('0'), findsOneWidget);\n    expect(find.text('1'), findsNothing);\n\n    // Increment the state and re-render\n    await tester.tap(find.byType(FloatingActionButton));\n    await tester.pump();\n\n    // The state is now `1`\n    expect(find.text('0'), findsNothing);\n    expect(find.text('1'), findsOneWidget);\n  });\n\n  testWidgets('counter state is not shared between tests', (tester) async {\n    await tester.pumpWidget(\n      ProviderScope(\n        child: MyApp(),\n      ),\n    );\n\n    // The state is `0` once again, with no tearDown/setUp needed\n    expect(find.text('0'), findsOneWidget);\n    expect(find.text('1'), findsNothing);\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Connecting TextField to StateProvider in Flutter\nDESCRIPTION: This code shows how to connect a TextField widget to the searchInputProvider, updating the provider's state when the text changes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/de/docusaurus-plugin-content-docs/current/cookbooks/search_as_we_type.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nConsumer(\n  builder: (context, ref, child) {\n    return TextField(\n      onChanged: (value) => ref.read(searchInputProvider.notifier).state = value,\n    );\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Using ref.keepAlive to Preserve Provider State Post Completion in Dart\nDESCRIPTION: Demonstrates how to use the ref.keepAlive property available on providers marked with .autoDispose. Setting ref.keepAlive() inside an async provider forces Riverpod to keep the provider's state even after it is no longer listened to. This is useful for situations like HTTP requests where you want to preserve the result and avoid re-fetching if the user returns to the screen. Dependencies include Riverpod, and the request logic is based on an asynchronous FutureProvider.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/bn/docusaurus-plugin-content-docs/current/concepts/modifiers/auto_dispose.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nfinal myProvider = FutureProvider.autoDispose((ref) async {\n  final response = await httpClient.get(...);\n  ref.keepAlive();\n  return response;\n});\n```\n\n----------------------------------------\n\nTITLE: Simplified Notifier Dispose with ref.onDispose in Riverpod 2.0 - Dart\nDESCRIPTION: Illustrates the improved lifecycle method by registering the dispose callback with ref.onDispose inside the notifier's build method, replacing multiple dispersed dispose logic points found in the old API. This snippet is part of the migration to ensure only one location handles dispose events, simplifying understanding and implementation. It requires Dart and Riverpod 2.0.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/migration/from_state_notifier.mdx#_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet language=\\\"dart\\\" {...oldLifecyclesFinal}></AutoSnippet>\n```\n\n----------------------------------------\n\nTITLE: Migrating Family.overrideWithProvider Syntax - Dart\nDESCRIPTION: Details the breaking change requiring `Family.overrideWithProvider` to return a provider instead of the raw value. The override now explicitly defines how to create the provider instance for the given argument.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/hooks_riverpod/CHANGELOG.md#_snippet_16\n\nLANGUAGE: Dart\nCODE:\n```\nfinal family = Provider.family<State, Arg>(...);\n\nfamily.overrideWithProvider(\n  (Arg arg) => Provider<State>((ref) => ...)\n);\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Provider with Riverpod Generator in Dart\nDESCRIPTION: This example demonstrates how to define a basic provider using the @riverpod annotation and how to use it in a Flutter widget.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_generator/README.md#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nimport 'package:riverpod_annotation/riverpod_annotation.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:flutter/material.dart';\n\npart 'main.g.dart';\n\n@riverpod\nString label(Ref ref) => 'Hello world';\n\nvoid main() {\n  runApp(ProviderScope(child: Home()));\n}\n\nclass Home extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    return MaterialApp(\n      home: Scaffold(\n        body: Text(ref.watch(labelProvider)),\n      ),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Listening to Provider Changes Dart\nDESCRIPTION: Illustrates the recommended way to listen to changes in a provider's value using ref.listen(). This replaces the deprecated ref.watch(...).stream.listen() pattern for StreamProviders.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/hooks_riverpod/CHANGELOG.md#_snippet_2\n\nLANGUAGE: Dart\nCODE:\n```\nref.listen(provider, (_, value) {...});\n```\n\n----------------------------------------\n\nTITLE: Adding a Scrollable View for RefreshIndicator in Flutter/Dart\nDESCRIPTION: Modifies the previous widget to wrap the `Card` content within a `ListView`. This provides the necessary scrollable surface required by the `RefreshIndicator` widget, enabling the pull-down gesture for refreshing.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/case_studies/pull_to_refresh.mdx#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nimport 'activity.dart';\nimport 'provider.dart';\n\nclass ActivityCard extends ConsumerWidget {\n  const ActivityCard({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final AsyncValue<Activity> activity = ref.watch(activityProvider);\n\n    // Wrap the Card with a ListView. This is necessary for RefreshIndicator\n    // to work, as it requires a scrollable parent.\n    return ListView(\n      children: [\n        Card(\n          child: Container(\n            padding: const EdgeInsets.all(16),\n            child: Column(\n              children: [\n                Text(\n                  activity.valueOrNull?.activity ?? '',\n                  style: Theme.of(context).textTheme.headlineSmall,\n                ),\n              ],\n            ),\n          ),\n        ),\n      ],\n    );\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: AsyncNotifier Initialization\nDESCRIPTION: Implementation of the build method in AsyncNotifier that replaces the _init method from ChangeNotifier, showing simplified asynchronous state initialization.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/migration/from_change_notifier.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n@override\nFutureOr<List<Todo>> build() async {\n  // No need to set isLoading, hasError, etc.\n  // Just fetch the data and return it\n  return fetchTodos();\n  // If an error occurs, Riverpod will catch it\n  // and expose the error via AsyncValue\n}\n```\n\n----------------------------------------\n\nTITLE: Reading provider value without listening in Riverpod (Dart)\nDESCRIPTION: Illustrates using `ref.read` to access a provider's value without subscribing to updates. Suitable for scenarios like authentication tokens where reactive updates are unnecessary.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/de/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nfinal userTokenProvider = StateProvider<String>((ref) => null);\n\nfinal repositoryProvider = Provider((ref) => Repository(ref.read));\n\nclass Repository {\n  Repository(this.read);\n\n  final Reader read;\n\n  Future<Catalog> fetchCatalog() async {\n    String token = read(userTokenProvider);\n    final response = await dio.get('/path', queryParameters: {\n      'token': token,\n    });\n    return Catalog.fromJson(response.data);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Optimizing Provider Rebuilds using ref.watch and select in Dart\nDESCRIPTION: Presents the preferred method for optimizing provider rebuilds when only a subset of a dependency's state is needed. The `productsProvider` uses `ref.watch` combined with `.select()` to specifically listen only to the `host` property of the `configProvider`'s state. This ensures the provider rebuilds only when the `host` value itself changes, avoiding unnecessary rebuilds triggered by changes to other properties in the `Configuration` object.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#2025-04-23_snippet_9\n\nLANGUAGE: dart\nCODE:\n```\nfinal configProvider = Provider<Configuration>((ref) => Configuration());\n\nfinal productsProvider = Provider((ref) {\n  // We use `select` to listen only to the properties that we care about.\n  final host = ref.watch(configProvider.select((config) => config.host));\n\n  // Performs a network request using the host obtained.\n  return dio.get('$host/products');\n});\n```\n\n----------------------------------------\n\nTITLE: Displaying Product List UI - Dart\nDESCRIPTION: This snippet shows how to display a list of products in the UI, used in conjunction with the product definition. It relies on the product definition. The expected input is a list of product objects and the output is a user interface that renders the data.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/providers/state_provider.mdx#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\n// Code for Product List View (product_list_view.dart)\n```\n\n----------------------------------------\n\nTITLE: Inefficient Provider Rebuild Example (Watching Whole Object) in Dart\nDESCRIPTION: Demonstrates an example to avoid: a `productsProvider` watching an entire `configProvider` object using `ref.watch`. This approach causes the `productsProvider` to rebuild whenever any property within the `Configuration` object changes, even if the `host` property (the only one used) remains the same, leading to potentially unnecessary computations or UI updates.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#2025-04-23_snippet_8\n\nLANGUAGE: dart\nCODE:\n```\nfinal configProvider = Provider<Configuration>((ref) => Configuration());\n\nfinal productsProvider = Provider((ref) {\n  // Using `watch` on the whole `configProvider`\n  final config = ref.watch(configProvider);\n  // Retrieves the host from the configuration.\n  final host = config.host;\n\n  // Performs a network request using the host obtained.\n  return dio.get('$host/products');\n});\n```\n\n----------------------------------------\n\nTITLE: Using ProviderObserver with ProviderContainer in Dart\nDESCRIPTION: Shows how to register a custom ProviderObserver with a ProviderContainer. This approach is useful for non-Flutter applications or for testing scenarios where manual container management is needed.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/essentials/provider_observer.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nfinal container = ProviderContainer(\n  observers: [\n    MyObserver(),\n  ],\n);\n```\n\n----------------------------------------\n\nTITLE: Discouraged Usage of ref.read Inside Riverpod Provider Creation (Dart)\nDESCRIPTION: Demonstrates a discouraged pattern: using `ref.read` directly inside the creation callback of a `Provider`. This bypasses Riverpod's reactive dependency tracking and is generally not recommended; `ref.watch` or optimizations like `select` should be preferred.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#2025-04-23_snippet_8\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nfinal myProvider = Provider((ref) {\n  // Тут не рекомендуется использовать `read`\n  final value = ref.read(anotherProvider);\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Using keepAlive with autoDispose in a FutureProvider (Dart)\nDESCRIPTION: This FutureProvider illustrates how to combine autoDispose with the keepAlive API to conditionally preserve provider state after an HTTP request. The async function makes a request via httpClient.get and then calls ref.keepAlive() to prevent disposal, ensuring state remains available if the request succeeds. Requires the httpClient dependency and a valid request configuration.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/modifiers/auto_dispose.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nfinal myProvider = FutureProvider.autoDispose((ref) async {\n  final response = await httpClient.get(...);\n  ref.keepAlive();\n  return response;\n});\n```\n\n----------------------------------------\n\nTITLE: Updating Local Cache with API Response in Riverpod\nDESCRIPTION: Shows how to update the local cache after a POST request by using the response from the API. This approach directly updates the state with the new data returned from the server.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/essentials/side_effects.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nFuture<void> addTodo(Todo todo) async {\n  // POST request is implemented to return a List<Todo> matching the new application state.\n  final response = await http.post(\n    Uri.https('your-api.com', '/todos'),\n    headers: {'Content-Type': 'application/json'},\n    body: jsonEncode(todo.toJson()),\n  );\n\n  // Decode the API response into a List<Todo>\n  final todos = (jsonDecode(response.body) as List)\n      .map((json) => Todo.fromJson(json))\n      .toList();\n\n  // Update our local cache to match the new state\n  // This will send a notification to all listeners\n  state = AsyncData(todos);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating \"Hello World\" with flutter_riverpod\nDESCRIPTION: This Dart snippet demonstrates a basic \"Hello World\" implementation using Riverpod within a Flutter application. It defines a `helloWorldProvider` to store the string \"Hello world\". The `main` function initializes the application within a `ProviderScope`, and the `MyApp` widget uses `ConsumerWidget` to access and display the provider's value using the `ref.watch` method. It uses `flutter run` command to execute it. Requires `flutter_riverpod` and `flutter` dependencies.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/getting_started.mdx#_snippet_4\n\nLANGUAGE: Dart\nCODE:\n```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Nous créons un \"provider\", qui va stocker une valeur (ici \"Hello world\").\n// En utilisant un provider, cela permet de mocker/changer la valeur exposée.\nfinal helloWorldProvider = Provider((_) => 'Hello world');\n\nvoid main() {\n  runApp(\n    // Pour que les widgets soient capables de lire des providers, nous\n    // devons encapsuler l'entièreté de notre application dans le\n    // widget \"ProviderScope\".\n    // C'est dans celui-ci que sera stocké l'état de nos providers.\n    ProviderScope(\n      child: MyApp(),\n    ),\n  );\n}\n\n// Note: MyApp est un ConsumerWidget, exposé par flutter_riverpod.\nclass MyApp extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // Pour lire note provider, nous pouvons utiliser l'objet \"ref\"\n    // Cet objet est fourni par HookConsumerWidget.\n    final String value = ref.watch(helloWorldProvider);\n\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: Text('Example')),\n        body: Center(\n          child: Text(value),\n        ),\n      ),\n    );\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Using ConsumerStatefulWidget in Flutter with Riverpod\nDESCRIPTION: Example demonstrating how to implement ConsumerStatefulWidget, which combines StatefulWidget with Consumer functionality, allowing direct access to providers through the ref parameter.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/essentials/first_request.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet {...consumerStatefulWidget} />\n```\n\n----------------------------------------\n\nTITLE: Defining a Weather Provider using Watch in Dart\nDESCRIPTION: Defines a Riverpod `FutureProvider` named `weatherProvider` that depends on `cityProvider`. It uses `ref.watch(cityProvider)` to get the current city name and fetches weather data asynchronously. The provider automatically re-runs when the value of `cityProvider` changes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n// The weather depends on the city\nfinal weatherProvider = FutureProvider((ref) async {\n  // We use `ref.watch` to listen to the cityProvider, and obtain the city.\n  final city = ref.watch(cityProvider);\n\n  // We can then use the city to fetch the weather.\n  final weather = await fetchWeather(city: city);\n  return weather;\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing a Riverpod ProviderObserver Logger in Dart\nDESCRIPTION: This Dart code defines a `Logger` class that extends `ProviderObserver`. It overrides the `didUpdateProvider` method to print information about provider updates, including the provider's name, its previous value, and its new value, using `debugPrint`. This is useful for monitoring state changes within a Riverpod application. It depends on the `riverpod` package and `flutter/foundation` for `debugPrint`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/provider_observer.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nimport 'package:flutter/foundation.dart';\nimport 'package:hooks_riverpod/hooks_riverpod.dart';\n\n/// A logger for providers.\n/// It listens to the changes of providers and logs them.\n/// It can be used to debug the state changes of the application.\nclass Logger extends ProviderObserver {\n  @override\n  void didUpdateProvider(\n    ProviderBase<Object?> provider,\n    Object? previousValue,\n    Object? newValue,\n    ProviderContainer container,\n  ) {\n    debugPrint('''\n{\n  \"provider\": \"${provider.name ?? provider.runtimeType}\",\n  \"newValue\": \"$newValue\"\n}''');\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Notifier Lifecycles with Cancellation in Dart\nDESCRIPTION: Example of Notifier lifecycles with proper cancellation using the new syntax in Dart. This snippet shows how to handle cancellation of asynchronous operations in the new Notifier API.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/migration/from_state_notifier.mdx#2025-04-23_snippet_8\n\nLANGUAGE: dart\nCODE:\n```\nfinal myProvider = NotifierProvider<MyNotifier, int>(() {\n  return MyNotifier();\n});\n\nclass MyNotifier extends Notifier<int> {\n  CancelToken? _cancelToken;\n\n  @override\n  int build() {\n    final duration = ref.watch(durationProvider);\n    ref.onDispose(() {\n      _cancelToken?.cancel();\n      print('Notifier disposed');\n    });\n    _startOperation(duration);\n    return 0;\n  }\n\n  Future<void> _startOperation(Duration duration) async {\n    _cancelToken?.cancel();\n    _cancelToken = CancelToken();\n    try {\n      final response = await Dio().get(\n        'https://example.com',\n        cancelToken: _cancelToken,\n      );\n      state = response.data['count'];\n    } catch (e) {\n      if (e is! DioException || e.type != DioExceptionType.cancel) {\n        // Handle error\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Consuming Synchronous Provider Values in Riverpod\nDESCRIPTION: Shows how to consume synchronously provided values without AsyncValue wrapper, including error handling patterns.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/websockets_sync.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, WidgetRef ref) {\n  // The value is accessed directly, without AsyncValue\n  final repository = ref.watch(repositoryProvider);\n  return Text(repository.toString());\n}\n```\n\n----------------------------------------\n\nTITLE: Connecting Dropdown to StateProvider - Dart\nDESCRIPTION: This code connects the dropdown menu to the `StateProvider`. This allows changes in the dropdown to update the state of the provider. It requires the previously defined `sortProvider` and the `dropdown` widget, and updates the UI.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/providers/state_provider.mdx#_snippet_4\n\nLANGUAGE: Dart\nCODE:\n```\n// Code for Connecting Dropdown (connected_dropdown.dart)\n```\n\n----------------------------------------\n\nTITLE: Creating a HookConsumerWidget in Dart for Riverpod and flutter_hooks\nDESCRIPTION: This example shows how to create a HookConsumerWidget, which combines the functionality of HookWidget and ConsumerWidget. It allows the use of both hooks and provider interactions in a single widget.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/de/docusaurus-plugin-content-docs/current/concepts/reading.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nclass HomeView extends HookConsumerWidget {\n  const HomeView({Key? key}): super(key: key);\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final state = useState(0);\n\n    return Container();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Filtering Completed Todos Using Provider in Riverpod (Dart)\nDESCRIPTION: This code defines a Provider responsible for returning a filtered list of completed todos from the main todo list in Riverpod (Dart). By watching todoListProvider, it caches and returns only those todos marked as completed. The Provider recalculates only when the source list changes, optimizing performance. Requires todoListProvider as a dependency, expects a list of Todo items, and outputs a filtered list of completed todos.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/providers/provider.mdx#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\nfinal completedTodosProvider = Provider<List<Todo>>((ref) {\n  final todos = ref.watch(todoListProvider);\n  return todos.where((todo) => todo.isCompleted).toList();\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing a Dropdown Button in Flutter\nDESCRIPTION: Shows the basic structure of a Flutter `DropdownButton` widget to allow users to select a sort type (`SortType` enum: name or price). The `value` and `onChanged` parameters are not yet connected to any state management.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/providers/state_provider.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nenum SortType {\n  name,\n  price,\n}\n\nclass SortDropdown extends StatelessWidget {\n  const SortDropdown({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return DropdownButton<SortType>(\n      value: SortType.name, // TODO connect to provider\n      onChanged: (value) {},\n      items: [\n        for (final sortType in SortType.values)\n          DropdownMenuItem(\n            value: sortType,\n            child: Text(sortType.name),\n          )\n      ],\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Correctly Watching an autoDispose Provider in Dart\nDESCRIPTION: Demonstrates the correct way to fix the previous error by ensuring that any provider watching an `.autoDispose` provider is also marked with `.autoDispose`. This maintains the intended disposal behavior.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/concepts/modifiers/auto_dispose.mdx#_snippet_5\n\nLANGUAGE: Dart\nCODE:\n```\nfinal firstProvider = Provider.autoDispose((ref) => 0);\n\nfinal secondProvider = Provider.autoDispose((ref) {\n  ref.watch(firstProvider);\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing StreamProvider with .autoDispose in Dart\nDESCRIPTION: This snippet demonstrates how to declare a StreamProvider with the .autoDispose modifier in Riverpod to ensure the provider's state is disposed of automatically when no longer listened to. It shows how to apply .autoDispose following the provider type with a generic parameter for the user type. No additional dependencies except Riverpod are required. The code defines userProvider that streams User objects.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/bn/docusaurus-plugin-content-docs/current/concepts/modifiers/auto_dispose.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nfinal userProvider = StreamProvider.autoDispose<User>((ref) {\n\n});\n```\n\n----------------------------------------\n\nTITLE: Avoiding Dynamic Provider References (Anti-pattern)\nDESCRIPTION: This example shows an anti-pattern where provider references are passed dynamically as widget parameters. This prevents static analysis tools from effectively analyzing the code for potential issues.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/essentials/do_dont.mdx#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nclass Example extends ConsumerWidget {\n  Example({required this.provider});\n  final Provider<int> provider;\n\n  @override\n  Widget build(context, ref) {\n    // Sbagliato: perchè l'analisi statica non può sapere di che provider si tratta\n    ref.watch(provider);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating an AutoDispose StreamProvider (Dart)\nDESCRIPTION: This code snippet demonstrates the basic usage of `.autoDispose` with a `StreamProvider`.  It creates a `userProvider` that will automatically dispose of its state when it's no longer being listened to.  No external dependencies are required for this basic usage.  The primary input is the function body within the `StreamProvider`. The output is a stream of `User` objects.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/es/docusaurus-plugin-content-docs/current/concepts/modifiers/auto_dispose.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nfinal userProvider = StreamProvider.autoDispose<User>((ref) {\n\n});\n```\n\n----------------------------------------\n\nTITLE: Fine-Grained Disposal Control with ref.keepAlive - Dart\nDESCRIPTION: Shows how to use `ref.keepAlive` after enabling auto-disposal to have more control over when a provider's state is disposed of. This is useful for keeping the state of successful operations while disposing of failed ones.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/essentials/auto_dispose.mdx#_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\n  // リクエストが成功した後のみ、providerを生かしておく。\n  // リクエストが失敗した（例外を投げた）場合、providerがリッスンされなくなると、stateは破棄される。\n  // `link`を使うことで、自動破棄の動作を元に戻すことができる:\n```\n\n----------------------------------------\n\nTITLE: Analyzing Missing Dependencies in Riverpod Provider (Dart)\nDESCRIPTION: This snippet shows a Riverpod provider with missing dependencies. It uses the @riverpod annotation and watches a provider without declaring it as a dependency.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/provider_dependencies/missing_dependencies2_lint.md#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\nint watchGeneratedScopedButNoDependencies(\n  Ref ref,\n) {\n  return ref.watch(generatedScopedProvider);\n}\n```\n\n----------------------------------------\n\nTITLE: Reading Providers with WidgetRef (Riverpod)\nDESCRIPTION: This snippet demonstrates how to read a provider using Riverpod.  It uses a ConsumerWidget, which provides a WidgetRef to its build method.  The ref.watch(modelProvider) method is then used to access the Model.  The widget rebuilds whenever the modelProvider's value changes. Riverpod does not rely on generics but uses the provider variable.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/from_provider/provider_vs_riverpod.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nfinal modelProvider = Provider<Model>(...);\n\nclass Example extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    Model model = ref.watch(modelProvider);\n\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Riverpod Providers for Repository and Todo List in Dart\nDESCRIPTION: This snippet sets up a Provider to supply a Repository instance and a FutureProvider to asynchronously fetch the list of Todos via the Repository, illustrating dependency injection and asynchronous data handling in Riverpod.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/cookbooks/testing.mdx#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\n// Un provider qui expose une instance de Repository\nfinal repositoryProvider = Provider((ref) => Repository());\n\n/// Une liste de tâches. Ici nous nous contentons de d'obtenir la liste de taches\n/// via [Repository].\nfinal todoListProvider = FutureProvider((ref) async {\n  // Récupère l'instance de Repository\n  final repository = ref.read(repositoryProvider);\n\n  // Requête la liste des tâches\n  return repository.fetchTodos();\n});\n```\n\n----------------------------------------\n\nTITLE: Multiple Dependencies with Trailing Comma\nDESCRIPTION: Test case showing multiple dependencies with trailing comma where one is unused\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/provider_dependencies/unused_dependency_lint.md#2025-04-23_snippet_9\n\nLANGUAGE: dart\nCODE:\n```\n// expect_lint: provider_dependencies\n@Dependencies([\n  dep2,\n  dep,\n])\nvoid secondUnusedWithTrailingComma() {\n  dep2Provider;\n```\n\n----------------------------------------\n\nTITLE: Reading Multiple Providers with Riverpod using Consumer in Dart\nDESCRIPTION: Example showing how to read multiple providers with Riverpod using a single Consumer widget with multiple ref.watch calls, eliminating the need for Consumer2/Consumer3 variants found in the Provider package.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/from_provider/provider_vs_riverpod.mdx#_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\nConsumer(\n  builder: (context, ref, child) {\n    Model1 model = ref.watch(model1Provider);\n    Model2 model = ref.watch(model2Provider);\n    Model3 model = ref.watch(model3Provider);\n    // ...\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Reacting to Provider State Disposal with onDispose - Riverpod/Dart\nDESCRIPTION: This example illustrates using the `ref.onDispose` lifecycle method within a provider. The callback provided to `ref.onDispose` is executed when the provider's state is destroyed, typically used for cleaning up resources like closing streams or canceling timers.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/essentials/auto_dispose.mdx#_snippet_2\n\nLANGUAGE: Dart\nCODE:\n```\nimport 'dart:async';\n\nfinal streamControllerProvider = StreamProvider.autoDispose<int>((ref) {\n  final controller = StreamController<int>();\n\n  // We can register a listener to cleanup resources when the state is destroyed\n  ref.onDispose(() => controller.close());\n\n  // ... rest of the implementation\n  return controller.stream;\n});\n```\n\n----------------------------------------\n\nTITLE: Updating Local Cache after POST\nDESCRIPTION: This snippet illustrates how to update the local cache after a POST request.  It outlines an approach where the server returns the new state and the local cache is directly updated via `state = AsyncData(response)`.  The example details the expected structure, including the POST request, API response decoding, and local cache update.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/essentials/side_effects.mdx#_snippet_6\n\nLANGUAGE: Dart\nCODE:\n```\n    // POST 요청은 새 애플리케이션 상태와 일치하는 List<Todo>를 반환합니다.\n    // API 응답을 디코딩하여 List<Todo>로 변환합니다.\n    // 새 상태와 일치하도록 로컬 캐시를 업데이트합니다.\n    // 이렇게 하면 모든 리스너에게 알림이 전송됩니다.\n```\n\n----------------------------------------\n\nTITLE: Consuming a Provider with Multiple Arguments using Records\nDESCRIPTION: Shows how to consume a provider that accepts multiple arguments, which are encapsulated in a Dart record. The code passes the record directly within the `watch` call. As records inherently implement `==`, this direct instantiation is valid and ensures proper caching behavior within the Riverpod system.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/essentials/passing_args.mdx#_snippet_5\n\nLANGUAGE: Dart\nCODE:\n```\n      // 레코드를 사용하여 매개 변수를 전달할 수 있습니다.\n      // 레코드가 ==를 오버라이드하므로 watch 호출에서 직접 레코드를 생성해도 괜찮습니다.\n```\n\n----------------------------------------\n\nTITLE: Example: Flutter + hooks_riverpod 'Hello World' Application\nDESCRIPTION: Defines a provider that supplies a string value ('Hello world') and a widget tree that consumes and displays this value using hooks_riverpod in Flutter. Demonstrates wrapping the app in ProviderScope and utilizing HookConsumerWidget to access provider data.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/es/docusaurus-plugin-content-docs/current/getting_started.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nimport 'package:flutter/material.dart';\nimport 'package:hooks_riverpod/hooks_riverpod.dart';\n\n// Creates a provider that supplies 'Hello world'.\nfinal helloWorldProvider = Provider((_) => 'Hello world');\n\nvoid main() {\n  runApp(\n    // Wraps entire app in ProviderScope to enable provider lifecycle management.\n    ProviderScope(\n      child: MyApp(),\n    ),\n  );\n}\n\n// Main app widget extending HookConsumerWidget to access providers.\nclass MyApp extends HookConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final String value = ref.watch(helloWorldProvider);\n\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: Text('Example')),\n        body: Center(\n          child: Text(value),\n        ),\n      ),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: StateNotifierProvider Definition (New Syntax) - Dart\nDESCRIPTION: This snippet demonstrates the updated syntax for defining a StateNotifierProvider in Riverpod 0.14.0 and later.  It now requires an additional generic type parameter to explicitly specify the state type of the StateNotifier, resulting in `StateNotifierProvider<MyStateNotifier, MyModel>`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nfinal provider = StateNotifierProvider<MyStateNotifier, MyModel>((ref) {\n  return MyStateNotifier();\n});\n```\n\n----------------------------------------\n\nTITLE: Consuming StateNotifierProvider in UI (Dart)\nDESCRIPTION: This Dart code demonstrates how to consume the `todosProvider` using `ConsumerWidget` in a Flutter UI. It retrieves the list of todos from the provider and displays them. It also shows how to interact with the `TodosNotifier` to add new todos by accessing the notifier using `ref.read(todosProvider.notifier)`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/bn/docusaurus-plugin-content-docs/current/providers/state_notifier_provider.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_hooks/flutter_hooks.dart';\nimport 'package:hooks_riverpod/hooks_riverpod.dart';\n\nimport 'todos.dart';\n\nclass TodoItem extends HookConsumerWidget {\n  const TodoItem({Key? key, required this.todo}) : super(key: key);\n\n  final Todo todo;\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    return Text(todo.description);\n  }\n}\n\nclass TodosConsumer extends HookConsumerWidget {\n  const TodosConsumer({Key? key}) : super(key: key);\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final todos = ref.watch(todosProvider);\n\n    return Column(\n      children: [\n        ElevatedButton(\n          onPressed: () {\n            ref.read(todosProvider.notifier).addTodo('New todo');\n          },\n          child: const Text('Add todo'),\n        ),\n        for (final todo in todos) TodoItem(todo: todo),\n      ],\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: 특정 시간 동안 상태 유지하기 (Timer + keepAlive 확장) - Dart\nDESCRIPTION: ref.keepAlive와 Timer를 조합하여, provider 상태를 일정 시간 동안 유지하는 확장 메서드 구현 예제입니다. 이 패턴은 비동기 요청 후 상태 유지에 유용하며, 필요 시 타이머 취소와 재설정을 통한 제어도 가능합니다. dependencies: Dart, Timer.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/essentials/auto_dispose.mdx#_snippet_5\n\nLANGUAGE: Dart\nCODE:\n```\n```dart\n// [duration] 동안 provider 상태를 유지하는 확장 메서드\nextension CacheForExtension on Ref {\n  void cacheFor(Duration duration, {VoidCallback? onDispose}) {\n    this.keepAlive();\n    Timer(duration, () {\n      // 기간 종료 후 자동 폐기 가능\n      if (onDispose != null) onDispose();\n    });\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Using Static Provider References Correctly\nDESCRIPTION: This snippet demonstrates the correct way to use providers with ref.watch. Provider references should be statically known to enable effective static analysis and linting with riverpod_lint.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/essentials/do_dont.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nfinal provider = Provider((ref) => 42);\n\n...\n\n// OK perchè il provider è conosciuto in modo statico\nref.watch(provider);\n```\n\n----------------------------------------\n\nTITLE: Reading Providers with Riverpod using Consumer\nDESCRIPTION: Equivalent example showing how to read a Model provider using the Consumer widget in Riverpod.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/riverpod_for_provider_users.mdx#_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nfinal modelProvider = Provider<Model>(...);\n\nConsumer(\n  builder: (BuildContext context, WidgetRef ref, Widget? child) {\n    Model model = ref.watch(modelProvider);\n\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Selecting Asynchronous Properties with 'selectAsync' in Riverpod\nDESCRIPTION: This snippet demonstrates how to use 'selectAsync' to extract a specific property from an asynchronous data stream in Riverpod. It allows consumers to only rebuild when the selected asynchronous property changes, optimizing performance.  It shows that using `ref.watch(anotherProvider.future)` will be replaced.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/advanced/select.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n  // user를 사용할 수 있을 때까지 기다렸다가 \"firstName\" 속성만 수신합니다.\n  // TODO 다른 항목을 가져오기위해 \"firstName\"을 사용합니다.\n```\n\n----------------------------------------\n\nTITLE: Testing a provider that uses ref.read parameter (Dart)\nDESCRIPTION: Provides an example of testing a provider that supplies a repository object which uses `ref.read`. Uses `ProviderContainer` to instantiate and test the object without widget dependencies.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/de/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\nfinal repositoryProvider = Provider((ref) => Repository(ref.read));\n\ntest('fetches catalog', () async {\n  final container = ProviderContainer();\n  addTearDown(container.dispose);\n\n  Repository repository = container.read(repositoryProvider);\n\n  await expectLater(\n    repository.fetchCatalog(),\n    completion(Catalog()),\n  );\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling riverpod_lint in analysis_options.yaml\nDESCRIPTION: Illustrates how to enable `riverpod_lint` by configuring the `analysis_options.yaml` file. This involves adding `custom_lint` to the analyzer plugins to enable linting rules provided by Riverpod.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/introduction/getting_started.mdx#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\n{`analyzer:\n  plugins:\n    - custom_lint`}\n```\n\n----------------------------------------\n\nTITLE: Overriding RepositoryProvider in Flutter Tests\nDESCRIPTION: This snippet shows how to override the `repositoryProvider` in a Flutter widget test using `ProviderScope`. The `overrideWithValue` method is used to replace the default `Repository` with a `FakeRepository`, allowing the test to control the data returned by the repository and avoid making real HTTP requests. The `todoListProvider` automatically uses the overridden `repositoryProvider`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/tr/docusaurus-plugin-content-docs/current/cookbooks/testing.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\ntestWidgets('override repositoryProvider', (tester) async {\n  await tester.pumpWidget(\n    ProviderScope(\n      overrides: [\n        // Geri dönmek için repositoryProvider'ın davranışını geçersiz kılın\n        // Repository yerine FakeRepository.\n        repositoryProvider.overrideWithValue(FakeRepository())\n        // `todoListProvider`ı geçersiz kılmamıza gerek yok,\n        // geçersiz kılınan repositoryProvider'ı otomatik olarak kullanacak\n      ],\n      child: MyApp(),\n    ),\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Combining Stateful Providers in Riverpod Package (Dart)\nDESCRIPTION: This snippet shows how to combine stateful providers in the Riverpod package, creating a UserNotifier based on UserIdNotifier using ref.listen.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/from_provider/provider_vs_riverpod.mdx#2025-04-23_snippet_9\n\nLANGUAGE: dart\nCODE:\n```\nclass UserIdNotifier extends ChangeNotifier {\n  String? userId;\n}\n\n// ...\n\nfinal userIdNotifierProvider = ChangeNotifierProvider<UserIdNotifier>(\n  (ref) => UserIdNotifier(),\n),\n\n// ...\n\nclass UserNotifier extends ChangeNotifier {\n  String? _userId;\n\n  void setUserId(String? userId) {\n    if (userId != _userId) {\n      print('The user ID changed from $_userId to $userId');\n      _userId = userId;\n    }\n  }\n}\n\n// ...\n\nfinal userNotifierProvider = ChangeNotifierProvider<UserNotifier>((ref) {\n  final userNotifier = UserNotifier();\n  ref.listen<UserIdNotifier>(\n    userIdNotifierProvider,\n    (previous, next) {\n      if (previous?.userId != next.userId) {\n        userNotifier.setUserId(next.userId);\n      }\n    },\n  );\n\n  return userNotifier;\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing UserIdNotifier with ChangeNotifier in Provider Package\nDESCRIPTION: Creates a basic ChangeNotifier implementation that stores a userId. This example shows how stateful objects are defined in the Provider package.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/from_provider/provider_vs_riverpod.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nclass UserIdNotifier extends ChangeNotifier {\n  String? userId;\n}\n\n// ...\n\nChangeNotifierProvider<UserIdNotifier>(create: (context) => UserIdNotifier()),\n```\n\n----------------------------------------\n\nTITLE: Migrating from Computed to Provider using Dart\nDESCRIPTION: Demonstrates how to migrate from the deprecated Computed syntax to the unified Provider approach in Riverpod 0.6.0. The before code uses Computed with a watch function, while the after code uses Provider with ref.watch. No external dependencies required except Riverpod. Both code snippets receive a provider, watch its value, and output the result.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/hooks_riverpod/CHANGELOG.md#_snippet_21\n\nLANGUAGE: dart\nCODE:\n```\nfinal provider = Provider(...);\nfinal example = Computed((watch) {\n  final value = watch(provider);\n  return value;\n});\n```\n\nLANGUAGE: dart\nCODE:\n```\nfinal provider = Provider(...);\nfinal example = Provider((ref) {\n  final value = ref.watch(provider);\n  return value;\n});\n```\n\n----------------------------------------\n\nTITLE: Using ref.read to retrieve provider state once in Dart Riverpod\nDESCRIPTION: This snippet illustrates how to use ref.read to obtain the current state or notifier of a provider without establishing a subscription. It is typically used inside event handlers like button onPressed callbacks. It is recommended to avoid using ref.read within build methods to prevent stale data and unintended behavior.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/es/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\nfinal counterProvider = StateNotifierProvider<Counter, int>((ref) => Counter());\n\nclass HomeView extends ConsumerWidget {\n  const HomeView({Key? key}): super(key: key);\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    return Scaffold(\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {\n          // Call the increment method of the Counter class.\n          ref.read(counterProvider.notifier).increment();\n        },\n      ),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Listening to Streams with Riverpod\nDESCRIPTION: Explains how to interact with streams, like WebSocket data sources, using Riverpod. Details how streams are naturally supported and converted into AsyncValue for easier state handling in UI components.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/essentials/websockets_sync.mdx#_snippet_2\n\nLANGUAGE: Dart\nCODE:\n```\n<AutoSnippet \n  {...streamProvider} \n  translations={{\n    provider: \"  // 1초마다 0에서 41 사이의 숫자를 산출합니다.\\n  // 이것은 Firestore나 GraphQL 또는 다른 것의 스트림으로 대체할 수 있습니다.\",\n    watch: \"    // 스트림을 수신하고 AsyncValue로 변환합니다.\",\n    consumer: \"    // 로딩/오류 상태를 처리하고 데이터를 표시하기 위해 AsyncValue를 사용할 수 있습니다.\",\n  }}\n/>\n```\n\n----------------------------------------\n\nTITLE: Defining Riverpod Provider with Arguments (Family Modifier)\nDESCRIPTION: This snippet demonstrates how to update a Riverpod provider to accept a String argument for the type of activity using the family modifier. It includes auto-dispose for memory management.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/passing_args.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nfinal activityProvider = FutureProvider.autoDispose.family<Activity, String>((ref, type) async {\n  final activity = await http.get(Uri.https(\n    'www.boredapi.com',\n    '/api/activity',\n    {'type': type},\n  ));\n\n  return Activity.fromJson(jsonDecode(activity.body));\n});\n```\n\n----------------------------------------\n\nTITLE: Watching Future from StreamProvider in Flutter\nDESCRIPTION: This code shows how to watch the Future that resolves with the latest value from a StreamProvider in a Flutter build method.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/reading.mdx#2025-04-23_snippet_16\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, WidgetRef ref) {\n  Future<User> user = ref.watch(userProvider.future);\n}\n```\n\n----------------------------------------\n\nTITLE: Exposing a ChangeNotifier with Riverpod @riverpod Annotation in Dart\nDESCRIPTION: Shows how to expose a ChangeNotifier using the @riverpod annotation combined with the previously defined extension method. This snippet demonstrates creating a provider named 'example' that returns a ChangeNotifier instance managed by Riverpod, which listens and disposes of the notifier automatically. The snippet includes an ignore comment to suppress unsupported provider value lint warnings.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/from_provider/quickstart.mdx#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\n// ignore_for_file: unsupported_provider_value\n@riverpod\nMyNotifier example(Ref ref) {\n  return ref.listenAndDisposeChangeNotifier(MyNotifier());\n}\n```\n\n----------------------------------------\n\nTITLE: Updating StateProvider, Good Practice - Dart\nDESCRIPTION: This code demonstrates updating a state by using the `update` method. This function takes a callback and updates the state with the callback's return value. It is more concise and readable. It takes the current state as input and returns the next state. It's a preferred approach to the previous snippet.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/providers/state_provider.mdx#_snippet_7\n\nLANGUAGE: Dart\nCODE:\n```\n// Code for Update Read Once (update_read_once.dart)\n```\n\n----------------------------------------\n\nTITLE: Updating StateProvider based on previous value\nDESCRIPTION: Shows how to update a StateProvider's state using the update method, which accepts a callback with the current state. This pattern improves clarity when modifying state relative to its previous value.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/es/docusaurus-plugin-content-docs/current/providers/state_provider.mdx#_snippet_2\n\nLANGUAGE: Dart\nCODE:\n```\n<CodeBlock>{trimSnippet(updateReadOnce)}</CodeBlock>\n```\n\n----------------------------------------\n\nTITLE: Using StateNotifierProvider (After) in Dart\nDESCRIPTION: This snippet shows how to use `StateNotifierProvider` after the 0.14.0 update. It explicitly specifies the state type (`MyModel`) as the second type argument of `StateNotifierProvider`. It relies on the `riverpod` package. The output is a configured `StateNotifierProvider`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nfinal provider = StateNotifierProvider<MyStateNotifier, MyModel>((ref) {\n  return MyStateNotifier();\n});\n```\n\n----------------------------------------\n\nTITLE: Reading Providers with Riverpod Package using Consumer Widget in Dart\nDESCRIPTION: Example showing how to read a provider using Riverpod with the Consumer widget, which serves the same purpose as Provider's Consumer but providing a WidgetRef object to access providers.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/from_provider/provider_vs_riverpod.mdx#_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nConsumer(\n  builder: (BuildContext context, WidgetRef ref, Widget? child) {\n    Model model = ref.watch(modelProvider);\n\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Reading a Provider Inside a Class Method in Dart\nDESCRIPTION: Demonstrates a pattern where a class `Repository` receives the provider `Ref` in its constructor. It then uses `ref.read(userTokenProvider)` inside a method (`fetchCatalog`) to get the current value of another provider (`userTokenProvider`) without listening to its changes. This is useful when a value is needed only at the time of execution, like fetching data with an authentication token.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#2025-04-23_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nfinal userTokenProvider = StateProvider<String>((ref) => null);\n\nfinal repositoryProvider = Provider(Repository.new);\n\nclass Repository {\n  Repository(this.ref);\n\n  final Ref ref;\n\n  Future<Catalog> fetchCatalog() async {\n    // Read the token *when the method is called*\n    String token = ref.read(userTokenProvider);\n\n    final response = await dio.get('/path', queryParameters: {\n      'token': token,\n    });\n\n    return Catalog.fromJson(response.data);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using StateNotifierProvider in UI for Todo List in Dart\nDESCRIPTION: This snippet shows how to use the StateNotifierProvider in a Flutter widget to display and interact with the todo list. It uses Consumer to watch the todosProvider and render the list of todos.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/providers/state_notifier_provider.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass TodoListView extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // Watch the provider and rebuild this widget when the todo list changes\n    List<Todo> todos = ref.watch(todosProvider);\n\n    return ListView(\n      children: [\n        for (final todo in todos)\n          CheckboxListTile(\n            value: todo.completed,\n            // When tapping on the todo, change its completed status\n            onChanged: (value) => ref.read(todosProvider.notifier).toggle(todo.id),\n            title: Text(todo.description),\n          ),\n      ],\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Advanced Usage of select in Riverpod\nDESCRIPTION: This snippet shows an advanced use of select where a derived value is watched instead of a direct property.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/reading.mdx#2025-04-23_snippet_21\n\nLANGUAGE: dart\nCODE:\n```\nfinal label = ref.watch(userProvider.select((user) => 'Mr ${user.name}'));\n```\n\n----------------------------------------\n\nTITLE: AutoDispose Family Syntax From 0.4.0 (Dart)\nDESCRIPTION: Illustrates the new, constructor-like syntax introduced in Riverpod 0.4.0 for defining providers with modifiers and families. Modifiers (`autoDispose`) and family (`family`) are chained onto the base provider type (e.g., `StateNotifierProvider`).\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod/CHANGELOG.md#2025-04-23_snippet_18\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nfinal myProvider = StateNotifierProvider.autoDispose.family<MyStateNotifier, int>((ref, id) {\n  return MyStateNotifier(id: id);\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Declaring String Providers\nDESCRIPTION: This code snippet shows how to declare multiple providers that expose String values.  It demonstrates that Riverpod allows multiple providers to return values of the same type, unlike 'package:provider'. Each provider is defined as a global constant using the `Provider` constructor.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/tr/docusaurus-plugin-content-docs/current/concepts/providers.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nfinal cityProvider = Provider((ref) => 'London');\nfinal countryProvider = Provider((ref) => 'England');\n```\n\n----------------------------------------\n\nTITLE: Using select with a computed value in Dart\nDESCRIPTION: This snippet demonstrates using select with a computed value instead of a direct property, which can be useful for more complex filtering scenarios.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/reading.mdx#2025-04-23_snippet_12\n\nLANGUAGE: dart\nCODE:\n```\nfinal label = ref.watch(userProvider.select((user) => 'Mr ${user.name}'));\n```\n\n----------------------------------------\n\nTITLE: Migrating from Computed to Provider With Dependency - Riverpod - Dart\nDESCRIPTION: Compares old usage of the Computed class with the new pattern where all functionality is consolidated under Provider. Shows how to use Provider to depend on other providers with ref.watch. Requires Riverpod dependency. Inputs/outputs are provider instances; output is a reactive value.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/flutter_riverpod/CHANGELOG.md#2025-04-23_snippet_23\n\nLANGUAGE: dart\nCODE:\n```\nfinal provider = Provider(...);\nfinal example = Computed((watch) {\n  final value = watch(provider);\n  return value;\n});\n```\n\nLANGUAGE: dart\nCODE:\n```\nfinal provider = Provider(...);\nfinal example = Provider((ref) {\n  final value = ref.watch(provider);\n  return value;\n});\n```\n\n----------------------------------------\n\nTITLE: Enable Auto-Dispose Without Codegen - Dart\nDESCRIPTION: Shows how to enable auto-disposal for a provider when not using code generation by using `.autoDispose`. This causes the state to be disposed of if the provider has no listeners for a full frame.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/essentials/auto_dispose.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n// 自動破棄を有効にするためにautoDisposeを指定することができます。\n```\n\n----------------------------------------\n\nTITLE: Correctly Watching AutoDispose Provider in Dart\nDESCRIPTION: This snippet presents the solution to the 'AlwaysAliveProviderBase' error shown previously. By marking the dependent provider (`secondProvider`) with `.autoDispose` as well, it can correctly watch another auto-disposing provider (`firstProvider`) without preventing its disposal, thus resolving the compile-time error.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/modifiers/auto_dispose.mdx#2025-04-23_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nfinal firstProvider = Provider.autoDispose((ref) => 0);\n\nfinal secondProvider = Provider.autoDispose((ref) {\n  ref.watch(firstProvider);\n});\n```\n\n----------------------------------------\n\nTITLE: Handling Initial Load and Error Display with Flutter\nDESCRIPTION: This snippet demonstrates how to handle loading and error states gracefully using Riverpod's `AsyncValue`. It uses pattern matching in Dart 3.0 to display a spinner during the initial load and show previous data or errors during the refresh. This is the section that controls the UI based on the async status of fetching the activity.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/case_studies/pull_to_refresh.mdx#_snippet_5\n\nLANGUAGE: Dart\nCODE:\n```\n              // 일부 데이터를 사용할 수 있는 경우 해당 데이터를 표시합니다.\n              // 새로 고침 중에도 데이터를 계속 사용할 수 있다는 점에 유의하세요.\n```\n\nLANGUAGE: Dart\nCODE:\n```\n              // 오류를 사용할 수 있으므로 렌더링합니다.\n```\n\nLANGUAGE: Dart\nCODE:\n```\n              // 데이터/오류가 없으므로 로딩 상태입니다.\n```\n\n----------------------------------------\n\nTITLE: Overriding Family Providers in Dart\nDESCRIPTION: Illustrates the new syntax for overriding family providers. The overrideWithProvider method now requires creating a new provider instance.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/flutter_riverpod/CHANGELOG.md#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nfinal family = Provider.family<State, Arg>(...);\n\nfamily.overrideWithProvider(\n  (Arg arg) => Provider<State>((ref) => ...)\n);\n```\n\n----------------------------------------\n\nTITLE: Using ref.watch to Combine Providers\nDESCRIPTION: Demonstrates how to use ref.watch to reactively combine providers. This example shows fetching restaurants based on the user's location, with the provider automatically rebuilding when the location changes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/combining_requests.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n// A provider that fetches the user's location\n@riverpod\nFuture<Coordinates> location(LocationRef ref) async {\n  // Logic to fetch the user's location\n  return Coordinates(lat: 0, long: 0);\n}\n\n// A provider that fetches restaurants near a specific location\n@riverpod\nFuture<List<Restaurant>> restaurantsNearLocation(\n  RestaurantsNearLocationRef ref,\n  Coordinates location,\n) async {\n  // Fetch restaurants near the coordinates\n  return [/* ... */];\n}\n\n// A provider that combines the two to fetch restaurants near the user\n@riverpod\nFuture<List<Restaurant>> restaurantsNearUser(\n  RestaurantsNearUserRef ref,\n) async {\n  // Wait for the user's location\n  final location = await ref.watch(locationProvider.future);\n\n  // Then fetch the restaurants near that location\n  // When the location changes, this provider will automatically rebuild\n  return ref.watch(restaurantsNearLocationProvider(location).future);\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating StateNotifierProvider.family to AsyncNotifier with Family and AutoDispose in Dart\nDESCRIPTION: This snippet compares the older StateNotifierProvider.family usage, which is verbose and splits initialization and parameters between the provider and notifier constructor, with the new AsyncNotifier family approach. The new approach passes family arguments directly as parameters to the build method and supports combining with autoDispose modifier naturally by class declaration. This leads to cleaner, more readable, and less error-prone asynchronous state providers with family parameters accessible via this.arg or this.paramName in codegen scenarios.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/migration/from_state_notifier.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\n/* Old StateNotifierProvider.family example */\nclass BugsEncounteredNotifier extends StateNotifier<AsyncValue<List<Bug>>> {\n  BugsEncounteredNotifier(this.projectId) : super(const AsyncValue.loading()) {\n    _fetchBugs();\n  }\n\n  final String projectId;\n\n  Future<void> _fetchBugs() async {\n    try {\n      final bugs = await fetchBugsForProject(projectId);\n      state = AsyncValue.data(bugs);\n    } catch (e) {\n      state = AsyncValue.error(e);\n    }\n  }\n}\n\nfinal bugsProvider = StateNotifierProvider.family<BugsEncounteredNotifier, AsyncValue<List<Bug>>, String>((ref, projectId) {\n  return BugsEncounteredNotifier(projectId);\n});\n```\n\nLANGUAGE: dart\nCODE:\n```\n/* New AsyncNotifier.family API example */\nclass BugsEncounteredNotifier extends FamilyAsyncNotifier<List<Bug>, String> {\n  @override\n  Future<List<Bug>> build(String projectId) async {\n    return fetchBugsForProject(projectId);\n  }\n}\n\nfinal bugsProvider = FamilyAsyncNotifierProvider<BugsEncounteredNotifier, List<Bug>, String>(BugsEncounteredNotifier.new);\n```\n\n----------------------------------------\n\nTITLE: Creating a Configuration FutureProvider in Dart\nDESCRIPTION: This snippet demonstrates how to create a FutureProvider that reads a configuration from a JSON file using Flutter's asset system. It shows the asynchronous creation of a Configuration object.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/providers/future_provider.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nfinal configProvider = FutureProvider<Configuration>((ref) async {\n  // Retrieve the configuration from the assets\n  final content = await rootBundle.loadString('assets/configurations.json');\n  // Parse the json\n  final json = jsonDecode(content);\n  // Convert the json into a Configuration instance\n  return Configuration.fromJson(json);\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Fade-In Animation with HookWidget in Flutter\nDESCRIPTION: An equivalent implementation of the fade-in animation using flutter_hooks and HookWidget. This approach simplifies state management by using hooks to handle animation controller lifecycle.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/about_hooks.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nclass FadeIn extends HookWidget {\n  const FadeIn({Key? key, required this.child}) : super(key: key);\n\n  final Widget child;\n\n  @override\n  Widget build(BuildContext context) {\n    // Create an AnimationController. The controller will automatically be\n    // disposed when the widget is unmounted.\n    final animationController = useAnimationController(\n      duration: const Duration(seconds: 2),\n    );\n\n    // useEffect is the equivalent of initState + didUpdateWidget + dispose.\n    // The callback passed to useEffect is executed the first time the hook is\n    // invoked, and then whenever the list passed as second parameter changes.\n    // Since we pass an empty const list here, that's strictly equivalent to `initState`.\n    useEffect(() {\n      // start the animation when the widget is first rendered.\n      animationController.forward();\n      // We could optionally return some \"dispose\" logic here\n      return null;\n    }, const []);\n\n    // Tell Flutter to rebuild this widget when the animation updates.\n    // This is equivalent to AnimatedBuilder\n    useAnimation(animationController);\n\n    return Opacity(\n      opacity: animationController.value,\n      child: child,\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized Previous Button Logic with Provider in Dart\nDESCRIPTION: This optimized approach extracts the button's enabled state logic into a separate `Provider`, `canGoToPreviousPageProvider`. This provider watches `pageIndexProvider` and computes a boolean indicating if navigation to the previous page is allowed. The `PreviousButton` widget now watches `canGoToPreviousPageProvider`. Because `Provider` only notifies listeners when the *value* changes (not just when it's recomputed), the `PreviousButton` rebuilds only when its enabled state actually changes (from enabled to disabled or vice-versa), significantly reducing unnecessary rebuilds compared to the unoptimized version.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/providers/provider.mdx#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\n/// A provider that holds the currently selected page index\nfinal pageIndexProvider = StateProvider((ref) => 0);\n\n/// We extracted the logic for checking if the user can go back\n/// to a separate provider.\nfinal canGoToPreviousPageProvider = Provider<bool>((ref) {\n  // We watch the current page index\n  final pageIndex = ref.watch(pageIndexProvider);\n  // And compute whether the user can go back\n  return pageIndex != 0;\n});\n\nclass PreviousButton extends ConsumerWidget {\n  const PreviousButton({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // We now watch the boolean provider\n    final canGoToPreviousPage = ref.watch(canGoToPreviousPageProvider);\n\n    // We disable the button if the boolean is false\n    return ElevatedButton(\n      onPressed: canGoToPreviousPage\n          ? () => ref.read(pageIndexProvider.notifier).update((state) => state - 1)\n          : null,\n      child: const Text('previous'),\n    );\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Rendering Multiple Providers with Different Arguments\nDESCRIPTION: Demonstrates how to consume the same provider with different arguments simultaneously.  This leverages the argument-based caching of Riverpod, allowing for concurrent requests and proper caching when consuming the same provider with various input parameter values.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/essentials/passing_args.mdx#_snippet_3\n\nLANGUAGE: Dart\nCODE:\n```\n        // 그러면 두 활동을 모두 렌더링할 수 있습니다.\n        // 두 요청이 모두 병렬로 발생하고 올바르게 캐시됩니다.\n```\n\n----------------------------------------\n\nTITLE: Properly handling provider initialization via button interaction\nDESCRIPTION: This snippet illustrates how to initialize a provider in response to a user action, such as pressing a button. This avoids initializing providers at widget creation and ensures control over side effects and state setup, preventing concurrency issues.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/essentials/do_dont.mdx#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\nElevatedButton(\n  onPressed: () {\n    ref.read(provider).init();\n    Navigator.of(context).push(...);\n  },\n  child: Text('Navigate'),\n)\n```\n\n----------------------------------------\n\nTITLE: Using ref.keepAlive with FutureProvider (Dart)\nDESCRIPTION: This example showcases the use of `ref.keepAlive()` inside an `autoDispose` `FutureProvider`.  The function will make sure the data is not requested again if it was already successfully retrieved.  It uses `httpClient.get(...)` and `ref.keepAlive()` to preserve the state. This requires a `FutureProvider` and an instance of `httpClient`. The input is a HTTP request, and the output is the response, or a preserved response.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/es/docusaurus-plugin-content-docs/current/concepts/modifiers/auto_dispose.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nfinal myProvider = FutureProvider.autoDispose((ref) async {\n  final response = await httpClient.get(...);\n  ref.keepAlive();\n  return response;\n});\n```\n\n----------------------------------------\n\nTITLE: AutoDispose Provider Configuration\nDESCRIPTION: Example showing how to configure autoDispose behavior in a code-generated provider.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/about_code_generation.mdx#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\n@Riverpod(keepAlive: true)\nString example(ExampleRef ref) {\n  return 'Example';\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Search Input Provider with Riverpod\nDESCRIPTION: Creates a StateProvider to store the user's search input as a string. This provider will be updated as the user types in the search field.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/cookbooks/search_as_we_type.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nfinal searchInputProvider = StateProvider<String>((ref) => '');\n```\n\n----------------------------------------\n\nTITLE: Mapping FutureProvider Dependencies (Recommended) Dart\nDESCRIPTION: Shows the recommended approach for creating a provider (here, a FutureProvider) that depends on the future value of another provider (b.future). This replaces the deprecated direct stream mapping.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/hooks_riverpod/CHANGELOG.md#_snippet_4\n\nLANGUAGE: Dart\nCODE:\n```\nfinal a = FutureProvider((ref) async {\n  final e = await ref.watch(b.future);\n  return Model(e);\n})\n```\n\n----------------------------------------\n\nTITLE: Using Consumer and HookConsumer Widgets to Obtain ref in Flutter Dart\nDESCRIPTION: Shows how to obtain the ref object from the builder callback of Consumer or HookConsumer widgets without defining custom ConsumerWidget classes. Useful for inline provider watching and UI reaction inside widget trees without additional class overhead.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_5\n\nLANGUAGE: Dart\nCODE:\n```\n<CodeBlock>{trimSnippet(consumerHook)}</CodeBlock>\n```\n\n----------------------------------------\n\nTITLE: Defining Search Input Provider with StateProvider - Riverpod (Dart)\nDESCRIPTION: Defines a StateProvider to manage and expose the search input string for the searchbar feature. No parameters are required beyond the provider reference. Used as the stateful source of truth for user input, allowing other providers or widgets to reactively watch changes. Depends on flutter_riverpod.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/cookbooks/search_as_we_type.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nfinal searchInputProvider = StateProvider<String>((ref) => '');\n```\n\n----------------------------------------\n\nTITLE: Reading Providers with Provider Package using BuildContext in Dart\nDESCRIPTION: Example showing how to read a provider using the Provider package with BuildContext, using the context.watch method inside a StatelessWidget.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/from_provider/provider_vs_riverpod.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nProvider<Model>(...);\n```\n\nLANGUAGE: dart\nCODE:\n```\nclass Example extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    Model model = context.watch<Model>();\n\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: 신규 `AsyncNotifier`를 사용하는 비동기 예제\nDESCRIPTION: 이 예제는 기존 `asyncNotifierOld` 예제에서 `AsyncNotifier` API로 완전하게 재작성한 버전입니다. `build`에서 초기 비동기 로직을 처리하며, `AsyncValue`를 자동으로 반환하는 구조를 보여줍니다. `update`, `future`와 같은 유틸리티 메서드를 사용하여 비동기 변이/부수효과를 간결하게 수행할 수 있으며, 비동기 상태 관리에 있어 큰 편리함을 제공합니다.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/migration/from_state_notifier.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet language=\"dart\" {...asyncNotifier}></AutoSnippet>\n```\n\n----------------------------------------\n\nTITLE: Consuming Notifier (0.14.0+) in a Widget (Dart)\nDESCRIPTION: Demonstrates the recommended way to access the StateNotifier instance via provider.notifier with the latest Riverpod syntax. Assumes Riverpod >=0.14.0 and relevant context. This ensures forward-compatibility and consistency with provider API updates.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, ScopedReader watch) {\n  MyStateNotifier notifier = watch(provider.notifier);\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Provider Lifecycle Callbacks in Riverpod (Dart)\nDESCRIPTION: This snippet demonstrates how to use ref.onCancel and ref.onDispose callbacks within a Riverpod provider in Dart. ref.onCancel is used to execute logic when all listeners stop listening, while ref.onDispose is triggered when the provider is disposed (especially with .autoDispose). These allow precise resource cleanup or debugging. No external dependencies are needed beyond riverpod; functions passed into the hooks do not take arguments, and there are no input parameters for these callbacks. Output is typically side-effects such as logging. Limitations: The hooks require the provider to be marked .autoDispose for ref.onDispose to fire on unused state cleanup.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/from_provider/provider_vs_riverpod.mdx#_snippet_15\n\nLANGUAGE: dart\nCODE:\n```\nref.onCancel((){\n  print(\"もう誰も私に耳を傾けていません！\");\n});\nref.onDispose((){\n  print(\"もし私が`.autoDispose`として定義されていれば、今破棄されました！\");\n});\n```\n\n----------------------------------------\n\nTITLE: Using ref.read for One-Time Provider Access - Riverpod Dart\nDESCRIPTION: This code demonstrates the use of 'ref.read' to access the value of a provider without establishing a subscription, typically for event-driven scenarios like button presses. Unlike 'watch', this method won't trigger widget rebuilds on provider changes. Dependencies include Riverpod/Flutter, and inputs are the ref and the desired provider. Output is the provider value at call-time; use with caution as it does not update reactively.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/reading.mdx#2025-04-23_snippet_11\n\nLANGUAGE: dart\nCODE:\n```\nonPressed: () {\n  ref.read(counterProvider.notifier).increment();\n}\n```\n\n----------------------------------------\n\nTITLE: Isolating Provider State in test with ProviderContainer (Dart)\nDESCRIPTION: This Dart-only test snippet illustrates how Riverpod ProviderContainer ensures state is not shared between individual tests. By manually creating new ProviderContainer instances, each test runs with a clean state, avoiding cross-test pollution. Dependencies: riverpod, test. Input: test functions; Output: assertions confirming state is 0 in both cases.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/cookbooks/testing.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nimport 'package:test/test.dart';\nimport 'package:riverpod/riverpod.dart';\n\nfinal counterProvider = StateProvider((ref) => 0);\n\nvoid main() {\n  test('first test', () {\n    final container = ProviderContainer();\n    expect(container.read(counterProvider).state, 0);\n  });\n\n  test('second test', () {\n    final container = ProviderContainer();\n    expect(container.read(counterProvider).state, 0);\n  });\n}\n\n```\n\n----------------------------------------\n\nTITLE: Rendering a Product List Using Riverpod in Flutter\nDESCRIPTION: Creates a basic ListView that displays a list of products from a Riverpod provider. It shows the product name and price for each item in the list.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/providers/state_provider.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nfinal productsProvider = Provider<List<Product>>((ref) {\n  return products;\n});\n\nclass ProductListView extends ConsumerWidget {\n  const ProductListView({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final products = ref.watch(productsProvider);\n    return ListView.builder(\n      itemCount: products.length,\n      itemBuilder: (context, index) {\n        final product = products[index];\n        return ListTile(\n          title: Text(product.name),\n          subtitle: Text('${product.price} \\$'),\n        );\n      },\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Problematic async operation with ref in Dart using Riverpod\nDESCRIPTION: This code snippet demonstrates the incorrect pattern that causes the \"Cannot use 'ref' after the widget was disposed\" error. The issue occurs when trying to use ref after an awaited operation when the widget might have been unmounted.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/essentials/faq.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nElevatedButton(\n  onPressed: () async {\n    await future;\n    ref.read(...); // 可能抛出 \"Cannot use \"ref\" after the widget was disposed\"\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Listening to Provider Changes in Test - Dart\nDESCRIPTION: This snippet illustrates how to listen to changes in a provider within a test using `container.listen`.  It sets the stage for spying on providers and using them with packages such as `mockito` or `mocktail` to verify interactions and changes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/essentials/testing.mdx#_snippet_7\n\nLANGUAGE: Dart\nCODE:\n```\n    container.listen<int>(\n      myProvider,\n      (previous, next) {\n        // TODO: provider의 변경 사항을 처리합니다.\n      },\n    );\n```\n\n----------------------------------------\n\nTITLE: Auto-disposing State in Riverpod (Dart)\nDESCRIPTION: This snippet demonstrates Riverpod's `autodispose` modifier, which allows for automatic disposal of provider state when it's no longer being listened to. This resolves the issue of Provider not being able to react when a consumer stops listening, enabling flexible caching strategies.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/from_provider/motivation/motivation.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nimport autoDispose from \"/docs/from_provider/motivation/auto_dispose\";\n```\n\n----------------------------------------\n\nTITLE: Fetching Activity with HTTP Request in Dart\nDESCRIPTION: This snippet defines a provider that makes an HTTP GET request to fetch a single activity. It likely uses a library such as `http` to handle the request and retrieves an activity from a REST API. The provider's role is to encapsulate the logic to fetch the activity.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/case_studies/pull_to_refresh.mdx#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\n\n```\n\n----------------------------------------\n\nTITLE: Overriding FutureProvider with AsyncValue in Tests\nDESCRIPTION: This snippet illustrates a simplified way to override a `FutureProvider` directly with a specific `AsyncValue`. Instead of mocking the underlying dependency, you can use `overrideWithValue` on the `FutureProvider` itself to force it into a specific state (e.g., `AsyncValue.data`) for testing purposes. Note: This specific `overrideWithValue` method was mentioned as temporarily removed in Riverpod 2.0.0.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/cookbooks/testing.mdx#2025-04-23_snippet_5\n\nLANGUAGE: Dart\nCODE:\n```\ntestWidgets('Override todoListProvider with an AsyncValue', (tester) async {\n  await tester.pumpWidget(\n    ProviderScope(\n      overrides: [\n        // Override todoListProvider to return a fixed data.\n        //\n        // We don't need to mock Repository for this test.\n        todoListProvider.overrideWithValue(\n          // The desired value\n          AsyncValue.data([{'id': 42, 'label': 'Hello world'}]),\n        ),\n      ],\n      child: const MyApp(),\n    ),\n  );\n\n  // Our UI shows the overridden value\n  expect(find.text('Hello world'), findsOneWidget);\n  // The progress indicator is not showing\n  expect(find.byType(CircularProgressIndicator), findsNothing);\n});\n\n```\n\n----------------------------------------\n\nTITLE: Call add To-Do Method from UI\nDESCRIPTION: This code snippet shows how to call the `addTodo` method using a `Consumer`/`ConsumerWidget` within the UI. It demonstrates how to trigger the method when a button is pressed, and the usage of `ref.read` in the context of an event handler like an \"onPressed\" callback.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/essentials/side_effects.mdx#_snippet_5\n\nLANGUAGE: Dart\nCODE:\n```\n\n```\n\n----------------------------------------\n\nTITLE: Naive watching of User object in Dart build method\nDESCRIPTION: This code shows a naive approach to watching a User object in a Flutter build method, which may cause unnecessary rebuilds.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/reading.mdx#2025-04-23_snippet_9\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, WidgetRef ref) {\n  User user = ref.watch(userProvider);\n  return Text(user.name);\n}\n```\n\n----------------------------------------\n\nTITLE: Exemple de scoping de sous-arbre pour la personnalisation du thème\nDESCRIPTION: Ce snippet montre comment appliquer un scope local pour override le thème dans un sous-arbre spécifique, similaire à l'usage d'un InheritedWidget comme Theme. Il permet de modifier l'état de manière ciblée sans recharger l'ensemble de l'application.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/concepts/scopes.mdx#_snippet_2\n\nLANGUAGE: Dart\nCODE:\n```\n{trimSnippet(themeScope)}\n```\n\n----------------------------------------\n\nTITLE: Defining a FutureProvider.family to Load Messages by ID in Dart\nDESCRIPTION: This snippet demonstrates defining a FutureProvider with the .family modifier to asynchronously fetch a Message entity by its ID using an HTTP client (dio). The provider takes a String parameter 'id' which is used to formulate the API endpoint. It returns a Future<Message>. This snippet assumes the existence of a configured dio client and a Message model.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/de/docusaurus-plugin-content-docs/current/concepts/modifiers/family.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nfinal messagesFamily = FutureProvider.family<Message, String>((ref, id) async {\n  return dio.get('http://my_api.dev/messages/$id');\n});\n```\n\n----------------------------------------\n\nTITLE: Handling Loading and Error States with AsyncValue Pattern Matching in Flutter/Dart\nDESCRIPTION: Enhances the widget to gracefully handle loading and error states provided by Riverpod's `AsyncValue`. It uses Dart 3 pattern matching to display a centered `CircularProgressIndicator` during initial load, show the previous data/error during refresh (handled implicitly by `AsyncValue` state transitions combined with `RefreshIndicator`), and display the activity data when available. `valueOrNull` is used for safe data access.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/case_studies/pull_to_refresh.mdx#_snippet_3\n\nLANGUAGE: Dart\nCODE:\n```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nimport 'activity.dart';\nimport 'provider.dart';\n\nclass ActivityCard extends ConsumerWidget {\n  const ActivityCard({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final AsyncValue<Activity> activity = ref.watch(activityProvider);\n\n    return RefreshIndicator(\n      onRefresh: () {\n        ref.refresh(activityProvider);\n        return ref.read(activityProvider.future);\n      },\n      // Use Dart 3 pattern matching to handle the states\n      // The `when` method is also an option.\n      child: switch (activity) {\n        // If the provider is loading and has no previous value,\n        // show a progress indicator.\n        // This handles the initial load.\n        AsyncValue(isLoading: true, valueOrNull: null) =>\n          const Center(child: CircularProgressIndicator()),\n        // If the provider encountered an error and has no previous value,\n        // show the error.\n        AsyncValue(error: final error?, valueOrNull: null) =>\n          Center(child: Text('Error: $error')),\n        // If the provider is refreshing (loading/error with a previous value),\n        // or if it has successfully loaded a value,\n        // show the list view.\n        // The RefreshIndicator will handle showing the loading indicator\n        // during refresh.\n        AsyncValue(:final valueOrNull?) => ListView(\n            children: [\n              Card(\n                child: Container(\n                  padding: const EdgeInsets.all(16),\n                  child: Column(\n                    children: [\n                      Text(\n                        // If the activity is null (which can happen during refresh\n                        // or if the initial load failed),\n                        // show a default text.\n                        valueOrNull?.activity ?? 'Pull to refresh',\n                        style: Theme.of(context).textTheme.headlineSmall,\n                      ),\n                      // Show a progress indicator if the provider is currently\n                      // refreshing the data.\n                      if (activity.isLoading) const CircularProgressIndicator(),\n                    ],\n                  ),\n                ),\n              ),\n            ],\n          ),\n      },\n    );\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Combining Auto-Dispose and Family Modifiers for a StreamProvider in Dart\nDESCRIPTION: Illustrates how to combine the `.autoDispose` and `.family` modifiers on a `StreamProvider` in Riverpod. This allows creating providers that are both auto-disposing and parameterized.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/modifiers/auto_dispose.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nfinal userProvider = StreamProvider.autoDispose.family<User, String>((ref, id) {\n\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Using ref.listen - Dart\nDESCRIPTION: Illustrates the use of `ref.listen` to react to provider changes. Unlike `ref.watch`, `ref.listen` doesn't rebuild widgets/providers. Instead, it executes a provided function when the provider's value changes, allowing side effects like showing a SnackBar or navigating.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_9\n\nLANGUAGE: dart\nCODE:\n```\n/* ... content of reading_listen.dart ... */\n```\n\n----------------------------------------\n\nTITLE: Using AsyncNotifierProvider in a Flutter UI\nDESCRIPTION: This snippet demonstrates how to consume an AsyncNotifierProvider in a Flutter UI to interact with a remote list of todos. It shows how to handle the asynchronous state and call methods to modify the remote data.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/providers/notifier_provider.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\n// This code is referenced via trimSnippet(remoteTodosConsumer) but not directly shown in the text\n```\n\n----------------------------------------\n\nTITLE: Defining Repository and State Provider with Riverpod (Dart)\nDESCRIPTION: This snippet sets up a Repository class, a repositoryProvider for dependency injection, and a ChangeNotifier-based state provider using Riverpod. It's designed to illustrate real-world provider composition prior to testing, forming the foundation for implementing overrides in tests. Dependency: riverpod. Inputs: none directly; Output: provider definitions to be used in app/tests.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/cookbooks/testing.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nimport 'package:riverpod/riverpod.dart';\nimport 'package:flutter/foundation.dart';\n\nclass Repository {\n  Future<String> fetchTodoList() async => 'todos result';\n}\n\nfinal repositoryProvider = Provider((ref) => Repository());\n\nclass TodoListNotifier extends ChangeNotifier {\n  TodoListNotifier(this.read);\n  final Reader read;\n  // ... other state management code\n}\n\nfinal todoListProvider = ChangeNotifierProvider((ref) {\n  return TodoListNotifier(ref.read);\n});\n\n```\n\n----------------------------------------\n\nTITLE: Implementing a ProviderObserver Logger in Dart (Riverpod)\nDESCRIPTION: Demonstrates how to create a custom `ProviderObserver` in Dart using the Riverpod library. This implementation overrides `didUpdateProvider` to log the provider's name, previous value, and new value whenever a provider emits a notification. Requires the `riverpod` package. Note that for mutable states like StateController or ChangeNotifier, previousValue and newValue might reference the same object.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/provider_observer.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n// logger.dart (Content assumed based on context)\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'dart:developer' as developer;\n\n// An observer that logs provider changes.\nclass Logger extends ProviderObserver {\n  @override\n  void didUpdateProvider(\n    ProviderBase<Object?> provider,\n    Object? previousValue,\n    Object? newValue,\n    ProviderContainer container,\n  ) {\n    developer.log('''\n{\n  \"provider\": \"${provider.name ?? provider.runtimeType}\",\n  \"newValue\": \"$newValue\"\n}''');\n  }\n\n  // Optionally override other methods like didAddProvider or didDisposeProvider\n  // @override\n  // void didAddProvider(ProviderBase provider, Object? value, ProviderContainer container) {\n  //   print('Provider ${provider.name ?? provider.runtimeType} was initialized with $value');\n  // }\n\n  // @override\n  // void didDisposeProvider(ProviderBase provider, ProviderContainer container) {\n  //   print('Provider ${provider.name ?? provider.runtimeType} was disposed');\n  // }\n}\n\n// To use this logger, add it to the observers list in your ProviderScope or ProviderContainer:\n// ProviderScope(\n//   observers: [Logger()],\n//   child: MyApp(),\n// );\n```\n\n----------------------------------------\n\nTITLE: Consuming a FutureProvider in a Flutter Widget\nDESCRIPTION: This snippet shows how to consume the configuration FutureProvider in a Flutter widget. It demonstrates handling the AsyncValue states (loading, error, data) that are returned when watching a FutureProvider.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/providers/future_provider.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass HomeView extends ConsumerWidget {\n  const HomeView({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // Watch the provider and handle all three states: loading, error, and data\n    final config = ref.watch(configProvider);\n\n    return config.when(\n      loading: () => const CircularProgressIndicator(),\n      error: (err, stack) => Text('Error: $err'),\n      data: (config) {\n        return Text('Host: ${config.host}');\n      },\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating StateProvider to Notifier (Dart)\nDESCRIPTION: This snippet demonstrates the process of migrating from a `StateProvider` to a `Notifier`. The original `StateProvider` is replaced with an equivalent implementation using `Notifier`, which provides a more robust and maintainable approach. This is done to improve state management with Riverpod. It reduces LoC (Lines of Code) to avoid using deprecated features. It uses the dart language to provide a functional example.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/migration/from_state_notifier.mdx#_snippet_10\n\nLANGUAGE: Dart\nCODE:\n```\n\n```\n\n----------------------------------------\n\nTITLE: Refreshing a Riverpod provider in Dart\nDESCRIPTION: This code snippet shows how to refresh a Riverpod provider, which recreates the associated state object.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/reading.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nref.refresh(counterProvider);\n```\n\n----------------------------------------\n\nTITLE: Fetching To-Do List with Provider\nDESCRIPTION: This snippet demonstrates a simple GET request to fetch a to-do list. It simulates a network request and is similar to the examples provided in the documentation for how to fetch data. The provider's implementation for this function is omitted in the text, but is assumed to be implemented elsewhere.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/essentials/side_effects.mdx#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\n  // 네트워크 요청을 시뮬레이션합니다. 이것은 일반적으로 실제 API에서 오는 것입니다.\n```\n\n----------------------------------------\n\nTITLE: Correct Hook Usage in HookWidget Build Method - Dart\nDESCRIPTION: Demonstrates the correct way to use a Flutter Hook (`useAnimationController`) within the `build` method of a widget that extends `HookWidget`. Hooks must be called directly inside the build method of a HookWidget or HookConsumerWidget.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/about_hooks.mdx#_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nclass Example extends HookWidget {\n  @override\n  Widget build(BuildContext context) {\n    final controller = useAnimationController();\n    ...\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Usage: ref.watch/read inside Selector - Dart\nDESCRIPTION: Highlights an important constraint: it is not allowed to use `ref.watch` or `ref.read` directly inside the selector function provided to `.select()`. Selectors must be pure functions based only on the input value.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/hooks_riverpod/CHANGELOG.md#_snippet_20\n\nLANGUAGE: Dart\nCODE:\n```\nprovider.select((value) => ref.watch(something)); // KO, cannot user ref.watch inside selectors\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of Hooks in a StatelessWidget\nDESCRIPTION: Example showing an incorrect implementation where hooks are used in a StatelessWidget instead of a HookWidget.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/about_hooks.mdx#2025-04-23_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\n// Not a HookWidget\nclass Example extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    final controller = useAnimationController();\n    ...\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an Asynchronous (Future) Functional Provider (Dart)\nDESCRIPTION: This snippet illustrates defining an asynchronous Riverpod provider returning a Future using an annotated async function. Riverpod automatically handles loading/error states and exposes an AsyncValue.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/about_code_generation.mdx#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\n{trimSnippet(asyncFnFuture)}\n```\n\n----------------------------------------\n\nTITLE: Providing Synchronous Access to Async Initialized Data using Scope Overrides (Dart)\nDESCRIPTION: This example demonstrates initializing an asynchronous dependency (`SharedPreferences`) and then providing it synchronously to the rest of the app. It defines a `sharedPreferencesProvider` that initially throws `UnimplementedError`. In `main`, it asynchronously gets the `SharedPreferences` instance and then runs the app within a `ProviderScope` that overrides `sharedPreferencesProvider` with the actual instance, making it synchronously accessible within the scope.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/scopes.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n// ignore_for_file: avoid_print, use_key_in_widget_constructors\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:shared_preferences/shared_preferences.dart';\n\n/// A provider that asynchronously creates a SharedPreferences.\n///\n/// This simulates loading our dependency asynchronously\nfinal sharedPreferencesProvider = Provider<SharedPreferences>((ref) {\n  // The provider initialization is synchronous.\n  // It should not return a Future.\n  throw UnimplementedError();\n});\n\n/// An example of provider that depends on [sharedPreferencesProvider].\n///\n/// It aims to read the list of favorite movies from the SharedPreferences.\n/// But it cannot, as [sharedPreferencesProvider] is not initialized yet.\n///\n/// This is where scoping/overriding providers is useful.\nfinal favoriteMoviesProvider = StateProvider<List<String>>((ref) {\n  // We use \"watch\" the sharedPreferencesProvider, such that if SharedPreferences changes,\n  // this provider is automatically re-evaluated.\n  final sharedPreferences = ref.watch(sharedPreferencesProvider);\n  // We can now read the result synchronously.\n  return sharedPreferences.getStringList('favoriteMovies') ?? const [];\n});\n\nFuture<void> main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n\n  final sharedPreferences = await SharedPreferences.getInstance();\n\n  runApp(\n    ProviderScope(\n      overrides: [\n        // We override the unimplemented provider with the value obtained.\n        // The provider is now initialized.\n        sharedPreferencesProvider.overrideWithValue(sharedPreferences),\n      ],\n      child: MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: Home(),\n    );\n  }\n}\n\nclass Home extends ConsumerWidget {\n  const Home({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // The list of favorite movies is loaded synchronously. No need for a FutureBuilder!\n    // We are also filtering the list for movies starting with \"The\".\n    // There's no need to do that inside the provider itself!\n    final favorites = ref.watch(\n      favoriteMoviesProvider.select((value) {\n        return value.where((s) => s.startsWith('The')).toList();\n      }),\n    );\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Favorites')),\n      body: ListView(\n        children: [\n          for (final movie in favorites) Text(movie),\n        ],\n      ),\n    );\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Using ref.watch in Build\nDESCRIPTION: This snippet shows using `ref.watch` within a widget's `build` method to update the UI based on a provider's value. The widget listens to a counter provider and rebuilds itself to display the current counter value. It provides a simple demonstration of reactive UI based on provider state.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_6\n\nLANGUAGE: Dart\nCODE:\n```\nclass CounterText extends ConsumerWidget {\n  const CounterText({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final count = ref.watch(counterProvider);\n    return Text('Count: \\$count');\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Optimizing Previous Button Rebuilds with Boolean Provider (Riverpod, Dart)\nDESCRIPTION: This snippet refactors the enabling logic for the 'previous' button into a boolean Provider, isolating state change observations and reducing unnecessary widget rebuilds. The canGoToPreviousPageProvider returns a boolean, allowing the button's enabled state to only depend on that specific value. Dependencies: Riverpod, pageIndexProvider. Input: BuildContext, WidgetRef; Output: IconButton bound to a Provider boolean. This optimization decouples logic from the widget, enhancing maintainability and efficiency.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/providers/provider.mdx#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nfinal canGoToPreviousPageProvider = Provider<bool>((ref) {\n  final pageIndex = ref.watch(pageIndexProvider);\n  return pageIndex > 0;\n});\n\n```\n\nLANGUAGE: dart\nCODE:\n```\nclass OptimizedPreviousButton extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final canGoToPreviousPage = ref.watch(canGoToPreviousPageProvider);\n    return IconButton(\n      icon: Icon(Icons.arrow_back),\n      onPressed: canGoToPreviousPage\n        ? () => ref.read(pageControllerProvider).previousPage()\n        : null,\n    );\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Installing Riverpod CLI in Shell\nDESCRIPTION: This shell command activates the `riverpod_cli` package globally using `dart pub global activate`. This tool helps in migrating the project to the new versions of Riverpod.  It assumes Dart and pub are correctly installed and configured on the system.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_7\n\nLANGUAGE: sh\nCODE:\n```\ndart pub global activate riverpod_cli\n```\n\n----------------------------------------\n\nTITLE: Declaring an AsyncNotifier for Todos in Riverpod (Dart)\nDESCRIPTION: This snippet demonstrates how to declare an AsyncNotifier<List<Todo>> provider, laying the foundation for an immutable and asynchronous state management solution in Riverpod (Dart). Required dependencies are Riverpod 2.0+ and the Dart language. Key implementation involves defining a class extending AsyncNotifier<List<Todo>>, with the build method specifying how to load the state. No extra parameters are required and side effects should be encapsulated in class methods. The provider exposes loading, error, and data states via AsyncValue, simplifying state management and reducing errors.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/migration/from_change_notifier.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n/* ... code from /docs/migration/from_change_notifier/declaration ... */\n```\n\n----------------------------------------\n\nTITLE: Accessing State from StateNotifierProvider with new Dart Riverpod Syntax\nDESCRIPTION: Exhibits the simplified current method of accessing the state managed by a StateNotifierProvider by directly watching the provider without referencing a state property. This updated usage aligns with the API changes in Riverpod 0.14.0, making state access more ergonomic.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/tr/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, ScopedReader watch) {\n  MyModel state = watch(provider);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing UserNotifier with ref.listen in Riverpod\nDESCRIPTION: Creates a UserNotifier that depends on UserIdNotifier using ref.listen in Riverpod. This shows how to achieve the equivalent of ChangeNotifierProxyProvider in Riverpod.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/from_provider/provider_vs_riverpod.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nclass UserNotifier extends ChangeNotifier {\n  String? _userId;\n\n  void setUserId(String? userId) {\n    if (userId != _userId) {\n      print('The user ID changed from $_userId to $userId');\n      _userId = userId;\n    }\n  }\n}\n\n// ...\n\nfinal userNotifierProvider = ChangeNotifierProvider<UserNotifier>((ref) {\n  final userNotifier = UserNotifier();\n  ref.listen<UserIdNotifier>(\n    userIdNotifierProvider,\n    (previous, next) {\n      if (previous?.userId != next.userId) {\n        userNotifier.setUserId(next.userId);\n      }\n    },\n  );\n\n  return userNotifier;\n});\n```\n\n----------------------------------------\n\nTITLE: Calling a Notifier Method from UI in Riverpod\nDESCRIPTION: Demonstrates how to call a method on a Notifier from a Consumer widget in a Flutter UI. Uses ref.read to access the notifier and call its addTodo method within an event handler.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/essentials/side_effects.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nConsumer(\n  builder: (context, ref, child) {\n    return ElevatedButton(\n      onPressed: () {\n        // Using ref.read to access the notifier\n        ref.read(todoListProvider.notifier).addTodo(\n          Todo(description: \"New todo\"),\n        );\n      },\n      child: const Text(\"Add todo\"),\n    );\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: 상태 폐기 시 콜백 등록 - Dart\nDESCRIPTION: ref.onDispose를 사용해 provider의 상태가 폐기될 때 호출되는 콜백을 등록하는 예입니다. 이 방법으로 StreamController 닫기와 같은 정리 작업을 수행할 수 있으며, 부작용 방지와 생명주기 이벤트 처리에 유용합니다. dependencies: Riverpod, Dart. 주요 메서드: ref.onDispose.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/essentials/auto_dispose.mdx#_snippet_2\n\nLANGUAGE: Dart\nCODE:\n```\n```dart\n// 상태가 소멸되면 스트림 컨트롤러를 닫습니다.\nref.onDispose(() {\n  // TODO: StreamController에 일부 값을 푸시합니다.\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Combining autoDispose with .family Provider for Memory Management (Dart)\nDESCRIPTION: This snippet uses FutureProvider.autoDispose.family to ensure that provider instances created with varying parameters will be disposed when unused, avoiding memory leaks. Especially relevant when using unstable or dynamic parameters such as search inputs. It shows taking a filter String parameter and asynchronously fetching a list of characters. Requires Riverpod and a fetchCharacters function; input is a String filter, output is a Future<List<Character>>.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/modifiers/family.mdx#2025-04-23_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nfinal characters = FutureProvider.autoDispose.family<List<Character>, String>((ref, filter) async {\n  return fetchCharacters(filter: filter);\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Multi-Parameter Provider with Equatable for Custom Equality (Dart)\nDESCRIPTION: This snippet uses the Equatable package to create a parameter class (MyParameter) that supports multiple fields (userId, locale) and proper equality semantics needed by family providers. It demonstrates defining the class, using it as the family parameter in a provider, and consuming it from a widget. Dependencies are Riverpod, Equatable, and Flutter. The input is a MyParameter instance with userId and locale, and the output is a value of type Something from the provider.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/modifiers/family.mdx#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nclass MyParameter extends Equatable  {\n  MyParameter({\n    required this.userId,\n    required this.locale,\n  });\n\n  final int userId;\n  final Locale locale;\n\n  @override\n  List<Object> get props => [userId, locale];\n}\n\nfinal exampleProvider = Provider.family<Something, MyParameter>((ref, myParameter) {\n  print(myParameter.userId);\n  print(myParameter.locale);\n  // Do something with userId/locale\n});\n\n@override\nWidget build(BuildContext context, WidgetRef ref) {\n  int userId; // Read the user ID from somewhere\n  final locale = Localizations.localeOf(context);\n\n  final something = ref.watch(\n    exampleProvider(MyParameter(userId: userId, locale: locale)),\n  );\n\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding a Riverpod Provider for a Widget Subtree using ProviderScope (Dart)\nDESCRIPTION: This example shows how to achieve subtree-specific state in Riverpod. A `counterProvider` (a `StateProvider<int>`) is defined globally. Within the widget tree, a nested `ProviderScope` is used with the `overrides` property to provide a different instance or initial value for `counterProvider` within that specific subtree (`SecondScreen` in this case). Widgets inside this nested scope will interact with the overridden provider state, while widgets outside use the state from the parent scope.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/scopes.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Define a provider (e.g., a counter)\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return ProviderScope(\n      // Root scope\n      child: MaterialApp(\n        home: HomeScreen(),\n      ),\n    );\n  }\n}\n\nclass HomeScreen extends ConsumerWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final count = ref.watch(counterProvider);\n    return Scaffold(\n      appBar: AppBar(title: Text('Home Screen (Count: $count)')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            Navigator.of(context).push(\n              MaterialPageRoute(\n                builder: (_) => ProviderScope(\n                  // Nested scope for SecondScreen\n                  parent:\n                      ProviderScope.containerOf(context), // Correctly link to parent\n                  overrides: [\n                    // Override the counterProvider for this subtree\n                    counterProvider.overrideWith((ref) => 100), // Start at 100\n                  ],\n                  child: const SecondScreen(),\n                ),\n              ),\n            );\n          },\n          child: const Text('Go to Second Screen (Overridden Scope)'),\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => ref.read(counterProvider.notifier).state++,\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}\n\nclass SecondScreen extends ConsumerWidget {\n  const SecondScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final count = ref.watch(counterProvider);\n    return Scaffold(\n      appBar: AppBar(title: Text('Second Screen (Count: $count)')),\n      body: const Center(\n        child: Text('Counter in this scope started at 100.'),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => ref.read(counterProvider.notifier).state++,\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining a StateNotifier for Todo List management in Dart\nDESCRIPTION: Implements a StateNotifier class managing a list of Todo objects and initializes a StateNotifierProvider to expose this state. It forms the basis for state management of a todo list within Riverpod.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#_snippet_2\n\nLANGUAGE: Dart\nCODE:\n```\nclass TodoList extends StateNotifier<List<Todo>> {\n  TodoList(): super(const []);\n}\n\nfinal todoListProvider = StateNotifierProvider((ref) => TodoList());\n```\n\n----------------------------------------\n\nTITLE: Incorrect usage: calling read inside provider body in Dart\nDESCRIPTION: An auto-generated snippet showing a bad practice of calling ref.read inside a provider body, which can cause unintended rebuilds. This pattern should be avoided.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#_snippet_7\n\nLANGUAGE: dart\nCODE:\n```\nfinal myProvider = Provider((ref) {\n  // É cattiva pratica chiamare `read` qui.\n  final value = ref.read(anotherProvider);\n});\n```\n\n----------------------------------------\n\nTITLE: Consumer/HookConsumer Usage\nDESCRIPTION: This snippet uses a `Consumer` widget to obtain a `ref` within a widget's build method. It directly uses the ref to interact with the providers within the child widget. It serves as an alternative to defining a class.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_4\n\nLANGUAGE: Dart\nCODE:\n```\nConsumer(\n  builder: (context, ref, child) {\n    // use ref here to interact with providers\n    return const Text('Hello World');\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Defining ChangeNotifier and Provider (Dart)\nDESCRIPTION: This snippet demonstrates the definition of a `ChangeNotifier` model and its corresponding `ChangeNotifierProvider` for use within a Flutter application using the Riverpod framework. It is used to manage the state of a Todo list. Dependencies: flutter_riverpod or hooks_riverpod and the appropriate Flutter libraries. Input: Defines the structure of a Todo item and the state changes related to the todo list. Output: Creates a provider accessible to the UI, giving access to the data and change notifications.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/providers/change_notifier_provider.mdx#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\n// Code from /i18n/ja/docusaurus-plugin-content-docs/current/providers/change_notifier_provider/todos.dart\n// Placeholder for the code snippet demonstrating the definition of a ChangeNotifier and its Provider.\n// The actual code would define a Todo model, a ChangeNotifier that manages a list of Todos,\n// and a ChangeNotifierProvider that exposes the ChangeNotifier to the UI.\n// Details about the implementation are not given in the document.\n\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of ref.read in Flutter Build Method\nDESCRIPTION: This snippet demonstrates an incorrect way of using ref.read inside a build method, which can lead to bugs and difficulties in future refactoring.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/reading.mdx#2025-04-23_snippet_9\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet language=\"dart\" {...readBuild}></AutoSnippet>\n```\n\n----------------------------------------\n\nTITLE: Sample Dart code snippet for Riverpod provider syntax\nDESCRIPTION: This code snippet illustrates the difference in syntax when defining a provider with and without code generation. It uses the trimSnippet function to showcase the raw and processed code versions, emphasizing the simplified syntax enabled by code generation.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/about_code_generation.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n{trimSnippet(rawFetchUser)}\n```\n\nLANGUAGE: dart\nCODE:\n```\n{trimSnippet(fetchUser)}\n```\n\n----------------------------------------\n\nTITLE: Using ref.listen in Widget Build Method to React to Changes - Riverpod Dart\nDESCRIPTION: This snippet shows using 'ref.listen' in the build method of a widget, enabling the widget to react to provider changes by executing callback code. This is useful for non-UI side-effects, such as navigation or displaying messages. Requires Riverpod for Flutter. Inputs are the provider, the callback, and the build method context; outputs are the triggered side-effects when the provider changes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/reading.mdx#2025-04-23_snippet_10\n\nLANGUAGE: dart\nCODE:\n```\nclass MyWidget extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    ref.listen<SomeState>(someProvider, (previous, next) {\n      // Perform a side effect\n    });\n    return Container();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using ConsumerStatefulWidget to Read Riverpod Provider (Flutter)\nDESCRIPTION: This snippet demonstrates using `ConsumerStatefulWidget` to consume a Riverpod provider in a stateful widget. Similar to `ConsumerWidget`, it combines `StatefulWidget` and `Consumer` for direct access to the `ref` object.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/essentials/first_request.mdx#_snippet_5\n\nLANGUAGE: Flutter\nCODE:\n```\n<AutoSnippet {...consumerStatefulWidget} />\n```\n\n----------------------------------------\n\nTITLE: Avoid Performing Side Effects During Provider Initialization - Dart\nDESCRIPTION: Shows an incorrect use of Riverpod providers for performing side-effect operations such as HTTP POST requests inside provider initialization. Providers are designed for 'read' operations and using them for 'write' or side effects can cause skipped operations and unstable behavior. For handling loading and error states of side effects, other patterns should be used according to Riverpod documentation.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/essentials/do_dont.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nfinal submitProvider = FutureProvider((ref) async {\n  final formState = ref.watch(formState);\n\n  // 坏的：提供者程序不应用于“写”操作。\n  return http.post('https://my-api.com', body: formState.toJson());\n});\n```\n\n----------------------------------------\n\nTITLE: Listening to Provider Changes with ProviderContainer in Dart\nDESCRIPTION: The code demonstrates using `container.listen` to observe provider state changes during tests. This approach allows detecting and reacting to updates or events produced by providers. It is useful for verifying that provider state changes occur as expected and integrates well with mocking and assertion packages like mockito or mocktail.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/essentials/testing.mdx#_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\n\n```\n\n----------------------------------------\n\nTITLE: Defining a ChangeNotifier and ChangeNotifierProvider for Todos in Dart (Riverpod)\nDESCRIPTION: Defines a `Todo` class, a `TodoNotifier` extending `ChangeNotifier` to manage a list of `Todo` objects, and a `ChangeNotifierProvider` named `todosProvider` to expose the `TodoNotifier`. The `TodoNotifier` includes methods for adding, removing, and toggling the completion status of todos, notifying listeners upon changes. This setup allows UI components to interact with and react to changes in the todo list.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/providers/change_notifier_provider.mdx#2025-04-23_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\nimport 'package:flutter/foundation.dart';\nimport 'package:riverpod/riverpod.dart';\nimport 'package:uuid/uuid.dart';\n\nconst _uuid = Uuid();\n\n/// A read-only description of a todo-item\n@immutable\nclass Todo {\n  Todo({\n    required this.description,\n    required this.id,\n    this.completed = false,\n  });\n\n  final String id;\n  final String description;\n  final bool completed;\n\n  Todo copyWith({String? id, String? description, bool? completed}) {\n    return Todo(\n      id: id ?? this.id,\n      description: description ?? this.description,\n      completed: completed ?? this.completed,\n    );\n  }\n}\n\n/// An object that controls a list of [Todo].\nclass TodoNotifier extends ChangeNotifier {\n  final List<Todo> _todos = [];\n\n  /// An unmodifiable view of the list of todos.\n  ///\n  /// This prevents external code from modifying the list directly,\n  /// ensuring that all changes go through the exposed methods.\n  List<Todo> get todos => List.unmodifiable(_todos);\n\n  /// Adds a new todo to the list.\n  ///\n  /// Generates a unique ID for the new todo and notifies listeners.\n  void addTodo(String description) {\n    _todos.add(Todo(description: description, id: _uuid.v4()));\n    // Notify listeners that the state has changed.\n    notifyListeners();\n  }\n\n  /// Removes a todo from the list based on its ID.\n  ///\n  /// Filters out the todo with the matching ID and notifies listeners.\n  void removeTodo(String todoId) {\n    _todos.removeWhere((todo) => todo.id == todoId);\n    // Notify listeners that the state has changed.\n    notifyListeners();\n  }\n\n  /// Toggles the completion status of a specific todo.\n  ///\n  /// Finds the todo by ID, creates a new `Todo` instance with the updated\n  /// completion status, and replaces the old one. Notifies listeners.\n  void toggle(String todoId) {\n    for (var i = 0; i < _todos.length; i++) {\n      if (_todos[i].id == todoId) {\n        _todos[i] = _todos[i].copyWith(completed: !_todos[i].completed);\n        // Notify listeners that the state has changed.\n        notifyListeners();\n        return; // Exit the loop once the todo is found and updated\n      }\n    }\n  }\n}\n\n// Finally, we are using ChangeNotifierProvider to allow the UI to interact\n// with our TodoNotifier class.\nfinal todosProvider = ChangeNotifierProvider<TodoNotifier>((ref) {\n  return TodoNotifier();\n});\n\n```\n\n----------------------------------------\n\nTITLE: Passing multiple parameters to .family using Freezed (Dart)\nDESCRIPTION: This code demonstrates how to pass multiple parameters to a `.family` provider by encapsulating them within a Freezed generated class.  Requires the Freezed and Riverpod packages. Assumes the existence of a Something type.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/modifiers/family.mdx#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\n@freezed\nabstract class MyParameter with _$MyParameter {\n  factory MyParameter({\n    required int userId,\n    required Locale locale,\n  }) = _MyParameter;\n}\n\nfinal exampleProvider = Provider.autoDispose.family<Something, MyParameter>((ref, myParameter) {\n  print(myParameter.userId);\n  print(myParameter.locale);\n  // userId と locale を使って何かする\n});\n\n@override\nWidget build(BuildContext context, WidgetRef ref) {\n  int userId; // ユーザ ID をどこかで取得する\n  final locale = Localizations.localeOf(context);\n\n  final something = ref.watch(\n    exampleProvider(MyParameter(userId: userId, locale: locale)),\n  );\n\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring AsyncNotifier for immutable asynchronous state in Riverpod with Dart\nDESCRIPTION: This snippet outlines a declaration of an AsyncNotifier subclass that encapsulates asynchronous loading of a List<Todo> as immutable state within Riverpod. It includes a build method returning a Future<List<Todo>>, conforming to Riverpod's recommended pattern for managing asynchronous state with better design and fewer side effects. The snippet forms the basis for migration by replacing mutable ChangeNotifier properties with an immutable state exposed via AsyncNotifier.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/migration/from_change_notifier.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nimport declaration from \"/docs/migration/from_change_notifier/declaration\";\n```\n\n----------------------------------------\n\nTITLE: Defining Activity Model Class for Riverpod State\nDESCRIPTION: Creates an Activity class using Freezed for immutable state management and JSON serialization. The class represents activities fetched from the Bored API.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/case_studies/pull_to_refresh.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nimport 'package:freezed_annotation/freezed_annotation.dart';\n\npart 'activity.freezed.dart';\npart 'activity.g.dart';\n\n@freezed\nclass Activity with _$Activity {\n  factory Activity({\n    required String activity,\n    required String type,\n    required int participants,\n    required double price,\n  }) = _Activity;\n\n  factory Activity.fromJson(Map<String, Object?> json) =>\n      _$ActivityFromJson(json);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a FutureProvider Family in Dart\nDESCRIPTION: Shows how to define a `FutureProvider` using the `.family` modifier in Riverpod. This allows creating a provider that takes an external parameter (`id` of type `String`) to fetch specific data (a `Message`) asynchronously, likely via an HTTP request using a dependency like `dio`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/modifiers/family.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nfinal messagesFamily = FutureProvider.family<Message, String>((ref, id) async {\n  return dio.get('http://my_api.dev/messages/$id');\n});\n```\n\n----------------------------------------\n\nTITLE: Passing Multiple Parameters to a Family using Equatable in Dart\nDESCRIPTION: Example of handling multiple parameters for a Riverpod `.family` provider (`exampleProvider`) by defining a parameter class (`MyParameter`) that extends the Equatable package. This class encapsulates `userId` and `locale` and provides the necessary `hashCode` and `==` overrides required for families by implementing the `props` getter. The example shows how to instantiate the parameter class and watch the provider.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/modifiers/family.mdx#2025-04-23_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\nclass MyParameter extends Equatable  {\n  MyParameter({\n    required this.userId,\n    required this.locale,\n  });\n\n  final int userId;\n  final Locale locale;\n\n  @override\n  List<Object> get props => [userId, locale];\n}\n\nfinal exampleProvider = Provider.family<Something, MyParameter>((ref, myParameter) {\n  print(myParameter.userId);\n  print(myParameter.locale);\n  // Do something with userId/locale\n});\n\n@override\nWidget build(BuildContext context, WidgetRef ref) {\n  int userId; // Read the user ID from somewhere\n  final locale = Localizations.localeOf(context);\n\n  final something = ref.watch(\n    exampleProvider(MyParameter(userId: userId, locale: locale)),\n  );\n\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Updating ConsumerWidget and Consumer in Dart\nDESCRIPTION: Examples of updating ConsumerWidget's build method and Consumer's builder function to use WidgetRef.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/migration/0.14.0_to_1.0.0.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nclass Example extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, ScopedReader watch) {\n    int count = watch(counterProvider);\n    ...\n  }\n}\n\nConsumer(\n  builder: (context, watch, child) {\n    int count = watch(counterProvider);\n    ...\n  }\n)\n```\n\nLANGUAGE: dart\nCODE:\n```\nclass Example extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    int count = ref.watch(counterProvider);\n    ...\n  }\n}\n\nConsumer(\n  builder: (context, ref, child) {\n    int count = ref.watch(counterProvider);\n    ...\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Incorrectly Watching an Auto-Dispose Provider in Dart\nDESCRIPTION: Shows code that causes a compilation error because a non-auto-dispose provider (`secondProvider`) attempts to watch (`ref.watch`) an auto-dispose provider (`firstProvider`). This pattern is disallowed as it would prevent the auto-dispose provider from ever being disposed.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/modifiers/auto_dispose.mdx#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nfinal firstProvider = Provider.autoDispose((ref) => 0);\n\nfinal secondProvider = Provider((ref) {\n  // The argument type 'AutoDisposeProvider<int>' can't be assigned to the\n  // parameter type 'AlwaysAliveProviderBase<Object, Null>'\n  ref.watch(firstProvider);\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Migrating StreamNotifierProvider from Manual to Generated Stream Class in Dart\nDESCRIPTION: The code shows how to replace a manual stream notifier provider with a generated stream class to enhance readability and maintainability. It relies on Riverpod's notifier and stream paradigms.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/about_code_generation.mdx#_snippet_11\n\nLANGUAGE: dart\nCODE:\n```\n{trimSnippet(streamNotifierProvider)}\n```\n\n----------------------------------------\n\nTITLE: Using read instead of watch for non-reactive provider access in Dart\nDESCRIPTION: Illustrates how to read a provider without setting up automatic dependency updates by using ref.read. This approach is useful for accessing data like tokens or constants without triggering rebuilds.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#_snippet_6\n\nLANGUAGE: Dart\nCODE:\n```\nfinal userTokenProvider = StateProvider<String>((ref) => null);\n\nfinal repositoryProvider = Provider((ref) => Repository(ref.read));\n\nclass Repository {\n  Repository(this.read);\n  final Reader read;\n  Future<Catalog> fetchCatalog() async {\n    String token = read(userTokenProvider);\n    final response = await dio.get('/path', queryParameters: {\n      'token': token,\n    });\n    return Catalog.fromJson(response.data);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a FutureProvider for asynchronous configuration loading in Dart\nDESCRIPTION: This snippet demonstrates how to create a FutureProvider that loads a configuration file from assets asynchronously. It reads a JSON file, parses it, and creates a Configuration object which is then exposed through the provider.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/providers/future_provider.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n...\n```\n\n----------------------------------------\n\nTITLE: Inefficient Provider Pattern: Watching Entire Configuration Object in Dart\nDESCRIPTION: This example shows an inefficient approach where a provider watches an entire Configuration object but only uses the host property, causing unnecessary updates when other configuration properties change.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#_snippet_10\n\nLANGUAGE: dart\nCODE:\n```\nfinal configsProvider = StreamProvider<Configuration>(...);\n\nfinal productsProvider = FutureProvider<List<Product>>((ref) async {\n  // Le ProductsProvider devra récupérer les produits si \n  // un élément de la configuration change.\n  final configs = await ref.watch(configsProvider.future);\n\n  return dio.get('${configs.host}/products');\n});\n```\n\n----------------------------------------\n\nTITLE: StateNotifierProvider Declaration Before and After Update in Dart\nDESCRIPTION: Comparison of StateNotifierProvider declaration syntax before and after the 0.14.0 update, showing the addition of a generic parameter for the state type.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/migration/0.13.0_to_0.14.0.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nfinal provider = StateNotifierProvider<MyStateNotifier>((ref) {\n  return MyStateNotifier();\n});\n```\n\nLANGUAGE: dart\nCODE:\n```\nfinal provider = StateNotifierProvider<MyStateNotifier, MyModel>((ref) {\n  return MyStateNotifier();\n});\n```\n\n----------------------------------------\n\nTITLE: প্রভাইডার আপডেটের ক্ষেত্রে কনফিগারেশন পরিবর্তনের ত্রুটি এড়ানো\nDESCRIPTION: একটি ভালো অনুশীলন দেখানো হয়েছে, যেখানে সম্পূর্ণ কনফিগারেশন বস্তু নয়, নির্দিষ্ট অংশ যেমন `host` কে আলাদা প্রোভাইডার করে উপযুক্ত স্পর্শকাতরতা কমানো যায়। এটি মূল প্রোভাইডার পুনরায় মূল্যায়ন থেকে বিরত রাখে এবং পার্সোনাল পার্টের উপর ভিত্তি করে কার্যক্ষমতা বৃদ্ধি করে।\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/bn/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nfinal configsProvider = StreamProvider<Configuration>(...);\n\nfinal _hostProvider = FutureProvider<String>((ref) async {\n  final config = await ref.watch(configsProvider.future);\n  return config.host;\n});\n\nfinal productsProvider = FutureProvider<List<Product>>((ref) async {\n  final host = await ref.watch(_hostProvider.future);\n  return dio.get('$host/products');\n});\n```\n\n----------------------------------------\n\nTITLE: New syntax for declaring a StateNotifierProvider with explicit state type in Dart\nDESCRIPTION: Declares a StateNotifierProvider for MyStateNotifier with explicit specification of both the notifier and state types, aligning with Riverpod 0.14.0 standards.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_2\n\nLANGUAGE: Dart\nCODE:\n```\nfinal provider = StateNotifierProvider<MyStateNotifier, MyModel>((ref) {\n  return MyStateNotifier();\n});\n```\n\n----------------------------------------\n\nTITLE: Using a family Provider with Parameter in a Flutter Widget (Dart)\nDESCRIPTION: This code illustrates how to consume a family provider inside a Flutter widget's build method. It shows that when using a provider defined with .family, a parameter must be passed to retrieve the provider instance. The example highlights the incorrect usage that omits the parameter and the correct usage that provides an 'id' to ref.watch.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/de/docusaurus-plugin-content-docs/current/concepts/modifiers/family.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, WidgetRef ref) {\n  // Error – messagesFamily is not a provider\n  final response = ref.watch(messagesFamily);\n}\n```\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, WidgetRef ref) {\n  final response = ref.watch(messagesFamily('id'));\n}\n```\n\n----------------------------------------\n\nTITLE: Watching multiple Family Providers with different parameters in Dart\nDESCRIPTION: Shows how to simultaneously consume multiple instances of a family provider with different parameters, here using Locale for translations. This allows widgets to react to multiple localized values concurrently, demonstrating flexibility in parameter usage with .family providers.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/concepts/modifiers/family.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n@override\nWidget build(BuildContext context, WidgetRef ref) {\n  final frenchTitle = ref.watch(titleFamily(const Locale('fr')));\n  final englishTitle = ref.watch(titleFamily(const Locale('en')));\n\n  return Text('fr: $frenchTitle en: $englishTitle');\n}\n```\n\n----------------------------------------\n\nTITLE: Using HookConsumerWidget for Combined Hook and Provider Usage in Flutter\nDESCRIPTION: This example shows how to use HookConsumerWidget, which allows the use of both flutter_hooks and Riverpod providers in the same widget, combining the functionality of HookWidget and ConsumerWidget.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/first_request.mdx#2025-04-23_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\nclass Example extends HookConsumerWidget {\n  const Example({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final counter = useState(0);\n    final activity = ref.watch(activityProvider);\n    return switch (activity) {\n      AsyncData(:final value) => Text(value.activity),\n      AsyncError() => const Text('Oops, something unexpected happened'),\n      _ => const CircularProgressIndicator(),\n    };\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling complex provider values: listening to StreamProvider in Dart Riverpod\nDESCRIPTION: This snippet explains how to interact with a StreamProvider of type User by using ref.watch to access different representations: the current AsyncValue's data, the underlying stream, or a future that resolves with the latest emitted value. This allows flexible UI reactions to provider data, error states, or loading indicators.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/es/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_4\n\nLANGUAGE: Dart\nCODE:\n```\nfinal userProvider = StreamProvider<User>(...);\n\n// Listening to the current AsyncValue state for UI updates:\nWidget build(BuildContext context, WidgetRef ref) {\n  AsyncValue<User> user = ref.watch(userProvider);\n\n  return user.when(\n    loading: () => const CircularProgressIndicator(),\n    error: (error, stack) => const Text('Oops'),\n    data: (user) => Text(user.name),\n  );\n}\n\n// Accessing the stream directly:\nWidget build(BuildContext context, WidgetRef ref) {\n  Stream<User> userStream = ref.watch(userProvider.stream);\n  // Use the stream as needed\n}\n\n// Accessing the latest future value:\nWidget build(BuildContext context, WidgetRef ref) {\n  Future<User> userFuture = ref.watch(userProvider.future);\n  // Use the future as needed\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering with Loading Spinner and Error Handling (Italian)\nDESCRIPTION: This snippet renders a button and shows a loading spinner while the add operation is in progress. If the operation fails, the button turns red to indicate an error. This can be achieved using flutter_hooks or a StatefulWidget. The snippet focuses on providing visual feedback to the user during the POST request.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/essentials/side_effects.mdx#_snippet_8\n\nLANGUAGE: dart\nCODE:\n```\nrenderAddTodo\n```\n\n----------------------------------------\n\nTITLE: Building UI for Search-as-you-type in Flutter\nDESCRIPTION: This code snippet shows the complete implementation of the search-as-you-type UI, including the search field and the list of results using Riverpod's Consumer widget.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/de/docusaurus-plugin-content-docs/current/cookbooks/search_as_we_type.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nclass MyHomePage extends ConsumerWidget {\n  const MyHomePage({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final questions = ref.watch(questionsProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Questions')),\n      body: Column(\n        children: [\n          TextField(\n            onChanged: (value) =>\n                ref.read(searchFieldProvider.notifier).state = value,\n          ),\n          Expanded(\n            child: questions.when(\n              loading: () => const Center(child: CircularProgressIndicator()),\n              error: (error, stack) => Center(child: Text('Error $error')),\n              data: (questions) {\n                return ListView.builder(\n                  itemCount: questions.length,\n                  itemBuilder: (context, index) {\n                    final question = questions[index];\n\n                    return ListTile(\n                      title: Text(\n                        question.toString(),\n                      ),\n                    );\n                  },\n                );\n              },\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using the Debounce and Cancel Extension within Riverpod Providers (Dart)\nDESCRIPTION: This example applies the Ref extension for debouncing and cancelling to an actual Riverpod provider, showcasing how to reduce repetitive logic in the codebase. The provider waits for the debounce interval, aborts appropriately on provider disposal, and performs the network request securely. Dependencies: flutter_riverpod, custom ref extension. Inputs: provider lifecycle events, user interactions; outputs: optimized network requests limited by debounce and lifecycle events. Limitation: Provider code must use the extension and handle exceptions as per design.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/case_studies/cancel.mdx#_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\n/* code from providerWithExtension */\n```\n\n----------------------------------------\n\nTITLE: Defining a Provider with Arguments (no code-gen)\nDESCRIPTION: This snippet demonstrates how to define a Riverpod provider that accepts arguments using the `.family` modifier. The provider's type is followed by `.family` and an additional type parameter corresponding to the argument type, in this case, `String`. The provider then receives the argument as `ref` in the build method. The code is based on the context with the `codegen={false}` condition.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/essentials/passing_args.mdx#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\n// \"함수형\" provider\n\n// \"family\" 한정자를 사용합니다.\n// \"문자열\" 일반 유형은 인자 유형에 해당합니다.\n// 이제 provider는 \"ref\" 위에 활동 유형이라는 추가 인수를 받습니다.\n```\n\n----------------------------------------\n\nTITLE: Gestione di Provider Multipli dello Stesso Tipo in Riverpod\nDESCRIPTION: Illustra come Riverpod possa gestire senza problemi più provider dello stesso tipo, eliminando una limitazione presente in Provider basato su InheritedWidget. Questo permette di suddividere liberamente la logica in parti più piccole.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/from_provider/motivation/motivation.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n// Code imported from /docs/from_provider/motivation/same_type\n// Placeholder: Actual code snippet not provided in the input text.\n// Example demonstrating multiple providers of the same type.\n```\n\n----------------------------------------\n\nTITLE: Gestione degli Effetti Collaterali in Riverpod\nDESCRIPTION: Mostra come utilizzare ref.listen in Riverpod per reagire ai cambiamenti di stato ed eseguire effetti collaterali, come la navigazione o la visualizzazione di snackbar. Questo risolve una limitazione di Provider, che manca di un callback onChange affidabile.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/from_provider/motivation/motivation.mdx#_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\n// Code imported from /docs/from_provider/motivation/side_effects\n// Placeholder: Actual code snippet not provided in the input text.\n// Example using ref.listen to trigger side effects based on state changes.\n```\n\n----------------------------------------\n\nTITLE: Consuming .family Providers with Multiple Parameters Using Freezed (Dart)\nDESCRIPTION: This advanced snippet demonstrates how to use Freezed to define an immutable parameter object encapsulating multiple values (userId and locale), ensuring proper equality and hash semantics. The provider, exampleProvider, is defined using Provider.autoDispose.family, taking MyParameter as its argument. The build method shows how to construct and pass a composite parameter to the provider. Requires Riverpod, Freezed, and Flutter's Locale. Expected input is a MyParameter instance; output is a provided value of type Something.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/modifiers/family.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\n@freezed\nabstract class MyParameter with _$MyParameter {\n  factory MyParameter({\n    required int userId,\n    required Locale locale,\n  }) = _MyParameter;\n}\n\nfinal exampleProvider = Provider.autoDispose.family<Something, MyParameter>((ref, myParameter) {\n  print(myParameter.userId);\n  print(myParameter.locale);\n  // Do something with userId/locale\n});\n\n@override\nWidget build(BuildContext context, WidgetRef ref) {\n  int userId; // Read the user ID from somewhere\n  final locale = Localizations.localeOf(context);\n\n  final something = ref.watch(\n    exampleProvider(MyParameter(userId: userId, locale: locale)),\n  );\n\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Logging Provider State Updates Using Riverpod in Dart\nDESCRIPTION: Defines a Logger class that extends Riverpod's ProviderObserver to override the didUpdateProvider method, capturing and printing a JSON-formatted log whenever a provider's value changes. The snippet shows how to integrate this observer into a Flutter application by adding it to ProviderScope observers, enabling real-time logging of provider updates. Dependencies include Flutter and Riverpod packages, with key parameters involving the provider instance, previous and new values, and the provider container. Expected input is any provider update, and output is a console log of the new state. This approach facilitates debugging and monitoring state changes in a reactive manner without modifying the provider logic directly.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/tr/docusaurus-plugin-content-docs/current/concepts/provider_observer.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n// Riverpod ile uygulanan bir Counter Logger örneği\n\nclass Logger extends ProviderObserver {\n  @override\n  void didUpdateProvider(\n    ProviderBase provider,\n    Object? previousValue,\n    Object? newValue,\n    ProviderContainer container,\n  ) {\n    print('''\n{\n  \"provider\": \"${provider.name ?? provider.runtimeType}\",\n  \"newValue\": \"$newValue\"\n}''');\n  }\n}\n\nvoid main() {\n  runApp(\n    // ProviderScope'un eklenmesi Riverpod'un tüm proje için etkinleştirilmesini sağlar\n    // Logger'ımızı gözlemci listesine ekliyoruz\n    ProviderScope(observers: [Logger()], child: MyApp()),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(home: Home());\n  }\n}\n\nfinal counterProvider = StateProvider((ref) => 0, name: 'counter');\n\nclass Home extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final count = ref.watch(counterProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Counter example')),\n      body: Center(\n        child: Text('$count'),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => ref.read(counterProvider.notifier).state++,\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing StateNotifierProvider (Pre-0.14.0) in Riverpod (Dart)\nDESCRIPTION: Demonstrates the old way to declare a StateNotifierProvider before Riverpod 0.14.0, using a single generic parameter. The provider exposes an instance of MyStateNotifier. Requires riverpod version ^0.13.0 and a properly set up MyStateNotifier class.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nfinal provider = StateNotifierProvider<MyStateNotifier>((ref) {\n  return MyStateNotifier();\n});\n```\n\n----------------------------------------\n\nTITLE: Manually Updating Local Cache in Dart\nDESCRIPTION: This snippet shows how to manually update the local cache after a POST request. It adds the new todo item to the existing list of todos.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/side_effects.mdx#2025-04-23_snippet_7\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet raw={manualAddTodo} />\n```\n\n----------------------------------------\n\nTITLE: Provider to Mock Example - Dart\nDESCRIPTION: This snippet provides the definition of a provider that is used as an example to demonstrate the mocking technique. It showcases the provider's structure and type, and serves as a starting point for creating mock implementations. Dependencies: Riverpod.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/essentials/testing.mdx#_snippet_6\n\nLANGUAGE: Dart\nCODE:\n```\nfinal myProvider = Provider((ref) => MyClass());\n```\n\n----------------------------------------\n\nTITLE: HookConsumer Widget'ı ile Sağlayıcılara Erişme (Dart)\nDESCRIPTION: Bu kod, widget ağacının içine bir HookConsumer widget'ının nasıl yerleştirileceğini gösterir. Oluşturucu işlevi bir 'ref' nesnesi sağlar ve hem kancaların ('useState') hem de sağlayıcı okumalarının ('ref.watch') ayrı bir ConsumerWidget sınıfı tanımlamadan birlikte kullanılmasına olanak tanır.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/tr/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nScaffold(\n  body: HookConsumer(\n    builder: (context, ref, child) {\n      // HookConsumerWidget gibi, oluşturucunun içinde kancalar kullanabiliriz.\n      final state = useState(0);\n\n      // Provider'ları dinlemek için ref parametresini de kullanabiliriz.\n      final counter = ref.watch(counterProvider);\n      return Text('$counter');\n    },\n  ),\n)\n```\n\n----------------------------------------\n\nTITLE: Simplified Provider Overriding with FutureProvider\nDESCRIPTION: Example of how FutureProvider allows simpler overriding with an AsyncValue, making it easier to simulate loading states or provide predefined data for tests.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/cookbooks/testing.mdx#2025-04-23_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nfinal todoListProvider = FutureProvider((ref) async {\n  // ...\n});\n\n// Later in tests\nvoid main() {\n  testWidgets('override with AsyncValue', (tester) async {\n    await tester.pumpWidget(\n      ProviderScope(\n        overrides: [\n          // Overrides the provider to returns a predefined value\n          todoListProvider.overrideWithValue(\n            AsyncValue.data([Todo(id: '42', label: 'Hello world')]),\n          ),\n        ],\n        child: MyApp(),\n      ),\n    );\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating from FutureProvider to Code Generation (Dart)\nDESCRIPTION: This snippet shows the 'before' state using a non-code-generation `FutureProvider`. The 'after' state uses an asynchronous (Future) functional provider with code generation.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/about_code_generation.mdx#_snippet_13\n\nLANGUAGE: dart\nCODE:\n```\n{trimSnippet(futureProvider)}\n```\n\n----------------------------------------\n\nTITLE: Obtaining ref in StatefulHookConsumerWidget (with flutter_hooks) - Riverpod Dart\nDESCRIPTION: This snippet demonstrates using StatefulHookConsumerWidget, allowing widgets to access both StatefulWidget lifecycle methods and hooks, as well as consume providers through the 'ref' property. Required dependencies are Riverpod, flutter_hooks, and hooks_riverpod. The main inputs are the build context and the state instance with access to 'ref'; output is a widget tree that combines hooks, stateful features, and provider state.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/reading.mdx#2025-04-23_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nclass MyStatefulHookConsumerWidget extends StatefulHookConsumerWidget {\n  const MyStatefulHookConsumerWidget({Key? key}) : super(key: key);\n\n  @override\n  ConsumerState<MyStatefulHookConsumerWidget> createState() => _MyStatefulHookConsumerWidgetState();\n}\n\nclass _MyStatefulHookConsumerWidgetState extends ConsumerState<MyStatefulHookConsumerWidget> with Hooks {\n  @override\n  Widget build(BuildContext context) {\n    final value = ref.watch(myProvider);\n    final controller = useTextEditingController();\n    return TextField(controller: controller, decoration: InputDecoration(helperText: '$value'));\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Simplifying Testing with Provider Overrides in Riverpod (Dart)\nDESCRIPTION: This placeholder represents a Dart code snippet showing how Riverpod simplifies unit and widget testing. It highlights the ease of overriding providers within a test scope to mock dependencies or provide specific states, reducing boilerplate compared to testing setups required for Provider.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/from_provider/motivation/motivation.mdx#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet language=\"dart\" {...override}></AutoSnippet>\n```\n\n----------------------------------------\n\nTITLE: Using .family with Multiple Parameters - Dart\nDESCRIPTION: This example shows how to use a `family` provider with different parameters simultaneously. It fetches titles in French and English using `Locale` objects as parameters. Demonstrates that multiple parameters can be passed at the same time.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/bn/docusaurus-plugin-content-docs/current/concepts/modifiers/family.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n@override\nWidget build(BuildContext context, WidgetRef ref) {\n  final frenchTitle = ref.watch(titleFamily(const Locale('fr')));\n  final englishTitle = ref.watch(titleFamily(const Locale('en')));\n\n  return Text('fr: $frenchTitle en: $englishTitle');\n}\n```\n\n----------------------------------------\n\nTITLE: Using .autoDispose with StreamProvider in Dart\nDESCRIPTION: This snippet shows the basic syntax for applying the `.autoDispose` modifier to a `StreamProvider` in Riverpod. This ensures the provider's state is automatically destroyed when it's no longer being listened to. Note the generic type `User` is passed after `.autoDispose`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/modifiers/auto_dispose.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nfinal userProvider = StreamProvider.autoDispose<User>((ref) {\n\n});\n```\n\n----------------------------------------\n\nTITLE: Accessing StateNotifier (After) in Dart\nDESCRIPTION: This code snippet demonstrates accessing the `StateNotifier` instance after the 0.14.0 update. It uses `watch(provider.notifier)` to obtain the `MyStateNotifier` instance within a `build` method. Requires `riverpod`, `BuildContext`, and `ScopedReader`. The output is the `MyStateNotifier` instance.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, ScopedReader watch) {\n  MyStateNotifier notifier = watch(provider.notifier);\n}\n```\n\n----------------------------------------\n\nTITLE: Multiple Dependencies with One Used\nDESCRIPTION: Test case showing multiple dependencies where one is unused\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/provider_dependencies/unused_dependency_lint.md#2025-04-23_snippet_8\n\nLANGUAGE: dart\nCODE:\n```\n// expect_lint: provider_dependencies\n@Dependencies([dep2, dep])\nvoid secondUnused() {\n  dep2Provider;\n```\n\n----------------------------------------\n\nTITLE: Initializing Ref in Notifier Class Providers using JavaScript/TypeScript\nDESCRIPTION: Shows accessing the Ref object as a property of a Notifier class instance in class-based provider implementations. This snippet provides context on using Ref to retrieve and manipulate other providers' states, enabling reactive programming patterns in Riverpod using JavaScript/TypeScript.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/essentials/combining_requests.mdx#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\n    // \"Ref\"를 사용하여 다른 providers를 읽을 수 있습니다.\n```\n\n----------------------------------------\n\nTITLE: Using multiple provider instances for different arguments to fetch distinct data\nDESCRIPTION: This snippet demonstrates listening to multiple instances of a parameterized provider, each with different arguments to simultaneously request and display different data, such as multiple activity categories.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/essentials/passing_args.mdx#_snippet_3\n\nLANGUAGE: Dart\nCODE:\n```\n// Listening to provider with 'recreational' activity type\nfinal recreationalActivity = ref.watch(activityProvider('recreational'));\n// Listening to provider with 'cooking' activity type\nfinal cookingActivity = ref.watch(activityProvider('cooking'));\n```\n\n----------------------------------------\n\nTITLE: Using ref.read for User Interactions\nDESCRIPTION: Shows how to use ref.read to access provider state without listening to it, typically used for handling user interactions like button clicks.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/reading.mdx#2025-04-23_snippet_8\n\nLANGUAGE: dart\nCODE:\n```\nclass HomeScreen extends ConsumerWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    return Scaffold(\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            // Using the provider immediately, but not listening to it\n            ref.read(counterProvider.notifier).increment();\n          },\n          child: const Text('Increment'),\n        ),\n      ),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: FadeIn Widget with StatefulWidget - Flutter\nDESCRIPTION: This code demonstrates implementing a fade-in animation using a StatefulWidget in Flutter. It involves creating a custom StatefulWidget, an AnimationController for managing the animation, and an AnimatedBuilder to rebuild the widget on animation updates. The animation starts in the initState method and is disposed of in the dispose method to prevent memory leaks.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/about_hooks.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nclass FadeIn extends StatefulWidget {\n  const FadeIn({Key? key, required this.child}) : super(key: key);\n\n  final Widget child;\n\n  @override\n  State<FadeIn> createState() => _FadeInState();\n}\n\nclass _FadeInState extends State<FadeIn> with SingleTickerProviderStateMixin {\n  late final AnimationController animationController = AnimationController(\n    vsync: this,\n    duration: const Duration(seconds: 2),\n  );\n\n  @override\n  void initState() {\n    super.initState();\n    animationController.forward();\n  }\n\n  @override\n  void dispose() {\n    animationController.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return AnimatedBuilder(\n      animation: animationController,\n      builder: (context, child) {\n        return Opacity(\n          opacity: animationController.value,\n          child: widget.child,\n        );\n      },\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Code Generation Notifier Pattern\nDESCRIPTION: Shows the syntax for defining a Notifier using Riverpod's code generation approach with the @riverpod annotation.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/side_effects.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\nclass MyNotifier extends _$MyNotifier {\n  @override\n  Result build() {\n    <your logic here>\n  }\n\n  <your methods here>\n}\n```\n\n----------------------------------------\n\nTITLE: Running development server for Korean locale with yarn\nDESCRIPTION: This command starts a development server for the Korean locale, allowing real-time testing and editing of Korean documents within the project. It requires the previously generated i18n files and helps verify translations during development.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/NOTE.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n# website/i18n/ko/ 폴더에서 문서수정\n# 한국어 문서 실행하고, 최초실행시 import 폴더 구조가 안맞는 것 맞추기\n\nyarn run dev --locale ko\n```\n\n----------------------------------------\n\nTITLE: Defining a FutureProvider Family in Dart\nDESCRIPTION: Shows how to define a `FutureProvider` using the `.family` modifier in Riverpod. This example creates a provider `messagesFamily` that takes a `String` ID as a parameter and asynchronously fetches a `Message` object, likely via an HTTP request using a `dio` instance.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/modifiers/family.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nfinal messagesFamily = FutureProvider.family<Message, String>((ref, id) async {\n  return dio.get('http://my_api.dev/messages/$id');\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Consuming Multiple Instances of a family Provider with Different Parameters in Dart/Flutter\nDESCRIPTION: This snippet demonstrates how to consume a family provider multiple times with different parameters simultaneously. It reads translated titles for French and English locales using a 'titleFamily' provider, showing usage in a Flutter widget build method. This allows retrieval of localized data based on the Locale parameter.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/de/docusaurus-plugin-content-docs/current/concepts/modifiers/family.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n@override\nWidget build(BuildContext context, WidgetRef ref) {\n  final frenchTitle = ref.watch(titleFamily(const Locale('fr')));\n  final englishTitle = ref.watch(titleFamily(const Locale('en')));\n\n  return Text('fr: $frenchTitle en: $englishTitle');\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Generator Provider with Numeric Parameters\nDESCRIPTION: Test cases for generator provider using numeric array parameters to validate consistency checks.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/provider_parameters/provider_parameters_lint.md#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n    ref.watch(generatorProvider(value: 42));\n    // expect_lint: provider_parameters\n    ref.watch(generatorProvider(value: [42]));\n    // expect_lint: provider_parameters\n    ref.watch(generatorProvider(value: {'string': 42}));\n```\n\n----------------------------------------\n\nTITLE: Using ref.keepAlive with FutureProvider.autoDispose in Dart\nDESCRIPTION: Illustrates how to use `ref.keepAlive()` within a `FutureProvider.autoDispose`. Calling `ref.keepAlive()` prevents the provider's state from being disposed even if it loses all its listeners, typically used after a successful asynchronous operation like an HTTP request.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/concepts/modifiers/auto_dispose.mdx#_snippet_2\n\nLANGUAGE: Dart\nCODE:\n```\nfinal myProvider = FutureProvider.autoDispose((ref) async {\n  final response = await httpClient.get(...);\n  ref.keepAlive();\n  return response;\n});\n```\n\n----------------------------------------\n\nTITLE: Using onDispose to Close StreamController in Dart with Riverpod\nDESCRIPTION: A code example demonstrating how to use the onDispose lifecycle method to properly clean up resources when a provider is disposed. This example specifically shows closing a StreamController when the provider is no longer needed.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/concepts/provider_lifecycles.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nfinal provider = StreamProvider.autoDispose((ref) {\n  // Créer un StreamController qui sera fermé lorsque ce provider sera libéré\n  final controller = StreamController<int>();\n  \n  // Lorsque le provider est libéré, fermer le StreamController\n  ref.onDispose(() {\n    controller.close();\n  });\n\n  return controller.stream;\n});\n```\n\n----------------------------------------\n\nTITLE: Add hooks_riverpod dependency to pubspec.yaml\nDESCRIPTION: This YAML snippet adds the `hooks_riverpod` dependency to your `pubspec.yaml` file, along with the required Flutter and Dart SDK versions.  It is intended for Flutter projects that also use `flutter_hooks`. After adding this snippet, run `pub get` in your terminal to install the dependency.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/bn/docusaurus-plugin-content-docs/current/getting_started.mdx#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nenvironment:\n  sdk: \">=2.12.0 <4.0.0\"\n  flutter: \">=2.0.0\"\n\ndependencies:\n  flutter:\n    sdk: flutter\n  flutter_hooks:\n  hooks_riverpod: ^1.0.0-dev.11\n```\n\n----------------------------------------\n\nTITLE: Updating State with API Response in Riverpod (Italian)\nDESCRIPTION: This snippet demonstrates how to update the Riverpod state directly with the response received from a POST API request. This approach relies on the server returning the updated state of the resource.  It is efficient but depends on specific server implementations.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/essentials/side_effects.mdx#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nrestAddTodo\n```\n\n----------------------------------------\n\nTITLE: NotifierProvider Migration\nDESCRIPTION: Demonstrates migration from NotifierProvider to code-generated class-based provider. The new syntax uses @riverpod annotation with a class implementation.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/about_code_generation.mdx#2025-04-23_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\nfinal counterProvider = NotifierProvider<Counter, int>(() => Counter());\n\nclass Counter extends Notifier<int> {\n  @override\n  int build() => 0;\n}\n```\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\nclass Counter extends _$Counter {\n  @override\n  int build() => 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Identifying Incomplete Dependencies in Riverpod Provider (Dart)\nDESCRIPTION: This snippet shows a Riverpod provider with incomplete dependencies. It declares one dependency but watches two providers, leading to a missing dependency warning.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/provider_dependencies/missing_dependencies2_lint.md#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n@Riverpod(dependencies: [dep])\nint watchGeneratedScopedButMissingDependencies(\n  Ref ref,\n) {\n  ref.watch(depProvider);\n  return ref.watch(generatedScopedProvider);\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Riverpod CLI - Shell\nDESCRIPTION: This command installs the Riverpod command-line interface (CLI) globally using the `dart pub global activate` command. This tool is used to automate the migration from older Riverpod versions to the new syntax.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\ndart pub global activate riverpod_cli\n```\n\n----------------------------------------\n\nTITLE: Demonstrating flawed ChangeNotifier implementation in Dart\nDESCRIPTION: This snippet presents an example of a ChangeNotifier-based class in Dart managing a list of todos with mutable state variables such as isLoading and hasError. It exemplifies common design issues like cumbersome try/catch/finally usage, manual notifyListeners calls for state updates, and inconsistent state initialization. The code serves to highlight challenges faced by developers with ChangeNotifier, particularly in handling asynchronous states and side effects, and sets the stage for migrating to AsyncNotifier.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/migration/from_change_notifier.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nimport old from \"!!raw-loader!/docs/migration/from_change_notifier/old.dart\";\n```\n\n----------------------------------------\n\nTITLE: Updating StateNotifierProvider Definition in Dart\nDESCRIPTION: Shows how to update the provider definition to include the additional generic parameter that specifies the state type of the StateNotifier.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/es/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nfinal provider = StateNotifierProvider<MyStateNotifier>((ref) {\n  return MyStateNotifier();\n});\n```\n\nLANGUAGE: dart\nCODE:\n```\nfinal provider = StateNotifierProvider<MyStateNotifier, MyModel>((ref) {\n  return MyStateNotifier();\n});\n```\n\n----------------------------------------\n\nTITLE: Using AsyncValue.requireValue for Simplified State Handling in Riverpod (Dart)\nDESCRIPTION: This snippet demonstrates how to simplify state management by using AsyncValue.requireValue, which fetches the data directly and throws an exception if there's an error. It reduces boilerplate code for handling loading and error states in widgets observing providers.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/essentials/eager_initialization.mdx#_snippet_2\n\nLANGUAGE: Dart\nCODE:\n```\n<AutoSnippet {...requireValue} />\n```\n\n----------------------------------------\n\nTITLE: Defining an Async Character Provider with Watch in Dart\nDESCRIPTION: Defines a Riverpod `FutureProvider` named `charactersProvider` that fetches characters based on configurations and a search query (providers assumed defined elsewhere). It uses `ref.watch` to listen to both `searchQueryProvider` and `configsProvider`. This demonstrates combining multiple dependencies, including futures/async values, and automatically re-fetching when any dependency changes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nfinal charactersProvider = FutureProvider(FutureProvider((ref) async {\n  // Read the query and the configurations from other providers\n  final searchQuery = ref.watch(searchQueryProvider);\n  // We are using `watch` on a FutureProvider. This is fine.\n  final configs = await ref.watch(configsProvider.future);\n\n  // We can then use those values to fetch the characters.\n  return dio.get(\n    '${configs.host}/characters?q=$searchQuery',\n  );\n}));\n```\n\n----------------------------------------\n\nTITLE: Using ref.watch From 0.6.0 (Replacing dependOn) (Dart)\nDESCRIPTION: Shows the replacement for `ref.dependOn` introduced in Riverpod 0.6.0. Use `ref.watch` combined with specific properties like `.last` (for StreamProvider) to achieve the same result of depending on derived states.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod/CHANGELOG.md#2025-04-23_snippet_15\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nfinal streamProvider = StreamProvider<T>(...);\nfinal example = Provider((ref) {\n  Future<T> last = ref.watch(streamProvider.last);\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Using select to watch specific property in Dart build method\nDESCRIPTION: This snippet demonstrates the use of select to watch only the name property of a User object, optimizing rebuilds in a Flutter widget.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/reading.mdx#2025-04-23_snippet_10\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, WidgetRef ref) {\n  String name = ref.watch(userProvider.select((user) => user.name));\n  return Text(name);\n}\n```\n\n----------------------------------------\n\nTITLE: Combining Providers in Riverpod\nDESCRIPTION: Demonstrates how Riverpod simplifies combining providers using ref.watch, which is more reliable and easier than Provider's ProxyProvider.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/from_provider/motivation/motivation.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nfinal allItemsProvider = Provider<List<Item>>((ref) {\n  final odd = ref.watch(oddItemsProvider);\n  final even = ref.watch(evenItemsProvider);\n  return [...odd, ...even];\n});\n```\n\n----------------------------------------\n\nTITLE: Passing Multiple Parameters to Riverpod Family using Equatable in Dart\nDESCRIPTION: Shows an alternative method for passing multiple parameters (`userId`, `locale`) to a Riverpod `.family` provider using a class (`MyParameter`) that extends the Equatable package. This ensures proper `==` and `hashCode` implementation, crucial for families. An instance of this class is passed to `exampleProvider` when watched.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/modifiers/family.mdx#2025-04-23_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nclass MyParameter extends Equatable  {\n  MyParameter({\n    required this.userId,\n    required this.locale,\n  });\n\n  final int userId;\n  final Locale locale;\n\n  @override\n  List<Object> get props => [userId, locale];\n}\n\nfinal exampleProvider = Provider.family<Something, MyParameter>((ref, myParameter) {\n  print(myParameter.userId);\n  print(myParameter.locale);\n  // Do something with userId/locale\n});\n\n@override\nWidget build(BuildContext context, WidgetRef ref) {\n  int userId; // Read the user ID from somewhere\n  final locale = Localizations.localeOf(context);\n\n  final something = ref.watch(\n    exampleProvider(MyParameter(userId: userId, locale: locale)),\n  );\n\n  ...\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a Provider.family with an Equatable Class Parameter in Dart\nDESCRIPTION: This snippet defines a class MyParameter extending Equatable that encapsulates a userId and a locale. This class overrides props for equality checks, making it suitable for use as a parameter in a Provider.family. The provider consumes an instance of MyParameter, and the widget passes a constructed object to retrieve the provider data.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/de/docusaurus-plugin-content-docs/current/concepts/modifiers/family.mdx#_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nclass MyParameter extends Equatable  {\n  MyParameter({\n    required this.userId,\n    required this.locale,\n  });\n\n  final int userId;\n  final Locale locale;\n\n  @override\n  List<Object> get props => [userId, locale];\n}\n\nfinal exampleProvider = Provider.family<Something, MyParameter>((ref, myParameter) {\n  print(myParameter.userId);\n  print(myParameter.locale);\n  // Benutze userId/locale\n});\n\n@override\nWidget build(BuildContext context, WidgetRef ref) {\n  int userId; // Lesen Sie die Benutzer-ID von irgendwoher\n  final locale = Localizations.localeOf(context);\n\n  final something = ref.watch(\n    exampleProvider(MyParameter(userId: userId, locale: locale)),\n  );\n\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring pubspec.yaml for Flutter Riverpod\nDESCRIPTION: Shows how to add Flutter Riverpod as a dependency in the `pubspec.yaml` file for a Flutter project. This involves adding the `flutter_riverpod` package under the `dependencies` section.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/introduction/getting_started.mdx#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\ndependencies:\n  flutter_riverpod: ^2.0.0\n```\n\n----------------------------------------\n\nTITLE: Consuming Filtered Todos in a Flutter Widget\nDESCRIPTION: This Dart code snippet demonstrates a Flutter `ConsumerWidget` that listens to `completedTodosProvider`. It uses `ref.watch` to get the list of completed todos and displays the count in a `Text` widget. The widget rebuilds only when the filtered list provided by `completedTodosProvider` changes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/providers/provider.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nclass TodoListView extends ConsumerWidget {\n  const TodoListView({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // The list of completed todos\n    // We don't care about the list of all todos\n    List<Todo> completedTodos = ref.watch(completedTodosProvider);\n\n    return ListView(\n      children: [\n        for (final todo in completedTodos) Text(todo.description),\n      ],\n    );\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Consuming Filtered Todos in UI using ConsumerWidget in Dart\nDESCRIPTION: Shows how to use a ConsumerWidget to display the list of completed todos in the UI.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/bn/docusaurus-plugin-content-docs/current/providers/provider.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nclass CompletedTodos extends ConsumerWidget {\n  const CompletedTodos({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final completedTodos = ref.watch(completedTodosProvider);\n    return ListView(\n      children: [\n        for (final todo in completedTodos)\n          CheckboxListTile(\n            value: todo.completed,\n            onChanged: (value) => ref.read(todoListProvider.notifier).toggleTodo(todo.id),\n            title: Text(todo.description),\n          ),\n      ],\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ProviderObserver Class in Dart\nDESCRIPTION: This code snippet defines a custom `ProviderObserver` class.  It involves extending the base class and overriding methods like `didAddProvider`, `didUpdateProvider`, `didDisposeProvider`, and `providerDidFail` to listen to specific events in the provider tree.  These methods allow you to react to the addition, update, disposal, and failure of providers. There are no direct dependencies, but it relies on the Riverpod framework.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/essentials/provider_observer.mdx#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass MyObserver extends ProviderObserver {\n  @override\n  void didAddProvider(\n    ProviderBase provider,\n    Object? value,\n    ProviderContainer container,\n  ) {\n    // Called when a provider is added to the provider tree.\n  }\n\n  @override\n  void didUpdateProvider<\n    T,\n  >(ProviderBase<T> provider,\n    T? previousValue,\n    T newValue,\n    ProviderContainer container,\n  ) {\n    // Called when a provider is updated.\n  }\n\n  @override\n  void didDisposeProvider(ProviderBase provider, ProviderContainer container) {\n    // Called when a provider is disposed of.\n  }\n\n  @override\n  void providerDidFail(\n    ProviderBase provider,\n    Object error,\n    StackTrace stackTrace,\n    ProviderContainer container,\n  ) {\n    // Called when a provider throws an error.\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Hello World Example with Riverpod in Flutter\nDESCRIPTION: This snippet shows a basic 'Hello World' example using Riverpod in a Flutter application. It demonstrates how to set up a provider and use it in a widget.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/introduction/getting_started.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// We create a \"provider\", which will store a value (here \"Hello world\").\n// By using a provider, this allows us to mock/override the value exposed.\nfinal helloWorldProvider = Provider((_) => 'Hello world');\n\nvoid main() {\n  runApp(\n    // For widgets to be able to read providers, we need to wrap the entire\n    // application in a \"ProviderScope\" widget.\n    // This is where the state of our providers will be stored.\n    ProviderScope(\n      child: MyApp(),\n    ),\n  );\n}\n\n// Extend ConsumerWidget instead of StatelessWidget, which is exposed by Riverpod\nclass MyApp extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final String value = ref.watch(helloWorldProvider);\n\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Example')),\n        body: Center(\n          child: Text(value),\n        ),\n      ),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using SelectAsync for Asynchronous Properties in Riverpod (Dart)\nDESCRIPTION: This snippet illustrates the usage of 'selectAsync' in Riverpod for optimizing asynchronous providers. It shows how to select and watch specific properties from an asynchronous User provider, returning a Future of the selected property.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/advanced/select.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nfinal userProvider = FutureProvider((ref) async => User('John', 42));\n\nfinal userName = ref.watch(\n  userProvider.selectAsync((user) => user.name),\n);\n```\n\n----------------------------------------\n\nTITLE: Incorrect usage of ref.read with StateNotifierProvider in Dart\nDESCRIPTION: This snippet shows an incorrect way of using ref.read with a StateNotifierProvider, which can lead to problems when the state needs to change.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/reading.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet language=\"dart\" {...readNotifierBuild}></AutoSnippet>\n```\n\n----------------------------------------\n\nTITLE: Migrating ProviderListener to ref.listen in ConsumerWidget - Dart\nDESCRIPTION: Shows the recommended approach to replace the deprecated `ProviderListener` widget. The functionality is moved into the `ConsumerWidget`'s build method using the new `ref.listen` API.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/hooks_riverpod/CHANGELOG.md#_snippet_14\n\nLANGUAGE: Dart\nCODE:\n```\nclass Example extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    ref.listen<int>(counter, (count) {\n      print('count changed $count');\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Synchronous Provider Initialization for Async APIs using Riverpod Scopes (Dart)\nDESCRIPTION: Demonstrates how to handle asynchronous initialization (like `SharedPreferences`) and provide the result synchronously to dependent providers using Riverpod scopes. An initial provider might represent a loading state, which is then overridden within a `ProviderScope` once the asynchronous operation completes, making the initialized value available synchronously to widgets/providers within that scope.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/scopes.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n// Example showing async initialization and synchronous access via scoping\n// (Content loaded from async_initialization.dart)\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:shared_preferences/shared_preferences.dart';\n\n/// A mock database storing user preferences.\n///\n/// It depends on [SharedPreferences].\nclass SettingsRepository {\n  SettingsRepository(this.prefs);\n  final SharedPreferences prefs;\n\n  bool get isDarkModeEnabled => prefs.getBool('isDarkMode') ?? false;\n\n  Future<void> setDarkModeEnabled(bool value) async {\n    await prefs.setBool('isDarkMode', value);\n  }\n}\n\n/// A provider that asynchronously creates a [SharedPreferences].\n///\n/// This provider is here to represent asynchronous operations like reading\n/// a file or obtaining an authentication token.\nfinal sharedPreferencesProvider = FutureProvider<SharedPreferences>((ref) async {\n  // Simulate some delay\n  await Future<void>.delayed(const Duration(milliseconds: 500));\n  // The value could alternatively come from FlutterSecureStorage or Firebase\n  return SharedPreferences.getInstance();\n});\n\n/// A provider that creates our [SettingsRepository].\n///\n/// It depends on [sharedPreferencesProvider]. As such, whenever [sharedPreferencesProvider]\n/// changes, this provider will automatically be recomputed.\n///\n/// It does not handle the loading/error states of [sharedPreferencesProvider].\n/// This will be done somewhere else (see [InitializationProvider] below).\nfinal settingsRepositoryProvider = Provider<SettingsRepository>((ref) {\n  // Obtains the SharedPreferences instance. \n  // The .requireValue is safe because we override the provider below,\n  // and ensure that the override is available before accessing it.\n  final prefs = ref.watch(sharedPreferencesProvider).requireValue;\n  // Creates the SettingsRepository using the SharedPreferences instance.\n  return SettingsRepository(prefs);\n});\n\n/// A provider used to synchronize the initialization of [settingsRepositoryProvider].\n///\n/// This provider does not yield a meaningful value. Instead, widgets/providers\n/// can `ref.watch(initializationProvider)` to react to the initialization state:\n///\n/// - If the initialization is loading, the provider is in loading state.\n/// - If the initialization failed, the provider is in error state.\n/// - If the initialization completed, the provider obtains AsyncData(null).\n///\n/// This allows widgets/providers to handle the loading/error states of\n/// [sharedPreferencesProvider] in a centralized way.\nfinal initializationProvider = Provider<void>((ref) {\n  // Monitors the initialization state of SharedPreferences.\n  // If SharedPreferences is still loading or encountered an error, this\n  // provider will reflect that state.\n  ref.watch(sharedPreferencesProvider);\n});\n\nvoid main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n\n  // Obtain the SharedPreferences instance BEFORE the app starts.\n  final prefs = await SharedPreferences.getInstance();\n\n  runApp(\n    ProviderScope(\n      overrides: [\n        // Override the default SharedPreferences provider behavior.\n        // Instead of creating the SharedPreferences instance asynchronously,\n        // we pass the already obtained instance.\n        // This will allow dependent providers/widgets to synchronously\n        // access SharedPreferences.\n        sharedPreferencesProvider.overrideWithValue(AsyncValue.data(prefs)),\n      ],\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends ConsumerWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // Watches the initialization state.\n    // This is done here to centrally handle the loading/error states.\n    // It could alternatively be done in each widget/provider that needs\n    // the SettingsRepository.\n    final initialization = ref.watch(initializationProvider);\n\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Settings')),        \n        // Handle loading/error states\n        body: initialization.when(\n          // Initialization completed successfully\n          data: (_) => const SettingsView(),\n          // Initialization is loading\n          loading: () => const Center(child: CircularProgressIndicator()),\n          // Initialization failed\n          error: (err, stack) => Center(child: Text('Error: $err')),\n        ),\n      ),\n    );\n  }\n}\n\n// A widget that uses the SettingsRepository to display/modify settings.\nclass SettingsView extends ConsumerWidget {\n  const SettingsView({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // Access the SettingsRepository synchronously.\n    // This is safe because the initialization is handled in MyApp.\n    final settings = ref.watch(settingsRepositoryProvider);\n\n    return ListView(\n      children: [\n        SwitchListTile(\n          title: const Text('Dark mode'),\n          value: settings.isDarkModeEnabled,\n          onChanged: (value) {\n            // Modify the settings using the repository.\n            // No need to handle async operations here, the repository handles it.\n            ref.read(settingsRepositoryProvider).setDarkModeEnabled(value);\n          },\n        ),\n      ],\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Local Cache with API Response in Dart\nDESCRIPTION: This snippet shows how to update the local cache to match the API response after a POST request. It sets the state to the new list of todos returned by the server.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/side_effects.mdx#2025-04-23_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet raw={restAddTodo} />\n```\n\n----------------------------------------\n\nTITLE: Listening to StreamProvider (Deprecated) Dart\nDESCRIPTION: Shows the deprecated method of listening to a StreamProvider's raw stream using ref.watch().stream.listen(). This approach is no longer recommended.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/hooks_riverpod/CHANGELOG.md#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\nref.watch(provider.stream).listen(...)\n```\n\n----------------------------------------\n\nTITLE: Incorrect Provider Initialization in Widget\nDESCRIPTION: Demonstrates an anti-pattern where a provider is incorrectly initialized within a widget's initState method. This approach should be avoided as it can lead to race conditions.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/do_dont.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nclass WidgetState extends State<MyWidget> {\n  @override\n  void initState() {\n    super.initState();\n    // Bad: the provider should initialize itself\n    ref.read(provider).init();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Test Isolation in Dart using Riverpod\nDESCRIPTION: This Dart unit test (`test`) shows that Riverpod provider state is isolated even without Flutter. It uses `ProviderContainer` directly to manage state. Two separate tests interact with the same `counterProvider`, but each test operates on an independent state, demonstrating automatic state reset between tests.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/cookbooks/testing.mdx#2025-04-23_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\n// A Counter implemented using StateProvider\nfinal counterProvider = StateProvider((ref) => 0);\n\nvoid main() {\n  test('Counter increments smoke test', () {\n    // Create a ProviderContainer for this test.\n    // DO NOT share ProviderContainers between tests.\n    final container = ProviderContainer();\n    addTearDown(container.dispose);\n\n    // The initial state is 0.\n    expect(container.read(counterProvider), 0);\n\n    // Increment the state\n    container.read(counterProvider.notifier).state++;\n\n    // The state is now 1.\n    expect(container.read(counterProvider), 1);\n  });\n\n  test('the counter state is not shared between tests', () {\n    final container = ProviderContainer();\n    addTearDown(container.dispose);\n\n    // The state is 0 again.\n    expect(container.read(counterProvider), 0);\n  });\n}\n\n```\n\n----------------------------------------\n\nTITLE: Provider Parameters Implementation\nDESCRIPTION: Shows correct usage of provider parameters with consistent equality checks.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint/README.md#2025-04-23_snippet_8\n\nLANGUAGE: dart\nCODE:\n```\nref.watch(myProvider(const Object()));\nref.watch(myProvider(const [42]));\nref.watch(myProvider(variable));\n```\n\n----------------------------------------\n\nTITLE: Passing Parameters to a Class-Based Provider (Dart)\nDESCRIPTION: This snippet shows how to pass parameters to a class-based provider using code generation. Parameters are passed to the `build` method of the annotated class.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/about_code_generation.mdx#_snippet_10\n\nLANGUAGE: dart\nCODE:\n```\n{trimSnippet(familyClass)}\n```\n\n----------------------------------------\n\nTITLE: Rendering Response Using Consumer Widget in Dart\nDESCRIPTION: 이 코드 스니펫은 `Consumer` 위젯을 사용하여 UI 내에서 `activityProvider`를 읽고 Activity를 표시하는 방법을 보여줍니다. 로딩 및 오류 상태를 처리하고, 위젯이 다시 빌드될 경우 네트워크 요청이 올바르게 다시 실행되지 않습니다.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/essentials/first_request.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\n { ...consumer} \n```\n\n----------------------------------------\n\nTITLE: Cancelling HTTP requests with autoDispose and onDispose\nDESCRIPTION: This code snippet shows how to initiate an HTTP request within an autoDispose FutureProvider, associate a cancellation token, and cancel the request if the provider is disposed before completion. It ensures resource cleanup and prevents unnecessary network calls.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/tr/docusaurus-plugin-content-docs/current/concepts/modifiers/auto_dispose.mdx#_snippet_3\n\nLANGUAGE: Dart\nCODE:\n```\nfinal myProvider = FutureProvider.autoDispose((ref) async {\n  final cancelToken = CancelToken();\n  ref.onDispose(() => cancelToken.cancel());\n\n  final response = await dio.get('path', cancelToken: cancelToken);\n  ref.keepAlive();\n  return response;\n});\n```\n\n----------------------------------------\n\nTITLE: Correctly Watching an Auto-Dispose Provider in Dart\nDESCRIPTION: Illustrates the correct way to watch an auto-dispose provider (`firstProvider`) from another provider by ensuring the watching provider (`secondProvider`) is also marked with `.autoDispose`. This resolves the compilation error and maintains the auto-disposal behavior.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/modifiers/auto_dispose.mdx#2025-04-23_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nfinal firstProvider = Provider.autoDispose((ref) => 0);\n\nfinal secondProvider = Provider.autoDispose((ref) {\n  ref.watch(firstProvider);\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Using ConsumerWidget for Cleaner Provider Access in Flutter\nDESCRIPTION: This example shows how to use ConsumerWidget instead of Consumer to reduce code indentation and improve readability while still accessing providers in the UI.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/first_request.mdx#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nclass Example extends ConsumerWidget {\n  const Example({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final activity = ref.watch(activityProvider);\n    return switch (activity) {\n      AsyncData(:final value) => Text(value.activity),\n      AsyncError() => const Text('Oops, something unexpected happened'),\n      _ => const CircularProgressIndicator(),\n    };\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a FutureProvider for Configuration Loading (Dart)\nDESCRIPTION: This snippet placeholder represents the definition of a `FutureProvider` (imported as `configProvider`). It's designed to asynchronously load configuration data, typically from a JSON file using Flutter's asset system, employing async/await syntax within the provider's creation logic. The provider handles the asynchronous operation and caches the resulting `Future`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/providers/future_provider.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet language=\"dart\" {...configProvider}></AutoSnippet>\n```\n\n----------------------------------------\n\nTITLE: State Update with Double Read\nDESCRIPTION: Shows how to update state based on previous value by reading the provider twice.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/providers/state_provider.mdx#2025-04-23_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\nfinal counter = StateProvider<int>((ref) => 0);\n\nref.read(counter.notifier).state = ref.read(counter) + 1;\n```\n\n----------------------------------------\n\nTITLE: Auto-disposing State with Riverpod\nDESCRIPTION: Shows how Riverpod's autodispose and keepAlive features enable flexible caching strategies, which are difficult to implement with Provider.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/from_provider/motivation/motivation.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nfinal myProvider = FutureProvider.autoDispose((ref) async {\n  final myExpensiveValue = await doExpensiveComputation();\n  ref.keepAlive();\n  return myExpensiveValue;\n});\n```\n\n----------------------------------------\n\nTITLE: Using ref.read to Imperatively Obtain Provider State in Dart\nDESCRIPTION: Shows proper usage of ref.read to synchronously obtain provider state without subscribing to updates, typically in event handlers such as button presses. Highlights that ref.read is non-reactive and should be avoided inside build methods to prevent bugs.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_10\n\nLANGUAGE: Dart\nCODE:\n```\n<CodeBlock>{trimSnippet(read)}</CodeBlock>\n```\n\n----------------------------------------\n\nTITLE: Mocking a Provider - Dart\nDESCRIPTION: This snippet demonstrates how to mock a provider by using the `overrides` parameter in either `ProviderScope` or `ProviderContainer`. This allows you to replace a provider with a mock during testing, controlling its behavior and state.  Dependencies include Riverpod.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/essentials/testing.mdx#_snippet_5\n\nLANGUAGE: Dart\nCODE:\n```\nfinal container = ProviderContainer(\n  overrides: [myProvider.overrideWith((ref) => MyMock())],\n);\n// OR\nawait tester.pumpWidget(\n  ProviderScope(\n    overrides: [myProvider.overrideWith((ref) => MyMock())],\n    child: MyApp(),\n  ),\n);\n```\n\n----------------------------------------\n\nTITLE: Connecting TextField Widget to a Riverpod StateProvider in Dart\nDESCRIPTION: This example demonstrates binding a Flutter TextField widget to a Riverpod StateProvider. Using a Consumer widget, it listens to provider changes and updates the provider's state on each input change with the new value from the TextField. This approach decouples input handling logic from UI and ensures the search state remains in sync with user input across the app. Requires Flutter and flutter_riverpod libraries.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/cookbooks/search_as_we_type.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nConsumer(\n  builder: (context, ref, child) {\n    return TextField(\n      onChanged: (value) => ref.read(searchInputProvider.notifier).state = value,\n    );\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Passing ref or ref.read to repository for dependency injection in Dart\nDESCRIPTION: Shows alternative approach of passing the entire ref object to the repository for flexible provider access, versus only passing ref.read. This offers different trade-offs in code verbosity and reactivity.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#_snippet_7\n\nLANGUAGE: Dart\nCODE:\n```\nfinal repositoryProvider = Provider((ref) => Repository(ref));\n\nclass Repository {\n  Repository(this.ref);\n  final Ref ref;\n}\n```\n\n----------------------------------------\n\nTITLE: Watching a Full Provider State in Flutter (Dart)\nDESCRIPTION: Illustrates a basic use of `ref.watch` within a Flutter widget's `build` method to listen to the entire state object (`User`) exposed by `userProvider`. While simple, this approach causes the widget to rebuild whenever *any* property of the `User` object changes, potentially leading to unnecessary rebuilds if only a subset of the data (like `user.name`) is used.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_16\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, WidgetRef ref) {\n  User user = ref.watch(userProvider);\n  return Text(user.name);\n}\n```\n\n----------------------------------------\n\nTITLE: Updating FutureProvider<T> Reading Pattern in Dart\nDESCRIPTION: Explains updating provider reading patterns after Riverpod 0.6.0, where ref.read(FutureProvider<T>) returns an AsyncValue<T> instead of Future<T>. To access the wrapped future, ref.watch(futureProvider.future) should be used. The provider dependency is a FutureProvider<T>, and this impacts how asynchronous data is handled in application logic.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/hooks_riverpod/CHANGELOG.md#_snippet_23\n\nLANGUAGE: dart\nCODE:\n```\nfinal futureProvider = FutureProvider<T>(...);\nfinal example = Provider((ref) {\n  Future<T> future = ref.read(futureProvider);\n});\n```\n\nLANGUAGE: dart\nCODE:\n```\nfinal futureProvider = FutureProvider<T>(...);\nfinal example = Provider((ref) {\n  Future<T> future = ref.watch(futureProvider.future);\n});\n```\n\n----------------------------------------\n\nTITLE: Defining a ChangeNotifierProvider with Riverpod\nDESCRIPTION: Shows the Riverpod approach to defining a `ChangeNotifierProvider`. The provider is declared as a global final variable outside the widget tree. The application's root widget must be wrapped in a `ProviderScope`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/from_provider/provider_vs_riverpod.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n// providerはトップレベルの変数として定義されます\nfinal counterProvider = ChangeNotifierProvider<Counter>((ref) => Counter());\n\nvoid main() {\n  runApp(\n    // このウィジェットはプロジェクト全体に対してRiverpodを有効にします\n    ProviderScope(\n      child: MyApp(),\n    ),\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing StateNotifierProvider (0.14.0+) in Riverpod (Dart)\nDESCRIPTION: Shows the updated provider declaration for Riverpod 0.14.0 and newer, using two generic parameters: the StateNotifier type and its state type. This pattern requires Riverpod >=0.14.0 and the relevant notifier and model classes in scope.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nfinal provider = StateNotifierProvider<MyStateNotifier, MyModel>((ref) {\n  return MyStateNotifier();\n});\n```\n\n----------------------------------------\n\nTITLE: Full Search-as-You-Type App Example with FutureProvider - Riverpod/Flutter (Dart)\nDESCRIPTION: Implements a full Flutter app using Riverpod's providers to allow real-time search over StackOverflow questions using the Stack Exchange API. Defines StateProvider for the search string, and a FutureProvider for the HTTP request. The FutureProvider dynamically builds the API request URL based on the debounced or current search query. Uses a ConsumerWidget in combination with ProviderScope for Riverpod. Handles UI and state for showing the question list, loading indicator, and errors. Requires flutter, flutter_riverpod, http package, and Dart standard libraries. Inputs are user-typed query strings; output is a list of question titles dynamically updated as the user types.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/cookbooks/search_as_we_type.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n/*\n// Copyright (c) 2019, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n*/\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:http/http.dart' as http;\nimport 'dart:convert';\n\nfinal searchFieldProvider = StateProvider<String>((ref) => '');\nfinal questionsProvider = FutureProvider<List>((ref) async {\n  final client = http.Client();\n  ref.onDispose(client.close);\n\n  final search = ref.watch(searchFieldProvider);\n\n  Uri uri;\n\n  if (search.isEmpty) {\n    uri = Uri.parse(\n      'https://api.stackexchange.com/2.3/questions?order=desc&sort=activity&site=stackoverflow',\n    );\n  } else {\n    final encodedQuery = Uri.encodeComponent(search);\n    uri = Uri.parse(\n      'https://api.stackexchange.com/2.3/search?order=desc&sort=activity&intitle=$encodedQuery&site=stackoverflow',\n    );\n  }\n\n  final response = await client.get(uri);\n  final questions = jsonDecode(response.body);\n\n  return questions['items'].map((question) => question['title']).toList();\n});\n\nvoid main() => runApp(const ProviderScope(child: MyApp()));\n\nclass MyApp extends StatelessWidget {\n  const MyApp({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(home: MyHomePage());\n  }\n}\n\nclass MyHomePage extends ConsumerWidget {\n  const MyHomePage({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final questions = ref.watch(questionsProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Questions')),\n      body: Column(\n        children: [\n          TextField(\n            onChanged: (value) =>\n                ref.read(searchFieldProvider.notifier).state = value,\n          ),\n          Expanded(\n            child: switch (questions) {\n              AsyncData(:final value) => ListView.builder(\n                  itemCount: value.length,\n                  itemBuilder: (context, index) {\n                    final question = value[index];\n\n                    return ListTile(\n                      title: Text(\n                        question.toString(),\n                      ),\n                    );\n                  },\n                );,\n              AsyncError(:final error) => Center(child: Text('Error $error')),\n              _ => const Center(child: CircularProgressIndicator()),\n            },\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Using ref.listen in Build\nDESCRIPTION: This snippet shows how to use `ref.listen` within the `build` method of a widget.  It listens for changes in a provider's value and executes a callback function, such as displaying a snackbar, when a condition is met.  `ref.listen` is useful for triggering side effects without rebuilding the widget.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_8\n\nLANGUAGE: Dart\nCODE:\n```\nclass MyWidget extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    ref.listen(\n      myProvider,\n      (previous, next) {\n        if (next is Error) {\n          ScaffoldMessenger.of(context).showSnackBar(\n            SnackBar(content: Text(next.message)),\n          );\n        }\n      },\n    );\n    return Container();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using ref.watch in a Widget's Build Method - Riverpod Dart\nDESCRIPTION: This example shows a widget using 'ref.watch' inside its build method to subscribe to provider changes. The widget automatically rebuilds when the provider outputs change, ensuring UI reactivity. Key dependencies are Riverpod and Flutter. Inputs include the build context and ref; outputs are UI elements reflecting the provider state.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/reading.mdx#2025-04-23_snippet_8\n\nLANGUAGE: dart\nCODE:\n```\nclass CounterWidget extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final count = ref.watch(counterProvider);\n    return Text('Count: $count');\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage for Ephemeral State\nDESCRIPTION: Demonstrates an anti-pattern where a provider is incorrectly used to manage ephemeral state like selected items.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/do_dont.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nfinal selectedBookProvider = StateProvider<String?>((ref) => null);\n```\n\n----------------------------------------\n\nTITLE: Efficient Selective Watching of User Name in Flutter\nDESCRIPTION: This snippet shows how to use select to efficiently watch only the name property of a User object, reducing unnecessary rebuilds.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/reading.mdx#2025-04-23_snippet_19\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, WidgetRef ref) {\n  String name = ref.watch(userProvider.select((user) => user.name));\n  return Text(name);\n}\n```\n\n----------------------------------------\n\nTITLE: Using ref.read for One-off Provider Reads (Dart)\nDESCRIPTION: This snippet shows how to use ref.read to obtain a provider value without subscribing to updates. Typically used in event handlers, it enables imperative reads and actions. Riverpod is the only dependency, and it's generally discouraged except when reactivity is not needed. Inputs are the ref and provider; output is the provider's current state.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_9\n\nLANGUAGE: dart\nCODE:\n```\n// Example: ref.read in event handler\nElevatedButton(\n  onPressed: () {\n    ref.read(counterProvider.notifier).increment();\n  },\n  child: Text('Increment'),\n);\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Provider in Dart\nDESCRIPTION: This snippet demonstrates the creation of a basic provider using the `Provider` class in Dart. It defines a provider named `myProvider` which encapsulates a shared state. The provider uses a function to create the shared state, returning an instance of `MyValue`.  The variable `myProvider` will then be used to read this state.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/bn/docusaurus-plugin-content-docs/current/concepts/providers.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nfinal myProvider = Provider((ref) {\n  return MyValue();\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring autoDispose Behavior in Riverpod with Dart\nDESCRIPTION: Demonstrates how to disable the default autoDispose behavior in code-generated Riverpod providers by using the `keepAlive: true` annotation option. This disables automatic disposal of providers when there are no active listeners, aligning provider lifecycle with specific use cases where persistent state is desired. Dependency: requires Riverpod's code generation setup with the appropriate annotations.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/about_code_generation.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n/// Example of disabling autoDispose on a provider using code generation annotation\n@riverpod\n@KeepAlive(true) // or @riverpod(keepAlive: true)\nfinal myProvider = Provider<int>((ref) {\n  return 42;\n});\n```\n\n----------------------------------------\n\nTITLE: Overriding FutureProvider with AsyncValue - Riverpod - Dart\nDESCRIPTION: Provides an example of directly overriding a FutureProvider with an AsyncValue for simple and immediate test responses. This is a shortcut for replacing provider return values during tests. Dependencies: riverpod or flutter_riverpod. Expects use with ProviderScope or ProviderContainer. Input: the specific AsyncValue mock data. Output: provider consumers receive the mocked state directly.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/cookbooks/testing.mdx#2025-04-23_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nProviderScope(\n  overrides: [\n    todoListProvider.overrideWithValue(const AsyncValue.data([])),\n  ],\n  child: MyApp(),\n)\n\n```\n\n----------------------------------------\n\nTITLE: Creating a Provider - Dart\nDESCRIPTION: This snippet demonstrates how to create a provider that uses `ref.watch` to interact with another provider and returns a new value based on it.  The `ref` object provides access to other providers.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nfinal provider = Provider((ref) {\n  // используем ref для взаимодействия с другим провайдером\n  final repository = ref.watch(repositoryProvider);\n\n  return SomeValue(repository);\n})\n```\n\n----------------------------------------\n\nTITLE: Mocking Notifier with Override\nDESCRIPTION: This code snippet demonstrates a specific approach to mock `Notifier` classes for testing, especially given the limitations with direct implementation. The mock must subclass the original Notifier, and then it overrides the provider. This method allows creating mock Notifier behavior.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/essentials/testing.mdx#_snippet_8\n\nLANGUAGE: Dart\nCODE:\n```\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:mockito/mockito.dart';\n\n// Create a mock class that extends the Notifier's base class.\nclass MockMyNotifier extends Mock implements MyNotifier {} \n\nfinal myProvider = NotifierProvider<MyNotifier, int>(MyNotifier.new);\n\nclass MyNotifier extends Notifier<int> {\n  @override\n  int build() => 0;\n}\n\nvoid main() {\n  test('MyNotifier', () async {\n    // Create a mock instance of the Notifier.\n    final mock = MockMyNotifier();\n\n    // You can then override the provider with the mock.\n    final container = ProviderContainer(overrides: [myProvider.overrideWith((_) => mock)]);\n\n    //... Then assert against the mock\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Using ref.listen in Riverpod Provider - Dart\nDESCRIPTION: Demonstrates how to use `ref.listen` within a Riverpod Provider definition to react to changes in another provider without causing the listening provider's state to be recreated.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/hooks_riverpod/CHANGELOG.md#_snippet_9\n\nLANGUAGE: Dart\nCODE:\n```\nfinal counterProvider = StateNotifierProvider<Counter, int>(...);\n\nfinal anotherProvider = Provider<T>((ref) {\n  ref.listen<int>(counterProvider, (previous, count) {\n    print('counter changed from $previous to $count');\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a StateProvider for Sort Type in Riverpod\nDESCRIPTION: Defines a `StateProvider` named `sortTypeProvider`. This provider manages the state of the selected `SortType` enum, initialized with `SortType.name` as the default value.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/providers/state_provider.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nfinal sortTypeProvider = StateProvider<SortType>((ref) => SortType.name);\n```\n\n----------------------------------------\n\nTITLE: Refreshing Provider with ref.invalidateSelf() in Dart\nDESCRIPTION: This code demonstrates how to use 'ref.invalidateSelf()' to refresh the provider and re-execute the GET request after a POST request is completed.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/side_effects.mdx#2025-04-23_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet raw={invalidateSelfAddTodo} />\n```\n\n----------------------------------------\n\nTITLE: Updating ConsumerWidget and Consumer Builder - Dart\nDESCRIPTION: Illustrates the required signature changes for the `build` method in `ConsumerWidget` and the `builder` method in `Consumer` when migrating to Riverpod 1.0.0.  The `ScopedReader watch` parameter is replaced with `WidgetRef ref` and the `watch` method is replaced with `ref.watch`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/migration/0.14.0_to_1.0.0.mdx#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nclass Example extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, ScopedReader watch) {\n    int count = watch(counterProvider);\n    ...\n  }\n}\n\nConsumer(\n  builder: (context, watch, child) {\n    int count = watch(counterProvider);\n    ...\n  }\n)\n```\n\nLANGUAGE: dart\nCODE:\n```\nclass Example extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    int count = ref.watch(counterProvider);\n    ...\n  }\n}\n\nConsumer(\n  builder: (context, ref, child) {\n    int count = ref.watch(counterProvider);\n    ...\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Running Globally Installed Riverpod Graph Generator\nDESCRIPTION: This command runs the Riverpod graph generator tool when it's installed globally in the Dart cache. It analyzes the current directory ('.') and produces output in Mermaid.js markup format.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_graph/README.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncd <the lib directory of the program you wish to analyze>\n$ dart pub global run riverpod_graph .\n```\n\n----------------------------------------\n\nTITLE: Correct: Watching an autoDispose Provider from another autoDispose Provider (Dart)\nDESCRIPTION: This code shows the correct way to compose providers with autoDispose in Riverpod by marking both the dependency and the dependent provider with autoDispose. This allows secondProvider to safely watch firstProvider, ensuring both are automatically disposed when no longer observed. No external dependencies are required.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/modifiers/auto_dispose.mdx#2025-04-23_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nfinal firstProvider = Provider.autoDispose((ref) => 0);\n\nfinal secondProvider = Provider.autoDispose((ref) {\n  ref.watch(firstProvider);\n});\n```\n\n----------------------------------------\n\nTITLE: Filtering Widget Rebuilds with ref.watch and .select in Dart\nDESCRIPTION: Demonstrates using the `.select` modifier with `ref.watch` inside a `Consumer` widget. This optimizes performance by rebuilding the widget only when the selected value (in this case, `user.name`) changes, even if other parts of the `userProvider`'s state are updated.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/flutter_riverpod/CHANGELOG.md#2025-04-23_snippet_11\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nfinal userProvider = StateNotifierProvider<UserController, User>(...);\n\nConsumer(\n  builder: (context, ref, _) {\n    // With this syntax, the Consumer will not rebuild if `userProvider`\n    // emits a new User but its \"name\" didn't change.\n    bool userName = ref.watch(userProvider.select((user) => user.name));\n  },\n)\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a FutureProvider that depends on another provider\nDESCRIPTION: Defines an asynchronous provider that watches 'cityProvider' to fetch weather data based on the city. Demonstrates dependency injection and data fetching using ref.watch.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/es/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\nfinal weatherProvider = FutureProvider((ref) async {\n  final city = ref.watch(cityProvider);\n  return fetchWeather(city: city);\n});\n```\n\n----------------------------------------\n\nTITLE: Using the Custom Timed Cache Extension - Riverpod/Dart\nDESCRIPTION: This code demonstrates how to apply the custom `cacheFor` extension method to a provider definition. By calling `ref.cacheFor(const Duration(minutes: 5))` inside the provider, its state will be kept alive for 5 minutes even if it loses all listeners, automatically becoming eligible for disposal after the timer expires.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/essentials/auto_dispose.mdx#_snippet_6\n\nLANGUAGE: Dart\nCODE:\n```\nimport 'package:riverpod/riverpod.dart';\n\nimport 'cache_for_extension.dart';\n\nfinal cacheForExampleProvider = Provider.autoDispose((ref) {\n  // Caches the state for 5 minutes\n  ref.cacheFor(const Duration(minutes: 5));\n\n  return Future.value('Hello world');\n});\n```\n\n----------------------------------------\n\nTITLE: 신규 `Notifier` API를 사용하는 동일 예제\nDESCRIPTION: 이 예제는 기존 구버전 `StateNotifier`의 구조를 새 `Notifier` API로 변환한 코드입니다. `Notifier`의 간단한 생성 방식과 `build` 메서드 내 초기화 방식을 보여줍니다. 반응형 dependencies는 `build` 내에 위치하며, 코드가 더 명료하고 중앙집중적으로 설계된 방식에 대해 설명합니다. 이것이 기존 구조와 어떻게 차별화되는지도 볼 수 있습니다.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/migration/from_state_notifier.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet language=\"dart\" {...buildInit}></AutoSnippet>\n```\n\n----------------------------------------\n\nTITLE: Correct implementation with mounted check in Dart using Riverpod\nDESCRIPTION: This code snippet demonstrates the proper solution to prevent the \"Cannot use 'ref' after the widget was disposed\" error. It checks if the widget is still mounted after an awaited operation before using the ref object.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/essentials/faq.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nElevatedButton(\n  onPressed: () async {\n    await future;\n    if (!context.mounted) return;\n    ref.read(...); // 不再抛出\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Creating a Provider for Sorted Products using Riverpod\nDESCRIPTION: Defines a `productsProvider` that depends on the `sortTypeProvider`. It uses `ref.watch` to listen to changes in the selected sort type. Based on the current `SortType`, it sorts the original `products` list either by name or by price and returns the sorted list.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/providers/state_provider.mdx#2025-04-23_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nfinal productsProvider = Provider<List<Product>>((ref) {\n  final sortType = ref.watch(sortTypeProvider);\n  switch (sortType) {\n    case SortType.name:\n      return products.sorted((a, b) => a.name.compareTo(b.name));\n    case SortType.price:\n      return products.sorted((a, b) => a.price.compareTo(b.price));\n  }\n});\n\n// Using package:collection/collection.dart for the `sorted` method\n// Make sure to add `collection: ^1.17.0` to your pubspec.yaml\n```\n\n----------------------------------------\n\nTITLE: Building Riverpod Packages\nDESCRIPTION: Command to fetch and install Flutter dependencies for the Riverpod project.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_generator/integration/build_yaml/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nflutter pub get\n```\n\n----------------------------------------\n\nTITLE: Public Property Declaration in Dart Notifier\nDESCRIPTION: Example of a public property that violates the avoid_public_notifier_properties lint rule. Shows a direct public property declaration that should be exposed through state instead.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/avoid_public_notifier_properties/avoid_public_notifier_properties_lint.md#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nint publicProperty = 0;\n```\n\n----------------------------------------\n\nTITLE: Testing a Riverpod Provider using ProviderContainer (Dart)\nDESCRIPTION: Demonstrates how to test a Riverpod provider (`repositoryProvider`) using `ProviderContainer`. It creates a container, reads the provider's value (the `Repository` instance), calls a method (`fetchCatalog`), and asserts the expected outcome using standard testing utilities. Requires `test` package setup and assumes `Repository` and `Catalog` classes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#2025-04-23_snippet_9\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nfinal repositoryProvider = Provider((ref) => Repository(ref.read));\n\ntest('fetches catalog', () async {\n  final container = ProviderContainer();\n  addTearDown(container.dispose);\n\n  Repository repository = container.read(repositoryProvider);\n\n  await expectLater(\n    repository.fetchCatalog(),\n    completion(Catalog()),\n  );\n});\n```\n```\n\n----------------------------------------\n\nTITLE: লাইভ কনফিগারেশন ও সার্চ ফিচার কম্পোজিট করা\nDESCRIPTION: লিভ যোগ্য কনফিগারেশনের উপর ভিত্তি করে, সার্চের জন্য স্টেট প্রোভাইডার, কনফিগারেশন স্ট্রিম ও অক্ষর তালিকা ফেচের উদাহরণ। এটি দেখায় কিভাবে রিয়েলটাইম আপডেটের জন্য ভিন্ন ভিন্ন প্রোভাইডারকে একত্রিত করে কাজ করানো যায়।\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/bn/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n// বর্তমান সার্চ ফিল্টার\nfinal searchProvider = StateProvider((ref) => '');\n\n/// কনফিগারেশন যা সময়ের সাথে পরিবর্তিত হতে পারে\nfinal configsProvider = StreamProvider<Configuration>(...);\n\nfinal charactersProvider = FutureProvider<List<Character>>((ref) async {\n  final search = ref.watch(searchProvider);\n  final configs = await ref.watch(configsProvider.future);\n  final response = await dio.get('${configs.host}/characters?search=$search');\n  return response.data.map((json) => Character.fromJson(json)).toList();\n});\n```\n\n----------------------------------------\n\nTITLE: Defining a Todos StateNotifier with StateNotifierProvider in Riverpod (Dart)\nDESCRIPTION: This snippet defines a todos list management solution using a StateNotifier and a StateNotifierProvider in Dart with Riverpod. It encapsulates mutable state (a list of todos) and exposes business logic methods like addTodo for external modification while maintaining immutability. Dependencies include Riverpod and state_notifier packages; key parameters involve managing the list state and events like additions. Input is actions/events (e.g., add), and output is the updated state. This approach enforces separation of logic and state and should be preferrably replaced by NotifierProvider in new code.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/providers/state_notifier_provider.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n// todos.dart\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:state_notifier/state_notifier.dart';\n\nclass Todo {\n  final String description;\n  final bool completed;\n  Todo({required this.description, this.completed = false});\n}\n\nclass TodosNotifier extends StateNotifier<List<Todo>> {\n  TodosNotifier(): super([]);\n\n  void addTodo(String description) {\n    state = [...state, Todo(description: description)];\n  }\n\n  void toggleTodo(int index) {\n    state = [\n      for (int i = 0; i < state.length; i++)\n        if (i == index)\n          Todo(description: state[i].description, completed: !state[i].completed)\n        else\n          state[i],\n    ];\n  }\n}\n\nfinal todosProvider = StateNotifierProvider<TodosNotifier, List<Todo>>(\n  (ref) => TodosNotifier(),\n);\n\n```\n\n----------------------------------------\n\nTITLE: Using AutoDispose Listen to Safely Read Riverpod Providers in Dart\nDESCRIPTION: This snippet shows how to use `container.listen` to subscribe to a provider value. Unlike `container.read`, listening prevents auto-disposable providers from being disposed unexpectedly during tests by maintaining an active subscription. This pattern is recommended for testing providers that use autoDispose. It requires managing the subscription's lifecycle to correctly release resources.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/essentials/testing.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n      // `container.read(provider)`と同等です。\n      // しかし、\"subscription\"が破棄されない限り、providerは破棄されません。\n\n```\n\n----------------------------------------\n\nTITLE: Using ref.listen in Provider\nDESCRIPTION: This code demonstrates using `ref.listen` to react to changes in a provider within another provider. It observes a provider, and executes a callback function whenever the provider's value changes, without rebuilding the UI or provider. This is useful for triggering side effects.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_7\n\nLANGUAGE: Dart\nCODE:\n```\nfinal errorProvider = Provider((ref) {\n  ref.listen(\n    myProvider,\n    (previous, next) {\n      if (next is Error) {\n        // show a snackbar\n      }\n    },\n  );\n\n  return null;\n});\n```\n\n----------------------------------------\n\nTITLE: 시간 기반 상태 지속 및 재활용 - Dart\nDESCRIPTION: extension 함수와 Timer를 사용하는 전략으로, 특정 시간 동안 provider 상태를 유지하며, 필요 시 재활용 또는 자동 폐기를 조절할 수 있습니다. 예를 들어 5분 동안 유지하는 케이스에 적용하며, 보류 중인 타이머 취소 구현도 가능. dependencies: Dart, Timer.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/essentials/auto_dispose.mdx#_snippet_6\n\nLANGUAGE: Dart\nCODE:\n```\n```dart\n// 5분 동안 상태를 유지하는 예시\nref.cacheFor(Duration(minutes: 5));\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a Provider.family with a Freezed Class Parameter in Dart\nDESCRIPTION: This snippet shows the definition of an immutable parameter class using Freezed, containing userId and locale fields, to be passed as a parameter to a Provider.family. The provider is marked autoDispose and receives a MyParameter instance, which is destructured to use fields within the provider logic. The consuming widget passes a constructed MyParameter object to the provider instance.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/de/docusaurus-plugin-content-docs/current/concepts/modifiers/family.mdx#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\n@freezed\nabstract class MyParameter with _$MyParameter {\n  factory MyParameter({\n    required int userId,\n    required Locale locale,\n  }) = _MyParameter;\n}\n\nfinal exampleProvider = Provider.autoDispose.family<Something, MyParameter>((ref, myParameter) {\n  print(myParameter.userId);\n  print(myParameter.locale);\n  // Benutze userId/locale\n});\n\n@override\nWidget build(BuildContext context, WidgetRef ref) {\n  int userId; // Lesen Sie die Benutzer-ID von irgendwoher\n  final locale = Localizations.localeOf(context);\n\n  final something = ref.watch(\n    exampleProvider(MyParameter(userId: userId, locale: locale)),\n  );\n\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple City Provider in Dart\nDESCRIPTION: Defines a simple Riverpod `Provider` named `cityProvider` that returns a static string representing a city name. This serves as a basic provider that other providers can depend on.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n// A provider that holds a city name\nfinal cityProvider = Provider((ref) => 'London');\n```\n\n----------------------------------------\n\nTITLE: Creating a Dropdown to Select Sort Type in Flutter (Dart)\nDESCRIPTION: This snippet shows how to construct a dropdown UI control with Flutter to let users select a sort criterion (e.g., by price or name). Utilizes Flutter's DropdownButton and expects a list of enum or string options. Requires: Flutter SDK. Main parameters are the options and a callback for selection changes. Inputs: current selection state; Outputs: updated selection triggering logic elsewhere. Useful for simple filter or sort UIs.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/providers/state_provider.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n/* Example Dart code for a dropdown selector. See dropdown.dart for full implementation. */\n```\n\n----------------------------------------\n\nTITLE: Implementing a Todos ChangeNotifier in Riverpod (Dart)\nDESCRIPTION: This snippet shows an initial, sub-optimal implementation of Todos state management using ChangeNotifier within Riverpod in Dart. Dependencies include riverpod and provider packages. It introduces mutable properties for todos, loading, and error state, and requires manual invocation of notifyListeners and boilerplate for asynchronous fetching using try/catch/finally. Inputs and outputs are managed via state variables and listeners; this approach is susceptible to inconsistent state and complex error handling.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/migration/from_change_notifier.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n/* ... code from /docs/migration/from_change_notifier/old.dart ... */\n```\n\n----------------------------------------\n\nTITLE: Accessing StateNotifier (New Syntax) - Dart\nDESCRIPTION: This snippet demonstrates the updated syntax for accessing the StateNotifier instance in Riverpod 0.14.0 and later. It now requires accessing the `notifier` property of the provider, `provider.notifier`, to obtain the StateNotifier instance.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, ScopedReader watch) {\n  MyStateNotifier notifier = watch(provider.notifier);\n}\n```\n\n----------------------------------------\n\nTITLE: Combining search and configuration providers with FutureProvider in Dart\nDESCRIPTION: Shows how to use a StateProvider for search input and a StreamProvider for configuration updates, then combines them in a FutureProvider to fetch character data. This pattern allows automatic updates when search parameters or configs change.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#_snippet_5\n\nLANGUAGE: Dart\nCODE:\n```\nfinal searchProvider = StateProvider((ref) => '');\n\nfinal configsProvider = StreamProvider<Configuration>(...);\n\nfinal charactersProvider = FutureProvider<List<Character>>((ref) async {\n  final search = ref.watch(searchProvider);\n  final configs = await ref.watch(configsProvider.future);\n  final response = await dio.get('${configs.host}/characters?search=$search');\n\n  return response.data.map((json) => Character.fromJson(json)).toList();\n});\n```\n\n----------------------------------------\n\nTITLE: Full Riverpod Migration Example\nDESCRIPTION: Shows the complete migration of a ChangeNotifier to a pure Riverpod Notifier implementation.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/from_provider/quickstart.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nclass MyNotifier extends Notifier<int> {\n  @override\n  int build() => 0;\n\n  void increment() => state++;\n}\n\nfinal myNotifierProvider = NotifierProvider<MyNotifier, int>(MyNotifier.new);\n```\n\n----------------------------------------\n\nTITLE: Consuming AsyncNotifierProvider State in Flutter Widget\nDESCRIPTION: This snippet illustrates how a Flutter widget consumes state from an `AsyncNotifierProvider`. It uses `ref.watch` to listen to the `AsyncValue` state (representing loading, data, or error states) and rebuilds the UI accordingly. Interaction with the notifier to trigger actions like `addTodo` is done via `ref.read(provider.notifier).method()`. Common patterns involve using `.when` on the `AsyncValue` for declarative UI rendering based on the state.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/providers/notifier_provider.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\n// Code dynamically loaded via <CodeBlock>{trimSnippet(remoteTodosConsumer)}</CodeBlock>\n// This typically shows a ConsumerWidget handling AsyncValue.\n\n// Example structure:\n// class RemoteTodoListView extends ConsumerWidget {\n//   @override\n//   Widget build(BuildContext context, WidgetRef ref) {\n//     // Watch the AsyncValue state\n//     final asyncTodos = ref.watch(remoteTodosProvider);\n// \n//     return asyncTodos.when(\n//       data: (todos) => ListView(\n//         children: [\n//           for (final todo in todos) Text(todo.description),\n//           ElevatedButton(\n//             onPressed: () {\n//               ref.read(remoteTodosProvider.notifier).addTodo(Todo(/* ... */));\n//             },\n//             child: Text('Add Remote Todo'),\n//           ),\n//         ],\n//       ),\n//       loading: () => const Center(child: CircularProgressIndicator()),\n//       error: (err, stack) => Center(child: Text('Error: $err')),\n//     );\n//   }\n// }\n```\n\n----------------------------------------\n\nTITLE: Consuming Riverpod Provider with Multiple Arguments Using Records\nDESCRIPTION: This snippet demonstrates how to consume a Riverpod provider that accepts multiple arguments using Dart 3 records in a Flutter widget.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/passing_args.mdx#2025-04-23_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nclass Example extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final activity = ref.watch(activityProvider(('recreational', 30.0)));\n    return activity.when(\n      loading: () => const CircularProgressIndicator(),\n      error: (error, stack) => Text('Oops, something unexpected happened'),\n      data: (activity) => Text('${activity.type} - ${activity.price}'),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Reading Providers with BuildContext (Provider)\nDESCRIPTION: This snippet illustrates how to read a provider in Provider using the BuildContext. The context.watch<Model>() method is used within the build method of a StatelessWidget to access the Model provided higher up in the widget tree. This method rebuilds the widget whenever the Model's value changes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/from_provider/provider_vs_riverpod.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nProvider<Model>(...);\n\nclass Example extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    Model model = context.watch<Model>();\n\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Provider State Dart\nDESCRIPTION: Introduces the new provider.overrideWith() method for overriding the behavior or state of a provider. This is the recommended way to perform overrides and replaces provider.overrideWithProvider().\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/hooks_riverpod/CHANGELOG.md#_snippet_5\n\nLANGUAGE: Dart\nCODE:\n```\nprovider.overrideWith((ref) => state)\n```\n\n----------------------------------------\n\nTITLE: Implementing a refresh function with ref.refresh and ref.invalidate in Dart\nDESCRIPTION: Defines a Dart function that demonstrates the difference between ref.refresh and ref.invalidate within the Riverpod framework. The function invalidates a provider and reads its new value, illustrating the typical usage pattern and behavior implications.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/essentials/faq.mdx#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\nT refresh<T>(provider) {\n  invalidate(provider);\n  return read(provider);\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Providers in Dart Tests with ProviderContainer (Dart)\nDESCRIPTION: Here, a ProviderContainer is created with an override for repositoryProvider, injecting a fake implementation for pure Dart tests. This pattern enables deterministic unit testing by substituting dependencies at test-time. Dependency: riverpod. Key parameter: overrides on ProviderContainer. Input: test; Output: assertions on overridden provider results.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/cookbooks/testing.mdx#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nfinal fakeRepository = FakeRepository();\nfinal container = ProviderContainer(overrides: [\n  repositoryProvider.overrideWithValue(fakeRepository),\n]);\nexpect(container.read(repositoryProvider), fakeRepository);\n\n```\n\n----------------------------------------\n\nTITLE: Overriding Providers in Flutter Tests\nDESCRIPTION: Demonstration of mocking the repository in Flutter tests by overriding the provider. The test ensures that a fake repository is used instead of making real API calls during testing.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/cookbooks/testing.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\ntestWidgets('override repositoryProvider', (tester) async {\n  await tester.pumpWidget(\n    ProviderScope(\n      overrides: [\n        // Override the behavior of repositoryProvider to return\n        // a fake implementation of Repository instead of the real one\n        repositoryProvider.overrideWithValue(\n          FakeRepository(),\n        ),\n      ],\n      child: MyApp(),\n    ),\n  );\n});\n```\n\n----------------------------------------\n\nTITLE: Connected Dropdown with StateProvider\nDESCRIPTION: Connects the dropdown UI with StateProvider to manage sort type state.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/providers/state_provider.mdx#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nDropdownButton<SortType>(\n  value: ref.watch(sortTypeProvider),\n  onChanged: (value) => ref.read(sortTypeProvider.notifier).state = value!,\n  items: const [\n    DropdownMenuItem(value: SortType.name, child: Text('Sort by name')),\n    DropdownMenuItem(value: SortType.price, child: Text('Sort by price')),\n  ],\n)\n```\n\n----------------------------------------\n\nTITLE: Isolating provider state in Dart-only tests with Riverpod\nDESCRIPTION: Shows how to use ProviderContainer to ensure independent provider instances for each test in Dart-only unit tests, avoiding shared global state. Illustrates the setup and usage of a provider container for testing without Flutter widgets. Requires riverpod package and Dart test framework. Inputs are provider definitions and ProviderContainer instances, outputs are isolated test behaviors.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/cookbooks/testing.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:test/test.dart';\n\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\nvoid main() {\n  test('increments counter state', () {\n    final container = ProviderContainer();\n    addTearDown(container.dispose);\n\n    expect(container.read(counterProvider).state, 0);\n    container.read(counterProvider).state++;\n    expect(container.read(counterProvider).state, 1);\n  });\n\n  test('counter state is fresh', () {\n    final container = ProviderContainer();\n    addTearDown(container.dispose);\n\n    expect(container.read(counterProvider).state, 0);\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Filter State Provider for a Todo List in Dart\nDESCRIPTION: Creates a `StateProvider` named `filterProvider` that manages the current filter state (None, Completed, Uncompleted) for a todo list. It uses an `enum Filter` and initializes the state to `Filter.none`, allowing the UI or other providers to modify and read the current filter setting.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nenum Filter {\n  none,\n  completed,\n  uncompleted,\n}\n\nfinal filterProvider = StateProvider((ref) => Filter.none);\n```\n\n----------------------------------------\n\nTITLE: Listening to Provider Changes in Tests\nDESCRIPTION: This snippet showcases how to observe changes in a provider using `container.listen` within a test.  It allows to verify the provider's behavior by observing the values emitted over time.  This method enables you to assert on the sequence of values provided during a test.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/essentials/testing.mdx#_snippet_6\n\nLANGUAGE: Dart\nCODE:\n```\nimport \"package:flutter_riverpod/flutter_riverpod.dart\";\nimport \"package:flutter_test/flutter_test.dart\";\n\nfinal myProvider = StateProvider((ref) => 0);\n\nvoid main() {\n  test(\"myProvider\", () {\n    final container = ProviderContainer();\n    final logs = <int>[];\n\n    container.listen<int>(\n      myProvider.notifier,\n      (previous, next) {\n        logs.add(next);\n      },\n      fireImmediately: true,\n    );\n\n    container.read(myProvider.notifier).state = 1;\n    container.read(myProvider.notifier).state = 2;\n\n    expect(logs, [0, 1, 2]);\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized Previous Button using Provider in Dart\nDESCRIPTION: Shows an optimized implementation of the 'Previous' button using a Provider to reduce unnecessary rebuilds.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/bn/docusaurus-plugin-content-docs/current/providers/provider.mdx#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nfinal canGoToPreviousPageProvider = Provider<bool>((ref) {\n  return ref.watch(currentPageProvider) > 0;\n});\n\nclass PreviousButton extends ConsumerWidget {\n  const PreviousButton({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final canGoToPreviousPage = ref.watch(canGoToPreviousPageProvider);\n\n    return ElevatedButton(\n      onPressed: canGoToPreviousPage\n          ? () => ref.read(currentPageProvider.notifier).previous()\n          : null,\n      child: const Text('previous'),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing a provider that uses ref.read in Dart\nDESCRIPTION: Shows how to test a provider that passes ref.read to an object by creating a ProviderContainer, reading the provider, and executing asynchronous methods to verify behavior.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#_snippet_8\n\nLANGUAGE: dart\nCODE:\n```\nfinal repositoryProvider = Provider((ref) => Repository(ref.read));\n\ntest('fetches catalog', () async {\n  final container = ProviderContainer();\n  addTearDown(container.dispose);\n\n  Repository repository = container.read(repositoryProvider);\n\n  await expectLater(\n    repository.fetchCatalog(),\n    completion(Catalog()),\n  );\n});\n```\n\n----------------------------------------\n\nTITLE: Sorted Products Provider Implementation\nDESCRIPTION: Implements a provider that sorts products based on the selected sort type.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/providers/state_provider.mdx#2025-04-23_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nfinal productsProvider = Provider((ref) {\n  final sortType = ref.watch(sortTypeProvider);\n  final products = [...products];\n\n  switch (sortType) {\n    case SortType.name:\n      products.sort((a, b) => a.name.compareTo(b.name));\n    case SortType.price:\n      products.sort((a, b) => a.price.compareTo(b.price));\n  }\n\n  return products;\n});\n```\n\n----------------------------------------\n\nTITLE: Reacting to State Disposal with ref.onDispose - Dart\nDESCRIPTION: Illustrates how to use `ref.onDispose` to register a listener that will be executed when a provider's state is disposed of, such as when the provider is no longer used or is recomputed.  This example shows closing a StreamController.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/essentials/auto_dispose.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n  // stateが破棄されると、streamControllerを閉じます。\n  // TO-DO: StreamControllerに値をプッシュする。\n```\n\n----------------------------------------\n\nTITLE: Defining ConsumerWidget Build Method (Post-1.0.0-dev.0) in Dart\nDESCRIPTION: Illustrates the updated signature of the `build` method in `ConsumerWidget` introduced in Riverpod version 1.0.0-dev.0. It replaces `ScopedReader watch` with `WidgetRef ref`, which provides access to providers via methods like `ref.watch`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/flutter_riverpod/CHANGELOG.md#2025-04-23_snippet_9\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nclass Example extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    int count = ref.watch(counterProvider);\n    ...\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Updating ConsumerWidget Build Method Signature in Dart\nDESCRIPTION: Changes the signature of the build method in ConsumerWidget from using ScopedReader to WidgetRef. This allows for a more unified syntax when interacting with providers.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/flutter_riverpod/CHANGELOG.md#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nclass Example extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    int count = ref.watch(counterProvider);\n    ...\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Multiple Riverpod Providers of the Same Type in Dart\nDESCRIPTION: This example demonstrates that Riverpod permits the creation of multiple distinct providers that expose values of the same type (e.g., `String`). Each provider is uniquely identified by its variable name, avoiding conflicts.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/providers.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n// The content of this code block is inferred from the surrounding text\n// describing the imported `declaringManyProviders` snippet.\nfinal greetingProvider = Provider((ref) => 'Hello');\nfinal nameProvider = Provider((ref) => 'World');\n```\n\n----------------------------------------\n\nTITLE: StateNotifier Implementation for Todos in Dart\nDESCRIPTION: This Dart code defines a `TodosNotifier` class that extends `StateNotifier` from the `state_notifier` package. It manages a list of `Todo` objects and provides methods to add, edit, and remove todos. This example showcases the core logic for managing a stateful list of todos.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/bn/docusaurus-plugin-content-docs/current/providers/state_notifier_provider.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nimport 'package:riverpod/riverpod.dart';\nimport 'package:state_notifier/state_notifier.dart';\n\nclass Todo {\n  Todo({required this.description, this.completed = false, required this.id});\n\n  final String id;\n  final String description;\n  final bool completed;\n\n  Todo copyWith({String? id, String? description, bool? completed}) {\n    return Todo(\n      id: id ?? this.id,\n      description: description ?? this.description,\n      completed: completed ?? this.completed,\n    );\n  }\n}\n\nclass TodosNotifier extends StateNotifier<List<Todo>> {\n  TodosNotifier() : super([]);\n\n  void addTodo(String description) {\n    final todo = Todo(id: DateTime.now().toString(), description: description);\n    state = [...state, todo];\n  }\n\n  void editTodo(String id, String description) {\n    state = [\n      for (final todo in state)\n        if (todo.id == id)\n          todo.copyWith(description: description)\n        else\n          todo,\n    ];\n  }\n\n  void removeTodo(Todo target) {\n    state = state.where((todo) => todo.id != target.id).toList();\n  }\n\n  void toggle(String id) {\n    state = [\n      for (final todo in state)\n        if (todo.id == id)\n          todo.copyWith(completed: !todo.completed)\n        else\n          todo,\n    ];\n  }\n}\n\nfinal todosProvider = StateNotifierProvider<TodosNotifier, List<Todo>>((ref) {\n  return TodosNotifier();\n});\n```\n\n----------------------------------------\n\nTITLE: Adding riverpod dependency in pubspec.yaml\nDESCRIPTION: This YAML snippet illustrates how to add the `riverpod` package to your `pubspec.yaml` file for Dart-only projects. It sets environment constraints for the Dart SDK and adds a dependency on `riverpod`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/getting_started.mdx#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nenvironment:\n  sdk: \">=2.12.0-0 <4.0.0\"\n\ndependencies:\n  riverpod: ^2.1.3\n```\n\n----------------------------------------\n\nTITLE: Creating Simple City Provider in Dart\nDESCRIPTION: Demonstrates creating a basic provider that exposes a city name string.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/combining_providers.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nfinal cityProvider = Provider((ref) => 'London');\n```\n\n----------------------------------------\n\nTITLE: Accessing the StateNotifier instance in a widget with old syntax\nDESCRIPTION: Shows how to obtain the MyStateNotifier instance within a widget using the previous syntax, by reading the provider directly.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_3\n\nLANGUAGE: Dart\nCODE:\n```\nWidget build(BuildContext context, ScopedReader watch) {\n  MyStateNotifier notifier = watch(provider);\n}\n```\n\n----------------------------------------\n\nTITLE: Disposing StreamController in Riverpod Provider\nDESCRIPTION: This snippet demonstrates how to use the onDispose method to close a StreamController when a provider is disposed. It ensures proper cleanup of resources when the provider is no longer needed.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/provider_lifecycles.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nfinal example = Provider((ref) {\n  final streamController = StreamController<String>();\n\n  ref.onDispose(() {\n    // Closes the StreamController when the provider is disposed\n    streamController.close();\n  });\n\n  return streamController;\n});\n```\n\n----------------------------------------\n\nTITLE: Using selectAsync for asynchronous provider property selection in Riverpod (TypeScript)\nDESCRIPTION: Shows how to use 'selectAsync' to watch specific properties of asynchronous providers in Riverpod, allowing the widget to wait for the data and update only when the targeted property becomes available or changes. It mirrors 'select' behavior but returns a 'Future' instead of immediate value.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/advanced/select.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\n<AutoSnippet\n  {...selectAsync}\n  translations={{\n    watch:\n      '  // Wait for the user data to become available, monitoring only the \"firstName\" property',\n    todo: '  // TODO: Use \"firstName\" for other operations',\n  }}\n/>\n```\n\n----------------------------------------\n\nTITLE: Enabling Auto-Dispose for Providers without Code Generation\nDESCRIPTION: Demonstrates how to enable automatic disposal of state when a provider stops being listened to, using the .autoDispose modifier.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/auto_dispose.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nfinal myProvider = Provider.autoDispose<String>((ref) {\n  return 'Hello world';\n});\n\n```\n\n----------------------------------------\n\nTITLE: Using ref.listen to Observe Provider Changes with Callback in Dart\nDESCRIPTION: Explains monitoring provider changes with ref.listen by registering a callback that runs on state change. Unlike ref.watch, ref.listen is used for side effects such as showing dialogs or snackbar notifications. Examples are provided for usage both inside providers and widget build methods.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_8\n\nLANGUAGE: Dart\nCODE:\n```\n<CodeBlock>{trimSnippet(listen)}</CodeBlock>\n```\n\n----------------------------------------\n\nTITLE: Using select with ref.listen in Riverpod\nDESCRIPTION: This code demonstrates how to use select with ref.listen to listen for changes to a specific property of a provided object.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/reading.mdx#2025-04-23_snippet_20\n\nLANGUAGE: dart\nCODE:\n```\nref.listen<String>(\n  userProvider.select((user) => user.name),\n  (String? previousName, String newName) {\n    print('The user name changed $newName');\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: Defining a Synchronous Class-Based Provider (Dart)\nDESCRIPTION: This snippet shows how to define a synchronous Riverpod provider using an annotated class with code generation. Class-based providers allow defining public methods to modify the provider's state (side-effects).\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/about_code_generation.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\n{trimSnippet(syncClass)}\n```\n\n----------------------------------------\n\nTITLE: Handling provider type mismatch with autoDispose\nDESCRIPTION: This snippet explains a common error when trying to assign an autoDispose provider to a variable typed as AlwaysAliveProviderBase. It emphasizes the need to match provider types correctly and shows how to properly declare a provider with autoDispose to avoid runtime issues.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/tr/docusaurus-plugin-content-docs/current/concepts/modifiers/auto_dispose.mdx#_snippet_4\n\nLANGUAGE: Dart\nCODE:\n```\nfinal firstProvider = Provider.autoDispose((ref) => 0);\n\nfinal secondProvider = Provider((ref) {\n  ref.watch(firstProvider);\n});\n```\n\nLANGUAGE: Dart\nCODE:\n```\nfinal firstProvider = Provider.autoDispose((ref) => 0);\n\nfinal secondProvider = Provider.autoDispose((ref) {\n  ref.watch(firstProvider);\n});\n```\n\n----------------------------------------\n\nTITLE: HookConsumerWidget Example - Dart\nDESCRIPTION: Shows the usage of `HookConsumerWidget` for widgets utilizing `flutter_hooks`. This widget combines the functionalities of `ConsumerWidget` and `HookWidget` enabling providers interaction and hooks usage simultaneously.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\n/* ... content of reading_consumer_hook_widget.dart ... */\n```\n\n----------------------------------------\n\nTITLE: Add Todo Method to Notifier\nDESCRIPTION: This snippet introduces the `addTodo` method within the Notifier class. This method is intended to handle the action of adding a new to-do item. It shows how to add a method that allows for performing side effects, such as submitting a POST request.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/essentials/side_effects.mdx#_snippet_4\n\nLANGUAGE: Dart\nCODE:\n```\n\n```\n\n----------------------------------------\n\nTITLE: Consuming Completed Todos in a Dart Widget\nDESCRIPTION: This snippet shows how to use Consumer to listen to the completedTodosProvider and display the list of completed todos in a ListView.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/providers/provider.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nclass CompletedTodos extends ConsumerWidget {\n  const CompletedTodos({Key? key}): super(key: key);\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final completedTodos = ref.watch(completedTodosProvider);\n    return ListView(\n      children: [\n        for (final todo in completedTodos)\n          CheckboxListTile(\n            value: todo.completed,\n            onChanged: (value) => ref.read(todoListProvider.notifier).toggle(todo.id),\n            title: Text(todo.description),\n          ),\n      ],\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Add flutter_riverpod dependency to pubspec.yaml\nDESCRIPTION: This YAML snippet adds the `flutter_riverpod` dependency to your `pubspec.yaml` file, along with the required Flutter and Dart SDK versions.  It is intended for Flutter projects that do *not* use `flutter_hooks`. After adding this snippet, run `pub get` in your terminal to install the dependency.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/bn/docusaurus-plugin-content-docs/current/getting_started.mdx#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nenvironment:\n  sdk: \">=2.12.0-0 <4.0.0\"\n  flutter: \">=2.0.0\"\n\ndependencies:\n  flutter:\n    sdk: flutter\n  flutter_riverpod: ^1.0.0-dev.11\n```\n\n----------------------------------------\n\nTITLE: প্রোভাইডার রেঞ্জ ও রিইউজ সুবিধা\nDESCRIPTION: যে প্রোভাইডারটি একটি স্টেট নোটিফায়ার দ্বারা তালিকা প্রকাশ করে, তার উপর ভিত্তি করে ফিল্টারিং প্রক্রিয়া দেখানো হয়েছে। এই উদাহরণে ফিল্টার পুশ করার জন্য এক স্টেটপ্রোভাইডার, এবং এর মাধ্যমে সংশ্লিষ্ট টোডুগুলির তালিকা তৈরি করা হয়।\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/bn/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nfinal filterProvider = StateProvider((ref) => Filter.none);\n```\n\nLANGUAGE: dart\nCODE:\n```\nfinal filteredTodoListProvider = Provider<List<Todo>>((ref) {\n  final filter = ref.watch(filterProvider);\n  final todos = ref.watch(todoListProvider);\n  switch (filter) {\n    case Filter.none:\n      return todos;\n    case Filter.completed:\n      return todos.where((todo) => todo.completed).toList();\n    case Filter.uncompleted:\n      return todos.where((todo) => !todo.completed).toList();\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Using Select with ref.listen\nDESCRIPTION: Example showing how to use select with ref.listen to only trigger on specific property changes\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/reading.mdx#2025-04-23_snippet_18\n\nLANGUAGE: dart\nCODE:\n```\nref.listen<String>(\n  userProvider.select((user) => user.name),\n  (String? previousName, String newName) {\n    print('The user name changed $newName');\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: Avoiding ref.read in Dart build method\nDESCRIPTION: This snippet demonstrates an anti-pattern of using ref.read inside a build method, which can lead to bugs and difficulties in future refactoring.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/reading.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet language=\"dart\" {...readBuild}></AutoSnippet>\n```\n\n----------------------------------------\n\nTITLE: Consuming parameterized provider in UI with dynamic argument passing\nDESCRIPTION: This snippet shows how to consume a Riverpod provider that requires arguments, passing a constant string (e.g., activity type) from the UI, enabling dynamic data fetching based on user input or state.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/essentials/passing_args.mdx#_snippet_2\n\nLANGUAGE: Dart\nCODE:\n```\n// Assuming provider expects an activity type argument\nfinal activityType = 'recreational';\nfinal activityAsyncValue = ref.watch(activityProvider(activityType));\n```\n\n----------------------------------------\n\nTITLE: Wrapping App with ProviderScope\nDESCRIPTION: This snippet illustrates how to wrap the root of a Flutter application with `ProviderScope`. This is a necessary step to enable Riverpod to manage the state within the application.  `ProviderScope` must be the ancestor of any widget that uses providers.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/tr/docusaurus-plugin-content-docs/current/concepts/providers.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nvoid main() {\n  runApp(ProviderScope(child: MyApp()));\n}\n```\n\n----------------------------------------\n\nTITLE: Unoptimized Previous Button Logic in Dart\nDESCRIPTION: This snippet shows an inefficient Flutter `ConsumerWidget` for a 'Previous' button. It directly watches a hypothetical `pageIndexProvider` using `ref.watch`. The button's enabled/disabled state (`onPressed` callback being null or not) is determined within the `build` method based on the current page index. This causes the widget to rebuild every time the page index changes, even if the button's enabled state remains the same (e.g., staying disabled when navigating from page 1 to 2).\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/providers/provider.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\n/// A provider that holds the currently selected page index\nfinal pageIndexProvider = StateProvider((ref) => 0);\n\nclass PreviousButton extends ConsumerWidget {\n  const PreviousButton({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // watch the current page index\n    final pageIndex = ref.watch(pageIndexProvider);\n    // We disable the button if the current page is the first page\n    final isButtonDisabled = pageIndex == 0;\n\n    return ElevatedButton(\n      onPressed: isButtonDisabled\n          ? null\n          : () => ref.read(pageIndexProvider.notifier).update((state) => state - 1),\n      child: const Text('previous'),\n    );\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Full Widget Test Example\nDESCRIPTION: This code snippet provides a comprehensive example of a widget test, combining the setup of a `ProviderScope`, using `tester.pumpWidget` and interacting with a provider through the obtained `ProviderContainer` to read its value.  This tests a widget that uses a provider.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/essentials/testing.mdx#_snippet_4\n\nLANGUAGE: Dart\nCODE:\n```\nimport \"package:flutter/material.dart\";\nimport \"package:flutter_riverpod/flutter_riverpod.dart\";\nimport \"package:flutter_test/flutter_test.dart\";\n\nfinal myProvider = Provider((ref) => \"Hello world\");\n\nclass MyWidget extends ConsumerWidget {\n  const MyWidget({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final value = ref.watch(myProvider);\n    return Text(value);\n  }\n}\n\nvoid main() {\n  testWidgets(\"myWidget\", (tester) async {\n    await tester.pumpWidget(\n      const ProviderScope(\n        child: MaterialApp(home: MyWidget()),\n      ),\n    );\n\n    final container = ProviderScope.containerOf(tester.element);\n\n    expect(container.read(myProvider), \"Hello world\");\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Using static, known providers with ref.watch/read/listen\nDESCRIPTION: This snippet emphasizes that providers should be statically defined as top-level final variables for static code analysis and linting. Dynamic provider creation or instantiating providers within classes is discouraged to prevent bugs and maintain code clarity.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/essentials/do_dont.mdx#_snippet_4\n\nLANGUAGE: Dart\nCODE:\n```\nfinal provider = Provider((ref) => 42);\n\n// OK: providerの静的定義により解析可能\nref.watch(provider);\n```\n\nLANGUAGE: Dart\nCODE:\n```\nclass Example extends ConsumerWidget {\n  Example({required this.provider});\n  final Provider<int> provider;\n\n  @override\n  Widget build(context, ref) {\n    // 静的解析により provider の種類が判別可能な例\n    ref.watch(provider);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Provider Dependency in Flutter Tests\nDESCRIPTION: This Flutter widget test demonstrates how to override a provider (`repositoryProvider`) within a test using `ProviderScope`. It replaces the real `Repository` with a `FakeRepository` mock implementation by passing a list of `Override` objects to the `overrides` parameter of `ProviderScope`. This ensures that `todoListProvider` uses the mock during the test.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/cookbooks/testing.mdx#2025-04-23_snippet_3\n\nLANGUAGE: Dart\nCODE:\n```\nclass FakeRepository implements Repository {\n  @override\n  Future<List<Object?>> fetchTodos() async {\n    // Return a predefined list of todos for tests\n    return [{'id': 42, 'label': 'Hello world'}];\n  }\n}\n\nvoid main() {\n  testWidgets('Override repositoryProvider', (tester) async {\n    await tester.pumpWidget(\n      ProviderScope(\n        overrides: [\n          // Override the behavior of repositoryProvider to return\n          // FakeRepository instead of Repository.\n          repositoryProvider.overrideWithValue(FakeRepository())\n        ],\n        // Our application, which will read repositoryProvider internally\n        child: const MyApp(),\n      ),\n    );\n\n    // No loading state, dismissed immediately because the request completes\n    // synchronously.\n    expect(find.byType(CircularProgressIndicator), findsNothing);\n\n    // The UI now shows the fake todo list.\n    expect(find.text('Hello world'), findsOneWidget);\n  });\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining a StreamProvider in Riverpod\nDESCRIPTION: This snippet demonstrates how to create a StreamProvider for a User object in Riverpod.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/reading.mdx#2025-04-23_snippet_13\n\nLANGUAGE: dart\nCODE:\n```\nfinal userProvider = StreamProvider<User>(...);\n```\n\n----------------------------------------\n\nTITLE: Riverpod CLI Diff Example - Diff\nDESCRIPTION: This is a diff example showing the changes suggested by the Riverpod CLI during the migration process. It highlights the difference between the old and new syntax for listening to the state of a StateNotifier. This is not a language, but a diff output.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_10\n\nLANGUAGE: diff\nCODE:\n```\nWidget build(BuildContext context, ScopedReader watch) {\n-  MyModel state = watch(provider.state);\n+  MyModel state = watch(provider);\n}\n\nAccept change (y = yes, n = no [default], A = yes to all, q = quit)? \n```\n\n----------------------------------------\n\nTITLE: Listening to State (New Syntax) - Dart\nDESCRIPTION: This snippet demonstrates the updated syntax for listening to the state of a StateNotifier in Riverpod 0.14.0 and later. It now directly reads the provider (`provider`) to listen to the state.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, ScopedReader watch) {\n  MyModel state = watch(provider);\n}\n```\n\n----------------------------------------\n\nTITLE: Combinazione di Provider in Riverpod\nDESCRIPTION: Dimostra la facilità e l'affidabilità con cui Riverpod permette di combinare lo stato di diversi provider utilizzando ref.watch e ref.listen. Questo contrasta con la complessità e la potenziale inaffidabilità di combinare provider usando context.watch o ProxyProvider in Provider.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/from_provider/motivation/motivation.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n// Code imported from /docs/from_provider/motivation/combine\n// Placeholder: Actual code snippet not provided in the input text.\n// Example showing how to combine multiple providers reactively.\n```\n\n----------------------------------------\n\nTITLE: Using ref.watch to Combine Providers Reactively in JavaScript/TypeScript\nDESCRIPTION: Illustrates usage of the ref.watch method to combine multiple providers reactively. The example shows watching a locationProvider and waiting for its future result before using it to fetch nearby restaurants. This approach automatically invalidates and re-runs logic when dependencies update, supporting declarative UI states including loading and error handling. Requires handling AsyncValue states and awareness of async providers.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/essentials/combining_requests.mdx#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\n  // TO-DO: 현재 위치를 가져오는 스트림을 반환합니다.\n  // \"ref.watch\"를 사용하여 최신 위치를 가져옵니다.\n  // provider 뒤에 \".future\"를 지정하면 코드가 적어도 하나의 위치를 사용할 수 있을 때까지 기다립니다.\n  // 이제 해당 위치를 기반으로 네트워크 요청을 할 수 있습니다.\n  // 예를 들어 Google 지도 API를 사용할 수 있습니다:\n  // JSON에서 레스토랑 이름 가져오기\n```\n\n----------------------------------------\n\nTITLE: Consuming Filtered Todos in UI Widget (Riverpod, Dart)\nDESCRIPTION: This snippet demonstrates consuming the completedTodosProvider within a ConsumerWidget to render a UI based on completed todos. It leverages ref.watch and build methods to reactively update the UI when the completed todos change. Dependencies: Riverpod, completedTodosProvider. Input: BuildContext, WidgetRef; Output: Widget displaying filtered todos. This pattern is essential for decoupling UI updates from state changes and for scalable Flutter/Riverpod applications.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/providers/provider.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nclass CompletedTodosConsumer extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final completedTodos = ref.watch(completedTodosProvider);\n    return ListView(\n      children: [\n        for (final todo in completedTodos)\n          ListTile(title: Text(todo.title)),\n      ],\n    );\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Riverpod StateNotifierProvider for Todo List Management (Dart)\nDESCRIPTION: Implements a `TodoList` class extending `StateNotifier` to manage a list of `Todo` items. A `StateNotifierProvider` named `todoListProvider` is created to make the `TodoList` state accessible and manageable within the application. Assumes a `Todo` class exists.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nclass TodoList extends StateNotifier<List<Todo>> {\n  TodoList(): super(const []);\n}\n\nfinal todoListProvider = StateNotifierProvider((ref) => TodoList());\n```\n```\n\n----------------------------------------\n\nTITLE: Synchronous Object Provider Definition in Riverpod\nDESCRIPTION: Demonstrates how to create a provider that synchronously returns an object without using Futures. Shows basic repository pattern implementation.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/websockets_sync.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\nRepository repository(RepositoryRef ref) {\n  return Repository();\n}\n```\n\n----------------------------------------\n\nTITLE: Mocking and overriding Provider behavior during tests\nDESCRIPTION: This snippet describes how to replace real provider implementations with mocks or custom behaviors during tests by using overrides in ProviderScope or ProviderContainer, enabling controlled testing environments.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/de/docusaurus-plugin-content-docs/current/cookbooks/testing.mdx#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\n/* Example demonstrating overriding repository providers with mock implementations using ProviderScope or ProviderContainer */\n// Shows how to replace provider behavior for testing purposes\n```\n\nLANGUAGE: Dart\nCODE:\n```\n/* Example of overriding FutureProvider with a specific AsyncValue for test scenarios */\n// Demonstrates simplified provider overrides\n```\n\nLANGUAGE: Dart\nCODE:\n```\n/* Syntax for overriding providers with family parameter, such as myProvider('12345') */\n// Shows how to override parameterized providers\n```\n\n----------------------------------------\n\nTITLE: Using select for Filtered Rebuilds in Dart\nDESCRIPTION: Shows how to use the select method to filter rebuilds based on specific parts of a provider's state. This can help optimize performance by reducing unnecessary widget rebuilds.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/flutter_riverpod/CHANGELOG.md#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nfinal userProvider = StateNotifierProvider<UserController, User>(...);\n\nConsumer(\n  builder: (context, ref, _) {\n    // With this syntax, the Consumer will not rebuild if `userProvider`\n    // emits a new User but its \"name\" didn't change.\n    bool userName = ref.watch(userProvider.select((user) => user.name));\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Timed Cache Extension - Riverpod/Dart\nDESCRIPTION: This snippet defines an extension method `cacheFor` on `AutoDisposeRef` to implement a custom timed caching mechanism. It uses `ref.keepAlive()` to prevent state disposal and a `Timer` to revert to automatic disposal after a specified duration, effectively keeping the state alive only for that time.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/essentials/auto_dispose.mdx#_snippet_5\n\nLANGUAGE: Dart\nCODE:\n```\nimport 'dart:async';\n\nimport 'package:riverpod/riverpod.dart';\n\nextension CacheForExtension on AutoDisposeRef {\n  // Keeps the state alive for [duration]\n  void cacheFor(Duration duration) {\n    // Immediately prevent disposal\n    final link = keepAlive();\n    // When the timer expires, we restore the original behavior (autoDispose)\n    final timer = Timer(duration, () => link.close());\n\n    // Optional: when the provider is disposed, cancel the timer\n    onDispose(() => timer.cancel());\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a StreamProvider for Live Chat in Dart\nDESCRIPTION: This snippet defines a `StreamProvider` called `liveStreamChatProvider` using Riverpod. It simulates a live data stream (e.g., from a socket) by creating a `Stream.periodic` that emits an incrementing integer every second. It includes a placeholder for cleanup logic using `ref.onDispose` which would typically close the socket or stream source when the provider is no longer in use.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/providers/stream_provider.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nimport 'package:riverpod/riverpod.dart';\n\n// Simulates a live chat stream that yields a new message (integer) every second.\nfinal liveStreamChatProvider = StreamProvider<int>((ref) {\n  // Close the connection when the provider is disposed\n  ref.onDispose(() {/* close socket */});\n\n  // Creates a Stream that emits an integer every second, simulating new messages.\n  return Stream.periodic(\n    const Duration(seconds: 1),\n    (computationCount) => computationCount,\n  );\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Dropdown Menu in Flutter\nDESCRIPTION: Implements a simple DropdownButton component to allow users to select a sort option. It shows how to set up a dropdown without connecting it to state management yet.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/providers/state_provider.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nenum ProductSortType {\n  name,\n  price,\n}\n\nclass ProductSort extends StatefulWidget {\n  const ProductSort({super.key});\n\n  @override\n  State<ProductSort> createState() => _ProductSortState();\n}\n\nclass _ProductSortState extends State<ProductSort> {\n  ProductSortType sortType = ProductSortType.name;\n\n  @override\n  Widget build(BuildContext context) {\n    return DropdownButton<ProductSortType>(\n      value: sortType,\n      onChanged: (value) {\n        if (value != null) {\n          setState(() {\n            sortType = value;\n          });\n        }\n      },\n      items: const [\n        DropdownMenuItem(\n          value: ProductSortType.name,\n          child: Text('Sort by name'),\n        ),\n        DropdownMenuItem(\n          value: ProductSortType.price,\n          child: Text('Sort by price'),\n        ),\n      ],\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Marvel API Keys in JSON\nDESCRIPTION: JSON configuration file structure for storing Marvel API public and private keys. This file should be named 'configuration.json' and placed in the project root.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod/example/README.md#2025-04-23_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"public_key\": \"1234\",\n    \"private_key\": \"5678\"\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Search Provider with FutureProvider\nDESCRIPTION: Initializes a FutureProvider that will handle the search request. This provider will use the search input to perform the API call and return the results.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/cookbooks/search_as_we_type.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nfinal searchProvider = FutureProvider<\n```\n\n----------------------------------------\n\nTITLE: Declaring Multiple Riverpod Providers of the Same Type in Dart\nDESCRIPTION: This snippet illustrates that Riverpod allows declaring multiple providers that expose state of the same data type (e.g., `String`) without conflicts. Each provider is distinct and identified by its variable name (`greetingProvider`, `otherProvider`). This requires the Riverpod package.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/providers.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nfinal greetingProvider = Provider((ref) => 'Hello world');\n\nfinal otherProvider = Provider((ref) => 'Hello world');\n```\n\n----------------------------------------\n\nTITLE: Reading Future from StreamProvider\nDESCRIPTION: Demonstrates accessing a Future that resolves with the latest value from a StreamProvider\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/reading.mdx#2025-04-23_snippet_14\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, WidgetRef ref) {\n  Future<User> user = ref.watch(userProvider.future);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Logger with ProviderObserver in Dart\nDESCRIPTION: This snippet demonstrates how to create a custom logger by extending ProviderObserver and overriding the didUpdateProvider method. The logger converts provider updates to JSON and prints them to the console.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/provider_observer.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nimport 'dart:convert';\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass Logger extends ProviderObserver {\n  @override\n  void didUpdateProvider(\n    ProviderBase provider,\n    Object? previousValue,\n    Object? newValue,\n    ProviderContainer container,\n  ) {\n    debugPrint(\n      jsonEncode({\n        'provider': provider.name ?? provider.runtimeType.toString(),\n        'newValue': newValue.toString(),\n      }),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a ConsumerWidget in Dart for Riverpod\nDESCRIPTION: This example shows how to create a ConsumerWidget, which is similar to a StatelessWidget but with an additional 'ref' parameter in its build method. This allows the widget to interact with providers.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/de/docusaurus-plugin-content-docs/current/concepts/reading.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nclass HomeView extends ConsumerWidget {\n  const HomeView({Key? key}): super(key: key);\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    return Container();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using ref.listen in a Provider to React to State Changes - Riverpod Dart\nDESCRIPTION: This code demonstrates using 'ref.listen' inside a provider to perform side-effects in response to another provider's state changes, such as triggering UI feedback or external actions. The callback receives both previous and current values of the listened provider. The pattern requires Riverpod; the main inputs are the provider to listen to and a handler callback, with output as the side-effect (not a UI value).\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/reading.mdx#2025-04-23_snippet_9\n\nLANGUAGE: dart\nCODE:\n```\nref.listen<SomeState>(someProvider, (previous, next) {\n  if (next.hasError) {\n    // Handle error\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Widget Testing Riverpod Provider Override in Flutter with Dart\nDESCRIPTION: This snippet implements a Flutter widget test that validates overriding the repositoryProvider with a FakeRepository to simulate fetching tasks. It builds a ProviderScope wrapping a MaterialApp containing a Consumer widget that reacts to the future provider's state, showing a loading indicator while data loads and a ListView of TodoItems upon completion. The test asserts proper loading state transitions and correct rendering of the fake todo item.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/es/docusaurus-plugin-content-docs/current/cookbooks/testing.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nvoid main() {\n  testWidgets('override repositoryProvider', (tester) async {\n    await tester.pumpWidget(\n      ProviderScope(\n        overrides: [\n          repositoryProvider.overrideWithValue(FakeRepository())\n        ],\n        // Nuestra aplicación, que leerá desde todoListProvider para mostrar la lista de tareas pendientes.\n        // Probablemente extraigas esto en un widget de MyApp\n        child: MaterialApp(\n          home: Scaffold(\n            body: Consumer(builder: (context, ref, _) {\n              final todos = ref.watch(todoListProvider);\n              // La lista de tareas está cargando o en error\n              if (todos.asData  == null) {\n                return const CircularProgressIndicator();\n              }\n              return ListView(\n                children: [\n                  for (final todo in todos.asData!.value) TodoItem(todo: todo)\n                ],\n              );\n            }),\n          ),\n        ),\n      ),\n    );\n\n    // El primer frame es un estado de carga.\n    expect(find.byType(CircularProgressIndicator), findsOneWidget);\n\n    // Re-renderiza. TodoListProvider ya debería haber obtenido todas las tareas.\n    await tester.pump();\n\n    // Sin estado de carga.\n    expect(find.byType(CircularProgressIndicator), findsNothing);\n    \n    // Renderizó una tarea con los datos devueltos por FakeRepository\n    expect(tester.widgetList(find.byType(TodoItem)), [\n      isA<TodoItem>()\n          .having((s) => s.todo.id, 'todo.id', '42')\n          .having((s) => s.todo.label, 'todo.label', 'Hello world')\n          .having((s) => s.todo.completed, 'todo.completed', false),\n    ]);\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Using Consumer WidgetBuilder Pattern - Riverpod - Dart\nDESCRIPTION: This snippet demonstrates the refactoring of the Consumer API to use a builder property, aligning with the convention of other Builder widgets in Flutter. The builder function now explicitly includes the context, watch, and child parameters. Intended for Flutter apps using the Riverpod library, and requires importing the riverpod and flutter packages. Input is a BuildContext, a ScopedReader, and an optional child. Expected output is a Widget built from provider data.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/flutter_riverpod/CHANGELOG.md#2025-04-23_snippet_20\n\nLANGUAGE: dart\nCODE:\n```\nreturn Consumer((context, watch) {\n  final value = watch(myProvider);\n  return Text('$value');\n});\n```\n\nLANGUAGE: dart\nCODE:\n```\nreturn Consumer(\n  builder: (context, watch, child) {\n    final value = watch(myProvider);\n    return Text('$value');\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Declaring Multiple Providers in Dart\nDESCRIPTION: Shows how to declare multiple providers of the same type (String) without conflicts. This is a unique feature of Riverpod compared to package:provider.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/providers.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nfinal firstProvider = Provider((ref) => 'First');\nfinal secondProvider = Provider((ref) => 'Second');\n```\n\n----------------------------------------\n\nTITLE: Passing Multiple Parameters with Equatable - Dart\nDESCRIPTION: This example uses the `Equatable` package to create a class `MyParameter` with `userId` and `locale` properties.  `Equatable` automatically generates `hashCode` and `==` based on the specified `props`.  This class is used as the parameter for a `Provider.family`, allowing multiple values to be passed while maintaining correct equality semantics.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/bn/docusaurus-plugin-content-docs/current/concepts/modifiers/family.mdx#_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nclass MyParameter extends Equatable  {\n  MyParameter({\n    required this.userId,\n    required this.locale,\n  });\n\n  final int userId;\n  final Locale locale;\n\n  @override\n  List<Object> get props => [userId, locale];\n}\n\nfinal exampleProvider = Provider.family<Something, MyParameter>((ref, myParameter) {\n  print(myParameter.userId);\n  print(myParameter.locale);\n  // userId/locale দিয়ে কিছু করুন\n});\n\n@override\nWidget build(BuildContext context, WidgetRef ref) {\n  int userId; // userId অন্য কোথাও থেকে পড়ুন\n  final locale = Localizations.localeOf(context);\n\n  final something = ref.watch(\n    exampleProvider(MyParameter(userId: userId, locale: locale)),\n  );\n\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Hook Usage in Conditional Statement - Dart\nDESCRIPTION: Illustrates that Flutter Hooks cannot be called conditionally or within loops (`if`, `for`, `while`). They must be called unconditionally and in the same order during every build cycle to maintain state consistency.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/about_hooks.mdx#_snippet_8\n\nLANGUAGE: dart\nCODE:\n```\nclass Example extends HookWidget {\n  const Example({required this.condition, super.key});\n  final bool condition;\n  @override\n  Widget build(BuildContext context) {\n    if (condition) {\n      // Hooks should not be used inside \"if\"s/\"for\"s, ...\n      final controller = useAnimationController();\n    }\n    ...\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Mocking Providers Example\nDESCRIPTION: Shows how to mock providers using the overrides parameter in ProviderScope or ProviderContainer.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/testing.mdx#2025-04-23_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\ntest('mock test', () {\n  final container = ProviderContainer(\n    overrides: [\n      repositoryProvider.overrideWithValue(FakeRepository()),\n    ],\n  );\n\n  // The properties are typed\n  Repository repository = container.read(repositoryProvider);\n});\n```\n\n----------------------------------------\n\nTITLE: Consuming a .family Provider (Dart)\nDESCRIPTION: Shows the correct way to consume a `family` provider within a widget. Instead of directly watching `messagesFamily`, you need to pass the parameter (in this case, a string 'id') to the provider when watching it.  It requires a WidgetRef from the Riverpod library.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/modifiers/family.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, WidgetRef ref) {\n  final response = ref.watch(messagesFamily('id'));\n}\n```\n\n----------------------------------------\n\nTITLE: Obtaining Ref in Functional Providers\nDESCRIPTION: Demonstrates how to access the Ref object in a functional provider. The Ref is passed as a parameter to the provider's function.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/combining_requests.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\nString example(ExampleRef ref) {\n  // We can use \"ref\" here\n  return 'Hello world';\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ProviderObserver Logger in Dart\nDESCRIPTION: This snippet demonstrates how to create a custom ProviderObserver to log updates from any provider. It extends the ProviderObserver class and overrides the didUpdateProvider method to print the provider's name or type and its new value whenever it changes. This requires the flutter_riverpod package.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/provider_observer.mdx#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'dart:developer'; // Or use print\n\nclass Logger extends ProviderObserver {\n  @override\n  void didUpdateProvider(\n    ProviderBase<Object?> provider,\n    Object? previousValue,\n    Object? newValue,\n    ProviderContainer container,\n  ) {\n    log('''\n{\n  \"provider\": \"${provider.name ?? provider.runtimeType}\",\n  \"newValue\": \"$newValue\"\n}''');\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Reusable Hook in a HookWidget - Dart\nDESCRIPTION: This example shows the use of a custom hook function `useFadeIn` (defined in a previous code snippet) within a `HookWidget`.  It demonstrates how to call a custom hook and how the return value is then utilized in the `build` method to control the opacity of a widget. The approach emphasizes code reusability and cleaner widget structures.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/about_hooks.mdx#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nclass FadeIn extends HookWidget {\n  const FadeIn({Key? key, required this.child}) : super(key: key);\n\n  final Widget child;\n\n  @override\n  Widget build(BuildContext context) {\n    final fade = useFadeIn();\n\n    return Opacity(opacity: fade, child: child);\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Reusable Fade-In Hook Function - Flutter\nDESCRIPTION: This code defines a reusable hook function, `useFadeIn`, which encapsulates the logic for creating and starting a fade-in animation. This function can be used within any HookWidget to easily add a fade-in effect to a widget. It returns the animation value, which can be used to control the opacity of a widget.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/about_hooks.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\ndouble useFadeIn() {\n  final animationController = useAnimationController(\n    duration: const Duration(seconds: 2),\n  );\n  useEffect(() {\n    animationController.forward();\n    return null;\n  }, const []);\n  useAnimation(animationController);\n  return animationController.value;\n}\n```\n\n----------------------------------------\n\nTITLE: Using ref.read for One-time Provider Access\nDESCRIPTION: Shows how to use ref.read to access a provider's state without listening to changes. This is useful in methods of Notifiers where ref.watch cannot be used.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/combining_requests.mdx#2025-04-23_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\nclass CartNotifier extends _$CartNotifier {\n  @override\n  List<Product> build() {\n    // Return an empty list as initial value\n    return [];\n  }\n\n  void addProduct(String productId) async {\n    // Since we're inside a method, we can't use ref.watch.\n    // Let's use ref.read instead\n    final product = await ref.read(productProvider(productId).future);\n\n    // Add the product to the cart\n    state = [...state, product];\n  }\n\n  void removeProduct(String productId) {\n    state = [for (final product in state) if (product.id != productId) product];\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Force Provider Disposal with ref.invalidate - Dart\nDESCRIPTION: Demonstrates how to use `ref.invalidate` to force the disposal of a provider's state from another provider or widget. This will either create a new state if the provider is being listened to, or completely dispose of the provider if it is not.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/essentials/auto_dispose.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\n        // タップすると、providerを破棄します。\n```\n\n----------------------------------------\n\nTITLE: Using ConsumerStatefulWidget and ConsumerState to Access Providers (Dart)\nDESCRIPTION: This snippet shows how to access the 'ref' property inside ConsumerState when using ConsumerStatefulWidget for stateful behaviors. The 'ref' is available as a property, not a build method parameter. Dependencies include Riverpod for widget classes and Spring hooks. Expected inputs: Flutter context. Expected outputs: widgets rebuilt in response to provider state changes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\n// Example: ConsumerStatefulWidget pattern\nclass MyStatefulWidget extends ConsumerStatefulWidget {\n  @override\n  ConsumerState<MyStatefulWidget> createState() => _MyStatefulWidgetState();\n}\nclass _MyStatefulWidgetState extends ConsumerState<MyStatefulWidget> {\n  @override\n  Widget build(BuildContext context) {\n    final count = ref.watch(counterProvider);\n    return Text('$count');\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using the cacheFor Extension for Time-Based Caching\nDESCRIPTION: Example showing how to apply the custom cacheFor extension to keep a provider's state alive for a specific duration after it stops being used.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/auto_dispose.mdx#2025-04-23_snippet_7\n\nLANGUAGE: dart\nCODE:\n```\nfinal myProvider = Provider.autoDispose((ref) {\n  // This will keep the provider alive for 5 minutes after it was listened to\n  ref.cacheFor(const Duration(minutes: 5));\n\n  return 'Hello world';\n});\n\n```\n\n----------------------------------------\n\nTITLE: Migrating from StateNotifier's addListener and stream to ref.listen in Riverpod 2.0 Using Dart\nDESCRIPTION: Depicts the transition from the deprecated StateNotifier's .addListener and .stream APIs for listening to state changes to the new unified ref.listen approach used by Notifier and AsyncNotifier in Riverpod 2.0. This change aligns with API uniformity goals. The snippet shows the old usage and the recommended new method, assuming Dart language and Riverpod 2.0 environment.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/migration/from_state_notifier.mdx#_snippet_7\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet raw={addListenerOld}></AutoSnippet>\n```\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet language=\\\"dart\\\" {...addListener}></AutoSnippet>\n```\n\n----------------------------------------\n\nTITLE: Displaying Immutable Settings Example with AutoSnippet (MDX)\nDESCRIPTION: This MDX component (`AutoSnippet`) is configured to display a Dart code example related to implementing immutable state. Based on the context (`whyImmutability` import and surrounding text), it's intended to show an immutable `Settings` class (likely using `freezed`) managed by a Riverpod `Notifier` (`SettingsNotifier`) to handle updates like changing the application theme. The snippet requires importing `freezed_annotation`, adding a part directive, and running `build_runner` for code generation.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/why_immutability.mdx#2025-04-23_snippet_0\n\nLANGUAGE: mdx\nCODE:\n```\n<AutoSnippet language=\"dart\" {...whyImmutability}></AutoSnippet>\n```\n\n----------------------------------------\n\nTITLE: Handling ChangeNotifier and StateNotifier in Riverpod\nDESCRIPTION: Demonstrates the use of ChangeNotifier or StateNotifier objects with Riverpod. Details how to adapt notification objects via pipe mechanisms and explains the use of legacy providers when not using code generation, including automatic disposal and listening features.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/essentials/websockets_sync.mdx#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\n<AutoSnippet \n  raw={pipeChangeNotifier} \n  translations={{\n    provider: \"/// 값이 변경될 때마다 ValueNotifier를 생성하고 리스너를 업데이트하는 provider입니다.\",\n    onDispose: \"  // provider가 폐기되면 notifier를 폐기합니다.\",\n    addListener: \"  // ValueNotifier가 업데이트될 때마다 provider의 리스너들에 알립니다.\",\n  }}\n/>\n```\n\nLANGUAGE: Dart\nCODE:\n```\n<AutoSnippet \n  raw={sharedPipeChangeNotifier} \n  translations={{\n    extension: \"  // 이전 로직을 Ref extension으로 옮길 수 있습니다.\\n  // 이렇게 하면 provider 간에 로직을 재사용할 수 있습니다.\",\n    return: \"    // 사용 편의성을 높이기 위해 notifier를 반환합니다.\",\n  }}\n/>\n```\n\nLANGUAGE: Dart\nCODE:\n```\n<AutoSnippet \n  raw={changeNotifierProvider} \n  translations={{\n    provider: \"  // ValueNotifier를 수신하고 폐기합니다.\\n  // 그러면 위젯은 이 provider를 \\\"ref.watch\\\"하여 업데이트를 수신할 수 있습니다.\",\n  }}\n/>\n```\n\n----------------------------------------\n\nTITLE: Adding RefreshIndicator to Display with Flutter\nDESCRIPTION: This code demonstrates the addition of the `RefreshIndicator` widget. It shows how to integrate it with a `ListView`, `GridView`, or `SingleChildScrollView` to allow a user to trigger a refresh by pulling down on the screen. The key component is the inclusion of a scrollable surface for the `RefreshIndicator` to function correctly.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/case_studies/pull_to_refresh.mdx#_snippet_3\n\nLANGUAGE: Dart\nCODE:\n```\n\n```\n\n----------------------------------------\n\nTITLE: Defining StateProvider for Sorting in Dart\nDESCRIPTION: Creates a StateProvider to manage the sorting type state for products.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/bn/docusaurus-plugin-content-docs/current/providers/state_provider.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nfinal sortTypeProvider = StateProvider<String>((ref) => 'name');\n```\n\n----------------------------------------\n\nTITLE: Using ConsumerWidget to Access Providers (Dart)\nDESCRIPTION: This example demonstrates how to extend ConsumerWidget instead of StatelessWidget to obtain a 'ref' object in the build method. This approach enables widgets to reactively read provider values. The main dependency is Riverpod, and all provider interactions occur inside the build method. Parameters are the usual Flutter build context and ref; outputs are UI widgets that rebuild on provider value changes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n// Example: ConsumerWidget pattern\nclass MyWidget extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final count = ref.watch(counterProvider);\n    return Text('$count');\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Dropdown in Flutter\nDESCRIPTION: Implements a DropdownButton widget to allow sorting of products by name or price.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/bn/docusaurus-plugin-content-docs/current/providers/state_provider.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nDropdownButton<String>(\n  value: sortType,\n  onChanged: (value) {\n    // TODO: We still need to update the sorting type\n  },\n  items: const [\n    DropdownMenuItem(\n      value: 'name',\n      child: Text('Sort by name'),\n    ),\n    DropdownMenuItem(\n      value: 'price',\n      child: Text('Sort by price'),\n    ),\n  ],\n)\n```\n\n----------------------------------------\n\nTITLE: Hello World with Dart Riverpod\nDESCRIPTION: Presents a simple \"Hello world\" example using Dart Riverpod.  It demonstrates how to create a Provider and read its value.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/introduction/getting_started.mdx#_snippet_7\n\nLANGUAGE: dart\nCODE:\n```\nimport 'package:riverpod/riverpod.dart';\n\n// A [Provider] that returns the current time\nfinal helloWorldProvider = Provider((_) => 'Hello world');\n\nvoid main() {\n  final container = ProviderContainer();\n\n  // Prints \"Hello world\"\n  print(container.read(helloWorldProvider));\n}\n```\n\n----------------------------------------\n\nTITLE: Example usage of FutureProvider for reading configuration in Dart\nDESCRIPTION: Demonstrates how to create a FutureProvider to load a JSON configuration file asynchronously using Flutter's Asset system, and illustrates how UI components can consume the FutureProvider to access configuration data. Highlights automatic UI updates upon Future completion and reusing decoded assets.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/bn/docusaurus-plugin-content-docs/current/providers/future_provider.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet language=\"dart\" {...configProvider}></AutoSnippet>\n```\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet language=\"dart\" {...configConsumer}></AutoSnippet>\n```\n\n----------------------------------------\n\nTITLE: Using Provider with Riverpod Bridge\nDESCRIPTION: Demonstrates how to bridge Riverpod providers with existing Provider-based code during migration phase.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/from_provider/quickstart.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nMultiProvider(\n  providers: [\n    ChangeNotifierProvider.value(value: ref.watch(myNotifierProvider.notifier)),\n  ]\n)\n```\n\n----------------------------------------\n\nTITLE: Using HookConsumerWidget with Riverpod and flutter_hooks\nDESCRIPTION: This snippet illustrates how to use `HookConsumerWidget` to combine Riverpod providers with Flutter Hooks.  `HookConsumerWidget` merges the functionalities of `Consumer` and `HookWidget`, allowing the use of both hooks and providers within the same widget.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/essentials/first_request.mdx#_snippet_6\n\nLANGUAGE: Flutter\nCODE:\n```\n<AutoSnippet {...hookConsumerWidget} />\n```\n\n----------------------------------------\n\nTITLE: Accessing Riverpod Provider State via ref.read within a Service (Dart)\nDESCRIPTION: Defines a `repositoryProvider` that creates a `Repository` instance. The `Repository` constructor takes `ref.read` (as `Reader`) allowing it to read other providers like `userTokenProvider` on demand (e.g., inside `fetchCatalog`) without subscribing to their changes. Requires `dio` or a similar HTTP client and a `Catalog` class.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#2025-04-23_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nfinal userTokenProvider = StateProvider<String>((ref) => null);\n\nfinal repositoryProvider = Provider((ref) => Repository(ref.read));\n\nclass Repository {\n  Repository(this.read);\n\n  /// Функция `ref.read`\n  final Reader read;\n\n  Future<Catalog> fetchCatalog() async {\n    String token = read(userTokenProvider);\n\n    final response = await dio.get('/path', queryParameters: {\n      'token': token,\n    });\n\n    return Catalog.fromJson(response.data);\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Example Diff Output in Dart\nDESCRIPTION: This displays a code diff example, showing the proposed changes made by the `riverpod migrate` tool. The example illustrates how the tool suggests changes for migrating a project to use the new `provider` syntax for accessing the state. It provides an example of the expected output, highlighting the changes that the tool will apply to the user's code. The `riverpod` package is required for these changes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_10\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, ScopedReader watch) {\n-  MyModel state = watch(provider.state);\n+  MyModel state = watch(provider);\n}\n```\n\n----------------------------------------\n\nTITLE: Using ref.listen to Imperatively Listen to Provider Changes in JavaScript/TypeScript\nDESCRIPTION: Demonstrates the use of ref.listen as an alternative to ref.watch, providing an imperative way to react to provider state changes via callbacks. While generally ref.watch is preferred for declarative and reactive patterns, ref.listen can be valuable for adding quick logic without extensive refactoring. It supports removing listeners either automatically during rebuilds or manually.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/essentials/combining_requests.mdx#_snippet_4\n\nLANGUAGE: JavaScript\nCODE:\n```\n\n```\n\n----------------------------------------\n\nTITLE: Extending Ref for Combined Debouncing and Cancelling (Dart)\nDESCRIPTION: This snippet implements an extension method on Ref to encapsulate logic for both debouncing and cancelling in-flight network requests. By calling this extension in a provider, developers can reuse the combined behavior across different providers, improving maintainability and avoiding code duplication. Dependencies: flutter_riverpod. Inputs: debounce duration, request code block; outputs: debounced and cancellable async operations. Limitation: Intended for providers handling async network calls.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/case_studies/cancel.mdx#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\n/* code from extension */\n```\n\n----------------------------------------\n\nTITLE: Combining Providers in Riverpod Package (Dart)\nDESCRIPTION: This snippet shows how to combine providers in the Riverpod package, creating a new provider based on UserIdNotifier using ref.watch.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/from_provider/provider_vs_riverpod.mdx#2025-04-23_snippet_7\n\nLANGUAGE: dart\nCODE:\n```\nclass UserIdNotifier extends ChangeNotifier {\n  String? userId;\n}\n\n// ...\n\nfinal userIdNotifierProvider = ChangeNotifierProvider<UserIdNotifier>(\n  (ref) => UserIdNotifier(),\n);\n\n// ...\n\nfinal labelProvider = Provider<String>((ref) {\n  UserIdNotifier userIdNotifier = ref.watch(userIdNotifierProvider);\n  return 'The user ID of the the user is ${userIdNotifier.userId}';\n});\n```\n\n----------------------------------------\n\nTITLE: Using select to optimize rebuilds in Dart\nDESCRIPTION: An auto-generated snippet recommending the use of select when only a portion of a provider's data, such as a single property, is needed. This approach minimizes re-evaluations and rebuilds, improving performance.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#_snippet_10\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet language=\"dart\" {...selectAsyncProvider}></AutoSnippet>\n```\n\n----------------------------------------\n\nTITLE: Listening to Providers in Tests\nDESCRIPTION: This code snippet demonstrates how to listen to a provider within a test, ensuring the provider's state isn't prematurely disposed.  It leverages `container.listen` which ensures the provider remains active during the test.  The return values provide a way to observe provider changes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/essentials/testing.mdx#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\nimport \"package:flutter_riverpod/flutter_riverpod.dart\";\nimport \"package:flutter_test/flutter_test.dart\";\n\nvoid main() {\n  test(\"myProvider\", () {\n    final container = ProviderContainer();\n\n    container.listen(\n      myProvider,\n      (previous, next) {\n        // ...\n      },\n      // Ensure that the provider isn't destroyed between tests\n      // and prevent the test from failing.\n      fireImmediately: true,\n    );\n\n    // ...\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Using ref.listen in Riverpod ConsumerWidget - Dart\nDESCRIPTION: Shows how to use `ref.listen` inside a `ConsumerWidget`'s build method. This is typically used to trigger side effects like showing dialogs or navigations when a watched provider's value changes, without causing the widget to rebuild.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/hooks_riverpod/CHANGELOG.md#_snippet_10\n\nLANGUAGE: Dart\nCODE:\n```\nfinal counterProvider = StateNotifierProvider<Counter, int>(...);\n\nclass Example extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    ref.listen<int>(counterProvider, (previous, count) {\n      showDialog(...);\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Activity with Flutter\nDESCRIPTION: This snippet shows how to display a fetched activity, without taking into account loading and error states. It assumes that the activity is available and renders it. It's a basic implementation that focuses on displaying the data, assuming the data has been fetched and is ready to be presented to the user.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/case_studies/pull_to_refresh.mdx#_snippet_2\n\nLANGUAGE: Dart\nCODE:\n```\n        // activity가 있으면 표시하고, 그렇지 않으면 대기합니다.\n```\n\n----------------------------------------\n\nTITLE: Implementing ConsumerStatefulWidget in Flutter with Riverpod\nDESCRIPTION: This snippet demonstrates how to use ConsumerStatefulWidget, which combines StatefulWidget with Consumer functionality, allowing state management and provider access.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/first_request.mdx#2025-04-23_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nclass Example extends ConsumerStatefulWidget {\n  const Example({super.key});\n\n  @override\n  ConsumerState<Example> createState() => _ExampleState();\n}\n\nclass _ExampleState extends ConsumerState<Example> {\n  @override\n  void initState() {\n    super.initState();\n    // Can use \"ref\" here\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // Can use \"ref\" here too\n    return Container();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using a Riverpod Family with Multiple Parameters in Dart\nDESCRIPTION: Demonstrates how a single `.family` provider (`titleFamily`) can be used multiple times within the same `build` method, each time with a different parameter (`Locale('fr')` and `Locale('en')`). This allows managing distinct states, such as localized titles, based on the provided locale.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/modifiers/family.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\n```dart\n@override\nWidget build(BuildContext context, WidgetRef ref) {\n  final frenchTitle = ref.watch(titleFamily(const Locale('fr')));\n  final englishTitle = ref.watch(titleFamily(const Locale('en')));\n\n  return Text('fr: $frenchTitle en: $englishTitle');\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Overriding Flutter Theme in a Subtree (Dart)\nDESCRIPTION: Provides an example of how Flutter's `Theme` widget allows overriding theme data for a specific part of the widget tree. This serves as an analogy to understand how Riverpod's subtree scoping works, although Riverpod achieves this using `ProviderScope` overrides rather than `InheritedWidget` directly for provider state.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/scopes.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n// Example showing Flutter Theme scoping\n// (Content loaded from theme_scope.dart)\nimport 'package:flutter/material.dart';\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      // Default theme for the entire app\n      theme: ThemeData.light().copyWith(\n        appBarTheme: const AppBarTheme(color: Colors.blue),\n        elevatedButtonTheme: ElevatedButtonThemeData(\n          style: ElevatedButton.styleFrom(backgroundColor: Colors.blue),\n        ),\n      ),\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Theme Scope Example')),\n        body: Center(\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: [\n              // This button uses the default blue theme\n              ElevatedButton(\n                onPressed: () {},\n                child: const Text('Default Theme Button'),\n              ),\n              const SizedBox(height: 20),\n              // Apply a different theme to a specific part of the widget tree\n              Theme(\n                // Override the theme data for this subtree\n                data: ThemeData.dark().copyWith(\n                  appBarTheme: const AppBarTheme(color: Colors.purple),\n                  elevatedButtonTheme: ElevatedButtonThemeData(\n                    style: ElevatedButton.styleFrom(backgroundColor: Colors.purple),\n                  ),\n                ),\n                child: Builder(\n                  // Use Builder to get a context within the overridden theme\n                  builder: (context) {\n                    return ElevatedButton(\n                      onPressed: () {\n                        // Show a dialog using the overridden theme\n                        showDialog<void>(\n                          context: context,\n                          builder: (dialogContext) => Theme(\n                            // Ensure dialog also uses the correct theme\n                            data: Theme.of(context), \n                            child: AlertDialog(\n                              title: const Text('Scoped Theme Dialog'),\n                              content: const Text('This dialog uses the purple theme.'),\n                              actions: [\n                                TextButton(\n                                  onPressed: () => Navigator.of(dialogContext).pop(),\n                                  child: const Text('OK'),\n                                ),\n                              ],\n                            ),\n                          ),\n                        );\n                      },\n                      child: const Text('Scoped Theme Button'),\n                    );\n                  },\n                ),\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining StateNotifier and Model Classes in Dart\nDESCRIPTION: Example of defining a MyModel class and a corresponding MyStateNotifier class that extends StateNotifier<MyModel>.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/migration/0.13.0_to_0.14.0.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nclass MyModel {}\n\nclass MyStateNotifier extends StateNotifier<MyModel> {\n  MyStateNotifier(): super(MyModel());\n}\n```\n\n----------------------------------------\n\nTITLE: 자동 폐기 활성화 및 비활성화 - Dart\nDESCRIPTION: 자동 폐기(`autoDispose`)를 활성화하는 방법과, 이를 비활성화하는 방법을 보여줍니다. provider 타입에 `.autoDispose`를 붙여 자동 상태 폐기를 적용하며, 비활성화시 상태는 수신 중단 시 유지됩니다. 의존성: autoDispose, Dart 언어. 핵심 파라미터: autoDispose 플래그 또는 메서드.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/essentials/auto_dispose.mdx#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\n```dart\n// 자동 상태 파기를 활성화하려면 autoDispose를 지정할 수 있습니다.\n```\n```\n\n----------------------------------------\n\nTITLE: Filtering Widget Rebuilds Using Select in Riverpod (Dart)\nDESCRIPTION: This snippet demonstrates how to use the 'select' functionality in Riverpod to filter widget rebuilds based on specific properties of a User object. It shows how to watch only the 'name' property and avoid rebuilds when other properties change.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/advanced/select.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nclass User {\n  User(this.name, this.age);\n  final String name;\n  final int age;\n}\n\nfinal userProvider = StateProvider((ref) => User('John', 42));\n\nconsumer.watch(\n  userProvider.select((user) => user.name),\n);\n```\n\n----------------------------------------\n\nTITLE: Consuming a ChangeNotifierProvider in a Flutter Widget with Riverpod\nDESCRIPTION: This snippet demonstrates how to use a Flutter `ConsumerWidget` from `flutter_riverpod` to listen to the `todosProvider` defined previously. It accesses the `TodosNotifier` instance using `ref.watch(todosProvider)` to get the current list of todos and rebuilds when it changes. It also uses `ref.read(todosProvider)` to access the notifier's methods (`toggle`, `removeTodo`, `addTodo`) for user interactions like toggling completion, removing todos, and adding new ones via UI elements like CheckboxListTile and FloatingActionButton.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/providers/change_notifier_provider.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nimport 'package:flutter/material.dart';\nimport 'package:hooks_riverpod/hooks_riverpod.dart';\n\nimport 'todos.dart';\n\nvoid main() {\n  runApp(\n    // Adding ProviderScope enables Riverpod for the entire project\n    const ProviderScope(child: MyApp()),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: Home(),\n    );\n  }\n}\n\nclass Home extends HookConsumerWidget {\n  const Home({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // rebuild the widget when the todo list changes\n    final todos = ref.watch(todosProvider).todos;\n    // use ref.watch(todoListProvider.notifier) below to not rebuild\n    // when the todo list changes\n\n    // The list of todos is watched\n    // We define a TextEditingController to be able to read the text from the TextField\n    final newTodoController = useTextEditingController();\n\n    return GestureDetector(\n      onTap: () => FocusScope.of(context).unfocus(),\n      child: Scaffold(\n        body: ListView(\n          padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 40),\n          children: [\n            const Title(),\n            TextField(\n              controller: newTodoController,\n              decoration: const InputDecoration(\n                labelText: 'What needs to be done?',\n              ),\n              // Add a new todo on submit\n              onSubmitted: (value) {\n                ref.read(todosProvider).addTodo(Todo(description: value));\n                newTodoController.clear();\n              },\n            ),\n            const SizedBox(height: 42),\n            const Toolbar(),\n            if (todos.isNotEmpty) const Divider(height: 0),\n            // Render the list of todos\n            for (var i = 0; i < todos.length; i++) ...[\n              if (i > 0) const Divider(height: 0),\n              Dismissible(\n                key: ValueKey(todos[i].id),\n                // Remove a todo on dismiss\n                onDismissed: (_) {\n                  ref.read(todosProvider).removeTodo(todos[i].id);\n                },\n                child: ProviderScope(\n                  overrides: [\n                    // Scoped provider\n                    _currentTodo.overrideWithValue(todos[i]),\n                  ],\n                  // Renders the todo item\n                  child: const TodoItem(),\n                ),\n              )\n            ],\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n/// The provider which will be overridden\nfinal _currentTodo = Provider<Todo>((ref) => throw UnimplementedError());\n\nclass TodoItem extends HookConsumerWidget {\n  const TodoItem({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final todo = ref.watch(_currentTodo);\n    final itemFocusNode = useFocusNode();\n    final itemIsFocused = useIsFocused(itemFocusNode);\n\n    final textEditingController = useTextEditingController();\n    final textFieldFocusNode = useFocusNode();\n\n    return Material(\n      color: Colors.white,\n      elevation: 6,\n      child: Focus(\n        focusNode: itemFocusNode,\n        onFocusChange: (focused) {\n          if (focused) {\n            textEditingController.text = todo.description;\n          } else {\n            // Commit changes only when the textfield is unfocused, for performance\n            ref\n                .read(todosProvider)\n                .edit(id: todo.id, description: textEditingController.text);\n          }\n        },\n        child: ListTile(\n          onTap: () {\n            itemFocusNode.requestFocus();\n            textFieldFocusNode.requestFocus();\n          },\n          leading: Checkbox(\n            value: todo.completed,\n            // Toggle a todo on tap\n            onChanged: (value) => ref.read(todosProvider).toggle(todo.id),\n          ),\n          title: itemIsFocused\n              ? TextField(\n                  autofocus: true,\n                  focusNode: textFieldFocusNode,\n                  controller: textEditingController,\n                )\n              : Text(todo.description),\n        ),\n      ),\n    );\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Refactoring StreamProvider.stream usage in Dart\nDESCRIPTION: Demonstrates how to refactor from the deprecated StreamProvider.stream approach to using ref.listen for stream handling, showing both the deprecated pattern and the recommended alternative.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod/CHANGELOG.md#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n// Deprecated:\nref.watch(provider.stream).listen(...)\n\n// Recommended alternative:\nref.listen(provider, (_, value) {...});\n```\n\n----------------------------------------\n\nTITLE: Setting up Unit Tests with ProviderContainer in Dart\nDESCRIPTION: Demonstrates how to set up a basic unit test using ProviderContainer to test providers in isolation. Shows creation of container, test setup, and verification.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/testing.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\ntest('description', () {\n  final container = ProviderContainer();\n  addTearDown(container.dispose);\n\n  // Test logic goes here\n});\n```\n\n----------------------------------------\n\nTITLE: Replacing context.read with ref.read in Dart\nDESCRIPTION: Converting a StatelessWidget using context.read to a ConsumerWidget with ref.read for Riverpod 1.0.0.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/migration/0.14.0_to_1.0.0.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nclass Example extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    SomeButton(\n      onPressed: () => context.read(provider.notifier).doSomething(),\n    );\n  }\n}\n```\n\nLANGUAGE: dart\nCODE:\n```\nclass Example extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    SomeButton(\n      onPressed: () => ref.read(provider.notifier).doSomething(),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Connecting StateProvider to Dropdown in Flutter\nDESCRIPTION: Updates the DropdownButton to use the StateProvider for managing and updating the sort type.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/bn/docusaurus-plugin-content-docs/current/providers/state_provider.mdx#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nConsumer(\n  builder: (context, ref, child) {\n    final sortType = ref.watch(sortTypeProvider);\n    return DropdownButton<String>(\n      value: sortType,\n      onChanged: (value) =>\n          ref.read(sortTypeProvider.notifier).state = value!,\n      items: const [\n        DropdownMenuItem(\n          value: 'name',\n          child: Text('Sort by name'),\n        ),\n        DropdownMenuItem(\n          value: 'price',\n          child: Text('Sort by price'),\n        ),\n      ],\n    );\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Migration of StreamProvider from Manual to Generated in Dart\nDESCRIPTION: This snippet shows how to replace a manually defined StreamProvider with its code-generated version in Dart. It involves asynchronous stream functions and improves type safety by leveraging code generation for stream providers.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/about_code_generation.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nBefore: <initial StreamProvider code snippet>\n```\n\nLANGUAGE: dart\nCODE:\n```\nAfter: <generated StreamProvider implementation in Dart>\n```\n\n----------------------------------------\n\nTITLE: Exemple de scoping pour l'initialisation asynchrone dans Riverpod\nDESCRIPTION: Ce snippet illustre comment utiliser le scoping pour remplacer provisoirement un provider asynchrone, comme celui de 'asyncInitialization', afin de garantir une initialisation synchrone dans l'application. Cela permet de charger ou simuler des dépendances (ex: SharedPreferences) avant l'affichage de l'interface utilisateur.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/concepts/scopes.mdx#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\n{trimSnippet(asyncInitialization)}\n```\n\n----------------------------------------\n\nTITLE: Using a Custom Hook in a HookWidget in Dart\nDESCRIPTION: Implementation of a FadeIn widget that uses the custom useFadeIn hook. This demonstrates how extracted hook logic can be cleanly consumed by HookWidgets for simpler component implementations.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/about_hooks.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nclass FadeIn extends HookWidget {\n  const FadeIn({Key? key, required this.child}) : super(key: key);\n\n  final Widget child;\n\n  @override\n  Widget build(BuildContext context) {\n    final fade = useFadeIn();\n\n    return Opacity(opacity: fade, child: child);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a FutureProvider that depends on another Provider (Dart)\nDESCRIPTION: Defines a FutureProvider that fetches weather data based on the city provided by `cityProvider`. Uses `ref.watch` to monitor the value of `cityProvider` and initiates an asynchronous weather fetch operation.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/de/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nfinal weatherProvider = FutureProvider((ref) async {\n  // Use ref.watch to listen to cityProvider\n  final city = ref.watch(cityProvider);\n  // Fetch weather data based on the city\n  return fetchWeather(city: city);\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing a ConsumerWidget in Riverpod\nDESCRIPTION: Shows how to create a widget that can read providers by extending ConsumerWidget instead of StatelessWidget, with the ref object passed as a build parameter.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/reading.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nclass MyWidget extends ConsumerWidget {\n  const MyWidget({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // Use ref to watch providers\n    return Container();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Filtering Completed Todos using Provider in Dart\nDESCRIPTION: Demonstrates using a Provider to create a filtered list of completed todos, efficiently caching the computation.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/bn/docusaurus-plugin-content-docs/current/providers/provider.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nfinal completedTodosProvider = Provider<List<Todo>>((ref) {\n  final todos = ref.watch(todoListProvider);\n  return todos.where((todo) => todo.completed).toList();\n});\n```\n\n----------------------------------------\n\nTITLE: Invalidating Provider Cache after POST Request in Riverpod\nDESCRIPTION: Demonstrates how to refresh data after a POST request by invalidating the provider's cache. This approach triggers a new GET request to ensure the UI displays the latest data from the server.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/essentials/side_effects.mdx#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nFuture<void> addTodo(Todo todo) async {\n  // We don't care about the API response\n  await http.post(\n    Uri.https('your-api.com', '/todos'),\n    headers: {'Content-Type': 'application/json'},\n    body: jsonEncode(todo.toJson()),\n  );\n\n  // Once the POST request is complete, we can mark our local cache as dirty.\n  // This will cause the notifier's \"build\" to be called again asynchronously,\n  // at which point listeners will be notified.\n  ref.invalidateSelf();\n\n  // (Optional) We can then wait for the new state to be computed.\n  // This ensures that \"addTodo\" will not complete until the new state is available.\n  await future;\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating from AsyncNotifierProvider to Code Generation (Dart)\nDESCRIPTION: This snippet shows the 'before' state using a non-code-generation `AsyncNotifierProvider`. The 'after' state uses an asynchronous (Future) class-based provider with code generation.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/about_code_generation.mdx#_snippet_15\n\nLANGUAGE: dart\nCODE:\n```\n{trimSnippet(asyncNotifierProvider)}\n```\n\n----------------------------------------\n\nTITLE: Migrating from Provider to Code Generation (Dart)\nDESCRIPTION: This snippet shows the 'before' state of a simple non-code-generation `Provider`. The 'after' state uses a synchronous functional provider with code generation.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/about_code_generation.mdx#_snippet_11\n\nLANGUAGE: dart\nCODE:\n```\n{trimSnippet(provider)}\n```\n\n----------------------------------------\n\nTITLE: Updating StateProvider Usage - Dart\nDESCRIPTION: Explains how the return value of `ref.watch(StateProvider)` changed from `StateController` to the state itself in Riverpod 1.0.0. This snippet demonstrates accessing the state directly and alternatively using `StateProvider.state` to maintain the old behavior.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/migration/0.14.0_to_1.0.0.mdx#_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\nfinal provider = StateProvider<int>(...);\n\nConsumer(\n  builder: (context, ref, child) {\n    StateController<int> count = ref.watch(provider);\n\n    return Text('${count.state}');\n  }\n)\n```\n\nLANGUAGE: dart\nCODE:\n```\nfinal provider = StateProvider<int>(...);\n\nConsumer(\n  builder: (context, ref, child) {\n    int count = ref.watch(provider);\n\n    return Text('${count}');\n  }\n)\n```\n\nLANGUAGE: dart\nCODE:\n```\nfinal provider = StateProvider<int>(...);\n\nConsumer(\n  builder: (context, ref, child) {\n    StateController<int> count = ref.watch(provider.state);\n\n    return Text('${count.state}');\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Using ref.watch with .select() for Filtering Rebuilds - Dart\nDESCRIPTION: Explains how to use the `.select()` method on a provider read (`ref.watch`) to optimize widget rebuilds. The widget only rebuilds if the value returned by the selector changes, not just if the provider emits a new value.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/hooks_riverpod/CHANGELOG.md#_snippet_15\n\nLANGUAGE: Dart\nCODE:\n```\nfinal userProvider = StateNotifierProvider<UserController, User>(...);\n\nConsumer(\n  builder: (context, ref, _) {\n    // With this syntax, the Consumer will not rebuild if `userProvider`\n    // emits a new User but its \"name\" didn't change.\n    bool userName = ref.watch(userProvider.select((user) => user.name));\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Notifier Lifecycles in Dart (New Syntax)\nDESCRIPTION: Example of Notifier lifecycles using the new syntax in Dart. This snippet demonstrates how dispose and other lifecycle events are handled in the new Notifier API.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/migration/from_state_notifier.mdx#2025-04-23_snippet_7\n\nLANGUAGE: dart\nCODE:\n```\nfinal myProvider = NotifierProvider<MyNotifier, int>(() {\n  return MyNotifier();\n});\n\nclass MyNotifier extends Notifier<int> {\n  Timer? _timer;\n\n  @override\n  int build() {\n    final duration = ref.watch(durationProvider);\n    ref.onDispose(() {\n      _timer?.cancel();\n      print('Notifier disposed');\n    });\n    _startTimer(duration);\n    return 0;\n  }\n\n  void _startTimer(Duration duration) {\n    _timer?.cancel();\n    _timer = Timer.periodic(duration, (_) {\n      state++;\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Example: Flutter 'Hello World' with Riverpod\nDESCRIPTION: Sample code snippet demonstrating how to create a simple Flutter app using Riverpod. It shows creating a provider for a string value, wrapping the app in ProviderScope, and using ConsumerWidget or HookConsumerWidget to access the provider and display 'Hello world'. Requires importing the relevant Riverpod package and setting up providers.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/Introduction/getting_started.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\n// Providerを作成し、「Hello world」文字列を提供します。\nfinal provider = Provider<String>((ref) => 'Hello world');\n\n// アプリ全体をProviderScopeでラップし、Providerの状態管理を可能にします。\nvoid main() {\n  runApp(ProviderScope(child: MyApp()));\n}\n\nclass MyApp extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final message = ref.watch(provider);\n    return MaterialApp(\n      home: Scaffold(\n        body: Center(\n          child: Text(message),\n        ),\n      ),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining StreamNotifier with Codegen Dart\nDESCRIPTION: Demonstrates how to create a StreamNotifier using the @riverpod annotation with code generation. This pattern is introduced as a modern way to build StreamProviders that require state modification capabilities.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/hooks_riverpod/CHANGELOG.md#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\n@riverpod\nclass Example extends _$Example {\n  @override\n  Stream<Model> build() {\n    // TODO return some stream\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Consumer Widget for Eager Initialization in Riverpod (Dart)\nDESCRIPTION: This snippet demonstrates how to observe a provider immediately after 'ProviderScope' using a Consumer widget, which allows for eager initialization without causing unnecessary rebuilds of the entire widget tree. It includes handling for error and loading states via conventional Consumer patterns.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/essentials/eager_initialization.mdx#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\nimport { AutoSnippet } from \"../../../../../src/components/CodeSnippet\";\nimport consumerExample from \"!!raw-loader!/docs/essentials/eager_initialization/consumer_example.dart\";\nimport asyncConsumerExample from \"!!raw-loader!/docs/essentials/eager_initialization/async_consumer_example.dart\";\nimport requireValue from \"/docs/essentials/eager_initialization/require_value\";\n\n// Il metodo consigliato per forzare l'inizializzazione anticipata di un provider, osservandolo tramite un Consumer subito sotto ProviderScope.\n// Questo approccio impedisce il ricostruimento dell'intera app quando il provider cambia, grazie alla gestione del widget che ritorna un 'child' costante.\n<AutoSnippet raw={consumerExample} />\n```\n\n----------------------------------------\n\nTITLE: Migrating from useProvider to HookConsumerWidget in Dart\nDESCRIPTION: Converting a HookWidget that uses useProvider to a HookConsumerWidget with ref.watch syntax for Riverpod 1.0.0.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/migration/0.14.0_to_1.0.0.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nclass Example extends HookWidget {\n  @override\n  Widget build(BuildContext context) {\n    useState(...);\n    int count = useProvider(counterProvider);\n    ...\n  }\n}\n```\n\nLANGUAGE: dart\nCODE:\n```\nclass Example extends HookConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    useState(...);\n    int count = ref.watch(counterProvider);\n    ...\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Flagging Required BuildContext in Provider Build Method (Dart)\nDESCRIPTION: This code snippet shows a build method in a provider class with a required named parameter of type BuildContext. The linter identifies this as a violation of the 'avoid_build_context_in_providers' rule.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/avoid_build_context_in_providers/avoid_build_context_in_providers_lint.md#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\n    BuildContext context1, {\n    // expect_lint: avoid_build_context_in_providers\n    required BuildContext context2,\n  }) =>\n      0;\n\n```\n\n----------------------------------------\n\nTITLE: Defining Activity Class - Dart\nDESCRIPTION: This snippet defines an `Activity` class in Dart. The class encapsulates the data structure of a recommended activity fetched from an external API. It handles JSON encoding and decoding. Freezed/json_serializable is recommended but not required.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/case_studies/pull_to_refresh.mdx#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\n/* code for activity not provided in the text */\n```\n\n----------------------------------------\n\nTITLE: Accessing ProviderContainer in Widget Test - Dart\nDESCRIPTION: This snippet explains how to access the `ProviderContainer` within a widget test using `ProviderScope.containerOf(buildContext)`. This allows you to interact with providers, such as reading their values, within a widget test.  It provides context on how to obtain and use the container within a test widget.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/essentials/testing.mdx#_snippet_3\n\nLANGUAGE: Dart\nCODE:\n```\n    final container = ProviderScope.containerOf(context);\n```\n\n----------------------------------------\n\nTITLE: StateProvider Implementation for Sort Type\nDESCRIPTION: Creates a StateProvider to manage the sort type state in Riverpod.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/providers/state_provider.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nfinal sortTypeProvider = StateProvider<SortType>((ref) => SortType.name);\n```\n\n----------------------------------------\n\nTITLE: Example HookWidget - Dart\nDESCRIPTION: This code snippet shows the usage of `useProvider` inside of a `HookWidget` before migration and the equivalent after migration using `HookConsumerWidget` and `ref.watch`. The migration changes the base class and how to read the value of a provider.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/migration/0.14.0_to_1.0.0.mdx#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\n  class Example extends HookWidget {\n    @override\n    Widget build(BuildContext context) {\n      useState(...);\n      int count = useProvider(counterProvider);\n      ...\n    }\n  }\n\n```\n\nLANGUAGE: dart\nCODE:\n```\n  class Example extends HookConsumerWidget {\n    @override\n    Widget build(BuildContext context, WidgetRef ref) {\n      useState(...);\n      int count = ref.watch(counterProvider);\n      ...\n    }\n  }\n\n```\n\n----------------------------------------\n\nTITLE: Replacing context.read with ref.read in StatelessWidget - Dart\nDESCRIPTION: Prior to Riverpod 1.0.0, provider values in StatelessWidgets were accessed via `context.read`. The updated approach mandates switching to a ConsumerWidget and using the provided `WidgetRef ref` parameter with `ref.read` to access provider notifiers or states. This snippet compares the deprecated method with the new recommended pattern, ensuring proper integration with the Riverpod 1.0.0 lifecycle and API.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/bn/docusaurus-plugin-content-docs/current/migration/0.14.0_to_1.0.0.mdx#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nclass Example extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    SomeButton(\n      onPressed: () => context.read(provider.notifier).doSomething(),\n    );\n  }\n}\n\n```\n\nLANGUAGE: dart\nCODE:\n```\nclass Example extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    SomeButton(\n      onPressed: () => ref.read(provider.notifier).doSomething(),\n    );\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing a StateNotifierProvider and dependent filtered list in Riverpod (Dart)\nDESCRIPTION: Shows the creation of a StateNotifier for managing a to-do list, along with a StateProvider for filter state, and a Provider that combines both to produce a filtered to-do list. Automatically updates UI when either the filter or list changes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/de/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nclass TodoList extends StateNotifier<List<Todo>> {\n  TodoList(): super(const []);\n}\n\nfinal todoListProvider = StateNotifierProvider((ref) => TodoList());\n```\n\nLANGUAGE: dart\nCODE:\n```\nenum Filter {\n  none,\n  completed,\n  uncompleted,\n}\n\nfinal filterProvider = StateProvider((ref) => Filter.none);\n```\n\nLANGUAGE: dart\nCODE:\n```\nfinal filteredTodoListProvider = Provider<List<Todo>>((ref) {\n  final filter = ref.watch(filterProvider);\n  final todos = ref.watch(todoListProvider);\n\n  switch (filter) {\n    case Filter.none:\n      return todos;\n    case Filter.completed:\n      return todos.where((todo) => todo.completed).toList();\n    case Filter.uncompleted:\n      return todos.where((todo) => !todo.completed).toList();\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Defining a StateNotifier Model Class in Dart\nDESCRIPTION: Demonstrates the creation of a basic Riverpod StateNotifier subclass managing a state of type MyModel. It initializes the StateNotifier with a default MyModel instance. This snippet requires the Riverpod package and the state_notifier dependency.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nclass MyModel {}\n\nclass MyStateNotifier extends StateNotifier<MyModel> {\n  MyStateNotifier(): super(MyModel());\n}\n```\n\n----------------------------------------\n\nTITLE: Sync Class Provider\nDESCRIPTION: Example of a synchronous class-based provider using code generation.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/about_code_generation.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\nclass Number extends _$Number {\n  @override\n  int build() {\n    return 0;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Providers with Riverpod\nDESCRIPTION: Demonstrates how Riverpod simplifies testing by allowing easy overriding of providers in test environments.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/from_provider/motivation/motivation.mdx#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\ntest('allItemsProvider', () {\n  final container = ProviderContainer(\n    overrides: [\n      oddItemsProvider.overrideWithValue([Item(id: 1)]);\n      evenItemsProvider.overrideWithValue([Item(id: 2)]);\n    ],\n  );\n\n  expect(\n    container.read(allItemsProvider),\n    [Item(id: 1), Item(id: 2)],\n  );\n});\n```\n\n----------------------------------------\n\nTITLE: Watching AsyncValue in Flutter Build Method\nDESCRIPTION: This code shows how to watch an AsyncValue from a StreamProvider and handle different states in the build method.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/reading.mdx#2025-04-23_snippet_14\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, WidgetRef ref) {\n  AsyncValue<User> user = ref.watch(userProvider);\n\n  return switch (user) {\n    AsyncData(:final value) => Text(value.name),\n    AsyncError(:final error) => const Text('Oops $error'),\n    _ => const CircularProgressIndicator(),\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring pubspec.yaml for Dart Riverpod\nDESCRIPTION: Shows how to add Riverpod as a dependency in the `pubspec.yaml` file for a Dart-only project. This involves adding the `riverpod` package under the `dependencies` section.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/introduction/getting_started.mdx#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\ndependencies:\n  riverpod: ^2.0.0\n```\n\n----------------------------------------\n\nTITLE: Migrating from useProvider to HookConsumerWidget and ref.watch - Dart\nDESCRIPTION: Shows the migration path from using `useProvider` in a `HookWidget` to using `HookConsumerWidget` and `ref.watch`. The `WidgetRef` provided in the `build` method replaces the need for `useProvider`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/hooks_riverpod/CHANGELOG.md#_snippet_12\n\nLANGUAGE: Dart\nCODE:\n```\nclass Example extends HookWidget {\n  @override\n  Widget build(BuildContext context) {\n    useState(...);\n    int count = useProvider(counterProvider);\n    ...\n  }\n}\n```\n\nLANGUAGE: Dart\nCODE:\n```\nclass Example extends HookConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    useState(...);\n    int count = ref.watch(counterProvider);\n    ...\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Refreshing a Riverpod Provider in Dart\nDESCRIPTION: Demonstrates how to manually invalidate and refresh a Riverpod provider using `ref.refresh()`. This forces the provider to discard its current state and re-evaluate, which is useful for resetting state or fetching updated data. Requires a `WidgetRef` or `Ref` instance (`ref`) and the target provider (`counterProvider`) to be accessible.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_10\n\nLANGUAGE: dart\nCODE:\n```\nref.refresh(counterProvider);\n```\n\n----------------------------------------\n\nTITLE: Observing Provider Lifecycle with onCancel/onDispose in Dart\nDESCRIPTION: Demonstrates using `ref.onCancel` and `ref.onDispose` within a Riverpod provider to react to lifecycle events. `onCancel` triggers when the last listener stops listening, and `onDispose` triggers when an `.autoDispose` provider is destroyed after losing all listeners. This helps illustrate the automatic state cleanup mechanism, particularly for providers marked with `.autoDispose`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/from_provider/provider_vs_riverpod.mdx#2025-04-23_snippet_10\n\nLANGUAGE: dart\nCODE:\n```\nref.onCancel((){\n  print(\"No one listens to me anymore!\");\n});\nref.onDispose((){\n  print(\"If I've been defined as `.autoDispose`, I just got disposed!\");\n});\n```\n\n----------------------------------------\n\nTITLE: Flagging Required BuildContext in Provider Event Method (Dart)\nDESCRIPTION: This code snippet shows an event method in a provider class with a required named parameter of type BuildContext. The linter identifies this as a violation of the 'avoid_build_context_in_providers' rule.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/avoid_build_context_in_providers/avoid_build_context_in_providers_lint.md#2025-04-23_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\n    BuildContext context3, {\n    // expect_lint: avoid_build_context_in_providers\n    required BuildContext context4,\n  }) {}\n}\n\n```\n\n----------------------------------------\n\nTITLE: Accessing ProviderContainer in Widget Tests\nDESCRIPTION: Demonstrates how to obtain a ProviderContainer instance within widget tests using ProviderScope.containerOf.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/testing.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\ntestWidgets('description', (tester) async {\n  await tester.pumpWidget(\n    ProviderScope(\n      child: Builder(\n        builder: (context) {\n          final container = ProviderScope.containerOf(context);\n          return Container();\n        },\n      ),\n    ),\n  );\n});\n```\n\n----------------------------------------\n\nTITLE: Notifier State Management\nDESCRIPTION: Demonstrates proper state management in Notifier classes using the state property.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint/README.md#2025-04-23_snippet_9\n\nLANGUAGE: dart\nCODE:\n```\nclass Model {\n  Model(this.a, this.b);\n  final int a;\n  final int b;\n}\n\n@riverpod\nclass MyNotifier extends _$MyNotifier {\n  @override\n  Model build() => Model(0, 0);\n}\n```\n\n----------------------------------------\n\nTITLE: Serving the built Korean site with yarn\nDESCRIPTION: This command launches a local server to preview the Korean localized site after building. It allows developers to verify the final Korean content before deployment or publication.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/NOTE.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n# 빌드된 파일 확인\nyarn run serve\n```\n\n----------------------------------------\n\nTITLE: Watching Stream from StreamProvider in Flutter\nDESCRIPTION: This snippet demonstrates how to watch the Stream directly from a StreamProvider in a Flutter build method.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/reading.mdx#2025-04-23_snippet_15\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, WidgetRef ref) {\n  Stream<User> user = ref.watch(userProvider.stream);\n}\n```\n\n----------------------------------------\n\nTITLE: Adding RefreshIndicator Widget - Dart\nDESCRIPTION: This snippet shows the integration of a `RefreshIndicator` widget in the UI. It uses a scrollable widget such as `ListView`, `GridView`, or `SingleChildScrollView` to enable the pull-to-refresh interaction.  This is a basic implementation to enable refreshing.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/case_studies/pull_to_refresh.mdx#_snippet_3\n\nLANGUAGE: Dart\nCODE:\n```\n/* code for displayActivity2 not provided in the text */\n```\n\n----------------------------------------\n\nTITLE: Demonstrating incorrect provider initialization in Flutter widget\nDESCRIPTION: This snippet shows a common mistake where a provider is initialized within the widget's initState, which can lead to race conditions and unexpected behavior. The recommended approach is to initialize providers outside the widget or within proper lifecycle methods that avoid side effects in initState.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/essentials/do_dont.mdx#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\nclass WidgetState extends State<MyWidget> {\n  @override\n  void initState() {\n    super.initState();\n    // Bad: providerは自分で初期化するべきです\n    ref.read(provider).init();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring providers with annotations using code generation\nDESCRIPTION: Guides on defining provider functions and classes with annotations for code generation. Explains support for synchronous and asynchronous primitives, and how to write provider logic using either function-based or class-based providers, with auto-dispose options. Also discusses how to handle async error and loading states with AsyncValue.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/about_code_generation.mdx#_snippet_3\n\n\n\n----------------------------------------\n\nTITLE: Correctly Handling Async Operations with Mounted Check in Riverpod\nDESCRIPTION: The proper implementation for handling asynchronous operations in Riverpod widgets. By checking if the widget is still mounted before using ref, we prevent errors when the widget is disposed during the async operation.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/faq.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nElevatedButton(\n  onPressed: () async {\n    await future;\n    if (!context.mounted) return;\n    ref.read(...); // No longer throws\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Correct Provider Declaration\nDESCRIPTION: Shows the recommended way to declare providers as top-level final variables.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/do_dont.mdx#2025-04-23_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\nfinal provider = Provider<String>((ref) => 'Hello world');\n```\n\n----------------------------------------\n\nTITLE: Best practice for passing ref.read vs ref within Provider\nDESCRIPTION: Mentions the alternative of passing the entire ref object to the custom class, versus passing only ref.read. Explains how ref.read prevents automatic rebuilds, aligning with the recommended pattern.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/es/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#_snippet_5\n\nLANGUAGE: Dart\nCODE:\n```\nfinal repositoryProvider = Provider((ref) => Repository(ref));\n\nclass Repository {\n  Repository(this.ref);\n  final Ref ref;\n}\n```\n\n----------------------------------------\n\nTITLE: Migration of NotifierProvider from Manual to Generated in Dart\nDESCRIPTION: This snippet illustrates transitioning a NotifierProvider from a manual definition to a code-generated implementation in Dart, improving type safety and reducing boilerplate. It shows the difference between the before and after states, emphasizing the use of generated classes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/about_code_generation.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nBefore: <original notifier provider code snippet in non-generation style>\n```\n\nLANGUAGE: dart\nCODE:\n```\nAfter: <updated notifier provider using generated classes in Dart>\n```\n\n----------------------------------------\n\nTITLE: Combining Multiple Providers with ref.watch in a Provider - Riverpod Dart\nDESCRIPTION: This code snippet demonstrates composing multiple providers using 'ref.watch' to transform or combine their output into a new derived value. A practical example is filtering a todo list by watching both a filter type provider and a todo list provider. The code should be placed in a provider factory and depends on Riverpod. Inputs are the reference and source provider states; output is a computed filtered list or derived value, automatically updated when dependencies change.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/reading.mdx#2025-04-23_snippet_7\n\nLANGUAGE: dart\nCODE:\n```\nfinal filteredTodoListProvider = Provider<List<Todo>>((ref) {\n  final filter = ref.watch(filterTypeProvider);\n  final todos = ref.watch(todosProvider);\n  // Apply filtering logic based on filter\n  return todos.where((todo) => /* filter condition */).toList();\n});\n```\n\n----------------------------------------\n\nTITLE: Using Custom Hook in HookWidget Implementation\nDESCRIPTION: Example showing how to use a custom hook function (useFadeIn) within a HookWidget to simplify the implementation of a fade-in effect widget.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/about_hooks.mdx#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nclass FadeIn extends HookWidget {\n  const FadeIn({Key? key, required this.child}) : super(key: key);\n\n  final Widget child;\n\n  @override\n  Widget build(BuildContext context) {\n    final fade = useFadeIn();\n\n    return Opacity(opacity: fade, child: child);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Combining multiple providers with dynamic data fetching (Dart)\nDESCRIPTION: Demonstrates combining a search filter provider and a configuration provider, and fetching character data accordingly. Reruns fetch whenever the search query or configuration changes, allowing dynamic content updates.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/de/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nfinal searchProvider = StateProvider((ref) => '');\n\n// Configuration stream provider\nfinal configsProvider = StreamProvider<Configuration>(...);\n\nfinal charactersProvider = FutureProvider<List<Character>>((ref) async {\n  final search = ref.watch(searchProvider);\n  final configs = await ref.watch(configsProvider.future);\n  final response = await dio.get('${configs.host}/characters?search=$search');\n\n  return response.data.map((json) => Character.fromJson(json)).toList();\n});\n```\n\n----------------------------------------\n\nTITLE: Auto-dispose Provider Testing Pattern\nDESCRIPTION: Shows the correct way to test auto-disposed providers using container.listen instead of container.read to prevent state destruction during tests.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/testing.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\ntest('description', () {\n  final container = ProviderContainer();\n  addTearDown(container.dispose);\n\n  final listener = container.listen(provider, (previous, next) {});\n  // The value can be obtained using `listener.read()`\n});\n```\n\n----------------------------------------\n\nTITLE: Recommended Pattern for Initialization Logic\nDESCRIPTION: This snippet shows the recommended approach for handling initialization logic that depends on external factors. Placing initialization within button event handlers is often more appropriate than using provider initialization.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/essentials/do_dont.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nElevatedButton(\n  onPressed: () {\n    ref.read(provider).init();\n    Navigator.of(context).push(...);\n  },\n  child: Text('Navigate'),\n)\n```\n\n----------------------------------------\n\nTITLE: Using the Reusable Fade-In Hook - Flutter\nDESCRIPTION: This code snippet demonstrates how to use the reusable `useFadeIn` hook function within a HookWidget. The `useFadeIn` function is called to obtain the animation value, which is then used to control the opacity of the child widget within an Opacity widget. This exemplifies the reusability and composability that hooks provide.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/about_hooks.mdx#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nclass FadeIn extends HookWidget {\n  const FadeIn({Key? key, required this.child}) : super(key: key);\n\n  final Widget child;\n\n  @override\n  Widget build(BuildContext context) {\n    final fade = useFadeIn();\n\n    return Opacity(opacity: fade, child: child);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating FutureProvider from Manual to Code-Generated in Dart\nDESCRIPTION: This snippet shows how to replace a manual FutureProvider declaration with a generated asynchronous function. Dependencies include Dart's async features and Riverpod's provider system.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/about_code_generation.mdx#_snippet_8\n\nLANGUAGE: dart\nCODE:\n```\n{trimSnippet(futureProvider)}\n```\n\n----------------------------------------\n\nTITLE: Using autoDispose with FutureProvider Family in Dart\nDESCRIPTION: Defines a Riverpod `FutureProvider` combining `.autoDispose` and `.family`. This pattern is recommended when the family parameter (`filter`) might change frequently and not be reused (e.g., search input), ensuring the provider state is automatically disposed of when no longer listened to, thus preventing potential memory leaks.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/modifiers/family.mdx#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nfinal characters = FutureProvider.autoDispose.family<List<Character>, String>((ref, filter) async {\n  return fetchCharacters(filter: filter);\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing Search Input Provider in Dart\nDESCRIPTION: Creates a StateProvider to store the user's search input as a String.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/bn/docusaurus-plugin-content-docs/current/cookbooks/search_as_we_type.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nfinal searchInputProvider = StateProvider<String>((ref) => '');\n```\n\n----------------------------------------\n\nTITLE: Configurazione di analysis_options.yaml per riverpod_lint\nDESCRIPTION: Configurazione necessaria nel file analysis_options.yaml per abilitare il pacchetto riverpod_lint che fornisce regole di lint e refactoring per Riverpod.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/introduction/getting_started.mdx#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nanalyzer:\n  plugins:\n    - custom_lint\n```\n\n----------------------------------------\n\nTITLE: Passing Provider ref to StateNotifier - Riverpod Dart\nDESCRIPTION: This code shows how to pass the provider's 'ref' into a StateNotifier class constructor using Riverpod. This pattern allows the StateNotifier class to interact with other providers or perform side-effects via the 'ref' object. The code assumes dependency on both Riverpod and StateNotifier, where key parameters include the provider ref object. Output is a StateNotifier instance configured with provider context.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/reading.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nfinal counterProvider = StateNotifierProvider<Counter, int>((ref) {\n  return Counter(ref);\n});\n\nclass Counter extends StateNotifier<int> {\n  Counter(this.ref) : super(0);\n  final Ref ref;\n  // ... implementation ...\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect usage of ref.read in build method with Riverpod\nDESCRIPTION: An anti-pattern example showing improper usage of ref.read in a build method, which should be avoided as it can lead to hard-to-track bugs when provider values change.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/tr/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_11\n\nLANGUAGE: dart\nCODE:\n```\nfinal counterProvider = StateProvider((ref) => 0);\n\nWidget build(BuildContext context, WidgetRef ref) {\n  // provider'dan gelen güncellemeleri yok saymak için \"oku\"yu kullanın\n  final counter = ref.read(counterProvider.notifier);\n  return ElevatedButton(\n    onPressed: () => counter.state++,\n    child: const Text('button'),\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Proper Usage of Hooks in a HookWidget\nDESCRIPTION: Example demonstrating the correct way to use hooks within a HookWidget's build method.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/about_hooks.mdx#2025-04-23_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nclass Example extends HookWidget {\n  @override\n  Widget build(BuildContext context) {\n    final controller = useAnimationController();\n    ...\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrectly Using ref.read Inside a Provider Body (Dart)\nDESCRIPTION: Illustrates an **incorrect** pattern where `ref.read` is called directly inside the provider's creation callback. This is discouraged because it makes the dependency untracked, potentially leading to stale data if the read provider changes. It also obscures the provider's dependencies. `ref.watch` should be used instead if the provider needs to react to changes, or the `Ref` should be passed to the created object as shown in other examples.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#2025-04-23_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\nfinal configurationProvider = Provider<Configuration>((ref) => Configuration());\n\n// DON'T call `ref.read` inside the body of a provider\nfinal productsProvider = FutureProvider((ref) async {\n  // Calling `ref.read` here is risky.\n  final host = ref.read(configurationProvider).host;\n\n  final response = await dio.get('$host/products');\n  return Products.fromJson(response.data);\n});\n```\n\n----------------------------------------\n\nTITLE: Creating \"Hello World\" with Dart\nDESCRIPTION: This Dart snippet provides a basic \"Hello World\" example using Riverpod in a Dart console application. It defines a `helloWorldProvider` that provides the string \"Hello world\". The `main` function creates a `ProviderContainer`, reads the provider's value using `container.read()`, and prints the result to the console. Requires `riverpod` dependency. To run it, use command `dart lib/main.dart`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/getting_started.mdx#_snippet_5\n\nLANGUAGE: Dart\nCODE:\n```\nimport 'package:riverpod/riverpod.dart';\n\n// Nous créons un \"provider\", qui va stocker une valeur (ici \"Hello world\").\n// En utilisant un provider, cela permet de mocker/changer la valeur exposée.\nfinal helloWorldProvider = Provider((_) => 'Hello world');\n\nvoid main() {\n  // ProviderContainer est un objet stockant l'état de nos providers.\n  final container = ProviderContainer();\n\n  // Grace à \"container\", nous pouvons lire nos providers.\n  final value = container.read(helloWorldProvider);\n\n  print(value); // Hello world\n}\n\n```\n\n----------------------------------------\n\nTITLE: Selezionare dati asincroni con selectAsync in Riverpod - JavaScript/TypeScript\nDESCRIPTION: Questo snippet illustra l'uso di 'selectAsync' per eseguire un'operazione di selezione su dati emessi da un provider asincrono in Riverpod. A differenza di 'select', che si applica solo a 'AsyncValue', 'selectAsync' restituisce un Future e permette di selezionare proprietà di valore asincrono senza bloccare il codice. È particolarmente utile quando si usa 'ref.watch(anotherProvider.future)'.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/advanced/select.mdx#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { useProvider } from 'riverpod';\nconst userNameAsync = useProvider(userProvider.selectAsync((user) => user.name));\n```\n\n----------------------------------------\n\nTITLE: Creating Multiple Animation Controllers with Hooks in Flutter\nDESCRIPTION: Example showing how hooks can be used multiple times within the same build method to create multiple animation controllers without any negative consequences.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/about_hooks.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n@override\nWidget build(BuildContext context) {\n  final animationController = useAnimationController(\n    duration: const Duration(seconds: 2),\n  );\n  final anotherController = useAnimationController(\n    duration: const Duration(seconds: 2),\n  );\n\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Using the CLI tool to migrate Riverpod projects\nDESCRIPTION: Steps to run the migration tool in your project directory to analyze and update your codebase to the new Riverpod syntax, including example diff output.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_8\n\nLANGUAGE: Shell\nCODE:\n```\nriverpod migrate\n```\n\n----------------------------------------\n\nTITLE: Installing Riverpod in Dart project via pubspec.yaml\nDESCRIPTION: This snippet shows how to include the 'riverpod' package in a Dart project's pubspec.yaml dependencies, followed by executing 'dart pub get' to install dependencies and run the code generator with 'dart run build_runner watch'.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/introduction/getting_started.mdx#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\npubspec:\n  dependencies:\n    riverpod: ^X.Y.Z  # specify the desired version\n```\n\n----------------------------------------\n\nTITLE: Reading a Provider using BuildContext with Provider\nDESCRIPTION: Illustrates how to read a provider's value within a `StatelessWidget`'s build method using `context.watch<Model>()` from the Provider package. This establishes a dependency, causing the widget to rebuild when the model changes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/from_provider/provider_vs_riverpod.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nclass Example extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    Model model = context.watch<Model>();\n\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Consuming a NotifierProvider in a Flutter UI\nDESCRIPTION: This snippet shows how to use a NotifierProvider in a Flutter UI to interact with a list of todos. It demonstrates reading the state and calling methods to modify the state in response to user actions.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/providers/notifier_provider.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n// This code is referenced via trimSnippet(todosConsumer) but not directly shown in the text\n```\n\n----------------------------------------\n\nTITLE: Creating Activity Provider with HTTP Request\nDESCRIPTION: Implements a provider that fetches random activities from the Bored API using HTTP GET requests. The provider manages the asynchronous state of the activity data.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/case_studies/pull_to_refresh.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nfinal activityProvider = FutureProvider<Activity>((ref) async {\n  final response = await http.get(\n    Uri.https('www.boredapi.com', '/api/activity'),\n  );\n  return Activity.fromJson(jsonDecode(response.body));\n});\n```\n\n----------------------------------------\n\nTITLE: Running custom_lint for Riverpod\nDESCRIPTION: Shows the command to run the `custom_lint` tool to analyze code and identify potential issues when using Riverpod. This command helps in identifying and fixing errors related to Riverpod usage.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/introduction/getting_started.mdx#_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\ndart run custom_lint\n```\n\n----------------------------------------\n\nTITLE: Migrating from HookWidget to HookConsumerWidget - Dart\nDESCRIPTION: Demonstrates how to migrate from using `HookWidget` with `useProvider` to `HookConsumerWidget` with `ref.watch` in Riverpod 1.0.0.  This change is part of the syntax unification effort in Riverpod.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/migration/0.14.0_to_1.0.0.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nclass Example extends HookWidget {\n  @override\n  Widget build(BuildContext context) {\n    useState(...);\n    int count = useProvider(counterProvider);\n    ...\n  }\n}\n```\n\nLANGUAGE: dart\nCODE:\n```\nclass Example extends HookConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    useState(...);\n    int count = ref.watch(counterProvider);\n    ...\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Avoiding side effects during provider usage\nDESCRIPTION: This code demonstrates improper use of a provider to perform write or side-effect operations, such as submitting a form. Instead, providers should be used for read operations, maintaining side effects outside the provider scope to ensure predictable behavior.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/essentials/do_dont.mdx#_snippet_3\n\nLANGUAGE: Dart\nCODE:\n```\nfinal submitProvider = FutureProvider((ref) async {\n  final formState = ref.watch(formState);\n\n  // Bad: providerは\"write\"操作に使われるべきでありません。\n  return http.post('https://my-api.com', body: formState.toJson());\n});\n```\n\n----------------------------------------\n\nTITLE: Using Riverpod CLI Help Command\nDESCRIPTION: Command to verify the Riverpod CLI installation and view available commands and options.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/es/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nriverpod --help\n```\n\n----------------------------------------\n\nTITLE: Declaring a Simple Provider in Riverpod (Dart)\nDESCRIPTION: This snippet demonstrates how to declare a basic provider in Riverpod using Dart. The provider receives a 'ref' parameter, allowing it to read other providers or expose values for consumption across the widget tree. No external dependencies are required beyond Riverpod itself. The provider's output can be any serializable Dart value or object.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n// Example: Declaring a simple provider\nfinal someProvider = Provider<int>((ref) => 42);\n```\n\n----------------------------------------\n\nTITLE: Using onDispose for Cleanup\nDESCRIPTION: This snippet demonstrates how to use `onDispose` to perform cleanup when a provider's state is destroyed.  It shows how to close a `StreamController` when the `StreamProvider` is disposed. The `ref.onDispose` method takes a callback function that is executed when the provider is destroyed.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/tr/docusaurus-plugin-content-docs/current/concepts/providers.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nfinal example = StreamProvider.autoDispose((ref) {\n  final streamController = StreamController<int>();\n\n  ref.onDispose(() {\n    // Bu provider'ın durumu bozulduğunda StreamController'ı kapatır.\n    streamController.close();\n  });\n\n  return streamController.stream;\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Providers with Provider Package in Dart\nDESCRIPTION: Example showing how to define a provider using the Provider package where providers are widgets placed in the widget tree, typically inside a MultiProvider.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/from_provider/provider_vs_riverpod.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nclass Counter extends ChangeNotifier {\n ...\n}\n\nvoid main() {\n  runApp(\n    MultiProvider(\n      providers: [\n        ChangeNotifierProvider<Counter>(create: (context) => Counter()),\n      ],\n      child: MyApp(),\n    )\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Reading Providers with Riverpod Package in Dart\nDESCRIPTION: This snippet shows how to read providers using the Riverpod package. It demonstrates the use of ConsumerWidget and WidgetRef to access the provider's value.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/from_provider/provider_vs_riverpod.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nfinal modelProvider = Provider<Model>(...);\n\nclass Example extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    Model model = ref.watch(modelProvider);\n\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating Riverpod Project\nDESCRIPTION: Initiates the migration process for a Riverpod project using the riverpod CLI tool. This command analyzes the project and suggests necessary changes to upgrade to the latest Riverpod version.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/migration/0.14.0_to_1.0.0.mdx#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nriverpod migrate\n```\n\n----------------------------------------\n\nTITLE: Using ref.listen within a Provider (Post-1.0.0-dev.0) in Dart\nDESCRIPTION: Shows how to use `ref.listen` inside the definition of a provider (`anotherProvider`). This allows the provider to react to changes in another provider (`counter`) without causing `anotherProvider` itself to be recomputed or disposed, enabling side effects based on other providers' states.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/flutter_riverpod/CHANGELOG.md#2025-04-23_snippet_13\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nfinal counter = StateNotifierProvider<Counter, int>(...);\n\nfinal anotherProvider = Provider<T>((ref) {\n  ref.listen<int>(counter, (count) {\n    print('counter change: $count');\n  });\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Basic User Name Display Widget\nDESCRIPTION: Simple widget that watches the entire user object but only displays the name\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/reading.mdx#2025-04-23_snippet_16\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, WidgetRef ref) {\n  User user = ref.watch(userProvider);\n  return Text(user.name);\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing ProviderScope in Flutter App\nDESCRIPTION: Shows how to set up ProviderScope at the root of a Flutter application, which is required to enable Riverpod functionality throughout the app.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/first_request.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nvoid main() {\n  runApp(\n    // To install Riverpod, we need to add this widget above everything else.\n    // This should not be inside \"MyApp\" but as direct parameter to \"runApp\".\n    ProviderScope(\n      child: MyApp(),\n    ),\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Detecting Empty Dependency List in Riverpod Provider (Dart)\nDESCRIPTION: This code demonstrates a Riverpod provider with an empty dependency list. It uses the @Riverpod annotation with dependencies: [] but still watches a provider, resulting in a linting warning.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/provider_dependencies/missing_dependencies2_lint.md#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n@Riverpod(dependencies: [])\nint watchGeneratedScopedButEmptyDependencies(\n  Ref ref,\n) {\n  return ref.watch(generatedScopedProvider);\n}\n```\n\n----------------------------------------\n\nTITLE: Mocking a Provider - Dart\nDESCRIPTION: This snippet demonstrates how to mock a provider using the `overrides` parameter. The code highlights how to specify a list of providers to mock within the `overrides` parameter and how to customize their behavior. It provides an example of overriding `exampleProvider` with a mock.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/essentials/testing.mdx#_snippet_6\n\nLANGUAGE: Dart\nCODE:\n```\n    // 단위 테스트에서는 이전의 \"createContainer\" 유틸리티를 재사용합니다.\n\n    final container = ProviderContainer(\n      // 모의(Mock)할 providers 목록을 지정할 수 있습니다:\n      overrides: [\n        // 이 경우 \"exampleProvider\"를 모방(Mock)하고 있습니다.\n        exampleProvider.overrideWith((ref) {\n          // 이 함수는 provider의 일반적인 초기화 함수입니다.\n          // 일반적으로 \"ref.watch\"를 호출하고 초기 상태를 반환하는 곳입니다.\n\n          // 기본값인 \"Hello world\"를 사용자 정의 값으로 바꿔보겠습니다.\n          // 그러면 `exampleProvider`와 상호작용하면 이 값이 반환됩니다.\n          return \"Custom Value\";\n        }),\n      ],\n    );\n\n    // ProviderScope를 사용하여 위젯 테스트에서도 동일한 작업을 수행할 수 있습니다:\n\n    testWidgets('My widget test', (tester) async {\n      await tester.pumpWidget(\n        ProviderScope(\n          // ProviderScope에는 정확히 동일한 \"overrides\" 매개 변수가 있습니다\n          overrides: [\n            // 이전과 동일\n            exampleProvider.overrideWith((ref) => \"Custom Value\"),\n          ],\n          child: MyWidget(),\n        ),\n      );\n    });\n```\n\n----------------------------------------\n\nTITLE: Watching StateProvider State Dart\nDESCRIPTION: Shows the recommended way to access the current state of a StateProvider using ref.watch(stateProvider). This is an alternative to using the deprecated StateProvider.state property directly.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/hooks_riverpod/CHANGELOG.md#_snippet_6\n\nLANGUAGE: Dart\nCODE:\n```\nref.watch(stateProvider)\n```\n\n----------------------------------------\n\nTITLE: Initializing StateNotifier (Dart)\nDESCRIPTION: Demonstrates the legacy pattern for initializing a Riverpod StateNotifier, showing how state management logic is divided between the provider and the notifier constructor. Requires Flutter Riverpod <2.0, and uses StateNotifierProvider. Key parameters include the notifier state, and initialization logic may be split across multiple methods. Returns a StateNotifier holding the managed state. Limitations include scattered dependency declarations and less unified syntax.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/migration/from_state_notifier.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n<!-- buildInitOld.dart content placeholder -->\n```\n\n----------------------------------------\n\nTITLE: Awaiting Asynchronous Riverpod Provider Results in Dart Tests\nDESCRIPTION: This snippet shows how to handle asynchronous providers returning Futures or Streams in tests by reading the provider's `.future` property. This approach allows awaiting the provider’s completion, making it possible to assert asynchronous outcomes or errors. The snippet uses `expectLater` to assert future results appropriately. It requires understanding of Dart async testing patterns and Riverpod’s asynchronous handling.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/essentials/testing.mdx#_snippet_7\n\nLANGUAGE: dart\nCODE:\n```\n    // TODO: アプリのテストを行うためにcontainerを使用します。\n    // 期待値は非同期なので、\"expectLater\" を使うべきである。\n      // \"provider\" の代わりに \"provider.future\"で読み取ります。\n      // これは非同期providerの場合に可能で、providerの値を決めるfutureを返します。\n      // futureが期待値で決まることを確認できます。\n      // あるいはエラーの場合 \"throwsA\"を使用できます。\n\n```\n\n----------------------------------------\n\nTITLE: Consuming Live Chat StreamProvider in Dart\nDESCRIPTION: This snippet shows how to consume the chatProvider in a Flutter widget. It uses ref.watch to listen to the stream of chat messages and displays them in a ListView.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/providers/stream_provider.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nclass ChatView extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final messages = ref.watch(chatProvider);\n    return messages.when(\n      loading: () => const CircularProgressIndicator(),\n      error: (error, stack) => Text('Error: $error'),\n      data: (messages) {\n        return ListView.builder(\n          itemCount: messages.length,\n          itemBuilder: (context, index) {\n            final message = messages[index];\n            return Text(message.content);\n          },\n        );\n      },\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Cache State for a Specific Duration (Extension) - Dart\nDESCRIPTION: Demonstrates how to create an extension method to cache a provider's state for a specific duration using `Timer` and `ref.keepAlive`. This allows for a reusable way to keep the state alive for a set amount of time.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/essentials/auto_dispose.mdx#_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\n/// [duration] の間 providerを維持する。\n    // stateが破壊されるのを防ぐ。\n    // 期間経過後、自動破棄を再度有効にする。\n    // オプション：providerが再計算される場合（ref.watch など）、\n    // 保留中のタイマーをキャンセルする.\n```\n\n----------------------------------------\n\nTITLE: Cancelling In-Flight Requests with ref.onDispose in Riverpod (Dart)\nDESCRIPTION: This snippet introduces request cancellation using ref.onDispose within a Riverpod provider. The HTTP client (from package:http) is closed when the provider is disposed, such as when the user navigates away from the detail page. This prevents unnecessary processing and resource wastage. Dependencies: flutter_riverpod, http. Inputs: provider lifecycle events; outputs: cancelled HTTP requests if navigation occurs mid-request. Limitation: Appropriate provider auto-disposal must be enabled.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/case_studies/cancel.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n/* code from detailScreenCancel */\n```\n\n----------------------------------------\n\nTITLE: Handling Type Assignment Errors with autoDispose Providers in Dart\nDESCRIPTION: Shows a scenario where mixing autoDispose and non-autoDispose providers can cause a type assignment error during compilation. A provider marked with .autoDispose cannot be passed where AlwaysAliveProviderBase is expected, which can indicate a logic issue where providers with mismatched lifecycle semantics are watched. The suggested fix is to also mark dependent providers with .autoDispose to maintain consistency and ensure proper disposal behaviors.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/bn/docusaurus-plugin-content-docs/current/concepts/modifiers/auto_dispose.mdx#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nfinal firstProvider = Provider.autoDispose((ref) => 0);\n\nfinal secondProvider = Provider((ref) {\n  // The argument type 'AutoDisposeProvider<int>' can't be assigned to the\n  // parameter type 'AlwaysAliveProviderBase<Object, Null>'\n  ref.watch(firstProvider);\n});\n```\n\nLANGUAGE: dart\nCODE:\n```\nfinal firstProvider = Provider.autoDispose((ref) => 0);\n\nfinal secondProvider = Provider.autoDispose((ref) {\n  ref.watch(firstProvider);\n});\n```\n\n----------------------------------------\n\nTITLE: Misusing ref.read inside provider body\nDESCRIPTION: Shows an incorrect practice: using ref.read within the provider body causes the provider to rebuild whenever the read provider changes, which may be undesirable and lead to frequent updates.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/es/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#_snippet_6\n\nLANGUAGE: Dart\nCODE:\n```\nfinal myProvider = Provider((ref) {\n  final value = ref.read(anotherProvider);\n});\n```\n\n----------------------------------------\n\nTITLE: Defining and Watching StateNotifierProvider (Post-0.14.0) in Dart\nDESCRIPTION: Illustrates the updated syntax for `StateNotifierProvider` introduced in Riverpod 0.14.0. It requires specifying both the notifier type and the state type (`StateNotifierProvider<NotifierType, StateType>`). Accessing the notifier is done via `provider.notifier`, and the state is accessed by watching the provider directly.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/flutter_riverpod/CHANGELOG.md#2025-04-23_snippet_18\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nclass MyStateNotifier extends StateNotifier<MyModel> {...}\n\nfinal provider = StateNotifierProvider<MyStateNotifier, MyModel>>((ref) => MyStateNotifier());\n\n...\nWidget build(context, watch) {\n  MyStateNotifier notifier = watch(provider.notifier);\n  MyModel model = watch(provider);\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Invalidating Riverpod Provider Family Members - Riverpod/Dart\nDESCRIPTION: This code shows how to invalidate providers created by a provider family. You can either invalidate a specific instance of the family (e.g., `myFamily(0)`) or invalidate the entire family, which disposes of all its currently active instances.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/essentials/auto_dispose.mdx#_snippet_4\n\nLANGUAGE: Dart\nCODE:\n```\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal myFamily = Provider.family.autoDispose<String, int>((ref, id) => 'Value for id: $id');\n\nclass MyWidget extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    return Column(\n      children: [\n        ElevatedButton(\n          // Invalidate a specific family member\n          onPressed: () => ref.invalidate(myFamily(0)),\n          child: Text('Invalidate myFamily(0)'),\n        ),\n        ElevatedButton(\n          // Invalidate the whole family\n          onPressed: () => ref.invalidate(myFamily),\n          child: Text('Invalidate whole myFamily'),\n        ),\n      ],\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Combining Providers with Provider Package for Stateful Objects in Dart\nDESCRIPTION: Example showing how to combine providers using the Provider package with ChangeNotifierProxyProvider to create a stateful provider that reacts to changes in another provider.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/from_provider/provider_vs_riverpod.mdx#_snippet_9\n\nLANGUAGE: dart\nCODE:\n```\nclass UserNotifier extends ChangeNotifier {\n  String? _userId;\n\n  void setUserId(String? userId) {\n    if (userId != _userId) {\n      print('The user ID changed from $_userId to $userId');\n      _userId = userId;\n    }\n  }\n}\n\n// ...\n\nChangeNotifierProxyProvider<UserIdNotifier, UserNotifier>(\n  create: (context) => UserNotifier(),\n  update: (context, userIdNotifier, userNotifier) {\n    return userNotifier!\n      ..setUserId(userIdNotifier.userId);\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Accessing the state object using old syntax\nDESCRIPTION: Demonstrates how to access the current state of the notifier in a widget with the pre-0.14.0 syntax by reading provider.state.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_5\n\nLANGUAGE: Dart\nCODE:\n```\nWidget build(BuildContext context, ScopedReader watch) {\n  MyModel state = watch(provider.state);\n}\n```\n\n----------------------------------------\n\nTITLE: Reading Providers with Riverpod using ConsumerWidget\nDESCRIPTION: Equivalent example showing how to read a Model provider in Riverpod using ConsumerWidget and WidgetRef.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/riverpod_for_provider_users.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nfinal modelProvider = Provider<Model>(...);\n\nclass Example extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    Model model = ref.watch(modelProvider);\n\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Triggering Side Effects with Riverpod\nDESCRIPTION: Shows how Riverpod's ref.listen feature enables easy triggering of side effects, which is not straightforward with Provider.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/from_provider/motivation/motivation.mdx#2025-04-23_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nclass MyWidget extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    ref.listen<User?>(userProvider, (previous, next) {\n      if (next == null) {\n        showDialog(context: context, builder: (context) {\n          return AlertDialog(title: Text('Disconnected'));\n        });\n      }\n    });\n\n    // ...\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Piping ChangeNotifier to a Riverpod Provider in Dart\nDESCRIPTION: Demonstrates how to integrate a ChangeNotifier with Riverpod by piping its notification mechanism to a Riverpod provider when using code generation.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/essentials/websockets_sync.mdx#_snippet_2\n\nLANGUAGE: Dart\nCODE:\n```\n@riverpod\nString counter(CounterRef ref) {\n  // Create a ChangeNotifier\n  final notifier = MyChangeNotifier();\n  // Tell Riverpod to update our provider when the notifier changes\n  final listener = () => ref.state = notifier.value;\n  // Start listening to the notifier\n  notifier.addListener(listener);\n  // When the provider is destroyed or needs to refresh, dispose the notifier\n  ref.onDispose(() {\n    notifier.removeListener(listener);\n    notifier.dispose();\n  });\n  // Return the current value\n  return notifier.value;\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing the StateNotifier instance in a widget with new syntax\nDESCRIPTION: Illustrates retrieving the MyStateNotifier instance with the updated syntax by reading provider.notifier.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_4\n\nLANGUAGE: Dart\nCODE:\n```\nWidget build(BuildContext context, ScopedReader watch) {\n  MyStateNotifier notifier = watch(provider.notifier);\n}\n```\n\n----------------------------------------\n\nTITLE: StateNotifier Class Definition in Dart\nDESCRIPTION: This snippet shows a basic implementation of a StateNotifier class in Dart. It defines a `MyModel` class and a `MyStateNotifier` class that extends `StateNotifier<MyModel>`. The StateNotifier is initialized with an instance of MyModel as its initial state.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nclass MyModel {}\n\nclass MyStateNotifier extends StateNotifier<MyModel> {\n  MyStateNotifier(): super(MyModel());\n}\n```\n\n----------------------------------------\n\nTITLE: 수명주기 관리의 새로운 방식: `ref.onDispose`\nDESCRIPTION: 이 예제는 기존 `dispose` 콜백 대신 `ref.onDispose`를 활용하는 방식으로 수명주기 관리 방식을 전환하는 방법을 보여줍니다. 내부 상태를 정리하는 코드와 취소 토큰 또는 비동기 작업 취소를 위한 패턴도 함께 설명하며, `mounted` 프로퍼티의 부재로 인한 제한사항과, 이를 우회하는 커스텀 방법 또는 권장하는 취소 전략을 다룹니다.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/migration/from_state_notifier.mdx#_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet {...oldLifecycles} ... />\n```\n\n----------------------------------------\n\nTITLE: Using Consumer Widget with Provider Package in Dart\nDESCRIPTION: This snippet demonstrates the use of the Consumer widget from the Provider package for reading provider values and optimizing rebuilds.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/from_provider/provider_vs_riverpod.mdx#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nConsumer<Model>(\n  builder: (BuildContext context, Model model, Widget? child) {\n\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Using Consumer Widget with Riverpod Package in Dart\nDESCRIPTION: This snippet shows the use of the Consumer widget from the Riverpod package for reading provider values and optimizing rebuilds.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/from_provider/provider_vs_riverpod.mdx#2025-04-23_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nConsumer(\n  builder: (BuildContext context, WidgetRef ref, Widget? child) {\n    Model model = ref.watch(modelProvider);\n\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Sample diff output from migration tool\nDESCRIPTION: Example of the suggested code modifications the CLI provides, highlighting the change from `.state` to direct usage of the provider.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_9\n\nLANGUAGE: Dart\nCODE:\n```\nWidget build(BuildContext context, ScopedReader watch) {\n-  MyModel state = watch(provider.state);\n+  MyModel state = watch(provider);\n}\n```\n\n----------------------------------------\n\nTITLE: Consuming StateNotifierProvider in Flutter Widget Tree with Riverpod and Dart\nDESCRIPTION: This snippet showcases how to interact with a StateNotifierProvider from a Flutter UI using Riverpod in Dart. It demonstrates reading the current list of todos and invoking provider methods (e.g., addTodo, toggle) based on user actions via ConsumerWidget or Consumer. Dependencies include riverpod and optionally Flutter widgets; the snippet expects a previously defined todosProvider. Primary parameters involve context, ref (provider reference), and user-generated inputs. This usage pattern allows UI components to stay reactive to immutable state changes driven by the notifier.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/providers/state_notifier_provider.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nclass TodosPage extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final todos = ref.watch(todosProvider);\n    return ListView.builder(\n      itemCount: todos.length,\n      itemBuilder: (context, index) {\n        final todo = todos[index];\n        return ListTile(\n          title: Text(todo.description),\n          leading: Checkbox(\n            value: todo.completed,\n            onChanged: (_) {\n              ref.read(todosProvider.notifier).toggle(index);\n            },\n          ),\n        );\n      },\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Running the Android App\nDESCRIPTION: These commands create the necessary Android platform files for the example app and then run the application on an Android device or emulator. The 'flutter create' command adds Android platform support to the existing project.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/examples/pub/README.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nflutter create . --platforms android\nflutter run\n```\n\n----------------------------------------\n\nTITLE: Configuring Riverpod Generator Options in build.yaml\nDESCRIPTION: This YAML snippet shows how to configure global options for Riverpod generator in the build.yaml file, including customizing provider name prefixes and suffixes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_generator/README.md#2025-04-23_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\ntargets:\n  $default:\n    builders:\n      riverpod_generator:\n        options:\n          provider_name_prefix: \"\"\n          provider_family_name_prefix: \"\"\n          provider_name_suffix: \"Provider\"\n          provider_family_name_suffix: \"Provider\"\n```\n\n----------------------------------------\n\nTITLE: Declaring Multiple Riverpod Providers of the Same Type in Dart\nDESCRIPTION: Illustrates that Riverpod allows declaring multiple providers that create state of the same data type (e.g., multiple providers creating `String` values) without causing conflicts. This is a key difference compared to `package:provider`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/providers.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet language=\"dart\" {...declaringManyProviders}></AutoSnippet>\n```\n\n----------------------------------------\n\nTITLE: Migration of FutureProvider from Manual to Generated in Dart\nDESCRIPTION: This snippet compares the manual implementation of FutureProvider with its code-generated counterpart in Dart. It highlights dependencies on asynchronous functions and how the generated version simplifies and clarifies the provider setup.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/about_code_generation.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nBefore: <original FutureProvider implementation in non-code gen style>\n```\n\nLANGUAGE: dart\nCODE:\n```\nAfter: <generated FutureProvider variant in Dart>\n```\n\n----------------------------------------\n\nTITLE: Accessing StateNotifier Instance with new Dart Riverpod Syntax\nDESCRIPTION: Shows how to obtain the StateNotifier instance in Riverpod 0.14.0 and later by watching the provider's notifier property rather than the provider itself. This change reflects the separation between state and notifier access enforced by the updated API.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/tr/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, ScopedReader watch) {\n  MyStateNotifier notifier = watch(provider.notifier);\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Loading and Error States in Eager Initialization with Riverpod (Dart)\nDESCRIPTION: This snippet explains how to manage loading and error states during eager initialization using a Consumer widget in Riverpod. It suggests displaying a progress indicator while loading and handling errors appropriately, ensuring a smooth user experience.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/essentials/eager_initialization.mdx#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\n<AutoSnippet raw={asyncConsumerExample} />\n```\n\n----------------------------------------\n\nTITLE: Using raw_loader to import code snippets as raw text\nDESCRIPTION: Imports Dart code snippets from external files as raw text for display or processing purposes within documentation or UI components. These snippets include various provider implementations such as sync, async, family, and autoDispose variants.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/about_code_generation.mdx#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\nimport fetchUser from \"!!raw-loader!/docs/concepts/about_codegen/main.dart\";\nimport rawFetchUser from \"!!raw-loader!/docs/concepts/about_codegen/raw.dart\";\nimport syncFn from \"!!raw-loader!/docs/concepts/about_codegen/provider_type/sync_fn.dart\";\nimport syncClass from \"!!raw-loader!/docs/concepts/about_codegen/provider_type/sync_class.dart\";\nimport asyncFnFuture from \"!!raw-loader!/docs/concepts/about_codegen/provider_type/async_fn_future.dart\";\nimport asyncClassFuture from \"!!raw-loader!/docs/concepts/about_codegen/provider_type/async_class_future.dart\";\nimport asyncFnStream from \"!!raw-loader!/docs/concepts/about_codegen/provider_type/async_fn_stream.dart\";\nimport asyncClassStream from \"!!raw-loader!/docs/concepts/about_codegen/provider_type/async_class_stream.dart\";\nimport familyFn from \"!!raw-loader!/docs/concepts/about_codegen/provider_type/family_fn.dart\";\nimport familyClass from \"!!raw-loader!/docs/concepts/about_codegen/provider_type/family_class.dart\";\nimport provider from \"!!raw-loader!/docs/concepts/about_codegen/provider_type/non_code_gen/provider.dart\";\nimport notifierProvider from \"!!raw-loader!/docs/concepts/about_codegen/provider_type/non_code_gen/notifier_provider.dart\";\nimport futureProvider from \"!!raw-loader!/docs/concepts/about_codegen/provider_type/non_code_gen/future_provider.dart\";\nimport asyncNotifierProvider from \"!!raw-loader!/docs/concepts/about_codegen/provider_type/non_code_gen/async_notifier_provider.dart\";\nimport streamProvider from \"!!raw-loader!/docs/concepts/about_codegen/provider_type/non_code_gen/stream_provider.dart\";\nimport streamNotifierProvider from \"!!raw-loader!/docs/concepts/about_codegen/provider_type/non_code_gen/stream_notifier_provider.dart\";\nimport autoDisposeCodeGen from \"!!raw-loader!/docs/concepts/about_codegen/provider_type/auto_dispose.dart\";\nimport autoDisposeNonCodeGen from \"!!raw-loader!/docs/concepts/about_codegen/provider_type/non_code_gen/auto_dispose.dart\";\nimport familyCodeGen from \"!!raw-loader!/docs/concepts/about_codegen/provider_type/family.dart\";\nimport familyNonCodeGen from \"!!raw-loader!/docs/concepts/about_codegen/provider_type/non_code_gen/family.dart\";\n```\n\n----------------------------------------\n\nTITLE: Migrating from StreamProvider to Code Generation (Dart)\nDESCRIPTION: This snippet shows the 'before' state using a non-code-generation `StreamProvider`. The 'after' state uses an asynchronous (Stream) functional provider with code generation.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/about_code_generation.mdx#_snippet_14\n\nLANGUAGE: dart\nCODE:\n```\n{trimSnippet(streamProvider)}\n```\n\n----------------------------------------\n\nTITLE: Overriding FutureProvider with AsyncValue in Tests (Dart)\nDESCRIPTION: This snippet demonstrates how select provider types, such as FutureProvider, can be overridden in a test to return a specific AsyncValue instead of the default behavior. Useful for simulating edge-cases or network responses without executing real code. Dependencies: riverpod (>=2.0.0 limitation: overrideWithValue temporarily removed from some providers). Input: provider reference; Output: mocked AsyncValue response.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/cookbooks/testing.mdx#2025-04-23_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nfutureProvider.overrideWithValue(const AsyncValue.data('test value')),\n\n```\n\n----------------------------------------\n\nTITLE: Disabling AsyncValue Conversion for Raw Stream/Future in Dart\nDESCRIPTION: Shows how to disable Riverpod's automatic conversion of Stream/Future to AsyncValue by using the Raw typedef, allowing direct access to the underlying object.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/essentials/websockets_sync.mdx#_snippet_6\n\nLANGUAGE: Dart\nCODE:\n```\n// With the default behavior, Stream/Future objects are converted to AsyncValue\n@riverpod\nFuture<String> futureValue(FutureValueRef ref) async {\n  return 'Hello world';\n}\n\n// Using Raw prevents the convertion\n@riverpod\nRaw<Future<String>> rawFuture(RawFutureRef ref) async {\n  return Future.value('Hello world');\n}\n\n// Reading a provider that returns Raw<Future<String>>\nConsumer(builder: (context, ref, child) {\n  // Notice how we get the Future directly, not an AsyncValue\n  final future = ref.watch(rawFutureProvider);\n  // We need to handle the Future ourselves\n  return FutureBuilder<String>(\n    future: future,\n    builder: (context, snapshot) {\n      if (snapshot.hasData) {\n        return Text(snapshot.data!);\n      }\n      return CircularProgressIndicator();\n    },\n  );\n});\n```\n\n----------------------------------------\n\nTITLE: Extension method for ChangeNotifier with code generation (Dart)\nDESCRIPTION: Defines an extension method on Ref to facilitate the use of ChangeNotifiers with Riverpod's code generation. This method listens to the ChangeNotifier and disposes it properly when the provider is disposed. It allows you to expose a ChangeNotifier using the @riverpod annotation.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/from_provider/quickstart.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nextension ChangeNotifierWithCodeGenExtension on Ref {\n  T listenAndDisposeChangeNotifier<T extends ChangeNotifier>(T notifier) {\n    notifier.addListener(notifyListeners);\n    onDispose(() => notifier.removeListener(notifyListeners));\n    onDispose(notifier.dispose);\n    return notifier;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Side Effect Implementation\nDESCRIPTION: Shows an anti-pattern where side effects are performed during provider initialization, which can lead to unexpected behaviors.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/do_dont.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nfinal submitProvider = FutureProvider((ref) async {\n  final formState = ref.watch(formState);\n\n  // Bad: Providers should not be used for \"write\" operations.\n  return http.post('https://my-api.com', body: formState.toJson());\n});\n```\n\n----------------------------------------\n\nTITLE: provider 스스로 무효화 - Dart\nDESCRIPTION: provider가 스스로, 즉 내부 로직에서 ref.invalidateSelf()를 호출하여 always 새로운 상태를 생성하는 방법입니다. 이는 개별 provider 인스턴스를 특정 조건에 따라 무효화하는 기술에 유용합니다. dependencies: Riverpod, Dart.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/essentials/auto_dispose.mdx#_snippet_4\n\nLANGUAGE: Dart\nCODE:\n```\n```dart\n// provider가 스스로 무효화하여 새 상태를 생성합니다.\nref.invalidateSelf();\n```\n```\n\n----------------------------------------\n\nTITLE: HookConsumerWidget Implementation\nDESCRIPTION: This snippet demonstrates how to create a `HookConsumerWidget` when using `flutter_hooks`. It extends `HookConsumerWidget` instead of `HookWidget`, providing access to `ref`.  It allows the widget to read and watch providers within hooks.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_3\n\nLANGUAGE: Dart\nCODE:\n```\nclass MyHookConsumerWidget extends HookConsumerWidget {\n  const MyHookConsumerWidget({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // use ref here to interact with providers\n    return const Text('Hello World');\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrectly Watching an autoDispose Provider in Dart\nDESCRIPTION: Shows an incorrect scenario where a standard provider (which is 'always alive') tries to watch a provider marked with `.autoDispose`. This causes a compile-time error because it would prevent the `firstProvider` from ever being disposed.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/concepts/modifiers/auto_dispose.mdx#_snippet_4\n\nLANGUAGE: Dart\nCODE:\n```\nfinal firstProvider = Provider.autoDispose((ref) => 0);\n\nfinal secondProvider = Provider((ref) {\n  // Le type d'argument 'AutoDisposeProvider<int>' ne peut être \n  // attribué au type de paramètre 'AlwaysAliveProviderBase<Object, Null>'.\n  ref.watch(firstProvider);\n});\n```\n\n----------------------------------------\n\nTITLE: Updating StateProvider State Inefficiently in Dart\nDESCRIPTION: Shows a less efficient approach to updating a StateProvider's state based on its previous value, where the provider is read twice. This example demonstrates what to avoid.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/providers/state_provider.mdx#_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\nWidget build(BuildContext context, WidgetRef ref) {\n  return ElevatedButton(\n    onPressed: () {\n      // Read the provider once to get the current value\n      final currentCount = ref.read(counterProvider);\n      // Read it a second time to obtain the controller and update the state\n      ref.read(counterProvider.notifier).state = currentCount + 1;\n    },\n    child: const Text('Increment'),\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Defining StateNotifierProvider From 0.14.0 (Dart)\nDESCRIPTION: Shows the updated syntax for `StateNotifierProvider` introduced in Riverpod 0.14.0, requiring both Notifier and State types in the generic signature. It also demonstrates accessing the notifier instance via `provider.notifier` and the state directly via `watch(provider)`. Requires the `riverpod` package and a `StateNotifier` implementation.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod/CHANGELOG.md#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nclass MyStateNotifier extends StateNotifier<MyModel> {...}\n\nfinal provider = StateNotifierProvider<MyStateNotifier, MyModel>>((ref) => MyStateNotifier());\n\n...\nWidget build(context, watch) {\n  MyStateNotifier notifier = watch(provider.notifier);\n  MyModel model = watch(provider);\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Exemple de surcharge d'un provider pour un sous-arbre avec Riverpod\nDESCRIPTION: Ce snippet démontre comment remplacer ou surcharger un provider pour une portion spécifique de l'interface en utilisant le scoping, permettant ainsi d'avoir des configurations ou états différents selon le contexte ou la page. Cela offre une flexibilité similaire à celle d'InheritedWidget mais en utilisant la gestion d'état de Riverpod.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/concepts/scopes.mdx#_snippet_3\n\nLANGUAGE: Dart\nCODE:\n```\n{trimSnippet(subtreeScope)}\n```\n\n----------------------------------------\n\nTITLE: Initializing Notifier in Flutter Riverpod with Dart\nDESCRIPTION: This snippet presents the newer approach introduced in Riverpod 2.0, where a Notifier class is defined with a single build method to centralize initialization and reactive logic. Dependencies are accessed through the Ref instance available in the notifier class. The provider is simpler and unifies the syntax for sync and async state management. This approach avoids placing logic in the constructor and supports more readable, maintainable code. Input parameters are handled inside the build method, and output is the notifier's maintained state.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/migration/from_state_notifier.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n/* New Notifier API example */\nimport 'package:riverpod/riverpod.dart';\n\nclass CounterNotifier extends Notifier<int> {\n  @override\n  int build() {\n    return 0; // initial state\n  }\n\n  void increment() {\n    state = state + 1;\n  }\n}\n\nfinal counterProvider = NotifierProvider<CounterNotifier, int>(CounterNotifier.new);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Test Isolation in Flutter using Riverpod\nDESCRIPTION: This Flutter widget test (`testWidgets`) demonstrates that Riverpod provider state is not shared between tests. Two separate tests increment the same `counterProvider`, but each test starts with the counter at 0 because `ProviderScope` creates an isolated state container for each test.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/cookbooks/testing.mdx#2025-04-23_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\n// A Counter implemented using StateProvider\nfinal counterProvider = StateProvider((ref) => 0);\n\nvoid main() {\n  testWidgets('Counter increments smoke test', (tester) async {\n    await tester.pumpWidget(\n      ProviderScope(\n        child: MaterialApp(\n          home: Scaffold(\n            body: Consumer(\n              builder: (context, ref, _) {\n                final count = ref.watch(counterProvider);\n                return Text('$count');\n              },\n            ),\n          ),\n        ),\n      ),\n    );\n\n    // The default value is `0`, as declared in our provider\n    expect(find.text('0'), findsOneWidget);\n    expect(find.text('1'), findsNothing);\n\n    // Increment the state and re-render\n    await tester.tap(find.byType(Scaffold));\n    await tester.pump();\n\n    // The counter state is now `1`\n    expect(find.text('1'), findsOneWidget);\n    expect(find.text('0'), findsNothing);\n  });\n\n  testWidgets('the counter state is not shared between tests', (tester) async {\n    await tester.pumpWidget(\n      ProviderScope(\n        child: MaterialApp(\n          home: Scaffold(\n            body: Consumer(\n              builder: (context, ref, _) {\n                final count = ref.watch(counterProvider);\n                return Text('$count');\n              },\n            ),\n          ),\n        ),\n      ),\n    );\n\n    // The state is `0` again, with no tearDown/setUp needed\n    expect(find.text('0'), findsOneWidget);\n    expect(find.text('1'), findsNothing);\n  });\n}\n\n```\n\n----------------------------------------\n\nTITLE: FadeIn Widget with HookWidget - Flutter\nDESCRIPTION: This code implements a fade-in animation using a HookWidget in Flutter with the flutter_hooks package. It utilizes useAnimationController to manage the animation and useEffect to start the animation when the widget is first built. The widget rebuilds when the animation updates using useAnimation. This example demonstrates how hooks simplify state management and reduce boilerplate code compared to StatefulWidgets.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/about_hooks.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nclass FadeIn extends HookWidget {\n  const FadeIn({Key? key, required this.child}) : super(key: key);\n\n  final Widget child;\n\n  @override\n  Widget build(BuildContext context) {\n    // 创建一个 AnimationController。\n    // 卸载 widget 时，控制器将自动处置。\n    final animationController = useAnimationController(\n      duration: const Duration(seconds: 2),\n    );\n\n    // useEffect 相当于 initState + didUpdateWidget + dispose。\n    // 传给 useEffect 的回调会在第一次调用钩子时执行，\n    // 然后每当作为第二个参数传递的列表发生变化时也会执行。\n    // 由于我们在这里传递的是一个空的常量列表，\n    // 因此严格意义上等同于 `initState`。\n    useEffect(() {\n      // 在首次呈现 widget 时启动动画。\n      animationController.forward();\n      // 我们可以选择在这里返回一些“处置”逻辑\n      return null;\n    }, const []);\n\n    // 告诉 Flutter 在动画更新时重建此部件。\n    // 这相当于 AnimatedBuilder\n    useAnimation(animationController);\n\n    return Opacity(\n      opacity: animationController.value,\n      child: child,\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using AsyncNotifier.listenSelf Example - Dart\nDESCRIPTION: Code example showing how to use the AsyncNotifier.listenSelf feature in Riverpod\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/flutter_riverpod/CHANGELOG.md#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\nclass Example extends _$Example {\n  @override\n  Stream<Model> build() {\n    // TODO return some stream\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating from NotifierProvider to Code Generation (Dart)\nDESCRIPTION: This snippet shows the 'before' state using a non-code-generation `NotifierProvider`. The 'after' state uses a synchronous class-based provider with code generation.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/about_code_generation.mdx#_snippet_12\n\nLANGUAGE: dart\nCODE:\n```\n{trimSnippet(notifierProvider)}\n```\n\n----------------------------------------\n\nTITLE: Connecting TextField to Search Input Provider in Flutter\nDESCRIPTION: Sets up a TextField that updates the searchInputProvider state when the user types.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/bn/docusaurus-plugin-content-docs/current/cookbooks/search_as_we_type.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nConsumer(\n  builder: (context, ref, child) {\n    return TextField(\n      onChanged: (value) => ref.read(searchInputProvider.notifier).state = value,\n    );\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Complete Application Code - Dart\nDESCRIPTION: This code snippet presents the complete code incorporating all of the preceding snippets, combining the activity class, provider definitions, UI integration, and the refresh logic. It demonstrates the full implementation of the pull-to-refresh feature with loading and error handling.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/case_studies/pull_to_refresh.mdx#_snippet_6\n\nLANGUAGE: Dart\nCODE:\n```\n/* code for fullApp not provided in the text */\n```\n\n----------------------------------------\n\nTITLE: Widget ref.watch Example - Dart\nDESCRIPTION: Demonstrates how a widget uses `ref.watch` to listen to a provider. When the provider's value changes, the widget rebuilds and displays the new value. This makes it easy to update the UI in response to provider changes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_8\n\nLANGUAGE: dart\nCODE:\n```\n/* ... content of reading_watch_build.dart ... */\n```\n\n----------------------------------------\n\nTITLE: Creating Sort Provider - Dart\nDESCRIPTION: This snippet demonstrates the creation of a `StateProvider` that manages the sort type. This provider holds the current sort type (e.g., price, name). The output is the current sort type, and there are no specific dependencies beyond Riverpod.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/providers/state_provider.mdx#_snippet_3\n\nLANGUAGE: Dart\nCODE:\n```\n// Code for Sort Provider (sort_provider.dart)\n```\n\n----------------------------------------\n\nTITLE: Defining StateNotifier and Model with Riverpod (Dart)\nDESCRIPTION: Defines a custom model class and a StateNotifier subclass for state management with Riverpod. Prerequisites include the state_notifier and flutter_riverpod packages. The snippet shows the typical class-based setup required for Riverpod state management, with MyStateNotifier initializing its state from MyModel.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nclass MyModel {}\n\nclass MyStateNotifier extends StateNotifier<MyModel> {\n  MyStateNotifier(): super(MyModel());\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing the Stream from a Riverpod Provider (Dart)\nDESCRIPTION: Demonstrates retrieving the underlying `Stream` object directly from a provider (specifically, one like `StreamProvider`) using `ref.watch(userProvider.stream)`. This allows direct interaction with the stream, for example, passing it to other stream-handling widgets or libraries. Depends on `BuildContext`, `WidgetRef`, and the `userProvider`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_13\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, WidgetRef ref) {\n  Stream<User> user = ref.watch(userProvider.stream);\n}\n```\n\n----------------------------------------\n\nTITLE: Using ref.watch to Reactively Select Provider State (Dart)\nDESCRIPTION: This snippet demonstrates the use of ref.watch to combine or filter multiple providers and create a new derived provider. When any dependency changes, the new provider automatically recomputes its state. Requires Riverpod, and is typically used inside provider bodies or widgets. Inputs are other providers, outputs are derived or filtered values.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\n// Example: Combining providers with ref.watch\nfinal filteredTodoListProvider = Provider<List<Todo>>((ref) {\n  final filter = ref.watch(filterTypeProvider);\n  final todos = ref.watch(todosProvider);\n  return todos.where((todo) => filter.apply(todo)).toList();\n});\n```\n\n----------------------------------------\n\nTITLE: Defining an Asynchronous (Future) Class-Based Provider (Dart)\nDESCRIPTION: This snippet demonstrates defining an asynchronous Riverpod provider managing a Future using an annotated class. It allows methods for side-effects while handling async state via AsyncValue.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/about_code_generation.mdx#_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\n{trimSnippet(asyncClassFuture)}\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom cacheFor Extension for Timed State Preservation\nDESCRIPTION: Implementation of a reusable extension method that keeps a provider's state alive for a specific duration before allowing automatic disposal.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/auto_dispose.mdx#2025-04-23_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\nextension AutoDisposeRefExtension on AutoDisposeRef {\n  /// Keeps the provider alive for [duration] after it was last listened to.\n  void cacheFor(Duration duration) {\n    final link = keepAlive();\n    Timer? timer;\n\n    onCancel(() {\n      timer = Timer(duration, () {\n        link.close();\n      });\n    });\n\n    onResume(() {\n      timer?.cancel();\n    });\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Example Console Output from ProviderObserver Logger\nDESCRIPTION: This text snippet shows example output printed to the console by the `Logger` implementation of `ProviderObserver` shown previously. It demonstrates the format of the log, showing the provider name (\"counter\") and its new value (\"1\") when an update occurs. This output is generated by the `debugPrint` call within the `didUpdateProvider` override.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/provider_observer.mdx#2025-04-23_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nI/flutter (16783): {\nI/flutter (16783):   \"provider\": \"counter\",\nI/flutter (16783):   \"newValue\": \"1\"\nI/flutter (16783): }\n```\n\n----------------------------------------\n\nTITLE: Running Riverpod Graph Generator for D2 Output\nDESCRIPTION: This command runs the Riverpod graph generator tool, analyzing a specified folder and producing output in D2 markup format. It uses the '-f d2' flag to specify the D2 format.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_graph/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndart run riverpod_graph path/to/folder -f d2\n```\n\n----------------------------------------\n\nTITLE: Implementing Abstract Build Method in Riverpod Notifiers\nDESCRIPTION: Shows how to use an abstract build method in Riverpod Notifiers, which is equivalent to specifying an empty dependency list and throwing an UnimplementedError.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_generator/CHANGELOG.md#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\nclass Example extends _$Example {\n  @override\n  int build();\n}\n```\n\nLANGUAGE: dart\nCODE:\n```\n@Riverpod(dependencies: [])\nclass Example extends _$Example {\n  @override\n  int build() => throw UnimplementedError();\n}\n```\n\n----------------------------------------\n\nTITLE: Avoiding Dynamic Provider Creation (Anti-pattern)\nDESCRIPTION: This example shows an anti-pattern where providers are created dynamically as instance variables within a class. This approach can lead to memory leaks and unpredictable behavior.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/essentials/do_dont.mdx#_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\nclass Example {\n  // Operazione non supportata. Può portare a memory leaks e comportamenti imprevisti.\n  final provider = Provider<String>((ref) => 'Hello world');\n}\n```\n\n----------------------------------------\n\nTITLE: Updating StateProvider, Bad Practice - Dart\nDESCRIPTION: This code snippet shows an example of updating a state with potential issues by reading the state twice and performing an operation. This is not the recommended approach. It uses the `ref.read` method. The intended use is to show how to update the state in a possibly non optimal manner.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/providers/state_provider.mdx#_snippet_6\n\nLANGUAGE: Dart\nCODE:\n```\n// Code for Update Read Twice (update_read_twice.dart)\n```\n\n----------------------------------------\n\nTITLE: Installing the Riverpod migration CLI tool\nDESCRIPTION: Instructions to install the Riverpod CLI migration tool using Dart's package manager to facilitate automatic code updates.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_7\n\nLANGUAGE: Shell\nCODE:\n```\ndart pub global activate riverpod_cli\n```\n\n----------------------------------------\n\nTITLE: Widget ref.listen Example - Dart\nDESCRIPTION: Shows how a widget uses `ref.listen` to respond to provider changes, which is used for performing side effects, like displaying a message when an event occurs on the listened provider, but without rebuilding the widget.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_10\n\nLANGUAGE: dart\nCODE:\n```\n/* ... content of reading_listen_build.dart ... */\n```\n\n----------------------------------------\n\nTITLE: Consuming State (Pre-0.14.0) in a Widget (Dart)\nDESCRIPTION: Shows the old method for watching StateNotifier state via provider.state. Riverpod 0.14.0 and newer deprecate this access pattern in favor of directly watching the provider. Requires a properly set up provider and MyModel state.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#2025-04-23_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, ScopedReader watch) {\n  MyModel state = watch(provider.state);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom ProviderObserver for Logging in Dart\nDESCRIPTION: Conceptual example demonstrating how to create a custom `Logger` class by extending `ProviderObserver` in Dart. It overrides the `didUpdateProvider` method to log the provider's name and its new value whenever a provider notifies its listeners of a change. This requires implementing the actual class based on this pattern.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/provider_observer.mdx#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\n// The actual code is referenced via an import (provider_observer_logger.dart)\n// and not directly present in the source text.\n// Example structure based on description:\n\n// import 'package:flutter_riverpod/flutter_riverpod.dart';\n// import 'dart:convert';\n\n// class Logger extends ProviderObserver {\n//   @override\n//   void didUpdateProvider(\n//     ProviderBase provider,\n//     Object? previousValue,\n//     Object? newValue,\n//     ProviderContainer container,\n//   ) {\n//     print('''{\n//   \"provider\": \"${provider.name ?? provider.runtimeType}\",\n//   \"newValue\": \"$newValue\"\n// }''');\n//   }\n// \n//   // Optionally override other methods like didAddProvider, didDisposeProvider\n// }\n```\n\n----------------------------------------\n\nTITLE: Migrating Provider from Manual Type to Code-Generation in Dart\nDESCRIPTION: This snippet demonstrates how to replace an explicit provider declaration with a code-generated version to simplify type management. It shows the 'Before' code with explicit provider definition and the 'After' code using a generated sync function. Dependencies include the Riverpod package for provider management.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/about_code_generation.mdx#_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\n{trimSnippet(provider)}\n```\n\n----------------------------------------\n\nTITLE: Correct AutoDispose Provider Usage in Dart\nDESCRIPTION: Corrected example showing proper usage where both providers use .autoDispose modifier.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/modifiers/auto_dispose.mdx#2025-04-23_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nfinal firstProvider = Provider.autoDispose((ref) => 0);\n\nfinal secondProvider = Provider.autoDispose((ref) {\n  ref.watch(firstProvider);\n});\n```\n\n----------------------------------------\n\nTITLE: Reading a Provider On-Demand with ref.read inside a Class Method in Dart\nDESCRIPTION: Defines a `Repository` class that receives `Ref` in its constructor, allowing methods within the class to access provider states. The `fetchCatalog` method uses `ref.read(userTokenProvider)` to get the current user token only when the method is invoked, preventing the `repositoryProvider` from rebuilding if the token changes when it's not relevant to the repository instance itself.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#2025-04-23_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nfinal userTokenProvider = StateProvider<String>((ref) => null);\n\nfinal repositoryProvider = Provider(Repository.new);\n\nclass Repository {\n  Repository(this.ref);\n\n  final Ref ref;\n\n  Future<Catalog> fetchCatalog() async {\n    String token = ref.read(userTokenProvider);\n\n    final response = await dio.get('/path', queryParameters: {\n      'token': token,\n    });\n\n    return Catalog.fromJson(response.data);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing the Future from a Riverpod Provider (Dart)\nDESCRIPTION: Shows how to obtain a `Future` representing the latest value emitted by an asynchronous provider using `ref.watch(userProvider.future)`. This `Future` completes with the most recent data value received from the underlying stream or future. Depends on `BuildContext`, `WidgetRef`, and the `userProvider`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_14\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, WidgetRef ref) {\n  Future<User> user = ref.watch(userProvider.future);\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Provider Isolation with testWidgets - Riverpod - Dart\nDESCRIPTION: Demonstrates how to use testWidgets in Flutter to ensure that Riverpod providers do not share state between individual tests. Uses ProviderContainer to create isolated provider environments in tests. Useful for verifying that global provider declarations do not cause unwanted state persistence across tests. Dependencies: flutter_test, riverpod, flutter_riverpod. Expects testWidgets or similar test framework environment. Accepts global providers and verifies value resets after each test. Output is isolation of state and successful passing test assertions.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/cookbooks/testing.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal counterProvider = StateProvider((ref) => 0);\n\nvoid main() {\n  testWidgets('Each test gets a fresh provider state', (tester) async {\n    final container = ProviderContainer();\n    expect(container.read(counterProvider), 0);\n    container.read(counterProvider.notifier).state++;\n    expect(container.read(counterProvider), 1);\n  });\n\n  testWidgets('Different test, state resets here', (tester) async {\n    final container = ProviderContainer();\n    expect(container.read(counterProvider), 0);\n  });\n}\n\n```\n\n----------------------------------------\n\nTITLE: Combining Stateful Providers with ChangeNotifierProxyProvider in Provider Package (Dart)\nDESCRIPTION: This snippet demonstrates how to combine stateful providers using ChangeNotifierProxyProvider in the Provider package, creating a UserNotifier based on UserIdNotifier.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/from_provider/provider_vs_riverpod.mdx#2025-04-23_snippet_8\n\nLANGUAGE: dart\nCODE:\n```\nclass UserIdNotifier extends ChangeNotifier {\n  String? userId;\n}\n\n// ...\n\nChangeNotifierProvider<UserIdNotifier>(create: (context) => UserIdNotifier()),\n\n// ...\n\nclass UserNotifier extends ChangeNotifier {\n  String? _userId;\n\n  void setUserId(String? userId) {\n    if (userId != _userId) {\n      print('The user ID changed from $_userId to $userId');\n      _userId = userId;\n    }\n  }\n}\n\n// ...\n\nChangeNotifierProxyProvider<UserIdNotifier, UserNotifier>(\n  create: (context) => UserNotifier(),\n  update: (context, userIdNotifier, userNotifier) {\n    return userNotifier!\n      ..setUserId(userIdNotifier.userId);\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Enabling Custom Lint Plugin in analysis_options.yaml\nDESCRIPTION: Configuration required in analysis_options.yaml to enable the custom_lint plugin.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint/README.md#2025-04-23_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nanalyzer:\n  plugins:\n    - custom_lint\n```\n\n----------------------------------------\n\nTITLE: 이전 `StateNotifier` 예제(구버전 문법)\nDESCRIPTION: 기존 `StateNotifier`를 사용하는 기술적 예제로, reactive dependencies와 초기화 신호 분리 방식을 보여줍니다. 이 예제는 구버전 `StateNotifier` 사용법을 통해 단순한 상태 초기화와 업데이트 방법을 설명하며, 후속 `Notifier` 구조와 비교하여 차이점을 이해하는 데 도움을 줍니다. dependencies와 생성자 관계를 이해하는 데 유용합니다.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/migration/from_state_notifier.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet raw={buildInitOld}/>\n```\n\n----------------------------------------\n\nTITLE: Using Provider Modifiers in Dart\nDESCRIPTION: Illustrates the use of provider modifiers like autoDispose and family, which add extra functionalities to providers.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/providers.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nfinal myAutoDisposeProvider = StateProvider.autoDispose<int>((ref) => 0);\nfinal myFamilyProvider = Provider.family<String, int>((ref, id) => '$id');\n```\n\n----------------------------------------\n\nTITLE: Consumer Widget Dependencies\nDESCRIPTION: Test case showing unused dependency in a ConsumerStatefulWidget class\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/provider_dependencies/unused_dependency_lint.md#2025-04-23_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\n// expect_lint: provider_dependencies\n@Dependencies([dep])\nclass StateNotFound extends ConsumerStatefulWidget {\n  @override\n```\n\n----------------------------------------\n\nTITLE: Functional Provider Migration\nDESCRIPTION: Shows migration from basic Provider to code-generated functional provider syntax. The new syntax uses the @riverpod annotation and defines a simple function.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/about_code_generation.mdx#2025-04-23_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nfinal myProvider = Provider<String>((ref) => 'Hello');\n```\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\nString value(ValueRef ref) => 'Hello';\n```\n\n----------------------------------------\n\nTITLE: HookConsumerWidget ile Sağlayıcıları ve Kancaları Kullanma (Dart)\nDESCRIPTION: flutter_hooks kullananlar için bu örnek, hem Flutter Kancalarını (useState gibi) kullanmak hem de 'build' yöntemindeki 'ref' parametresi aracılığıyla Riverpod sağlayıcılarını ('ref.watch' kullanarak) dinlemek için HookWidget yerine HookConsumerWidget'ın nasıl kullanılacağını gösterir.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/tr/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nclass HomeView extends HookConsumerWidget {\n  const HomeView({Key? key}): super(key: key);\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // HookConsumerWidget, derleme yöntemi içinde kancaların kullanılmasına izin verir\n    final state = useState(0);\n\n    // Provider'ları dinlemek için ref parametresini de kullanabiliriz.\n    final counter = ref.watch(counterProvider);\n    return Text('$counter');\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Reading provider state and reacting to changes to reorder product list\nDESCRIPTION: Demonstrates how to create a derived provider (sortedProductProvider) that reacts to changes in the sort type provider and re-sorts the product list accordingly. It updates automatically whenever the sorting preference changes, ensuring UI consistency.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/es/docusaurus-plugin-content-docs/current/providers/state_provider.mdx#_snippet_3\n\nLANGUAGE: Dart\nCODE:\n```\n<CodeBlock>{trimSnippet(sortedProductProvider)}</CodeBlock>\n```\n\n----------------------------------------\n\nTITLE: Listening to Provider Changes From 0.6.0 (Dart)\nDESCRIPTION: Demonstrates the method introduced in Riverpod 0.6.0 for listening to provider changes outside the widget tree using `ProviderContainer.listen`. This replaced the older `Provider.watchOwner` functionality and provides callbacks for potential changes (`mayHaveChanged`) and confirmed changes (`didChange`). The subscription should be closed when no longer needed.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod/CHANGELOG.md#2025-04-23_snippet_16\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nProviderContainer container;\nfinal provider = Provider((ref) => 0);\n\nfinal subscription = container.listen(\n  provider,\n  mayHaveChanged: (sub) {},\n  didChange: (sub) {}.\n);\n\nsubscription.close();\n```\n```\n\n----------------------------------------\n\nTITLE: Riverpod Code Generation Usage\nDESCRIPTION: Example of using code generation with ChangeNotifier during migration phase.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/from_provider/quickstart.mdx#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\n// ignore_for_file: unsupported_provider_value\n@riverpod\nMyNotifier example(Ref ref) {\n  return ref.listenAndDisposeChangeNotifier(MyNotifier());\n}\n```\n\n----------------------------------------\n\nTITLE: ThemeNotifier with StateNotifierProvider - Dart\nDESCRIPTION: This snippet demonstrates how to use a StateNotifierProvider with a StateNotifier to manage the theme settings of an application. It shows how to define an immutable state class ThemeSettings using freezed, and how to create a ThemeNotifier that allows 'mutating' the state using copyWith. It also includes methods to toggle between light and dark themes, and to set a primary color.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/concepts/why_immutability.mdx#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\nfinal themeProvider = StateNotifierProvider((ref) => ThemeNotifier());\n\nclass ThemeNotifier extends StateNotifier<ThemeSettings> {\n  ThemeNotifier(): super(\n      ThemeSettings(\n        mode: ThemeMode.system,\n        primaryColor: Colors.blue,\n      ));\n\n  void toggle() {\n    state = state.copyWith(mode: state.mode.toggle);\n  }\n  void setDarkTheme() {\n    state = state.copyWith(mode: ThemeMode.dark);\n  }\n  void setLightTheme() {\n    state = state.copyWith(mode: ThemeMode.light);\n  }\n  void setSystemTheme() {\n    state = state.copyWith(mode: ThemeMode.system);\n  }\n  void setPrimaryColor(Color color) {\n    state = state.copyWith(primaryColor: color);\n  }\n\n}\n\n@freezed\nsealed class ThemeSettings with _$ThemeSettings {\n  const factory ThemeSettings({ThemeMode mode, Color primaryColor}) = _ThemeSettings;\n}\n\nextension ToggleTheme on ThemeMode {\n  ThemeMode get toggle {\n    switch (this){\n      case ThemeMode.dark:\n        return ThemeMode.light;\n      case ThemeMode.light:\n        return ThemeMode.dark;\n      case ThemeMode.system:\n        return ThemeMode.system;\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Combining Providers (Stateless) using ProxyProvider (Provider)\nDESCRIPTION: Shows how to use `ProxyProvider` from the Provider package to combine providers and create a derived, stateless value (a String). It depends on `UserIdNotifier` and automatically updates when `userIdNotifier.userId` changes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/from_provider/provider_vs_riverpod.mdx#_snippet_10\n\nLANGUAGE: dart\nCODE:\n```\nProxyProvider<UserIdNotifier, String>(\n  update: (context, userIdNotifier, _) {\n    return 'The user ID of the the user is ${userIdNotifier.userId}';\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Understanding refresh Method Implementation in Dart using Riverpod\nDESCRIPTION: Illustration of how the refresh method is implemented internally in Riverpod. It shows that refresh is simply a combination of invalidate followed by read, demonstrating why refresh should only be used when you need the new value.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/faq.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nT refresh<T>(provider) {\n  invalidate(provider);\n  return read(provider);\n}\n```\n\n----------------------------------------\n\nTITLE: Consuming a Synchronous Provider in Dart\nDESCRIPTION: Shows how to consume a synchronously created object in Riverpod. The example demonstrates that synchronous values aren't wrapped in AsyncValue and how errors are handled.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/essentials/websockets_sync.mdx#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\n// Consumer widget somewhere in your application\nConsumer(builder: (context, ref, child) {\n  // No need to use \"when\", as the value is not an AsyncValue\n  final repository = ref.watch(repositoryProvider);\n  return Text(repository.toString());\n});\n\n// If we want to listen to changes\nref.listen<Repository>(repositoryProvider, (previous, next) {\n  // Do something when the repository changes\n}, onError: (error, stackTrace) {\n  // Do something if repositoryProvider throws\n});\n```\n\n----------------------------------------\n\nTITLE: Overriding RepositoryProvider in Dart Tests\nDESCRIPTION: This snippet demonstrates how to override the `repositoryProvider` in a Dart test using `ProviderContainer`. Similar to the Flutter example, `overrideWithValue` replaces the default `Repository` with a `FakeRepository`. The test then verifies that the `todoListProvider` uses the overridden repository and returns the expected data. It also shows how to read the `AsyncValue` state of the `FutureProvider`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/tr/docusaurus-plugin-content-docs/current/cookbooks/testing.mdx#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\ntest('override repositoryProvider', () async {\n  final container = ProviderContainer(\n    overrides: [\n       // Geri dönmek için repositoryProvider'ın davranışını geçersiz kılın\n       // Repository yerine FakeRepository.\n        repositoryProvider.overrideWithValue(FakeRepository())\n        // `todoListProvider`ı geçersiz kılmamıza gerek yok,\n        // geçersiz kılınan repositoryProvider'ı otomatik olarak kullanacak\n    ],\n  );\n\n  // Şarj durumu ise ilk okuma\n  expect(\n    container.read(todoListProvider),\n    const AsyncValue<List<Todo>>.loading(),\n  );\n\n  /// İsteğin bitmesini bekle\n  await container.read(todoListProvider.future);\n\n  // Elde edilen verileri görüntüler\n  expect(container.read(todoListProvider).value, [\n    isA<Todo>()\n        .having((s) => s.id, 'id', '42')\n        .having((s) => s.label, 'label', 'Hello world')\n        .having((s) => s.completed, 'completed', false),\n  ]);\n});\n```\n\n----------------------------------------\n\nTITLE: Generated Provider Dependencies in Dart\nDESCRIPTION: Shows correct dependency patterns for generated providers using riverpod_generator.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint/README.md#2025-04-23_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\nint dep(Ref ref) => 0;\n\n@riverpod\nvoid example(Ref ref) {\n  ref.watch(depProvider);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Riverpod Provider in Dart\nDESCRIPTION: This snippet shows the fundamental way to declare a Riverpod provider using a global `final` variable. It utilizes the `Provider` type, which exposes an immutable value ('Hello world') created by the provided function. The function receives a `ref` object for interacting with other providers or lifecycle events.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/providers.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n// The content of this code block is inferred from the surrounding text\n// describing the imported `creatingProvider` snippet.\nfinal myProvider = Provider((ref) {\n  return 'Hello world';\n});\n```\n\n----------------------------------------\n\nTITLE: Product List View Implementation\nDESCRIPTION: Shows how to display a list of products using ListView.builder in Flutter.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/providers/state_provider.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nListView.builder(\n  itemCount: products.length,\n  itemBuilder: (context, index) {\n    final product = products[index];\n    return ListTile(\n      title: Text(product.name),\n      trailing: Text('${product.price} \\$'),\n    );\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Widget Test Setup - Dart\nDESCRIPTION: This snippet shows how to set up a widget test using Riverpod. It focuses on integrating a `ProviderScope` into the widget tree within the `tester.pumpWidget` function. This enables the widget tests to use and interact with Riverpod providers. Requires `package:flutter_test` and Riverpod.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/essentials/testing.mdx#_snippet_2\n\nLANGUAGE: Dart\nCODE:\n```\ntestWidgets('...', (tester) async {\n  await tester.pumpWidget(\n    ProviderScope(\n      child: MaterialApp(\n        home: MyWidget(),\n      ),\n    ),\n  );\n});\n```\n\n----------------------------------------\n\nTITLE: Incorrect usage of read inside a provider in Dart\nDESCRIPTION: Highlights a common mistake of invoking ref.read within the provider function scope, which can lead to unintended excessive rebuilds. Advises to avoid calling read imperatively inside provider definitions.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#_snippet_8\n\nLANGUAGE: Dart\nCODE:\n```\nfinal myProvider = Provider((ref) {\n  // Mauvaise pratique d'appeler `read` ici.\n  final value = ref.read(anotherProvider);\n});\n```\n\n----------------------------------------\n\nTITLE: Running Riverpod CLI Migration Tool to Upgrade Project Syntax\nDESCRIPTION: Instructs users to execute the migration command to automatically analyze and suggest updates for Riverpod syntax changes within a project. It requires the user to be in the project directory, keeps the Riverpod package version intact, and ensures no existing errors are in the code to allow smooth migration.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/tr/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_9\n\nLANGUAGE: sh\nCODE:\n```\nriverpod migrate\n```\n\n----------------------------------------\n\nTITLE: Displaying Product List in Flutter\nDESCRIPTION: Creates a ListView to display the list of products using a Consumer widget from Riverpod.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/bn/docusaurus-plugin-content-docs/current/providers/state_provider.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nConsumer(\n  builder: (context, ref, child) {\n    final List<Product> products = ref.watch(productsProvider);\n    return ListView(\n      children: [\n        for (final product in products)\n          ListTile(\n            title: Text(product.name),\n            subtitle: Text('${product.price} \\$'),\n          ),\n      ],\n    );\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: StateNotifier'a 'ref' Aktarma (Dart)\nDESCRIPTION: Bu örnek, bir StateNotifierProvider'dan 'ref' nesnesinin, StateNotifier sınıfının bir örneğine nasıl aktarılabileceğini gösterir. Bu, StateNotifier'ın 'ref.read' gibi yöntemleri kullanarak diğer sağlayıcılara erişmesini sağlar.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/tr/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nfinal counter = StateNotifierProvider<Counter, int>((ref) {\n  return Counter(ref);\n});\n\nclass Counter extends StateNotifier<int> {\n  Counter(this.ref): super(0);\n\n  final Ref ref;\n\n  void increment() {\n    // 'Sayaç' diğer provider'ları okumak için \"ref\"i kullanabilir\n    final repository = ref.read(repositoryProvider);\n    repository.post('...');\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring VS Code Save Actions for Riverpod\nDESCRIPTION: VS Code settings configuration to enable automatic code fixes on save, specifically for fixing all source issues explicitly.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/.tasks.md#2025-04-23_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n\"editor.codeActionsOnSave\": {\n\"source.fixAll\": \"explicit\"\n}\n}\n```\n\n----------------------------------------\n\nTITLE: Including Immutable State Example (MDX)\nDESCRIPTION: This snippet utilizes a custom MDX component, `AutoSnippet`, to embed a Dart code example. The example, sourced from `whyImmutability`, illustrates the implementation of a simple immutable settings class, likely using the `freezed` package, for use with a Riverpod `Notifier`. The component specifies `language=\"dart\"` for the embedded code.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/why_immutability.mdx#_snippet_0\n\nLANGUAGE: mdx\nCODE:\n```\n<AutoSnippet language=\"dart\" {...whyImmutability}></AutoSnippet>\n```\n\n----------------------------------------\n\nTITLE: Passing Multiple Parameters to a Family using Freezed in Dart\nDESCRIPTION: Example of handling multiple parameters for a Riverpod `.family` provider (`exampleProvider`) by defining an immutable parameter class (`MyParameter`) using the Freezed package. This class encapsulates `userId` and `locale`, ensuring proper `hashCode` and `==` implementation needed for families. The provider uses `autoDispose` for state management, and the example shows how to instantiate the parameter class and watch the provider.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/modifiers/family.mdx#2025-04-23_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\n@freezed\nabstract class MyParameter with _$MyParameter {\n  factory MyParameter({\n    required int userId,\n    required Locale locale,\n  }) = _MyParameter;\n}\n\nfinal exampleProvider = Provider.autoDispose.family<Something, MyParameter>((ref, myParameter) {\n  print(myParameter.userId);\n  print(myParameter.locale);\n  // Do something with userId/locale\n});\n\n@override\nWidget build(BuildContext context, WidgetRef ref) {\n  int userId; // Read the user ID from somewhere\n  final locale = Localizations.localeOf(context);\n\n  final something = ref.watch(\n    exampleProvider(MyParameter(userId: userId, locale: locale)),\n  );\n\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Flutter App with Riverpod ProviderScope (Dart)\nDESCRIPTION: Illustrates the standard way to set up a Flutter application using Riverpod by wrapping the root widget (`MyApp`) with `ProviderScope`. It explicitly discourages creating a standalone `ProviderContainer` for typical Flutter app initialization, reserving that for testing or Dart-only applications. `ProviderScope` internally manages a `ProviderContainer`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/scopes.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nfinal valueProvider = StateProvider((ref) => 0);\n\n// DO this\nvoid main() {\n  runApp(ProviderScope(child: MyApp()));\n}\n\n//DON'T do this:\nfinal myProviderContainer = ProviderContainer();\nvoid main(){\n  runApp(MyApp());\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Watching AsyncValue state from StreamProvider in Dart with Riverpod\nDESCRIPTION: Demonstrates how to watch a StreamProvider's AsyncValue to handle loading, error, and data states in a reactive Flutter UI component.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/tr/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_13\n\nLANGUAGE: dart\nCODE:\n```\nfinal userProvider = StreamProvider<User>(...);\n\nWidget build(BuildContext context, WidgetRef ref) {\n  AsyncValue<User> user = ref.watch(userProvider);\n\n  return user.when(\n    loading: () => const CircularProgressIndicator(),\n    error: (error, stack) => const Text('Oops'),\n    data: (user) => Text(user.name),\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Detecting Missing Dependencies in ConsumerWidget Scopes (Dart)\nDESCRIPTION: This snippet demonstrates the lint identifying missing dependencies in a ConsumerWidget that uses ProviderScope. The widget uses 'DepWidget' and overrides 'depProvider' but doesn't declare the dependency.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/provider_dependencies/missing_dependencies_lint.md#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\n// expect_lint: provider_dependencies\nclass AboveScope extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    return DepWidget(\n      child: ProviderScope(\n        overrides: [depProvider.overrideWithValue(42)],\n        child: Container(),\n      ),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Combining Providers (Stateful) using ref.listen (Riverpod)\nDESCRIPTION: Shows the Riverpod equivalent of `ChangeNotifierProxyProvider`. A `ChangeNotifierProvider` (`userNotifierProvider`) creates a stateful object (`UserNotifier`) and uses `ref.listen` to react to changes in another provider (`userIdNotifierProvider`), updating its own state accordingly.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/from_provider/provider_vs_riverpod.mdx#_snippet_14\n\nLANGUAGE: dart\nCODE:\n```\nclass UserNotifier extends ChangeNotifier {\n  String? _userId;\n\n  void setUserId(String? userId) {\n    if (userId != _userId) {\n      print('The user ID changed from $_userId to $userId');\n      _userId = userId;\n    }\n  }\n}\n\n// ...\n\nfinal userNotifierProvider = ChangeNotifierProvider<UserNotifier>((ref) {\n  final userNotifier = UserNotifier();\n  ref.listen<UserIdNotifier>(\n    userIdNotifierProvider,\n    (previous, next) {\n      if (previous?.userId != next.userId) {\n        userNotifier.setUserId(next.userId);\n      }\n    },\n  );\n\n  return userNotifier;\n});\n```\n\n----------------------------------------\n\nTITLE: Passing Riverpod Ref Object to a Service for Provider Access (Dart)\nDESCRIPTION: Shows an alternative pattern where the entire `Ref` object, instead of just `ref.read`, is passed to the `Repository` instance created by `repositoryProvider`. This allows the `Repository` to potentially use `ref.watch` or `ref.listen` if needed.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#2025-04-23_snippet_7\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nfinal repositoryProvider = Provider((ref) => Repository(ref));\n\nclass Repository {\n  Repository(this.ref);\n\n  final Ref ref;\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Initializing StateNotifier in Flutter Riverpod with Dart\nDESCRIPTION: This snippet demonstrates the old way of defining a StateNotifier provider in Flutter Riverpod using Dart. It includes the constructor and state initialization logic spread between the provider declaration and the StateNotifier constructor. This pattern requires the usage of StateNotifierProvider and involves reactive dependencies declared in the provider. Input is typically initial state or parameters passed externally. Output is the managed state exposed by the notifier. This is marked as deprecated in favor of Notifier due to its verbose and split logic.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/migration/from_state_notifier.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n/* Example of old StateNotifier syntax */\n// stateNotifier.dart\nclass CounterStateNotifier extends StateNotifier<int> {\n  CounterStateNotifier(): super(0); // initial state\n\n  void increment() {\n    state = state + 1;\n  }\n}\n\nfinal counterProvider = StateNotifierProvider<CounterStateNotifier, int>((ref) {\n  return CounterStateNotifier();\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Refresh Logic with RefreshIndicator and Riverpod in Flutter/Dart\nDESCRIPTION: Integrates the `RefreshIndicator` widget around the `ListView`. The `onRefresh` callback is implemented to trigger a data refresh by calling `ref.refresh(activityProvider)`. It returns the future obtained from `ref.read(activityProvider.future)` to ensure the refresh indicator remains visible until the asynchronous operation completes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/case_studies/pull_to_refresh.mdx#_snippet_2\n\nLANGUAGE: Dart\nCODE:\n```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nimport 'activity.dart';\nimport 'provider.dart';\n\nclass ActivityCard extends ConsumerWidget {\n  const ActivityCard({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final AsyncValue<Activity> activity = ref.watch(activityProvider);\n\n    return RefreshIndicator(\n      // The onRefresh callback is called when the user pulls down.\n      // It must return a Future.\n      onRefresh: () {\n        // We refresh the provider. This will trigger a network request.\n        // It is important to NOT use \"watch\" here, as it could trigger\n        // infinite loops if the request fails.\n        ref.refresh(activityProvider);\n        // We must return the Future generated by the provider.\n        // By doing so, the RefreshIndicator will show a loading indicator\n        // until the Future completes.\n        return ref.read(activityProvider.future);\n      },\n      child: ListView(\n        children: [\n          Card(\n            child: Container(\n              padding: const EdgeInsets.all(16),\n              child: Column(\n                children: [\n                  Text(\n                    activity.valueOrNull?.activity ?? '',\n                    style: Theme.of(context).textTheme.headlineSmall,\n                  ),\n                ],\n              ),\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Utilizzo di ref.read per ottenere valori di provider in modo imperativo in Dart\nDESCRIPTION: Mostra come usare ref.read per ottenere lo stato corrente di un provider senza rimanere in ascolto. Questo metodo è utile in metodi di Notifier, ma deve essere usato con cautela in quanto il provider potrebbe essere distrutto se non viene ascoltato continuamente.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/essentials/combining_requests.mdx#_snippet_5\n\nLANGUAGE: Dart\nCODE:\n```\n<AutoSnippet {...readExample} />\n```\n\n----------------------------------------\n\nTITLE: Generic AsyncValue<T> Switch Pattern Matching\nDESCRIPTION: Example showing unsafe pattern matching in a switch statement with generic AsyncValue<T> type. Shows problematic usage that triggers the lint warning.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/async_value_nullable_pattern/async_value_nullable_pattern_lint.md#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\n  switch (obj) {\n    // expect_lint: async_value_nullable_pattern\n    case AsyncValue<T>(:final value?):\n      print(value);\n  }\n```\n\n----------------------------------------\n\nTITLE: Overriding Theme with Subtree Scoping in Flutter\nDESCRIPTION: Shows how to use Theme widget in Flutter to override the theme for a specific subtree, which works under the hood using InheritedWidget.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/scopes.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\ntrimSnippet(themeScope)\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom ProviderObserver in Dart\nDESCRIPTION: Creates a custom ProviderObserver by extending the base class and overriding methods to listen to provider events. This example implementation logs provider additions, updates, disposals, and errors to the console.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/essentials/provider_observer.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n// From external file: provider_observer.dart (referenced but not shown in the content)\n```\n\n----------------------------------------\n\nTITLE: Rendering Add Todo Button with Loading and Error States in Dart\nDESCRIPTION: This snippet shows how to implement a button that displays a progress indicator during a POST request and turns red if the operation fails. It uses flutter_hooks for managing local widget state.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/side_effects.mdx#2025-04-23_snippet_9\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet {...renderAddTodo} />\n```\n\n----------------------------------------\n\nTITLE: Using ChangeNotifierProvider in Riverpod without Code Generation\nDESCRIPTION: Shows the legacy approach to using ChangeNotifier with Riverpod when not using code generation, which automatically handles listening and disposal of the ChangeNotifier.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/essentials/websockets_sync.mdx#_snippet_4\n\nLANGUAGE: Dart\nCODE:\n```\n// Define a ChangeNotifier\nclass MyChangeNotifier extends ChangeNotifier {\n  String _value = '';\n  String get value => _value;\n\n  void setValue(String newValue) {\n    _value = newValue;\n    notifyListeners();\n  }\n}\n\n// Create a ChangeNotifierProvider\nfinal changeNotifierProvider = ChangeNotifierProvider<MyChangeNotifier>((ref) {\n  return MyChangeNotifier();\n});\n\n// Usage in a widget\nConsumer(builder: (context, ref, child) {\n  // Read the ChangeNotifier\n  final notifier = ref.watch(changeNotifierProvider);\n  // Access a property\n  return Text(notifier.value);\n});\n```\n\n----------------------------------------\n\nTITLE: Updating ConsumerWidget and Consumer builder signatures with ref.watch - Dart\nDESCRIPTION: This example shows the changes in ConsumerWidget's build method and the Consumer widget's builder function to use the new `ref.watch` syntax instead of the old `watch` callback parameter. The `ScopedReader watch` parameter is replaced by `WidgetRef ref`, and provider interactions now happen via `ref.watch()` rather than calling `watch()` directly. This improves consistency and unifies the provider interaction API throughout Riverpod 1.0.0.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/bn/docusaurus-plugin-content-docs/current/migration/0.14.0_to_1.0.0.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nclass Example extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, ScopedReader watch) {\n    int count = watch(counterProvider);\n    ...\n  }\n}\n\nConsumer(\n  builder: (context, watch, child) {\n    int count = watch(counterProvider);\n    ...\n  }\n)\n\n```\n\nLANGUAGE: dart\nCODE:\n```\nclass Example extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    int count = ref.watch(counterProvider);\n    ...\n  }\n}\n\nConsumer(\n  builder: (context, ref, child) {\n    int count = ref.watch(counterProvider);\n    ...\n  }\n)\n\n```\n\n----------------------------------------\n\nTITLE: Riverpod Provider with No Parameters\nDESCRIPTION: Test case showing unused dependency in a provider without parameters\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/provider_dependencies/unused_dependency_lint.md#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\n@Riverpod(\n  // expect_lint: provider_dependencies\n  dependencies: [\n    dep,\n  ],\n)\nint noDepNoParam(Ref ref) {\n```\n\n----------------------------------------\n\nTITLE: Using HookConsumerWidget for Ref and Hooks in Flutter Dart\nDESCRIPTION: Explains how to use HookConsumerWidget as a replacement for HookWidget to access both Riverpod's ref and flutter_hooks' hook functionality simultaneously. This widget combines provider access and hooks management, allowing more declarative and reactive Flutter UI code for users leveraging flutter_hooks.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_3\n\nLANGUAGE: Dart\nCODE:\n```\n<CodeBlock>{trimSnippet(consumerHookWidget)}</CodeBlock>\n```\n\n----------------------------------------\n\nTITLE: Improper Placement of ref.watch\nDESCRIPTION: Shows incorrect usage of ref.watch inside imperative code, which is considered bad practice. The ref.watch should only be used during the build phase of a provider.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/combining_requests.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\n// Good: watch is used inside the provider's \"build\" method:\n@riverpod\nFuture<List<Restaurant>> restaurants(RestaurantsRef ref) async {\n  // OK to use ref.watch here\n  final location = await ref.watch(locationProvider.future);\n  return fetchRestaurants(location);\n}\n\n// Bad: watch is used inside a method:\n@riverpod\nclass Example extends _$Example {\n  @override\n  int build() => 0;\n\n  void increment() {\n    // BAD: Don't use ref.watch here\n    final count = ref.watch(counterProvider);\n    state = count + 1;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: StatefulHookConsumerWidget Example - Dart\nDESCRIPTION: Provides an example of using `StatefulHookConsumerWidget`. This is suitable for scenarios where you need the lifecycle methods of `StatefulWidget` alongside hooks while interacting with providers.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\n/* ... content of reading_stateful_hook_consumer_widget.dart ... */\n```\n\n----------------------------------------\n\nTITLE: ConsumerStatefulWidget Example - Dart\nDESCRIPTION: Illustrates the use of `ConsumerStatefulWidget` and `ConsumerState`.  Unlike `ConsumerWidget`, the `ref` isn't passed to `build`, but is available as a field within the `ConsumerState` class, allowing interaction with providers within a stateful widget.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\n/* ... content of reading_consumer_stateful_widget.dart ... */\n```\n\n----------------------------------------\n\nTITLE: Using ref.listen within a provider in Dart with Riverpod\nDESCRIPTION: Demonstrates how to use ref.listen inside a provider to react to changes in another provider. The example shows listening to a counterProvider and executing a callback when its value changes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/tr/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_8\n\nLANGUAGE: dart\nCODE:\n```\nfinal counterProvider = StateNotifierProvider<Counter, int>((ref) => Counter());\n\nfinal anotherProvider = Provider((ref) {\n  ref.listen<int>(counterProvider, (int? previousCount, int newCount) {\n    print('The counter changed $newCount');\n  });\n  // ...\n});\n```\n\n----------------------------------------\n\nTITLE: Defining a Todo List NotifierProvider in Dart\nDESCRIPTION: This snippet defines a `TodosNotifier` class extending `Notifier<List<Todo>>` to manage a list of `Todo` objects. It includes methods to add and toggle todos. A `todosProvider` is created using `NotifierProvider`, making the `TodosNotifier` and its state (the list of todos) accessible throughout the application.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/providers/provider.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n/// A mock Todo class\nclass Todo {\n  Todo({\n    required this.id,\n    required this.description,\n    required this.completed,\n  });\n\n  final String id;\n  final String description;\n  final bool completed;\n\n  Todo copyWith({\n    String? id,\n    String? description,\n    bool? completed,\n  }) {\n    return Todo(\n      id: id ?? this.id,\n      description: description ?? this.description,\n      completed: completed ?? this.completed,\n    );\n  }\n}\n\n/// The Notifier for our todos\nclass TodosNotifier extends Notifier<List<Todo>> {\n  @override\n  List<Todo> build() => [];\n\n  void addTodo(Todo todo) {\n    state = [...state, todo];\n  }\n\n  void toggle(String todoId) {\n    state = [\n      for (final todo in state)\n        // we're marking only the matching todo as completed\n        if (todo.id == todoId)\n          todo.copyWith(completed: !todo.completed)\n        else\n          // other todos are not modified\n          todo,\n    ];\n  }\n}\n\n/// Finally, we are using NotifierProvider to allow the UI to interact with\n/// our TodosNotifier class.\nfinal todosProvider = NotifierProvider<TodosNotifier, List<Todo>>(() {\n  return TodosNotifier();\n});\n\n```\n\n----------------------------------------\n\nTITLE: Connecting Dropdown Selection to StateProvider State in Riverpod (Dart)\nDESCRIPTION: This snippet illustrates linking the dropdown's selected value directly to the Riverpod StateProvider. When the user picks an option, the provider's state updates and the UI rebuilds accordingly. Requires: Riverpod, Flutter hooks or ConsumerWidget. Key parameters include context, provider reference, and the new value. Inputs: StateProvider and dropdown value; outputs: updated app state and refreshed UI. Allows reactive control over simple UI selections.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/providers/state_provider.mdx#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\n/* Example connecting dropdown to provider. Actual code is located in connected_dropdown.dart */\n```\n\n----------------------------------------\n\nTITLE: Connecting StateProvider to Dropdown widget\nDESCRIPTION: Binds the sortProvider StateProvider to a DropdownButton, allowing users to select the sorting criterion (name or price). The dropdown's value reflects the provider's state, facilitating reactive UI updates upon selection changes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/es/docusaurus-plugin-content-docs/current/providers/state_provider.mdx#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\n<CodeBlock>{trimSnippet(connectedDropdown)}</CodeBlock>\n```\n\n----------------------------------------\n\nTITLE: Multiple AnimationControllers in HookWidget - Flutter\nDESCRIPTION: This code snippet shows how to create and use multiple AnimationController instances within a single HookWidget in Flutter. It demonstrates that hooks allow for the creation of multiple stateful objects without any negative consequences, providing flexibility in managing complex animations or UI behaviors within a single widget.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/about_hooks.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n@override\nWidget build(BuildContext context) {\n  final animationController = useAnimationController(\n    duration: const Duration(seconds: 2),\n  );\n  final anotherController = useAnimationController(\n    duration: const Duration(seconds: 2),\n  );\n\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Unoptimized Previous Button Implementation in Dart\nDESCRIPTION: This snippet shows an unoptimized implementation of a 'previous' button in a paginated view. It rebuilds unnecessarily on every page change.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/providers/provider.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nfinal pageIndexProvider = StateProvider<int>((ref) => 0);\n\nclass PreviousButton extends ConsumerWidget {\n  const PreviousButton({Key? key}): super(key: key);\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final pageIndex = ref.watch(pageIndexProvider);\n    return ElevatedButton(\n      onPressed: pageIndex != 0 ? () => ref.read(pageIndexProvider.notifier).update((state) => state - 1) : null,\n      child: const Text('previous'),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Riverpod for Flutter\nDESCRIPTION: This snippet defines the `pubspec.yaml` file configurations for integrating Riverpod into a standard Flutter project. It specifies the necessary dependencies, including `flutter_riverpod`, and the Flutter SDK. The code targets a Flutter project with version constraints.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/getting_started.mdx#_snippet_1\n\nLANGUAGE: YAML\nCODE:\n```\nenvironment:\n  sdk: \">=2.12.0-0 <4.0.0\"\n  flutter: \">=2.0.0\"\n\ndependencies:\n  flutter:\n    sdk: flutter\n  flutter_riverpod: ^1.0.0-dev.11\n```\n\n----------------------------------------\n\nTITLE: Defining a Provider Returning a Synchronous Object in Riverpod\nDESCRIPTION: Shows how to create a provider that returns a synchronously created object without wrapping it in AsyncValue. Emphasizes that such providers provide direct access to the object, influencing how values are consumed and error handling.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/essentials/websockets_sync.mdx#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\n<AutoSnippet \n  {...syncDefinition} \n  translations={{\n  }}\n/>\n```\n\n----------------------------------------\n\nTITLE: Unoptimized Previous Button Logic with ConsumerWidget in Riverpod (Dart)\nDESCRIPTION: This example shows a naive implementation of a 'Previous' button in a paginated view where the button disables itself if the current page index is zero. The logic is embedded directly in the widget, causing it to rebuild on every page index update, potentially affecting performance. Depends on Riverpod and the relevant page index provider, takes the current index as input, and only disables the button at index zero. For optimal usage, refactor logic into a separate provider.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/providers/provider.mdx#_snippet_3\n\nLANGUAGE: Dart\nCODE:\n```\n@override\nWidget build(BuildContext context, WidgetRef ref) {\n  final pageIndex = ref.watch(pageIndexProvider);\n  return ElevatedButton(\n    onPressed: pageIndex == 0 ? null : () => goToPreviousPage(),\n    child: Text('Previous'),\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Example: Dart Script Using Riverpod for Stateless Value Retrieval\nDESCRIPTION: Creates a provider and a ProviderContainer to manage and retrieve the provider's value in a command-line Dart script environment. Demonstrates how to use Riverpod without Flutter to access provider values directly from core Dart code.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/es/docusaurus-plugin-content-docs/current/getting_started.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nimport 'package:riverpod/riverpod.dart';\n\n// Creates a provider that supplies 'Hello world'.\nfinal helloWorldProvider = Provider((_) => 'Hello world');\n\nvoid main() {\n  // Creates a container to hold provider states.\n  final container = ProviderContainer();\n\n  // Reads the provider's value via the container.\n  final value = container.read(helloWorldProvider);\n\n  print(value); // Outputs: Hello world\n}\n```\n\n----------------------------------------\n\nTITLE: Defining StateNotifier with Riverpod in Dart\nDESCRIPTION: Defines a custom StateNotifier class managing the state of a model type (MyModel) in Dart using Riverpod. This snippet provides the basic structure needed to implement a StateNotifier which initializes its superclass with an instance of MyModel. It is a prerequisite for using StateNotifierProvider to expose state and notifier instances.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/tr/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nclass MyModel {}\n\nclass MyStateNotifier extends StateNotifier<MyModel> {\n  MyStateNotifier(): super(MyModel());\n}\n```\n\n----------------------------------------\n\nTITLE: Alternative Generic AsyncValue<T> Switch Pattern\nDESCRIPTION: Another example of unsafe pattern matching in a switch statement with generic AsyncValue<T> type. Demonstrates the same lint warning in a different context.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/async_value_nullable_pattern/async_value_nullable_pattern_lint.md#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\n  switch (obj) {\n    // expect_lint: async_value_nullable_pattern\n    case AsyncValue<T>(:final value?):\n      print(value);\n  }\n```\n\n----------------------------------------\n\nTITLE: AsyncError<int?> Nullable Pattern Matching\nDESCRIPTION: Example showing unsafe pattern matching with AsyncError<int?> using nullable pattern. Shows incorrect usage that triggers the async_value_nullable_pattern lint warning.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/async_value_nullable_pattern/async_value_nullable_pattern_lint.md#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n    case AsyncError<int?>(\n        // expect_lint: async_value_nullable_pattern\n        :final value?,\n      ):\n      print(value);\n```\n\n----------------------------------------\n\nTITLE: Watching a Family Provider with Different Parameters Simultaneously in Dart\nDESCRIPTION: Example of using a `.family` provider (`titleFamily`, assumed to be defined elsewhere) multiple times within a Flutter `build` method, each instance using a different parameter (`Locale('fr')` and `Locale('en')`). This allows fetching and displaying different data (e.g., translations) based on the provided parameters simultaneously.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/modifiers/family.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\n@override\nWidget build(BuildContext context, WidgetRef ref) {\n  final frenchTitle = ref.watch(titleFamily(const Locale('fr')));\n  final englishTitle = ref.watch(titleFamily(const Locale('en')));\n\n  return Text('fr: $frenchTitle en: $englishTitle');\n}\n```\n\n----------------------------------------\n\nTITLE: Adding flutter_riverpod dependency in pubspec.yaml\nDESCRIPTION: This YAML snippet demonstrates how to add the `flutter_riverpod` package to your `pubspec.yaml` file. It defines environment constraints for the Dart SDK and Flutter, and specifies the dependencies on `flutter` and `flutter_riverpod`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/getting_started.mdx#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nenvironment:\n  sdk: \">=2.12.0 <4.0.0\"\n  flutter: \">=2.0.0\"\n\ndependencies:\n  flutter:\n    sdk: flutter\n  flutter_riverpod: ^2.1.3\n```\n\n----------------------------------------\n\nTITLE: Defining Providers with Repository Abstraction - Riverpod - Dart\nDESCRIPTION: Illustrates defining a Repository class with Riverpod providers, modeling dependency injection for testability. The Repository could represent an HTTP layer, and the main provider consumes this repository to load data. Useful as a pattern for decoupling dependencies and enabling mocking for tests. Dependencies: riverpod or flutter_riverpod. Inputs are the Repository and external data-fetching logic. Output: data exposure via provider for consumption.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/cookbooks/testing.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nclass Repository {\n  Future<List<String>> fetchTodos() async => ['foo', 'bar'];\n}\n\nfinal repositoryProvider = Provider((ref) => Repository());\n\nfinal todoListProvider = FutureProvider((ref) async {\n  final repository = ref.watch(repositoryProvider);\n  return repository.fetchTodos();\n});\n\n```\n\n----------------------------------------\n\nTITLE: Installing Riverpod Generator Dependencies in pubspec.yaml\nDESCRIPTION: This YAML snippet shows the required dependencies to add to the pubspec.yaml file for using Riverpod generator in a Dart/Flutter project.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_generator/README.md#2025-04-23_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\ndependencies:\n  riverpod:\n  riverpod_annotation:\n\ndev_dependencies:\n  build_runner:\n  riverpod_generator:\n```\n\n----------------------------------------\n\nTITLE: Overriding Provider (Deprecated) Dart\nDESCRIPTION: Shows the deprecated method for overriding a provider's implementation or value using provider.overrideWithProvider(). Users should transition to using provider.overrideWith() instead.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/hooks_riverpod/CHANGELOG.md#_snippet_8\n\nLANGUAGE: Dart\nCODE:\n```\nprovider.overrideWithProvider\n```\n\n----------------------------------------\n\nTITLE: Testing Generator Provider with Factory Class Parameters\nDESCRIPTION: Test cases for generator provider using Factory class methods.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/provider_parameters/provider_parameters_lint.md#2025-04-23_snippet_7\n\nLANGUAGE: dart\nCODE:\n```\n\n    // expect_lint: provider_parameters\n    ref.watch(generatorProvider(value: Factory.bar()));\n    ref.watch(generatorProvider(value: const Factory.bar()));\n    ref.watch(generatorProvider(value: Factory.foo()));\n```\n\n----------------------------------------\n\nTITLE: Sağlayıcı Tanımında 'ref' Elde Etme (Dart)\nDESCRIPTION: Bu kod parçacığı, bir Riverpod Sağlayıcısının bir 'ref' parametresi aldığını gösterir. Bu 'ref' nesnesi, diğer sağlayıcıları izlemek için 'ref.watch' gibi yöntemleri kullanarak bağımlılıkları okumak için sağlayıcının içinde kullanılabilir.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/tr/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nfinal provider = Provider((ref) {\n  // ref'i diğer provider'ları almak için kullanın\n  final repository = ref.watch(repositoryProvider);\n\n  return SomeValue(repository);\n})\n```\n\n----------------------------------------\n\nTITLE: Watching Stream from StreamProvider in Dart with Riverpod\nDESCRIPTION: Shows how to access the underlying Stream from a StreamProvider using the .stream modifier with ref.watch for custom stream handling.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/tr/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_14\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, WidgetRef ref) {\n  Stream<User> user = ref.watch(userProvider.stream);\n}\n```\n\n----------------------------------------\n\nTITLE: ChangeNotifier Class Provider\nDESCRIPTION: Demonstrates a class-based implementation of an unsupported ChangeNotifier provider\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/unsupported_provider_value/unsupported_provider_value_lint.md#2025-04-23_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\n// expect_lint: unsupported_provider_value\nclass ChangeNotifierClass extends _$ChangeNotifierClass {\n  MyChangeNotifier build() => MyChangeNotifier();\n}\n```\n\n----------------------------------------\n\nTITLE: 변이(변경) API 및 상태 소비 방식 변화 없음\nDESCRIPTION: 기존 `StateNotifier`와 새 `Notifier` 계열 간의 공통점으로, 담당하는 상태를 읽고 변경하는 패턴은 동일하게 유지됩니다. `ref.listen()`, `ref.read()`, `.addListener` 등 기존 API와 호환되며, 이는 마이그레이션 시 대체 로직 주입을 최소화하는 핵심 포인트입니다. 예제 코드에는 기존 `Consumer` 또는 `ref.listen` 사용이 보여집니다.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/migration/from_state_notifier.mdx#_snippet_7\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet raw={consumersDontChange}></AutoSnippet>\n```\n\n----------------------------------------\n\nTITLE: Implementing Sorted Products Provider in Dart\nDESCRIPTION: Creates a Provider that sorts the products based on the selected sort type from the StateProvider.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/bn/docusaurus-plugin-content-docs/current/providers/state_provider.mdx#2025-04-23_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nfinal productsProvider = Provider<List<Product>>((ref) {\n  final sortType = ref.watch(sortTypeProvider);\n  switch (sortType) {\n    case 'name':\n      return [...products]..sort((a, b) => a.name.compareTo(b.name));\n    case 'price':\n      return [...products]..sort((a, b) => a.price.compareTo(b.price));\n    default:\n      throw UnsupportedError('Unknown sort type');\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Inappropriate use of provider for local widget state\nDESCRIPTION: This snippet clarifies that provider is intended for shared, global state and should not manage local widget-specific states like form inputs, selected items, or animations. For local states, consider using flutter_hooks or other local state management strategies.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/essentials/do_dont.mdx#_snippet_2\n\nLANGUAGE: Dart\nCODE:\n```\n// Example of local widget state\n// Do not use provider for local transient states such as TextEditingController, form data, or animations.\n```\n\n----------------------------------------\n\nTITLE: Accessing StateNotifier Instance via Provider.notifier in Dart (Riverpod ^0.14.0)\nDESCRIPTION: Demonstrates the updated pattern for accessing the StateNotifier itself by watching the provider's notifier property instead of the provider. This is required as of Riverpod 0.14.0 due to API changes allowing for clearer separation between state and notifier.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, ScopedReader watch) {\n  MyStateNotifier notifier = watch(provider.notifier);\n}\n```\n\n----------------------------------------\n\nTITLE: Using ref.read inside State.dispose\nDESCRIPTION: Example of a linting violation where ref.read is used inside the dispose method of a State object. This is discouraged as it can lead to unexpected behavior during widget disposal.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/avoid_ref_inside_state_dispose/avoid_ref_inside_state_dispose_lint.md#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n  void dispose() {\n    // expect_lint: avoid_ref_inside_state_dispose\n    ref.read(provider);\n    // expect_lint: avoid_ref_inside_state_dispose\n    ref.watch(provider);\n```\n\n----------------------------------------\n\nTITLE: Listening to State Changes: StateNotifier vs Notifier APIs in Dart\nDESCRIPTION: This pair of snippets shows the migration from using StateNotifier's .addListener API to the ref.listen method with Notifier or AsyncNotifier. The old code uses explicit listener registration while the modern approach leverages Riverpod's uniform provider APIs. ref.listen tracks provider state and reacts accordingly. These require the riverpod package, and ref must be available in the relevant context. Inputs include a provider or notifier instance; output is the setup of a callback for state changes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/migration/from_state_notifier.mdx#2025-04-23_snippet_10\n\nLANGUAGE: dart\nCODE:\n```\n// OLD: Using StateNotifier's .addListener\nfinal listener = myStateNotifier.addListener((state) {\n  // React to state updates\n});\n\n// ... cleanup when done\nlistener.cancel();\n```\n\nLANGUAGE: dart\nCODE:\n```\n// NEW: Using ref.listen with Notifier/AsyncNotifier\nref.listen(myProvider, (previous, next) {\n  // React to state updates\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing a HookConsumerWidget in Flutter with Riverpod\nDESCRIPTION: This code demonstrates how to create a widget that combines the functionality of HookWidget and ConsumerWidget by extending HookConsumerWidget. It shows how to use hooks like useState alongside provider access in a single widget.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/essentials/first_request.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n/// \"HookConsumerWidget\"をサブクラス化しました。  \n/// これにより \"StatelessWidget\" + \"Consumer\" + \"HookWidget\"が組み合わさります。\nclass Home extends HookConsumerWidget {\n  const Home({Key? key}) : super(key: key);\n\n  // \"build\"メソッドに\"ref\"パラメータが追加されたことに注目してください。 \n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // ウィジェット内で\"useState\"などのhooksを使用することができます。\n    final counter = useState(0);\n    // providerプロバイダーも読み取ることができます。\n    final activity = ref.watch(activityProvider);\n\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Example'),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            Text('counter: ${counter.value}'),\n            Text('activity: $activity'),\n          ],\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => counter.value++,\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Filtering Todo List with StateNotifierProvider - Dart\nDESCRIPTION: This code snippet defines a StateNotifierProvider that manages a list of todo items. It includes methods for adding, completing, and removing todos, providing the base data for further filtering and display.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/es/docusaurus-plugin-content-docs/current/providers/provider.mdx#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:uuid/uuid.dart';\n\nfinal todoListProvider =\n    StateNotifierProvider<TodoList, List<Todo>>((ref) => TodoList());\n\nclass Todo {\n  Todo({\n    required this.description,\n    this.completed = false,\n    String? id,\n  }) : id = id ?? const Uuid().v4();\n\n  final String id;\n  final String description;\n  final bool completed;\n\n  Todo copyWith({String? id, String? description, bool? completed}) {\n    return Todo(\n      id: id ?? this.id,\n      description: description ?? this.description,\n      completed: completed ?? this.completed,\n    );\n  }\n}\n\nclass TodoList extends StateNotifier<List<Todo>> {\n  TodoList([List<Todo>? initialTodos]) : super(initialTodos ?? []);\n\n  void add(String description) {\n    state = [...state, Todo(description: description)];\n  }\n\n  void toggle(String id) {\n    state = [for (final todo in state) if (todo.id == id) todo.copyWith(completed: !todo.completed) else todo];\n  }\n\n  void edit({required String id, required String description}) {\n    state = [for (final todo in state) if (todo.id == id) todo.copyWith(description: description) else todo];\n  }\n\n  void remove(Todo target) {\n    state = state.where((todo) => todo.id != target.id).toList();\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: প্রোভাইডার থেকে রিড বনাম ওয়াচ সংক্রান্ত জিনিসগুলো\nDESCRIPTION: প্রোভাইডার থেকে ভ্যালু রিড বা ওয়াচ করার পার্থক্য ব্যাখ্যা করা হয়েছে। যেখানে রিড ব্যবহার করে, পরিবর্তন হলে অবজেক্টটি নিজে আপডেট হয় না, তবে ওয়াচ ব্যবহার করে অপ্রত্যাশিত আপডেট হওয়ার সম্ভাবনা থাকে। এড়ানোর জন্য নির্দিষ্ট প্যাটার্ন ও প্র্যাকটিস শেখানো হয়েছে।\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/bn/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nfinal userTokenProvider = StateProvider<String>((ref) => null);\n\nfinal repositoryProvider = Provider((ref) => Repository(ref.read));\n\nclass Repository {\n  Repository(this.read);\n  final Reader read;\n  Future<Catalog> fetchCatalog() async {\n    String token = read(userTokenProvider);\n    final response = await dio.get('/path', queryParameters: {\n      'token': token,\n    });\n    return Catalog.fromJson(response.data);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Understanding the difference between ref.refresh and ref.invalidate in Dart\nDESCRIPTION: Demonstrates how ref.refresh is implemented as a combination of invalidate and read operations. This shows that refresh is essentially a syntax sugar that invalidates a provider and immediately reads its new value.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/essentials/faq.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nT refresh<T>(provider) {\n  invalidate(provider);\n  return read(provider);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Using NotifierProvider for Local State Management in Dart\nDESCRIPTION: This snippet introduces the NotifierProvider in Riverpod for managing mutable local state, exemplified with a to-do list. It demonstrates how to expose methods like addTodo to facilitate UI interactions for task modifications. The snippet includes code for defining the provider and interacting with it through auto-generated snippets and code blocks.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/providers/notifier_provider.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nimport { trimSnippet, AutoSnippet } from \"../../../../../src/components/CodeSnippet\";\n\n<AutoSnippet language=\"dart\" {...todos}></AutoSnippet>\n\n<CodeBlock>{trimSnippet(todosConsumer)}</CodeBlock>\n```\n\n----------------------------------------\n\nTITLE: Correct usage of ref.watch with StateNotifierProvider in Dart\nDESCRIPTION: This snippet demonstrates the correct way to use ref.watch with a StateNotifierProvider, which supports cases where the state might be reset or changed.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/reading.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet language=\"dart\" {...watchNotifierBuild}></AutoSnippet>\n```\n\n----------------------------------------\n\nTITLE: Good and Bad Hook Usage Examples - Dart\nDESCRIPTION: This code shows examples of how hooks should and should not be used within Flutter's HookWidget. The \"Good\" examples demonstrate valid hook usage within the `build` method of a `HookWidget`. The \"Bad\" examples highlight the restrictions such as not using hooks in a `StatelessWidget`, within a button's `onPressed` callback, or conditionally within an `if` statement.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/about_hooks.mdx#_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\n```dart\n  class Example extends HookWidget {\n    @override\n    Widget build(BuildContext context) {\n      final controller = useAnimationController();\n      ...\n    }\n  }\n```\n```\n\nLANGUAGE: dart\nCODE:\n```\n```dart\n  // N'est pas un HookWidget\n  class Example extends StatelessWidget {\n    @override\n    Widget build(BuildContext context) {\n      final controller = useAnimationController();\n      ...\n    }\n  }\n```\n```\n\nLANGUAGE: dart\nCODE:\n```\n```dart\n  class Example extends HookWidget {\n    @override\n    Widget build(BuildContext context) {\n      return ElevatedButton(\n        onPressed: () {\n          // Pas _actuellement_ à l'intérieur de la méthode \"build\", mais plutôt à l'intérieur\n          // d'un cycle de vie d'interaction avec l'utilisateur (ici \"on pressed\").\n          final controller = useAnimationController();\n        },\n        child: Text('click me'),\n      );\n    }\n  }\n```\n```\n\nLANGUAGE: dart\nCODE:\n```\n```dart\n  class Example extends HookWidget {\n    const Example({required this.condition, super.key});\n    final bool condition;\n    @override\n    Widget build(BuildContext context) {\n      if (condition) {\n        // Les hooks ne doivent pas être utilisés à l'intérieur de \"if\"/\"for\", ...\n        final controller = useAnimationController();\n      }\n      ...\n    }\n  }\n```\n```\n\n----------------------------------------\n\nTITLE: Using ConsumerStatefulWidget to Access ref Property - Riverpod Dart\nDESCRIPTION: The snippet demonstrates how to use ConsumerStatefulWidget and ConsumerState in Riverpod, providing the 'ref' property on the ConsumerState object. This allows stateful widgets to acquire and react to provider updates in a familiar Flutter StatefulWidget pattern, with no extra dependencies required beyond Riverpod/Flutter. The implementation inputs are the build context and the state instance (which carries 'ref'), and the output is the rendered widget.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/reading.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nclass MyConsumerStatefulWidget extends ConsumerStatefulWidget {\n  const MyConsumerStatefulWidget({Key? key}) : super(key: key);\n\n  @override\n  ConsumerState<MyConsumerStatefulWidget> createState() => _MyConsumerStatefulWidgetState();\n}\n\nclass _MyConsumerStatefulWidgetState extends ConsumerState<MyConsumerStatefulWidget> {\n  @override\n  Widget build(BuildContext context) {\n    final value = ref.watch(myProvider);\n    return Text('$value');\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Caching Filtered Todos with Provider in Dart\nDESCRIPTION: This snippet defines `completedTodosProvider` using Riverpod's `Provider`. It watches the state of `todosProvider` using `ref.watch`. The provider filters the list of todos to include only the completed ones. This computation is cached; the filtering logic only re-runs when the list of todos in `todosProvider` changes, not every time `completedTodosProvider` is read.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/providers/provider.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nfinal completedTodosProvider = Provider<List<Todo>>((ref) {\n  // We obtain the list of all todos from the TodosNotifierProvider\n  final todos = ref.watch(todosProvider);\n\n  // We filter the list of todos and keep only the completed ones\n  return todos.where((todo) => todo.completed).toList();\n});\n\n```\n\n----------------------------------------\n\nTITLE: Consuming NotifierProvider State in Flutter Widget\nDESCRIPTION: This snippet shows how to consume the state exposed by a `NotifierProvider` within a Flutter widget. It uses `ref.watch` to listen for state changes and rebuild the UI, and `ref.read` (or `ref.watch`) in combination with `.notifier` to access the notifier instance and call its methods (e.g., `addTodo`).\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/providers/notifier_provider.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n// Code dynamically loaded via <CodeBlock>{trimSnippet(todosConsumer)}</CodeBlock>\n// This typically shows a ConsumerWidget or HookConsumerWidget using ref.\n\n// Example structure:\n// class TodoListView extends ConsumerWidget {\n//   @override\n//   Widget build(BuildContext context, WidgetRef ref) {\n//     // Watch the state of the provider\n//     final todos = ref.watch(todosProvider);\n// \n//     return ListView(\n//       children: [\n//         for (final todo in todos) Text(todo.description),\n//         // Button to add a new todo\n//         ElevatedButton(\n//           onPressed: () {\n//             // Read the notifier and call its method\n//             ref.read(todosProvider.notifier).addTodo(Todo(/* ... */));\n//           },\n//           child: Text('Add Todo'),\n//         ),\n//       ],\n//     );\n//   }\n// }\n```\n\n----------------------------------------\n\nTITLE: Incorrect Generic Type Extension in Riverpod Class (Dart)\nDESCRIPTION: This snippet shows a Riverpod class declaration with incorrect generic type extension. The class NoGenerics<A extends num, B> is supposed to extend _$NoGenerics, but it's missing the generic type parameters.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/notifier_extends/notifier_extends_lint.md#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\n// expect_lint: notifier_extends\nclass NoGenerics<A extends num, B> extends _$NoGenerics {\n  int build() => 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Counter Provider with StateNotifier in Dart\nDESCRIPTION: This snippet demonstrates how to create a counter provider using StateNotifier in Riverpod. It shows how to pass the 'ref' object to the StateNotifier, allowing it to interact with other providers.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/de/docusaurus-plugin-content-docs/current/concepts/reading.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nfinal counterProvider = StateNotifierProvider<Counter, int>((ref) {\n  return Counter(ref);\n});\n\nclass Counter extends StateNotifier<int> {\n  Counter(this.ref): super(0);\n\n  final Ref ref;\n\n  void increment() => state++;\n}\n```\n\n----------------------------------------\n\nTITLE: Using ref.watch to rebuild widget on provider state change in Dart Riverpod\nDESCRIPTION: This snippet demonstrates the correct approach of using ref.watch to listen for provider updates, ensuring the widget rebuilds when the provider's state changes. It contrasts with ref.read to highlight how watch facilitates reactive UI updates and supports resetting the provider's value with ref.refresh, maintaining consistency in state management.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/es/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_3\n\nLANGUAGE: Dart\nCODE:\n```\nfinal counterProvider = StateProvider((ref) => 0);\n\nWidget build(BuildContext context, WidgetRef ref) {\n  StateController<int> counter = ref.watch(counterProvider.notifier);\n  return ElevatedButton(\n    onPressed: () => counter.state++,\n    child: const Text('button'),\n  );\n}\n\n// To reset the provider:\n// ref.refresh(counterProvider);\n```\n\n----------------------------------------\n\nTITLE: Running Migration Tool in Shell\nDESCRIPTION: This shell command runs the Riverpod migration tool within a project directory using the 'riverpod migrate' command.  It assumes the user has navigated to the project directory. This command automatically makes changes to the project based on the Riverpod CLI's suggestions.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_9\n\nLANGUAGE: sh\nCODE:\n```\nriverpod migrate\n```\n\n----------------------------------------\n\nTITLE: Combining providers for live configuration-based data fetching\nDESCRIPTION: Shows how to dynamically fetch data based on user-configurable search and settings, using ref.watch on both StateProvider and StreamProvider. Demonstrates reactive data fetching with dependency on multiple providers.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/es/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#_snippet_3\n\nLANGUAGE: Dart\nCODE:\n```\nfinal searchProvider = StateProvider((ref) => '');\n\nfinal configsProvider = StreamProvider<Configuration>(...);\n\nfinal charactersProvider = FutureProvider<List<Character>>((ref) async {\n  final search = ref.watch(searchProvider);\n  final configs = await ref.watch(configsProvider.future);\n  final response = await dio.get('${configs.host}/characters?search=$search');\n  return response.data.map((json) => Character.fromJson(json)).toList();\n});\n```\n\n----------------------------------------\n\nTITLE: Defining a StreamProvider for User data in Dart\nDESCRIPTION: This snippet defines a StreamProvider for User data, which can be used to asynchronously provide user information.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/reading.mdx#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nfinal userProvider = StreamProvider<User>(...);\n```\n\n----------------------------------------\n\nTITLE: Filtering Listener Execution with ref.listen and select (Dart)\nDESCRIPTION: Shows how to combine `ref.listen` with `select` to trigger a listener callback only when a specific part of a provider's state changes. The listener observes `userProvider` but uses `select((user) => user.name)` so the callback function is executed only when the `name` property changes, receiving the previous and new name values. Requires a `Ref` instance (`ref`) and the `userProvider`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_18\n\nLANGUAGE: dart\nCODE:\n```\nref.listen<String>(\n  userProvider.select((user) => user.name),\n  (String? previousName, String newName) {\n    print('The user name changed $newName');\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: Detecting Cross-File Dependencies in Riverpod Provider (Dart)\nDESCRIPTION: This code shows a Riverpod provider with cross-file dependencies. It watches a provider from another file without declaring it as a dependency.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/provider_dependencies/missing_dependencies2_lint.md#2025-04-23_snippet_11\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\nint crossFileDependency(Ref ref) {\n  ref.watch(anotherNonEmptyScopedProvider);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Running Riverpod CLI Migrate - Shell\nDESCRIPTION: This command executes the Riverpod CLI with the `migrate` command. It analyzes the project in the current directory and suggests changes to migrate to the new syntax introduced in Riverpod 0.14.0.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\nriverpod migrate\n```\n\n----------------------------------------\n\nTITLE: Running Riverpod CLI help\nDESCRIPTION: This command executes the Riverpod command-line interface and displays the help menu. This is a way to verify that the CLI has been successfully installed and is accessible.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/migration/0.14.0_to_1.0.0.mdx#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nriverpod --help\n```\n\n----------------------------------------\n\nTITLE: Using Notifier methods from widgets in Dart/Flutter\nDESCRIPTION: Shows how to properly access and call methods on a Notifier from widgets. This pattern helps maintain separation between UI and business logic by using the Notifier's Ref for provider interactions.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/essentials/faq.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nref.read(yourNotifierProvider.notifier).yourMethod();\n```\n\n----------------------------------------\n\nTITLE: Implementing Fade-in Animation with Hooks\nDESCRIPTION: This snippet demonstrates how to create a fade-in animation using hooks, providing a more concise and maintainable approach compared to using StatefulWidget. It utilizes `useAnimationController` to manage the animation, `useEffect` to handle initialization and disposal, and `useAnimation` to trigger rebuilds when the animation updates. It showcases how to replace a `StatefulWidget` with a `HookWidget` for state management.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/about_hooks.mdx#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\nclass FadeIn extends HookWidget {\n  const FadeIn({Key? key, required this.child}) : super(key: key);\n\n  final Widget child;\n\n  @override\n  Widget build(BuildContext context) {\n    // AnimationController 생성. \n    // 위젯인 마운트해제(unmounted)되면 컨트롤러는 자동으로 폐기(disposed)됩니다.\n    final animationController = useAnimationController(\n      duration: const Duration(seconds: 2),\n    );\n\n    // useEffect는 initState + didUpdateWidget + dispose와 동일합니다\n    // useEffect에 잔달된 콜백(callback)은 훅(hook)이 처음 호출될 때 실행되고,\n    // 두 번째 매개변수로 전달된 목록이 변경될 때마다 실행됩니다.\n    // 여기서는 빈 const list를 전달하므로, 이는 엄밀히 말해 `initState`와 동일합니다.\n    useEffect(() {\n      // 위젯이 처음 렌더링될 때 애니메이션이 시작\n      animationController.forward();\n      // 여기서 선택적으로 \"Dispose\"로직을 반환할 수 있습니다.\n      return null;\n    }, const []);\n\n    // 애니메이션이 업데이트될 때 이 위젯을 다시 빌드하도록 Flutter에 알립니다.\n    // 이는 AnimatedBuilder와 동일합니다\n    useAnimation(animationController);\n\n    return Opacity(\n      opacity: animationController.value,\n      child: child,\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: ConsumerStatefulWidget ile Sağlayıcılara Erişme (Dart)\nDESCRIPTION: Bu kod parçacığı, StatefulWidget/State yerine ConsumerStatefulWidget/ConsumerState kullanmayı gösterir. ConsumerState, 'ref' nesnesine bir özellik olarak erişim sağlar ve bu, initState gibi yaşam döngüsü yöntemlerinde ('ref.read' kullanarak) ve build yönteminde ('ref.watch' kullanarak) sağlayıcılarla etkileşim kurmak için kullanılabilir.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/tr/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nclass HomeView extends ConsumerStatefulWidget {\n  const HomeView({Key? key}): super(key: key);\n\n  @override\n  HomeViewState createState() => HomeViewState();\n}\n\nclass HomeViewState extends ConsumerState<HomeView> {\n  @override\n  void initState() {\n    super.initState();\n   // \"ref\" bir StatefulWidget'ın tüm yaşam döngülerinde kullanılabilir.\n    ref.read(counterProvider);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // Derleme yöntemi içindeki bir provider'ı dinlemek için \"ref\" komutunu da kullanabiliriz\n    final counter = ref.watch(counterProvider);\n    return Text('$counter');\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Obtaining ref with Consumer/HookConsumer Builder Callback - Riverpod Dart\nDESCRIPTION: This code shows how to use the Consumer or HookConsumer widget to obtain a 'ref' via a builder callback, providing flexibility to access provider data inside widget trees without defining a new class. Dependencies are Riverpod (and optionally flutter_hooks and hooks_riverpod). Inputs are context and ref from the builder; outputs are widgets utilizing the provider states. Ideal for in-line or ad-hoc provider access in widget hierarchies.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/reading.mdx#2025-04-23_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\nConsumer(\n  builder: (context, ref, child) {\n    final value = ref.watch(myProvider);\n    return Text('$value');\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Verifying Riverpod CLI Installation in Shell\nDESCRIPTION: This command checks if the Riverpod CLI is installed correctly by displaying its help information. It executes the 'riverpod --help' command to display the help message for the installed Riverpod CLI.  Success depends on the previous installation step.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_8\n\nLANGUAGE: sh\nCODE:\n```\nriverpod --help\n```\n\n----------------------------------------\n\nTITLE: Optimized Previous Button using Provider Value in Riverpod (Dart)\nDESCRIPTION: Here, the permission logic for navigating to the previous page is extracted into a separate Provider, enabling the PreviousButton widget to only rebuild when this explicit value changes. This approach decouples UI logic from state management and minimizes unnecessary rebuilds. The snippet relies on Riverpod, an existing pageIndexProvider, and Flutter; it uses a boolean provider to control the button's enabled state.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/providers/provider.mdx#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nfinal canGoToPreviousPageProvider = Provider<bool>((ref) {\n  final pageIndex = ref.watch(pageIndexProvider);\n  return pageIndex > 0;\n});\n\nclass PreviousButton extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final enabled = ref.watch(canGoToPreviousPageProvider);\n    return ElevatedButton(\n      onPressed: enabled ? () {\n        // Implement previous button logic\n      } : null,\n      child: Text('Previous'),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Provider Function Structure in Riverpod\nDESCRIPTION: Demonstrates the syntax structure for defining providers in Riverpod, including provider type, modifiers, and function parameters.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/first_request.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nfinal name = SomeProvider.someModifier<Result>((ref) {\n  <your logic here>\n});\n```\n\n----------------------------------------\n\nTITLE: Show Riverpod CLI Help - Shell\nDESCRIPTION: This shell command displays the help information for the Riverpod CLI tool. It is used to verify the installation and understand the available commands and options.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/migration/0.14.0_to_1.0.0.mdx#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nriverpod --help\n```\n\n----------------------------------------\n\nTITLE: Mocking Notifiers in Tests - Dart\nDESCRIPTION: This snippet provides guidelines on how to mock Notifiers in tests. It emphasizes that Notifiers must be subclasses of their base class, and it is not recommended to mock them directly. It highlights a specific example, and suggests to make the base-class an abstract class or using an interface to allow for mock implementations.  It encourages mocking the logic within the Notifier instead of mocking the Notifier itself.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/essentials/testing.mdx#_snippet_9\n\nLANGUAGE: Dart\nCODE:\n```\n// 모의클래스(Mock)는 notifier가 사용하는 것에 해당하는\n// Notifier base-class를 서브클래싱해야 합니다.\n```\n\n----------------------------------------\n\nTITLE: Incorrect Hook Usage in StatelessWidget Build Method - Dart\nDESCRIPTION: Illustrates an incorrect attempt to use a Flutter Hook (`useAnimationController`) within a widget that extends `StatelessWidget`. Hooks can only be used in widgets that extend `HookWidget` or `HookConsumerWidget`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/about_hooks.mdx#_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\n// Not a HookWidget\nclass Example extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    final controller = useAnimationController();\n    ...\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Verifying Riverpod CLI Tool Installation\nDESCRIPTION: Shows how to verify that the Riverpod CLI migration tool has been installed correctly by running the help command. This ensures the tool is accessible globally in the shell environment.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/tr/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_8\n\nLANGUAGE: dart\nCODE:\n```\nriverpod --help\n```\n\n----------------------------------------\n\nTITLE: ChangeNotifier extension with Code Generation\nDESCRIPTION: This snippet extends `Ref` to include `listenAndDisposeChangeNotifier` enabling integration of the legacy `ChangeNotifier` and `@riverpod` code generation.  This facilitates seamless management of `ChangeNotifier` instances within the context of code generation. Requires the riverpod package.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/from_provider/quickstart.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nextension ChangeNotifierWithCodeGenExtension on Ref {\n  T listenAndDisposeChangeNotifier<T extends ChangeNotifier>(T notifier) {\n    notifier.addListener(notifyListeners);\n    onDispose(() => notifier.removeListener(notifyListeners));\n    onDispose(notifier.dispose);\n    return notifier;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a ChangeNotifier Provider for Combination (Riverpod)\nDESCRIPTION: Defines a `UserIdNotifier` using `ChangeNotifierProvider` from the Riverpod package as a global final variable. This serves as a dependency for a subsequent Riverpod combination example.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/from_provider/provider_vs_riverpod.mdx#_snippet_11\n\nLANGUAGE: dart\nCODE:\n```\nclass UserIdNotifier extends ChangeNotifier {\n  String? userId;\n}\n\n// ...\n\nfinal userIdNotifierProvider = ChangeNotifierProvider<UserIdNotifier>(\n  (ref) => UserIdNotifier(),\n);\n```\n\n----------------------------------------\n\nTITLE: Incorrectly Watching AutoDispose Provider (Causes Error) in Dart\nDESCRIPTION: This snippet illustrates a common mistake in Riverpod that causes a compile-time error ('AlwaysAliveProviderBase'). It shows a standard `Provider` (`secondProvider`) attempting to `ref.watch` a `Provider.autoDispose` (`firstProvider`). This is disallowed because it would prevent `firstProvider` from ever being disposed, defeating the purpose of `.autoDispose`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/modifiers/auto_dispose.mdx#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nfinal firstProvider = Provider.autoDispose((ref) => 0);\n\nfinal secondProvider = Provider((ref) {\n  // The argument type 'AutoDisposeProvider<int>' can't be assigned to the\n  // parameter type 'AlwaysAliveProviderBase<Object, Null>'\n  ref.watch(firstProvider);\n});\n```\n\n----------------------------------------\n\nTITLE: 라이프사이클과 수명주기 (dispose) 처리\nDESCRIPTION: 이 섹션은 `StateNotifier`의 수명주기 관리와 달리, `Notifier`와 `AsyncNotifier`가 `ref.onDispose`로 수명주기를 처리하는 방식의 개념적 차이와 이점, 이전 `dispose` 메서드와의 차이점을 설명합니다. 기존 API의 `dispose` 호출 대신 `ref.onDispose`로 내부 상태를 폐기하는 구조가 단순화되어, 개발자가 라이프사이클 관리에 더 집중할 수 있게 됨을 보여줍니다. 예시 코드에서는 `build` 내부에서 `ref.onDispose`를 사용하는 방법을 보여줍니다.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/migration/from_state_notifier.mdx#_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet raw={oldLifecyclesOld}/>\n```\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet language=\"dart\" {...oldLifecycles} ... />\n```\n\n----------------------------------------\n\nTITLE: ref.watch ile Sağlayıcıları Birleştirme (Dart)\nDESCRIPTION: Bu örnek, bir sağlayıcının ('filteredTodoListProvider') diğer iki sağlayıcıyı ('filterTypeProvider', 'todosProvider') dinlemek için 'ref.watch'ı nasıl kullanabileceğini gösterir. Bağımlı sağlayıcılardan herhangi biri değiştiğinde türetilmiş durumu (filtrelenmiş liste) otomatik olarak yeniden hesaplar.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/tr/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\nfinal filterTypeProvider = StateProvider<FilterType>((ref) => FilterType.none);\nfinal todosProvider = StateNotifierProvider<TodoList, List<Todo>>((ref) => TodoList());\n\nfinal filteredTodoListProvider = Provider((ref) {\n  // hem filtreyi hem de görev listesini al\n  final FilterType filter = ref.watch(filterTypeProvider);\n  final List<Todo> todos = ref.watch(todosProvider);\n\n  switch (filter) {\n    case FilterType.completed:\n      // görevlerin tam listesini döndür\n      return todos.where((todo) => todo.isCompleted).toList();\n    case FilterType.none:\n      // filtrelenmemiş görev listesini döndürür\n      return todos;\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Migrating from useProvider to ref.watch in HookConsumerWidget - Dart\nDESCRIPTION: This snippet illustrates the migration in the usage of providers within a HookConsumerWidget. Previously, the `useProvider` hook was used to listen to providers, but in version 1.0.0, it is replaced with the unified syntax: using the `ref.watch` method of the widget's WidgetRef parameter. This change centralizes provider interaction under the `ref` object and aligns build method signatures with the new Riverpod API.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/bn/docusaurus-plugin-content-docs/current/migration/0.14.0_to_1.0.0.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nclass Example extends HookWidget {\n  @override\n  Widget build(BuildContext context) {\n    useState(...);\n    int count = useProvider(counterProvider);\n    ...\n  }\n}\n\n```\n\nLANGUAGE: dart\nCODE:\n```\nclass Example extends HookConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    useState(...);\n    int count = ref.watch(counterProvider);\n    ...\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Initializing Search Input Provider with Riverpod in Dart\nDESCRIPTION: This snippet shows how to define a StateProvider in Dart using Riverpod, intended to hold the user's current search query as a string. The provider exposes the search input state, which is initially set to an empty string and can be referenced and updated throughout the widget tree using Riverpod's ProviderScope context. There are no external dependencies beyond Riverpod itself, and the provider's value represents a single String without validation or persistence.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/cookbooks/search_as_we_type.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nfinal searchInputProvider = StateProvider<String>((ref) => '');\n```\n\n----------------------------------------\n\nTITLE: Defining Repository and Dependent Provider in Dart\nDESCRIPTION: This snippet defines a `Repository` class (presumably for data fetching) and two Riverpod providers. `repositoryProvider` provides an instance of `Repository`. `todoListProvider` is a `FutureProvider` that depends on `repositoryProvider` to fetch a list of todos, demonstrating a common dependency pattern in Riverpod applications.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/cookbooks/testing.mdx#2025-04-23_snippet_2\n\nLANGUAGE: Dart\nCODE:\n```\n/// A repository that exposes methods to fetch todos.\n///\n/// This is a plain Dart class. It does not know about Riverpod.\nclass Repository {\n  Future<List<Object?>> fetchTodos() async => [];\n}\n\n/// A provider that creates an instance of [Repository].\n///\n/// This exposes the [Repository] to the rest of the application.\nfinal repositoryProvider = Provider<Repository>((ref) => Repository());\n\n/// A provider that fetches the list of todos\n///\n/// This depends on [repositoryProvider] to make the HTTP request.\n/// It will automatically update dependents when the dependency changes.\nfinal todoListProvider = FutureProvider<List<Object?>>((ref) async {\n  // Obtain the Repository instance from repositoryProvider\n  final repository = ref.watch(repositoryProvider);\n\n  // Fetch the todos and expose them to the UI.\n  return repository.fetchTodos();\n});\n\n```\n\n----------------------------------------\n\nTITLE: Displaying Product List in Flutter UI using Riverpod (Dart)\nDESCRIPTION: This snippet presents how to build a Flutter widget that consumes the product list, displaying it in the UI. It typically uses Riverpod consumers or hooks to reactively update when the product list changes. Requires: Flutter SDK, Riverpod. Key parameters include the provider reference and the widget context. Input is the product list provider; output is a rendered widget (e.g., ListView) showing the products. This approach is suitable for small to medium data sets.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/providers/state_provider.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n/* Example Dart UI widget to display products using Riverpod. Actual implementation is in product_list_view.dart */\n```\n\n----------------------------------------\n\nTITLE: Emitting Multiple Values with AsyncValue in Riverpod (Dart)\nDESCRIPTION: This snippet showcases Riverpod's ability to emit multiple values simultaneously using AsyncValue, allowing for displaying the last read value while loading a new value from a RESTful API. This is a feature not easily achievable with Provider.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/from_provider/motivation/motivation.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nimport asyncValues from \"/docs/from_provider/motivation/async_values\";\n```\n\n----------------------------------------\n\nTITLE: Invalidate Parameterized Provider - Dart\nDESCRIPTION: Illustrates how to invalidate a provider that accepts parameters. It shows how to invalidate a specific combination of parameters or all possible combinations at once.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/essentials/auto_dispose.mdx#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\n  // このproviderの全ての組み合わせ可能なパラメータを無効にします。\n  // 指定した組み合わせのみを無効にします。\n```\n\n----------------------------------------\n\nTITLE: Disabling autoDispose for a Provider (Dart)\nDESCRIPTION: This snippet shows how to disable the default autoDispose behavior for a code-generated provider by passing `keepAlive: true` to the annotation. This prevents the provider from being disposed when no listeners are attached.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/about_code_generation.mdx#_snippet_8\n\nLANGUAGE: dart\nCODE:\n```\n{trimSnippet(autoDisposeCodeGen)}\n```\n\n----------------------------------------\n\nTITLE: Initializing Notifier with Riverpod 2.0 (Dart)\nDESCRIPTION: Shows how to set up a Notifier in Riverpod 2.0, consolidating initialization and dependency logic within the build method for better readability and maintainability. Depends on Riverpod 2.0+, and uses NotifierProvider. Key input is the build context/ref object; output is the managed state, with all side effects and reactive dependencies wired into build. Removes the need for constructor-based logic and unifies syntax for sync/async notifiers.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/migration/from_state_notifier.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n<!-- buildInit.dart content placeholder -->\n```\n\n----------------------------------------\n\nTITLE: Logging Provider State Updates Using ProviderObserver in Dart\nDESCRIPTION: This snippet extends the ProviderObserver class to override the didUpdateProvider method, allowing it to log every update emitted by a provider. It helps track the provider name and the new value whenever the provider's state changes. The snippet depends on Riverpod framework and assumes a ProviderContainer is instantiated. Expected input is any provider emitting updates, and the output is a log entry in the console reflecting these changes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/de/docusaurus-plugin-content-docs/current/concepts/provider_observer.mdx#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\nclass Logger extends ProviderObserver {\n  @override\n  void didUpdateProvider(ProviderBase provider, Object? previousValue, Object? newValue, ProviderContainer container) {\n    print('{\n  \"provider\": \"${provider.name}\",\n  \"newValue\": \"$newValue\"\n}');\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Notifier Structure in Riverpod (Non-Codegen)\nDESCRIPTION: Shows the structure of a Notifier in Riverpod without using code generation. This pattern allows providers to expose methods that can modify state in a controlled manner, acting as a stateful widget equivalent for providers.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/essentials/side_effects.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nfinal name = SomeNotifierProvider.someModifier<MyNotifier, Result>(MyNotifier.new);\n \nclass MyNotifier extends SomeNotifier<Result> {\n  @override\n  Result build() {\n    <your logic here>\n  }\n\n  <your methods here>\n}\n```\n\n----------------------------------------\n\nTITLE: AsyncValue<int?> Nullable Pattern Matching\nDESCRIPTION: Example showing unsafe pattern matching with AsyncValue<int?> using nullable pattern. The lint warns against using :final value? syntax and recommends using hasValue: true instead.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/async_value_nullable_pattern/async_value_nullable_pattern_lint.md#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n    case AsyncValue<int?>(\n        // expect_lint: async_value_nullable_pattern\n        :final value?,\n      ):\n      print(value);\n```\n\n----------------------------------------\n\nTITLE: Traditional Riverpod Provider Definition\nDESCRIPTION: Example showing the traditional way of defining a provider without code generation.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/about_code_generation.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nfinal userProvider = FutureProvider((ref) async {\n  final user = await fetchUser();\n  return user;\n});\n```\n\n----------------------------------------\n\nTITLE: Using AutoSnippet to Document Riverpod Implementation in Dart\nDESCRIPTION: This code snippet illustrates the use of the AutoSnippet component to include a Dart code example demonstrating Riverpod's implementation for handling asynchronous data, errors, and UI state within a Flutter application. It leverages the imported 'whyRiverpod' documentation object for contextual details and includes translations for key functions, supporting multi-language documentation and code presentation.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/introduction/why_riverpod.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet language=\"dart\" \n    {...whyRiverpod}\n    translations={{\n        fetchPackages: \"// pub.dev에서 패키지 목록을 가져옵니다.\",\n        fetchApi: \"  // API를 호출합니다. 여기서는 package:dio를 사용하고 있지만 다른 것을 사용할 수도 있습니다.\",\n        decodeJson: \"  // JSON 응답을 Dart 클래스로 디코딩합니다.\",\n    }}\n/>\n```\n\n----------------------------------------\n\nTITLE: Using ref.listen in ConsumerWidget (Post-1.0.0-dev.0) in Dart\nDESCRIPTION: Shows how to use `ref.listen` within the `build` method of a `ConsumerWidget` as a replacement for the deprecated `ProviderListener`. This allows reacting to provider state changes (like executing side effects) without triggering a widget rebuild.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/flutter_riverpod/CHANGELOG.md#2025-04-23_snippet_10\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nclass Example extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    ref.listen<int>(counter, (count) {\n      print('count changed $count');\n    });\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Character Search Provider with Configuration\nDESCRIPTION: Implements a FutureProvider for fetching characters with dynamic configuration and search.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/combining_providers.mdx#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nfinal charactersProvider = FutureProvider.autoDispose((ref) {\n  final configurations = ref.watch(configurationsProvider);\n  final search = ref.watch(searchProvider);\n\n  return fetchCharacters(configurations, search: search);\n});\n```\n\n----------------------------------------\n\nTITLE: Using ProviderScope in Flutter\nDESCRIPTION: This snippet shows how to integrate `ProviderScope` into a Flutter application.  It is required to make providers work. `ProviderScope` is added at the root of the Flutter application, wrapping the `MyApp` widget to provide the necessary context for Riverpod.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/bn/docusaurus-plugin-content-docs/current/concepts/providers.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nvoid main() {\n  runApp(ProviderScope(child: MyApp()));\n}\n```\n\n----------------------------------------\n\nTITLE: Avoid Initializing Riverpod Providers in Widgets - Dart\nDESCRIPTION: Demonstrates the anti-pattern of initializing a Riverpod provider within a widget's lifecycle method (initState), which can cause race conditions and unpredictable behavior. Instead, initialization logic depending on external factors should be placed within event handlers such as a button's onPressed callback. This snippet highlights provider self-initialization best practices and how to handle navigation-triggered initialization safely in Flutter.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/essentials/do_dont.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nclass WidgetState extends State<MyWidget> {\n  @override\n  void initState() {\n    super.initState();\n    // 坏的：提供者程序应该自己初始化自己\n    ref.read(provider).init();\n  }\n}\n```\n\nLANGUAGE: dart\nCODE:\n```\nElevatedButton(\n  onPressed: () {\n    ref.read(provider).init();\n    Navigator.of(context).push(...);\n  },\n  child: Text('Navigate'),\n)\n```\n\n----------------------------------------\n\nTITLE: Sample 'Hello World' Dart CLI app with Riverpod\nDESCRIPTION: This snippet demonstrates a simple Dart console application that uses Riverpod to create a provider and display its value. It involves initializing Riverpod container and reading provider values, suitable for command-line environments.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/introduction/getting_started.mdx#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\n// 예제 'Hello World' Dart CLI 앱\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal helloProvider = Provider<String>((ref) => \"Hello world\");\n\nvoid main() {\n  final container = ProviderContainer();\n  final message = container.read(helloProvider);\n  print(message);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating Generic Riverpod Providers\nDESCRIPTION: Demonstrates how to create generic Riverpod providers, both as functions and classes, and how to use them with type parameters.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_generator/CHANGELOG.md#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\nList<T> example<T extends num>(ExampleRef<T> ref) {\n  return <T>[];\n}\n\n@riverpod\nclass ClassExample<T> extends _$ClassExample<T> {\n  @override\n  List<T> build() => <T>[];\n}\n\nref.watch(example<int>());\n```\n\n----------------------------------------\n\nTITLE: Using Select to Listen to a Specific Property (Prefer) in Dart\nDESCRIPTION: Illustrates the preferred method for optimizing provider rebuilds when only a specific property of a dependency is needed. It uses `ref.watch` combined with `.select()` to listen *only* to the `host` property of the `configurationProvider`. This ensures the `productsProvider` only rebuilds when the `host` property changes, ignoring changes to other properties in the `Configuration` object.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#2025-04-23_snippet_9\n\nLANGUAGE: dart\nCODE:\n```\nfinal configurationProvider = Provider<Configuration>((ref) => Configuration());\n\n// PREFER using `select` for filtering unwanted rebuilds\nfinal productsProvider = FutureProvider((ref) async {\n  // Listens to the configurationProvider, but return only `host`.\n  // This will cause the provider to re-evaluate only when `host` changes.\n  final host = ref.watch(\n    configurationProvider.select((config) => config.host),\n  );\n\n  final response = await dio.get('$host/products');\n  return Products.fromJson(response.data);\n});\n```\n\n----------------------------------------\n\nTITLE: Using select to filter provider property for selective rebuilds in Riverpod (TypeScript)\nDESCRIPTION: Demonstrates how to utilize the 'select' function in Riverpod to watch only specific properties of a provider, thereby reducing unnecessary widget rebuilds when other properties change. It emphasizes that 'select' can be called multiple times for different properties and should return immutable data to prevent unintended rebuild triggers.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/advanced/select.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\n<AutoSnippet\n  {...select}\n  translations={{\n    watch:\n      \"    // Next, instead of: \\n    // String name = ref.watch(provider).firstName!;\\n    // You can write as follows:\",\n    note: \"    // This makes the widget only listen to changes in 'firstName'.\",\n  }}\n/>\n```\n\n----------------------------------------\n\nTITLE: `AsyncNotifier`의 비동기 마이그레이션 예제\nDESCRIPTION: 이 예제는 기존 `StateNotifier<AsyncValue<T>>`를 사용하는 비동기 상태를 `AsyncNotifier<T>`로 마이그레이션하는 방법을 보여줍니다. `AsyncNotifier`는 `FutureProvider`와 유사하며, 비동기 데이터 관리, 에러 핸들링 및 상태 갱신을 간단하게 처리하는 유틸리티를 포함합니다. `build` 메서드 내에 비동기 초기화 로직을 넣어, 코드가 더 간단해지고 유지보수가 용이합니다.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/migration/from_state_notifier.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet raw={asyncNotifierOld}/>\n```\n\n----------------------------------------\n\nTITLE: Using ref.listen to React to Provider Changes (Dart)\nDESCRIPTION: This pattern uses ref.listen to call a callback whenever a provider changes, rather than rebuilding the UI. Useful for side effects such as navigation or showing notifications. ref.listen is used in provider bodies or the build method of widgets. Inputs include the provider and a callback; outputs are side effects. Avoid using ref.listen in asynchronous contexts or widget lifecycle methods.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_7\n\nLANGUAGE: dart\nCODE:\n```\n// Example: ref.listen usage\nref.listen<AsyncValue<User>>(userProvider, (previous, next) {\n  if (next.hasError) {\n    showSnackbar('An error occurred');\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of ref.read Inside Build Method in Flutter Dart\nDESCRIPTION: Illustrates a bad practice of using ref.read inside build methods, which can lead to elusive bugs and maintenance issues. Advises against this pattern and promotes using ref.watch for reactive, robust code.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_11\n\nLANGUAGE: Dart\nCODE:\n```\n<CodeBlock>{trimSnippet(readBuild)}</CodeBlock>\n```\n\n----------------------------------------\n\nTITLE: Defining Home Screen in Flutter using Riverpod (Dart)\nDESCRIPTION: This snippet defines the main screen of the sample Flutter application. It includes a ProviderScope at the root, ensuring Riverpod context is available throughout the widget tree. The home screen features a FloatingActionButton that uses Navigator.push to open a detail page. No debouncing or cancellation logic is included at this stage. Required dependencies: flutter, flutter_riverpod. Expected input: user interaction with the button; output: navigation to the detail screen.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/case_studies/cancel.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n/* contents of lib/src/main.dart as per homeScreen */\n```\n\n----------------------------------------\n\nTITLE: Defining a city provider in Dart\nDESCRIPTION: An auto-generated snippet demonstrating the declaration of a city provider, which provides city data to other parts of the application. Depends on the city_provider module and is used to create dependent providers such as weatherProvider.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet language=\"dart\" {...cityProvider}></AutoSnippet>\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage Example: Omitting Parameter for family Providers (Dart)\nDESCRIPTION: This snippet highlights a common error when using .family providers in Riverpod by attempting to watch the provider without supplying the required parameter. The parameterized provider cannot be accessed without specifying its argument; failing to do so will produce an error. It demonstrates the correct function signature and the need to supply the expected input.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/modifiers/family.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, WidgetRef ref) {\n  // Error – messagesFamily is not a provider\n  final response = ref.watch(messagesFamily);\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of ref.read with StateNotifier in Flutter\nDESCRIPTION: This example shows an incorrect approach to using ref.read with a StateNotifier, which can cause issues when the state needs to be reset or updated.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/reading.mdx#2025-04-23_snippet_10\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet language=\"dart\" {...readNotifierBuild}></AutoSnippet>\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Raw Type Usage in Riverpod Provider\nDESCRIPTION: This snippet shows how to use the 'Raw' typedef in a Riverpod provider to return a Future<int> instead of AsyncValue<int>. It demonstrates the new feature added in version 2.1.0 for disabling automatic conversion of Futures/Streams into AsyncValues.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_annotation/CHANGELOG.md#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\nRaw<Future<int>> myProvider(...) async => ...;\n...\n// returns a Future<int> instead of AsyncValue<int>\nFuture<int> value = ref.watch(myProvider);\n```\n\n----------------------------------------\n\nTITLE: Implementing Eager Initialization with Consumer in Riverpod\nDESCRIPTION: This code demonstrates how to eagerly initialize providers by placing a Consumer widget directly under the ProviderScope at the root of a Flutter application. This approach ensures the provider is initialized when the app starts rather than lazily when first accessed.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/eager_initialization.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nvoid main() {\n  runApp(\n    // This widget is where the application providers are initialized\n    ProviderScope(\n      child: _EagerInitialization(\n        child: MyApp(),\n      ),\n    ),\n  );\n}\n\nclass _EagerInitialization extends ConsumerWidget {\n  const _EagerInitialization({required this.child});\n\n  final Widget child;\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // Eagerly initialize providers by watching them\n    ref.watch(someProvider);\n    ref.watch(anotherProvider);\n\n    // Return the application without any changes\n    return child;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Riverpod dependency using pub add Dart\nDESCRIPTION: Demonstrates how to add the Flutter Riverpod or Riverpod dependency to a Flutter or Dart project using the `pub add` command. It shows the specific command for each environment.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/introduction/getting_started.mdx#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ndart pub add riverpod\n```\n\n----------------------------------------\n\nTITLE: Using ProviderObserver with ProviderContainer\nDESCRIPTION: This snippet demonstrates how to use a custom ProviderObserver with a ProviderContainer. This is useful for scenarios where you're not using the full Flutter widget tree.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/provider_observer.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nfinal container = ProviderContainer(\n  observers: [\n    MyObserver(),\n  ],\n);\n```\n\n----------------------------------------\n\nTITLE: Converting StreamProvider to FutureProvider in Dart\nDESCRIPTION: Example showing how to refactor from using StreamProvider with the deprecated .stream modifier to using FutureProvider for asynchronous data transformation.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod/CHANGELOG.md#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n// Deprecated:\nfinal a = StreamProvider((ref) {\n  return ref.watch(b.stream).map((e) => Model(e));\n})\n\n// Recommended alternative:\nfinal a = FutureProvider((ref) async {\n  final e = await ref.watch(b.future);\n  return Model(e);\n})\n```\n\n----------------------------------------\n\nTITLE: Original ChangeNotifier Implementation\nDESCRIPTION: Example of a flawed ChangeNotifier implementation showing common issues like manual loading state management, try/catch blocks, and explicit notifyListeners calls.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/migration/from_change_notifier.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nclass TodosNotifier extends ChangeNotifier {\n  TodosNotifier() {\n    _init();\n  }\n\n  List<Todo> todos = [];\n  bool isLoading = false;\n  bool hasError = false;\n\n  void _init() async {\n    isLoading = true;\n    hasError = false;\n    notifyListeners();\n    \n    try {\n      todos = await fetchTodos();\n    } catch (e) {\n      hasError = true;\n    } finally {\n      isLoading = false;\n      notifyListeners();\n    }\n  }\n\n  void addTodo(Todo todo) async {\n    isLoading = true;\n    hasError = false;\n    notifyListeners();\n    \n    try {\n      todos = [... todos, todo]; // optimistic update\n      await saveTodo(todo);\n    } catch (e) {\n      hasError = true;\n      todos = [...todos]..removeLast(); // revert optimistic update\n    } finally {\n      isLoading = false;\n      notifyListeners();\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Unoptimized Previous Button Logic - Dart\nDESCRIPTION: This code shows an unoptimized approach to determining if a 'previous' button should be enabled, where the logic is directly embedded within the widget. This causes unnecessary rebuilds of the button whenever the current page index changes, even if the enabled state doesn't.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/es/docusaurus-plugin-content-docs/current/providers/provider.mdx#_snippet_2\n\nLANGUAGE: Dart\nCODE:\n```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal currentPageIndexProvider = StateProvider((_) => 0);\n\nclass UnoptimizedPreviousButton extends ConsumerWidget {\n  const UnoptimizedPreviousButton({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final currentPageIndex = ref.watch(currentPageIndexProvider);\n\n    return ElevatedButton(\n      onPressed: currentPageIndex == 0 ? null : () {},\n      child: const Text('Previous'),\n    );\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining styles for documentation elements\nDESCRIPTION: Defines various style objects used for UI highlighting and formatting code snippets and headings in the documentation, such as transparent backgrounds, red and blue text, font sizes, and alignment styles.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/about_code_generation.mdx#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst TRANSPARENT_STYLE = { backgroundColor: \"transparent\" };\nconst RED_STYLE = { color: \"indianred\", fontWeight: \"700\" };\nconst BLUE_STYLE = { color: \"rgb(103, 134, 196)\", fontWeight: \"700\" };\nconst FONT_16_STYLE = {\n  fontSize: \"16px\",\n  fontWeight: \"700\"\n};\nconst BLUE_20_STYLE = {\n  color: \"rgb(103, 134, 196)\",\n  fontSize: \"20px\",\n  fontWeight: \"700\"\n};\nconst PROVIDER_STYLE = {\n  textAlign: \"center\",\n  fontWeight: \"600\",\n  maxWidth: \"210px\"\n};\nconst BEFORE_STYLE = {\n  minWidth: \"120px\",\n  textAlign: \"center\",\n  fontWeight: \"600\",\n  color: \"crimson\"\n};\nconst AFTER_STYLE = {\n  minWidth: \"120px\",\n  textAlign: \"center\",\n  fontWeight: \"600\",\n  color: \"rgb(40,180,40)\"\n};\n```\n\n----------------------------------------\n\nTITLE: Migrating ConsumerWidget/Consumer build signature - Dart\nDESCRIPTION: Details the breaking change in the `build` method signature for `ConsumerWidget` and `builder` for `Consumer`. `ScopedReader watch` is replaced by `WidgetRef ref`, and provider watching/reading is done via `ref.watch` and `ref.read`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/hooks_riverpod/CHANGELOG.md#_snippet_13\n\nLANGUAGE: Dart\nCODE:\n```\nclass Example extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, ScopedReader watch) {\n    int count = watch(counterProvider);\n    ...\n  }\n}\n```\n\nLANGUAGE: Dart\nCODE:\n```\nclass Example extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    int count = ref.watch(counterProvider);\n    ...\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Consuming Multiple Instances of Riverpod Provider with Different Arguments\nDESCRIPTION: This example demonstrates how to consume the same Riverpod provider multiple times with different arguments in a single widget, showing both 'recreational' and 'cooking' activities.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/passing_args.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nclass Example extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final recreationalActivity = ref.watch(activityProvider('recreational'));\n    final cookingActivity = ref.watch(activityProvider('cooking'));\n    return Column(\n      children: [\n        recreationalActivity.when(\n          loading: () => const CircularProgressIndicator(),\n          error: (error, stack) => Text('Oops, something unexpected happened'),\n          data: (activity) => Text(activity.type),\n        ),\n        cookingActivity.when(\n          loading: () => const CircularProgressIndicator(),\n          error: (error, stack) => Text('Oops, something unexpected happened'),\n          data: (activity) => Text(activity.type),\n        ),\n      ],\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Repository and TodoList Providers\nDESCRIPTION: This snippet demonstrates how to define a `Repository` class for fetching Todos and a `todoListProvider` using `FutureProvider` to fetch the Todos using the repository. The `repositoryProvider` exposes the `Repository` instance. This structure is typical in Riverpod applications where providers manage dependencies and data fetching.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/tr/docusaurus-plugin-content-docs/current/cookbooks/testing.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nclass Repository {\n  Future<List<Todo>> fetchTodos() async {}\n}\n\n// Repository örneğimizi bir provider'da kullanıma sunuyoruz\nfinal repositoryProvider = Provider((ref) => Repository());\n\n/// Görev listesi. Burada, bunları kullanarak sunucudan alıyoruz.\n/// [Repository], yapacak başka bir şey yok.\nfinal todoListProvider = FutureProvider((ref) async {\n  // Repository örneğini alın\n  final repository = ref.read(repositoryProvider);\n\n  // Görevleri alın ve bunları kullanıcı arayüzüne gösterin.\n  return repository.fetchTodos();\n});\n```\n\n----------------------------------------\n\nTITLE: Deploying Riverpod Website to GitHub Pages\nDESCRIPTION: Command to deploy the website to GitHub Pages. It builds the website and pushes the content to the 'gh-pages' branch using the specified GitHub credentials.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/README.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ GIT_USER=<Your GitHub username> USE_SSH=true yarn deploy\n```\n\n----------------------------------------\n\nTITLE: Creating a StateProvider for Filter selection in Dart\nDESCRIPTION: Defines an enum for filter types and a StateProvider to track the current filter state. Facilitates dynamic filtering of the todo list based on user selection, updating automatically when the filter state changes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#_snippet_3\n\nLANGUAGE: Dart\nCODE:\n```\nenum Filter {\n  none,\n  completed,\n  uncompleted,\n}\n\nfinal filterProvider = StateProvider((ref) => Filter.none);\n```\n\n----------------------------------------\n\nTITLE: Using HookConsumer\nDESCRIPTION: This snippet demonstrates the use of `HookConsumer`. It provides a streamlined way to use hooks and consume Riverpod providers, combining `HookBuilder` and `Consumer` for concise code.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/about_hooks.mdx#_snippet_2\n\nLANGUAGE: Dart\nCODE:\n```\n\n```\n\n----------------------------------------\n\nTITLE: Combining .autoDispose with .family (Dart)\nDESCRIPTION: This code snippet shows the combination of `.autoDispose` with `.family` modifier to create a provider that accepts an argument (`id`). It allows for the creation of providers that are automatically disposed when no longer used, but can be customized using a family parameter. It builds on the previous snippet by adding a family modifier. The input is a string id, and the output is a User.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/es/docusaurus-plugin-content-docs/current/concepts/modifiers/auto_dispose.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nfinal userProvider = StreamProvider.autoDispose.family<User, String>((ref, id) {\n\n});\n```\n\n----------------------------------------\n\nTITLE: Passing Multiple Parameters to Riverpod Family using Freezed in Dart\nDESCRIPTION: Demonstrates passing multiple parameters (`userId`, `locale`) to a Riverpod `.family` provider by encapsulating them within an immutable class (`MyParameter`) generated by the Freezed package. An instance of this class is passed to `exampleProvider` when watched. The use of `.autoDispose` is also shown.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/modifiers/family.mdx#2025-04-23_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\n```dart\n@freezed\nabstract class MyParameter with _$MyParameter {\n  factory MyParameter({\n    required int userId,\n    required Locale locale,\n  }) = _MyParameter;\n}\n\nfinal exampleProvider = Provider.autoDispose.family<Something, MyParameter>((ref, myParameter) {\n  print(myParameter.userId);\n  print(myParameter.locale);\n  // Do something with userId/locale\n});\n\n@override\nWidget build(BuildContext context, WidgetRef ref) {\n  int userId; // Read the user ID from somewhere\n  final locale = Localizations.localeOf(context);\n\n  final something = ref.watch(\n    exampleProvider(MyParameter(userId: userId, locale: locale)),\n  );\n\n  ...\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a Computed/Filtered Riverpod Provider using Multiple Watches (Dart)\nDESCRIPTION: Defines a `Provider` named `filteredTodoListProvider` that computes a filtered list of `Todo` items. It watches both `filterProvider` and `todoListProvider` using `ref.watch`, automatically recalculating the filtered list whenever the filter or the todo list changes. Assumes a `Todo` class with a `completed` property exists.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nfinal filteredTodoListProvider = Provider<List<Todo>>((ref) {\n  final filter = ref.watch(filterProvider);\n  final todos = ref.watch(todoListProvider);\n\n  switch (filter) {\n    case Filter.none:\n      return todos;\n    case Filter.completed:\n      return todos.where((todo) => todo.completed).toList();\n    case Filter.uncompleted:\n      return todos.where((todo) => !todo.completed).toList();\n  }\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Using Riverpod Provider Modifiers (.autoDispose, .family) in Dart\nDESCRIPTION: This snippet demonstrates how to use provider modifiers in Riverpod. `.autoDispose` is used with `StateProvider` to automatically destroy the provider's state when it's no longer listened to. `.family` is used with `Provider` to create providers that accept external parameters (`id` in this case), allowing for dynamic provider creation based on input. Requires the Riverpod package.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/providers.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nfinal myAutoDisposeProvider = StateProvider.autoDispose<int>((ref) => 0);\nfinal myFamilyProvider = Provider.family<String, int>((ref, id) => '$id');\n```\n\n----------------------------------------\n\nTITLE: Canceling HTTP Requests with ref.onDispose in Dart\nDESCRIPTION: Provides an example using `FutureProvider.autoDispose` and `ref.onDispose` to cancel an ongoing HTTP request (using `dio`'s `CancelToken`) if the provider is disposed before the request completes. It also uses `ref.keepAlive()` to preserve the state upon successful completion.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/concepts/modifiers/auto_dispose.mdx#_snippet_3\n\nLANGUAGE: Dart\nCODE:\n```\nfinal myProvider = FutureProvider.autoDispose((ref) async {\n  // Un objet du package:dio qui permet d'annuler les requêtes http.\n  final cancelToken = CancelToken();\n  // Lorsque le provider est détruit, annuler la requête http.\n  ref.onDispose(() => cancelToken.cancel());\n\n  // Récupérer nos données et passer notre `cancelToken` pour que l'annulation fonctionne.\n  final response = await dio.get('path', cancelToken: cancelToken);\n  // i la requête s'est terminée avec succès, gardez l'état (state)\n  ref.keepAlive();\n  return response;\n});\n```\n\n----------------------------------------\n\nTITLE: Incorrect Provider Declaration\nDESCRIPTION: Demonstrates an anti-pattern where providers are created dynamically within a class, which can cause memory leaks.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/do_dont.mdx#2025-04-23_snippet_7\n\nLANGUAGE: dart\nCODE:\n```\nclass Example {\n  // Unsupported operation. Could cause memory leaks and unexpected behaviors.\n  final provider = Provider<String>((ref) => 'Hello world');\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Search Provider with FutureProvider in Dart\nDESCRIPTION: Creates a FutureProvider that handles API requests based on the search input. This snippet is incomplete in the original text.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/bn/docusaurus-plugin-content-docs/current/cookbooks/search_as_we_type.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nfinal searchProvider = FutureProvider<\n```\n\n----------------------------------------\n\nTITLE: Cleaning up resources with onDispose in Dart\nDESCRIPTION: This code snippet demonstrates how to perform actions before a provider's state is destroyed or recreated using the `onDispose` method. It defines a `StreamProvider.autoDispose` that creates a `StreamController`. The `onDispose` method is used to close the `StreamController` when the provider's state is disposed of to prevent memory leaks.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/bn/docusaurus-plugin-content-docs/current/concepts/providers.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nfinal example = StreamProvider.autoDispose((ref) {\n  final streamController = StreamController<int>();\n\n  ref.onDispose(() {\n    // StreamController বন্ধ করে দেয় যখন প্রভাইডার এর স্টেট ধ্বংস হয়ে যায়।\n    streamController.close();\n  });\n\n  return streamController.stream;\n});\n```\n\n----------------------------------------\n\nTITLE: Async StateNotifier Provider Implementation\nDESCRIPTION: Shows an async implementation of an unsupported StateNotifier provider\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/unsupported_provider_value/unsupported_provider_value_lint.md#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\n// expect_lint: unsupported_provider_value\nFuture<MyStateNotifier> asyncStateNotifier(Ref ref) async {\n  return MyStateNotifier();\n}\n```\n\n----------------------------------------\n\nTITLE: Adding ScrollView for RefreshIndicator\nDESCRIPTION: Updates the widget to include a ScrollView, which is required for the RefreshIndicator to work properly.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/case_studies/pull_to_refresh.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nclass ActivityPage extends ConsumerWidget {\n  const ActivityPage({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final activity = ref.watch(activityProvider).value;\n    if (activity == null) return const SizedBox.shrink();\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Activity suggestions')),\n      body: Center(\n        child: ListView(\n          children: [Text(activity.activity)],\n        ),\n      ),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: StateNotifier with Family and AutoDispose in Dart (Old Syntax)\nDESCRIPTION: Example of a StateNotifier using family and autoDispose modifiers with the old syntax in Dart. This snippet shows how these modifiers were applied to StateNotifier.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/migration/from_state_notifier.mdx#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nfinal bugsEncounteredProvider = StateNotifierProvider.autoDispose.family<BugsEncounteredNotifier, AsyncValue<List<String>>, String>((ref, feature) {\n  return BugsEncounteredNotifier(feature: feature, ref: ref);\n});\n\nclass BugsEncounteredNotifier extends StateNotifier<AsyncValue<List<String>>> {\n  BugsEncounteredNotifier({required this.feature, required this.ref})\n      : super(const AsyncValue.loading()) {\n    _fetchBugs();\n  }\n\n  final String feature;\n  final AutoDisposeStateNotifierProviderRef<BugsEncounteredNotifier, AsyncValue<List<String>>> ref;\n\n  Future<void> _fetchBugs() async {\n    state = const AsyncValue.loading();\n    try {\n      final result = await ref.read(bugsRepositoryProvider).fetchBugs(feature);\n      state = AsyncValue.data(result);\n    } catch (e, stack) {\n      state = AsyncValue.error(e, stack);\n    }\n  }\n\n  @override\n  void dispose() {\n    // Cancel any ongoing operations\n    super.dispose();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Lifecycle and Disposal in StateNotifier (Dart)\nDESCRIPTION: Explains prior methodology of managing provider lifecycle and disposal logic in StateNotifier-based Riverpod code. Disposal was managed via explicit overrides and callbacks, which were often spread across the provider and notifier. Requires StateNotifier/StateNotifierProvider from pre-2.0 Riverpod. Inputs include ref objects where applicable; outputs are callback invocations upon disposal. Limitations include diffuse logic location, leading to potential maintenance headaches.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/migration/from_state_notifier.mdx#_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\n<!-- oldLifecyclesOld.dart content placeholder -->\n```\n\n----------------------------------------\n\nTITLE: Extending ConsumerWidget for Provider Reads - Riverpod - Dart\nDESCRIPTION: Illustrates creating a custom Flutter widget by extending ConsumerWidget, thus allowing access to provider values via the build method. Requires riverpod and flutter dependencies and is used when you want stateless widgets that interact with providers. Inputs are BuildContext and a ScopedReader, output is a Widget constructed from provider data.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/flutter_riverpod/CHANGELOG.md#2025-04-23_snippet_21\n\nLANGUAGE: dart\nCODE:\n```\nclass MyWidget extends ConsumerWidget {\n  const MyWidget({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context, ScopedReader watch) {\n    final value = watch(myProvider);\n    return Text('$value');\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring a StateProvider for Search Input (Riverpod, Dart)\nDESCRIPTION: Defines a StateProvider to store the current search input text. This provider keeps track of changes to the search field and is used as a dependency in subsequent providers. No external dependencies are required for this code, but it is part of a larger Riverpod/Flutter context. The provider expects a String state (the user query), and its value changes as the user types.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/cookbooks/search_as_we_type.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nfinal searchInputProvider = StateProvider<String>((ref) => '');\n```\n\n----------------------------------------\n\nTITLE: Listening to a Whole Object (Avoid) in Dart\nDESCRIPTION: Demonstrates a potentially inefficient pattern where a provider (`productsProvider`) watches an entire configuration object (`configurationProvider`) but only uses one property (`host`). If any other property in the `Configuration` changes, this provider will still rebuild unnecessarily. This pattern should be avoided if only specific properties are needed.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#2025-04-23_snippet_8\n\nLANGUAGE: dart\nCODE:\n```\nfinal configurationProvider = Provider<Configuration>((ref) => Configuration());\n\n// AVOID listening to the entire object if you only need one property\nfinal productsProvider = FutureProvider((ref) async {\n  // Listens to the entire `Configuration` object\n  final host = ref.watch(configurationProvider).host;\n\n  final response = await dio.get('$host/products');\n  return Products.fromJson(response.data);\n});\n```\n\n----------------------------------------\n\nTITLE: Consuming a FutureProvider in a Widget (Dart)\nDESCRIPTION: This snippet placeholder represents a Flutter widget (imported as `configConsumer`) demonstrating how to consume the previously defined `configProvider`. It uses `ref.watch` to listen to the provider's state, which returns an `AsyncValue`. The widget automatically rebuilds based on the `Future`'s state (loading, data, or error), typically using the `when` method of `AsyncValue` to handle these different cases.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/providers/future_provider.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet language=\"dart\" {...configConsumer}></AutoSnippet>\n```\n\n----------------------------------------\n\nTITLE: Consuming Notifier (Pre-0.14.0) in a Widget (Dart)\nDESCRIPTION: Accesses the StateNotifier instance inside a widget's build method using the previous Riverpod syntax. Requires a valid provider and the ScopedReader parameter. This approach is deprecated in 0.14.0+ in favor of the `.notifier` API.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, ScopedReader watch) {\n  MyStateNotifier notifier = watch(provider);\n}\n```\n\n----------------------------------------\n\nTITLE: Using ChangeNotifierProvider in UI with Riverpod Consumer in Dart\nDESCRIPTION: This snippet shows how to use the ChangeNotifierProvider in the UI to interact with the list of todos. It uses a Riverpod Consumer to watch the todosProvider and rebuild the widget when the state changes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/providers/change_notifier_provider.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass TodoListView extends ConsumerWidget {\n  const TodoListView({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // rebuild the widget when the todo list changes\n    List<Todo> todos = ref.watch(todosProvider).todos;\n\n    // Let's render the todos in a scrollable list view\n    return ListView(children: [\n      for (final todo in todos)\n        CheckboxListTile(\n          value: todo.completed,\n          // When tapping on the todo, change its completed status\n          onChanged: (value) =>\n              ref.read(todosProvider.notifier).toggle(todo.id),\n          title: Text(todo.description),\n        ),\n    ]);\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Declaring Multiple Providers of Same Type in Riverpod (Dart)\nDESCRIPTION: This placeholder represents a Dart code snippet demonstrating how Riverpod allows declaring multiple providers of the same type without the ambiguity issues faced by Provider/InheritedWidget. Riverpod overcomes the limitation where InheritedWidget only retrieves the closest ancestor of a given type, enabling finer-grained state management.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/from_provider/motivation/motivation.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet language=\"dart\" {...sameType}></AutoSnippet>\n```\n\n----------------------------------------\n\nTITLE: Canceling HTTP Requests on Provider Dispose with dio and autoDispose (Dart)\nDESCRIPTION: This example uses a FutureProvider with autoDispose in Riverpod to cleanly cancel pending HTTP requests using the dio package. A CancelToken is created and passed into dio.get for cancellation support. ref.onDispose registers a cleanup callback to cancel the token when the provider is destroyed. If the request completes successfully, ref.keepAlive() is called to keep the state. Dependencies include package:dio and dio configuration.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/modifiers/auto_dispose.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nfinal myProvider = FutureProvider.autoDispose((ref) async {\n  // An object from package:dio that allows cancelling http requests\n  final cancelToken = CancelToken();\n  // When the provider is destroyed, cancel the http request\n  ref.onDispose(() => cancelToken.cancel());\n\n  // Fetch our data and pass our `cancelToken` for cancellation to work\n  final response = await dio.get('path', cancelToken: cancelToken);\n  // If the request completed successfully, keep the state\n  ref.keepAlive();\n  return response;\n});\n```\n\n----------------------------------------\n\nTITLE: Defining a Fully Migrated Riverpod Notifier Class with Code Generation in Dart\nDESCRIPTION: Illustrates a fully migrated Riverpod notifier class using the @riverpod annotation and extending the generated class (_$MyNotifier). The class overrides the build method to initialize state to zero and provides an increment method to update the state. This approach eliminates the need for the temporary extension method and the use of ChangeNotifierProvider, promoting idiomatic Riverpod usage with code generation.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/from_provider/quickstart.mdx#_snippet_2\n\nLANGUAGE: Dart\nCODE:\n```\n@riverpod\nclass MyNotifier extends _$MyNotifier {\n  @override\n  int build() => 0;\n\n  void increment() => state++;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating parameterized FutureProvider with .family in Dart\nDESCRIPTION: Defines a FutureProvider using the .family modifier to asynchronously fetch a Message by its ID. The provider accepts a String parameter representing the message ID, which is used in an API call. This pattern enables dynamic retrieval of data based on external inputs. It requires the Riverpod package and an HTTP client like dio for requests.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/concepts/modifiers/family.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nfinal messagesFamily = FutureProvider.family<Message, String>((ref, id) async {\n  return dio.get('http://my_api.dev/messages/$id');\n});\n```\n\n----------------------------------------\n\nTITLE: Handling Side Effects with ref.listen in Riverpod (Dart)\nDESCRIPTION: This placeholder represents a Dart code snippet demonstrating the use of `ref.listen` in Riverpod to trigger side effects (like navigation, showing snackbars, or logging) in response to state changes. This provides a clean and straightforward mechanism that Provider lacks due to the limitations of `InheritedWidget` (no `onChange` callback).\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/from_provider/motivation/motivation.mdx#2025-04-23_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet language=\"dart\" {...sideEffects}></AutoSnippet>\n```\n\n----------------------------------------\n\nTITLE: Correcting .autoDispose Usage (Dart)\nDESCRIPTION: This code snippet shows how to fix the error from the previous example by also using `.autoDispose` on the provider which uses the `autoDispose` provider. This ensures that both providers are disposed together.  It requires no external dependencies other than the previous snippet. The input is `ref.watch(firstProvider)`, the output is correct behaviour.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/es/docusaurus-plugin-content-docs/current/concepts/modifiers/auto_dispose.mdx#_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nfinal firstProvider = Provider.autoDispose((ref) => 0);\n\nfinal secondProvider = Provider.autoDispose((ref) {\n  ref.watch(firstProvider);\n});\n```\n\n----------------------------------------\n\nTITLE: Testing Generator Provider with Bar Class Parameters\nDESCRIPTION: Test cases for generator provider using Bar class instances.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/provider_parameters/provider_parameters_lint.md#2025-04-23_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\n\n    // expect_lint: provider_parameters\n    ref.watch(generatorProvider(value: Bar()));\n    ref.watch(generatorProvider(value: const Bar()));\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Provider with Provider\nDESCRIPTION: Example of defining a basic `Provider` using the Provider package. This is typically placed within the widget tree, often inside a `MultiProvider`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/from_provider/provider_vs_riverpod.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nProvider<Model>(...);\n```\n\n----------------------------------------\n\nTITLE: Implementing Todo List with ChangeNotifierProvider in Dart\nDESCRIPTION: This snippet demonstrates how to use ChangeNotifierProvider to implement a todo list. It defines a TodoList class that extends ChangeNotifier and provides methods to add and remove todos.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/providers/change_notifier_provider.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// A provider that exposes a `ChangeNotifier`\nfinal todosProvider = ChangeNotifierProvider<TodoList>((ref) {\n  return TodoList();\n});\n\nclass TodoList extends ChangeNotifier {\n  final List<Todo> _todos = [];\n\n  List<Todo> get todos => _todos;\n\n  void add(Todo todo) {\n    _todos.add(todo);\n    notifyListeners();\n  }\n\n  void remove(String todoId) {\n    _todos.removeWhere((element) => element.id == todoId);\n    notifyListeners();\n  }\n\n  // ...\n}\n\nclass Todo {\n  Todo({\n    required this.id,\n    required this.description,\n    required this.completed,\n  });\n\n  final String id;\n  final String description;\n  final bool completed;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Using @riverpod annotation with ChangeNotifier (Dart)\nDESCRIPTION: Shows how to use the @riverpod annotation to expose a ChangeNotifier using the custom extension method. The listenAndDisposeChangeNotifier method is used within the provider to properly manage the ChangeNotifier's lifecycle.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/from_provider/quickstart.mdx#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\n// ignore_for_file: unsupported_provider_value\n@riverpod\nMyNotifier example(Ref ref) {\n  return ref.listenAndDisposeChangeNotifier(MyNotifier());\n}\n```\n\n----------------------------------------\n\nTITLE: Adding hooks_riverpod dependency in pubspec.yaml\nDESCRIPTION: This YAML snippet shows how to add the `hooks_riverpod` package to your `pubspec.yaml` file. It includes environment constraints for the Dart SDK and Flutter, and specifies the dependency on `flutter`, `flutter_hooks`, and `hooks_riverpod`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/getting_started.mdx#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nenvironment:\n  sdk: \">=2.12.0 <4.0.0\"\n  flutter: \">=2.0.0\"\n\ndependencies:\n  flutter:\n    sdk: flutter\n  flutter_hooks:\n  hooks_riverpod: ^2.1.3\n```\n\n----------------------------------------\n\nTITLE: Reading Stream from StreamProvider\nDESCRIPTION: Shows how to obtain the underlying Stream from a StreamProvider using ref.watch\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/reading.mdx#2025-04-23_snippet_13\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, WidgetRef ref) {\n  Stream<User> user = ref.watch(userProvider.stream);\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Raw Typedef Usage in Riverpod Provider\nDESCRIPTION: Shows how to use the Raw typedef to silence the unsupported_provider_value lint when a provider intentionally returns an unsupported object.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint/CHANGELOG.md#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\nRaw<MyChangeNotifier> myProvider(...) => MyChangeNotifier();\n```\n\n----------------------------------------\n\nTITLE: Definizione di un Notifier con annotazioni @riverpod in Dart\nDESCRIPTION: Dimostra come creare un provider annotando una classe con `@riverpod` o `@Riverpod()`, estendendo la classe generata `_NotifierName`. La classe contiene un metodo `build` per configurare lo stato e può includere metodi pubblici per modificare lo stato, il tutto senza proprietà pubbliche eccetto `state`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/essentials/side_effects.mdx#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\n@riverpod\nclass MyNotifier extends _$MyNotifier {\n  @override\n  Result build() {\n    <your logic here>\n  }\n\n  <your methods here>\n}\n```\n\n----------------------------------------\n\nTITLE: Using autoDispose with Riverpod Family in Dart\nDESCRIPTION: Defines a `FutureProvider` that uses both `.autoDispose` and `.family`. This pattern is useful for scenarios like search filters where parameters change often and may not be reused, preventing potential memory leaks by automatically disposing of the provider's state when it's no longer listened to.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/modifiers/family.mdx#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nfinal characters = FutureProvider.autoDispose.family<List<Character>, String>((ref, filter) async {\n  return fetchCharacters(filter: filter);\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Migrating from StateProvider to Notifier in Riverpod 2.0 with Dart\nDESCRIPTION: Provides guidance on migrating from the deprecated StateProvider, which simplified StateNotifierProvider, to the explicit Notifier introduced in Riverpod 2.0. Although this results in more code lines (LoC), it aligns with the new Riverpod APIs and allows proper use of StateNotifier concepts. The snippet shows old and new equivalent implementations, requiring Dart and Riverpod.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/migration/from_state_notifier.mdx#_snippet_9\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet raw={fromStateProviderOld}/>\n```\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet language=\\\"dart\\\" {...fromStateProvider}></AutoSnippet>\n```\n\n----------------------------------------\n\nTITLE: Implementing Fade-In Animation with StatefulWidget in Flutter\nDESCRIPTION: A traditional implementation of a fade-in animation using StatefulWidget, AnimationController, and SingleTickerProviderStateMixin. The widget starts invisible and gradually appears over a 2-second duration.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/about_hooks.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nclass FadeIn extends StatefulWidget {\n  const FadeIn({Key? key, required this.child}) : super(key: key);\n\n  final Widget child;\n\n  @override\n  State<FadeIn> createState() => _FadeInState();\n}\n\nclass _FadeInState extends State<FadeIn> with SingleTickerProviderStateMixin {\n  late final AnimationController animationController = AnimationController(\n    vsync: this,\n    duration: const Duration(seconds: 2),\n  );\n\n  @override\n  void initState() {\n    super.initState();\n    animationController.forward();\n  }\n\n  @override\n  void dispose() {\n    animationController.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return AnimatedBuilder(\n      animation: animationController,\n      builder: (context, child) {\n        return Opacity(\n          opacity: animationController.value,\n          child: widget.child,\n        );\n      },\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing dependencies in pubspec.yaml (Flutter) and pubspec.yaml (Dart)\nDESCRIPTION: Sample code snippets demonstrating how to add Riverpod dependencies to your project's pubspec.yaml file, both for Flutter and pure Dart projects. This process is essential for integrating Riverpod into the project and involves specifying the package version and running package management commands.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/Introduction/getting_started.mdx#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n# Flutterの場合の依存関係追加例\ndependencies:\n  flutter_riverpod: ^<latest_version>\n\n# Dartのみの場合の依存関係追加例\ndependencies:\n  riverpod: ^<latest_version>\n```\n\n----------------------------------------\n\nTITLE: Declaring Multiple Providers of Same Type in Riverpod\nDESCRIPTION: Demonstrates how Riverpod allows declaring multiple providers of the same type, which is not possible with Provider. This enables splitting logic into smaller pieces.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/from_provider/motivation/motivation.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nfinal oddItemsProvider = Provider<List<Item>>((ref) {\n  return [Item(id: 1), Item(id: 3), Item(id: 5)];\n});\n\nfinal evenItemsProvider = Provider<List<Item>>((ref) {\n  return [Item(id: 2), Item(id: 4), Item(id: 6)];\n});\n```\n\n----------------------------------------\n\nTITLE: Isolating provider state in widget tests with Riverpod (Flutter, Dart)\nDESCRIPTION: Demonstrates how global provider declarations do not share state across separate tests by using separate ProviderContainers automatically created by ProviderScope. Shows a Flutter widget test that verifies state isolation between tests, ensuring no side effects or shared state exists. Requires Flutter test framework and Riverpod package. Inputs are testWidgets callbacks and outputs are test results verifying independent provider states.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/cookbooks/testing.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\nvoid main() {\n  testWidgets('increments counter', (tester) async {\n    await tester.pumpWidget(\n      ProviderScope(\n        child: Consumer(\n          builder: (context, ref, _) {\n            final count = ref.watch(counterProvider).state;\n            return Text(count.toString());\n          },\n        ),\n      ),\n    );\n\n    // Verify initial value\n    expect(find.text('0'), findsOneWidget);\n\n    // Tap increments the counter\n  });\n  \n  testWidgets('counter is reset between tests', (tester) async {\n    // This test shows the counterProvider state is reset as no shared state\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: AutoDispose Notifier Provider\nDESCRIPTION: Demonstrates an implementation of an unsupported AutoDisposeNotifier provider\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/unsupported_provider_value/unsupported_provider_value_lint.md#2025-04-23_snippet_8\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\n// expect_lint: unsupported_provider_value\nMyAutoDisposeNotifier autoDisposeNotifier(Ref ref) {\n  return MyAutoDisposeNotifier();\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect: Watching an autoDispose Provider from a non-autoDispose Provider (Dart)\nDESCRIPTION: This code shows an anti-pattern in Riverpod: attempting to watch an autoDispose provider (firstProvider) from a regular Provider (secondProvider). This results in a type error because an AlwaysAliveProviderBase cannot depend on an AutoDisposeProvider. To avoid resource leaks, ensure provider dependencies respect lifecycle relationships.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/modifiers/auto_dispose.mdx#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nfinal firstProvider = Provider.autoDispose((ref) => 0);\n\nfinal secondProvider = Provider((ref) {\n  // The argument type 'AutoDisposeProvider<int>' can't be assigned to the\n  // parameter type 'AlwaysAliveProviderBase<Object, Null>'\n  ref.watch(firstProvider);\n});\n```\n\n----------------------------------------\n\nTITLE: Using autoDispose with FutureProvider.family to Avoid Memory Leaks in Dart\nDESCRIPTION: This snippet defines a FutureProvider with .autoDispose.family that fetches a list of Character entities filtered by a string parameter. It illustrates the use of autoDispose to ensure the provider resources are freed when no longer used, which is important when provider parameters change frequently and to prevent memory leaks.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/de/docusaurus-plugin-content-docs/current/concepts/modifiers/family.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nfinal characters = FutureProvider.autoDispose.family<List<Character>, String>((ref, filter) async {\n  return fetchCharacters(filter: filter);\n});\n```\n\n----------------------------------------\n\nTITLE: Auto-disposing .family Provider - Dart\nDESCRIPTION: This code demonstrates the usage of `.autoDispose` with `.family` to prevent memory leaks.  It creates a `FutureProvider` that fetches a list of characters based on a filter string.  The provider is automatically disposed when it's no longer being watched, which is crucial when the parameter is frequently changing (e.g., a search filter).\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/bn/docusaurus-plugin-content-docs/current/concepts/modifiers/family.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nfinal characters = FutureProvider.autoDispose.family<List<Character>, String>((ref, filter) async {\n  return fetchCharacters(filter: filter);\n});\n```\n\n----------------------------------------\n\nTITLE: Example Output from ProviderObserver Logger in Dart\nDESCRIPTION: This snippet shows the console output when the ProviderObserver logger records a change in a counter provider, displaying the provider name and its new value in JSON format.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/provider_observer.mdx#2025-04-23_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nI/flutter (16783): {\nI/flutter (16783):   \"provider\": \"counter\",\nI/flutter (16783):   \"newValue\": \"1\"\nI/flutter (16783): }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Incorrect Ref Parameter in Dart Functional Provider\nDESCRIPTION: This snippet shows a functional provider that violates the linting rule by not having a ref parameter matching the provider name. The linter will flag this as a warning.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/functional_ref/functional_ref_lint.md#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nint nameless(\n  // expect_lint: functional_ref\n  >>>ref<<<,\n) {\n  return 0;\n```\n\n----------------------------------------\n\nTITLE: Defining a MyStateNotifier class extending StateNotifier in Dart\nDESCRIPTION: Defines a basic StateNotifier class MyStateNotifier managing MyModel state, demonstrating the core class structure necessary for state management in Riverpod.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\nclass MyModel {}\n\nclass MyStateNotifier extends StateNotifier<MyModel> {\n  MyStateNotifier(): super(MyModel());\n}\n```\n\n----------------------------------------\n\nTITLE: Using Provider with ref.watch From 0.6.0 (Dart)\nDESCRIPTION: Shows the updated pattern after Riverpod 0.6.0, where `Computed` was merged into `Provider`. A standard `Provider` now uses `ref.watch` to listen to other providers and automatically rebuilds its state when dependencies change, replacing the need for `Computed`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod/CHANGELOG.md#2025-04-23_snippet_9\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nfinal provider = Provider(...);\nfinal example = Provider((ref) {\n  final value = ref.watch(provider);\n  return value;\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Triggering Side Effects with Riverpod (Dart)\nDESCRIPTION: This snippet demonstrates how Riverpod triggers side effects using `ref.listen`, providing a way to react to provider changes and integrate well with Flutter for tasks like displaying snackbars or modals. Provider lacks a direct equivalent due to the absence of an `onChange` callback in `InheritedWidget`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/from_provider/motivation/motivation.mdx#_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nimport sideEffects from \"/docs/from_provider/motivation/side_effects\";\n```\n\n----------------------------------------\n\nTITLE: Overriding Provider Family with Provider Instance (Post-1.0.0-dev.0) in Dart\nDESCRIPTION: Illustrates the breaking change in `Family.overrideWithProvider` from Riverpod version 1.0.0-dev.0. The override function must now return a new provider instance (e.g., `Provider<State>`) instead of directly returning the state value.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/flutter_riverpod/CHANGELOG.md#2025-04-23_snippet_12\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nfinal family = Provider.family<State, Arg>(...);\n\nfamily.overrideWithProvider(\n  (Arg arg) => Provider<State>((ref) => ...)\n);\n```\n```\n\n----------------------------------------\n\nTITLE: Provider Without Comma Separator\nDESCRIPTION: Test case showing unused dependency in a provider declaration without comma separator\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/provider_dependencies/unused_dependency_lint.md#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\n// expect_lint: provider_dependencies\n@Riverpod(keepAlive: false, dependencies: [dep])\nint noDepWithoutComma(Ref ref) {\n  return 0;\n```\n\n----------------------------------------\n\nTITLE: Importing Typed Providers for Linting (Post-0.10.0) in Dart\nDESCRIPTION: Shows how to explicitly import and type provider definitions (e.g., `AutoDisposeStateProvider<int>`) when using strict type lints like `always_specify_types`. This involves importing from `flutter_riverpod/all.dart` (or later, `flutter_riverpod/flutter_riverpod.dart`) to access the implementation classes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/flutter_riverpod/CHANGELOG.md#2025-04-23_snippet_19\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nimport 'package:flutter_riverpod/all.dart';\n\nfinal AutoDisposeStateProvider<int> counter = StateProvider.autoDispose<int>((ProviderRefBase ref) {\n  return 0;\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a Dependent Weather Provider using ref.watch in Dart\nDESCRIPTION: Illustrates how to create a `weatherProvider` that depends on `cityProvider`. It uses `ref.watch(cityProvider)` to listen for changes in the city name and returns a weather string based on the current city. The provider automatically updates if `cityProvider` changes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n/// A provider that fetches the weather for the current city\nfinal weatherProvider = Provider<String>((ref) {\n  // We use `ref.watch` to listen to another provider\n  final city = ref.watch(cityProvider);\n\n  // We can then use the result to do something based on the value obtained\n  return fetchWeather(city: city);\n});\n```\n\n----------------------------------------\n\nTITLE: Obtaining ref Object from Provider in Dart\nDESCRIPTION: Demonstrates how to obtain the ref object inside a Riverpod provider in Dart. The example shows a provider that receives ref as an argument, which is then used to watch another provider. The ref object acts as a gateway to interact with other providers and manage dependencies within the provider context.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\nfinal provider = Provider((ref) {\n  // `ref` を通じて他のプロバイダを利用する\n  final repository = ref.watch(repositoryProvider);\n\n  return SomeValue(repository);\n})\n```\n\n----------------------------------------\n\nTITLE: Disabling Automatic Conversion of Stream and Future to AsyncValue\nDESCRIPTION: Shows how to prevent Riverpod from automatically converting Stream and Future into AsyncValue by wrapping the provider in a raw typedef. Used only in advanced scenarios where raw data types are preferred.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/essentials/websockets_sync.mdx#_snippet_3\n\nLANGUAGE: Dart\nCODE:\n```\n<AutoSnippet \n  raw={rawUsage} \n  translations={{\n    provider: \"  // \\\"Raw\\\"는 타입 정의입니다.\\n  // 반환값을 \\\"Raw\\\" 생성자로 래핑할 필요가 없습니다.\",\n    watch: \"    // 값이 더 이상 AsyncValue로 변환되지 않고\\n    // 생성된 스트림이 그대로 반환됩니다.\"\n  }}\n/>\n```\n\n----------------------------------------\n\nTITLE: Building a TodoItem Widget in Flutter using Dart\nDESCRIPTION: This snippet defines a simple stateless widget TodoItem that displays the label of a Todo object as a Text widget. The widget accepts a required Todo parameter and builds a Text widget showing the todo's label. It serves as a reusable UI component for individual todo items within lists.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/es/docusaurus-plugin-content-docs/current/cookbooks/testing.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nclass TodoItem extends StatelessWidget {\n  const TodoItem({Key? key, required this.todo}) : super(key: key);\n  final Todo todo;\n  @override\n  Widget build(BuildContext context) {\n    return Text(todo.label);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring StateNotifierProvider with new Dart Riverpod Syntax\nDESCRIPTION: Demonstrates the updated syntax for StateNotifierProvider introduced in Riverpod 0.14.0, where the provider takes two generic parameters: the StateNotifier type and the state type it manages. This explicit typing enhances code clarity and type safety when accessing state and notifier instances.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/tr/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nfinal provider = StateNotifierProvider<MyStateNotifier, MyModel>((ref) {\n  return MyStateNotifier();\n});\n```\n\n----------------------------------------\n\nTITLE: Replacing ref.dependOn with ref.read/ref.watch in Dart\nDESCRIPTION: Demonstrates migrating logic that previously used ref.dependOn to now using ref.watch to achieve dependency tracking in providers. This migration step eliminates a legacy API to standardize dependency reads in Riverpod 0.6.0. The key change is replacing ref.dependOn(provider).last with ref.watch(provider.last), handling asynchronous completion as Future<T>.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/hooks_riverpod/CHANGELOG.md#_snippet_24\n\nLANGUAGE: dart\nCODE:\n```\nfinal streamProvider = StreamProvider<T>(...);\nfinal example = Provider((ref) {\n  Future<T> last = ref.dependOn(streamProvider).last;\n});\n```\n\nLANGUAGE: dart\nCODE:\n```\nfinal streamProvider = StreamProvider<T>(...);\nfinal example = Provider((ref) {\n  Future<T> last = ref.watch(streamProvider.last);\n});\n```\n\n----------------------------------------\n\nTITLE: Optimizing provider update frequency by listening only to needed parts\nDESCRIPTION: Advises to avoid listening to entire objects like 'Configuration' to prevent unnecessary recomputations. Instead, creates a dedicated provider to expose only relevant properties, making dependent providers more efficient.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/es/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#_snippet_8\n\nLANGUAGE: Dart\nCODE:\n```\nfinal configsProvider = StreamProvider<Configuration>(...);\n\nfinal _hostProvider = FutureProvider<String>((ref) async {\n  final config = await ref.watch(configsProvider.future);\n  return config.host;\n});\n\nfinal productsProvider = FutureProvider<List<Product>>((ref) async {\n  final host = await ref.watch(_hostProvider.future);\n  return dio.get('$host/products');\n});\n```\n\n----------------------------------------\n\nTITLE: Building Static Content for Riverpod Website\nDESCRIPTION: Command to build the static website content which generates files in the 'build' directory ready for deployment to any static hosting service.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/README.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ yarn build\n```\n\n----------------------------------------\n\nTITLE: Shared ChangeNotifier Piping Logic in Riverpod\nDESCRIPTION: Shows how to extract and share common ChangeNotifier piping logic across multiple providers.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/websockets_sync.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nextension PipeNotifier on Ref {\n  T listenNotifier<T extends ChangeNotifier>(T notifier) {\n    onDispose(notifier.dispose);\n    notifier.addListener(notifyListeners);\n    return notifier;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Ref in Functional Providers using JavaScript/TypeScript\nDESCRIPTION: Demonstrates how to obtain the Ref object as a parameter in a functional provider to read other providers' state. This snippet depends on Riverpod's provider framework and shows that Ref allows access to lifecycle listeners and provider combination methods. The Ref parameter enables reactive and declarative state management.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/essentials/combining_requests.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\n  // \"Ref\"를 사용하여 다른 providers를 읽을 수 있습니다.\n```\n\n----------------------------------------\n\nTITLE: Accessing Providers from a Counter Class (Dart)\nDESCRIPTION: This snippet illustrates how a custom class (such as 'Counter') can receive a 'ref' to access providers. The class stores the ref, permitting provider reads within the class methods. Requires Riverpod as a dependency. Inputs include the 'ref', and outputs are managed internally by the class logic.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n// Example: Passing ref to a Counter class\nclass Counter {\n  final ProviderRef ref;\n  Counter(this.ref);\n  // Class methods can use ref.read or ref.watch here\n}\n```\n\n----------------------------------------\n\nTITLE: Limiting widget rebuilds by conditionally watching Provider in Flutter with Dart\nDESCRIPTION: This snippet demonstrates how to prevent unnecessary widget rebuilds in Flutter by utilizing Riverpod's Provider to compute UI logic externally. It uses Provider to determine whether the 'Previous' button should be enabled, updating only when relevant state changes, thus improving performance.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/providers/provider.mdx#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\n{trimSnippet(unoptimizedPreviousButton)}\n```\n\nLANGUAGE: Dart\nCODE:\n```\n{trimSnippet(optimizedPreviousButton)}\n```\n\n----------------------------------------\n\nTITLE: Reading Providers with Consumer (Provider)\nDESCRIPTION: This snippet demonstrates how to read a provider using the Consumer widget in Provider. The Consumer widget allows for granular rebuilds of specific parts of the widget tree when the provider's value changes. The builder function receives the BuildContext, the provider's value (Model), and an optional child widget.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/from_provider/provider_vs_riverpod.mdx#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nProvider<Model>(...);\n\nConsumer<Model>(\n  builder: (BuildContext context, Model model, Widget? child) {\n\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Using ConsumerWidget to Obtain ref in Flutter Dart\nDESCRIPTION: Shows how to replace a StatelessWidget with ConsumerWidget to access the ref object within the build method of a Flutter widget using Riverpod. This enables widgets to interact with providers reactively by watching provider values and rebuilding when those values change. No additional plugin dependencies beyond Riverpod are required.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\n<CodeBlock>{trimSnippet(consumerWidget)}</CodeBlock>\n```\n\n----------------------------------------\n\nTITLE: Defining Providers with Typed Refs (Post-1.0.0-dev.0) in Dart\nDESCRIPTION: Demonstrates that different provider types now receive specific subclasses of `ProviderRefBase` (e.g., `ProviderRef`, `FutureProviderRef`, `StateProviderRef`). This allows adding type-specific functionality to the `ref` object available within each provider.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/flutter_riverpod/CHANGELOG.md#2025-04-23_snippet_14\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nProvider<T>((ProviderRef<T> ref) {...});\nFutureProvider<T>((FutureProviderRef<T> ref) {...});\nStateProvider<T>((StateProviderRef<T> ref) {...});\n```\n```\n\n----------------------------------------\n\nTITLE: Running build_runner for code generation with Riverpod\nDESCRIPTION: Code snippets include commands to execute Riverpod's code generator using build_runner. For Flutter projects, use 'flutter pub run build_runner watch'; for Dart projects, use 'dart run build_runner watch'. These commands are necessary for generating boilerplate code like providers and hooks.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/Introduction/getting_started.mdx#_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\nflutter pub run build_runner watch\n# (for Flutter projects)\ndart run build_runner watch\n# (for Dart projects)\n```\n\n----------------------------------------\n\nTITLE: Applying Provider Modifiers in Dart\nDESCRIPTION: This code snippet demonstrates the use of provider modifiers. It shows how to use the `.autoDispose` modifier with a `StateProvider` and `.family` modifier with a `Provider`.  `.autoDispose` will automatically dispose of the provider's state when it's no longer in use. `.family` allows the provider to be parameterized with an external value.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/bn/docusaurus-plugin-content-docs/current/concepts/providers.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nfinal myAutoDisposeProvider = StateProvider.autoDispose<int>((ref) => 0);\nfinal myFamilyProvider = Provider.family<String, int>((ref, id) => '$id');\n```\n\n----------------------------------------\n\nTITLE: Syntax for Overriding Providers with Family Modifier\nDESCRIPTION: This snippet demonstrates the syntax required to override a Riverpod provider that uses the `family` modifier. To override a specific instance of a family provider, you first access the provider with its parameter (e.g., `myProvider('12345')`) and then call the override method (e.g., `.overrideWithValue(...)`) on that specific instance.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/cookbooks/testing.mdx#2025-04-23_snippet_6\n\nLANGUAGE: Dart\nCODE:\n```\nfinal response = ref.watch(myProvider('12345'));\n```\n\nLANGUAGE: Dart\nCODE:\n```\nmyProvider('12345').overrideWithValue(...));\n```\n\n----------------------------------------\n\nTITLE: Using Provider with Flutter in Dart to cache calculation results\nDESCRIPTION: This snippet explains how to use Riverpod's Provider for caching expensive calculations, such as filtering a Todo list, to optimize UI performance and minimize unnecessary rebuilds. It leverages ref.watch to automatically handle cache invalidation when underlying data changes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/providers/provider.mdx#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\n{trimSnippet(todo)}\n```\n\nLANGUAGE: Dart\nCODE:\n```\n{trimSnippet(completedTodos)}\n```\n\nLANGUAGE: Dart\nCODE:\n```\n{trimSnippet(todosConsumer)}\n```\n\n----------------------------------------\n\nTITLE: Using ref.readNotifier and Alternative ref.watchNotifierBuild for Efficient Updates in Dart\nDESCRIPTION: Compares ref.readNotifierBuild and ref.watchNotifierBuild usage showing how ref.watch can achieve the same effect without unnecessary widget rebuilds, supporting safe updates even when providers are refreshed elsewhere. Demonstrates recommended best practices for notifier-dependent UI.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_12\n\nLANGUAGE: Dart\nCODE:\n```\n<CodeBlock>{trimSnippet(readNotifierBuild)}</CodeBlock>\n```\n\nLANGUAGE: Dart\nCODE:\n```\n<CodeBlock>{trimSnippet(watchNotifierBuild)}</CodeBlock>\n```\n\n----------------------------------------\n\nTITLE: Implementing Home Screen with Riverpod in Flutter\nDESCRIPTION: Sets up the main application structure with MaterialApp and ProviderScope, including a home screen with a floating action button to navigate to a detail screen.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/case_studies/cancel.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nvoid main() {\n  runApp(const ProviderScope(child: MyApp()));\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(home: HomeScreen());\n  }\n}\n\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Home')),\n      body: const Center(child: Text('Press the button to fetch an activity')),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {\n          Navigator.push(\n            context,\n            MaterialPageRoute(builder: (_) => const DetailScreen()),\n          );\n        },\n        child: const Icon(Icons.refresh),\n      ),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using StateNotifierProvider (Before) in Dart\nDESCRIPTION: This code snippet demonstrates the use of `StateNotifierProvider` before the 0.14.0 update. It creates a provider for `MyStateNotifier` without specifying the state type. This is a key difference from the newer version of Riverpod. This construct requires the `riverpod` dependency.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nfinal provider = StateNotifierProvider<MyStateNotifier>((ref) {\n  return MyStateNotifier();\n});\n```\n\n----------------------------------------\n\nTITLE: Sync Function Provider\nDESCRIPTION: Example of a synchronous functional provider using code generation.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/about_code_generation.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\nint number(NumberRef ref) {\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Riverpod Provider in Dart\nDESCRIPTION: This snippet demonstrates the fundamental way to create a Riverpod provider. It declares a global final variable (`myProvider`) initialized with a `Provider`. The `Provider` takes a callback function that receives a `ref` object and returns the initial state (`MyValue()`), which is an object that never changes in this basic case. This provider can then be used to access the state elsewhere in the application. Requires the Riverpod package.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/providers.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n// Assuming MyValue is a class you've defined\nclass MyValue {}\n\nfinal myProvider = Provider((ref) {\n  return MyValue();\n});\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Riverpod Syntax Error with Abstract Class in Dart\nDESCRIPTION: This code snippet shows an incorrect implementation of a Riverpod provider class. The class is annotated with @riverpod but is also declared as abstract, which is not allowed and results in a linting error. The error message indicates that classes with @riverpod annotation cannot be abstract.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/riverpod_syntax_error/riverpod_syntax_error_lint.md#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\n// expect_lint: riverpod_syntax_error\nabstract class ExampleProvider1 extends _$ExampleProvider1 {\n  int build() => 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Hook Usage in Callback Method - Dart\nDESCRIPTION: Shows that Flutter Hooks must be called directly within the `build` method of a `HookWidget`, not inside event handlers, callbacks like `onPressed`, or any function scope other than the build method itself.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/about_hooks.mdx#_snippet_7\n\nLANGUAGE: dart\nCODE:\n```\nclass Example extends HookWidget {\n  @override\n  Widget build(BuildContext context) {\n    return ElevatedButton(\n      onPressed: () {\n        // Not _actually_ inside the \"build\" method, but instead inside\n        // a user interaction lifecycle (here \"on pressed\").\n        final controller = useAnimationController();\n      },\n      child: Text('click me'),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Code generation for ChangeNotifierProvider\nDESCRIPTION: This code snippet demonstrates the application of `@riverpod` code generation to a `ChangeNotifier` provider. It shows how to integrate the extension to wrap `ChangeNotifier` for proper disposal.  It expects the `ChangeNotifierWithCodeGenExtension` to be present in the project. It helps in enabling code generation with `ChangeNotifierProvider` during the migration.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/from_provider/quickstart.mdx#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\n// ignore_for_file: unsupported_provider_value\n@riverpod\nMyNotifier example(Ref ref) {\n  return ref.listenAndDisposeChangeNotifier(MyNotifier());\n}\n```\n\n----------------------------------------\n\nTITLE: Listening to Providers in Containers - Riverpod - Dart\nDESCRIPTION: Shows how to listen for provider state changes with ProviderContainer in Riverpod, replacing older Provider.readOwner and Provider.watchOwner APIs. Instantiates ProviderContainer, declares a provider, subscribes to updates, and shows how to clean up the listener. Requires Riverpod dependency.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/flutter_riverpod/CHANGELOG.md#2025-04-23_snippet_27\n\nLANGUAGE: dart\nCODE:\n```\nProviderContainer container;\nfinal provider = Provider((ref) => 0);\n\nfinal subscription = container.listen(\n  provider,\n  mayHaveChanged: (sub) {},\n  didChange: (sub) {}.\n);\n\nsubscription.close();\n```\n\n----------------------------------------\n\nTITLE: Gestione Automatica della Distruzione dello Stato in Riverpod\nDESCRIPTION: Spiega come Riverpod risolve il problema della distruzione dello stato non più utilizzato tramite i modificatori .autoDispose e .keepAlive. Questo permette strategie di caching flessibili, a differenza di Provider dove la gestione del ciclo di vita è manuale e complessa.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/from_provider/motivation/motivation.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\n// Code imported from /docs/from_provider/motivation/auto_dispose\n// Placeholder: Actual code snippet not provided in the input text.\n// Example demonstrating the use of .autoDispose for automatic state disposal.\n```\n\n----------------------------------------\n\nTITLE: Migrating StreamProvider Ref Read to Ref Watch - Riverpod - Dart\nDESCRIPTION: Demonstrates migration for Riverpod StreamProvider API: ref.read(StreamProvider<T>) now returns an AsyncValue<T> and you should use ref.watch to access the stream. This update impacts how you interact with streams provided by Riverpod. Requires Riverpod dependency.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/flutter_riverpod/CHANGELOG.md#2025-04-23_snippet_24\n\nLANGUAGE: dart\nCODE:\n```\nfinal streamProvider = StreamProvider<T>(...);\nfinal example = Provider((ref) {\n  Stream<T> stream = ref.read(streamProvider);\n});\n```\n\nLANGUAGE: dart\nCODE:\n```\nfinal streamProvider = StreamProvider<T>(...);\nfinal example = Provider((ref) {\n  Stream<T> stream = ref.watch(streamProvider.steam);\n});\n```\n\n----------------------------------------\n\nTITLE: Combining Provider Modifiers in Dart\nDESCRIPTION: This example showcases the combined use of provider modifiers.  It uses `.autoDispose` and `.family` together with a `FutureProvider`. This creates a `FutureProvider` that automatically disposes of itself when not in use and accepts an external parameter (`userId`) to fetch user data asynchronously.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/bn/docusaurus-plugin-content-docs/current/concepts/providers.mdx#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nfinal userProvider = FutureProvider.autoDispose.family<User, int>((ref, userId) async {\n  return fetchUser(userId);\n});\n```\n\n----------------------------------------\n\nTITLE: Combining Providers with Riverpod for Stateful Objects in Dart\nDESCRIPTION: Example showing how to combine providers using Riverpod to create a stateful provider that listens to changes in another provider using ref.listen to react to dependency changes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/from_provider/provider_vs_riverpod.mdx#_snippet_10\n\nLANGUAGE: dart\nCODE:\n```\nclass UserNotifier extends ChangeNotifier {\n  String? _userId;\n\n  void setUserId(String? userId) {\n    if (userId != _userId) {\n      print('The user ID changed from $_userId to $userId');\n      _userId = userId;\n    }\n  }\n}\n\n// ...\n\nfinal userNotifierProvider = ChangeNotifierProvider<UserNotifier>((ref) {\n  final userNotifier = UserNotifier();\n  ref.listen<UserIdNotifier>(\n    userIdNotifierProvider,\n    (previous, next) {\n      if (previous?.userId != next.userId) {\n        userNotifier.setUserId(next.userId);\n      }\n    },\n  );\n\n  return userNotifier;\n});\n```\n\n----------------------------------------\n\nTITLE: Using ref.read to Imperatively Read Provider State Without Listening in JavaScript/TypeScript\nDESCRIPTION: Shows how to read the current state of another provider imperatively using ref.read, without subscribing for updates. It emphasizes that ref.read should only be used where reactive listening is impossible, such as inside Notifier methods, but warns that use of ref.read can lead to state destruction if the provider is not listened to elsewhere. Proper understanding of reactive vs. imperative access is critical.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/essentials/combining_requests.mdx#_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\n    // Bad! 반응형이 아니므로 여기서는 'read'를 사용하지 마십시오.\n    ref.read(otherProvider); // 여기서 '읽기'를 사용해도 괜찮습니다.\n```\n\n----------------------------------------\n\nTITLE: Accessing Provider-Specific Properties via Ref - Dart\nDESCRIPTION: Describes the introduction of provider-specific `Ref` subclasses. Different provider types (Provider, FutureProvider, StateProvider) now receive specialized `ref` objects, enabling access to unique properties like `ref.state` (for `Provider`) or `ref.controller` (for `StateProvider`). Also shows replicating `ProviderReference.mounted` using `ref.onDispose`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/hooks_riverpod/CHANGELOG.md#_snippet_17\n\nLANGUAGE: Dart\nCODE:\n```\nProvider<T>((ProviderRef<T> ref) {...});\nFutureProvider<T>((FutureProviderRef<T> ref) {...});\nStateProvider<T>((StateProviderRef<T> ref) {...});\n```\n\nLANGUAGE: Dart\nCODE:\n```\nProvider<int>((ref) {\n  ref.listen(onIncrementProvider, (_) {\n    ref.state++;\n  });\n\n  return 0;\n});\n```\n\nLANGUAGE: Dart\nCODE:\n```\nStateProvider<T>((StateProviderRef<T> ref) {\n  ref.controller; // Access the StateController\n});\n```\n\nLANGUAGE: Dart\nCODE:\n```\nProvider<T>((ref) {\n  var mounted = true;\n  ref.onDispose(() => mounted = false);\n});\n```\n\n----------------------------------------\n\nTITLE: Provider Dependencies Examples\nDESCRIPTION: Examples of correct and incorrect usage of provider dependencies with the @riverpod annotation.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint/README.md#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\n// Base providers\n@riverpod\nint root(Ref ref) => 0;\n\n@Riverpod(dependencies: [])\nint scoped(Ref ref) => 0;\n\n// Good examples\n@riverpod\nint example(Ref ref) => 0;\n\n@Riverpod(dependencies: [])\nint example(Ref ref) => 0;\n\n@riverpod\nvoid example(Ref ref) {\n  ref.watch(rootProvider);\n}\n\n@Riverpod(dependencies: [scoped])\nvoid example(Ref ref) {\n  ref.watch(scopedProvider);\n}\n```\n\n----------------------------------------\n\nTITLE: Awaiting AsyncValue from StateNotifierProvider.future - Dart\nDESCRIPTION: Illustrates how to await the future result of a `StateNotifierProvider` that exposes an `AsyncValue`. Accessing `myAsyncStateNotifierProvider.future` provides a Future that resolves with the first successful `AsyncData` value emitted by the notifier.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/hooks_riverpod/CHANGELOG.md#_snippet_11\n\nLANGUAGE: Dart\nCODE:\n```\nclass MyAsyncStateNotifier extends StateNotifier<AsyncValue<MyState>> {\n  MyAsyncStateNotifier(): super(AsyncValue.loading()) {\n    // TODO fetch some data and update the state when it is obtained\n  }\n}\n\nfinal myAsyncStateNotifierProvider = StateNotifierProvider<MyAsyncStateNotifier, AsyncValue<MyState>>((ref) {\n  return MyAsyncStateNotifier();\n});\n\nfinal someFutureProvider = FutureProvider((ref) async {\n  MyState myState = await ref.watch(myAsyncStateNotifierProvider.future);\n});\n```\n\n----------------------------------------\n\nTITLE: Reading Counter Example - Dart\nDESCRIPTION: This snippet likely defines a `Counter` class that can read providers.  It uses the provided `ref` from either a `ConsumerWidget`, `ConsumerStatefulWidget` or any other mechanism to interact with other providers. It showcases a class able to read other providers using the 'ref' object.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n/* ... content of reading_counter.dart ... */\n```\n\n----------------------------------------\n\nTITLE: Example of consuming todos in UI with ChangeNotifierProvider\nDESCRIPTION: This snippet shows how to access the todo-list provider in the widget tree and interact with its data and methods. It facilitates UI updates based on the state managed by ChangeNotifierProvider, enabling user-driven modifications.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/providers/change_notifier_provider.mdx#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\n<CodeBlock>{trimSnippet(todosConsumer)}</CodeBlock>\n```\n\n----------------------------------------\n\nTITLE: Using ref.watch inside State.dispose\nDESCRIPTION: Example of a linting violation where ref.watch is used inside the dispose method of a State object. Using ref.watch during disposal can cause issues since the widget is no longer active.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/avoid_ref_inside_state_dispose/avoid_ref_inside_state_dispose_lint.md#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n    ref.read(provider);\n    // expect_lint: avoid_ref_inside_state_dispose\n    ref.watch(provider);\n\n    super.dispose();\n```\n\n----------------------------------------\n\nTITLE: Displaying Activity Initially - Dart\nDESCRIPTION: This snippet demonstrates the initial display of a fetched activity using Riverpod. It consumes the provider defined previously and shows the activity data when available. This doesn't handle loading/error states initially, displaying the data as soon as it's fetched.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/case_studies/pull_to_refresh.mdx#_snippet_2\n\nLANGUAGE: Dart\nCODE:\n```\n/* code for displayActivity not provided in the text */\n```\n\n----------------------------------------\n\nTITLE: Listening to Auto-Dispose Provider - Dart\nDESCRIPTION: This snippet shows how to use `container.listen` to listen to a provider and prevent its disposal during the test. This is crucial when using `container.read` with auto-dispose providers to avoid unexpected behavior. The snippet demonstrates an alternative to `container.read` that prevents provider disposal.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/essentials/testing.mdx#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\n      // `container.read(provider)`와 동일합니다.\n      // 그러나 \"subscription\"이 폐기(dispose)되지 않는 한 provider는 폐기되지 않습니다.\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Provider\nDESCRIPTION: This snippet demonstrates how to create a basic Provider using Riverpod. The Provider exposes a value that is computed by the provided function. The function receives a `ref` object which allows interacting with other providers. This example defines a global constant `myProvider` that exposes an instance of `MyValue`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/tr/docusaurus-plugin-content-docs/current/concepts/providers.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nfinal myProvider = Provider((ref) {\n  return MyValue();\n});\n```\n\n----------------------------------------\n\nTITLE: Displaying a List of Products in Flutter using Riverpod\nDESCRIPTION: Demonstrates how a Flutter widget (`ProductsListView`) can use `ref.watch` to listen to a `productsProvider` (defined elsewhere) and display the list of products in a `ListView`. Each product is shown in a `ListTile`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/providers/state_provider.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nclass ProductsListView extends ConsumerWidget {\n  const ProductsListView({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final products = ref.watch(productsProvider);\n    return ListView(\n      children: [\n        for (final product in products)\n          ListTile(\n            title: Text(product.name),\n            subtitle: Text('\\${product.price}'),\n          ),\n      ],\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing StateNotifierProvider Without State Generic in Dart (Riverpod ^0.13.0)\nDESCRIPTION: Illustrates the older syntax for creating a StateNotifierProvider without specifying the state type as a generic parameter. The provider exposes a StateNotifier of type MyStateNotifier and initializes it through a provider function. This pattern is deprecated as of Riverpod 0.14.0.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nfinal provider = StateNotifierProvider<MyStateNotifier>((ref) {\n  return MyStateNotifier();\n});\n```\n\n----------------------------------------\n\nTITLE: Migrating from AutoDisposeStateNotifierProviderFamily Syntax in Dart\nDESCRIPTION: Shows how to change provider initialization from the older AutoDisposeStateNotifierProviderFamily constructor to the new StateNotifierProvider.autoDispose.family constructor, as per Riverpod 0.4.0. Both approaches support family arguments and auto-dispose, but the after syntax is more concise and aligns with Dart idioms.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/hooks_riverpod/CHANGELOG.md#_snippet_26\n\nLANGUAGE: dart\nCODE:\n```\nfinal myProvider = AutoDisposeStateNotifierProviderFamily<MyStateNotifier, int>((ref, id) {\n  return MyStateNotifier(id: id);\n});\n```\n\nLANGUAGE: dart\nCODE:\n```\nfinal myProvider = StateNotifierProvider.autoDispose.family<MyStateNotifier, int>((ref, id) {\n  return MyStateNotifier(id: id);\n});\n```\n\n----------------------------------------\n\nTITLE: Migrating to NotifierProvider from ChangeNotifierProvider (Dart)\nDESCRIPTION: Illustrates the final step of migrating a ChangeNotifier to a fully Riverpod-native Notifier. This involves replacing the ChangeNotifier with a Notifier and updating the provider definition accordingly. Each context.watch should also be updated to ref.watch to access the provider.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/from_provider/quickstart.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nclass MyNotifier extends Notifier<int> {\n  @override\n  int build() => 0;\n\n  void increment() => state++;\n}\n\nfinal myNotifierProvider = NotifierProvider<MyNotifier, int>(MyNotifier.new);\n```\n\n----------------------------------------\n\nTITLE: Enabling Automatic Disposal for Providers - Riverpod/Dart\nDESCRIPTION: This code shows how to enable automatic state disposal for a provider when not using Riverpod's code generation. By using the `.autoDispose` modifier on the provider definition, the state will be destroyed if the provider has no active listeners for a full frame.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/essentials/auto_dispose.mdx#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\nfinal autoDisposeExampleProvider = Provider.autoDispose((ref) {\n  // The state will be disposed when no-longer used\n});\n```\n\n----------------------------------------\n\nTITLE: Accessing State from StateNotifierProvider Without .state in Dart (Riverpod ^0.13.0)\nDESCRIPTION: Shows how the state was accessed by watching provider.state in the widget build method in versions of Riverpod before 0.14.0. This pattern is outdated and replaced with direct provider access.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, ScopedReader watch) {\n  MyModel state = watch(provider.state);\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing StateNotifierProvider With State Generic in Dart (Riverpod ^0.14.0)\nDESCRIPTION: Shows the updated Riverpod 0.14.0 syntax for StateNotifierProvider which now requires an additional generic parameter specifying the state type (MyModel). This allows better type inference and updated provider usage patterns.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nfinal provider = StateNotifierProvider<MyStateNotifier, MyModel>((ref) {\n  return MyStateNotifier();\n});\n```\n\n----------------------------------------\n\nTITLE: Migrating AsyncNotifierProvider from Manual to Generated Class in Dart\nDESCRIPTION: This snippet presents transitioning an AsyncNotifierProvider to a code-generated notifier class, simplifying the codebase and improving type safety.\nDependencies include Riverpod's async notifier system and Dart's class structures.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/about_code_generation.mdx#_snippet_10\n\nLANGUAGE: dart\nCODE:\n```\n{trimSnippet(asyncNotifierProvider)}\n```\n\n----------------------------------------\n\nTITLE: Consuming Riverpod Provider in Flutter UI\nDESCRIPTION: This snippet shows how to consume a Riverpod provider in a Flutter widget using ConsumerWidget. It demonstrates pattern matching on the AsyncValue to handle different states (loading, error, data) of the asynchronous operation.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/README.md#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nclass Home extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final boredSuggestion = ref.watch(boredSuggestionProvider);\n    // Perform a switch-case on the result to handle loading/error states\n    return switch (boredSuggestion) {\n      AsyncData(:final value) => Text('data: $value'),\n      AsyncError(:final error) => Text('error: $error'),\n      _ => const Text('loading'),\n    };\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Identifying Missing Dependencies in Nested Provider Scopes (Dart)\nDESCRIPTION: This snippet shows the lint detecting missing dependencies in a ConsumerWidget with nested ProviderScopes. It uses both 'DepFamily' and 'DepWidget' but doesn't declare the dependencies.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/provider_dependencies/missing_dependencies_lint.md#2025-04-23_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\n// expect_lint: provider_dependencies\nclass SupportsMultipleScopes2 extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    ProviderScope(\n      overrides: [depProvider.overrideWith((ref) => 0)],\n      child: DepFamily(),\n    );\n\n    return ProviderScope(\n      overrides: [depFamilyProvider.overrideWith((ref, arg) => 0)],\n      child: DepWidget(),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating to code-generated Notifier (Dart)\nDESCRIPTION: Demonstrates the final step of migrating a ChangeNotifier to a code-generated Notifier using the @riverpod annotation. This involves extending _$MyNotifier and overriding the build method.  This showcases how to fully leverage Riverpod's code generation capabilities after migrating from ChangeNotifier.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/from_provider/quickstart.mdx#_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\nclass MyNotifier extends _$MyNotifier {\n  @override\n  int build() => 0;\n\n  void increment() => state++;\n}\n```\n\n----------------------------------------\n\nTITLE: Explicitly Typing AutoDispose Provider (Dart)\nDESCRIPTION: Illustrates how to explicitly type a provider with an `autoDispose` modifier, such as `AutoDisposeStateProvider`, when using the `always_specify_types` lint. This involves importing implementation classes from `package:riverpod/all.dart` (though `riverpod/riverpod.dart` is now preferred).\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod/CHANGELOG.md#2025-04-23_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nimport 'package:riverpod/all.dart';\n\nfinal AutoDisposeStateProvider<int> counter = StateProvider.autoDispose<int>((ProviderRefBase ref) {\n  return 0;\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Utilizzo di ref.watch con providers asincroni in Dart\nDESCRIPTION: Mostra come usare ref.watch con provider asincroni utilizzando `.future` per attendere valori iniziali. Evita di ricevere AsyncValue inutili e facilita l'uso di dati asincroni come la posizione dell'utente, che potrebbero non essere immediatamente disponibili.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/essentials/combining_requests.mdx#_snippet_3\n\nLANGUAGE: Dart\nCODE:\n```\n<AutoSnippet {...watchExample} />\n```\n\n----------------------------------------\n\nTITLE: Using ref.listen in a Widget's build Method in Dart with Riverpod\nDESCRIPTION: This snippet demonstrates how to use ref.listen within a widget's build method to perform actions when a provider's state changes. It shows a snackbar when an error occurs in the repository provider.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/de/docusaurus-plugin-content-docs/current/concepts/reading.mdx#2025-04-23_snippet_8\n\nLANGUAGE: dart\nCODE:\n```\n@override\nWidget build(BuildContext context, WidgetRef ref) {\n  ref.listen<AsyncValue<User>>(\n    userProvider,\n    (_, next) {\n      if (next.hasError) {\n        showDialog(\n          context: context,\n          builder: (context) {\n            return AlertDialog(\n              title: Text('Error'),\n              content: Text(next.error.toString()),\n            );\n          },\n        );\n      }\n    },\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching Activity with Provider - Dart\nDESCRIPTION: This snippet defines a Riverpod provider that fetches a single activity from an external API. It utilizes an HTTP GET request. The provider handles the API call and provides access to the retrieved data.  It is a key dependency for the application's functionality.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/case_studies/pull_to_refresh.mdx#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\n/* code for fetchActivity not provided in the text */\n```\n\n----------------------------------------\n\nTITLE: Using ConsumerWidget to Read Riverpod Provider (Flutter)\nDESCRIPTION: This snippet shows how to use a `ConsumerWidget` to read the state of a Riverpod provider, offering a cleaner syntax compared to using `Consumer`. `ConsumerWidget` is a fusion of `StatelessWidget` and `Consumer`, providing direct access to the `ref` object.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/essentials/first_request.mdx#_snippet_4\n\nLANGUAGE: Flutter\nCODE:\n```\n<AutoSnippet {...consumerWidget} />\n```\n\n----------------------------------------\n\nTITLE: Testing Provider Lifecycle Events in Dart with Riverpod\nDESCRIPTION: A code snippet demonstrating how to use lifecycle methods in Riverpod to detect when a provider is no longer being listened to and when it's disposed. Use ref.onCancel to detect when listeners stop and ref.onDispose to detect when the provider is destroyed.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/from_provider/provider_vs_riverpod.mdx#_snippet_11\n\nLANGUAGE: dart\nCODE:\n```\nref.onCancel((){\n  print(\"더 이상 어떤 것도 나를 Listen하지 않음!\");\n});\nref.onDispose((){\n  print(\"`.autoDispose`로 정의된 경우, 방금 폐기되었음!\");\n});\n```\n\n----------------------------------------\n\nTITLE: Combining Multiple Riverpod Provider Modifiers in Dart\nDESCRIPTION: Illustrates that multiple provider modifiers can be chained together. This example combines `.autoDispose` and `.family` on a `FutureProvider` to create a provider that fetches a `User` based on a `userId`, and automatically disposes its state when not in use.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/providers.mdx#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nfinal userProvider = FutureProvider.autoDispose.family<User, int>((ref, userId) async {\n  return fetchUser(userId);\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Avoiding Provider Initialization in Widgets (Anti-pattern)\nDESCRIPTION: This example demonstrates an anti-pattern where a provider is incorrectly initialized inside a widget's initState method. Providers should self-initialize rather than being initialized by external components like widgets to avoid race conditions.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/essentials/do_dont.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nclass WidgetState extends State<MyWidget> {\n  @override\n  void initState() {\n    super.initState();\n    // Sbagliato: il provider dovrebbe inizializzarsi da solo\n    ref.read(provider).init();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Provider Modifiers\nDESCRIPTION: This snippet shows examples of using provider modifiers, specifically `.autoDispose` and `.family`. `autoDispose` automatically disposes the provider's state when it's no longer listened to.  `family` allows creating provider instances with external parameters.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/tr/docusaurus-plugin-content-docs/current/concepts/providers.mdx#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nfinal myAutoDisposeProvider = StateProvider.autoDispose<String>((ref) => 0);\nfinal myFamilyProvider = Provider.family<String, int>((ref, id) => '$id');\n```\n\n----------------------------------------\n\nTITLE: Overriding Provider in Deeply Nested ProviderScope\nDESCRIPTION: This snippet shows an override of a provider in a deeply nested ProviderScope, which should trigger the lint warning for not specifying dependencies in a non-root context.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/scoped_providers_should_specify_dependencies/scoped_providers_should_specify_dependencies_lint.md#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nrootProvider.overrideWith((ref) => 0)\n```\n\n----------------------------------------\n\nTITLE: Defining and Watching StateNotifierProvider (Pre-0.14.0) in Dart\nDESCRIPTION: Shows the older syntax for defining a `StateNotifierProvider` and accessing its notifier and state before Riverpod version 0.14.0. It required specifying only the notifier type in `StateNotifierProvider` and accessing the state via `provider.state`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/flutter_riverpod/CHANGELOG.md#2025-04-23_snippet_17\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nclass MyStateNotifier extends StateNotifier<MyModel> {...}\n\nfinal provider = StateNotifierProvider<MyStateNotifier>((ref) => MyStateNotifier());\n\n...\nWidget build(context, watch) {\n  MyStateNotifier notifier = watch(provider);\n  MyModel model = watch(provider.state);\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Creating FutureProvider with .family - Dart\nDESCRIPTION: This code snippet demonstrates how to create a `FutureProvider` using the `.family` modifier.  It fetches a `Message` object from an API based on an ID passed as a parameter to the provider. The `dio` object is assumed to be an HTTP client.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/bn/docusaurus-plugin-content-docs/current/concepts/modifiers/family.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nfinal messagesFamily = FutureProvider.family<Message, String>((ref, id) async {\n  return dio.get('http://my_api.dev/messages/$id');\n});\n```\n\n----------------------------------------\n\nTITLE: Converting ChangeNotifier to ChangeNotifierProvider\nDESCRIPTION: This snippet shows how to adapt a `ChangeNotifier` class to be used with `ChangeNotifierProvider`.  It's a direct method to migrate existing code using `Provider`'s `ChangeNotifierProvider`.  The prerequisite is a `ChangeNotifier` class.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/from_provider/quickstart.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nclass MyNotifier extends ChangeNotifier {\n  int state = 0;\n\n  void increment() {\n    state++;\n    notifyListeners();\n  }\n}\n\nfinal myNotifierProvider = ChangeNotifierProvider<MyNotifier>((ref) {\n  return MyNotifier();\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Network Request with Riverpod\nDESCRIPTION: This snippet demonstrates how to define a network request using Riverpod's @riverpod annotation. It fetches a random activity suggestion from the Bored API and parses the JSON response to return the activity string.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/README.md#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\nFuture<String> boredSuggestion(Ref ref) async {\n  final response = await http.get(\n    Uri.https('boredapi.com', '/api/activity'),\n  );\n  final json = jsonDecode(response.body);\n  return json['activity']! as String;\n}\n```\n\n----------------------------------------\n\nTITLE: Running Riverpod Migration Command (Shell)\nDESCRIPTION: Shows how to initiate automatic migration of a Dart Riverpod project using the riverpod_cli tool. Requires a clean project workspace and the CLI tool installed globally. Will suggest code changes and may prompt user input.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#2025-04-23_snippet_9\n\nLANGUAGE: sh\nCODE:\n```\nriverpod migrate\n```\n\n----------------------------------------\n\nTITLE: Request Debouncing Implementation in Riverpod\nDESCRIPTION: Shows how to implement request debouncing by delaying requests and cancelling them if new requests come in before the delay period ends.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/case_studies/cancel.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\nFuture<Activity> activity(ActivityRef ref) async {\n  final completer = Completer<void>();\n  ref.onDispose(completer.complete);\n\n  try {\n    await Future.delayed(const Duration(milliseconds: 500));\n    await completer.future;\n  } catch (_) {\n    // The request was cancelled\n    throw Exception('cancelled');\n  }\n\n  final response = await http.get(\n    Uri.https('www.boredapi.com', '/api/activity'),\n  );\n  return Activity.fromJson(\n    jsonDecode(response.body) as Map<String, Object?>,\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Watching State (After) in Dart\nDESCRIPTION: This shows how to watch the state of a `StateNotifier` after the 0.14.0 update. It uses `watch(provider)` to observe the state (MyModel). It relies on `riverpod`, `BuildContext`, and `ScopedReader`.  The output is the `MyModel` state.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, ScopedReader watch) {\n  MyModel state = watch(provider);\n}\n```\n\n----------------------------------------\n\nTITLE: Sovrascrittura di Provider per il Testing in Riverpod\nDESCRIPTION: Illustra come Riverpod semplifichi il testing permettendo di sovrascrivere facilmente i provider all'interno dei test. Questo esempio mostra come fornire valori o implementazioni mockate per testare la logica che dipende da altri provider.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/from_provider/motivation/motivation.mdx#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\n// Code imported from /docs/from_provider/motivation/override\n// Placeholder: Actual code snippet not provided in the input text.\n// Example demonstrating how to override providers in tests.\n```\n\n----------------------------------------\n\nTITLE: FutureProvider.autoDispose.family for search input (Dart)\nDESCRIPTION: This snippet shows the usage of `.autoDispose` with `.family` to prevent memory leaks when using frequently changing input values like search fields. `fetchCharacters` function is assumed to be defined elsewhere.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/modifiers/family.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nfinal characters = FutureProvider.autoDispose.family<List<Character>, String>((ref, filter) async {\n  return fetchCharacters(filter: filter);\n});\n```\n\n----------------------------------------\n\nTITLE: Combining autoDispose with family to parameterize provider\nDESCRIPTION: This snippet shows how to extend autoDispose by using the 'family' modifier, allowing the provider to accept parameters such as an ID, while ensuring it disposes correctly when no longer needed.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/tr/docusaurus-plugin-content-docs/current/concepts/modifiers/auto_dispose.mdx#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\nfinal userProvider = StreamProvider.autoDispose.family<User, String>((ref, id) {\n\n});\n```\n\n----------------------------------------\n\nTITLE: Synchronously Reading User State with StreamProvider\nDESCRIPTION: Example showing how to synchronously read and handle different states from a StreamProvider using ref.watch. Demonstrates handling AsyncValue states including data, error and loading.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/reading.mdx#2025-04-23_snippet_12\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, WidgetRef ref) {\n  AsyncValue<User> user = ref.watch(userProvider);\n\n  return switch (user) {\n    AsyncData(:final value) => Text(value.name),\n    AsyncError(:final error) => const Text('Oops $error'),\n    _ => const CircularProgressIndicator(),\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Riverpod Provider Class in Dart\nDESCRIPTION: This snippet demonstrates an incorrect implementation of a Riverpod provider class. The class is annotated with @riverpod but lacks the required 'build' method, which triggers a linting error. This example serves to highlight the necessity of including the 'build' method in Riverpod provider classes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/notifier_build/notifier_build_lint.md#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\n// expect_lint: notifier_build\nclass ExampleProvider1 extends _$ExampleProvider1 {}\n\n@riverpod\n```\n\n----------------------------------------\n\nTITLE: Detecting BuildContext in Provider Event Method (Dart)\nDESCRIPTION: This snippet demonstrates an event method in a provider class where BuildContext is passed as both a positional and named parameter. Both instances are flagged by the linter as violations of the 'avoid_build_context_in_providers' rule.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/avoid_build_context_in_providers/avoid_build_context_in_providers_lint.md#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\n  void event(\n    // expect_lint: avoid_build_context_in_providers\n    BuildContext context3, {\n    // expect_lint: avoid_build_context_in_providers\n    required BuildContext context4,\n\n```\n\n----------------------------------------\n\nTITLE: provider 강제 삭제 (invalidate) - Dart\nDESCRIPTION: ref.invalidate를 사용하여 특정 provider의 상태를 수동으로 삭제하는 방법을 예시로 보여줍니다. 무효화 후, provider를 계속 청취하는 경우 새 상태가 생성되고, 그렇지 않으면 완전히 소멸됩니다. dependencies: Riverpod, Dart.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/essentials/auto_dispose.mdx#_snippet_3\n\nLANGUAGE: Dart\nCODE:\n```\n```dart\n// 클릭 시 provider를 파괴(destroy)합니다.\nref.invalidate();\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing a 'mounted' Flag using ref.onDispose in Dart\nDESCRIPTION: Provides a pattern to replicate the behavior of the removed `ProviderReference.mounted` property (as of Riverpod 1.0.0-dev.0). It uses `ref.onDispose` to set a boolean flag (`mounted`) to false when the provider is disposed.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/flutter_riverpod/CHANGELOG.md#2025-04-23_snippet_16\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nProvider<T>((ref) {\n  var mounted = true;\n  ref.onDispose(() => mounted = false);\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Mock Implementation for a Provider - Dart\nDESCRIPTION: This snippet provides an example of a Mock implementation for a given provider. It defines a `MyMock` class extending `MyClass`, allowing for the replacement of the real provider with a controlled mock during testing. Dependencies: Riverpod, Mockito or other mocking libraries.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/essentials/testing.mdx#_snippet_7\n\nLANGUAGE: Dart\nCODE:\n```\nclass MyMock extends MyClass {}\n```\n\n----------------------------------------\n\nTITLE: Example of Dart and Flutter tests demonstrating provider isolation\nDESCRIPTION: This snippet showcases how tests using Riverpod's ProviderContainer or ProviderScope maintain isolated provider states, preventing shared global state between tests, thereby simplifying test setup and teardown.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/de/docusaurus-plugin-content-docs/current/cookbooks/testing.mdx#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\n/* Dart-only test example using ProviderContainer for isolated provider state */\n// Example code demonstrating test setup with ProviderContainer\n```\n\nLANGUAGE: Flutter\nCODE:\n```\n/* Flutter widget test example using ProviderScope for isolated provider state */\n// Example code demonstrating test setup with ProviderScope\n```\n\n----------------------------------------\n\nTITLE: Using ref.listen in Widget build Method for Provider Change Reactions in Dart\nDESCRIPTION: Demonstrates usage of ref.listen within a widget’s build method to observe provider value changes and trigger side effects via callbacks, while avoiding improper usage in asynchronous or lifecycle methods.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_9\n\nLANGUAGE: Dart\nCODE:\n```\n<CodeBlock>{trimSnippet(listenBuild)}</CodeBlock>\n```\n\n----------------------------------------\n\nTITLE: Installing Riverpod CLI Migration Tool (Shell)\nDESCRIPTION: Provides the shell command to globally activate the riverpod_cli tool via Dart's pub package manager. Requires Dart SDK to be installed. This enables invoking riverpod migration utilities for project upgrades.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#2025-04-23_snippet_7\n\nLANGUAGE: sh\nCODE:\n```\ndart pub global activate riverpod_cli\n```\n\n----------------------------------------\n\nTITLE: Installing Riverpod in Flutter using pubspec.yaml\nDESCRIPTION: This snippet demonstrates how to manually add the 'flutter_riverpod' dependency to the project's pubspec.yaml file for Flutter projects, followed by running 'flutter pub get' to install it.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/introduction/getting_started.mdx#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\npubspec:\n  dependencies:\n    flutter_riverpod: ^X.Y.Z  # specify the desired version\n```\n\n----------------------------------------\n\nTITLE: FutureProvider with .family example (Dart)\nDESCRIPTION: This code snippet demonstrates how to use `FutureProvider.family` to fetch a `Message` based on an ID.  It uses a dio client to make an HTTP request. Requires the dio package to be installed.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/modifiers/family.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nfinal messagesFamily = FutureProvider.family<Message, String>((ref, id) async {\n  return dio.get('http://my_api.dev/messages/$id');\n});\n```\n\n----------------------------------------\n\nTITLE: Linting keepAlive Provider Usage in Dart with Riverpod\nDESCRIPTION: This code snippet demonstrates the linting rule for keepAlive providers in Riverpod. It shows examples of incorrect usage where a keepAlive provider watches auto-dispose providers, which triggers the lint warning.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/only_use_keep_alive_inside_keep_alive/only_use_keep_alive_inside_keep_alive_lint.md#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n  // expect_lint: only_use_keep_alive_inside_keep_alive\n  >>>ref.watch(autoDisposeProvider)<<<;\n  // expect_lint: only_use_keep_alive_inside_keep_alive\n  ref.watch(autoDisposeClassProvider);\n```\n\nLANGUAGE: dart\nCODE:\n```\n  ref.watch(autoDisposeProvider);\n  // expect_lint: only_use_keep_alive_inside_keep_alive\n  >>>ref.watch(autoDisposeClassProvider)<<<;\n\n  return 0;\n```\n\n----------------------------------------\n\nTITLE: Updating documentation code after translation work with dart build_runner\nDESCRIPTION: This command runs the Dart build runner in watch mode with conflict resolution, updating generated code based on recent translation or code changes. It supports maintaining consistency across generated Dart files.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/NOTE.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n# 작업후 문서의 생성코드 업데이트\ndart run build_runner watch --delete-conflicting-outputs\n```\n\n----------------------------------------\n\nTITLE: Combining HookWidget with ConsumerWidget using HookConsumerWidget\nDESCRIPTION: Example showing how to use HookConsumerWidget to combine flutter_hooks functionality with Riverpod's provider access. This allows using both hooks and providers in the same widget without nesting issues.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/essentials/first_request.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet {...hookConsumerWidget} />\n```\n\n----------------------------------------\n\nTITLE: Using StateController.update Method - Dart\nDESCRIPTION: Shows the new `update` method available on `StateController`. This method simplifies updating the state based on its current value, commonly used for incrementing or modifying the state functionally.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/hooks_riverpod/CHANGELOG.md#_snippet_19\n\nLANGUAGE: Dart\nCODE:\n```\nfinal provider = StateController((ref) => 0);\n...\nref.read(provider).update((state) => state + 1);\n```\n\n----------------------------------------\n\nTITLE: Extracting Reusable Hook Logic into a Custom Hook Function\nDESCRIPTION: A demonstration of how hook logic can be refactored into a separate reusable function called useFadeIn(), which encapsulates the animation controller creation, initialization, and usage.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/about_hooks.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\ndouble useFadeIn() {\n  final animationController = useAnimationController(\n    duration: const Duration(seconds: 2),\n  );\n  useEffect(() {\n    animationController.forward();\n    return null;\n  }, const []);\n  useAnimation(animationController);\n  return animationController.value;\n}\n```\n\n----------------------------------------\n\nTITLE: Consumer Hook Example - Dart\nDESCRIPTION: Demonstrates the use of `Consumer` or `HookConsumer` inside the widget to get the `ref`. The `Consumer` and `HookConsumer` widgets allow access to the ref object within a builder function, providing a way to interact with providers inline.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\n/* ... content of reading_consumer_hook.dart ... */\n```\n\n----------------------------------------\n\nTITLE: Correct usage of ref.watch with notifier in Dart with Riverpod\nDESCRIPTION: Shows the proper approach to watching a provider's notifier in a build method, which avoids unnecessary rebuilds while maintaining reactivity to controller changes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/tr/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_12\n\nLANGUAGE: dart\nCODE:\n```\nfinal counterProvider = StateProvider((ref) => 0);\n\nWidget build(BuildContext context, WidgetRef ref) {\n  StateController<int> counter = ref.watch(counterProvider.notifier);\n  return ElevatedButton(\n    onPressed: () => counter.state++,\n    child: const Text('button'),\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Detecting BuildContext in Provider Parameters (Dart)\nDESCRIPTION: This snippet shows a provider function where BuildContext is passed as both a positional and named parameter. The linter flags both instances as violations of the 'avoid_build_context_in_providers' rule.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/avoid_build_context_in_providers/avoid_build_context_in_providers_lint.md#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n  Ref ref,\n  // expect_lint: avoid_build_context_in_providers\n  BuildContext context1, {\n  // expect_lint: avoid_build_context_in_providers\n  required BuildContext context2,\n\n```\n\n----------------------------------------\n\nTITLE: Linting Incorrectly Typed Ref Parameter in Riverpod Functional Provider (Dart)\nDESCRIPTION: This example demonstrates a functional provider with an incorrectly typed 'ref' parameter. The linter flags this as an error, emphasizing that the 'ref' parameter must have the correct type matching the provider name.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/functional_ref/failing_functional_ref_lint.md#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nint incorrectlyTyped(\n  // expect_lint: functional_ref\n  int ref,\n) {\n  return 0;\n```\n\n----------------------------------------\n\nTITLE: Defining Providers with Provider Package in Dart\nDESCRIPTION: This snippet demonstrates how to define providers using the Provider package. It shows the creation of a Counter class and its integration within a MultiProvider widget.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/from_provider/provider_vs_riverpod.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nclass Counter extends ChangeNotifier {\n ...\n}\n\nvoid main() {\n  runApp(\n    MultiProvider(\n      providers: [\n        ChangeNotifierProvider<Counter>(create: (context) => Counter()),\n      ],\n      child: MyApp(),\n    )\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating FutureProvider Ref Read to Ref Watch - Riverpod - Dart\nDESCRIPTION: Shows changes required for working with FutureProvider<T> in Riverpod: ref.read(FutureProvider<T>) is replaced with ref.watch(futureProvider.future). Ensures compatibility with new API. Requires Riverpod dependency.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/flutter_riverpod/CHANGELOG.md#2025-04-23_snippet_25\n\nLANGUAGE: dart\nCODE:\n```\nfinal futureProvider = FutureProvider<T>(...);\nfinal example = Provider((ref) {\n  Future<T> future = ref.read(futureProvider);\n});\n```\n\nLANGUAGE: dart\nCODE:\n```\nfinal futureProvider = FutureProvider<T>(...);\nfinal example = Provider((ref) {\n  Future<T> future = ref.watch(futureProvider.future);\n});\n```\n\n----------------------------------------\n\nTITLE: Fetching data with a provider that automatically re-fetches in Dart\nDESCRIPTION: An auto-generated snippet showing the use of a provider, such as charactersProvider, to fetch data and automatically re-fetch upon configuration or input changes. Useful for live search features.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet language=\"dart\" {...charactersProvider}></AutoSnippet>\n```\n\n----------------------------------------\n\nTITLE: Implementing Remote Todos with AsyncNotifierProvider in Dart\nDESCRIPTION: This example shows how to use AsyncNotifierProvider to implement a remote todo-list. It demonstrates creating an AsyncNotifier that can be asynchronously initialized, which is useful for fetching data from a remote source.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/providers/notifier_provider.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n// This code is referenced via an import and not directly shown in the text\n```\n\n----------------------------------------\n\nTITLE: Defining Provider Dependencies for Automatic Override - Dart\nDESCRIPTION: Introduces the optional `dependencies` parameter for providers. This allows explicitly listing providers or families that a provider depends on, enabling Riverpod to automatically override the dependent provider when a dependency is overridden.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/hooks_riverpod/CHANGELOG.md#_snippet_18\n\nLANGUAGE: Dart\nCODE:\n```\nfinal a = Provider(...);\n\nfinal b = Provider((ref) => ref.watch(a), dependencies: [a]);\n```\n\n----------------------------------------\n\nTITLE: Building the Example App with Code Generation\nDESCRIPTION: These commands navigate to the examples/pub directory, fetch dependencies, and run the build_runner to generate code. The -d flag enables debug output during the build process.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/examples/pub/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd examples/pub\nflutter pub get\ndart run build_runner build -d\n```\n\n----------------------------------------\n\nTITLE: Initializing Korean i18n folder with yarn in Docusaurus\nDESCRIPTION: This shell script command initializes Korean translation files for a Docusaurus project by generating the necessary i18n folder structure. It ensures Korean translations are set up for further editing or deployment.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/NOTE.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n# 처음에 한국어 i18n 생성하기 (docusaurus)\nyarn run write-translations --locale ko\n```\n\n----------------------------------------\n\nTITLE: Defining Product Model in Dart\nDESCRIPTION: Defines a basic Product class with name and price properties along with a list of sample products.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/providers/state_provider.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nclass Product {\n  Product({required this.name, required this.price});\n\n  final String name;\n  final double price;\n}\n```\n\n----------------------------------------\n\nTITLE: Reading Providers with Riverpod Package using WidgetRef in Dart\nDESCRIPTION: Example showing how to read a provider using Riverpod with WidgetRef, using the ref.watch method inside a ConsumerWidget instead of the StatelessWidget approach used in Provider.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/from_provider/provider_vs_riverpod.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nfinal modelProvider = Provider<Model>(...);\n\nclass Example extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    Model model = ref.watch(modelProvider);\n\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Incomplete Generic Type Extension in Riverpod Class (Dart)\nDESCRIPTION: This example demonstrates a Riverpod class declaration where the extension is missing one of the generic type parameters. The class MissingGenerics<A, B> extends _$MissingGenerics<A>, but it should include both A and B.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/notifier_extends/notifier_extends_lint.md#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\n// expect_lint: notifier_extends\nclass MissingGenerics<A, B> extends _$MissingGenerics<A> {\n  int build() => 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Unit Test Setup - Dart\nDESCRIPTION: This snippet demonstrates setting up a unit test for Riverpod providers. It creates a `ProviderContainer` to interact with providers and explains how to read and listen to providers within the test environment.  Dependencies include `package:test` and Riverpod.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/essentials/testing.mdx#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\nfinal container = ProviderContainer();\n\ntest('...', () {\n  // ...\n});\n```\n\n----------------------------------------\n\nTITLE: Using ref.listen for Provider Notifications in Dart\nDESCRIPTION: Demonstrates how to use ref.listen to replace the deprecated ProviderListener. This method allows for listening to changes in a provider and executing a callback when changes occur.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/flutter_riverpod/CHANGELOG.md#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nclass Example extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    ref.listen<int>(counter, (count) {\n      print('count changed $count');\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: StateProvider Example - Dart\nDESCRIPTION: This code snippet shows how to access the state of a `StateProvider` before and after migration. It shows the difference in how to use `ref.watch` to retrieve the state and update the state.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/migration/0.14.0_to_1.0.0.mdx#_snippet_7\n\nLANGUAGE: dart\nCODE:\n```\nfinal provider = StateProvider<int>(...);\n\nConsumer(\n  builder: (context, ref, child) {\n    StateController<int> count = ref.watch(provider);\n\n    return Text('${count.state}');\n  }\n)\n```\n\nLANGUAGE: dart\nCODE:\n```\nfinal provider = StateProvider<int>(...);\n\nConsumer(\n  builder: (context, ref, child) {\n    int count = ref.watch(provider);\n\n    return Text('${count}');\n  }\n)\n```\n\nLANGUAGE: dart\nCODE:\n```\nfinal provider = StateProvider<int>(...);\n\nConsumer(\n  builder: (context, ref, child) {\n    StateController<int> count = ref.watch(provider.state);\n\n    return Text('${count.state}');\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Combining Providers with ProxyProvider in Provider Package (Dart)\nDESCRIPTION: This snippet demonstrates how to combine providers using ProxyProvider in the Provider package, creating a new provider based on UserIdNotifier.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/from_provider/provider_vs_riverpod.mdx#2025-04-23_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\nclass UserIdNotifier extends ChangeNotifier {\n  String? userId;\n}\n\n// ...\n\nChangeNotifierProvider<UserIdNotifier>(create: (context) => UserIdNotifier()),\n\n// ...\n\nProxyProvider<UserIdNotifier, String>(\n  update: (context, userIdNotifier, _) {\n    return 'The user ID of the the user is ${userIdNotifier.userId}';\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Widget Build Before Migration - Dart\nDESCRIPTION: This code snippet demonstrates the old syntax for the `build` method in a `ConsumerWidget` where `watch` is used.  This shows the `watch` method which is going to be replaced.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/migration/0.14.0_to_1.0.0.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\n-Widget build(BuildContext context, ScopedReader watch) {\n+Widget build(BuildContext context, Widget ref) {\n-  MyModel state = watch(provider);\n+  MyModel state = ref.watch(provider);\n}\n```\n\n----------------------------------------\n\nTITLE: Combining .autoDispose and .family Modifiers in Dart\nDESCRIPTION: Shows how to use the `.autoDispose` modifier in conjunction with the `.family` modifier on a `StreamProvider`. This allows creating providers that are both automatically disposed and accept parameters.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/concepts/modifiers/auto_dispose.mdx#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\nfinal userProvider = StreamProvider.autoDispose.family<User, String>((ref, id) {\n\n});\n```\n\n----------------------------------------\n\nTITLE: Using ref.read in an Event Handler in Dart with Riverpod\nDESCRIPTION: This example shows how to use ref.read to obtain a provider's state within an event handler, such as a button press. It increments a counter when a button is clicked.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/de/docusaurus-plugin-content-docs/current/concepts/reading.mdx#2025-04-23_snippet_9\n\nLANGUAGE: dart\nCODE:\n```\n@override\nWidget build(BuildContext context, WidgetRef ref) {\n  return ElevatedButton(\n    onPressed: () {\n      ref.read(counterProvider.notifier).increment();\n    },\n    child: const Text('Increment'),\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using ref.listen in a Provider in Dart with Riverpod\nDESCRIPTION: This example shows how to use ref.listen within a provider to react to changes in another provider. It listens to a counter provider and prints a message when the count changes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/de/docusaurus-plugin-content-docs/current/concepts/reading.mdx#2025-04-23_snippet_7\n\nLANGUAGE: dart\nCODE:\n```\nfinal example = Provider((ref) {\n  ref.listen<int>(counterProvider, (previous, next) {\n    print('The counter changed from $previous to $next');\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Using Consumer Widget in Dart for Riverpod\nDESCRIPTION: This snippet demonstrates how to use the Consumer widget to obtain a 'ref' object without defining a new class. It's useful for localized provider interactions within a widget tree.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/de/docusaurus-plugin-content-docs/current/concepts/reading.mdx#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nConsumer(\n  builder: (context, ref, child) {\n    // We can use ref here\n    return Container();\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Running Dart Tests to Update Golden Snapshots\nDESCRIPTION: This command runs Dart tests with a specific flag to update the golden test snapshots. It sets the 'goldens' environment variable to true, which likely triggers the snapshot update process in the test suite.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/README.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ngoldens=true dart test\n```\n\n----------------------------------------\n\nTITLE: Combined Debouncing and Cancellation Extension for Riverpod\nDESCRIPTION: Reusable extension that combines both debouncing and cancellation functionality into a single utility method for Riverpod references.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/case_studies/cancel.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nextension CancelableRefExtension on Ref {\n  Future<T> debounceRequest<T>({\n    required Duration delay,\n    required Future<T> Function() callback,\n  }) async {\n    final completer = Completer<void>();\n    onDispose(completer.complete);\n\n    try {\n      await Future.delayed(delay);\n      await completer.future;\n    } catch (_) {\n      throw Exception('cancelled');\n    }\n\n    return callback();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Order of Generic Types in Riverpod Class Extension (Dart)\nDESCRIPTION: This snippet shows a Riverpod class declaration where the order of generic type parameters in the extension is incorrect. The class WrongOrder<A, B> extends _$WrongOrder<B, A>, swapping the order of A and B.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/notifier_extends/notifier_extends_lint.md#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\n// expect_lint: notifier_extends\nclass WrongOrder<A, B> extends _$WrongOrder<B, A> {\n  int build() => 0;\n}\n```\n\n----------------------------------------\n\nTITLE: ConsumerWidget ile Sağlayıcıları İzleme (Dart)\nDESCRIPTION: Bu kod, StatelessWidget yerine ConsumerWidget'ın nasıl kullanılacağını gösterir. ConsumerWidget, sağlayıcıları dinlemek için 'ref.watch' kullanabileceğiniz 'build' yöntemine ek bir WidgetRef parametresi ('ref') sağlar.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/tr/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nclass HomeView extends ConsumerWidget {\n  const HomeView({Key? key}): super(key: key);\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // provider'ı dinlemek için ref'i kullanın\n    final counter = ref.watch(counterProvider);\n    return Text('$counter');\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Multiple Parameters with Equatable\nDESCRIPTION: Implementation of a family provider that accepts multiple parameters using Equatable package.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/modifiers/family.mdx#2025-04-23_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\nclass MyParameter extends Equatable  {\n  MyParameter({\n    required this.userId,\n    required this.locale,\n  });\n\n  final int userId;\n  final Locale locale;\n\n  @override\n  List<Object> get props => [userId, locale];\n}\n\nfinal exampleProvider = Provider.family<Something, MyParameter>((ref, myParameter) {\n  print(myParameter.userId);\n  print(myParameter.locale);\n  // Do something with userId/locale\n});\n\n@override\nWidget build(BuildContext context, WidgetRef ref) {\n  int userId; // Read the user ID from somewhere\n  final locale = Localizations.localeOf(context);\n\n  final something = ref.watch(\n    exampleProvider(MyParameter(userId: userId, locale: locale)),\n  );\n\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Global Packages for Riverpod\nDESCRIPTION: This command navigates to the riverpod directory and installs the melos package globally. Melos is a tool for managing Dart monorepos and is required for working with the Riverpod project.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/examples/pub/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncd riverpod\ndart pub global activate melos\n```\n\n----------------------------------------\n\nTITLE: Defining Providers with Riverpod\nDESCRIPTION: Equivalent example showing how to define a Counter provider using Riverpod, where providers are top-level variables rather than widgets.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/riverpod_for_provider_users.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n// Les providers sont désormais des variables de premier niveau\nfinal counterProvider = ChangeNotifierProvider<Counter>((ref) => Counter());\n\nvoid main() {\n  runApp(\n    // Ce widget active Riverpod pour l'ensemble du projet.\n    ProviderScope(\n      child: MyApp(),\n    ),\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Family Arguments in Riverpod Overrides\nDESCRIPTION: Shows how family arguments are now handled in provider overrides, with the new syntax taking two parameters instead of accessing arguments through the Ref object.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_generator/CHANGELOG.md#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\nString example(Ref ref, int arg, {required int anotherArg}) {...}\n// ...\nexampleProvider.overrideWith(\n  (ref, ({int arg, int anotherArg}) args) {\n\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Defining a ChangeNotifier Provider for Combination (Provider)\nDESCRIPTION: Defines a `UserIdNotifier` using `ChangeNotifierProvider` from the Provider package. This serves as a dependency for a subsequent `ProxyProvider` example.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/from_provider/provider_vs_riverpod.mdx#_snippet_9\n\nLANGUAGE: dart\nCODE:\n```\nclass UserIdNotifier extends ChangeNotifier {\n  String? userId;\n}\n\n// ...\n\nChangeNotifierProvider<UserIdNotifier>(create: (context) => UserIdNotifier()),\n```\n\n----------------------------------------\n\nTITLE: ConsumerWidget Example - Dart\nDESCRIPTION: Demonstrates a `ConsumerWidget` which replaces a `StatelessWidget` to obtain a `ref` within the build method.  The `ref` is passed as a parameter to the build method, allowing the widget to read and interact with providers.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n/* ... content of reading_consumer_widget.dart ... */\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of Hooks Outside of Build Method\nDESCRIPTION: Example showing an incorrect implementation where hooks are used inside an event handler instead of directly in the build method.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/about_hooks.mdx#2025-04-23_snippet_7\n\nLANGUAGE: dart\nCODE:\n```\nclass Example extends HookWidget {\n  @override\n  Widget build(BuildContext context) {\n    return ElevatedButton(\n      onPressed: () {\n        // Not _actually_ inside the \"build\" method, but instead inside\n        // a user interaction lifecycle (here \"on pressed\").\n        final controller = useAnimationController();\n      },\n      child: Text('click me'),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Migration of StreamNotifierProvider from Manual to Generated in Dart\nDESCRIPTION: This snippet illustrates the shift from a manual StreamNotifierProvider to a code-generated class-based version in Dart, which improves code organization and readability when managing stream-based notifications.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/about_code_generation.mdx#_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nBefore: <existing StreamNotifierProvider code snippet>\n```\n\nLANGUAGE: dart\nCODE:\n```\nAfter: <generated StreamNotifierProvider class implementation in Dart>\n```\n\n----------------------------------------\n\nTITLE: Using Computed Pre-0.6.0 (Dart)\nDESCRIPTION: Illustrates the pattern of using a separate `Computed` provider to derive state from another `Provider` before Riverpod version 0.6.0. The `Computed` used `watch` to listen to dependencies.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod/CHANGELOG.md#2025-04-23_snippet_8\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nfinal provider = Provider(...);\nfinal example = Computed((watch) {\n  final value = watch(provider);\n  return value;\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Flagging Required BuildContext in Provider (Dart)\nDESCRIPTION: This code snippet demonstrates a provider function with a required named parameter of type BuildContext. The linter identifies this as a violation of the 'avoid_build_context_in_providers' rule.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/avoid_build_context_in_providers/avoid_build_context_in_providers_lint.md#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n  BuildContext context1, {\n  // expect_lint: avoid_build_context_in_providers\n  required BuildContext context2,\n}) =>\n    0;\n\n```\n\n----------------------------------------\n\nTITLE: Incorrect Conditional Usage of Hooks in Flutter\nDESCRIPTION: Example showing an incorrect implementation where hooks are used conditionally inside an if statement, which violates the rules of hooks.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/about_hooks.mdx#2025-04-23_snippet_8\n\nLANGUAGE: dart\nCODE:\n```\nclass Example extends HookWidget {\n  const Example({required this.condition, super.key});\n  final bool condition;\n  @override\n  Widget build(BuildContext context) {\n    if (condition) {\n      // Hooks should not be used inside \"if\"s/\"for\"s, ...\n      final controller = useAnimationController();\n    }\n    ...\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using ref.dependOn Pre-0.6.0 (Dart)\nDESCRIPTION: Illustrates the usage of `ref.dependOn` before Riverpod 0.6.0 to access dependent values like `StreamProvider.last`. This API was removed in version 0.6.0.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod/CHANGELOG.md#2025-04-23_snippet_14\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nfinal streamProvider = StreamProvider<T>(...);\nfinal example = Provider((ref) {\n  Future<T> last = ref.dependOn(streamProvider).last;\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Analyzing Missing Dependencies in StatefulWidget (Dart)\nDESCRIPTION: This snippet demonstrates a StatefulWidget with missing dependencies. It uses a widget with dependencies in its build method without declaring them.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/provider_dependencies/missing_dependencies2_lint.md#2025-04-23_snippet_10\n\nLANGUAGE: dart\nCODE:\n```\n@Dependencies([])\nclass Stateful2 extends StatefulWidget {\n  const Stateful2({super.key});\n\n  @override\n  State<Stateful2> createState() => _Stateful2State();\n}\n\nclass _Stateful2State extends State<Stateful2> {\n  @override\n  Widget build(BuildContext context) {\n    return WidgetDependencies();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Updating StateProvider usage in Dart\nDESCRIPTION: Adapting code to the new StateProvider API which now returns the state directly instead of the StateController in Riverpod 1.0.0.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/migration/0.14.0_to_1.0.0.mdx#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nfinal provider = StateProvider<int>(...);\n\nConsumer(\n  builder: (context, ref, child) {\n    StateController<int> count = ref.watch(provider);\n\n    return Text('${count.state}');\n  }\n)\n```\n\nLANGUAGE: dart\nCODE:\n```\nfinal provider = StateProvider<int>(...);\n\nConsumer(\n  builder: (context, ref, child) {\n    int count = ref.watch(provider);\n\n    return Text('${count}');\n  }\n)\n```\n\nLANGUAGE: dart\nCODE:\n```\nfinal provider = StateProvider<int>(...);\n\nConsumer(\n  builder: (context, ref, child) {\n    StateController<int> count = ref.watch(provider.state);\n\n    return Text('${count.state}');\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Installing Riverpod CLI\nDESCRIPTION: This command installs the Riverpod command-line interface globally using Dart's pub package manager. This tool is used for automatically migrating Riverpod projects to the latest syntax.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/migration/0.14.0_to_1.0.0.mdx#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ndart pub global activate riverpod_cli\n```\n\n----------------------------------------\n\nTITLE: Connecting TextField to Search Input Provider\nDESCRIPTION: Demonstrates how to connect a TextField widget to the searchInputProvider. The onChanged callback updates the provider's state with the current input value.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/cookbooks/search_as_we_type.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nConsumer(\n  builder: (context, ref, child) {\n    return TextField(\n      onChanged: (value) => ref.read(searchInputProvider.notifier).state = value,\n    );\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Override Public Getter in Dart Notifier\nDESCRIPTION: Multiple examples of overridden public getters that violate the avoid_public_notifier_properties lint rule. These implementations should expose their values through the state property instead.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/avoid_public_notifier_properties/avoid_public_notifier_properties_lint.md#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nint get publicGetter => _privateGetter;\n```\n\n----------------------------------------\n\nTITLE: Implementing Provider Dependencies in Dart\nDESCRIPTION: Shows how to define dependencies for a provider using the new dependencies parameter. This allows for automatic overriding of dependent providers when the dependency is overridden.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/flutter_riverpod/CHANGELOG.md#2025-04-23_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\nfinal a = Provider(...);\n\nfinal b = Provider((ref) => ref.watch(a), dependencies: [a]);\n```\n\n----------------------------------------\n\nTITLE: Checking Riverpod CLI Installation\nDESCRIPTION: Verifies that the riverpod CLI tool has been successfully installed and is accessible from the command line. This confirms that the tool is ready to be used for migrating Riverpod projects.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/migration/0.14.0_to_1.0.0.mdx#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nriverpod --help\n```\n\n----------------------------------------\n\nTITLE: Showing provider definition - Dart\nDESCRIPTION: このコードスニペットはプロバイダを定義する、コードジェネレーションを使用しない場合のプロバイダの実表现です。主な機能は、コードを書くことです。依存関係はなく、コードジェネレーションに際した、プロバイダ定義のしたられる形式です。\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/about_code_generation.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n// ignore_for_file: unused_element\n\nimport 'package:riverpod/riverpod.dart';\n\n// We create a Provider that will expose the user's name\nfinal fetchUserProvider = FutureProvider((ref) async {\n  // Simulate fetching a user from a server\n  await Future.delayed(const Duration(milliseconds: 100));\n\n  return 'John Doe';\n});\n\n```\n\n----------------------------------------\n\nTITLE: Accessing the state object with new syntax\nDESCRIPTION: Shows how to access the current state directly with Riverpod 0.14.0 by reading the provider without the .state property.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_6\n\nLANGUAGE: Dart\nCODE:\n```\nWidget build(BuildContext context, ScopedReader watch) {\n  MyModel state = watch(provider);\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Documentation Tabs with JavaScript\nDESCRIPTION: Imports the Tabs and TabItem components from the documentation theme package in JavaScript. These dependencies are required for creating tabbed code examples or navigation in documentation pages. The imports are essential setup for structured, tab-based demo code and do not modify any business logic themselves.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/bn/docusaurus-plugin-content-docs/current/cookbooks/refresh.mdx#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\n```\n\n----------------------------------------\n\nTITLE: Missing Notifier Extension Example - Dart\nDESCRIPTION: Example of a class that fails lint checks because it does not extend the required _$ClassName pattern required for @riverpod annotated classes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/notifier_extends/failing_notifier_extends_lint.md#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\n// expect_lint: notifier_extends\nclass NoExtends {\n  int build() => 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Detecting Missing Dependencies in Custom Riverpod Annotations (Dart)\nDESCRIPTION: This snippet demonstrates the lint identifying missing dependencies in a custom Riverpod annotation. The provider uses 'depProvider' but doesn't include it in the dependencies.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/provider_dependencies/missing_dependencies_lint.md#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n// expect_lint: provider_dependencies\n@Riverpod(keepAlive: false)\nint customAnnotation(Ref ref) {\n  ref.watch(depProvider);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Detecting Unused Dependencies in Class Member (Dart)\nDESCRIPTION: This code shows a class member with unused dependencies. It uses the @Dependencies annotation but doesn't utilize the specified dependency in the build method.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/provider_dependencies/missing_dependencies2_lint.md#2025-04-23_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nclass MemberDependencies {\n  @Dependencies([dep])\n  int build() => 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Unoptimized Previous Button Implementation in Dart\nDESCRIPTION: Demonstrates an unoptimized implementation of a 'Previous' button in a paged view, which rebuilds unnecessarily on page changes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/bn/docusaurus-plugin-content-docs/current/providers/provider.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nclass PreviousButton extends ConsumerWidget {\n  const PreviousButton({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final currentPage = ref.watch(currentPageProvider);\n\n    return ElevatedButton(\n      onPressed: currentPage == 0 ? null : () => ref.read(currentPageProvider.notifier).previous(),\n      child: const Text('previous'),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing StateNotifier Instance in Dart\nDESCRIPTION: Shows how to update code to access the StateNotifier instance with the new .notifier syntax rather than accessing it directly from the provider.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/es/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, ScopedReader watch) {\n  MyStateNotifier notifier = watch(provider);\n}\n```\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, ScopedReader watch) {\n  MyStateNotifier notifier = watch(provider.notifier);\n}\n```\n\n----------------------------------------\n\nTITLE: Running Code Generation for Freezed\nDESCRIPTION: Shell command to run the build_runner for generating Freezed model classes. This needs to be executed before building the application.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/examples/marvel/README.md#2025-04-23_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ndart run build_runner build -d\n```\n\n----------------------------------------\n\nTITLE: Detecting Missing ProviderScope in main() Function in Dart\nDESCRIPTION: Example of code that triggers the 'missing_provider_scope' linting warning in a main() function when calling runApp without wrapping the app in a ProviderScope widget.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/missing_provider_scope/missing_provider_scope_lint.md#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nvoid main() {\n  // expect_lint: missing_provider_scope\n  runApp(\n    MyApp(),\n  );\n```\n\n----------------------------------------\n\nTITLE: Combining Providers with Provider Package using ProxyProvider in Dart\nDESCRIPTION: Example showing how to combine providers using the Provider package with ProxyProvider to create a new stateless provider based on the value of another provider.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/from_provider/provider_vs_riverpod.mdx#_snippet_7\n\nLANGUAGE: dart\nCODE:\n```\nclass UserIdNotifier extends ChangeNotifier {\n  String? userId;\n}\n\n// ...\n\nChangeNotifierProvider<UserIdNotifier>(create: (context) => UserIdNotifier()),\n```\n\nLANGUAGE: dart\nCODE:\n```\nProxyProvider<UserIdNotifier, String>(\n  update: (context, userIdNotifier, _) {\n    return 'The user ID of the the user is ${userIdNotifier.userId}';\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Accessing StateNotifier State Before and After Update in Dart\nDESCRIPTION: Comparison of how to access the state of a StateNotifier before and after the 0.14.0 update, removing the need for .state.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/migration/0.13.0_to_0.14.0.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, ScopedReader watch) {\n  MyModel state = watch(provider.state);\n}\n```\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, ScopedReader watch) {\n  MyModel state = watch(provider);\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up Code Generation for Riverpod StackOverflow Client\nDESCRIPTION: Command to run the build_runner to generate necessary code for the StackOverflow client example. This must be executed before starting the application as the project uses code generation.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/examples/stackoverflow/README.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ncd examples/stackoverflow\ndart run build_runner build -d\n```\n\n----------------------------------------\n\nTITLE: Defining a weather provider in Dart\nDESCRIPTION: An auto-generated snippet showing how to create a weather provider that depends on the city provider, illustrating provider dependencies using Riverpod's ref and watch method.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet language=\"dart\" {...weatherProvider}></AutoSnippet>\n```\n\n----------------------------------------\n\nTITLE: Using select with ref.listen in Dart\nDESCRIPTION: This code shows how to use select with ref.listen to listen for changes to a specific property of a provided object.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/reading.mdx#2025-04-23_snippet_11\n\nLANGUAGE: dart\nCODE:\n```\nref.listen<String>(\n  userProvider.select((user) => user.name),\n  (String? previousName, String newName) {\n    print('The user name changed $newName');\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: Inefficient Watching of Entire User Object in Flutter\nDESCRIPTION: This code demonstrates an inefficient way of watching a User object when only the name property is used, potentially causing unnecessary rebuilds.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/reading.mdx#2025-04-23_snippet_18\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, WidgetRef ref) {\n  User user = ref.watch(userProvider);\n  return Text(user.name);\n}\n```\n\n----------------------------------------\n\nTITLE: Avoiding Improper Placement of ref.watch in Imperative Code in JavaScript/TypeScript\nDESCRIPTION: Provides a cautionary example warning against calling ref.watch imperatively inside callbacks or Notifier methods, which do not run during the provider build phase. This snippet highlights pitfalls of such use, which can lead to inconsistent or invalid state observations within Riverpod providers.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/essentials/combining_requests.mdx#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\n\n```\n\n----------------------------------------\n\nTITLE: Showing generated provider definition - Dart\nDESCRIPTION: このコードスニペットは、コードジェネレーションを使用した、プロバイダを定義する場合のプロバイダの実表现です。主な機能は、コードを書くことです。依存関係はなく、コードジェネレーションによるプロバイダ定義のしたられる形式です。\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/about_code_generation.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n// ignore_for_file: unused_element\n\nimport 'package:riverpod/riverpod.dart';\n\npart 'main.g.dart';\n\n@riverpod\nFuture<String> fetchUser(FetchUserRef ref) async {\n  // Simulate fetching a user from a server\n  await Future.delayed(const Duration(milliseconds: 100));\n\n  return 'John Doe';\n}\n\n```\n\n----------------------------------------\n\nTITLE: Dart code snippet for CLI 'Hello World' example\nDESCRIPTION: Dart script to output 'Hello World' in console, illustrating a basic use of Riverpod in a non-Flutter environment. Uses Dart SDK.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/getting_started.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet title=\"lib/main.dart\" language=\"dart\" {...dartHelloWorld}></AutoSnippet>\n```\n\n----------------------------------------\n\nTITLE: Riverpod Annotation with Unused Dependency\nDESCRIPTION: Test case showing unused dependency in a Riverpod annotation declaration\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/provider_dependencies/unused_dependency_lint.md#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n@Riverpod(\n  // expect_lint: provider_dependencies\n  dependencies: [\n    dep,\n  ],\n  keepAlive: false,\n)\n```\n\n----------------------------------------\n\nTITLE: Creating Dropdown UI - Dart\nDESCRIPTION: This Dart code creates the UI for the dropdown menu using Flutter's DropdownButton widget. This snippet is used to allow users to select the sorting criteria for the product list. It needs the Flutter framework.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/providers/state_provider.mdx#_snippet_2\n\nLANGUAGE: Dart\nCODE:\n```\n// Code for Dropdown UI (dropdown.dart)\n```\n\n----------------------------------------\n\nTITLE: Defining Activity Model in Dart\nDESCRIPTION: 이 코드 스니펫은 Bored API에서 수신할 데이터의 모델을 정의합니다. 여기에는 JSON 객체를 Dart 클래스 인스턴스로 파싱하는 방법이 포함됩니다.  Freezed 또는 json_serializable과 같은 코드 생성기를 사용하는 것이 좋습니다.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/essentials/first_request.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n { ...activity} \n```\n\n----------------------------------------\n\nTITLE: Using Provider-Specific Ref Subclasses in Dart\nDESCRIPTION: Demonstrates the use of provider-specific Ref subclasses, which allow providers to implement features not shared with other providers. This example shows how to use the state property of a Provider's ref.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/flutter_riverpod/CHANGELOG.md#2025-04-23_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nProvider<int>((ref) {\n  ref.listen(onIncrementProvider, (_) {\n    ref.state++;\n  });\n\n  return 0;\n});\n```\n\n----------------------------------------\n\nTITLE: Defining an Abstract Data Class in Dart\nDESCRIPTION: Defines an abstract `User` class in Dart, intended as a data model example. It declares getter methods for `name` (String) and `age` (int), providing a structure for objects that might be managed by a Riverpod provider.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_15\n\nLANGUAGE: dart\nCODE:\n```\nabstract class User {\n  String get name;\n  int get age;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining User Class with Name and Age Properties\nDESCRIPTION: This snippet defines an abstract User class with name and age properties, used in subsequent examples for demonstrating selective watching.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/reading.mdx#2025-04-23_snippet_17\n\nLANGUAGE: dart\nCODE:\n```\nabstract class User {\n  String get name;\n  int get age;\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Family Provider Usage Example\nDESCRIPTION: Example demonstrating incorrect way to use a family provider without parameters.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/modifiers/family.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, WidgetRef ref) {\n  // Error – messagesFamily is not a provider\n  final response = ref.watch(messagesFamily);\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Provider in Scoped ProviderScope\nDESCRIPTION: This snippet shows an override of a provider in a scoped ProviderScope (not Flutter's runApp), which should trigger the lint warning for not specifying dependencies.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/scoped_providers_should_specify_dependencies/scoped_providers_should_specify_dependencies_lint.md#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nrootProvider.overrideWith((ref) => 0)\n```\n\n----------------------------------------\n\nTITLE: Detecting Missing Dependencies in StatelessWidget (Dart)\nDESCRIPTION: This code shows a StatelessWidget with missing dependencies. It uses a widget that has dependencies without declaring them in the parent widget.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/provider_dependencies/missing_dependencies2_lint.md#2025-04-23_snippet_9\n\nLANGUAGE: dart\nCODE:\n```\nclass WidgetDependencies2 extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return WidgetDependencies();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Synchronous Provider for Async APIs with Scoping\nDESCRIPTION: Demonstrates how to use scoping to override a dummy provider with the actual implementation once an asynchronous API is initialized, allowing synchronous access to the API.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/scopes.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\ntrimSnippet(asyncInitialization)\n```\n\n----------------------------------------\n\nTITLE: Filtered Todo List Provider\nDESCRIPTION: Creates a provider that combines filter state with todo list to show filtered results.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/combining_providers.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nfinal filteredTodoListProvider = Provider<List<Todo>>((ref) {\n  final filter = ref.watch(filterProvider);\n  final todos = ref.watch(todoListProvider);\n\n  switch (filter) {\n    case Filter.none:\n      return todos;\n    case Filter.completed:\n      return todos.where((todo) => todo.completed).toList();\n    case Filter.uncompleted:\n      return todos.where((todo) => !todo.completed).toList();\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Identifying Missing Dependencies in Riverpod Providers (Dart)\nDESCRIPTION: This snippet shows the lint detecting missing dependencies in a Riverpod provider. The provider uses 'depProvider' but doesn't declare it in the dependencies.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/provider_dependencies/missing_dependencies_lint.md#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n// expect_lint: provider_dependencies\n@riverpod\nint plainAnnotation(Ref ref) {\n  ref.watch(depProvider);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Dynamic Provider Usage\nDESCRIPTION: Shows an anti-pattern where providers are used with dynamic references, making static analysis difficult.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/do_dont.mdx#2025-04-23_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nclass Example extends ConsumerWidget {\n  Example({required this.provider});\n  final Provider<int> provider;\n\n  @override\n  Widget build(context, ref) {\n    // Bad because static analysis cannot know what `provider` is\n    ref.watch(provider);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using the cacheFor Extension - Dart\nDESCRIPTION: Shows an example of how to use the previously defined `cacheFor` extension method to keep a provider's state alive for 5 minutes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/essentials/auto_dispose.mdx#_snippet_7\n\nLANGUAGE: dart\nCODE:\n```\n  /// 5分間、stateを維持する\n```\n\n----------------------------------------\n\nTITLE: Complete Flutter widget test example for Riverpod\nDESCRIPTION: Provides a full example of a Flutter widget test utilizing ProviderScope to override and control provider states, illustrating best testing practices with Riverpod.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/de/docusaurus-plugin-content-docs/current/cookbooks/testing.mdx#_snippet_2\n\nLANGUAGE: Dart\nCODE:\n```\n/* Full Flutter test code utilizing ProviderScope to override providers for isolated and controlled testing environment */\n// Complete test code example\n```\n\n----------------------------------------\n\nTITLE: Detecting Unused Dependencies in Function (Dart)\nDESCRIPTION: This code shows a function with unused dependencies. It uses the @Dependencies annotation but doesn't utilize the specified dependency within the function body.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/provider_dependencies/missing_dependencies2_lint.md#2025-04-23_snippet_7\n\nLANGUAGE: dart\nCODE:\n```\n@Dependencies([dep])\nvoid fn() {}\n```\n\n----------------------------------------\n\nTITLE: Passing Parameters to a Functional Provider (Dart)\nDESCRIPTION: This snippet demonstrates how to pass parameters to a functional provider using code generation without the `family` modifier. The annotated function can accept parameters directly.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/about_code_generation.mdx#_snippet_9\n\nLANGUAGE: dart\nCODE:\n```\n{trimSnippet(familyFn)}\n```\n\n----------------------------------------\n\nTITLE: Defining Product Model in Dart\nDESCRIPTION: Defines a Product class with name and price properties, and creates a list of sample products.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/bn/docusaurus-plugin-content-docs/current/providers/state_provider.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nclass Product {\n  Product({required this.name, required this.price});\n\n  final String name;\n  final double price;\n}\n\nfinal products = [\n  Product(name: 'iPhone', price: 999),\n  Product(name: 'cookie', price: 2),\n  Product(name: 'ps5', price: 500),\n];\n```\n\n----------------------------------------\n\nTITLE: Example Log Output from Custom ProviderObserver\nDESCRIPTION: Shows the sample console output generated by the custom `Logger` (extending `ProviderObserver`) when the `didUpdateProvider` method is triggered. The output is formatted as JSON, indicating the provider's name ('counter') and its new value ('1').\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/concepts/provider_observer.mdx#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nI/flutter (16783): {\nI/flutter (16783):   \"provider\": \"counter\",\nI/flutter (16783):   \"newValue\": \"1\"\nI/flutter (16783): }\n```\n\n----------------------------------------\n\nTITLE: Dart code snippet for Flutter 'Hello World' example\nDESCRIPTION: Dart code to demonstrate a 'Hello World' application using Riverpod within a Flutter project. Requires Flutter SDK and related dependencies.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/getting_started.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet title=\"lib/main.dart\" language=\"dart\" {...helloWorld}></AutoSnippet>\n```\n\n----------------------------------------\n\nTITLE: Accessing StateNotifier State in Dart\nDESCRIPTION: Shows how to update code to access the state directly from the provider instead of using the .state property.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/es/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, ScopedReader watch) {\n  MyModel state = watch(provider.state);\n}\n```\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, ScopedReader watch) {\n  MyModel state = watch(provider);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Code-Generated Provider Structure in Riverpod\nDESCRIPTION: Shows the structure for defining code-generated providers using the @riverpod annotation, including function parameters and return types.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/first_request.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\nResult myFunction(Ref ref) {\n  <your logic here>\n}\n```\n\n----------------------------------------\n\nTITLE: Combining AutoDispose with Family Modifier in Dart\nDESCRIPTION: Shows how to combine .autoDispose with other modifiers like .family to create a provider that accepts parameters and auto-cleanup.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/modifiers/auto_dispose.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nfinal userProvider = StreamProvider.autoDispose.family<User, String>((ref, id) {\n\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing UserIdNotifier with ChangeNotifier in Riverpod\nDESCRIPTION: Creates a UserIdNotifier using ChangeNotifierProvider in Riverpod. This shows the Riverpod equivalent of the first Provider example.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/from_provider/provider_vs_riverpod.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nclass UserIdNotifier extends ChangeNotifier {\n  String? userId;\n}\n\n// ...\n\nfinal userIdNotifierProvider = ChangeNotifierProvider<UserIdNotifier>(\n  (ref) => UserIdNotifier(),\n),\n```\n\n----------------------------------------\n\nTITLE: Running Riverpod Benchmarks with Flutter CLI\nDESCRIPTION: This command runs a specific benchmark file in release mode using Flutter. Replace 'some_benchmark.dart' with the actual benchmark file you want to run.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/benchmarks/README.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nflutter run --release -t lib/some_benchmark.dart\n```\n\n----------------------------------------\n\nTITLE: Using Raw Type in Riverpod Provider Return Values\nDESCRIPTION: Shows how to use the Raw typedef in provider return values to disable automatic conversion of Futures/Streams into AsyncValues.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_generator/CHANGELOG.md#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\nRaw<Future<int>> myProvider(...) async => ...;\n...\n// returns a Future<int> instead of AsyncValue<int>\nFuture<int> value = ref.watch(myProvider);\n```\n\n----------------------------------------\n\nTITLE: Raw Stream Usage Without AsyncValue Wrapper\nDESCRIPTION: Shows how to bypass AsyncValue conversion for Stream and Future values using Raw typedef.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/websockets_sync.mdx#2025-04-23_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\nRaw<Future<int>> counter(CounterRef ref) {\n  return Future.value(42);\n}\n```\n\n----------------------------------------\n\nTITLE: AsyncNotifierProvider Migration\nDESCRIPTION: Shows migration from AsyncNotifierProvider to code-generated async class provider. Uses @riverpod annotation with an async class implementation.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/about_code_generation.mdx#2025-04-23_snippet_9\n\nLANGUAGE: dart\nCODE:\n```\nfinal counterProvider = AsyncNotifierProvider<Counter, int>(() => Counter());\n\nclass Counter extends AsyncNotifier<int> {\n  @override\n  Future<int> build() async => 0;\n}\n```\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\nclass Counter extends _$Counter {\n  @override\n  Future<int> build() async => 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Analyzing Missing Dependencies in Widget Class (Dart)\nDESCRIPTION: This snippet demonstrates a widget class with missing dependencies. It uses a provider without declaring it in the Dependencies annotation.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/provider_dependencies/missing_dependencies2_lint.md#2025-04-23_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\n@Dependencies([])\nclass CanUpdateMultipleDependenciesAtOnce {\n  int build(WidgetRef ref) {\n    ref.watch(depProvider);\n    return 0;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating HookWidget to HookConsumerWidget in Dart\nDESCRIPTION: Example of migrating from HookWidget to HookConsumerWidget, updating the build method signature and provider usage.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/migration/0.14.0_to_1.0.0.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nclass Example extends HookWidget {\n  @override\n  Widget build(BuildContext context) {\n    useState(...);\n    int count = useProvider(counterProvider);\n    ...\n  }\n}\n```\n\nLANGUAGE: dart\nCODE:\n```\nclass Example extends HookConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    useState(...);\n    int count = ref.watch(counterProvider);\n    ...\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Reading Providers with Provider using BuildContext\nDESCRIPTION: Example showing how to read a Model provider using the BuildContext extension methods in Provider.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/riverpod_for_provider_users.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nProvider<Model>(...);\n\nclass Example extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    Model model = context.watch<Model>();\n\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Riverpod migration CLI tool with Dart\nDESCRIPTION: Commands to install the Riverpod CLI tool that automates the migration process from version 0.14.x to 1.0.0.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/migration/0.14.0_to_1.0.0.mdx#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ndart pub global activate riverpod_cli\n```\n\nLANGUAGE: sh\nCODE:\n```\nriverpod --help\n```\n\nLANGUAGE: sh\nCODE:\n```\nriverpod migrate\n```\n\n----------------------------------------\n\nTITLE: Managing State Disposal Automatically in Riverpod (Dart)\nDESCRIPTION: This placeholder represents a Dart code snippet illustrating Riverpod's automatic state disposal capabilities using the `.autoDispose` modifier and related APIs like `.keepAlive`. This solves a major limitation of Provider (due to InheritedWidget constraints) where state isn't automatically cleaned up when no longer used, simplifying memory management and enabling flexible caching strategies.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/from_provider/motivation/motivation.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet language=\"dart\" {...autoDispose}></AutoSnippet>\n```\n\n----------------------------------------\n\nTITLE: Defining a simple Provider in Dart\nDESCRIPTION: Creates a Provider that supplies a fixed string 'London'. Used as a dependency for other providers.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/es/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\nfinal cityProvider = Provider((ref) => 'London');\n```\n\n----------------------------------------\n\nTITLE: Installing Riverpod CLI in Dart/Flutter\nDESCRIPTION: Command to install the Riverpod CLI migration tool globally, which helps automate the migration process from Riverpod 0.13.0 to 0.14.0.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/es/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\ndart pub global activate riverpod_cli\n```\n\n----------------------------------------\n\nTITLE: Deprecating Generated Ref Subclasses in Riverpod\nDESCRIPTION: Demonstrates the deprecated usage of generated Ref subclasses and the new recommended approach using the generic Ref type for provider functions.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_generator/CHANGELOG.md#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\nModel foo(FooRef ref) => ..\n```\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\nModel foo(Ref ref) => ..\n```\n\n----------------------------------------\n\nTITLE: Updating StateProvider Usage in Dart\nDESCRIPTION: Examples of migrating StateProvider usage to directly return the state instead of StateController.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/migration/0.14.0_to_1.0.0.mdx#2025-04-23_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nfinal provider = StateProvider<int>(...);\n\nConsumer(\n  builder: (context, ref, child) {\n    StateController<int> count = ref.watch(provider);\n\n    return Text('${count.state}');\n  }\n)\n```\n\nLANGUAGE: dart\nCODE:\n```\nfinal provider = StateProvider<int>(...);\n\nConsumer(\n  builder: (context, ref, child) {\n    int count = ref.watch(provider);\n\n    return Text('${count}');\n  }\n)\n```\n\nLANGUAGE: dart\nCODE:\n```\nfinal provider = StateProvider<int>(...);\n\nConsumer(\n  builder: (context, ref, child) {\n    StateController<int> count = ref.watch(provider.state);\n\n    return Text('${count.state}');\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Riverpod Code Generation Extension\nDESCRIPTION: Utility extension method to support ChangeNotifier with Riverpod's code generation feature.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/from_provider/quickstart.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nextension ChangeNotifierWithCodeGenExtension on Ref {\n  T listenAndDisposeChangeNotifier<T extends ChangeNotifier>(T notifier) {\n    notifier.addListener(notifyListeners);\n    onDispose(() => notifier.removeListener(notifyListeners));\n    onDispose(notifier.dispose);\n    return notifier;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Subtree Scoping with Riverpod Providers\nDESCRIPTION: Demonstrates how to override a provider's implementation for a specific widget subtree in Riverpod, similar to how InheritedWidget works in Flutter.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/scopes.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\ntrimSnippet(subtreeScope)\n```\n\n----------------------------------------\n\nTITLE: FutureProvider Migration\nDESCRIPTION: Shows migration from FutureProvider to code-generated async function provider. Uses @riverpod annotation with an async function returning a Future.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/about_code_generation.mdx#2025-04-23_snippet_7\n\nLANGUAGE: dart\nCODE:\n```\nfinal userProvider = FutureProvider<User>((ref) async => fetchUser());\n```\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\nFuture<User> user(UserRef ref) => fetchUser();\n```\n\n----------------------------------------\n\nTITLE: StreamProvider Migration\nDESCRIPTION: Shows migration from StreamProvider to code-generated stream function provider. Uses @riverpod annotation with a function returning a Stream.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/about_code_generation.mdx#2025-04-23_snippet_8\n\nLANGUAGE: dart\nCODE:\n```\nfinal userProvider = StreamProvider<User>((ref) => watchUser());\n```\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\nStream<User> user(UserRef ref) => watchUser();\n```\n\n----------------------------------------\n\nTITLE: Testing Generator Provider with Object Parameters\nDESCRIPTION: Test cases for generator provider using Object instances and null values.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/provider_parameters/provider_parameters_lint.md#2025-04-23_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\n    ref.watch(generatorProvider(value: null));\n    // expect_lint: provider_parameters\n    ref.watch(generatorProvider(value: Object()));\n    ref.watch(generatorProvider(value: const Object()));\n\n```\n\n----------------------------------------\n\nTITLE: Using keepAlive with FutureProvider in Dart\nDESCRIPTION: Example of using ref.keepAlive() to preserve provider state after an HTTP request completes successfully.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/modifiers/auto_dispose.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nfinal myProvider = FutureProvider.autoDispose((ref) async {\n  final response = await httpClient.get(...);\n  ref.keepAlive();\n  return response;\n});\n```\n\n----------------------------------------\n\nTITLE: Unused Multiple Dependencies in Provider\nDESCRIPTION: Test case showing unused dependencies 'dep' and 'dep2' in a provider declaration with keepAlive parameter\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/provider_dependencies/unused_dependency_lint.md#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n  keepAlive: false,\n  // expect_lint: provider_dependencies\n  dependencies: [\n    dep,\n    dep2,\n  ],\n)\nint extraDep(Ref ref) {\n```\n\n----------------------------------------\n\nTITLE: Manually Invalidating Provider State\nDESCRIPTION: Shows how to manually force the destruction of a provider's state using ref.invalidate, which can trigger recreation if the provider is still being listened to.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/auto_dispose.mdx#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\n// A provider which we want to be able to reset\nfinal counterProvider = StateProvider((ref) => 0);\n\n// When this provider is called, it will reset the counterProvider\nfinal resetCounterProvider = Provider(\n  (ref) => VoidCallback(() => ref.invalidate(counterProvider)),\n);\n\n```\n\n----------------------------------------\n\nTITLE: Async StateNotifier Class Provider\nDESCRIPTION: Demonstrates an async class-based implementation of an unsupported StateNotifier provider\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/unsupported_provider_value/unsupported_provider_value_lint.md#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\n// expect_lint: unsupported_provider_value\nclass StateNotifierClassAsync extends _$StateNotifierClassAsync {\n  Future<MyStateNotifier> build() async => MyStateNotifier();\n}\n```\n\n----------------------------------------\n\nTITLE: Starting Local Development Server for Riverpod Website\nDESCRIPTION: Command to start a local development server that automatically refreshes when changes are made to the website code.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ yarn start\n```\n\n----------------------------------------\n\nTITLE: Testing Async Providers\nDESCRIPTION: Shows how to test providers that return Future/Stream values by awaiting their completion.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/testing.mdx#2025-04-23_snippet_7\n\nLANGUAGE: dart\nCODE:\n```\ntest('await async operation', () async {\n  final container = ProviderContainer();\n  addTearDown(container.dispose);\n\n  expect(\n    container.read(asyncProvider.future),\n    completion(42),\n  );\n});\n```\n\n----------------------------------------\n\nTITLE: Widget Testing Setup with ProviderScope\nDESCRIPTION: Shows how to set up widget tests with ProviderScope to enable provider functionality in widget testing environment.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/testing.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\ntestWidgets('description', (tester) async {\n  await tester.pumpWidget(\n    ProviderScope(\n      child: MyApp(),\n    ),\n  );\n});\n```\n\n----------------------------------------\n\nTITLE: Installing Global Packages for Riverpod\nDESCRIPTION: Commands to navigate to the riverpod directory and install the melos package globally using dart pub.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_generator/integration/build_yaml/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncd riverpod\ndart pub global activate melos\n```\n\n----------------------------------------\n\nTITLE: Creating StateProvider for Search Input in Dart\nDESCRIPTION: This snippet creates a StateProvider to store the user's search input as a string.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/de/docusaurus-plugin-content-docs/current/cookbooks/search_as_we_type.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nfinal searchInputProvider = StateProvider<String>((ref) => '');\n```\n\n----------------------------------------\n\nTITLE: Running Riverpod Lint Migrations\nDESCRIPTION: Command to run Riverpod Lint migrations using the custom_lint package. This applies all available migrations and fixes in the project.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint/README.md#2025-04-23_snippet_10\n\nLANGUAGE: sh\nCODE:\n```\ndart run custom_lint --fix\n```\n\n----------------------------------------\n\nTITLE: Testing Notifier Usage\nDESCRIPTION: Demonstrates how to use mocked notifiers in tests with overrides.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/testing.mdx#2025-04-23_snippet_8\n\nLANGUAGE: dart\nCODE:\n```\ntest('mock notifier', () {\n  final notifier = MyNotifierMock();\n  final container = ProviderContainer(\n    overrides: [\n      myNotifierProvider.overrideWith(() => notifier),\n    ],\n  );\n\n  when(notifier.build).thenReturn('mock');\n});\n```\n\n----------------------------------------\n\nTITLE: Updating StateProvider State Based on Previous Value in Dart\nDESCRIPTION: Demonstrates how to update a StateProvider's state based on its previous value using the update function.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/bn/docusaurus-plugin-content-docs/current/providers/state_provider.mdx#2025-04-23_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\nref.read(counterProvider.notifier).update((state) => state + 1);\n```\n\n----------------------------------------\n\nTITLE: Installing Riverpod Lint Dependencies in pubspec.yaml\nDESCRIPTION: Configuration required in pubspec.yaml to install riverpod_lint and its dependency custom_lint as dev dependencies.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint/README.md#2025-04-23_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\ndev_dependencies:\n  custom_lint:\n  riverpod_lint:\n```\n\n----------------------------------------\n\nTITLE: User Class Definition\nDESCRIPTION: Abstract class defining the User model with name and age properties\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/reading.mdx#2025-04-23_snippet_15\n\nLANGUAGE: dart\nCODE:\n```\nabstract class User {\n  String get name;\n  int get age;\n}\n```\n\n----------------------------------------\n\nTITLE: Running Riverpod Migration Tool\nDESCRIPTION: Command to run the Riverpod migration tool on a project to automatically update to the new syntax.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/migration/0.13.0_to_0.14.0.mdx#2025-04-23_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\nriverpod migrate\n```\n\n----------------------------------------\n\nTITLE: Refreshing a Provider in Riverpod\nDESCRIPTION: This code shows how to refresh a provider using ref.refresh, which recreates the provider's state.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/reading.mdx#2025-04-23_snippet_12\n\nLANGUAGE: dart\nCODE:\n```\nref.refresh(counterProvider);\n```\n\n----------------------------------------\n\nTITLE: BuildContext Usage in Providers\nDESCRIPTION: Demonstrates proper provider implementation without BuildContext dependencies.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint/README.md#2025-04-23_snippet_7\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\nint fn(Ref ref) => 0;\n\n@riverpod\nclass MyNotifier extends _$MyNotifier {\n  int build() => 0;\n\n  void event() {}\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Product Model in Dart\nDESCRIPTION: Defines a simple Product class with name and price properties, plus a list of sample products for demonstration purposes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/providers/state_provider.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nclass Product {\n  Product({required this.name, required this.price});\n\n  final String name;\n  final double price;\n}\n\nfinal products = [\n  Product(name: 'iPhone', price: 999),\n  Product(name: 'cookie', price: 2),\n  Product(name: 'ps5', price: 500),\n];\n```\n\n----------------------------------------\n\nTITLE: AsyncNotifier Class Provider\nDESCRIPTION: Shows a class-based implementation of an unsupported AsyncNotifier provider\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/unsupported_provider_value/unsupported_provider_value_lint.md#2025-04-23_snippet_11\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\n// expect_lint: unsupported_provider_value\nclass AsyncNotifierClass extends _$AsyncNotifierClass {\n  MyAsyncNotifier build() => MyAsyncNotifier();\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for Riverpod Documentation (Shell)\nDESCRIPTION: Commands for installing the necessary dependencies to run the Riverpod documentation website locally using Yarn.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/CONTRIBUTING.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nyarn install\n```\n\n----------------------------------------\n\nTITLE: Incorrect Provider Scope Implementation\nDESCRIPTION: Example of incorrectly implementing a Flutter app without ProviderScope.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint/README.md#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nvoid main() {\n  runApp(MyApp());\n}\n```\n\n----------------------------------------\n\nTITLE: Function Dependencies\nDESCRIPTION: Test case showing unused dependency in a function declaration\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/provider_dependencies/unused_dependency_lint.md#2025-04-23_snippet_7\n\nLANGUAGE: dart\nCODE:\n```\n// expect_lint: provider_dependencies\n@Dependencies([dep])\nvoid fn() {}\n\n```\n\n----------------------------------------\n\nTITLE: AsyncNotifier Provider Implementation\nDESCRIPTION: Demonstrates an implementation of an unsupported AsyncNotifier provider\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/unsupported_provider_value/unsupported_provider_value_lint.md#2025-04-23_snippet_10\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\n// expect_lint: unsupported_provider_value\nMyAsyncNotifier asyncNotifier(Ref ref) => MyAsyncNotifier();\n\n@riverpod\n```\n\n----------------------------------------\n\nTITLE: Running Riverpod Migration Tool\nDESCRIPTION: Command to run the Riverpod migration tool on a project.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/migration/0.14.0_to_1.0.0.mdx#2025-04-23_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nriverpod migrate\n```\n\n----------------------------------------\n\nTITLE: ChangeNotifier Provider Implementation\nDESCRIPTION: Shows an implementation of an unsupported ChangeNotifier provider\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/unsupported_provider_value/unsupported_provider_value_lint.md#2025-04-23_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\n// expect_lint: unsupported_provider_value\nMyChangeNotifier changeNotifier(Ref ref) => MyChangeNotifier();\n\n@riverpod\n```\n\n----------------------------------------\n\nTITLE: Notifier Provider Implementation\nDESCRIPTION: Shows an implementation of an unsupported Notifier provider\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/unsupported_provider_value/unsupported_provider_value_lint.md#2025-04-23_snippet_7\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\n// expect_lint: unsupported_provider_value\nMyNotifier notifier(Ref ref) => MyNotifier();\n\n@riverpod\n```\n\n----------------------------------------\n\nTITLE: Using ChangeNotifierProvider to consume a provider\nDESCRIPTION: This code snippet demonstrates how to use Riverpod package APIs to consume a provider that uses `ChangeNotifierProvider`. This allows the continued use of `ChangeNotifier` within a Riverpod context.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/from_provider/quickstart.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nMultiProvider(\n  providers: [\n    ChangeNotifierProvider.value(value: ref.watch(myNotifierProvider.notifier)),\n  ]\n)\n```\n\n----------------------------------------\n\nTITLE: StateNotifier Class Provider\nDESCRIPTION: Demonstrates a class-based implementation of an unsupported StateNotifier provider\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/unsupported_provider_value/unsupported_provider_value_lint.md#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\n// expect_lint: unsupported_provider_value\nclass StateNotifierClass extends _$StateNotifierClass {\n  MyStateNotifier build() => MyStateNotifier();\n}\n```\n\n----------------------------------------\n\nTITLE: Updating ConsumerWidget and Consumer syntax in Dart\nDESCRIPTION: Changing the build method signature from using ScopedReader to WidgetRef in ConsumerWidget and Consumer for Riverpod 1.0.0.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/migration/0.14.0_to_1.0.0.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nclass Example extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, ScopedReader watch) {\n    int count = watch(counterProvider);\n    ...\n  }\n}\n\nConsumer(\n  builder: (context, watch, child) {\n    int count = watch(counterProvider);\n    ...\n  }\n)\n```\n\nLANGUAGE: dart\nCODE:\n```\nclass Example extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    int count = ref.watch(counterProvider);\n    ...\n  }\n}\n\nConsumer(\n  builder: (context, ref, child) {\n    int count = ref.watch(counterProvider);\n    ...\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Defining StateNotifierProvider with AutoDisposeFamily Syntax Change - Riverpod - Dart\nDESCRIPTION: Exemplifies the syntax change in defining a StateNotifierProvider with both autoDispose and family modifiers, showing the old and new recommended styles. Designed for Flutter apps using Riverpod. Requires Riverpod, Dart, Flutter SDKs. The provider provides a MyStateNotifier instance by id; the signature demonstrates how argument handling remains the same.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/flutter_riverpod/CHANGELOG.md#2025-04-23_snippet_28\n\nLANGUAGE: dart\nCODE:\n```\nfinal myProvider = AutoDisposeStateNotifierProviderFamily<MyStateNotifier, int>((ref, id) {\n  return MyStateNotifier(id: id);\n});\n```\n\nLANGUAGE: dart\nCODE:\n```\nfinal myProvider = StateNotifierProvider.autoDispose.family<MyStateNotifier, int>((ref, id) {\n  return MyStateNotifier(id: id);\n});\n```\n\n----------------------------------------\n\nTITLE: Legacy ChangeNotifierProvider Implementation\nDESCRIPTION: Shows how to use the legacy ChangeNotifierProvider for compatibility with existing code.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/essentials/websockets_sync.mdx#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nfinal counterProvider = ChangeNotifierProvider((ref) => Counter());\n```\n\n----------------------------------------\n\nTITLE: Read Notifier Provider Example - Dart\nDESCRIPTION: This snippet shows an example of reading a provider. It's not a standard method and could imply using `ref.read` but is dependent on the implementation in the corresponding file.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/concepts/reading.mdx#_snippet_13\n\nLANGUAGE: dart\nCODE:\n```\n/* ... content of reading_read_notifier_build.dart ... */\n```\n\n----------------------------------------\n\nTITLE: AsyncLoading<int?> Nullable Pattern Matching\nDESCRIPTION: Example showing unsafe pattern matching with AsyncLoading<int?> using nullable pattern. Demonstrates pattern that should be avoided according to the lint rule.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/async_value_nullable_pattern/async_value_nullable_pattern_lint.md#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n    case AsyncLoading<int?>(\n        // expect_lint: async_value_nullable_pattern\n        :final value?,\n      ):\n      print(value);\n```\n\n----------------------------------------\n\nTITLE: Error Example:  Incorrect .autoDispose Usage (Dart)\nDESCRIPTION: This code example demonstrates the error that occurs when an `autoDispose` provider is used by a non-`autoDispose` provider. This can lead to the `autoDispose` provider never being disposed of.  It highlights a common mistake and explains the reason for the error. Requires no dependencies, only understanding the error message.  Input is a ref.watch call within a non-autoDispose provider. The output is an error.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/es/docusaurus-plugin-content-docs/current/concepts/modifiers/auto_dispose.mdx#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nfinal firstProvider = Provider.autoDispose((ref) => 0);\n\nfinal secondProvider = Provider((ref) {\n  // The argument type 'AutoDisposeProvider<int>' can't be assigned to the\n  // parameter type 'AlwaysAliveProviderBase<Object, Null>'\n  ref.watch(firstProvider);\n});\n```\n\n----------------------------------------\n\nTITLE: Anti-Pattern: Calling ref.read Directly in Provider Body in Dart\nDESCRIPTION: Demonstrates an incorrect usage pattern where `ref.read(anotherProvider)` is called directly within the provider's creation callback. This is discouraged as it hides the dependency from Riverpod's tracking mechanisms and can lead to unexpected behavior or state inconsistencies; using `ref.watch` or passing `ref` to the created object and calling `read` later are the preferred alternatives.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#2025-04-23_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\nfinal anotherProvider = Provider((ref) => 42);\n\nfinal myProvider = Provider((ref) {\n  // DON'T call ref.read here\n  final value = ref.read(anotherProvider);\n\n  return MyValue(value);\n});\n```\n\n----------------------------------------\n\nTITLE: Whole Object Provider Example\nDESCRIPTION: Shows an anti-pattern of watching entire configuration object.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/concepts/combining_providers.mdx#2025-04-23_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\nfinal productsProvider = FutureProvider((ref) {\n  final config = ref.watch(configProvider);\n  return fetchProducts(config.host);\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling riverpod_lint in analysis_options.yaml\nDESCRIPTION: This snippet demonstrates how to enable riverpod_lint by adding the necessary configuration to the analysis_options.yaml file.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/introduction/getting_started.mdx#2025-04-23_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nanalyzer:\n  plugins:\n    - custom_lint\n```\n\n----------------------------------------\n\nTITLE: Single Unused Dependency in Provider\nDESCRIPTION: Test case showing single unused dependency 'dep' in a provider declaration\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/provider_dependencies/unused_dependency_lint.md#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n  keepAlive: false,\n  // expect_lint: provider_dependencies\n  dependencies: [\n    dep,\n  ],\n)\nint noDep(Ref ref) {\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of a Riverpod Family Provider in Dart\nDESCRIPTION: Illustrates the incorrect way to watch a provider defined with `.family`. Accessing `messagesFamily` directly within a `build` method using `ref.watch` without providing the required parameter will result in an error, as the family itself is not a provider but a function that returns one based on the parameter.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/modifiers/family.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nWidget build(BuildContext context, WidgetRef ref) {\n  // Error – messagesFamily is not a provider\n  final response = ref.watch(messagesFamily);\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Replacing context.read with ref.read - Dart\nDESCRIPTION: Shows how to replace `context.read` with `ref.read` for accessing provider notifiers in Riverpod 1.0.0. This change enforces using `WidgetRef` for accessing provider functionality within widgets.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/migration/0.14.0_to_1.0.0.mdx#_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nclass Example extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    SomeButton(\n      onPressed: () => context.read(provider.notifier).doSomething(),\n    );\n  }\n}\n```\n\nLANGUAGE: dart\nCODE:\n```\nclass Example extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    SomeButton(\n      onPressed: () => ref.read(provider.notifier).doSomething(),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing StateNotifier Before and After Update in Dart\nDESCRIPTION: Comparison of how to access the StateNotifier instance before and after the 0.14.0 update, introducing the use of .notifier.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/migration/0.13.0_to_0.14.0.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, ScopedReader watch) {\n  MyStateNotifier notifier = watch(provider);\n}\n```\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, ScopedReader watch) {\n  MyStateNotifier notifier = watch(provider.notifier);\n}\n```\n\n----------------------------------------\n\nTITLE: Reading Providers with Provider Package in Dart\nDESCRIPTION: This snippet demonstrates how to read providers using the Provider package. It shows the use of BuildContext to access the provider's value within a StatelessWidget.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/from_provider/provider_vs_riverpod.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nclass Example extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    Model model = context.watch<Model>();\n\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Root Dependency Provider\nDESCRIPTION: Test case showing unused root dependency in a provider declaration\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/provider_dependencies/unused_dependency_lint.md#2025-04-23_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\n  keepAlive: false,\n  // expect_lint: provider_dependencies\n  dependencies: [\n    root,\n  ],\n)\nint rootDep(Ref ref) => 0;\n```\n\n----------------------------------------\n\nTITLE: Warning against using ref.read inside provider build methods (Dart)\nDESCRIPTION: Advises avoiding calling `ref.read` within the main body of provider functions, as it can cause unintended behaviors or infinite rebuilds. Emphasizes correct patterns for dependency access.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/de/docusaurus-plugin-content-docs/current/concepts/combining_providers.mdx#_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nfinal myProvider = Provider((ref) {\n  // Bad practice: calling ref.read here can cause issues\n  final value = ref.read(anotherProvider);\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling riverpod_lint custom lint rules in analysis_options.yaml\nDESCRIPTION: This code snippet details how to activate the 'riverpod_lint' plugin by adding it to the 'analyzer.plugins' list within 'analysis_options.yaml', helping IDEs display warnings and perform linting during code analysis.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/introduction/getting_started.mdx#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nanalyzer:\n  plugins:\n    - custom_lint\n```\n\n----------------------------------------\n\nTITLE: Defining a Notifier in Dart (Old StateNotifier Syntax)\nDESCRIPTION: Example of defining a StateNotifier using the old syntax in Dart. This snippet shows how reactive dependencies and initialization were handled in StateNotifier.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/migration/from_state_notifier.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nfinal counterProvider = StateNotifierProvider<Counter, int>((ref) {\n  return Counter(ref.watch(initialCountProvider));\n});\n\nclass Counter extends StateNotifier<int> {\n  Counter(int initialCount) : super(initialCount);\n\n  void increment() => state++;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Product Data Structure and Sample List in Dart\nDESCRIPTION: Defines a `Product` class with `name` and `price` attributes. It also creates a constant list `products` containing sample `Product` instances. This list serves as the base data for the examples.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/providers/state_provider.mdx#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nimport 'package:meta/meta.dart';\n\n@immutable\nclass Product {\n  const Product({required this.name, required this.price});\n\n  final String name;\n  final double price;\n}\n\nconst products = [\n  Product(name: 'iPhone', price: 999),\n  Product(name: 'cookie', price: 2),\n  Product(name: 'ps5', price: 500),\n];\n```\n\n----------------------------------------\n\nTITLE: Example Diff Output Showing Deprecated to New Riverpod Syntax Change\nDESCRIPTION: Illustrates a typical output generated by the migration tool that shows the change from the old state access pattern (`watch(provider.state)`) to the new simplified one (`watch(provider)`). It provides a prompt for the developer to accept or reject the change interactively.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/tr/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_10\n\nLANGUAGE: diff\nCODE:\n```\nWidget build(BuildContext context, ScopedReader watch) {\n-  MyModel state = watch(provider.state);\n+  MyModel state = watch(provider);\n}\n\nAccept change (y = yes, n = no [default], A = yes to all, q = quit)? \n```\n\n----------------------------------------\n\nTITLE: Running Riverpod Tests\nDESCRIPTION: Commands to navigate to the examples directory, run the build runner, and execute Flutter tests.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_generator/integration/build_yaml/README.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncd examples/build_yaml\ndart run build_runner build\n\nflutter test\n```\n\n----------------------------------------\n\nTITLE: Defining MyModel and MyStateNotifier in Dart\nDESCRIPTION: This code defines a simple `MyModel` class and a `MyStateNotifier` class that extends `StateNotifier`. The `MyStateNotifier` is initialized with an instance of `MyModel`.  There are no explicit dependencies, but it depends on the `riverpod` package. The output is the initialization of the `MyStateNotifier` provider.  The model holds the application state.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nclass MyModel {}\n\nclass MyStateNotifier extends StateNotifier<MyModel> {\n  MyStateNotifier(): super(MyModel());\n}\n```\n\n----------------------------------------\n\nTITLE: Combining Providers (ProxyProvider - Provider)\nDESCRIPTION: This code snippet demonstrates how to combine providers in Provider using ProxyProvider. It takes a UserIdNotifier and generates a string based on the userId. The ProxyProvider updates whenever the UserIdNotifier's userId changes, creating a new String with the user ID.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/from_provider/provider_vs_riverpod.mdx#_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\nclass UserIdNotifier extends ChangeNotifier {\n  String? userId;\n}\n\n// ...\n\nChangeNotifierProvider<UserIdNotifier>(create: (context) => UserIdNotifier()),\n\nProxyProvider<UserIdNotifier, String>(\n  update: (context, userIdNotifier, _) {\n    return 'The user ID of the the user is ${userIdNotifier.userId}';\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Riverpod Code Generation Overview in Dart\nDESCRIPTION: Provides an explanation of code generation in Riverpod, highlighting how it simplifies provider declaration syntax, supports async primitives, and offers benefits like better readability, debug metadata, and future-proofing. Also covers how to enable and disable autoDispose, and how to pass parameters to providers using main functions instead of family modifier.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/concepts/about_code_generation.mdx#_snippet_2\n\n\n\n----------------------------------------\n\nTITLE: Migrate Riverpod Project - Shell\nDESCRIPTION: This command runs the Riverpod migration tool to automatically update the syntax in a project.  It should be executed from the project's root directory after the tool is installed and before updating Riverpod.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/migration/0.14.0_to_1.0.0.mdx#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nriverpod migrate\n```\n\n----------------------------------------\n\nTITLE: Running Riverpod Migration Tool - Shell\nDESCRIPTION: This snippet shows the command used to run the Riverpod migration tool on your project. The tool analyzes the existing project code and prompts the user to accept or reject suggested syntax upgrades to conform to Riverpod 1.0.0 standards. It requires the project to be opened in the terminal and the migration tool installed.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/bn/docusaurus-plugin-content-docs/current/migration/0.14.0_to_1.0.0.mdx#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nriverpod migrate\n```\n\n----------------------------------------\n\nTITLE: Reading Providers with Provider using Consumer\nDESCRIPTION: Example showing how to read a Model provider using the Consumer widget in Provider for optimized rebuilds.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/riverpod_for_provider_users.mdx#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nProvider<Model>(...);\n\nConsumer<Model>(\n  builder: (BuildContext context, Model model, Widget? child) {\n\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing UserNotifier with ChangeNotifierProxyProvider in Provider Package\nDESCRIPTION: Creates a UserNotifier that depends on UserIdNotifier using ChangeNotifierProxyProvider. This demonstrates how to combine stateful providers in the Provider package.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/zh-Hans/docusaurus-plugin-content-docs/current/from_provider/provider_vs_riverpod.mdx#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nclass UserNotifier extends ChangeNotifier {\n  String? _userId;\n\n  void setUserId(String? userId) {\n    if (userId != _userId) {\n      print('The user ID changed from $_userId to $userId');\n      _userId = userId;\n    }\n  }\n}\n\n// ...\n\nChangeNotifierProxyProvider<UserIdNotifier, UserNotifier>(\n  create: (context) => UserNotifier(),\n  update: (context, userIdNotifier, userNotifier) {\n    return userNotifier!\n      ..setUserId(userIdNotifier.userId);\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Defining Providers with Provider\nDESCRIPTION: Example of how to define a Counter provider using Provider package, where providers are widgets placed in the widget tree.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/riverpod_for_provider_users.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nclass Counter extends ChangeNotifier {\n ...\n}\n\nvoid main() {\n  runApp(\n    MultiProvider(\n      providers: [\n        ChangeNotifierProvider<Counter>(create: (context) => Counter()),\n      ],\n      child: MyApp(),\n    )\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Reading a Provider using Consumer Widget with Provider\nDESCRIPTION: Shows how to use the `Consumer` widget from the Provider package to read a provider. The builder function receives the `BuildContext`, the provider's value (`Model`), and an optional `child` widget.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/from_provider/provider_vs_riverpod.mdx#_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nConsumer<Model>(\n  builder: (BuildContext context, Model model, Widget? child) {\n\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Running Riverpod CLI Migration to Auto-Update Project Syntax in Shell\nDESCRIPTION: Command to execute the Riverpod migration tool which scans the project for deprecated Riverpod syntax and suggests changes to update to version 0.14.0. It prompts for user confirmation before applying each change.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_9\n\nLANGUAGE: sh\nCODE:\n```\nriverpod migrate\n```\n\n----------------------------------------\n\nTITLE: Installing Riverpod CLI Migration Tool\nDESCRIPTION: Installs the riverpod_cli tool globally using Dart's pub package manager. This tool assists in migrating Riverpod projects from older versions to newer ones.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/migration/0.14.0_to_1.0.0.mdx#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ndart pub global activate riverpod_cli\n```\n\n----------------------------------------\n\nTITLE: Installing Riverpod CLI Migration Tool - Shell\nDESCRIPTION: This snippet demonstrates how to globally activate the Riverpod CLI migration tool via Dart's package manager. It is a prerequisite for automatically migrating a project from Riverpod version 0.14.x to 1.0.0 using the command line. After installation, the CLI can be invoked with the 'riverpod' command to access help and migration functionality.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/bn/docusaurus-plugin-content-docs/current/migration/0.14.0_to_1.0.0.mdx#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ndart pub global activate riverpod_cli\n```\n\n----------------------------------------\n\nTITLE: Creating a Reusable Fade-In Hook in Dart\nDESCRIPTION: Example of extracting fade-in animation logic into a reusable custom hook function. This demonstrates how hooks can be composed and reused across different widgets to promote code reusability.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/about_hooks.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\ndouble useFadeIn() {\n  final animationController = useAnimationController(\n    duration: const Duration(seconds: 2),\n  );\n  useEffect(() {\n    animationController.forward();\n    return null;\n  }, const []);\n  useAnimation(animationController);\n  return animationController.value;\n}\n```\n\n----------------------------------------\n\nTITLE: Add riverpod dependency to pubspec.yaml\nDESCRIPTION: This YAML snippet adds the `riverpod` dependency to your `pubspec.yaml` file, along with the required Dart SDK version.  It is intended for Dart-only projects (i.e., those not using Flutter). After adding this snippet, run `pub get` in your terminal to install the dependency.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/bn/docusaurus-plugin-content-docs/current/getting_started.mdx#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nenvironment:\n  sdk: \">=2.12.0-0 <4.0.0\"\n\ndependencies:\n  riverpod: ^1.0.0-dev.10\n```\n\n----------------------------------------\n\nTITLE: Using multiple AnimationControllers with Hooks - Dart\nDESCRIPTION: This snippet demonstrates the ability to use multiple animation controllers within the same widget when using hooks.  It highlights that using multiple `useAnimationController` calls doesn't have negative consequences and allows for greater flexibility in managing animations.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/about_hooks.mdx#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n```dart\n  @override\n  Widget build(BuildContext context) {\n    final animationController = useAnimationController(\n      duration: const Duration(seconds: 2),\n    );\n    final anotherController = useAnimationController(\n      duration: const Duration(seconds: 2),\n    );\n\n    ...\n  }\n```\n```\n\n----------------------------------------\n\nTITLE: Installing Riverpod CLI Migration Tool using Dart\nDESCRIPTION: Command to install the Riverpod CLI migration tool using dart pub global activate.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/migration/0.13.0_to_0.14.0.mdx#2025-04-23_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\ndart pub global activate riverpod_cli\n```\n\n----------------------------------------\n\nTITLE: Example Diff Output Showing Syntax Change Suggestions for Riverpod Migration\nDESCRIPTION: Presents an example patch output illustrating the migration where the code changes from accessing provider.state to directly accessing provider. The tool offers interactive confirmation for applying such changes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_10\n\nLANGUAGE: diff\nCODE:\n```\nWidget build(BuildContext context, ScopedReader watch) {\n-  MyModel state = watch(provider.state);\n+  MyModel state = watch(provider);\n}\n\nAccept change (y = yes, n = no [default], A = yes to all, q = quit)? \n```\n\n----------------------------------------\n\nTITLE: Basic Activity Display Widget\nDESCRIPTION: Implements a basic widget to display the fetched activity without handling loading or error states.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/docs/case_studies/pull_to_refresh.mdx#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nclass ActivityPage extends ConsumerWidget {\n  const ActivityPage({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final activity = ref.watch(activityProvider).value;\n    if (activity == null) return const SizedBox.shrink();\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Activity suggestions')),\n      body: Center(\n        child: Text(activity.activity),\n      ),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Combining Providers (Stateful) using ChangeNotifierProxyProvider (Provider)\nDESCRIPTION: Demonstrates using `ChangeNotifierProxyProvider` from the Provider package. It creates a single instance of a stateful object (`UserNotifier`) and updates it whenever its dependency (`UserIdNotifier`) changes, allowing dependent stateful logic.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/from_provider/provider_vs_riverpod.mdx#_snippet_13\n\nLANGUAGE: dart\nCODE:\n```\nclass UserNotifier extends ChangeNotifier {\n  String? _userId;\n\n  void setUserId(String? userId) {\n    if (userId != _userId) {\n      print('The user ID changed from $_userId to $userId');\n      _userId = userId;\n    }\n  }\n}\n\n// ...\n\nChangeNotifierProxyProvider<UserIdNotifier, UserNotifier>(\n  create: (context) => UserNotifier(),\n  update: (context, userIdNotifier, userNotifier) {\n    return userNotifier!\n      ..setUserId(userIdNotifier.userId);\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Updating StreamProvider<T> Reading Pattern in Dart\nDESCRIPTION: Shows how to update from ref.read(StreamProvider<T>) returning a Stream<T> to the new approach where ref.watch(streamProvider.stream) is used to access the stream. The migration aligns with Riverpod 0.6.0's change in provider result types. Key parameter is the StreamProvider<T>-typed provider, expected to yield a Stream of type T.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/hooks_riverpod/CHANGELOG.md#_snippet_22\n\nLANGUAGE: dart\nCODE:\n```\nfinal streamProvider = StreamProvider<T>(...);\nfinal example = Provider((ref) {\n  Stream<T> stream = ref.read(streamProvider);\n});\n```\n\nLANGUAGE: dart\nCODE:\n```\nfinal streamProvider = StreamProvider<T>(...);\nfinal example = Provider((ref) {\n  Stream<T> stream = ref.watch(streamProvider.steam);\n});\n```\n\n----------------------------------------\n\nTITLE: Defining ConsumerWidget Build Method (Pre-1.0.0-dev.0) in Dart\nDESCRIPTION: Demonstrates the older signature of the `build` method within a `ConsumerWidget` before Riverpod version 1.0.0-dev.0. It utilized `ScopedReader watch` as the second parameter to access provider values.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/flutter_riverpod/CHANGELOG.md#2025-04-23_snippet_8\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nclass Example extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, ScopedReader watch) {\n    int count = watch(counterProvider);\n    ...\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Building a Stateless Widget for Todo Item in Flutter (Dart)\nDESCRIPTION: This snippet defines a StatelessWidget that takes a Todo object and displays its label text, essential for rendering individual TODO items within a Flutter UI.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/fr/docusaurus-plugin-content-docs/current/cookbooks/testing.mdx#_snippet_3\n\nLANGUAGE: Dart\nCODE:\n```\nclass TodoItem extends StatelessWidget {\n  const TodoItem({Key? key, required this.todo}) : super(key: key);\n  final Todo todo;\n  @override\n  Widget build(BuildContext context) {\n    return Text(todo.label);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Riverpod CLI Help - Shell\nDESCRIPTION: This command executes the Riverpod CLI with the `--help` flag, displaying the available commands and options.  It verifies that the CLI has been installed correctly and is accessible in the system's PATH.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\nriverpod --help\n```\n\n----------------------------------------\n\nTITLE: Mutable Manual Cache Update in Riverpod (Italian)\nDESCRIPTION: This snippet demonstrates manually updating the local cache using a mutable state. While not the recommended approach (immutable state is preferred), it shows how it can be implemented. The manual update mimics the expected server-side behavior.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/essentials/side_effects.mdx#_snippet_7\n\nLANGUAGE: dart\nCODE:\n```\nmutableManualAddTodo\n```\n\n----------------------------------------\n\nTITLE: Initializing ScopedProvider with Null (Dart)\nDESCRIPTION: Demonstrates initializing a `ScopedProvider` with `null` as the creation function, introduced in Riverpod 0.7.0. This is a shorthand that results in the provider throwing an `UnimplementedError` when read.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod/CHANGELOG.md#2025-04-23_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nfinal example = ScopedProvider<int>(null);\n```\n```\n\n----------------------------------------\n\nTITLE: Overriding Root Provider in Nested ProviderScope\nDESCRIPTION: This snippet demonstrates overriding a root provider in a nested ProviderScope, which should trigger the lint warning as it's not specifying dependencies in a non-root scope.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/scoped_providers_should_specify_dependencies/scoped_providers_should_specify_dependencies_lint.md#2025-04-23_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nrootProvider.overrideWith((ref) => 0)\n```\n\n----------------------------------------\n\nTITLE: Notifier Class Provider\nDESCRIPTION: Shows a class-based implementation of an unsupported Notifier provider\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/unsupported_provider_value/unsupported_provider_value_lint.md#2025-04-23_snippet_9\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\n// expect_lint: unsupported_provider_value\nclass NotifierClass extends _$NotifierClass {\n  MyNotifier build() => MyNotifier();\n}\n```\n\n----------------------------------------\n\nTITLE: StateNotifier Provider Implementation\nDESCRIPTION: Demonstrates an unsupported StateNotifier provider implementation using the @riverpod annotation\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/unsupported_provider_value/unsupported_provider_value_lint.md#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\n// expect_lint: unsupported_provider_value\nMyStateNotifier stateNotifier(Ref ref) => MyStateNotifier();\n\n@riverpod\n```\n\n----------------------------------------\n\nTITLE: Running Localized Riverpod Documentation (Shell)\nDESCRIPTION: Command to start the Riverpod documentation server with a specific locale (e.g., Japanese) for translation work.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/CONTRIBUTING.md#2025-04-23_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nyarn dev -l ja # When you are checking the Japanese docs locally\n```\n\n----------------------------------------\n\nTITLE: Reading Providers with Provider Package using Consumer Widget in Dart\nDESCRIPTION: Example showing how to read a provider using the Provider package with the Consumer widget, which allows for more granular rebuilds in the widget tree for better performance optimization.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/from_provider/provider_vs_riverpod.mdx#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nConsumer<Model>(\n  builder: (BuildContext context, Model model, Widget? child) {\n\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Incorrect Notifier Extension Example - Dart\nDESCRIPTION: Example of a class that fails lint checks because it extends AsyncNotifier<int> instead of the required _$ClassName pattern for @riverpod annotated classes.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/notifier_extends/failing_notifier_extends_lint.md#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n@riverpod\n// expect_lint: notifier_extends\nclass WrongExtends extends AsyncNotifier<int> {\n  int build() => 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Reading FutureProvider Pre-0.6.0 (Dart)\nDESCRIPTION: Demonstrates the old behavior (before Riverpod 0.6.0) where `ref.read(futureProvider)` directly returned the underlying `Future<T>`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod/CHANGELOG.md#2025-04-23_snippet_12\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nfinal futureProvider = FutureProvider<T>(...);\nfinal example = Provider((ref) {\n  Future<T> future = ref.read(futureProvider);\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Watching StreamProvider Stream From 0.6.0 (Dart)\nDESCRIPTION: Shows the new pattern introduced in Riverpod 0.6.0 for obtaining the `Stream<T>` from a `StreamProvider`. Instead of `ref.read`, use `ref.watch(streamProvider.stream)`. Note that `ref.read(streamProvider)` now returns an `AsyncValue<T>`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod/CHANGELOG.md#2025-04-23_snippet_11\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nfinal streamProvider = StreamProvider<T>(...);\nfinal example = Provider((ref) {\n  Stream<T> stream = ref.watch(streamProvider.steam);\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Overriding Root Provider in Non-Root ProviderScope\nDESCRIPTION: This snippet demonstrates overriding a root provider in a non-root ProviderScope without specifying dependencies, which triggers the lint warning.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/scoped_providers_should_specify_dependencies/scoped_providers_should_specify_dependencies_lint.md#2025-04-23_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nrootProvider.overrideWith((ref) => 0)\n```\n\n----------------------------------------\n\nTITLE: Accessing StateNotifier (Old Syntax) - Dart\nDESCRIPTION: This snippet shows how to access the StateNotifier instance using the old syntax before Riverpod 0.14.0. It directly reads the provider to get the StateNotifier instance.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, ScopedReader watch) {\n  MyStateNotifier notifier = watch(provider);\n}\n```\n\n----------------------------------------\n\nTITLE: Watching State (Before) in Dart\nDESCRIPTION: This code illustrates how to watch the state of a `StateNotifier` before version 0.14.0.  It uses `watch(provider.state)` to observe the state (MyModel).  It requires `riverpod`, `BuildContext`, and `ScopedReader`.  The output is the `MyModel` state.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, ScopedReader watch) {\n  MyModel state = watch(provider.state);\n}\n```\n\n----------------------------------------\n\nTITLE: StateNotifierProvider Definition (Old Syntax) - Dart\nDESCRIPTION: This snippet illustrates the old syntax for defining a StateNotifierProvider in Riverpod before version 0.14.0. It uses `StateNotifierProvider<MyStateNotifier>` without specifying the state type as a generic parameter.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nfinal provider = StateNotifierProvider<MyStateNotifier>((ref) {\n  return MyStateNotifier();\n});\n```\n\n----------------------------------------\n\nTITLE: Testing Legacy Provider Parameter Usage\nDESCRIPTION: Test cases for legacy provider parameter validation checking various factory and constructor calls.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/provider_parameters/provider_parameters_lint.md#2025-04-23_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n    ref.watch(legacy(const Bar()));\n    // expect_lint: provider_parameters\n    ref.watch(legacy(Factory.bar()));\n    ref.watch(legacy(const Factory.bar()));\n    ref.watch(legacy(Factory.foo()));\n```\n\n----------------------------------------\n\nTITLE: Defining Providers with Provider\nDESCRIPTION: This snippet demonstrates how to define a provider using the Provider package. It shows the creation of a ChangeNotifierProvider within a MultiProvider widget, which is placed at the top of the widget tree to make the Counter class available to the entire application. The Counter class extends ChangeNotifier, indicating it holds mutable state that can trigger UI updates.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/from_provider/provider_vs_riverpod.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nclass Counter extends ChangeNotifier {\n ...\n}\n\nvoid main() {\n  runApp(\n    MultiProvider(\n      providers: [\n        ChangeNotifierProvider<Counter>(create: (context) => Counter()),\n      ],\n      child: MyApp(),\n    )\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Activity Class with Flutter\nDESCRIPTION: This snippet defines the `Activity` class, which represents a proposed activity. It is used to structure and handle the data retrieved from an API. This class likely handles JSON encoding/decoding using Freezed or json_serializable, though it is not strictly required. The code ensures type safety by representing the fetched activity in a structured way.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/case_studies/pull_to_refresh.mdx#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\n\n```\n\n----------------------------------------\n\nTITLE: Accessing StateNotifier (Before) in Dart\nDESCRIPTION: This code snippet shows how to access the `StateNotifier` instance before version 0.14.0. It uses `watch(provider)` to get the `MyStateNotifier` instance within a `build` method. It's dependent on `riverpod` and the `BuildContext` and `ScopedReader`. The output is the `MyStateNotifier` instance.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ja/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, ScopedReader watch) {\n  MyStateNotifier notifier = watch(provider);\n}\n```\n\n----------------------------------------\n\nTITLE: Equivalent Unimplemented ScopedProvider (Dart)\nDESCRIPTION: Shows the explicit equivalent of initializing a `ScopedProvider` with `null`: defining it with a function that immediately throws an `UnimplementedError`. This clarifies the behavior shown in the previous snippet from Riverpod 0.7.0.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod/CHANGELOG.md#2025-04-23_snippet_7\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nfinal example = ScopedProvider<int>((watch) => throw UnimplementedError(''));\n```\n```\n\n----------------------------------------\n\nTITLE: Mapping StreamProvider Dependencies (Deprecated) Dart\nDESCRIPTION: Demonstrates a deprecated pattern for creating a StreamProvider that depends on the raw stream of another provider (b.stream). This method is discouraged.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/hooks_riverpod/CHANGELOG.md#_snippet_3\n\nLANGUAGE: Dart\nCODE:\n```\nfinal a = StreamProvider((ref) {\n  return ref.watch(b.stream).map((e) => Model(e));\n})\n```\n\n----------------------------------------\n\nTITLE: Accessing State from StateNotifierProvider with old Dart Riverpod Syntax\nDESCRIPTION: Demonstrates the legacy method of reading the state managed by a StateNotifierProvider by watching the provider's state property. This was the prior way to access the current state before the API revision.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/tr/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, ScopedReader watch) {\n  MyModel state = watch(provider.state);\n}\n```\n\n----------------------------------------\n\nTITLE: Verifying Riverpod CLI Installation (Shell)\nDESCRIPTION: Checks successful installation of riverpod_cli by running the basic help command. This should output available CLI options. Requires previous successful activation of the CLI tool.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#2025-04-23_snippet_8\n\nLANGUAGE: sh\nCODE:\n```\nriverpod --help\n```\n\n----------------------------------------\n\nTITLE: Accessing StateNotifier Instance with old Dart Riverpod Syntax\nDESCRIPTION: Illustrates how to read the StateNotifier instance directly from a provider in Riverpod versions prior to 0.14.0 by watching the provider itself. This is part of the former syntax where the provider's value was the StateNotifier instance.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/tr/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, ScopedReader watch) {\n  MyStateNotifier notifier = watch(provider);\n}\n```\n\n----------------------------------------\n\nTITLE: Usage example of AutoSnippet component for consuming configuration in Dart\nDESCRIPTION: This snippet demonstrates embedding a code component (`AutoSnippet`) with language Dart and a configuration object meant to illustrate how the user interface reacts to the completion of a FutureProvider, re-rendering dynamically upon data load or error states.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/tr/docusaurus-plugin-content-docs/current/providers/future_provider.mdx#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet language=\"dart\" {...configConsumer}></AutoSnippet>\n```\n\n----------------------------------------\n\nTITLE: AutoDispose Family Syntax Pre-0.4.0 (Dart)\nDESCRIPTION: Shows the older syntax used before Riverpod 0.4.0 for defining providers that combined modifiers (like `AutoDispose`) and families (like `Family`). This used combined type names like `AutoDisposeStateNotifierProviderFamily`.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod/CHANGELOG.md#2025-04-23_snippet_17\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nfinal myProvider = AutoDisposeStateNotifierProviderFamily<MyStateNotifier, int>((ref, id) {\n  return MyStateNotifier(id: id);\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Starting Riverpod Documentation Server (Shell)\nDESCRIPTION: Command to start the local development server for the Riverpod documentation website using Yarn.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/CONTRIBUTING.md#2025-04-23_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nyarn dev\n```\n\n----------------------------------------\n\nTITLE: Implementing a Fade-In Animation with StatefulWidget in Dart\nDESCRIPTION: Implementation of a fade-in animation using traditional StatefulWidget approach with AnimationController and SingleTickerProviderStateMixin. The widget starts invisible and gradually becomes visible over a 2-second period.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/about_hooks.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nclass FadeIn extends StatefulWidget {\n  const FadeIn({Key? key, required this.child}) : super(key: key);\n\n  final Widget child;\n\n  @override\n  State<FadeIn> createState() => _FadeInState();\n}\n\nclass _FadeInState extends State<FadeIn> with SingleTickerProviderStateMixin {\n  late final AnimationController animationController = AnimationController(\n    vsync: this,\n    duration: const Duration(seconds: 2),\n  );\n\n  @override\n  void initState() {\n    super.initState();\n    animationController.forward();\n  }\n\n  @override\n  void dispose() {\n    animationController.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return AnimatedBuilder(\n      animation: animationController,\n      builder: (context, child) {\n        return Opacity(\n          opacity: animationController.value,\n          child: widget.child,\n        );\n      },\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying Provider State Directly via ref.state (Post-1.0.0-dev.0) in Dart\nDESCRIPTION: Illustrates the `ref.state` property available on `ProviderRef`, `FutureProviderRef`, and `StreamProviderRef` since Riverpod 1.0.0-dev.0. This allows directly modifying the provider's exposed state from within its definition (e.g., in response to a `ref.listen` callback), which notifies listeners.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/flutter_riverpod/CHANGELOG.md#2025-04-23_snippet_15\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nProvider<int>((ref) {\n  ref.listen(onIncrementProvider, (_) {\n    ref.state++;\n  });\n\n  return 0;\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Listening to State (Old Syntax) - Dart\nDESCRIPTION: This snippet illustrates the old syntax for listening to the state of a StateNotifier before Riverpod 0.14.0. It used `provider.state` to access and listen to the state.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nWidget build(BuildContext context, ScopedReader watch) {\n  MyModel state = watch(provider.state);\n}\n```\n\n----------------------------------------\n\nTITLE: Activating Riverpod CLI Migration Tool via Dart Pub in Shell\nDESCRIPTION: Command to globally activate the Riverpod CLI tool using Dart's package manager. This CLI assists with automatic migration of Riverpod codebases from older syntax to version 0.14.0 standards. Requires Dart SDK and internet connectivity.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ru/docusaurus-plugin-content-docs/current/migration/0.13.0_to_0.14.0.mdx#_snippet_7\n\nLANGUAGE: sh\nCODE:\n```\ndart pub global activate riverpod_cli\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for Riverpod Website\nDESCRIPTION: Command to install the required dependencies for the Riverpod website using Yarn package manager.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ yarn\n```\n\n----------------------------------------\n\nTITLE: Testing Generator Provider with Map Parameters\nDESCRIPTION: Test cases for generator provider using map parameters to validate consistency checks.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/provider_parameters/provider_parameters_lint.md#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\n    ref.watch(generatorProvider(value: [42]));\n    // expect_lint: provider_parameters\n    ref.watch(generatorProvider(value: {'string': 42}));\n    // expect_lint: provider_parameters\n    ref.watch(generatorProvider(value: {42}));\n```\n\n----------------------------------------\n\nTITLE: Analyzing Unused Dependencies in Riverpod Provider (Dart)\nDESCRIPTION: This snippet demonstrates a Riverpod provider with multiple dependencies, where one is used and another is unused. It highlights the linting for unnecessary dependencies.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/provider_dependencies/missing_dependencies2_lint.md#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\n@Riverpod(\n  dependencies: [\n  dep,\n  generatedRoot,\n])\nint specifiedDependencyButNeverUsed(Ref ref) {\n  ref.watch(depProvider);\n  // Rest of the implementation\n}\n```\n\n----------------------------------------\n\nTITLE: Identifying Multiple Missing Dependencies in Riverpod Providers (Dart)\nDESCRIPTION: This snippet shows the lint detecting multiple missing dependencies in a Riverpod provider. The provider uses both 'depProvider' and 'dep2Provider' but declares an empty dependencies list.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/provider_dependencies/missing_dependencies_lint.md#2025-04-23_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\n@Riverpod(\n  keepAlive: false,\n  // expect_lint: provider_dependencies\n  dependencies: [],\n)\nint multipleDeps(Ref ref) {\n  ref.watch(depProvider);\n  ref.watch(dep2Provider);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Generator Provider with Set Parameters\nDESCRIPTION: Test cases for generator provider using set parameters and constant values.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/packages/riverpod_lint_flutter_test/test/lints/goldens/provider_parameters/provider_parameters_lint.md#2025-04-23_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\n    ref.watch(generatorProvider(value: {'string': 42}));\n    // expect_lint: provider_parameters\n    ref.watch(generatorProvider(value: {42}));\n    ref.watch(generatorProvider(value: const [42]));\n    ref.watch(generatorProvider(value: const {'string': 42}));\n```\n\n----------------------------------------\n\nTITLE: Version Metadata for Riverpod Documentation (Markdown)\nDESCRIPTION: Example of how to add or update version metadata in Riverpod documentation files to indicate when translations need updating.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/CONTRIBUTING.md#2025-04-23_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n---\ntitle: This is an example\nversion: 2\n# ^ This number needs to be incremented.\n# Doing so will show an outdated banner on all translations of this page.\n---\n\nSome content\n```\n\n----------------------------------------\n\nTITLE: Example Log Output from ProviderObserver\nDESCRIPTION: Illustrates the typical console output generated by the custom `Logger` (ProviderObserver implementation) when the 'counter' provider's value is updated to '1'. The output shows the provider name and the new value.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/concepts/provider_observer.mdx#2025-04-23_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nI/flutter (16783): {\nI/flutter (16783):   \"provider\": \"counter\",\nI/flutter (16783):   \"newValue\": \"1\"\nI/flutter (16783): }\n```\n\n----------------------------------------\n\nTITLE: Usage example of AutoSnippet component for configuring provider setup in Dart\nDESCRIPTION: This snippet shows how to embed a code component (`AutoSnippet`) with specified language and configuration object for integrating a FutureProvider setup within a Dart Flutter project. It implies the display of code blocks for configuring and consuming asynchronous data.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/tr/docusaurus-plugin-content-docs/current/providers/future_provider.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n<AutoSnippet language=\"dart\" {...configProvider}></AutoSnippet>\n```\n\n----------------------------------------\n\nTITLE: Defining a Fixed Product List in Dart\nDESCRIPTION: This snippet demonstrates how to declare a static list of products inside a Dart application, typically as a constant or immutable collection. No dependencies are required beyond the core Dart SDK. The list structure should be tailored to the application's data model, usually as a List of custom objects or maps. This is most useful for prototyping or when fetching from a backend is unnecessary. Inputs: none; Outputs: a local variable representing the initial product list.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/it/docusaurus-plugin-content-docs/current/providers/state_provider.mdx#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n/* Example Dart code for defining a fixed product list. Actual code is located in product.dart */\n```\n\n----------------------------------------\n\nTITLE: Building Korean locale with yarn\nDESCRIPTION: This command compiles the Korean translations and generates static files for deployment. It prepares the Korean version of the site for production release by bundling all localized content.\nSOURCE: https://github.com/rrousselgit/riverpod/blob/master/website/i18n/ko/NOTE.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n# 빌드\nyarn run build --locale ko\n```"
  }
]