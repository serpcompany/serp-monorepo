[
  {
    "owner": "theatre-js",
    "repo": "theatre",
    "content": "TITLE: Modifying Atom State Using Different Methods\nDESCRIPTION: Demonstrates multiple ways to change an Atom's state: replacing the entire state, using a reducer function, or using pointers for targeted updates to specific properties.\n\nLANGUAGE: ts\nCODE:\n```\n// replace the whole stae\natom.set({intensity: 1, position: {x: 0, y: 0}})\n\n// or using an update function\natom.reduce((state) => ({...state, intensity: state.intensity + 1}))\n\n// or much easier, using a pointer\natom.setByPointer(atom.pointer.intensity, 3)\n\natom.reduceByPointer(atom.pointer.intensity, (intensity) => intensity + 1)\n```\n\n----------------------------------------\n\nTITLE: Creating and Initializing an Atom in TypeScript\nDESCRIPTION: Example showing how to initialize an Atom with a structured state object. The Atom will hold the application state with properties that can be accessed and modified.\n\nLANGUAGE: ts\nCODE:\n```\nimport {Atom} from '@theatre/dataverse'\n\nconst atom = new Atom({intensity: 1, position: {x: 0, y: 0}})\n```\n\n----------------------------------------\n\nTITLE: Creating Derived Values with Prisms in TypeScript\nDESCRIPTION: Shows how to create a Prism that derives a computed value from an Atom. Prisms automatically update when their dependencies change, enabling reactive derived state.\n\nLANGUAGE: ts\nCODE:\n```\nimport {Atom, prism, val} from '@theatre/dataverse'\n\nconst atom = new Atom({a: 1, b: 2, foo: 10})\n\n// the value of this prism will always be equal to the sum of `a` and `b`\nconst sum = prism(() => {\n  const a = val(atom.pointer.a)\n  const b = val(atom.pointer.b)\n  return a + b\n})\n```\n\n----------------------------------------\n\nTITLE: Reading Atom State Reactively in React Components\nDESCRIPTION: Example showing how to reactively read Atom state in React components using the useVal hook. The component will automatically re-render when the referenced value changes.\n\nLANGUAGE: ts\nCODE:\n```\nimport {useVal} from '@theatre/react'\n\nfunction Component() {\n  const intensity = useVal(atom.pointer.intensity) // 4\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Using useVal with Dataverse pointers in React\nDESCRIPTION: Demonstrates how to use the useVal hook to access values from Dataverse Atom pointers within a React component. This hook makes the component reactive to changes in the referenced values.\n\nLANGUAGE: tsx\nCODE:\n```\nimport {Atom} from '@theatre/dataverse'\nimport {useVal} from '@theatre/react'\n\nconst atom = new Atom({foo: 'foo'})\n\nfunction Component() {\n  const foo = useVal(atom.pointer.foo)\n  return <div>{foo}</div>\n}\n```\n\n----------------------------------------\n\nTITLE: Reading Prism Values Reactively in React Components\nDESCRIPTION: Demonstrates using Prisms reactively in React components with the useVal hook. Components will re-render when the Prism's value changes.\n\nLANGUAGE: tsx\nCODE:\n```\nfunction Component() {\n  return (\n    <div>\n      {useVal(atom.pointer.a)} + {useVal(atom.pointer.b)} = {useVal(prism)}\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Using Component-Local Atoms with useAtom Hook\nDESCRIPTION: Shows how to define an Atom inside a React component using the useAtom hook, making state local to that component instance. This approach is useful for component-specific state management.\n\nLANGUAGE: tsx\nCODE:\n```\nimport {useAtom} form '@theatre/react'\n\nfunction Component() {\n  const atom = useAtom({count: 0, ready: false})\n  const ready = useVal(atom.pointer.ready)\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Using Atoms with React Components via useVal Hook\nDESCRIPTION: Example demonstrating how to create an Atom for state management and access it in a React component using the useVal hook. Shows conditional rendering based on the atom's state and event handling for state changes.\n\nLANGUAGE: tsx\nCODE:\n```\nimport {Atom} from '@theatre/dataverse'\nimport {useVal} from '@theatre/react'\nimport {useEffect} from 'react'\n\n// Atoms hold state\nconst atom = new Atom({count: 0, ready: false})\n\nconst increaseCount = () =>\n  atom.setByPointer(atom.pointer.count, (count) => count + 1)\n\nfunction Component() {\n  // useVal is a hook that subscribes to changes in a specific path inside the atom\n  const ready = useVal(\n    // atom.pointer is a type-safe way to refer to a path inside the atom\n    atom.pointer.ready,\n  )\n\n  if (!ready) {\n    return <div>Loading...</div>\n  } else {\n    return <button onClick={increaseCount}>Increase count</button>\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Constructing an Atom in TypeScript\nDESCRIPTION: Creates a new Atom instance with the provided initial state. The state can be of any type defined by the generic parameter State.\n\nLANGUAGE: typescript\nCODE:\n```\nâ€¢ **new Atom**<`State`\\>(`initialState`)\n```\n\n----------------------------------------\n\nTITLE: Using prism.effect() and prism.state() in Theatre.js\nDESCRIPTION: Demonstrates using prism.effect() for side effects and prism.state() for stateful values in prisms. The example creates a mouse position tracker with cleanup of event listeners when the prism is no longer needed.\n\nLANGUAGE: tsx\nCODE:\n```\nimport {prism} from '@theatre/dataverse'\nimport {useVal} from '@theatre/react'\n\n// This prism holds the current mouse position and updates when the mouse moves\nconst mousePositionPr = prism(() => {\n  const [pos, setPos] = prism.state<[x: number, y: number]>('pos', [0, 0])\n\n  prism.effect(\n    'setupListeners',\n    () => {\n      const handleMouseMove = (e: MouseEvent) => {\n        setPos([e.screenX, e.screenY])\n      }\n      document.addEventListener('mousemove', handleMouseMove)\n\n      return () => {\n        document.removeEventListener('mousemove', handleMouseMove)\n      }\n    },\n    [],\n  )\n\n  return pos\n})\n\nfunction Component() {\n  const [x, y] = useVal(mousePositionPr)\n  return (\n    <div>\n      Mouse position: {x}, {y}\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Creating reactive computations with usePrism in React\nDESCRIPTION: Demonstrates using the usePrism hook to create reactive computations in React components. This example shows how to reactively compute values based on both props and Dataverse state.\n\nLANGUAGE: tsx\nCODE:\n```\nimport {Atom, val, prism} from '@theatre/dataverse'\nimport {usePrism} from '@theatre/react'\n\nconst state = new Atom({a: 1, b: 1})\n\nfunction Component(props: {which: 'a' | 'b'}) {\n  const value = usePrism(\n    () => {\n      prism.isPrism() // true\n      // note that this function is running inside a prism, so all of prism's\n      // hooks (prism.memo(), prism.effect(), etc) are available\n      const num = val(props.which === 'a' ? state.pointer.a : state.pointer.b)\n      return doExpensiveComputation(num)\n    },\n    // since our prism reads `props.which`, we should include it in the deps array\n    [props.which],\n  )\n  return <div>{value}</div>\n}\n```\n\n----------------------------------------\n\nTITLE: Using prism.memo() for Memoization in Theatre.js\nDESCRIPTION: Demonstrates how to use prism.memo() to cache computation results, similar to React's useMemo() but with explicit keys. The example calculates factorials and shows how memoization prevents recalculation when dependencies don't change.\n\nLANGUAGE: typescript\nCODE:\n```\nimport {Atom, prism, val} from '@theatre/dataverse'\n\nconst atom = new Atom(0)\n\nfunction factorial(n: number): number {\n  if (n === 0) return 1\n  return n * factorial(n - 1)\n}\n\nconst p = prism(() => {\n  // num will be between 0 and 9. This is so we can test what happens when the atom's value changes, but\n  // the memoized value doesn't change.\n  const num = val(atom.pointer)\n  const numMod10 = num % 10\n  const value = prism.memo(\n    // we need a string key to identify the hook. This allows us to call `prism.memo()` in any order, or even conditionally.\n    'factorial',\n    // the function to memoize\n    () => {\n      console.log('Calculating factorial')\n      factorial(numMod10)\n    },\n    // the dependencies of the function. If any of the dependencies change, the function will be called again.\n    [numMod10],\n  )\n\n  return `number is ${num}, num % 10 is ${numMod10} and its factorial is ${value}`\n})\n\np.onChange(ticker, (value) => {\n  console.log('=>', value)\n})\n\natom.set(1)\n// Calculating factorial\n// => number is 1, num % 10 is 1 and its factorial is 1\n\natom.set(2)\n// Calculating factorial\n// => number is 2, num % 10 is 2 and its factorial is 2\n\natom.set(12) // won't recalculate the factorial\n// => number is 12, num % 10 is 2 and its factorial is 2\n```\n\n----------------------------------------\n\nTITLE: Using prism.source() Hook for External Value Integration\nDESCRIPTION: Demonstrates using the prism.source() hook to create a Prism that reads from and reacts to external sources like DOM elements. This example creates a Prism that tracks an input element's value.\n\nLANGUAGE: ts\nCODE:\n```\nfunction prismFromInputElement(input: HTMLInputElement): Prism<string> {\n  function subscribe(cb: (value: string) => void) {\n    const listener = () => {\n      cb(input.value)\n    }\n    input.addEventListener('input', listener)\n    return () => {\n      input.removeEventListener('input', listener)\n    }\n  }\n\n  function get() {\n    return input.value\n  }\n  return prism(() => prism.source(subscribe, get))\n}\n\nconst p = prismFromInputElement(document.querySelector('input'))\n\np.onChange(ticker, (value) => {\n  console.log('input value changed to', value)\n})\n```\n\n----------------------------------------\n\nTITLE: Using Tickers for Scheduled Computation in TypeScript\nDESCRIPTION: Demonstrates using Tickers to schedule and synchronize computations outside of React's render loop. Shows how to react to atom changes with onChange and batched updates.\n\nLANGUAGE: ts\nCODE:\n```\nimport {Ticker, onChange} from '@theatre/dataverse'\n\nconst ticker = new Ticker()\n\n// advance the ticker roughly 60 times per second (note that it's better to use requestAnimationFrame)\nsetInterval(ticker.tick, 1000 / 60)\n\nonChange(atom.pointer.intensity, (newIntensity) => {\n  console.log('intensity changed to', newIntensity)\n})\n\natom.setByPointer(atom.pointer.intensity, 3)\n\n// After a few milliseconds, logs 'intensity changed to 3'\n\nsetTimeout(() => {\n  atom.setByPointer(atom.pointer.intensity, 4)\n  atom.setByPointer(atom.pointer.intensity, 5)\n  // updates are batched because our ticker advances every 16ms, so we\n  // will only get one log for 'intensity changed to 5', even though we changed the intensity twice\n}, 1000)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Current Atom State\nDESCRIPTION: The get() method returns the current state of the atom. This is a simple accessor to obtain the entire state object.\n\nLANGUAGE: typescript\nCODE:\n```\nâ–¸ **get**(): `State`\n```\n\n----------------------------------------\n\nTITLE: Using Pointers for Type-Safe Property Access\nDESCRIPTION: Demonstrates type-safe property access using pointers, showing how TypeScript provides error checking for property access while also explaining runtime behavior with non-existent properties.\n\nLANGUAGE: ts\nCODE:\n```\nimport {Atom} from '@theatre/dataverse'\n\nconst atom = new Atom({intensity: 1, position: {x: 0, y: 0}})\n\natom.setByPointer(atom.pointer.intensity, 3) // will set the intensity to 3\n\n// referring to a non-existing property is a typescript error, but it'll work at runtime\natom.setByPointer(atom.pointer.nonExistingProperty, 3)\n\natom.get() // {intensity: 3, position: {x: 0, y: 0}, nonExistingProperty: 3}\n```\n\n----------------------------------------\n\nTITLE: Creating local state with useAtom in React\nDESCRIPTION: Demonstrates using the useAtom hook to create component-local state that doesn't trigger re-renders when changed. This provides a more efficient way to manage component state when used with other hooks like useVal.\n\nLANGUAGE: tsx\nCODE:\n```\nimport {useAtom, useVal} from '@theatre/react'\nimport {useEffect} from 'react'\n\nfunction MyComponent() {\n  const atom = useAtom({count: 0, ready: false})\n\n  const onClick = () =>\n    atom.setByPointer(\n      (p) => p.count,\n      (count) => count + 1,\n    )\n\n  useEffect(() => {\n    setTimeout(() => {\n      atom.setByPointer((p) => p.ready, true)\n    }, 1000)\n  }, [])\n\n  const ready = useVal(atom.pointer.ready)\n  if (!ready) return <div>Loading...</div>\n  return <button onClick={onClick}>Click me</button>\n}\n```\n\n----------------------------------------\n\nTITLE: Reading Prism Values Non-Reactively in TypeScript\nDESCRIPTION: Shows how to read the current value of a Prism non-reactively using the val function. Also demonstrates how Prism values update when their dependencies change.\n\nLANGUAGE: ts\nCODE:\n```\nconsole.log(val(prism)) // 3\n\natom.setByPointer(atom.pointer.a, 2)\nconsole.log(val(prism)) // 4\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Pointer Value Changes\nDESCRIPTION: Registers a callback function that will be executed whenever the value at a specific path changes. The callback receives only the value at that path, not the entire state.\n\nLANGUAGE: typescript\nCODE:\n```\nâ–¸ **onChangeByPointer**<`S`\\>(`pointerOrFn`, `cb`): () => `void`\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Atom State Changes\nDESCRIPTION: Registers a callback function that will be executed whenever the atom's state changes. Returns an unsubscribe function to remove the listener.\n\nLANGUAGE: typescript\nCODE:\n```\nâ–¸ **onChange**(`cb`): () => `void`\n```\n\n----------------------------------------\n\nTITLE: Optimizing with prism.sub() in Theatre.js\nDESCRIPTION: Shows how to use prism.sub() to optimize prisms by dividing them into sub-prisms that only recalculate when specific dependencies change. The example demonstrates calculating factorials for different values independently.\n\nLANGUAGE: typescript\nCODE:\n```\nfunction factorial(num: number): number {\n  if (num === 0) return 1\n  return num * factorial(num - 1)\n}\n\nconst events: Array<'foo-calculated' | 'bar-calculated'> = []\n\n// example:\nconst state = new Atom({foo: 0, bar: 0})\nconst pr = prism(() => {\n  const resultOfFoo = prism.sub(\n    'foo',\n    () => {\n      events.push('foo-calculated')\n      const foo = val(state.pointer.foo) % 10\n      // Note how `prism.sub()` is more powerful than `prism.memo()` because it allows us to use `prism.memo()` and other hooks inside of it:\n      return prism.memo('factorial', () => factorial(foo), [foo])\n    },\n    [],\n  )\n  const resultOfBar = prism.sub(\n    'bar',\n    () => {\n      events.push('bar-calculated')\n      const bar = val(state.pointer.bar) % 10\n\n      return prism.memo('factorial', () => factorial(bar), [bar])\n    },\n    [],\n  )\n\n  return `result of foo is ${resultOfFoo}, result of bar is ${resultOfBar}`\n})\n\nconst unsub = pr.onChange(ticker, () => {})\n// on the first run, both subs should be calculated:\nconsole.log(events) // ['foo-calculated', 'bar-calculated']\nevents.length = 0 // clear the events array\n\n// now if we change the value of `bar`, only `bar` should be recalculated:\nstate.setByPointer(state.pointer.bar, 2)\npr.getValue()\nconsole.log(events) // ['bar-calculated']\n\nunsub()\n```\n\n----------------------------------------\n\nTITLE: Integrating Prisms with React using usePrism() Hook\nDESCRIPTION: Shows how to use the usePrism() React hook to create prisms within React components. This optimizes React components by moving heavy computations outside of React's render loop.\n\nLANGUAGE: tsx\nCODE:\n```\nimport {usePrism} from '@theatre/react'\n\nfunction Component() {\n  const value = usePrism(() => {\n    // [insert heavy calculation here]\n  }, [])\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Prism States in TypeScript\nDESCRIPTION: TypeScript type definition for the three possible states of a prism: Cold, Hot-Stale, and Hot-Fresh.\n\nLANGUAGE: typescript\nCODE:\n```\ntype PrismState =\n  | {isHot: false} // ðŸ§Š\n  | {isHot: true; isFresh: false} // ðŸ”¥ðŸªµ\n  | {isHot: true; isFresh: true} // ðŸ”¥ðŸŒ²\n```\n\n----------------------------------------\n\nTITLE: Using prism.state() for Reactive State Management in TypeScript\nDESCRIPTION: Example demonstrating how to use prism.state() to create reactive state within a prism, complete with effects for handling DOM events.\n\nLANGUAGE: typescript\nCODE:\n```\nimport {prism} from 'dataverse'\n\n// This prism holds the current mouse position and updates when the mouse moves\nconst mousePositionD = prism(() => {\n  const [pos, setPos] = prism.state<[x: number, y: number]>('pos', [0, 0])\n\n  prism.effect(\n    'setupListeners',\n    () => {\n      const handleMouseMove = (e: MouseEvent) => {\n        setPos([e.screenX, e.screenY])\n      }\n      document.addEventListener('mousemove', handleMouseMove)\n\n      return () => {\n        document.removeEventListener('mousemove', handleMouseMove)\n      }\n    },\n    [],\n  )\n\n  return pos\n})\n```\n\n----------------------------------------\n\nTITLE: Using pre-created prisms with usePrismInstance in React\nDESCRIPTION: Shows how to use the usePrismInstance hook to subscribe a React component to a pre-created prism. This is useful when you want to reuse the same prism across multiple components.\n\nLANGUAGE: tsx\nCODE:\n```\nimport {Atom, val, prism} from '@theatre/dataverse'\nimport {usePrismInstance} from '@theatre/react'\n\nconst state = new Atom({a: 1, b: 1})\n\nconst p = prism(() => {\n  return val(state.pointer.a) + val(state.pointer.b)\n})\n\nfunction Component() {\n  const value = usePrismInstance(p)\n  return <div>{value}</div>\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Prism State Transitions with onStale()\nDESCRIPTION: Example showing how a prism transitions between states when using onStale() subscription and updating atom values.\n\nLANGUAGE: typescript\nCODE:\n```\nconst atom = new Atom(0)\nconst a = prism(() => val(atom.pointer)) // ðŸ§Š\n\n// onStale(cb) calls `cb` when the prism goes from ðŸŒ² to ðŸªµ\na.onStale(() => {\n  console.log('a is stale')\n})\n// a from ðŸ§Š to ðŸ”¥\n// console: a is stale\n\n// reading the value of `a` will cause it to recalculate, and make it ðŸŒ² fresh.\nconsole.log(val(a)) // 1\n// a from ðŸ”¥ðŸªµ to ðŸ”¥ðŸŒ²\n\natom.set(1)\n// a from ðŸ”¥ðŸŒ² to ðŸ”¥ðŸªµ\n// console: a is stale\n\n// reading the value of `a` will cause it to recalculate, and make it ðŸŒ² fresh.\nconsole.log(val(a)) // 2\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Prism State Propagation in Dependency Graphs\nDESCRIPTION: Example showing how prism states propagate through dependency graphs when subscriptions are added or removed, and when values are read or updated.\n\nLANGUAGE: typescript\nCODE:\n```\nconst atom = new Atom({a: 0, b: 0})\nconst a = prism(() => val(atom.pointer.a))\nconst b = prism(() => val(atom.pointer.b))\nconst sum = prism(() => val(a) + val(b))\n\n//    a    |    b    |   sum    |\n//    ðŸ§Š   |    ðŸ§Š    |    ðŸ§Š    |\n\nlet unsub = a.onStale(() => {})\n\n// there is now a subscription to `a`, so it's ðŸ”¥ hot\n//    a    |    b    |   sum    |\n//    ðŸ”¥ðŸªµ  |    ðŸ§Š   |    ðŸ§Š    |\n\nunsub()\n// there are no subscriptions to `a`, so it's ðŸ§Š cold again\n//    a    |    b    |   sum    |\n//    ðŸ§Š   |    ðŸ§Š    |    ðŸ§Š    |\n\nunsub = sum.onStale(() => {})\n// there is now a subscription to `sum`, so it goes ðŸ”¥ hot, and so do its dependencies\n//    a    |    b    |   sum    |\n//    ðŸ”¥ðŸªµ  |    ðŸ”¥ðŸªµ  |    ðŸ”¥ðŸªµ  |\n\nval(sum)\n// reading the value of `sum` will cause it to recalculate, and make it ðŸŒ² fresh.\n//    a    |    b    |   sum    |\n//    ðŸ”¥ðŸŒ²  |    ðŸ”¥ðŸŒ²  |    ðŸ”¥ðŸŒ²  |\n\natom.setByPointer(atom.pointer.a, 1)\n// `a` is now stale, which will cause `sum` to become stale as well\n//    a    |    b    |   sum    |\n//    ðŸ”¥ðŸªµ  |    ðŸ”¥ðŸŒ²  |    ðŸ”¥ðŸªµ  |\n\nval(a)\n// reading the value of `a` will cause it to recalculate, and make it ðŸŒ² fresh. But notice that `sum` is still ðŸªµ stale.\n//    a    |    b    |   sum    |\n//    ðŸ”¥ðŸŒ²  |    ðŸ”¥ðŸŒ²  |    ðŸ”¥ðŸªµ  |\n\natom.setByPointer(atom.pointer.b, 1)\n// `b` now goes stale. Since sum was already stale, it will remain so\n//    a    |    b    |   sum    |\n//    ðŸ”¥ðŸŒ²  |    ðŸ”¥ðŸªµ  |    ðŸ”¥ðŸªµ  |\n\nval(sum)\n// reading the value of `sum` will cause it to recalculate and go ðŸŒ² fresh.\n//    a    |    b    |   sum    |\n//    ðŸ”¥ðŸŒ²  |    ðŸ”¥ðŸŒ²  |    ðŸ”¥ðŸŒ²  |\n\nunsub()\n// there are no subscriptions to `sum`, so it goes ðŸ§Š cold again, and so do its dependencies, since they don't have any other hot dependents\n//    a    |    b    |   sum    |\n//    ðŸ§Š   |    ðŸ§Š    |    ðŸ§Š    |\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Topological Order in Prism State Transitions\nDESCRIPTION: Example showing how prism state transitions propagate in topological order through a more complex dependency graph with multiple levels.\n\nLANGUAGE: typescript\nCODE:\n```\n// continued from the previous example\n\nconst double = prism(() => val(sum) * 2)\n\n// Initially, all prisms are ðŸ§Š cold\n//    a    |    b    |   sum    |  double  |\n//    ðŸ§Š   |    ðŸ§Š    |    ðŸ§Š    |    ðŸ§Š    |\n\nlet unsub = double.onStale(() => {})\n// here is how the state transitions will happen, step by step:\n// (step)   |   a    |    b    |   sum    |  double  |\n//    1     |   ðŸ§Š   |    ðŸ§Š    |    ðŸ§Š    |    ðŸ”¥ðŸªµ   |\n//    2     |   ðŸ§Š   |    ðŸ§Š    |   ðŸ”¥ðŸªµ   |    ðŸ”¥ðŸªµ   |\n//    3     |   ðŸ”¥ðŸªµ  |   ðŸ”¥ðŸªµ   |   ðŸ”¥ðŸªµ   |    ðŸ”¥ðŸªµ   |\n\nval(double)\n// freshening happens in the reverse order\n// (step)   |   a    |    b    |   sum    |  double  |\n//    0     |   ðŸ”¥ðŸªµ  |   ðŸ”¥ðŸªµ  |   ðŸ”¥ðŸªµ    |    ðŸ”¥ðŸªµ   |\n// --------------------------------------------------|\n//    1                              â–²         â–¼     | double reads the value of sum\n//                                   â””â”€â”€â”€â”€â—„â”€â”€â”€â”€â”˜     |\n// --------------------------------------------------|\n//    2          â–²        â–²          â–¼               | sum reads the value of a and b\n//               â”‚        â”‚          â”‚               |\n//               â””â”€â”€â”€â”€â—„â”€â”€â”€â”´â”€â”€â”€â”€â—„â”€â”€â”€â”€â”€â”˜               |\n// --------------------------------------------------|\n//    3     |   ðŸ”¥ðŸŒ²  |   ðŸ”¥ðŸŒ²  |   ðŸ”¥ðŸªµ    |    ðŸ”¥ðŸªµ   | a and b go fresh\n// --------------------------------------------------|\n//    4     |   ðŸ”¥ðŸŒ²  |   ðŸ”¥ðŸŒ²  |   ðŸ”¥ðŸŒ²    |    ðŸ”¥ðŸªµ   | sum goes fresh\n// --------------------------------------------------|\n//    5     |   ðŸ”¥ðŸŒ²  |   ðŸ”¥ðŸŒ²  |   ðŸ”¥ðŸŒ²    |    ðŸ”¥ðŸŒ²   | double goes fresh\n// --------------------------------------------------|\n```\n\n----------------------------------------\n\nTITLE: Creating a Prism from a Pointer\nDESCRIPTION: Creates a new Prism that tracks the value at a specific pointer path. This enables reactive programming with the pointer's value.\n\nLANGUAGE: typescript\nCODE:\n```\nâ–¸ **pointerToPrism**<`P`\\>(`pointer`): [`Prism`](../interfaces/Prism-1.md)<`P`\\>\n```\n\n----------------------------------------\n\nTITLE: Getting Value by Pointer\nDESCRIPTION: Retrieves a value at a specific path in the atom's state using a pointer. Can accept either a direct pointer or a function that returns a pointer.\n\nLANGUAGE: typescript\nCODE:\n```\nâ–¸ **getByPointer**<`S`\\>(`pointerOrFn`): `S`\n```\n\n----------------------------------------\n\nTITLE: Setting Value by Pointer\nDESCRIPTION: Updates a specific part of the atom's state using a pointer to target the desired path. Accepts either a direct pointer or a function that returns a pointer.\n\nLANGUAGE: typescript\nCODE:\n```\nâ–¸ **setByPointer**<`S`\\>(`pointerOrFn`, `val`): `void`\n```\n\n----------------------------------------\n\nTITLE: Reducing Atom State\nDESCRIPTION: Applies a reducer function to transform the entire state. The reducer takes the current state and should return the new state.\n\nLANGUAGE: typescript\nCODE:\n```\nâ–¸ **reduce**(`fn`): `void`\n```\n\n----------------------------------------\n\nTITLE: Reducing State by Pointer\nDESCRIPTION: Applies a reducer function to a specific part of the state defined by a pointer. The reducer takes the current value at that path and returns the new value.\n\nLANGUAGE: typescript\nCODE:\n```\nâ–¸ **reduceByPointer**<`S`\\>(`pointerOrFn`, `reducer`): `void`\n```\n\n----------------------------------------\n\nTITLE: Basic Theatric Setup with React\nDESCRIPTION: Basic example showing how to set up Theatric with React. The code demonstrates rendering a simple app that uses the useControls hook to create adjustable properties.\n\nLANGUAGE: tsx\nCODE:\n```\n// index.jsx\nReactDOM.render(<App />, document.getElementById('root'))\n\n// App.jsx\nimport {useControls} from 'theatric'\nimport React from 'react'\n\nexport default function App() {\n  const {name, age} = useControls({name: 'Andrew', age: 28})\n\n  return (\n    <div>\n      Hey, I'm {name} and I'm {age} years old.\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Using useControls Hook with Basic Properties\nDESCRIPTION: Example showing how to use the useControls hook to create interactive controls for component properties. The hook returns the current values that can be used in the component rendering.\n\nLANGUAGE: tsx\nCODE:\n```\nimport {useControls} from 'theatric'\n\nfunction Introduction() {\n  const {name, age} = useControls({name: 'Andrew', age: 28})\n\n  return (\n    <div>\n      Hey, I'm {name} and I'm {age} years old.\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Using Folders to Namespace Controls\nDESCRIPTION: Example demonstrating how to use the folder option to namespace controls, which is useful when you have multiple instances of the same component to prevent control collisions.\n\nLANGUAGE: tsx\nCODE:\n```\nimport {useControls} from 'theatric'\n\nfunction Introduction({id}) {\n  const {name, age} = useControls({name: 'Andrew', age: 28}, {folder: id})\n\n  return (\n    <div>\n      Hey, I'm {name} and I'm {age} years old.\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Using $get and $set for Imperative Value Control\nDESCRIPTION: Example showing how to use the $get and $set special properties returned by useControls to imperatively get and set control values, allowing for programmatic manipulation of controlled values.\n\nLANGUAGE: tsx\nCODE:\n```\nimport {useControls} from 'theatric'\n\nfunction Introduction() {\n  const {name, age, $get, $set} = useControls({name: 'Andrew', age: 28})\n\n  const increaseAge = useCallback(() => {\n    $set((values) => values.age, $get((values) => values.age) + 1)\n  }, [$get, $set])\n\n  return (\n    <div>\n      <div>\n        Hey, I'm {name} and I'm {age} years old.\n      </div>\n      <button onClick={increaseAge}>Increase age</button>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Button Controls to Trigger Actions\nDESCRIPTION: Example showing how to add button controls to the panel that can trigger actions. This combines the button control with $get and $set methods to create a more convenient UI.\n\nLANGUAGE: tsx\nCODE:\n```\nimport {useControls, button} from 'theatric'\n\nfunction Introduction() {\n  const {name, age, $get, $set} = useControls({\n    name: 'Andrew',\n    age: 28,\n    IncrementAge: button(() => {\n      $set((values) => values.age, $get((values) => values.age) + 1)\n    }),\n  })\n\n  return (\n    <div>\n      <div>\n        Hey, I'm {name} and I'm {age} years old.\n      </div>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Nested Properties with $get and $set\nDESCRIPTION: Example demonstrating how to use $get and $set with pointers to access and modify nested properties in the control structure, allowing for more complex data models.\n\nLANGUAGE: tsx\nCODE:\n```\nimport {useControls, button} from 'theatric'\n\nfunction Introduction() {\n  const {person, $get, $set} = useControls({\n    // note how name and age are sub-props of person\n    person: {\n      name: 'Andrew',\n      age: 28,\n    },\n    \n    IncrementAge: button(() => {\n      // values.person.age is a pointer to the age prop of the person object\n      $set((values) => values.person.age, $get((values) => values.person.age) + 1)\n    }),\n  })\n\n  return (\n    <div>\n      <div>\n        Hey, I'm {person.name} and I'm {person.age} years old.\n      </div>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Using Advanced Control Types\nDESCRIPTION: Example demonstrating how to use the types export to provide more advanced options for controls, such as specifying ranges for numbers or adjusting scrubbing sensitivity.\n\nLANGUAGE: tsx\nCODE:\n```\nimport {useControls, types} from 'theatric'\n\nfunction Introduction() {\n  const {name, age} = useControls({\n    name: 'Andrew',\n    age: types.number(28, {\n      // The range allowed in the UI (just a visual guide, not a validation rule)\n      range: [0, 10],\n      // Factor influencing the mouse-sensitivity when scrubbing the input\n      nudgeMultiplier: 0.1,\n    }),\n  })\n\n  return (\n    <div>\n      Hey, I'm {name} and I'm {age} years old.\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Using Image Assets with Theatric\nDESCRIPTION: Example showing how to use image assets in Theatric controls. It demonstrates initializing with asset configuration, using the types.image control, and retrieving asset URLs with getAssetUrl.\n\nLANGUAGE: tsx\nCODE:\n```\nimport {initialize, useControls, types, getAssetUrl} from 'theatric'\nimport theatricState from './theatricState.json'\n\ninitialize({\n  // if you're using assets in your controls, you can specify the base URL here.\n  \n  assets: {\n    // Defaults to '/'\n    // If you host your assets on a different domain, you can specify it here.\n    // For example if you're hosting your assets on https://cdn.example.com/theatric-assets\n    // you can set this to 'https://cdn.example.com/theatric-assets' (no trailing slash)\n    baseUrl: '/theatric-assets',\n  },\n}).then(() => {\n  // this is only necessary if you're using assets such as .hdr images in your prop values.\n  // awaiting the initialization ensures that the assets are loaded before rendering the app.\n  ReactDOM.render(<App />, document.getElementById('root'))\n})\n\nfunction App() {\n  const {img} = useControls({\n    // this will accept jpegs/pngs/hdrs/etc\n    // its default value is '' (empty string)\n    // learn more about assets here: https://www.theatrejs.com/docs/latest/manual/assets\n    img: types.image('')\n  })\n\n  const src = getAssetUrl(img)\n\n  return (\n    <div>\n      <img src={src} />\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Theatre.js R3F Implementation in React\nDESCRIPTION: Example React component showing how to set up Theatre.js with React Three Fiber. Demonstrates initialization, SheetProvider usage, and creating editable 3D objects with initial properties.\n\nLANGUAGE: tsx\nCODE:\n```\nimport React from 'react';\nimport { Canvas } from 'react-three-fiber';\nimport {editable as e, SheetProvider, extension} from '@theatre/r3f';\nimport studio from '@theatre/studio';\n\nstudio.extend(extension)\nstudio.initialize()\n\nexport default function App() {\n  return (\n    <Canvas>\n      <SheetProvider\n        sheet={getProject('Playground - R3F').sheet('R3F-Canvas')}\n      >\n          <ambientLight intensity={0.5} />\n          {/* Mark objects as editable. */}\n          {/* Properties in the code are used as initial values and reset points in the editor. */}\n          <e.spotLight\n            position={[10, 10, 10]}\n            angle={0.15}\n            penumbra={1}\n            theatreKey=\"Spotlight\"\n          />\n          <e.pointLight theatreKey=\"PointLight\" />\n          <e.mesh theatreKey=\"Box\">\n            <boxBufferGeometry />\n            <meshStandardMaterial color=\"orange\" />\n          </e.mesh>\n      </SheetProvider>\n    </Canvas>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Editable Components with Theatre.js R3F\nDESCRIPTION: Example of wrapping a custom component with the editable function to make it compatible with Theatre.js R3F. Shows how to specify the object type (perspectiveCamera) when creating an editable version of a component.\n\nLANGUAGE: ts\nCODE:\n```\nimport { editable } from '@theatre/r3f';\nimport { PerspectiveCamera } from '@react-three/drei';\n\nconst EditableCamera = editable(PerspectiveCamera, 'perspectiveCamera');\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Pointers with Prisms in TypeScript\nDESCRIPTION: This example demonstrates how to create pointers to properties of an Atom and use them in a prism to compute a value. The sum prism will update whenever the referenced atom properties change.\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Here, sum is a prism that updates whenever the a or b prop of someAtom does.\nconst sum = prism(() => {\n  return val(pointer({root: someAtom, path: ['a']})) + val(pointer({root: someAtom, path: ['b']}));\n});\n\n// Note, atoms have a convenience Atom.pointer property that points to the root,\n// which you would normally use in this situation.\nconst sum = prism(() => {\n  return val(someAtom.pointer.a) + val(someAtom.pointer.b);\n});\n```\n\n----------------------------------------\n\nTITLE: Getting Pointer Parts in TypeScript\nDESCRIPTION: Example showing how to extract the root object and path from a pointer using the getPointerParts function. This is useful when you need to work with the underlying structure of a pointer.\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst {root, path} = getPointerParts(pointer)\n```\n\n----------------------------------------\n\nTITLE: Using prism.ensurePrism() in TypeScript\nDESCRIPTION: Demonstrates how to use the prism.ensurePrism() function to validate that code is running inside a prism context, throwing an error if it's not.\n\nLANGUAGE: typescript\nCODE:\n```\nimport {prism} from '@theatre/dataverse'\n\nfunction onlyUsefulInAPrism() {\n  prism.ensurePrism()\n}\n\nprism(() => {\n  onlyUsefulInAPrism() // will run fine\n})\n\nsetTimeout(() => {\n  onlyUsefulInAPrism() // throws an error\n  console.log('This will never get logged')\n}, 0)\n```\n\n----------------------------------------\n\nTITLE: Using prism.memo() for Memoization in TypeScript\nDESCRIPTION: Example showing how to use prism.memo() to memoize expensive function calls within a prism, similar to React's useMemo but with an explicit key parameter.\n\nLANGUAGE: typescript\nCODE:\n```\nconst pr = prism(() => {\n const memoizedReturnValueOfExpensiveFn = prism.memo(\"memo1\", expensiveFn, [])\n})\n```\n\n----------------------------------------\n\nTITLE: Using prism.ref() to Maintain References in TypeScript\nDESCRIPTION: Demonstrates how prism.ref() works similarly to React's useRef(), creating a mutable reference that persists between prism evaluation cycles.\n\nLANGUAGE: typescript\nCODE:\n```\nconst pr = prism(() => {\n  const ref1 = prism.ref(\"ref1\", 0)\n  console.log(ref1.current) // will print 0, and if the prism is hot, it'll print the current value\n  ref1.current++ // changing the current value of the ref\n})\n```\n\n----------------------------------------\n\nTITLE: Using prism.source() to Connect External Sources in TypeScript\nDESCRIPTION: Shows how to use prism.source() to make a prism reactive to external data sources, creating a bridge between non-prism and prism-based reactivity systems.\n\nLANGUAGE: typescript\nCODE:\n```\nfunction prismFromInputElement(input: HTMLInputElement): Prism<string> {\n  function listen(cb: (value: string) => void) {\n    const listener = () => {\n      cb(input.value)\n    }\n    input.addEventListener('input', listener)\n    return () => {\n      input.removeEventListener('input', listener)\n    }\n  }\n  \n  function get() {\n    return input.value\n  }\n  return prism(() => prism.source(listen, get))\n}\n```\n\n----------------------------------------\n\nTITLE: Using Theatre.js Browser Bundles with HTML Script Tags\nDESCRIPTION: Example showing how to load Theatre.js via script tags and initialize it in a browser environment. The snippet demonstrates loading the bundle, accessing the core and studio objects, and initializing a project and sheet.\n\nLANGUAGE: html\nCODE:\n```\n<script src=\"path/to/core-and-studio.js\"></script>\n<script>\n  // here, core is equal to `import * as core from '@theatre/core`\n  const core = Theatre.core\n  // here, studio is equal to `import studio from '@theatre/studio`.\n  // Note this would be undefined if you're using `core-only.min.js`\n  const studio = Theatre.studio\n\n  // only call this if you're using the core-and-studio.js bundle\n  studio.initialize()\n\n  const project = core.getProject(\"My project\")\n  const sheet = project.sheet(\"...\")\n  // and so on...\n</script>\n```\n\n----------------------------------------\n\nTITLE: Installing @theatre/dataverse and React Bindings with npm\nDESCRIPTION: Commands for installing @theatre/dataverse library and its React bindings using npm. These packages are required to use the reactive dataflow functionality in JavaScript/TypeScript applications.\n\nLANGUAGE: sh\nCODE:\n```\n$ npm install @theatre/dataverse\n# and the react bindings\n$ npm install @theatre/react\n```\n\n----------------------------------------\n\nTITLE: Reading Atom State Non-Reactively in TypeScript\nDESCRIPTION: Shows how to read values from an Atom without reactivity, using either the get method for the entire state or getByPointer for specific properties.\n\nLANGUAGE: ts\nCODE:\n```\n// get the whole state\natom.get() // {intensity: 4, position: {x: 0, y: 0}}\n\n// or get a specific property using a pointer\natom.getByPointer(atom.pointer.intensity) // 4\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Referential Stability of Pointers\nDESCRIPTION: Shows that pointers maintain referential stability, meaning the same pointer instance is returned when accessing the same property multiple times.\n\nLANGUAGE: ts\nCODE:\n```\nassert.equal(atom.pointer.intensity, atom.pointer.intensity)\n```\n\n----------------------------------------\n\nTITLE: Optimizing React Renders with Pointers in Component Props\nDESCRIPTION: Demonstrates using pointers to pass data down the React component tree while minimizing re-renders. Components only re-render when their specific subscribed values change.\n\nLANGUAGE: tsx\nCODE:\n```\nimport {useVal, useAtom} from '@theatre/react'\nimport type {Pointer} from '@theatre/dataverse'\n\nfunction ParentComponent() {\n  const atom = useAtom({\n    light: {intensity: 1, position: {x: 0, y: 0}},\n    ready: true,\n  })\n\n  const ready = useVal(atom.pointer.ready)\n\n  if (!ready) return <div>loading...</div>\n\n  return (\n    <>\n      {/* <Group> will only re-render when the position of the light changes */}\n      <Group positionP={atom.pointer.light.position}>\n        {/* <Light> will only re-render when the intensity of the light changes */}\n        <Light intensityP={atom.pointer.intensity} />\n      </Group>\n    </>\n  )\n}\n\nfunction Group({positionP, children}) {\n  const {x, y} = useVal(positionP)\n  return <div style={{position: `${x}px ${y}px`}}>{children}</div>\n}\n\nfunction Light({intensityP}) {\n  const intensity = useVal(intensityP)\n  return <div style={{opacity: intensity}} className=\"light\" />\n}\n```\n\n----------------------------------------\n\nTITLE: Composing Prisms in TypeScript\nDESCRIPTION: Demonstrates composing Prisms by creating a new Prism that depends on another Prism. This allows for building complex derived state with clean separation of concerns.\n\nLANGUAGE: ts\nCODE:\n```\nconst double = prism(() => {\n  return 2 * val(sum)\n})\n\nconsole.log(val(double)) // 6\n```\n\n----------------------------------------\n\nTITLE: Using requestAnimationFrame with Tickers for Browser Sync\nDESCRIPTION: Shows how to advance Tickers using requestAnimationFrame to synchronize computations with the browser's refresh rate, optimizing performance and animation smoothness.\n\nLANGUAGE: ts\nCODE:\n```\nconst frame = () => {\n  ticker.tick()\n  requestAnimationFrame(frame)\n}\n\nrequestAnimationFrame(frame)\n```\n\n----------------------------------------\n\nTITLE: Using prism.ref() Hook for Persistent References\nDESCRIPTION: Shows how to use the prism.ref() hook to create a reference to a value that persists across Prism evaluations. Similar to React's useRef but requires a unique key parameter.\n\nLANGUAGE: ts\nCODE:\n```\nconst p = prism(() => {\n  const inputRef = prism.ref('some-unique-key')\n  if (!inputRef.current) {\n    inputRef.current = document.$('input.username')\n  }\n\n  // this prism will always reflect the value of <input class=\"username\">\n  return val(prismFromInputElement(inputRef.current))\n})\n\np.onChange(ticker, (value) => {\n  console.log('username changed to', value)\n})\n```\n\n----------------------------------------\n\nTITLE: Using prism.scope() to Prevent Hook Key Collisions\nDESCRIPTION: Demonstrates how to use prism.scope() to create scopes for prism hooks with the same key. This allows multiple hooks with the same key to coexist within a single prism without conflicts.\n\nLANGUAGE: typescript\nCODE:\n```\nconst pr = prism(() => {\n  prism.scope('a', () => {\n    prism.memo('foo', () => 1, [])\n  })\n\n  prism.scope('b', () => {\n    prism.memo('foo', () => 1, [])\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Describing Dataverse Experiments in Markdown\nDESCRIPTION: A markdown document explaining the purpose of the dataverse experiments package, which contains experimental code for @theatre/dataverse. It mentions keeping experiments in the main branch to prevent bitrot and references inspiration from the incremental library.\n\nLANGUAGE: markdown\nCODE:\n```\n# Dataverse experiments\n\nThis package contains some experiments in [@theatre/dataverse](../dataverse). We are keeping these experiments in the main branch so they don't bitrot.\n\nThe experimental `AbstractDerivation` in this package uses some ideas from [incremental](https://github.com/janestreet/incremental/blob/master/src/incremental_intf.ml).\n```\n\n----------------------------------------\n\nTITLE: Implementing Keyframe Copy/Paste Algorithms in Theatre.js\nDESCRIPTION: A detailed pseudocode specification of how keyframe copying and pasting works in Theatre.js. The algorithm handles different selection scenarios (single tracks, aggregate tracks) for copying and various property matching scenarios for pasting, with specific rules for simple and compound properties.\n\nLANGUAGE: pseudocode\nCODE:\n```\nALGORITHM copy:\n\nLET PATH =\n  CASE copy selection / single track THEN the path relative to the closest common ancestor for the tracks selected\n  CASE copy aggregate track          THEN the path relative the aggregate track compoundProp/sheetObject/sheet\n\nFOR EXAMPLE CASE copy selection / single track:\n- obj1.props.transform.position.x => x\n- obj1.props.transform.position.{x, z} => {x, z}\n- obj1.props.transform.position.{x, z} + obj1.props.transform.rotation.z =>\n  {position: {x, z}, rotation: {z}}\n\nFOR EXAMPLE CASE copy aggregate track:\n- sheet.obj1.props.transform.position => {x, y, z}\n- sheet.obj1.props.transform => {position: {x, y, z}, rotation: {x, y, z}}\n- sheet => { obj1: { props: { transform: {position: {x, y, z}, rotation: {x, y, z}}}}}\n\nALGORITHM: paste:\n\n- simple => simple => 1-1\n- simple => {x, y} => {x: simple, y: simple} (distribute to all)\n- compound => simple => compound[0] (the first simple property of the comopund,\n  recursively)\n- compound => compound =>\n  - if they match perfectly, then we know what to do\n  - if they match partially, then we paste partially\n    - {x, y, z} => {x, z} => {x, z}\n    - {x, y} => {x, d} => {x}\n  - if they don't match at all\n    - {x, y} => {a, b} => nothing\n    - {x, y} => {transforms: {position: {x, y, z}}} => nothing\n    - {x, y} => {object(not a prop): {x, y}} => {x, y}\n      - What this means is that, in case of objects and sheets, we do a forEach\n        at each object, then try pasting onto its object.props\n```\n\n----------------------------------------\n\nTITLE: Installing Theatric via npm\nDESCRIPTION: Command to install the Theatric package using npm package manager.\n\nLANGUAGE: bash\nCODE:\n```\n$ npm install theatric\n```\n\n----------------------------------------\n\nTITLE: Initializing Theatric with Configuration\nDESCRIPTION: Example showing how to initialize Theatric with a configuration object to set an initial state or leverage features like assets support. This follows the same pattern as Theatre.js's getProject() function.\n\nLANGUAGE: tsx\nCODE:\n```\nimport {initialize, useControls, types, getAssetUrl} from 'theatric'\nimport theatricState from './theatricState.json'\n\ninitialize({\n  // use the state of the state.json file you exported from the UI\n  state: theatricState,\n}).then(() => {\n  // theatric is ready (although we don't have to wait for it unless we want to use assets)\n})\n  \nReactDOM.render(<App />, document.getElementById('root'))\n\nfunction App() {\n  const {img} = useControls({\n    name: 'Andrew',\n    age: types.number(28, {\n      range: [0, 150],\n    }),\n  })\n  \n\n  return (\n    <div>\n      Hey, I'm {name} and I'm {age} years old.\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Theatre.js R3F and Dependencies using Yarn\nDESCRIPTION: Commands for installing all required dependencies including React, Three.js, React Three Fiber, Theatre.js core, studio, and the R3F extension.\n\nLANGUAGE: bash\nCODE:\n```\n# r3f and its deps\nyarn add react\nyarn add three\nyarn add @react-three/fiber\n\n# Theatre.js\nyarn add @theatre/core\nyarn add @theatre/studio\n\nyarn add @theatre/r3f\n```\n\n----------------------------------------\n\nTITLE: Directory Structure for Theatre Playground\nDESCRIPTION: Shows the folder organization for Theatre's playground, including shared playgrounds, personal workspaces, and test environments.\n\nLANGUAGE: plaintext\nCODE:\n```\nsrc/\n  shared/                      <---- playgrounds shared with teammates.\n    [playground-name]/         <---- each playground has a name...\n      index.tsx                <---- and an entry file.\n\n  personal/                    <---- personal playgrounds (gitignored).\n    [playground-name]/         <---- personal playgrounds also have names,\n      index.tsx                <---- and an entry file.\n\n  tests/                       <---- playgrounds for e2e testing.\n    [playground-name]/         <---- the name of the test playground,\n      index.tsx                <---- and its entry file.\n      [test-file-name].e2e.ts  <---- The playwright test script that tests this particular playground.\n      [test2].e2e.ts           <---- We can have more than one test file per playground.\n```\n\n----------------------------------------\n\nTITLE: Running End-to-End Tests with Playwright\nDESCRIPTION: Commands for running end-to-end tests in the Theatre playground using Playwright, with options for selecting browsers, headless mode, and debugging.\n\nLANGUAGE: bash\nCODE:\n```\n$ cd playground\n$ yarn test # runs the end-to-end tests\n$ yarn test --project=firefox # only run the tests in firefox\n$ yarn test --project=firefox --headed # run the test in headed mode in firefox\n$ yarn test --debug # run in debug mode using the inspector: https://playwright.dev/docs/inspector\n```\n\n----------------------------------------\n\nTITLE: Using Playwright Codegen for Test Generation\nDESCRIPTION: Command sequence for using Playwright's codegen tool to automatically generate test scripts for Theatre playgrounds by recording interactions.\n\nLANGUAGE: bash\nCODE:\n```\n$ cd playground\n$ yarn serve # first serve the playground\n$ yarn playwright codegen http://localhost:8080/tests/[playground-name] # run the codegen for [playground-name]\n```\n\n----------------------------------------\n\nTITLE: Running Visual Regression Tests in Docker\nDESCRIPTION: Command sequence for running visual regression tests in a Linux environment using Docker, which ensures consistent screenshot generation for CI compatibility.\n\nLANGUAGE: bash\nCODE:\n```\n$ cd repo\n$ docker-compose up -d # start the linux vm\n$ docker-compose exec -it node bash # ssh into the vm\n$ cd app\n$ yarn\n$ yarn test:e2e:ci\n```\n\n----------------------------------------\n\nTITLE: Running TypeScript Declaration Emission Command\nDESCRIPTION: Command to run TypeScript compiler with a specific tsconfig file to generate individual declaration files in the .temp directory.\n\nLANGUAGE: shell\nCODE:\n```\n$ npm run build:declarations:emit\n```\n\n----------------------------------------\n\nTITLE: Executing TypeScript Compiler for Declarations\nDESCRIPTION: The specific TypeScript compiler command that's executed to generate declaration files using a dedicated tsconfig file.\n\nLANGUAGE: shell\nCODE:\n```\n$ tsc\n```\n\n----------------------------------------\n\nTITLE: Running Declaration Bundling Command\nDESCRIPTION: Command to bundle the individual declaration files using rollup with the rollup-plugin-dts plugin.\n\nLANGUAGE: shell\nCODE:\n```\n$ npm run build:declarations:bundle\n```\n\n----------------------------------------\n\nTITLE: Verifying Node.js Installation for Theatre.js Development\nDESCRIPTION: Command to check Node.js version. Theatre.js requires Node.js version 14 or higher for development.\n\nLANGUAGE: sh\nCODE:\n```\n$ node -v\n> v14.0.0\n```\n\n----------------------------------------\n\nTITLE: Verifying Yarn Installation for Theatre.js Development\nDESCRIPTION: Command to check Yarn version. Theatre.js requires Yarn version 1.22 or higher for dependency management.\n\nLANGUAGE: sh\nCODE:\n```\n$ yarn -v\n> 1.22.10\n```\n\n----------------------------------------\n\nTITLE: Cloning the Theatre.js Repository\nDESCRIPTION: Git commands to clone the Theatre.js repository using either SSH or HTTPS connection methods, followed by changing to the project directory.\n\nLANGUAGE: sh\nCODE:\n```\n# for SSH:\n$ git clone git@github.com:<github-username>/theatre.git\n# for HTTPS:\n$ git clone https://github.com/<github-username>/theatre.git\n\n$ cd theatre\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for Theatre.js Development\nDESCRIPTION: Yarn commands to install project dependencies and run post-installation scripts for the Theatre.js project.\n\nLANGUAGE: sh\nCODE:\n```\n$ yarn\n$ yarn postinstall\n```\n\n----------------------------------------\n\nTITLE: Running the Playground for Theatre.js Development\nDESCRIPTION: Commands to navigate to the playground package, serve the application, and build the project using CLI for development and experimentation.\n\nLANGUAGE: sh\nCODE:\n```\n$ cd ./packages/playground\n$ yarn serve\n$ yarn cli build\n# or, shortcut:\n$ cd root\n$ yarn playground\n```\n\n----------------------------------------\n\nTITLE: Building Theatre.js Packages and Running Examples\nDESCRIPTION: Commands to build all Theatre.js packages and then navigate to and run a specific example project using the Create React App setup.\n\nLANGUAGE: sh\nCODE:\n```\n$ yarn cli build\n\n$ cd examples/dom-cra\n$ yarn start\n```\n\n----------------------------------------\n\nTITLE: Running Tests for Theatre.js\nDESCRIPTION: Commands to run Jest tests for the Theatre.js project, with an option to run them in watch mode for continuous testing during development.\n\nLANGUAGE: sh\nCODE:\n```\n$ yarn test\n\n# or run them in watch mode:\n$ yarn test --watch\n```\n\n----------------------------------------\n\nTITLE: Running Type Checking for Theatre.js\nDESCRIPTION: Commands to perform TypeScript type checking across all packages in the Theatre.js project, with an option for watch mode.\n\nLANGUAGE: sh\nCODE:\n```\n$ yarn typecheck\n\n# or in watch mode:\n$ yarn typecheck --watch\n```\n\n----------------------------------------\n\nTITLE: Running Linting for Theatre.js\nDESCRIPTION: Commands to run ESLint on the Theatre.js project, with an option to automatically fix linting issues where possible.\n\nLANGUAGE: sh\nCODE:\n```\n$ yarn lint:all\n\n$ yarn lint:all --fix\n```\n\n----------------------------------------\n\nTITLE: Publishing Theatre.js Packages to npm\nDESCRIPTION: CLI commands for publishing Theatre.js packages to npm with different version strategies, including regular releases, development versions, and release candidates.\n\nLANGUAGE: sh\nCODE:\n```\n$ yarn cli release x.y.z # npm publish version x.y.z\n$ yarn cli release x.y.z-dev.w # npm publish version x.y.z-dev.w and tag it as \"dev\"\n$ yarn cli release x.y.z-rc.w # npm publish version x.y.z-rc.w and tag it as \"rc\"\n```\n\n----------------------------------------\n\nTITLE: Available Commands for Theatre.js Development\nDESCRIPTION: A comprehensive list of utility commands available at the root workspace of the Theatre.js project for development, testing, linting, and building packages.\n\nLANGUAGE: sh\nCODE:\n```\n# Run the playground. It's a shortcut for `cd ./playground; yarn run serve`\n$ yarn playground\n\n# Run all the tests.\n$ yarn test\n\n# Run tests in watch mode.\n$ yarn test --watch\n\n# Typecheck all the packages\n$ yarn typecheck\n\n# Typecheck all the packages in watch mode\n$ yarn typecheck --watch\n\n# Run eslint on the repo\n$ yarn lint:all\n\n# Run eslint and auto fix\n$ yarn lint:all --fix\n\n# Build all the packages\n$ yarn cli build\n```\n\n----------------------------------------\n\nTITLE: Using AudioNode GainNode with sequence.attachAudio()\nDESCRIPTION: Example of referencing GainNode in HTML/MDN documentation. This relates to the feature where sequence.attachAudio() uses an internal GainNode that can be customized by connecting to your own audio graph.\n\nLANGUAGE: html\nCODE:\n```\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/GainNode\">GainNode</a>\n```\n\n----------------------------------------\n\nTITLE: Including Theatre.js via CDN\nDESCRIPTION: Reference to the @theatre/browser-bundles package that can be used via script tags and CDN, enabling Theatre.js to be used in CodePen or projects without a bundler.\n\nLANGUAGE: html\nCODE:\n```\n<script>\n```\n\n----------------------------------------\n\nTITLE: Configuring Robot Access Control with robots.txt\nDESCRIPTION: A basic robots.txt configuration that allows all web crawlers (user agents) to access all content on the site. The file includes a reference to the official robotstxt.org documentation.\n\nLANGUAGE: robotstxt\nCODE:\n```\n# https://www.robotstxt.org/robotstxt.html\nUser-agent: *\nDisallow:\n```\n\n----------------------------------------\n\nTITLE: Configuring Default Access Rules in robots.txt\nDESCRIPTION: This robots.txt configuration allows all web crawlers to access all content on the website. It includes a reference to the robotstxt.org standard documentation and sets no restrictions for any user agent.\n\nLANGUAGE: robotstxt\nCODE:\n```\n# https://www.robotstxt.org/robotstxt.html\nUser-agent: *\nDisallow:\n```\n\n----------------------------------------\n\nTITLE: Setting Atom State\nDESCRIPTION: The set() method replaces the entire state of the atom with the new provided state. This triggers notifications to all listeners tracking the atom or its subpaths.\n\nLANGUAGE: typescript\nCODE:\n```\nâ–¸ **set**(`newState`): `void`\n```\n\n----------------------------------------\n\nTITLE: Constructing a PointerProxy in TypeScript\nDESCRIPTION: Creates a new PointerProxy instance with the provided pointer. The constructor takes a currentPointer parameter that serves as the initial pointer to be proxied.\n\nLANGUAGE: TypeScript\nCODE:\n```\nâ€¢ **new PointerProxy**<`O`\\>(`currentPointer`)\n```\n\n----------------------------------------\n\nTITLE: Accessing the Pointer Property in PointerProxy\nDESCRIPTION: The pointer property provides a convenience pointer pointing to the root of the PointerProxy. It's a readonly property of the PointerProxy class.\n\nLANGUAGE: TypeScript\nCODE:\n```\nâ€¢ `Readonly` **pointer**: [`Pointer`](../README.md#pointer)<`O`\\>\n```\n\n----------------------------------------\n\nTITLE: Converting a Pointer to a Prism with PointerProxy\nDESCRIPTION: The pointerToPrism method returns a prism of the value at the provided sub-path of the proxied pointer. It implements the PointerToPrismProvider interface method.\n\nLANGUAGE: TypeScript\nCODE:\n```\nâ–¸ **pointerToPrism**<`P`\\>(`pointer`): [`Prism`](../interfaces/Prism-1.md)<`P`\\>\n```\n\n----------------------------------------\n\nTITLE: Setting the Pointer in PointerProxy\nDESCRIPTION: The setPointer method sets the underlying pointer to be proxied. It takes a single parameter p which is the pointer to be proxied.\n\nLANGUAGE: TypeScript\nCODE:\n```\nâ–¸ **setPointer**(`p`): `void`\n```\n\n----------------------------------------\n\nTITLE: Defining pointerToPrism Method in PointerToPrismProvider Interface with TypeScript\nDESCRIPTION: Declaration of the pointerToPrism method that returns a prism of the value at the provided pointer. The method is generic, allowing for different pointer types, and is implemented by Atom and PointerProxy classes.\n\nLANGUAGE: typescript\nCODE:\n```\npointerToPrism<P>(pointer: Pointer<P>): Prism<P>\n```"
  }
]