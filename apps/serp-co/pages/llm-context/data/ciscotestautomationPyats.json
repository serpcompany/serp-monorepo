[
  {
    "owner": "ciscotestautomation",
    "repo": "pyats",
    "content": "TITLE: Defining Device Connection Parameters and Credentials in YAML\nDESCRIPTION: This YAML snippet defines how to specify device connection details including protocol, host, IP, port, fallback credentials, and custom connection classes within a testbed configuration. It supports multi-console connections and allows overriding default connection classes. Credentials may be globally or locally defined per connection, supporting username, password, and other custom security details.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/topology/schema.rst#_snippet_1\n\nLANGUAGE: YAML\nCODE:\n```\nfallback_credentials: # list of the fallback credentials to be used for\\n                      # the connections in the testbed.(optional)\\n\\nconnections: # a list of subconnections for a multi-console\\n             # device.\\n             # Supported by unicon connector implementation.\\n             # (optional)\\n\\nconnections_arguments: # arguments to apply when creating a\\n             # multi-console device connection.\\n             # Supported by unicon connector implementation.\\n             # (optional)\\n             <key>: <value>\\n\\n<name>:\\n    # connection information on methods/ways to talk to this\\n    # testbed device.\\n    # (optional)\\n\\n    class:  # connection class to use. use this field to\\n            # provide an alternative connection class to use\\n            # to connect to this connection\\n            # (default to the above default/class)\\n            # (optional)\\n\\n    protocol:   # connection protocol\\n                # (optional)\\n\\n    host:   # device hostname\\n            # (optional)\\n\\n    ip:     # device connection ip address\\n            # if a hostname is provided in the ip block,\\n            # it be dns lookup-up and converted to IP address\\n            # during testbed yaml loading.\\n            # (optional)\\n\\n    port:   # port to connect to\\n            # (optional)\\n\\n    fallback_credentials: # list of the fallback credentials for this\\n                          # connection.(optional)\\n\\n    credentials:\\n        # credential details specific to this connection\\n        # (optional)\\n\\n        # All credentials in the device and testbed credentials\\n        # blocks are also available if not specified here.\\n\\n        <key>:        # Name of this credential.\\n            username: # (optional)\\n            password: # (optional)\\n\\n            # Any other credential details\\n            <key>: <value>\\n\\n    # all other key/values under a connection information block\\n    # that gets passed to the connection class constructor\\n    <key>: <value>\n```\n\n----------------------------------------\n\nTITLE: Writing Structured Test Scripts with AEtest Framework in Python\nDESCRIPTION: This Python code snippet exemplifies writing a pyATS test script using the AEtest framework. It defines test sections CommonSetup, Testcase, and CommonCleanup for topology verification, connection establishment, looping test cases with parameter iteration, error handling, and cleanup disconnections. The snippet utilizes decorators to specify subsections and loop over devices and destinations. It includes command execution like ping, exception capturing with conditional failure, and logging results. The final block integrates argparse for command-line input of the testbed YAML file. Dependencies are pyats.aetest and pyats.topology.loader modules. Input parameters allow dynamic test configuration.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/getting_started/index.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   connectivity_check.py\n\nfrom pyats import aetest\n\nclass CommonSetup(aetest.CommonSetup):\n\n    @aetest.subsection\n    def check_topology(self,\n                       testbed,\n                       ios1_name = 'ios-1',\n                       ios2_name = 'ios-2'):\n        ios1 = testbed.devices[ios1_name]\n        ios2 = testbed.devices[ios2_name]\n\n        # add them to testscript parameters\n        self.parent.parameters.update(ios1 = ios1, ios2 = ios2)\n\n        # get corresponding links\n        links = ios1.find_links(ios2)\n\n        assert len(links) >= 1, 'require one link between ios1 and ios2'\n\n\n    @aetest.subsection\n    def establish_connections(self, steps, ios1, ios2):\n        with steps.start('Connecting to %s' % ios1.name):\n            ios1.connect()\n\n        with steps.start('Connecting to %s' % ios2.name):\n            ios2.connect()\n\n@aetest.loop(device=('ios1', 'ios2'))\nclass PingTestcase(aetest.Testcase):\n\n    @aetest.test.loop(destination=('10.10.10.1', '10.10.10.2'))\n    def ping(self, device, destination):\n        try:\n            result = self.parameters[device].ping(destination)\n\n        except Exception as e:\n            self.failed('Ping {} from device {} failed with error: {}'.format(\n                                destination,\n                                device,\n                                str(e),\n                            ),\n                        goto = ['exit'])\n        else:\n            match = re.search(r'Success rate is (?P<rate>\\d+) percent', result)\n            success_rate = match.group('rate')\n\n            logger.info('Ping {} with success rate of {}%'.format(\n                                        destination,\n                                        success_rate,\n                                    )\n                               )\n\nclass CommonCleanup(aetest.CommonCleanup):\n\n    @aetest.subsection\n    def disconnect(self, steps, ios1, ios2):\n        with steps.start('Disconnecting from %s' % ios1.name):\n            ios1.disconnect()\n\n        with steps.start('Disconnecting from %s' % ios2.name):\n            ios2.disconnect()\n\nif __name__ == '__main__':\n    import argparse\n    from pyats.topology import loader\n\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--testbed', dest = 'testbed',\n                        type = loader.load)\n\n    args, unknown = parser.parse_known_args()\n\n    aetest.main(**vars(args))\n```\n\n----------------------------------------\n\nTITLE: Defining a CommonSetup Section in pyATS AEtest (Python)\nDESCRIPTION: This Python code demonstrates how to define a `CommonSetup` section in a pyATS AEtest script. It involves creating a class that inherits from `aetest.CommonSetup` and defining methods decorated with `@aetest.subsection` for prerequisite tasks like checking arguments, connecting to devices, and configuring interfaces, which run once before any testcases execute. Requires importing `aetest` from the `pyats` library.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/structure.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   an example common setup\n\n# import the aetest module\nfrom pyats import aetest\n\n# define a common setup section by inherting from aetest\nclass ScriptCommonSetup(aetest.CommonSetup):\n\n    @aetest.subsection\n    def check_script_arguments(self):\n        pass\n\n    @aetest.subsection\n    def connect_to_devices(self):\n        pass\n\n    @aetest.subsection\n    def configure_interfaces(self):\n        pass\n```\n\n----------------------------------------\n\nTITLE: Defining Looping Sections with PyATS AEtest Decorators in Python\nDESCRIPTION: Demonstrates how to loop subsections in CommonSetup and how to loop entire Testcases and individual test sections using the @aetest.loop decorator with specified uids. It shows the structure of a looped test script, including the effect of looping on section execution and reporting. Requires PyATS AEtest framework. The key decorators used are @aetest.loop to mark loop iterations and @aetest.subsection, @aetest.setup, @aetest.test, and @aetest.cleanup to define test sections. Inputs include loop iteration uids to control loop count and identification; outputs are multiple instantiated test sections run sequentially with unique uids.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/loop.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats import aetest\n\n# defining a common setup section\n# contains a subsection that is looped twice.\nclass CommonSetup(aetest.CommonSetup):\n\n    # defining a subsection\n    # this subsection is marked to be looped twice\n    # the first time having a uid of \"subsection_one\", and \n    # the second time having a uid of \"subsection_two\"\n    @aetest.loop(uids=['subsection_one', 'subsection_two'])\n    @aetest.subsection\n    def looped_subsection(self):\n        pass\n\n# defining a testcase that loops\n# this testcase also contains a test section that is looped twice\n@aetest.loop(uids=['testcase_one', 'testcase_two'])\nclass Testcase(aetest.Testcase):\n\n    # setup section of this testcase is run once\n    # every time the testcase is looped.\n    @aetest.setup\n    def setup(self):\n        pass\n\n    # looped test section\n    # both iterations are run per testcase iteration\n    @aetest.loop(uids=['test_one', 'test_two'])\n    @aetest.test\n    def test(self):\n        pass\n\n    # cleanup section of this testcase is run once\n    # every time the testcase is looped.\n    @aetest.cleanup\n    def cleanup(self):\n        pass\n\n```\n\n----------------------------------------\n\nTITLE: PyATS Reporter Job Execution Metadata - YAML\nDESCRIPTION: This YAML snippet illustrates the detailed structure captured by the PyATS reporter for job execution sections such as testcases and subsections. It includes parameters, results, runtimes, logs, source cross-references, and description fields. It also captures nested sections like SetupSection, TestSection, and CleanupSection with individual outcomes and timings. Objects such as the 'testbed' contain live references relevant for runtime context.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/reporter/overview.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\nparameters:\n  labels: {}\n  links: []\n  parameter_A: jobfile value A\n  parameter_B: value B\n  routers: []\n  testbed: <pyats.topology.testbed.Testbed object at 0x105ea92b0>\n  tgns: []\nresult:\n  value: passed\nsections:\n  - type: Subsection\n    id: a_simple_subsection\n    name: a_simple_subsection\n    starttime: 2019-09-19 19:56:08.435632\n    stoptime: 2019-09-19 19:56:08.437292\n    runtime: 0.0\n    description: \"A Simple Subsection\\n\\n        Use this docstring section to describe what is being done in this\\n        subsection.\\n\\n        Note:\\n            this subsection is empty and doing just about nothing. probably not\\n            a good idea to submit to code reviews, sanity/regression.\"\n    xref:\n      file: /Users/user/examples/comprehensive/base_example.py\n      line: 249\n      source_hash: ef801e370c14aacdb508536a357af11cd675e0e04025c06dde3080477cbd310d\n    logs:\n      begin: 106\n      file: TaskLog.Task-1\n      size: 419\n    result:\n      value: passed\n  - type: Testcase\n    id: ExampleTestcase\n    name: ExampleTestcase\n    starttime: 2019-09-19 19:56:08.459497\n    stoptime: 2019-09-19 19:56:08.488919\n    runtime: 0.03\n    description: An alternative description for this ExampleTestcase\n    xref:\n      file: /Users/user/examples/comprehensive/base_example.py\n      line: 492\n      source_hash: 196c823f82685246c1fd8ce040a81622e3eb48294d457622cb4fa03788d0b220\n    logs:\n      begin: 4317\n      file: TaskLog.Task-1\n      size: 7179\n    parameters:\n      labels: {}\n      links: []\n      local_A: default value A\n      local_B: default value B\n      parameter_A: jobfile value A\n      parameter_B: value B\n      routers: []\n      testbed: <pyats.topology.testbed.Testbed object at 0x115da92b0>\n      tgns: []\n    processors:\n      pre:\n        - type: Pre-processor\n          name: get_env_info\n          starttime: 2019-09-19 19:56:08.459518\n          stoptime: 2019-09-19 19:56:08.459733\n          runtime: 0.00\n          logs:\n            begin: 4325\n            file: TaskLog.Task-1\n            size: 264\n          returned:\n            env:\n              key1: val1\n              key2: val2\n    result:\n      value: errored\n    sections:\n      - type: SetupSection\n        id: setup\n        name: setup\n        starttime: 2019-09-19 19:56:08.460460\n        stoptime: 2019-09-19 19:56:08.462070\n        runtime: 0.0\n        description: \"Testcase Setup\\n\\n        This is where configuration specific to this testcase is carried out. In\\n        addition, this section can also be used to verify that the test targets'\\n        states are suitable for this testcase to be carried out\"\n        xref:\n          file: /Users/user/examples/comprehensive/base_example.py\n          line: 633\n          source_hash: deed3e44969da0e87c94c7e64fe34f9f92672c520ac1a5eb11cfd1bd04ccf57e\n        logs:\n          begin: 4436\n          file: TaskLog.Task-1\n          size: 345\n        result:\n          value: passed\n      - type: TestSection\n        id: a_simple_test\n        name: a_simple_test\n        starttime: 2019-09-19 19:56:08.462577\n        stoptime: 2019-09-19 19:56:08.464354\n        runtime: 0.0\n        description: \"A simple Test\\n\\n        The simplest test section is simply a class method with @aetest.test\\n        decorator.\\n\\n        No result APIs are called within this test section, and thus, as it\\n        exits without error, it will be defaulted to Passed.\"\n        xref:\n          file: /Users/user/examples/comprehensive/base_example.py\n          line: 664\n          source_hash: 6c4cacbd8233299d4d99361ba2518e06005551e1696fe97116d7325a1bb1e876\n        logs:\n          begin: 4781\n          file: TaskLog.Task-1\n          size: 460\n        result:\n          value: passed\n      - type: CleanupSection\n        id: cleanup\n        name: cleanup\n        starttime: 2019-09-19 19:56:08.487027\n        stoptime: 2019-09-19 19:56:08.488175\n        runtime: 0.0\n        description: \"Testcase Cleanup\\n\\n        Testcase cleanup is always called as a last resort to cleanup the\\n        test target of any changes made by this testcase. It should be written\\n        in such a way that it always cleans up what's potentially left behind.\\n\\n        cleanup section is optional in each testcase.\"\n        xref:\n          file: /Users/user/examples/comprehensive/base_example.py\n          line: 773\n          source_hash: b30a1bb819fa0fec0acf1028c75b8d3668b46ffe867d06b2982bf4e25c5f2308\n        logs:\n          begin: 11120\n          file: TaskLog.Task-1\n          size: 238\n        result:\n          value: passed\n```\n\n----------------------------------------\n\nTITLE: Connecting to Devices in a Testbed\nDESCRIPTION: This Python snippet shows how to connect to devices within a pyATS testbed. It demonstrates connecting to all devices in parallel and connecting to specific devices, optionally using different connection methods ('via' paths).  Dependencies include pyats.topology and pre-existing Testbed and Device objects.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/topology/concept.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# connect to all devices in this testbed in parallel\ntestbed_e.connect()\n\n# connect to specific devices in this testbed in parallel\n# and optionally, use specific via paths\ntestbed_e.connect(device_a, device_b,\n                  via = {device_a.name: 'vty',\n                         device_b.name: 'mgmt'})\n```\n\n----------------------------------------\n\nTITLE: Example Service Wrapper for Execute Service on IOSXE Devices in Python\nDESCRIPTION: Demonstrates a concrete implementation of a Service Wrapper subclass that wraps the 'execute' service of unicon.Connection instances connected to IOSXE devices. It configures a CLI argument, restricts applicability to IOSXE devices, and logs commands before execution and outputs after execution. This exemplifies how to extend base service wrappers with practical logging functionality targeted at specific device OS types.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/connections/wrapper.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport unicon\nfrom pyats.connections import ServiceWrapper\n\nclass ExampleWrapper(ServiceWrapper):\n    conn_type = unicon.Connection\n    service_name = 'execute'\n\n    @classmethod\n    def configure_parser(cls, parser) -> None:\n        parser.add_argument(\n            '--service-wrapper-arg',\n            dest='service_wrapper_arg',\n            action='store_true',\n            help='Service Wrapper argument',\n        )\n\n        return parser\n\n    @classmethod\n    def applicable(cls, connection, *args, **kwargs) -> bool:\n        return connection.device.os == 'iosxe'\n\n    def pre_service(self, *args, **kwargs) -> None:\n        self.logger.info(f\"Running command: {args[0]} on {self.device.name}\")\n\n    def post_service(self, output, *args, **kwargs) -> None:\n        self.logger.info(f\"Output: {output}\")\n```\n\n----------------------------------------\n\nTITLE: Loading Testbed and Managing Device Connections using pyATS Python APIs\nDESCRIPTION: This Python snippet demonstrates loading a pyATS testbed YAML file into a testbed object, accessing devices, discovering network links between devices, and establishing connections using different methods (telnet, ssh). It also illustrates command execution, device configuration, managing multiple simultaneous connections via aliases, and creating connection pools to support multiprocessing. Dependencies include the pyats.topology.loader module. Inputs are the YAML testbed file and device identifiers; outputs include device objects with connection capabilities. Designed to validate topology correctness and script interaction.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/getting_started/index.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# loader our newly minted testbed file\nfrom pyats.topology import loader\ntestbed = loader.load('ios_testbed.yaml')\n\n# access the devices\ntestbed.devices\n# AttrDict({'ios-1': <Device ott-tb1-n7k4 at 0xf77190cc>,\n#           'ios-2': <Device ott-tb1-n7k5 at 0xf744e16c>})\nios_1 = testbed.devices['ios-1']\nios_2 = testbed.devices['ios-2']\n\n# find links from one device to another\nfor link in ios_1.find_links(ios_2):\n    print(repr(link))\n# <Link link-1 at 0xf744ef8c>\n\n# establish basic connectivity\nios_1.connect()\n\n# issue commands\nprint(ios_1.execute('show version'))\nios_1.configure('''\n    interface GigabitEthernet0/0\n        ip address 10.10.10.1 255.255.255.0\n''')\n\n# establish multiple, simultaneous connections\nios_2.connect(alias = 'console', via = 'a')\nios_2.connect(alias = 'vty_1', via = 'vty')\n\n# issue commands through each connection separately\nios_2.vty_1.execute('show running')\nios_2.console.execute('reload')\n\n# creating connection pools\nios_2.start_pool(alias = 'pool', size = 2)\n\n# use connection pool in multiprocessing paradigms\n# each process will be allocated a connection - whenever one is available\ndef sleep(seconds):\n    ios_2.pool.execute('sleep %s' % seconds)\nimport multiprocessing\np1 = multiprocessing.Process(target=sleep, args = (10, ))\np2 = multiprocessing.Process(target=sleep, args = (10, ))\np3 = multiprocessing.Process(target=sleep, args = (10, ))\np1.start(); p2.start(); p3.start()\np1.join(); p2.join(); p3.join()\n```\n\n----------------------------------------\n\nTITLE: Callable Parameters - Python\nDESCRIPTION: This code provides an example of a callable parameter in aetest.  It demonstrates how to define a parameter whose value is a callable function (in this case, `random.random`).  When the parameter is used as a function argument in a test method, the function is executed, and the return value is used as the actual argument.  The snippet highlights that callable parameters are only evaluated when passed as a function argument.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/parameters.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport random\n    from pyats import aetest\n\n    # define a callable parameter called \"number\"\n    # the provided parameter value is the random function, imported\n    # from python random library.\n    # when called, random.random() generates a float number between 0 and 1\n    parameters = {\n        'number': random.random,\n    }\n\n    class Testcase(aetest.Testcase):\n\n        # as the \"number\" parameter's value is the callable function\n        # random.random, this function is evaluated right before the\n        # execution of this test method, and the call result is then used\n        # as the actual argument input\n        @aetest.test\n        def test(self, number):\n\n            # test whether the generated number is greater than 0.5\n            assert number > 0.5\n            # if you run this test enough times\n            # you will find that it passes exactly 50% of the time\n            # assuming that random.random() generate truly random numbers :)\n\n            # note that callable parameters are only evaluated if used\n            # as function arguments. they are still objects if viewed\n            # through the parameters property\n            self.parameters['number']\n            # <built-in method random of Random object at 0x91e2fc4>\n```\n\n----------------------------------------\n\nTITLE: Parsing Commands on Testbed Devices\nDESCRIPTION: This Python snippet demonstrates how to parse command outputs from devices within a pyATS testbed in parallel. It assumes a 'testbed' object exists, which contains the device information.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/topology/concept.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# parse commands from all devices in the testbed in parallel\ntestbed.parse('show version')\n```\n\n----------------------------------------\n\nTITLE: Device Connection & Command Execution with pyATS\nDESCRIPTION: This example shows how to connect to a device, send commands, configure interfaces, and disconnect using the pyATS topology and connection modules. It demonstrates the basic usage of the Device object for interacting with network devices.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/connections/integration.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   device & connection integration\n\n# when given a device object\ndevice = testbed.devices['some-uut-device']\n\n# users should be able to directly interface with it, eg:\n# connect to it\ndevice.connect()\n\n# send commands\noutput = device.execute('show version')\ndevice.configure('''\n    interface Ethernet1/1\n        ip address 192.5.10.1 255.255.255.0\n        no shutdown\n''')\n\n# and more ...\nassert device.connected\ndevice.ping('192.5.10.2')\ndevice.reload()\ndevice.disconnect()\n```\n\n----------------------------------------\n\nTITLE: Defining Device Interfaces and Their Network Attachments in YAML\nDESCRIPTION: Within the topology block, this snippet shows how each device's interfaces are described by specifying mandatory interface types, optional aliases, links to physical or logical network connections, IPv4 and IPv6 addressing with automatic parsing, and support for custom interface subclasses to extend functionality. It supports additional arbitrary metadata under each interface.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/topology/schema.rst#_snippet_5\n\nLANGUAGE: YAML\nCODE:\n```\n<device>:   # each device's interface/link gets its own block named\\n            # using the device name/hostname. the device mentioned\\n            # here must be also described under the device block.\\n            # (optional)\\n\\n    interfaces: # begin the device interface description section\\n                # (required)\\n\\n        <intfname>: # each device interface requires its own section\\n                    # under the interfaces block\\n                    # interface names must be unique per device\\n                    # (optional)\\n\\n            type:   # interface type string\\n                    # (mandatory)\\n\\n            alias:  # interface alias.\\n                    # (default: same as interface name)\\n                    # (optional)\\n\\n            link:   # string name of the link this interface is\\n                    # connected to. Unique link names here yield\\n                    # unique links. If a linkname is also described\\n                    # in the link section above, the extended info\\n                    # for that link is used.\\n                    # (optional)\\n\\n            ipv4:   # ipv4 interface address and mask\\n                    # this is loaded and converted to\\n                    # ipaddress.IPv4Interface object\\n                    # (optional)\\n\\n            ipv6:   # ipv6 interface address and mask\\n                    # this is loaded and converted to\\n                    # ipaddress.IPv6Interface object\\n                    # A list of IPv6 addresses may also be provided.\\n                    # (optional)\\n\\n            class:  # interface object class. use this field to provide\\n                    # an alternative subclass of Interface class to\\n                    # instantiate this interface section with. can be\\n                    # used to extend the base Interface class functions\\n                    #   Eg: module.submodule.myInterfaceClass\\n                    # (default: ats.topology.Interface)\\n                    # (optional)\\n\\n            <key>: <value>  # any other key/values custom to this\\n                            # interface goes here\\n                            # (optional)\n```\n\n----------------------------------------\n\nTITLE: Defining a Complete pyATS Testbed Configuration in YAML\nDESCRIPTION: A comprehensive example of a pyATS testbed file that extends a base configuration and defines two Nexus 7000 devices with their connections, credentials, cleaning procedures, and topology. It demonstrates credential management, including encrypted passwords and interactive prompts, as well as topology definition with interface links between devices.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/topology/example.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n# Example\n# -------\n#\n#   an example two router testbed\n\nextends: base_tb_config.yaml\n\ntestbed:\n    name: sampleTestbed\n    alias: topologySampleTestbed\n    credentials:\n        default:\n            username: admin\n            password: CSCO12345^\n        enable:\n            password: \"%ASK{user specified prompt}\"\n    servers:\n        filesvr:\n            server: ott2lab-tftp1\n            address: 223.255.254.254\n            path: \"\"\n            credentials:\n                default:\n                    username: rcpuser\n                    password: 123rcp!\n                sftp:\n                    username: sftpuser\n                    password: \"%ENC{w6DDmsOUw6fDqsOOw5bDiQ==}\"\n                ftp:\n                    username: ftpuser\n                    password: \"%ASK{}\"\n\n        ntp:\n            server: 102.0.0.102\n    custom:\n        owner: john\n        contacts: mai@domain.com\n        mobile: \"%ASK{enter owner mobile phone number}\"\n\ndevices:\n    ott-tb1-n7k4:\n        os: nxos\n        type: Nexus 7000\n        alias: device-1\n        credentials:\n            default:\n                username: admin\n                password: abc123\n            enable:\n                password: \"%ASK{}\"\n        connections:\n            a:\n              protocol: telnet\n              ip: 10.85.84.80\n              port: 2001\n            b:\n              protocol: telnet\n              ip: 10.85.84.80\n              port: 2003\n            vty:\n              protocol: telnet\n              ip: 5.19.27.5\n              credentials:\n                default:\n                    username: mgtuser\n                    password: mgtpw\n        clean:\n            pre_clean: |\n                      switchname %{self}\n                      license grace-period\n                      feature telnet\n                      interface mgmt0\n                          ip addr %{self.connections.vty.ip}/24\n                      no shut\n                      vrf context management\n                          ip route 101.0.0.0/24 5.19.27.251\n                          ip route 102.0.0.0/24 5.19.27.251\n            post_clean: |\n                      switchname %{self}\n                      license grace-period\n                      feature telnet\n                      interface mgmt0\n                          ip addr %{self.connections.vty.ip}/24\n                      no shut\n                      vrf context management\n                          ip route 101.0.0.0/24 5.19.27.251\n                          ip route 102.0.0.0/24 5.19.27.251\n        custom:\n            SUP1: Supervisor Module-1X\n            SUP2: Supervisor Module-1X\n\n    ott-tb1-n7k5:\n        os: nxos\n        type: Nexus 7000\n        alias: device-2\n        connections:\n            a:\n              protocol: telnet\n              ip: 10.85.84.80\n              port: 2006\n            b:\n              protocol: telnet\n              ip: 10.85.84.80\n              port: 2009\n            vty:\n              protocol: telnet\n              ip: 5.19.27.6\n        clean:\n            pre_clean: |\n                        switchname %{self}\n                        license grace-period\n                        feature telnet\n                        interface mgmt0\n                            ip addr %{self.connections.vty.ip}/24\n                        vrf context management\n                            ip route 101.0.0.0/24 5.19.27.251\n                            ip route 102.0.0.0/24 5.19.27.251\n            post_clean: |\n                      switchname %{self}\n                      license grace-period\n                      feature telnet\n                      interface mgmt0\n                          ip addr %{self.connections.vty.ip}/24\n                      no shut\n                      vrf context management\n                          ip route 101.0.0.0/24 5.19.27.251\n                          ip route 102.0.0.0/24 5.19.27.251\n        custom:\n            SUP1: Supervisor Module-1X\n            SUP2: Supervisor Module-1X\n\ntopology:\n    ott-tb1-n7k4:\n        interfaces:\n            Ethernet4/1:\n                alias: device1-intf1\n                link: rtr1-rtr2-1\n                type: ethernet\n            Ethernet4/2:\n                alias: device1-intf2\n                link: rtr1-rtr2-2\n                type: ethernet\n            Ethernet4/6:\n                link: ethernet-1\n                type: ethernet\n            Ethernet4/7:\n                link: ethernet-1\n                type: ethernet\n            Ethernet4/45:\n                link: ethernet-2\n                type: ethernet\n            Ethernet4/46:\n                link: ethernet-2\n                type: ethernet\n\n    ott-tb1-n7k5:\n        interfaces:\n            Ethernet5/1:\n                alias: device2-intf1\n                link: rtr1-rtr2-1\n                type: ethernet\n            Ethernet5/2:\n                alias: device2-intf2\n                link: rtr1-rtr2-2\n                type: ethernet\n```\n\n----------------------------------------\n\nTITLE: Using Script Arguments in pyATS aetest Testscript in Python\nDESCRIPTION: This script showcases how to accept command-line arguments for testbed and VLAN parameters, parse them, and pass them into aetest main() as keyword arguments. Dependencies include pyats.topology.loader for loading testbed files, argparse for argument parsing, and pyats.aetest for testing. It enables dynamic configuration based on user input during execution or job automation.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/examples.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   script arguments demo\n\nimport logging\nfrom pyats import aetest\n\nlogger = logging.getLogger(__name__)\n\nclass Testcase(aetest.Testcase):\n\n    @aetest.test\n    def test(self, testbed, vlan):\n        logger.info('Testbed = %s' % testbed)\n        logger.info('Vlan =  %s' % vlan)\n\n# main()\nif __name__ == '__main__':\n\n    # set logger level\n    logger.setLevel(logging.INFO)\n\n    # local imports\n    import sys\n    import argparse\n    from pyats.topology import loader\n\n    parser = argparse.ArgumentParser(description = \"standalone parser\")\n    parser.add_argument('--testbed', dest = 'testbed')\n    parser.add_argument('--vlan', dest = 'vlan')\n\n    # parse args\n    args, sys.argv[1:] = parser.parse_known_args(sys.argv[1:])\n\n    # post-parsing processing\n    testbed = loader.load(args.testbed)\n    vlan = int(args.vlan)\n\n    # and pass all arguments to aetest.main() as kwargs\n    aetest.main(testbed = testbed, vlan = vlan)\n```\n\n----------------------------------------\n\nTITLE: Creating a Simple AEtest Testscript in Python\nDESCRIPTION: Demonstrates the basic structure of an AEtest script using Python. It includes `CommonSetup` for initial setup (connecting to devices), `SimpleTestcase` with a test method (configuring interfaces), and `CommonCleanup` for teardown (disconnecting). The script can be run standalone using `aetest.main()`. Requires the `pyats` library and a `some_lib` module with `configure_interface`.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/introduction.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   very simple aetest testscript\n\nfrom pyats import aetest\nfrom some_lib import configure_interface\n\nclass CommonSetup(aetest.CommonSetup):\n    @aetest.subsection\n    def connect_to_device(self, testbed):\n        # connect to testbed devices\n        for device in testbed:\n            device.connect()\n\nclass SimpleTestcase(aetest.Testcase):\n    @aetest.test\n    def simple_test(self, testbed):\n        # configure each device interface\n        for device in testbed:\n            for intf in device:\n                configure_interface(intf)\n\nclass CommonCleanup(aetest.CommonCleanup):\n    @aetest.subsection\n    def disconnect_from_devices(self, testbed):\n        # disconnect_all\n        for device in testbed:\n            device.disconnect()\n\n# for running as its own executable\nif __name__ == '__main__':\n    aetest.main()\n```\n\n----------------------------------------\n\nTITLE: Implementing Nested Test Steps and Reporting in Python using pyats.aetest\nDESCRIPTION: This code defines a test case class inheriting from pyats.aetest.Testcase, demonstrating nested step creation with context managers. It accesses step details and generates reports at various levels, illustrating how to structure detailed, hierarchical test steps, and how to output their evaluation results for debugging and analysis.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/steps.rst#_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\n# Example\n# -------\n#\n#   accessing step details & localized reports\n\nfrom pyats import aetest\n\n# import Steps\nfrom pyats.aetest.steps import Steps\n\nclass Testcase(aetest.Testcase):\n\n    @aetest.test\n    def test(self, steps):\n\n        # creating a step monster\n        with steps.start('test step 1') as step:\n            with step.start('test step 1 substep a'):\n                pass\n            with step.start('test step 1 substep a') as substep:\n                with substep.start('test step 1 sub-step a sub-substep i'):\n                    pass\n                with substep.start('test step 1 sub-step a sub-substep ii'):\n                    pass\n\n                # access local step information/report\n                print(substep.details)\n                substep.report()\n\n        # access overall step details:\n        print(steps.details)\n\n```\n\n----------------------------------------\n\nTITLE: Specifying Test Groups to Run with pyATS AEtest - Python and Bash\nDESCRIPTION: Allows selection of specific testcase groups to run using callable logical expressions evaluating True or False based on each testcase's groups. Inputs can be passed as command-line arguments using Python-syntax evaluatable logic expressions or passed programmatically via aetest.main or easypy.run API calls. The pyats.datastructures.logic module provides logical operators used as dependencies. The input is an expression filtering testcase groups; output controls testcase execution. Valid Python syntax is required for command-line inputs.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/run.rst#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nbash$ python testscript.py -groups=\"And(Or('group1','group2'), 'group3')\"\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.datastructures.logic import Or, And\naetest.main('testscript.py', groups = And(Or('group1','group2'), 'group3'))\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.datastructures.logic import Or, And\nrun(testscript = 'testscript.py', groups = And(Or('group1','group2'), 'group3'))\n```\n\n----------------------------------------\n\nTITLE: Configuring Testbed Devices\nDESCRIPTION: This Python snippet demonstrates how to configure devices within a pyATS testbed in parallel. It assumes a 'testbed' object exists, which contains the device information.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/topology/concept.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# configure all devices in the testbed in parallel\ntestbed.configure('no logging console')\n\n# configure some devices in parallel\n# Note: devices is a list of Device objects\ndevices = [testbed.devices[dev] for dev in testbed.devices \\\n                    if testbed.devices[dev].os=='iosxe']\ntestbed.configure('no logging console', devices=devices)\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyATS/ATS via pip (bash)\nDESCRIPTION: This snippet provides the bash commands to upgrade pyATS for DevNet community users and ATS for Cisco internal developers using the pip package manager. It uses the --upgrade flag to update the existing installation.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2023/july.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats\n\n# Cisco Internal Developers\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Establishing and Managing Connection Pools with pyATS ConnectionManager (Python)\nDESCRIPTION: Shows how to create and manage pools of device connections using the pool_size parameter, both with the default and custom connection classes. Includes setting up connection pools with aliasing, different connection paths, and post-instantiation modification of pool objects. Examples demonstrate both direct connect calls and object instantiation, and explain how APIs distribute command execution among pool workers. Dependencies: pyATS device object, optionally a custom AltConnImpl class, and a valid connection configuration. Expects parameters like pool_size, via, cls, and allows attribute modification before pool activation. Pools must be homogeneous by type/path (e.g., multiple vty, not mixed connection types).\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/connections/manager.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# given a device connection manager object\ndevice.connectionmgr\n# <pyats.connections.ConnectionManager object at 0xf76f1c4c>\n\n# we could establish a pool of connections using the default class\n# just give the alias 'pool' for simplicity\n# and start it with 3 workers\ndevice.connect(pool_size = 3)\n\n# or connect using a different path\n# (this requires device.connections['mgmt'] to be populated)\ndevice.connect(pool_size = 3, via = 'mgmt')\n\n# we could establish a pool of workers using another class\nfrom some_connection_lib import AltConnImpl\n\n# start pool directly (default path)\ndevice.connect(pool_size = 5, cls = AltConnImpl)\n\n# start pool using a different path and this class\ndevice.connect(pool_size = 5,\n               cls = AltConnImpl,\n               via = 'mgmt')\n\n# additionally, we could instantiate the pool object first\npool = device.instantiate(pool_size = 5,\n                          cls = AltConnImpl,\n                          via = 'mgmt')\n# and modify various attributes before we connect\npool.new_attribute = 'x'\npool.connect()\n\n# once a pool is started, use it like any other connection\n# calls are redirected to the first available worker\ndevice.pool.execute('command')\n```\n\n----------------------------------------\n\nTITLE: Defining Test Section in pyATS Testcase (Python)\nDESCRIPTION: This code block shows how to define the core testing units within an `aetest.Testcase`. Each method decorated with `@aetest.test` represents an individual test or verification step. Test sections run sequentially and constitute the main logic of a testcase.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/structure.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   test sections\n\nfrom pyats import aetest\n\n# test section within Testcases\nclass Testcase(aetest.Testcase):\n\n    # define test section by applying @test decorator\n    @aetest.test\n    def a_testcase_test(self):\n        pass\n```\n\n----------------------------------------\n\nTITLE: Running pyATS Test Scripts from Command Line using Bash\nDESCRIPTION: This bash snippet shows how to execute a pyATS test script with a specified testbed YAML file from the command line. It uses standard python command execution syntax passing script arguments to provide dynamic testbed configuration. The snippet's key input is the test script filename and testbed YAML file path; output is the execution of the test with results printed to stdout. This approach enables integration with shell environments and automation workflows.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/getting_started/index.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nbash$ python connectivity_check.py --testbed ios_testbed.yaml\n```\n\n----------------------------------------\n\nTITLE: Maximum Allowed Failures Before Abort in AEtest - Python and Bash\nDESCRIPTION: Defines the maximum number of failures tolerated before the testscript automatically aborts. Input is an integer specifying the failure threshold. Used for controlling test execution robustness and early termination criteria. Provided as a command-line parameter or API argument. Dependency is the AEtest framework handling failure counts.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/run.rst#_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\nbash$ python testscript.py -max_failures 13\n```\n\nLANGUAGE: python\nCODE:\n```\naetest.main('testscript.py', max_failures = 13)\n```\n\nLANGUAGE: python\nCODE:\n```\nrun(testscript = 'testscript.py', max_failures = 13)\n```\n\n----------------------------------------\n\nTITLE: Iterating Through Testbed Devices\nDESCRIPTION: This Python snippet demonstrates how to iterate through the devices contained within a Testbed object and access their names. It assumes that `testbed_c` is a pre-existing Testbed object with Devices.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/topology/concept.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# looping over a testbed's devices\nfor device in testbed_c:\n    print(device.name)\n```\n\n----------------------------------------\n\nTITLE: Inserting a Debugger Breakpoint with pdb in Python\nDESCRIPTION: This snippet demonstrates how to introduce a manual breakpoint in Python code using the built-in pdb debugger. By importing pdb and calling pdb.set_trace(), execution halts and drops the developer into an interactive debugging shell at runtime. This approach has no dependencies beyond the standard library, and allows inspection of variables, stack frames, and program flow at the specified point. The main parameter is pdb.set_trace(), which takes no arguments; it is intended for use in any Python script requiring stepwise debugging or troubleshooting.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/resources/debugging.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#   \n#   putting a break in your code\n\n# yourPythonCode.py\n\n# code ...\n# code ..\n# code .\n\n# import python debugger and start to trace\nimport pdb; pdb.set_trace()\n\n# code .\n# code ..\n# code ...\n```\n\n----------------------------------------\n\nTITLE: Logging messages in pyATS (Typical Usage)\nDESCRIPTION: This snippet demonstrates the basic usage of the logging module within a pyATS test script or library. It assumes an EasyPy environment where root handlers are already configured. It logs various message types (info, critical, debug, warning, and error) to the configured log handlers. Exception messages are automatically included in error messages when an exception is caught.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/log/examples.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport logging\n\n# create a logger for this module\nlogger = logging.getLogger(__name__)\n\n# informational messages\nlogger.info('info messages')\n\n# critical messages\nlogger.critical('critical messages')\n\n# debug messages\nlogger.debug('debug messages')\n\n# warning messages\nlogger.warning('warning messages')\n\n# error messages\nlogger.error('error messages')\n\ntry:\n    # i am raising an error here so the except statement catches it\n    raise Exception('just raising for demo purposes')\nexcept:\n    # exception automatically included in error message\n    logger.exception('caught error above')\n```\n\n----------------------------------------\n\nTITLE: Passing custom script arguments to Easypy job files in Python\nDESCRIPTION: Shows how to supply custom script arguments as keyword arguments to the Easypy run() API within job files, which are then propagated to the AEtest testscript. This example sets arbitrary flags (pyats_is_awesome and aetest_is_legendary) that become accessible as parameters within the testscript testcases. It illustrates how Easypy enables flexible parameter passing between job orchestrator and AEtest scripts. Easypy must be used to execute this job file properly, ensuring the parameters propagate correctly during test execution.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/run.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.easypy import run\n\ndef main():\n    run(testscript='/path/to/your/script.py',\n        pyats_is_awesome = True,\n        aetest_is_legendary = True)\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Testcase Ordering with Python in pyATS\nDESCRIPTION: This snippet illustrates defining a custom order method in a TestcaseDiscovery subclass to control the sequence of testcase sections like setup and cleanup. The method can modify the test sections' list in place, inserting or appending based on received arguments. This logic is integrated by assigning the custom class to runtime.discoverer.testcase. It expects proper section objects as input and outputs an ordered list for execution.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/control.rst#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nclass MyCustomTestcaseDiscovery(TestcaseDiscovery):\n    def order(self, setup=None, tests=list(), cleanup=None):\n        # some logic\n        return [\\\n            self.target.common_setup,\\\n            self.target.tc_two,\\\n            self.target.tc_one,\\\n            self.target.common_cleanup]\n```\n\n----------------------------------------\n\nTITLE: Creating and Using a Connection Pool with Pcall in Python\nDESCRIPTION: Demonstrates creating a connection pool using `device.connect` with the `pool_size` parameter (e.g., `pool_size=5`). It then uses `pyats.async_.Pcall` to execute multiple commands concurrently, leveraging the pool to distribute these commands across the available worker connections. This allows for true parallel execution up to the pool size. Depends on `pyats.async_.Pcall`, a device object, and a connection class like `TelnetConnection`.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/connections/sharing.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   connection pool using TelnetConnection class example\n#   (and Pcall to make asynchronous executions)\n\nfrom pyats.async_ import Pcall\n\n# assuming we had an imaginary device object...\n# Assuming TelnetConnection class is defined as above\n\n# using the above device and TelnetConnection\n# create a pool of 5 workers\n# device.connect(target = TelnetConnection, \n#                via = 'mgmt',\n#                pool_size = 5) # Assumed setup\n\n# now let's use Pcall to perfrom 5 commands at the same time\n# in forked, child processes\n# output = Pcall(device.pool.execute, \n#                command = ['show version', \n#                           'show running-config',\n#                           'show ip ospf database',\n#                           'show ip route',\n#                           'show ip bgp']) \n# Placeholder for actual execution\n```\n\n----------------------------------------\n\nTITLE: Setting Up a Quick-Edit Test Script with pyATS in Python\nDESCRIPTION: This example creates a basic test script environment leveraging Cisco's pyATS framework to enable quick prototyping and experimentation. The snippet imports necessary modules (pyats.topology.Testbed, pyats.tcl, pyats.results), loads a testbed from configuration, connects to a device, and defines a sample test case function that can be invoked directly. It illustrates how to simulate the 'self' argument required by test classes, assigns test metadata, and uses pdb.set_trace() for interactive debugging. Users should have pyATS and its dependencies installed, as well as an accessible testbed YAML file; parameters include the testbed file path, device names, and result codes, with output dependent on the test logic. The approach is ideal for quick iteration and isolated feature testing within the pyATS ecosystem.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/resources/debugging.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   what a quick edit/test script could look like in pyATS\n\n# working with a testbed\nfrom pyats.topology import Testbed\n\n# working with tcl\nfrom pyats import tcl\n\n# import result codes\nfrom pyats.results import *\n\n# create a tb\ntb = Testbed(config_file = '/path/to/testbed.yaml')\n\n# grab a device\nd = tb.devices['uut']\n\n# connect it if needed\nd.connect()\n\n# now you can do whatever you want.\n# throw your testcode in here.\ndef myTestcaseSetup(self):\n    # code...\n\n    pass\n\n# wait, what's this self thing, isn't it part of a class?\n# yes and no. :) read up on it.\n# http://stackoverflow.com/questions/2709821/what-is-the-purpose-of-self-in-python\nself = {'id': 'myTestcase',\n        'description': '',\n        'script_args': {\n            'testbed': tb,\n        }\n        'result': Passed}\n\n# test it \nmyTestcaseSetup(self)\n\n# throw in a debugger for kicks\nimport pdb; pdb.set_trace()\n\n```\n\n----------------------------------------\n\nTITLE: Executing Command via Telnet\nDESCRIPTION: The `execute` method sends a command to the device, waits for the prompt, and returns the output. It sends the command using `self.send()`, reads the output until the prompt, and then removes the command's echo. It requires a command string as input.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/connections/class.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef execute(self, command):\n    '''execute\n\n    high-level api: sends a command through the session, expect it to\n    be executed, and return back to prompt.\n    '''\n\n    # send the command\n    self.send(command)\n\n    # expect the prompt\n    output = self._telnet.read_until(self._prompt.encode('ascii'))\n\n    # convert the output to string\n    output = output.decode('utf-8')\n\n    # remove the telnet echo of our original command\n    output.lstrp(command + '\\n')\n\n    # we're done!\n    return output\n```\n\n----------------------------------------\n\nTITLE: Connecting to Devices using pyATS ConnectionManager (Python)\nDESCRIPTION: Demonstrates different ways to connect to devices using the pyATS ConnectionManager API. Allows specifying aliases, paths (via), and custom connection classes. Highlights equivalency between device.connect and direct calls to the connection manager, and explains how to inject additional keyword arguments (like timeout). Dependencies: a properly instantiated device object with populated connection details, and optionally a custom connection implementation (e.g., AltConnImpl from another library). Inputs include connection parameters such as alias, via, cls, timeout, etc.; outputs are established device connections attached to the manager. APIs propagate additional arguments directly to the given connection class.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/connections/manager.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# just connect\ndevice.connect()\n# equivalent to: device.connectionmgr.connect()\n\n# connect using a different path and alias\n# (this requires device.connections['mgmt'] to be populated)\ndevice.connect(alias = 'vty_1', via = 'mgmt')\n# equivalent to: device.connectionmgr.connect(alias = 'vty_1', via = 'mgmt')\n\n# we could establish connections using another class\nfrom some_connection_lib import AltConnImpl\n\n# just connect using it\ndevice.connect(cls = AltConnImpl)\n# equivalent to: device.connectionmgr.connect(cls = AltConnImpl)\n\n# connect using a different path and alias and that class\ndevice.connect(cls = AltConnImpl, alias = 'vty_1', via = 'mgmt')\n# equivalent to: device.connectionmgr.connect(cls = AltConnImpl,\n#                                             alias = 'vty_1',\n#                                             via = 'mgmt')\n\n# additionally, we could instantiate the object first\nconnection = device.instantiate(cls = AltConnImpl)\n# and modify various attributes before we connect\nconnection.new_attribute = 'x'\nconnection.connect()\n# note that after device.instantiate() is called, the newly created\n# connection object is saved both under the given alias in the connection\n# manager, and returned for your direct access.\n\n# all other arguments to connect() api are propagated to the connection class\n# (assuming AltConnImpl took arguments timeout, term_width and max_buffer)\ndevice.connect(cls = AltConnImpl,\n               alias = 'session_1',\n               timeout = 100,\n               term_width = 512,\n               max_buffer = 999999)\n# eg, equivalent to:\n# device.connectionmgr.connections['session_1'] = AltConnImpl(timeout = 100,\n#                                                             term_width = 512,\n#                                                             max_buffer = 999999)\n# device.connectionmgr.connections['session_1'].connect()\n```\n\n----------------------------------------\n\nTITLE: Basic Python Logging Setup for pyATS\nDESCRIPTION: Example showing the recommended pattern for setting up logging in pyATS scripts. It demonstrates importing the logging module, creating a logger with the module name, and using different severity levels for logging messages.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/log/introduction.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   import the logging module at the top of your script\n#   setup the logger\n\nimport logging\n\n# always use your module name as the logger name.\n# this enables logger hierarchy\nlogger = logging.getLogger(__name__)\n\n# use logger:\nlogger.info('an info message')\nlogger.error('an error message')\nlogger.debug('a debug message')\n```\n\n----------------------------------------\n\nTITLE: Skipping Section with Reason by Returning False in Pre-processor - Python\nDESCRIPTION: Explains how a pre-processor can return a tuple `(False, reason)` to skip the test section and provide a specific message logged as the reason for skipping. This allows for more informative skip results.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/processors.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ndef preprocessorReturnFalseWithReason()\n    # return false along with a reason (as a tuple)\n    return False, \"murphy's law :-(\"\n```\n\n----------------------------------------\n\nTITLE: Flow Control with Goto Parameter in pyATS AETEST\nDESCRIPTION: Demonstrates various ways to use the 'goto' parameter to control test execution flow. The goto parameter allows skipping to specific sections like cleanup or common_cleanup based on test results.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/control.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nclass CommonSetup(aetest.CommonSetup):\n    @aetest.subsection\n    def subsection(self):\n        # goto with a message\n        self.errored('setup error, abandoning script', goto = ['exit'])\n\n# --------------------------------------------------------------------------\nclass TestcaseOne(aetest.Testcase):\n    @aetest.setup\n    def setup(self):\n        # setup failed, go to cleanup of testcase\n        self.failed('test failed', goto = ['cleanup'])\n\n# --------------------------------------------------------------------------\nclass TestcaseTwo(aetest.Testcase):\n    # test failed, move onto next testcase\n    @aetest.test\n    def test(self):\n        self.failed(goto = ['next_tc'])\n\n# --------------------------------------------------------------------------\nclass TestcaseThree(aetest.Testcase):\n    @aetest.setup\n    def setup(self):\n        # setup failed, move onto cleanup of this testcase, then\n        # jump to common_cleanup directly.\n        self.failed(goto=['cleanup','common_cleanup'])\n```\n\n----------------------------------------\n\nTITLE: Reporting Test Steps with Context Manager in pyATS Service Wrapper - Python\nDESCRIPTION: Demonstrates usage of the 'steps' object within pyATS service wrapper methods to enable context-managed testcase reporting. The snippet uses a 'with' block to start a test step and marks it as passed, illustrating how to integrate step-based status logging. Dependency is an active 'steps' object from the test framework. This pattern ensures clear reporting for each service stage. Intended for use within service wrapper methods where step tracking is desirable.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/connections/wrapper.rst#_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\nwith steps.start() as step:\n    step.passed('Passed')\n```\n\n----------------------------------------\n\nTITLE: Using inheritance and shared variables in pyATS aetest for flexible testcases in Python\nDESCRIPTION: This code illustrates creating a base Testcase class with undefined variables and inheriting from it to define specific instances with assigned values and identifiers. Dependencies include pyats.aetest. The pattern supports parameterized testing and code reuse across multiple test scenarios, allowing tests to be classified and driven by different data inputs.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/examples.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   the base testcase library script (to be inherited by other scripts)\n#   let's call this script: base_script.py\n\nfrom pyats import aetest\n\nclass MathTest(aetest.Testcase):\n\n    def test_plus(self):\n        '''test requires the definition of a & b at testcase level'''\n\n        assert self.a + self.b < 1000\n\n# Example of inheriting and providing data\n\nfrom base_script import MathTest\n\nclass RealMathTest(MathTest):\n\n    # provide uid and grouping information\n    uid = 'rocket_science_math_test'\n    groups = ('elementary', 'basic')\n\n    # give values for the tests\n    a = 1\n    b = 2\n\n```\n\n----------------------------------------\n\nTITLE: Importing Result Objects with pyATS in Python\nDESCRIPTION: Demonstrates how to import the standard result objects (Passed, Failed, Aborted, Errored, Skipped, Blocked, Passx) from the pyats.results module into a Python script. No additional libraries are required except for pyats itself. Shows both individual imports and wildcard import, explicitly noting that the module restricts wildcard behavior to prevent unintended objects being imported. Inputs: None. Outputs: Accessible result objects in the local namespace.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/results/objects.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   importing result objects\n\n# import each result object individually\nfrom pyats.results import (Passed, Failed, Aborted, Errored,\n                           Skipped, Blocked, Passx)\n\n# or you can also import them altogether using * wildcard\n# the module has code that specifically limits this to be the same as\n# the localized import statement above\nfrom pyats.results import *\n```\n\n----------------------------------------\n\nTITLE: Skipping Section by Returning False in Pre-processor - Python\nDESCRIPTION: Shows how a pre-processor returning the boolean value `False` results in all subsequent pre-processors being skipped and the test section being skipped with a 'Skipped' result. The execution does not proceed to the test section.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/processors.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndef preprocessorReturnFalse()\n    # if a pre-processor returns False, all remaining pre-processors\n    # are skipped, and the test section is skipped also.\n    return False\n```\n\n----------------------------------------\n\nTITLE: Loading Testbed YAML File Programmatically - pyATS Topology - Python\nDESCRIPTION: Shows how to load a testbed definition from a YAML file or URL programmatically using the pyATS topology.loader.load() API. The loader parses the YAML, constructs the testbed and device objects, and resolves relationships automatically. Requires the pyATS libraries, and the input must be a valid testbed-file schema.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/topology/creation.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.topology import loader\n\n# load testbed file\ntestbed = loader.load('/path/to/my/testbed/file/testbed.yaml')\n```\n\n----------------------------------------\n\nTITLE: Defining PyATS Testbed YAML Schema\nDESCRIPTION: Comprehensive YAML schema for PyATS testbed files. This schema defines the structure and allowed fields for testbed configurations, including testbed-level information, device details, credentials, connections, and custom properties.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/topology/schema.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n# Testbed File Schema\n# -------------------\n#\n#   production schema with commentary from the devs\n\nextends:    # Testbed file(s) to extend/build on.\n            # Use this field to extend an existing yaml testbed file,\n            # allowing you to create an inheritance hierarchy.\n            # Supports full path/names or name of file in the same dir.\n            # The content of the last file on the list forms the base and\n            # is updated with the preceding file, and so on,\n            # until the existing file content is updated last.\n            # (optional)\n\n# testbed block\n# -------------\n#   information concerning/common to the whole testbed.\ntestbed:\n\n    name :  # testbed name string.\n            # (default: testbed filename with prefix CONFIG. and/or postfix\n            #           .yaml trimmed)\n            # (optional)\n\n    alias:  # testbed name alias.\n            # (default: same as testbed name)\n            # (optional)\n\n    class:  # testbed object class.\n            # use this field to provide an alternative subclass of\n            # Testbed to instantiate this testbed to. can be used to\n            # extend the base Testbed class functionalities\n            #   Eg: module.submodule.MyTestbedClass\n            # (default: ats.topology.Testbed)\n            # (optional)\n\n\n    credentials:\n        # credential details common to the testbed\n        # (optional)\n\n        <key>:        # name of this credential.\n            username: # (optional)\n            password: # (optional)\n\n            # any other credential details\n            <key>: <value>\n\n    servers:\n        # servers serving/helping and providing services to this entire\n        # testbed. any server described here should ideally be servicing\n        # the entire testbed and accessible by all devices.\n        # (optional)\n\n        <name>: # server name goes here. each server requires its own\n                # description section\n                # (optional)\n\n            server: # server name\n                    # (optional)\n\n            type:   # server type generic string\n                    # use this to describe the type of server\n                    # (optional)\n\n            address:    # server ip address, or list of server ip addresses.\n                        # (optional)\n\n            path:       # path to root folder (eg, tftproot)\n                        # (optional)\n\n            credentials:\n                # credential details common to the server\n                # (optional)\n\n                # All credentials in the testbed credentials block are\n                # also available at this level if not specified here.\n\n                <key>:         # Name of this credential.\n                    username:  # (optional)\n                    password:  # (optional)\n\n                    # Any other credential details\n                    <key>: <value>\n\n            custom:\n                # any custom key/value pairs concerning this server\n                <key>: <value>\n\n    network:\n        # any network key/value pair information concerning this testbed\n        # (optional)\n        <key>: <value>\n\n\n    custom:\n        # any custom key/value pairs common to this entire testbed\n        # (optional)\n        <key>: <value>\n\n\n# devices block\n# -------------\n#   all testbed devices are described here\ndevices:\n\n    <name>: # device name (hostname) goes here. Each device requires its\n            # own description section within devices block\n\n        alias:  # device name alias.\n                # (default: same as device name)\n                # (optional)\n\n        class:  # device object class.\n                # use this field to provide an alternative subclass of\n                # Device to instantiate this device block to. can be used\n                # to extend the base Device class functionalities\n                #   Eg: module.submodule.MyDeviceClass\n                # (default: ats.topology.Device)\n                # (optional)\n\n        type:   # device type generic string\n                # use this to describe the type of device\n                #   Eg: ASR9k\n                # (required)\n\n        region: # device region string\n                # (optional)\n\n        role:   # device role string\n                # (optional)\n\n        chassis_type: # device chassis_type\n                      #  Eg: single_rp/dual_rp/stack/quad\n                      # (optional)\n\n        os:     # device os string\n                #  Eg: iosxe\n                # (optional)\n\n        series: # device series string\n                #  Eg: cat3k\n                # (optional)\n\n        platform:   # device platform string\n                    # Eg: cat9300\n                    # (optional)\n\n        model:  # device model string\n                # (optional)\n\n        power:  # device power string\n                # (optional)\n\n        hardware:   # device hardware block\n                    # may contain anything describing the hardware info\n                    # (optional)\n\n        peripherals:  # device hardware block\n                      # may contain anything describing peripherals\n                      # connected to the device.\n                      # currently supported devices are terminal servers\n                      # and power cyclers.\n                      # (optional)\n\n            terminal_server:  # device terminal server information\n                              # with its ports on which clear line\n                              # needs to be executed\n                              # (optional)\n\n            power_cycler:     # device power cycler information\n                              # to powercycle the device\n                              # (optional)\n\n        credentials:\n            # credential details common to the device\n            # (optional)\n\n            # All credentials in the testbed credentials block are\n            # also available at this level if not specified here.\n\n            <key>:        # Name of this credential.\n                username: # (optional)\n                password: # (optional)\n\n                # Any other credential details\n                <key>: <value>\n\n        connections:\n            # block describing the 'ways', 'methods' and 'paths' of\n            # connecting to this device. eg, telnet, ssh, netconf, etc\n            # (required)\n\n            defaults:\n                # block used to specify and/or alter the default\n                # connection manager behavior\n                # (optional)\n\n                class:  # the default connection implementation class to be\n                        # used by connection manager when arguments such as\n                        # 'cls' in connect() and 'factory' in start_pool()\n                        # is not provided.\n                        # (optional)\n\n                alias:  # the default alias name if 'alias' is not provided\n                        # to apis such as connect(), start_pool(), etc.\n                        # (optional)\n\n                via:    # the default path to use if 'via' is not provided\n                        # to apis such as connect(), start_pool(), etc.\n                        # (default: None - let the connection class decide)\n                        # (optional)\n```\n\n----------------------------------------\n\nTITLE: Applying Loop Parameters for Data-Driven Testing in PyATS AEtest Using Python\nDESCRIPTION: Demonstrates how to supply loop parameters to looped testcases and test sections to provide distinct local parameters per iteration, enabling data-driven test executions. The example shows looping a testcase with parameter 'a' and looping a test with parameter 'b', where each iteration receives different values and test method arguments reflect these parameters. This requires AEtest's support for loop parameters and the parameters_as_funcargs feature. Inputs are per-iteration parameter values passed as lists; outputs are multiple test executions each with corresponding parameter values accessible as function arguments.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/loop.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats import aetest\n\n# loop this testcast with a loop parameter named \"a\"\n# and set it to value 2 for the first iteration, \n# and 3 for the second iteration\n@aetest.loop(a=[2, 3])\nclass Testcase(aetest.Testcase):\n\n    # loop this test with loop parameter named \"b\"\n    # and set it to 8 for the first iteration, 9 for the second.\n    @aetest.test.loop(b=[8, 9])\n    def test(self, a, b):\n        # this test prints the exponential of two inputs, a and b\n        print(\"%s ^ %s = %s\" % (a, b, a**b))\n\n```\n\n----------------------------------------\n\nTITLE: Disconnecting from Multiple Devices in Parallel\nDESCRIPTION: This snippet demonstrates disconnecting from multiple testbed devices in parallel using the `Testbed.disconnect()` function. It also shows how to use unique vias for connections and shared keyword arguments. It uses threads under the hood.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/topology/usage.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n# disconnecting from devices in parallel\n# using the sample topology file from\nfrom pyats import topology\ntestbed = topology.loader.load('your-testbed-file.yaml')\n# connect to all devices in this testbed\ntestbed.connect()\n# disconnect from all devices in this testbed\ntestbed.disconnect()\n# disconnect from some devices in this testbed\ntestbed.disconnect(testbed.devices['uut'],\n                testbed.devices['helper'])\n# disconnect from some devices in this testbed\n# and provide unique vias\ntestbed.disconnect(testbed.devices['uut'],\n                testbed.devices['helper'],\n                vias = {'uut': 'cli',\n                        'helper': 'console'})\n# disconnect from some devices in this testbed\n# using unique vias per device, and shared kwargs\n# shared keyword-arguments will be passed to every single connection\ntestbed.disconnect(testbed.devices['uut'],\n                testbed.devices['helper'],\n                vias = {'uut': 'cli',\n                        'helper': 'console'},\n                        log_stdout = False)\n```\n\n----------------------------------------\n\nTITLE: Adding, Modifying, and Deleting Topology Objects (pyATS Python)\nDESCRIPTION: Provides a comprehensive example of dynamically changing the topology of a loaded testbed. It covers adding a new device, modifying the testbed's alias, adding a new interface to an existing device (and linking it), adding custom attributes, removing an interface, moving a device to a different testbed, and using the `squeeze()` method to filter the testbed to include only specified devices/links. It also highlights how object relationships are maintained during these operations.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/topology/usage.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   topology adding/deleting and modifying\n\n# continuing to use the same sample topology file from\n# the first example\nimport os\nfrom pyats import topology\n\ntestbedfile = os.path.join(os.path.dirname(topology.__file__),\n                               'sampleTestbed.yaml')\ntestbed = topology.loader.load(testbedfile)\n\n# add a new device\n# note - could also do this with\n#   topology.Device('myNewDevice', testbed = testbed)\nnew_device = topology.Device('myNewDevice')\ntestbed.add_device(new_device)\ntestbed.devices\n# AttrDict({'ott-tb1-n7k5': <Device ott-tb1-n7k5 at 0xf76990cc>,\n#           'ott-tb1-n7k4': <Device ott-tb1-n7k4 at 0xf73ce2ac>,\n#           'myNewDevice': <Device myNewDevice at 0xf74aa78c>})\n\n# modify a testbed alias\ntestbed.alias = 'newAlias'\n\n# add new interfaces (to existing device)\nn7k4 = testbed.devices['ott-tb1-n7k4']\ninterface = topology.Interface('Ethernet9/40', 'ethernet')\ninterface.link = topology.Link('newLink')\nn7k4.add_interface(interface)\nn7k4.interfaces\n# AttrDict({'Ethernet9/40': <Interface Ethernet9/40 at 0xf73ce98c>,\n#           'Ethernet4/45': <Interface Ethernet4/45 at 0xf73ce28c>,\n#           'Ethernet4/46': <Interface Ethernet4/46 at 0xf73ce36c>,\n#           'Ethernet4/2': <Interface Ethernet4/2 at 0xf73ce24c>,\n#           'Ethernet4/6': <Interface Ethernet4/6 at 0xf73ce18c>,\n#           'Ethernet4/7': <Interface Ethernet4/7 at 0xf73ce2ec>,\n#           'Ethernet4/1': <Interface Ethernet4/1 at 0xf73ce34c>})\n\n# modify device information\nn7k4.custom['newCustomInfo'] = 'new information that did not exist before'\n\n# removing interfaces\nn7k5 = testbed.devices['ott-tb1-n7k5']\nn7k5.remove_interface('Ethernet5/1')\n\n# now the number of connections changed:\nfor link in n7k4.find_links(n7k5):\n    print(repr(link))\n# <Link rtr1-rtr2-2 at 0xf73ce0ec>\n\n# let's create a new testbed and move n7k5 over to it.\nnew_testbed = topology.Testbed('newTestbed')\nn7k5.testbed = new_testbed\n\n# notice how everything changed over\nn7k4.interfaces['Ethernet4/2'].link.interfaces[0].device\n# <Device ott-tb1-n7k5 at 0xf76990cc>\nn7k4.interfaces['Ethernet4/2'].link.interfaces[0].device.testbed.name\n# 'newTestbed'\n\n# since now link rtr1-rtr2-2 connects 2 testbeds, it is contained in\n# both sides\nlink = n7k4.interfaces['Ethernet4/2'].link\nlink in testbed.links and link in new_testbed.links\n# True\n\n# let's squeeze a topology\n# (reduce a topology to a wanted list of devices and/or links,\n# aliases are respected, interfaces not connected to wanted links\n# are removed):\ntestbed = topology.loader.load(testbedfile)\ntestbed.squeeze('device-1', 'rtr1-rtr2-1', extend_devices_from_links=True)\n[device.name for device in testbed]\n# ['ott-tb1-n7k4', 'ott-tb1-n7k5']\n[link.name for link in testbed.links]\n# ['rtr1-rtr2-1']\n[interface.name for interface in testbed.devices['device-1']]\n# ['Ethernet4/1']\n[interface.name for interface in testbed.devices['device-2']]\n# ['Ethernet5/1']\n```\n\n----------------------------------------\n\nTITLE: Installing PyATS via pip\nDESCRIPTION: This snippet demonstrates how to upgrade the PyATS testing framework using the pip package installer. It provides two examples, one for the DevNet community and another for Cisco internal developers.  This uses the --upgrade flag to update existing installations.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2020/aug.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats\n```\n\nLANGUAGE: bash\nCODE:\n```\n# Cisco Internal Developers\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Using CLI '--retry' Argument to Enable Retry in pyats\nDESCRIPTION: Shows how to enable retries in pyats command-line interface with the '--retry' argument, optionally providing a configuration file or JSON/Key-Value data for detailed retry settings like specific sections, retries count, and wait times, supporting flexible retry configurations.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/retry.rst#_snippet_2\n\nLANGUAGE: Text\nCODE:\n```\npyats run manifest job.tem --retry\n```\n\n----------------------------------------\n\nTITLE: Raising AEtestInternalSignals Exceptions to Signal Test Results in pyATS AEtest Using Python\nDESCRIPTION: This example shows how to use internal pyATS AEtest signaling exceptions to immediately assign a test result and terminate execution of the current test subsection. It imports AEtestAbortedSignal and raises it with a reason string inside a CommonCleanup subsection. These signals subclass BaseException intentionally to avoid being caught by generic exception handlers, ensuring proper propagation to the test engine. This technique allows for programmatically controlling test outcomes within script execution flow.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/results.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats import aetest\nfrom pyats.aetest.signals import AEtestAbortedSignal\n\nclass CommonCleanup(aetest.CommonCleanup):\n\n    @aetest.subsection\n    def subsection(self):\n        # subsection getting aborted using signaling\n        raise AEtestAbortedSignal(reason = 'feeling it.')\n```\n\n----------------------------------------\n\nTITLE: Specifying Pause-On Phrases or File in AEtest - Python and Bash\nDESCRIPTION: Allows the test execution to pause based on matching phrase(s), which can be specified as a string, file path, or dictionary content string. This enables interactive pauses when specific phrases appear during testing. Input is string or path; output is a pause to user for interaction. Provided via command-line or API parameters.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/run.rst#_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\nbash$ python testscript.py -pause_on=\"some string to pause\"\n```\n\nLANGUAGE: python\nCODE:\n```\naetest.main('testscript.py', pause_on = \"/path/to/my/pause_on_file\")\n```\n\nLANGUAGE: python\nCODE:\n```\nrun(testscript = 'testscript.py', pause_on = \"/path/to/my/pause_on_file\")\n```\n\n----------------------------------------\n\nTITLE: Cloning pyATS Result Objects with Custom Data in Python\nDESCRIPTION: Illustrates creating a distinct result object (of the same result type) by cloning the base pyats.results.Passed object and attaching contextual data such as a reason string and a data dictionary. This pattern supports richer reporting by carrying extra information along with the test result. Requires the pyats.results module. Key parameters: reason (string specifying pass explanation), data (any serializable object holding extra data). Output is a unique result object unequal by identity to the base constant.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/results/objects.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   distinct result objects\n\nfrom pyats.results import Passed\n\n# we can make our own passed result from the base one. Both are \"Passed\",\n# but the new result now contains relevant information.\nmypassed = Passed.clone(reason = 'reason for passing',\n                        data = {'numbers': [1,2,3,4,5]})\n\nmypassed == Passed # True\nmypassed is Passed # False\nmypassed.reason # 'reason for passing'\nPassed.reason # None\n```\n\n----------------------------------------\n\nTITLE: Creating a pyATS Job File for Script Arguments with aetest in Python\nDESCRIPTION: This snippet demonstrates writing a pyATS job file with a main() function that invokes a test script with specific arguments, enabling automation and integration into test pipelines. It requires importing run from pyats.easypy and calling run() with script name and parameters. When executed via 'pyats run job', the script arguments are passed appropriately, facilitating automated test execution.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/examples.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   job file demonstrating passing script arguments to testscripts\n\nfrom pyats.easypy import run\n\n# job file requires a main block\ndef main():\n\n    run('script_argument_demo.py', vlan = 50)\n\n# To run under Easypy, save as script_argument_demo_job.py and execute:\n#\n# bash$ pyats run job script_argument_demo_job.py --testbed-file /path/to/testbed.yaml\n```\n\n----------------------------------------\n\nTITLE: Example usage of skip decorators in pyATS aetest\nDESCRIPTION: Demonstrates how to use @aetest.skip, @aetest.skipIf, @aetest.skipUnless decorators, and their affix counterparts to conditionally skip testcases or test sections based on various criteria such as version checks or runtime conditions.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/control.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats import aetest\n\n# skip testcase intentionally\n@aetest.skip('because we had to')\nclass Testcase(aetest.Testcase):\n    pass\n\nclass TestcaseTwo(aetest.Testcase):\n\n    # skip test section using if library version < some number\n    @aetest.skipIf(mylibrary.__version__ < (1, 3),\n                   'not supported in this library version')\n    @aetest.test\n    def test_one(self):\n        pass\n\n    # skip unless library version > some number\n    @aetest.skipUnless(mylibrary.__version__ > (1, 3),\n                       'not supported in this library version')\n    @aetest.test\n    def test_two(self):\n        pass\n\n    @aetest.test\n    def test_three(self):\n        aetest.skip.affix(section=TestcaseTwo.test_four, reason='message')\n        aetest.skipIf.affix(section=TestcaseTwo.test_five, condition=True, reason='message')\n        aetest.skipUnless.affix(section=TestcaseThree, condition=False, reason='message')\n\n    @aetest.test\n    def test_four(self):\n        # will be skipped because of test_three\n        pass\n\n    @aetest.test\n    def test_five(self):\n        # will be skipped because of test_three\n        pass\n\n    @aetest.test\n    def test_six(self):\n        # will be skipped because of test_three\n        pass\n\nclass TestcaseThree(aetest.Testcase):\n    # will be skipped because of TestcaseTwo.test_three\n    pass\n```\n\n----------------------------------------\n\nTITLE: Making pyATS Processor Reportable - Python\nDESCRIPTION: Shows how to use the `@aetest.processors.report` decorator to make a processor function appear as a reportable section in the test results. By default, processors are not reported, but this decorator changes that behavior.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/processors.rst#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n@aetest.processors.report\ndef my_post_processor(section):\n    print(section.result)\n```\n\n----------------------------------------\n\nTITLE: Installing pyATS Upgrade via pip for Different User Groups\nDESCRIPTION: Commands for upgrading pyATS packages. There are two different installation commands - one for DevNet Community users and another for Cisco Internal Developers.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2019/apr.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats\n\n# Cisco Internal Developers\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Defining a BasePlugin subclass\nDESCRIPTION: This code demonstrates how to create a new Easypy plugin by subclassing the `BasePlugin` class. It showcases defining a plugin name, configuring an argument parser, and implementing stage actions like `pre_job`, `post_job`, `pre_task`, and `post_task` to execute custom logic at various points in the Easypy workflow. Demonstrates how to access command line arguments and runtime attributes.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/easypy/plugins.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n    # Example\n    # --------\n    #\n    #   hello-world plugin\n\n    import logging\n    import argparse\n    import datetime\n\n    from pyats.easypy.plugins.bases import BasePlugin\n\n    logger = logging.getLogger(__name__)\n\n    class HelloWorldPlugin(BasePlugin):\n        '''HelloWorld Plugin\n\n        Runs before and after each job and task, saluting the world and printing\n        out the job/task runtime if a custom flag is used.\n        '''\n\n        # each plugin may have a unique name\n        # set it by setting the 'name' class variable.\n        # (defaults to the current class name)\n        name = 'HelloWorld'\n\n        # each plugin may have a parser to parse its own command line arguments.\n        # these parsers are expected to add arguments to the main easypy parser\n        @classmethod\n        def configure_parser(cls, parser, legacy_cli = False):\n            '''\n            plugin parser configurations\n\n            Arguments\n            ---------\n                parser: main program parser to update\n                legacy_cli: boolean indicating whether to support legacy args or\n                            not\n            '''\n            # always create a plugin's own parser group\n            hello_world_grp = parser.add_argument_group(\"My Hello World\")\n\n            # custom arguments shall always use -- as prefix\n            # positional custom arguments are NOT allowed.\n            hello_world_grp.add_argument('--print-timestamp',\n                                         action = 'store_true',\n                                         default = False)\n\n        # plugins may define its own class constructor __init__, though, it\n        # must respect the parent __init__, so super() needs to be called.\n        # any additional arguments defined in the plugin config file would be\n        # passed to here as keyword arguments\n        def __init__(self, *args, **kwargs):\n            super().__init__(*args, **kwargs)\n\n        # define your plugin's stage actions as methods\n        # as this plugin should run pre and post job\n        # we need to deifne 'pre_job' and 'post_job' methods.\n\n        # define the pre-job action\n        # if 'job' is specified as a function argument, the current Job\n        # object is provided as input to this action method when called\n        def pre_job(self, job):\n\n            # plugin parser results are stored under self.runtime.args\n            if self.runtime.args.print_timestamp:\n                self.job_start = datetime.datetime.now()\n                logger.info('Current time is: %s' % self.job_start)\n\n            logger.info('Pre-Job %s: Hello World!' % job.name)\n\n        # define post_job action\n        def post_job(self, job):\n\n            if self.runtime.args.print_timestamp:\n                self.job_end = datetime.datetime.now()\n                logger.info('Job run took: %s' % self.job_end - self.job_start)\n\n            logger.info('Post-Job %s: Hello World!' % job.name)\n\n        # similarly, with pre and post-task methods\n        # if a 'task' argument is specified as a function argument, the current\n        # Task object is provided as input to this action method on call.\n        def pre_task(self, task):\n            if self.runtime.args.print_timestamp:\n                self.task_start = datetime.datetime.now()\n                logger.info('Current time is: %s' % self.task_start)\n\n            logger.info('Pre-Task %s: Hello World!' % task.taskid)\n\n        def post_task(self, task):\n            if self.runtime.args.print_timestamp:\n                self.task_end = datetime.datetime.now()\n                logger.info('Task run took: %s' %\n                            self.task_end - self.task_start)\n\n            logger.info('Post-Task %s: Hello World!' % task.taskid)\n```\n\n----------------------------------------\n\nTITLE: Python Dictionary Pause Configuration\nDESCRIPTION: This Python snippet shows how to configure 'pause_on' using a dictionary, which is equivalent to the YAML configuration. It defines a timeout value and a list of patterns, each with a pattern and an optional section for more targeted pausing during test execution.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/debugging.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   dict format corresponding to the above\n\npause_on = {'timeout': 600,\n            'patterns': [{'pattern': '.*pass.*'},\n                         {'pattern': '.*state: down.*',\n                          'section': '^common_setup\\..*$'}, \n                         {'pattern': '.*should pause.*',\n                          'section': '^TestcaseTwo\\.setup$'}]}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Exception Result Behaviors in aetest\nDESCRIPTION: This code snippet illustrates how different exception types are handled within the aetest framework.  It defines two tests: one that raises a KeyError (expected to result in 'Errored') and another that uses an assert statement which fails, resulting in an AssertionError (expected to result in 'Failed').  The output demonstrates these expected behaviors.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/results.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats import aetest\n\nclass Testcase(aetest.Testcase):\n\n    # defining a test that raises a python exception\n    # the expected behavior is test Errored\n    @aetest.test\n    def test_one(self):\n        # creating an empty dictionary and accessing a key\n        # that does not exist raises KeyError Exception\n        {}['key does not exist']\n\n    # defining a test that raises an AssertionError\n    # the expected behavior is test Failed\n    @aetest.test\n    def test_two(self):\n        # do an assertion that fails.\n        assert 1 == 0, \"unfortunately 1 doesn't equal to 0\"\n```\n\n----------------------------------------\n\nTITLE: Showing pyATS Command Usage and Subcommands - Bash\nDESCRIPTION: This snippet demonstrates the basic command-line usage of the pyATS tool. It shows the general syntax `pyats <command> [options]` and lists the core subcommands available, such as `run`, `clean`, `parse`, `learn`, `diff`, etc. These subcommands represent the main operations provided by the pyATS framework accessible via the command line.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/cli/pyats.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nUsage:\n  pyats <command> [options]\n\nCommands:\n    clean               runs the provided clean file\n    create              create scripts and libraries from template\n    diff                Command to diff two snapshots saved to file or directory\n    learn               Command to learn device features and save to file\n    logs                command enabling log archive viewing in local browser\n    migrate             utilities for migrating to future versions of pyATS\n    parse               Command to parse show commands\n    run                 runs the provided script and output corresponding results.\n    secret              utilities for working with secret strings.\n    shell               enter Python shell, loading a pyATS testbed file and/or pickled data\n    validate            utilities that help to validate input files\n    version             commands related to version display and manipulation\n\nGeneral Options:\n  -h, --help            Show help\n\nRun 'pyats <command> --help' for more information on a command.\n```\n\n----------------------------------------\n\nTITLE: Parameters as Function Arguments - Python\nDESCRIPTION: The snippet illustrates how to use parameters as function arguments within aetest. It shows how to define default script-level parameters. It demonstrates how to declare section methods that require specific parameters, which are then passed in as function arguments. It uses a `setup`, `test`, and `cleanup` methods within an `aetest.Testcase`, and shows how the parameters get aggregated and passed down.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/parameters.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats import aetest\n\n    # define some default script-level parameters\n    #   param_A: a static value of 1\n    #   param_B: an empty dictionary\n    parameters = {\n        'param_A': 1,\n        'param_B': dict(),\n    }\n\n    class Testcase(aetest.Testcase):\n\n        # this setup section definition identifies \"param_B\" as\n        # as a input requirement. as this parameter is available at this\n        # testcase level (aggregated from parent testscript), it\n        # is passed in as input\n        @aetest.setup\n        def setup(self, param_B):\n\n            # param_B is a dictionary (mutable)\n            # any modification to this dictionary persists\n            param_B['new_key'] = \"a key added during setup section\"\n\n        # section needing both \"param_A\" and \"param_B\"\n        @aetest.test\n        def test_one(self, param_A, param_B):\n            print(param_A)\n            # 1\n            print(param_B)\n            # {'new_key': 'a key added during setup section'}\n\n        # calling for a non-existent parameter\n        # hence the default value is taken\n        # (if no defaults are provided, an exception is raised)\n        @aetest.test\n        def test_two(self, param_non_existent = 1000):\n            print(param_non_existent)\n            # 1000\n\n        # using arbitrary keywords **kwargs\n        # all known parameters are passed in as a dictionary\n        @aetest.cleanup\n        def cleanup(self, **kwargs):\n            print(kwargs)\n            # {'param_A': 1,\n            #  'param_B': {'new_key': 'a key added during setup section'}}\n```\n\n----------------------------------------\n\nTITLE: Running a pyATS Job with 'pyats run job' CLI Subcommand\nDESCRIPTION: Provides usage instructions, examples, and options for executing a pyATS job file, including configuration, mailing, reporting, runinfo, liveview, testbed, cleaning, and rerun options. It describes dependencies like job files and configuration files, and explains parameters controlling execution behavior and reporting output.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/cli/pyats_run.rst#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nUsage:\n  pyats run job [file] [options]\n\nExample\n-------\n  pyats run job /path/to/jobfile.py\n  pyats run job /path/to/jobfile.py --testbed-file /path/to/testbed.yaml\n\nDescription:\n  Runs a pyATS job file with the provided arguments, generating & report result.\n\nConfiguration:\n  -C, --configuration FILE\n                        easypy configuration yaml file for plugins\n\nJob Information:\n  JOBFILE               target jobfile to be launched\n  --job-uid             Unique ID identifiying this job run\n  --pyats-configuration\n                        pyats configuration override file\n\nMailing:\n  --no-mail             disable report email notifications\n  --mail-to             list of report email recipients\n  --mail-subject        report email subject header\n  --mail-html           enable html format report email\n\nReporting:\n  --submitter           Specify the current submitter user id\n  --image               Specify the image under test\n  --release             Specify the release being tested\n  --branch              Specify the branch being tested\n  --meta                Specify some meta information as a dict (supports base64 encoded strings)\n  --no-xml-report       Disable generation of the XML Report\n\nRuninfo:\n  --no-archive          disable archive creation\n  --no-archive-subdir   disable archive subdirectory creation\n  --runinfo-dir         specify alternate runinfo directory\n  --archive-dir         specify alternate archive directory\n  --archive-name        specify alternate archive file name\n\nLiveview:\n  --liveview            Starts a liveview server in a separate process\n  --liveview-host HOST  Specify host for liveview server. Default is localhost\n  --liveview-port PORT  Specify port for liveview server.\n  --liveview-hostname HOSTNAME\n                        Displayed hostname for liveview.\n  --liveview-displayed-url LIVEVIEW_DISPLAYED_URL\n                        Displayed url for liveview, for example, http://<liveview_hostname>:<port>\n  --liveview-keepalive  Keep log viewer server alive after the run finishes.\n  --liveview-callback-url LIVEVIEW_CALLBACK_URL\n                        Specify xpresso callback url for jenkins run.\n  --liveview-callback-token LIVEVIEW_CALLBACK_TOKEN\n                        Specify xpresso token for jenkins run.\n\nTestbed:\n  -t, --testbed-file    Specify testbed file location\n\nClean:\n  --clean-file FILE [FILE ...]\n                        Specify clean file location(s). Multiple clean files can be specified by\n                        separating them with spaces.\n  --clean-devices [ [ ...]]\n                        Specify list of devices to clean, separated by spaces. To clean groups of\n                        devices sequentially, specify as \"[[dev1, dev2], dev3]\".\n  --clean-scope {job,task}\n                        Specify whether clean runs before job or per task\n  --invoke-clean        Clean is only invoked if this parameter is specified.\n  --clean-device-image        space separated images per device with format device:/path/to/image.bin\n  --clean-os-image            space separated images per OS with format os:/path/to/image.bin\n  --clean-group-image         space separated images per group with format group:/path/to/image.bin\n  --clean-platform-image      space separated images per platform with format platform:/path/to/image.bin\n\nBringup:\n  --logical-testbed-file\n                        Specify logical testbed file location\n\nRerun:\n  --rerun-file FILE     rerun.results file that contains the information of tasks and testcases\n  --rerun-task  [ ...]  TASKID TESTSCRIPT [TESTCASES...] Details to identify a specific Task to\n                        rerun. Can be used multiple times for multiple tasks.\n  --rerun-condition  [ ...]\n                        Results type list for the condition of rerun plugin.\n\nxUnit:\n  --xunit [DIR]         Generate xunit report in the provided location. If used as a flag, generates\n                        xunit reports runtime directory\n\nHTML Logging:\n  --html-logs [DIR]     Directory to generate HTML logs in addition to any existing log files. Note\n                        - will increase archive size due to log duplication.\n\nGeneral Options:\n  -h, --help            Show help information\n  -v, --verbose         Give more output, additive up to 3 times.\n  -q, --quiet           Give less output, additive up to 3 times, corresponding to WARNING, ERROR,\n                        and CRITICAL logging levels\n```\n\n----------------------------------------\n\nTITLE: Simple Hello World Testscript using pyATS aetest in Python\nDESCRIPTION: This script demonstrates the minimal 'Hello World' example with pyATS aetest. It includes a Testcase class with a single test method that logs 'Hello World!'. Dependencies include pyats.aetest and Python's logging module. The script configures the logger level and runs the test using aetest.main().\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/examples.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   hello world\n\nimport logging\nfrom pyats import aetest\n\nlogger = logging.getLogger(__name__)\n\nclass HelloWorld(aetest.Testcase):\n\n    @aetest.test\n    def test(self):\n        logger.info('Hello World!')\n\n# main()\nif __name__ == '__main__':\n    # set logger level\n    logger.setLevel(logging.INFO)\n\n    aetest.main()\n```\n\n----------------------------------------\n\nTITLE: Defining Network Testbeds in YAML for pyATS Framework\nDESCRIPTION: This YAML snippet illustrates the structure of a pyATS testbed file used to describe network devices, credentials, connections, and interface topology. Dependencies include YAML parsers supported by pyATS and valid network topology concepts. The snippet defines device hostnames, OS types, connection methods (such as telnet and ssh), IP addresses, ports, and interface details with IPv4 and IPv6 addresses, and linkage between device interfaces. This file acts as core input describing physical network under test, facilitating device interaction and topology queries.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/getting_started/index.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n# Example\n# -------\n#\n#   an example testbed file - ios_testbed.yaml\n\ntestbed:\n    name: IOS_Testbed\n    credentials:\n        default:\n            username: admin\n            password: cisco\n        enable:\n            password: cisco\n\ndevices:\n    ios-1: # <----- must match to your device hostname in the prompt\n        os: ios\n        type: ios\n        connections:\n            a:\n                protocol: telnet\n                ip: 1.1.1.1\n                port: 11023\n    ios-2:\n        os: ios\n        type: ios\n        connections:\n            a:\n                protocol: telnet\n                ip: 1.1.1.2\n                port: 11024\n            vty:\n                protocol: ssh\n                ip: 5.5.5.5\ntopology:\n    ios-1:\n        interfaces:\n            GigabitEthernet0/0:\n                ipv4: 10.10.10.1/24\n                ipv6: '10:10:10::1/64'\n                link: link-1\n                type: ethernet\n            Loopback0:\n                ipv4: 192.168.0.1/32\n                ipv6: '192::1/128'\n                link: ios1_Loopback0\n                type: loopback\n    ios-2:\n        interfaces:\n            GigabitEthernet0/0:\n                ipv4: 10.10.10.2/24\n                ipv6: '10:10:10::2/64'\n                link: link-1\n                type: ethernet\n            Loopback0:\n                ipv4: 192.168.0.2/32\n                ipv6: '192::2/128'\n                link: ios2_Loopback0\n                type: loopback\n```\n\n----------------------------------------\n\nTITLE: Accessing and Setting AttrDict Elements - pyATS - Python\nDESCRIPTION: Explains that AttrDict allows both standard dictionary key access (`[]`) and attribute access (`.`) for getting and setting values. Demonstrates retrieving values and adding a new key/attribute. Requires an AttrDict instance.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/datastructures/attrdict.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   attribute dictionary access\n\nfrom pyats.datastructures import AttrDict\nattrdict = AttrDict(key = 'value', a = 1)\n\n# access it as if it was a dictionary\nattrdict['key']\n# 'value'\nattrdict['a']\n# 1\n\n# access it as attributes\nattrdict.key\n# 'value'\nattrdict.a\n# 1\n\n# set attributes is the same as adding new keys\n#   same as attrdict['b'] = 2\nattrdict.b = 2\nattrdict\n```\n\n----------------------------------------\n\nTITLE: Configuring CLI Parser Arguments for Service Wrapper in Python\nDESCRIPTION: Class method configure_parser sets up CLI argument parsing for the service wrapper, enabling integration with command-line interfaces. It adds an argument called '--service-wrapper-arg' which stores a boolean flag. This method takes an argparse.ArgumentParser instance and returns it after modification. Implementors can use this to add custom CLI options to their wrappers.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/connections/wrapper.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n@classmethod\n    def configure_parser(cls, parser: argparse.ArgumentParser) -> None:\n        parser.add_argument(\n            '--service-wrapper-arg',\n            dest='service_wrapper_arg',\n            action='store_true',\n            help='Service Wrapper argument',\n        )\n\n        return parser\n```\n\n----------------------------------------\n\nTITLE: Example of dynamically setting uids during test execution in pyATS\nDESCRIPTION: Illustrates how to assign a logical condition to runtime.uids within a test script, allowing dynamic control of which test sections are executed based on criteria such as name patterns or other attributes.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/control.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats import aetest\n\n# using logics\nfrom pyats.datastructures.logic import Not, And\n\nclass CommonSetup(aetest.CommonSetup):\n    \n    @aetest.subsection\n    def subsection(self):\n        \n        # set uids dynamically during runtime\n        # eg, run all tests with bgp in the name, but not traffic.\n        aetest.runtime.uids = And('.*bgp.*', Not('traffic'))\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Weak Reference Relationships in pyATS Topology - Python\nDESCRIPTION: This snippet demonstrates the creation of pyATS topology objects (Testbed, Device, Interface, Link) and how they relate using weak references to prevent circular dependencies. It shows how Testbed holds strong references to Devices, Devices hold weak references to their Testbed parent, and similarly for Interfaces and Links. The code illustrates the setup of these objects, their hierarchical relationships, and how weak referencing ensures Python garbage collection rules apply properly.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/topology/usage.rst#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   demonstration of where weak references apply\n\n# import objects\nfrom pyats.topology import Testbed, Device, Interface, Link\n\n# create the objects\ntestbed = Testbed('exampleTestbed')\ndevice = Device('exampleDevice')\ninterface = Interface('exampleInterface', 'ethernet')\nlink = Link('exampleLink')\n\n# hook up the relationship\ntestbed.add_device(device)\ndevice.add_interface(interface)\nlink.connect_interface(interface)\n\n# testbed contains devices as actual references\ntestbed.devices\n# AttrDict({'exampleDevice': <Device exampleDevice at 0xf763c70c>})\n\n# device.testbed is internally stored as a weak reference to testbed,\n# even though it returns the actual testbed object\ntestbed.device\n# <pyats.topology.testbed.Testbed object at 0xf763c6ac>\n\n# device.interfaces contains interfaces as actual references\ndevice.interfaces\n# AttrDict({'exampleInterface': <Interface exampleInterface at 0xf763c74c>})\n\n# interface.device is internally stored as a weak reference\n# even though it returns the actual device object\ninterface.device\n# <Device exampleDevice at 0xf763c70c>\n\n# interface connects to links as an actual reference\ninterface.link\n# <Link exampleLink at 0xf763ca8c>\n\n# links contain only weak references to interfaces\n# even though when you access it, it returns actual objects\nlink.interfaces\nWeakList([<Interface exampleInterface at 0xf763c74c>])\nlink.interfaces[0]\n# <Interface exampleInterface at 0xf763c74c>\n```\n\n----------------------------------------\n\nTITLE: Parametrized Number Generation\nDESCRIPTION: This function `number` uses the `random.randint()` API and is parameterized with `lower_bound` and `upper_bound`.  It accepts `lower_bound` and `upper_bound` as input, then returns a random integer within this bound.  The function is decorated with `@aetest.parameters.parametrize` and is used when the function is evaluated.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/parameters.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n    # ------------------------------------------------\n    # this function accepts a lower and an upper bound, and\n    # uses the random.randint() api to do the actual work.\n    # as part of this parametrization declaration, notice that\n    # a lower_bound and an upper_bound was provided. these values\n    # are used as function arguments when the function is evaluated\n    @aetest.parameters.parametrize(lower_bound=1, upper_bound=100)\n    def number(lower_bound, upper_bound):\n        return random.randint(lower_bound, upper_bound)\n```\n\n----------------------------------------\n\nTITLE: Dynamic Loop Marking in PyATS\nDESCRIPTION: This code demonstrates dynamically marking sections for looping during runtime. The `aetest.loop.mark()` function is used within the `setup` section of a testcase. This means the looping configuration isn't explicitly defined in the test method's decorator, but rather, is determined at runtime, providing flexibility for dynamic test behavior based on runtime conditions.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/loop.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats import aetest\n\nclass Testcase(aetest.Testcase):\n\n    @aetest.setup\n    def setup(self):\n        # mark the next test for looping\n        # provide it with two unique test uids.\n        # (self.simple_test is the next test method)\n        aetest.loop.mark(self.simple_test, uids=['test_one', 'test_two'])\n\n    # note: the simple_test section is not directly marked for looping\n    # instead, during runtime, its testcase's setup section marks it for\n    # looping dynamically.\n\n    @aetest.test\n    def simple_test(self, section):\n        # print the current section uid\n        # by using the internal parameter \"section\"\n```\n\n----------------------------------------\n\nTITLE: Accessing and Updating Parameters Dynamically in aetest\nDESCRIPTION: This example demonstrates how to dynamically access and update parameters within a test section (setup and test) in aetest. It shows how to add new parameters, overwrite existing parameters (shadowing parent parameters), and access parent testscript parameters using `self.parent.parameters`.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/parameters.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   continuing from the above\n\n# re-defining the testcase for the sake of code-continuity\nclass Testcase(aetest.Testcase):\n\n    # local parameters defaults, same as above\n    parameters = {\n        'generic_param_A': 200\n    }\n\n    # within any sections, the parent container parameters are directly\n    # accessible (applicable to setup/test/cleanup and subsections)\n\n    # here we'll do a combination access & updating of parameters\n    @aetest.setup\n    def setup(self):\n        # add to the parameters dict\n        self.parameters['new_parameter_from_setup'] = 'new value'\n\n        # overwrite a testscript parameter\n        # note that this creates a local parameter with the same\n        # name, and shadows the one from the parent testscript.\n        # the actual parent testscript parameter is unchanged.\n        self.parameters['testscript_param_A'] = 'another value'\n\n    @aetest.test\n    def test(self):\n        # access & print parent testscript parameters\n        # (following the parent model)\n        print(self.parent.parameters)\n        # {'generic_param_A': 100,\n```\n\n----------------------------------------\n\nTITLE: Waiting for Tasks in pyATS\nDESCRIPTION: This snippet shows how to wait for a task to finish, with a maximum runtime. It also shows how to check the task result and conditionally execute the next task based on the previous task's result.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/easypy/jobfile.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n        # wait for a max runtime of 60*5 seconds = 5 minutes\n        task_1.wait(60*5)\n\n        # check whether the next script should continue\n        # based on previous task's results.\n        if task_1.result:\n            # last result passed, run the next task\n            task_2 = Task(testscript = 'script_two.py',\n                          runtime = runtime,\n                          taskid = 'example_task_1')\n\n            # start & wait\n            task_2.start()\n            task_2.wait(60*5)\n```\n\n----------------------------------------\n\nTITLE: Simple Device Connection using pyATS Topology\nDESCRIPTION: This example demonstrates a simplistic connection to a device using the pyATS topology module. It includes loading an inline testbed, connecting to a device, executing commands, and disconnecting. The example uses a telnet connection to a device named 'tplana-hath'.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/connections/integration.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   simplistic connection example \n\n# using the topology module\nfrom pyats import topology\n\n# let's write an inline testbed file for simplicity\n# (edit this to whatever your testbed looks like)\ntestbed = topology.loader.load('''\ntestbed:\n    name: my-inline-testbed\n\ndevices:\n    tplana-hath:\n        type: iosxe\n        os: iosxe\n        connections:\n            a:\n                protocol: telnet\n                ip: 10.1.1.1\n                port: 10000\n''')\n\n# pick the device to work with\ndevice = testbed.devices['tplana-hath']\n\n# we should be able to directly connect to it\ndevice.connect()\nassert device.connected\n\n# run the various services associated with this connection\ndevice.execute('show version')\ndevice.configure('clock set 18:00:00 April 4 2063')\n\n# disconnect from it\ndevice.disconnect()\n```\n\n----------------------------------------\n\nTITLE: Standalone Reporter Output Example\nDESCRIPTION: This code block shows an example of the output generated by the StandaloneReporter when running aetest scripts directly from the command line. It displays the testcase results in a tree-like structure, showing sections, testcases, and steps with their respective results.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/reports.rst#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n# Example\n# -------\n#\n#   the following is an example standalone reporter ouput\n\n+------------------------------------------------------------------------------+\n|                               Detailed Results                               |\n+------------------------------------------------------------------------------+\n SECTIONS/TESTCASES                                                      RESULT\n--------------------------------------------------------------------------------\n.\n|-- common_setup                                                         PASSED\n|   |-- sample_subsection_1                                              PASSED\n|   `-- sample_subsection_2                                              PASSED\n|-- tc_one                                                               PASSED\n|   |-- prepare_testcase                                                 PASSED\n|   |-- simple_test_1                                                    PASSED\n|   |-- simple_test_2                                                    PASSED\n|   `-- clean_testcase                                                   PASSED\n|-- TestcaseWithSteps                                                   ERRORED\n|   |-- setup                                                            PASSED\n|   |   |-- Step 1: this is a description of the step                    PASSED\n|   |   `-- Step 2: another step                                         PASSED\n|   |-- step_continue_on_failure_and_assertions                          FAILED\n|   |   |-- Step 1: assertion errors -> Failed                           FAILED\n|   |   `-- Step 2: allowed to continue executing                        FAILED\n|   |-- steps_errors_exits_immediately                                  ERRORED\n|   |   `-- Step 1: exceptions causes all steps to skip over            ERRORED\n|   `-- steps_with_child_steps                                           PASSED\n|       |-- Step 1: test step one                                        PASSED\n|       |-- Step 1.1: substep one                                        PASSED\n|       |-- Step 1.1.1: subsubstep one                                   PASSED\n|       |-- Step 1.1.1.1: subsubsubstep one                              PASSED\n|       |-- Step 1.1.1.1.1: running out of indentation                   PASSED\n|       |-- Step 1.1.1.1.1.1: definitely gone too far...                 PASSED\n|       |-- Step 1.2: substep two                                        PASSED\n|       |-- Step 2: test step two                                        PASSED\n|       |-- Step 2.1: function step one                                  PASSED\n|       |-- Step 2.2: function step two                                  PASSED\n|       `-- Step 2.3: function step three                                PASSED\n`-- common_cleanup                                                       PASSED\n    `-- clean_everything                                                 PASSED\n```\n\n----------------------------------------\n\nTITLE: Using Loop Decorator Shortcuts for Subsection and Test Looping in PyATS AEtest with Python\nDESCRIPTION: Illustrates the shortcut decorators @aetest.subsection.loop and @aetest.test.loop that combine section declaration and looping in a single decorator call. This syntactic sugar avoids the need for applying two separate decorators for marking a section as looped. Requires PyATS AEtest. The examples show looping a CommonSetup subsection and a Testcase test section using these shortcuts, enhancing code readability and aesthetics without changing functionality.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/loop.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats import aetest\n\nclass CommonSetup(aetest.CommonSetup):\n\n    # marking this as both a subsection, and being looped\n    @aetest.subsection.loop(uids=['subsection_one', 'subsection_two'])\n    def looped_subsection(self):\n        pass\n\nclass Testcase(aetest.Testcase):\n\n    # marking this as both a test section and being looped\n    @aetest.test.loop(uids =['test_one', 'test_two'])\n    def test(self):\n        pass\n\n```\n\n----------------------------------------\n\nTITLE: Using pyATS AEtest exit codes to reflect test outcomes in Python\nDESCRIPTION: Demonstrates how to propagate AEtest script test results into the bash shell exit code by capturing the return value of aetest.main() and passing it to aetest.exit_cli_code(). This allows the script to exit with 0 if all tests pass or 1 if tests fail or are skipped, enabling integration with CI/CD pipelines or other automation tools that depend on exit codes. Requires pyATS framework with aetest module accessible.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/run.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nresult = aetest.main()\naetest.exit_cli_code(result)\n```\n\n----------------------------------------\n\nTITLE: Determining Applicability of Service Wrapper in Python\nDESCRIPTION: The applicable class method determines if the service wrapper should be applied based on runtime conditions of the connection object. This example checks that the connected device OS is 'iosxe' before allowing the wrapper to activate. It receives a connection instance and optionally other arguments and returns a boolean. This method enables filtering for specific devices or scenarios.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/connections/wrapper.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Override applicable to check if the device is an IOSXE device\n@classmethod\n    def applicable(cls, connection: BaseConnection, *args, **kwargs) -> bool:\n        \"\"\"Ensure the device OS is iosxe and the service wrapper argument is passed\"\"\"\n        return connection.device.os == 'iosxe'\n```\n\n----------------------------------------\n\nTITLE: Applying Different Discovery Classes to Individual Testcases\nDESCRIPTION: Demonstrates how to apply different discovery classes to individual testcases using the discoverer attribute. This allows fine-grained control over how different testcases discover and order their test sections.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/control.rst#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats import aetest\nfrom pyats.aetest import runtime\n\nruntime.discoverer.testcase = MyDefaultDiscovery\n\nclass my_testcase1(aetest.Testcase):\n    discoverer = MyTestcaseDiscovery1\n\nclass my_testcase2(aetest.Testcase):\n    discoverer = MyTestcaseDiscovery2\n\nclass my_testcase3(aetest.Testcase):\n    pass\n```\n\n----------------------------------------\n\nTITLE: Connecting to a Device using ConnectionManager\nDESCRIPTION: This snippet demonstrates how to connect to a device using the ConnectionManager in PyATS.  It loads a testbed from a YAML file, selects a device, and then connects to it.  It then shows examples of using the connection alias and how to execute commands through the connection.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/topology/usage.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   connecting to device\n\n# using the sample topology file from\nimport os\nfrom pyats import topology\n\ntestbedfile = os.path.join(os.path.dirname(topology.__file__),\n                           'sampleTestbed.yaml')\ntestbed = topology.loader.load(testbedfile)\n\n# pick a device\nn7k5 = testbed.devices['ott-tb1-n7k5']\n\n# connect to it by calling connect()\n#   this is actually a ConnectionManager method. the compound object\n#   redirects the call to Device.connectionmgr.connect(), and:\n#       - defaults to using connection alias \"default\"\n#       - and creates the connection\n#\n#   in effect, this is the same as calling\n#       n7k5.connectionmgr.connect()\nn7k5.connect == n7k5.connectionmgr.connect\n# True\nn7k5.connect()\nn7k5.is_connected()\n# True\n\n# since the connection above is aliased with default\n# we can make calls to it directly.\nn7k5.default\n# ott-tb1-n7k5(default)\nn7k5.default.execute('show clock')\n# 00:56:54.569 EST Sat Mar 07 2015\n\n# default connections are also shortcut to the device level, so users\n# don't always have to type the default alias\nn7k5.execute == n7k5.default.execute == n7k5.connectionmgr.default.execute\n# True\nn7k5.execute('show clock')\n# 00:58:27.069 EST Sat Mar 07 2015\n\n# the connection manager is capable of handling multiple connections\n# each connection is referred to via its alias, and the connection object\n# is again compounded to be callable directly under the device object.\n# if supported, you can always create extra connections to\n# the same connection type, as long as this is supported by the device\n\n# creating a new connection to the alt (mgmt) connection definition\n# and calling it 'mgmt'. After connecting, you can make calls to it.\nn7k5.connect(alias = 'mgmt', via = 'alt')\nn7k5.mgmt.execute('show version')\n# ... etc\n```\n\n----------------------------------------\n\nTITLE: Exception Handling Method for Service Wrapper in Python\nDESCRIPTION: Implements the exception_service method to log an exception and return a string describing it. This method is called by call_service if an exception occurs during service invocation and is optional to implement in child classes. It receives the exception object and the original service call parameters, returning a value to be used in the post_service method. It requires a logger configured for exception logging.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/connections/wrapper.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef exception_service(self, e: Exception, *args, **kwargs) -> Any:\n    logger.exception(f\"Exception occurred: {e}\")\n    return f'Exception occurred: {e}'\n```\n\n----------------------------------------\n\nTITLE: Controlling pyATS Step Continuation After Failure in Python\nDESCRIPTION: Illustrates how the default pyATS behavior is to stop the current test section immediately after a step fails or errors. It then shows how to override this by providing `continue_ = True` to `steps.start()`, allowing subsequent steps within the same section to execute despite the failure.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/steps.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   step continuation feature\n\nfrom pyats import aetest\n\nclass Testcase(aetest.Testcase):\n\n    # test section that immediately returns after the first step failure\n    @aetest.test\n    def test_stopped_due_to_step_failure(self, steps):\n\n        with steps.start('the failed first step'):\n            # intentionally cause a failure\n            assert 1 == 0\n\n        with steps.start('the step after failed step'):\n            # do nothing - this would normally be Passed\n            pass\n\n    # same test content/steps, but using continue_ = True\n    @aetest.test\n    def test_continues_after_step_failure(self, steps):\n\n        with steps.start('the failed first step', continue_ = True):\n            # intentionally cause a failure\n            assert 1 == 0\n\n        with steps.start('the step after failed step'):\n            # do nothing - this would normally be Passed\n            pass\n```\n\n----------------------------------------\n\nTITLE: Parsing Custom Arguments in pyATS Jobfiles\nDESCRIPTION: This snippet demonstrates how to parse custom arguments passed to a pyATS jobfile using the argparse module. It shows how to define a parser, add arguments, and retrieve the parsed values.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/easypy/jobfile.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n    # Example\n    # -------\n    #\n    #   parsing custom arguments in Easypy\n\n    # assuming that this job file is run with the following command:\n    #   pyats run job example_job.py --my_custom_arg 'value'\n    #\n    # where \"--my_custom_arg_a\" is a custom argument to be parsed by the jobfile\n\n    import sys\n    import os\n    from pyats.easypy import run\n\n    # using argparse module to do the parsing\n    import argparse\n\n    # create your own parser to parse script arguments\n    # outside of the main block. This only creates a parser object\n    parser = argparse.ArgumentParser(description = \"my custom parser\")\n    parser.add_argument('--my_custom_arg', help = 'my custom argument')\n    # add any additional arguments as required...\n\n    # main block\n    def main(runtime):\n\n        # do the parsing first thing in the main() block\n        # always use parse_known_args as per requirement in argument propagation\n        # also stores back extra arguments back to sys.argv\n        args, sys.argv[1:] = parser.parse_known_args(sys.argv[1:])\n\n        # you can now provide those new values to your pyATS script.\n        run(testscript = os.path.join(prefix, 'path', 'to', 'script_two.py'),\n            runtime = runtime,\n```\n\n----------------------------------------\n\nTITLE: Defining Testcase Sections in pyATS AEtest (Python)\nDESCRIPTION: This Python code illustrates how to define `Testcase` sections within a pyATS AEtest script. It shows two examples: a simple testcase inheriting from `aetest.Testcase` with a test method decorated by `@aetest.test`, and a more complex one including `@aetest.setup` and `@aetest.cleanup` methods for test-specific setup/teardown, demonstrating state management within a testcase and setting a custom `uid` for reporting. Requires importing `aetest` from the `pyats` library.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/structure.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   two example testcase\n\n# import the aetest module\nfrom pyats import aetest\n\n# define a simple testcase by inheriting aetest.Testcase\n# this testcase's uid is defaulted to \"SimpleTestcase\"\nclass SimpleTestcase(aetest.Testcase):\n\n    @aetest.test\n    def trivial_test(self):\n        assert 1 + 1 == 2\n\n# testcases could also have its own setup/cleanups\nclass SlightlyMoreComplexTestcase(aetest.Testcase):\n\n    # providing this testcase a user-defined uid\n    uid = 'id_of_this_testcase'\n\n    @aetest.setup\n    def setup(self):\n        self.value = 1\n\n    @aetest.test\n    def another_trivial_test(self):\n        self.value += -1\n        assert self.value == 0\n\n    @aetest.cleanup\n    def cleanup(self):\n        del self.value\n```\n\n----------------------------------------\n\nTITLE: Executing a pyATS Job (Bash)\nDESCRIPTION: This Bash command demonstrates how to execute a pyATS job file using the `pyats run job` command. It specifies the job file (`ios_job.py`) to run, provides the path to the testbed configuration file using the `--testbed-file` argument (`ios_testbed.yaml`), and enables HTML log generation with the `--html-logs` flag. The testbed file is automatically loaded and parsed by a built-in plugin.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/getting_started/index.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pyats run job ios_job.py --testbed-file ios_testbed.yaml --html-logs\n```\n\n----------------------------------------\n\nTITLE: Accessing pyATS Result Object Attributes in Python\nDESCRIPTION: Shows how to retrieve core attributes (code, value, reason) from pyATS result objects (e.g., Passed, Errored), typecast results to int or string, and create a reasoned clone. Highlights object attributes (code: int, value: string, reason: string, data: any) and their typical usage in test reporting. Requires prior import of target results from pyats.results. Outputs demonstrate result code retrieval, string conversion, and custom reason attachment.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/results/objects.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#    using pyATS results objects\n\n# import all of them\nfrom pyats.results import Passed, Errored\n\n# getting the result equivalent code\nPassed.code\n# 1\n\n# or get the code by typecasting\nint(Passed)\n# 1\n\n# getting the resuilt name string\nPassed.value\n# passed\n\n# or typecast into str\nstr(Passed)\n# passed\n\n# can have a reason for this particular result\nnew_passed = Passed.clone(reason = 'the test was successful')\nnew_passed.reason\n# the test was successful\n```\n\n----------------------------------------\n\nTITLE: Accessing Devices and Interfaces by Name or Alias (pyATS Python)\nDESCRIPTION: Demonstrates loading a testbed from a file and accessing `Device` objects within `testbed.devices` and `Interface` objects within `device.interfaces` using either their configured `name` or `alias`. It also shows checking for existence using `in`, accessing via attribute syntax for valid Python names/aliases, and verifying if a key is an alias using `is_alias()`.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/topology/usage.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   topology alias access\n\n# continuing to use the same sample topology file from\n# the previous example\nimport os\nfrom pyats import topology\n\ntestbedfile = os.path.join(os.path.dirname(topology.__file__),\n                               'sampleTestbed.yaml')\ntestbed = topology.loader.load(testbedfile)\n\n# testbed has alias\ntestbed.alias\n# topologySampleTestbed\n\n# testbed devices have aliases\ntestbed.devices['ott-tb1-n7k4'].alias\n# device-1\ntestbed.devices['ott-tb1-n7k5'].alias\n# device-2\n\n# you can refer to devices within a testbed using its alias name instead\n# of the actual device name. this yields the same device object\ntestbed.devices['device-1'] is testbed.devices['ott-tb1-n7k4']\ntestbed.devices['device-2'] is testbed.devices['ott-tb1-n7k5']\ndevice_1 = testbed.devices['device-1']\ndevice_2 = testbed.devices['device-2']\n\n# if the device name or alias is a valid python name,\n# the object can be accessed via attribute syntax\ndevice1 = testbed.devices.device1\ndevice1 = testbed.devices.alias1\n\n# device in testbed check also works using alias\n'device-1' in testbed.devices\n# True\n\n# testbed device interfaces also have aliases\ndevice_1.interfaces['Ethernet4/1'].alias\n# device1-intf1\ndevice_1.interfaces['Ethernet4/2'].alias\n# device1-intf2\n\n# same as devices in testbed, interface access in device can be\n# done using their aliases, including in operator\ndevice_1.interfaces['device1-intf1'] is device_1.interfaces['Ethernet4/1']\nTrue\ndevice_1.interfaces['device1-intf2'] is device_1.interfaces['Ethernet4/2']\nTrue\n'device1-intf1' in device_1.interfaces\nTrue\n\n# if the interface name or alias is a valid python name,\n# the object can be accessed via attribute syntax\ndevice_1.interfaces.Eth0\ndevice_1.interfaces.alias_eth0\n\n# in addition, to test if something is an alias or not, use is_alias()\ndevice_1.interfaces.is_alias('device1-intf1')\n# True\ntestbed.devices.is_alias('ott-tb1-n7k4')\n# False\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Device Attributes in YAML\nDESCRIPTION: The custom section provides a flexible mechanism to add arbitrary key-value pairs specific to devices, enabling user-defined metadata, custom parameters, or additional information that can extend device descriptions without altering core schema constraints.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/topology/schema.rst#_snippet_3\n\nLANGUAGE: YAML\nCODE:\n```\ncustom:\\n    # any custom key/value pairs specific to this device\\n    # (optional)\\n    <key>: <value>\n```\n\n----------------------------------------\n\nTITLE: Example of associating testcases to groups in pyATS aetest\nDESCRIPTION: Demonstrates how to assign group labels to testcases using the 'groups' attribute and subsequently filter execution based on these groups via standard arguments or runtime variables, facilitating organized and selective test runs.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/control.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats import aetest\n\nclass Testcase(aetest.Testcase):\n    # associating this testcase to 3 separate groups\n    groups = ['group_A', 'group_B', 'group_C']\n```\n\n----------------------------------------\n\nTITLE: Looping with keyword arguments in PyATS\nDESCRIPTION: This code snippet demonstrates looping a test case using the `@aetest.test.loop` decorator with keyword arguments. This method provides each parameter and its corresponding argument values independently. This allows for clear assignment of parameter values within the loop.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/loop.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats import aetest\n\nclass Testcase(aetest.Testcase):\n\n    # loop this test with the same arguments as above, but\n    # provide each of its iteration arguments independently using method two\n    @aetest.test.loop(a=(1,4),\n                      b=(2,5),\n                      c=(3,6))\n    def test_two(self, a, b, c):\n        print(\"a=%s, b=%s, c=%s\" % (a, b, c))\n```\n\n----------------------------------------\n\nTITLE: Creating Global Managed Log Handlers in Python\nDESCRIPTION: Defines global instances of managed log handlers used throughout the pyATS logging module, specifically a TaskLogHandler and a ScreenHandler. These handler instances are designed to be reused rather than creating new ones repeatedly, facilitating consistent logging behavior across the entire execution environment. This approach supports attaching these handlers to the root logger, ensuring that all log messages propagate through these managed handlers.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/log/integration.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nmanaged_handlers = {\n                    'tasklog': TaskLogHandler(None),\n                    'screen' : ScreenHandler(),\n                    }\n```\n\n----------------------------------------\n\nTITLE: Defining AEtest Container Classes in Python\nDESCRIPTION: Illustrates how to define `CommonSetup` and `Testcase` sections in an `aetest` script by inheriting from the respective base classes (`aetest.CommonSetup`, `aetest.Testcase`). It demonstrates including subsections using the `@aetest.subsection` decorator and tests using the `@aetest.test` decorator within these container classes. Docstrings are used for descriptions.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/objects.rst#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\n# Example\n# -------\n#\n#   defining container classes\n\nfrom pyats import aetest\n\n# inheriting CommonSetup\n# contains subsections\nclass MyCommonSetup(aetest.CommonSetup):\n    '''\n    this is the description for CommonSetup\n    '''\n\n    @aetest.subsection\n    def subsection_one(self):\n        self.a = 1\n        print('hello world')\n\n    @aetest.subsection\n    def subsection_two(self):\n        assert self.a == 1\n\n# inheriting Testcase\n# contains setup/test/cleanup\nclass MyTestcase(aetest.Testcase):\n    '''\n    this is the description for Testcase\n    '''\n\n    @aetest.test\n    def test_one(self):\n        print('inside testcase: %s' % self.uid)\n```\n\n----------------------------------------\n\nTITLE: Enabling AEClient Auto-Reconnect After Forking in Python\nDESCRIPTION: Shows how to use the `enable_forked()` method on an `AEClient` instance in Python. This makes the client process-aware, ensuring it automatically reconnects to the AEReport server if the process is forked using the `multiprocessing` library, preventing XML-RPC call failures in the child process due to PID changes.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aereport/index.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   enabling auto-fork reconnect\n\nfrom pyats.aereport.client import AEClient\n\nclient = AEClient(port = svrport, servername = servername)\nclient.connect()\n\n# enable auto-forking. \n# from here on-wards, forked child processes auto-reconnect to server\nclient.enable_forked()\n```\n\n----------------------------------------\n\nTITLE: Creating a Simple Sequential pyATS Job File using `run()` API in Python\nDESCRIPTION: This snippet illustrates a basic pyATS job file structure in Python. It defines the mandatory `main(runtime)` function, sets an optional custom job name using `runtime.job.name`, and uses the `easypy.run()` API to execute two testscripts (`script_one.py`, `script_two.py`) sequentially. It also demonstrates accessing the runtime directory via the `runtime` object to save a file. Requires the `os` module and `pyats.easypy.run` function.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/easypy/jobfile.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   a simple, sequential job file\n\nimport os\n\nfrom pyats.easypy import run\n\n# main() function must be defined in each job file\n#   - it should have a runtime argument\n#   - and contains one or more tasks\ndef main(runtime):\n    \n    # provide custom job name for reporting purposes (optional)\n    runtime.job.name = 'my-job-overwrite-name'\n\n    # using run() api to run a task\n    #\n    # syntax\n    # ------\n    #   run(testscript = <testscript path/file>,\n    #       runtime = <runtime object>,\n    #       max_runtime = None,\n    #       taskid = None,\n    #       **kwargs)\n    #\n    #   any additional arguments (**kwargs) to run() api are propagated\n    #*  to AEtest as input arguments.\n    run(testscript = 'script_one.py', runtime = runtime)\n\n    # each job may contain one or more tasks.\n    # tasks defined using run() api always run sequentially.\n    run(testscript = 'script_two.py', runtime = runtime)\n\n    # access runtime information, such as runtime directory\n    # eg, save a new file into runtime directory\n    with open(os.path.join(runtime.directory, 'my_file.txt')) as f:\n        f.write('some content')\n```\n\n----------------------------------------\n\nTITLE: Looping with Generator Arguments in PyATS\nDESCRIPTION: This code snippet illustrates using a generator as a loop parameter. The generator `my_generator` is defined and its result is passed to the loop. The generator is only queried before the next section needs to be created. The output shows that the generator is called multiple times as the loop iterates through each yielded value.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/loop.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats import aetest\n\n# defining a generator\ndef my_generator():\n    for i in [4, 5, 6]:\n        print('generating %s' % i)\n        yield i\n\nclass Testcase(aetest.Testcase):\n\n    # creating a test section with parameter \"b\" as a generator\n    # note that the generator is a result of calling my_generator(), not\n    # the function itself.\n    @aetest.test.loop(b=my_generator())\n    def test_two(self, b):\n        print('b = %s' % b)\n```\n\n----------------------------------------\n\nTITLE: Accessing and Printing Parameters - Python\nDESCRIPTION: This snippet demonstrates how to access and print the current parameters within a test script using `self.parameters`. It shows how parameters are set and inherited from the parent script and also shows how local parameters can shadow the parent parameters if they have the same name. It prints the parameters dictionary which includes any parameters from the parent and/or those set in the current scope.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/parameters.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nprint(self.parameters)\n```\n\n----------------------------------------\n\nTITLE: Maintaining State Using self in AEtest Testcase Classes - Python\nDESCRIPTION: Explains how the self instance variable maintains state across successive section methods within a pyATS AEtest.Testcase container. Requires pyats.aetest to be imported and the class to be used as part of an AEtest script. The code demonstrates setting and incrementing an instance attribute (self.value) in both the setup and test sections, ensuring consistent behavior throughout execution. Output is expected to show test assertions passing when value is updated as designed.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/behavior.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   self, consistency explained\n\nfrom pyats import aetest\n\n# define a testcase where its tests\n# expects self.value to be set by the setup section,\n# and continues to be carried throughout\nclass Testcase(aetest.Testcase):\n    @aetest.setup\n    def setup(self):\n        self.value = 1\n\n    @aetest.test\n    def test_one(self):\n        self.value += 1\n        assert self.value == 2\n\n    @aetest.test\n    def test_one(self):\n        self.value += 1\n        assert self.value == 3\n\n# run the Testcase\ntc = Testcase()\nprint(tc())\n# passed\n```\n\n----------------------------------------\n\nTITLE: Defining Test Result Classes with pyATS.results\nDESCRIPTION: This snippet illustrates how pyATS uses classes like Passed and Failed to represent individual test outcomes. These classes enable complex result relationships and support aggregation operations such as addition to combine multiple results, facilitating detailed test status management.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/results/introduction.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom pyats.results import Passed, Failed\n\n# rolling up passed + failed yields failed\nPassed + Failed\n```\n\n----------------------------------------\n\nTITLE: Defining Setup Section in pyATS Testcase (Python)\nDESCRIPTION: This snippet demonstrates how to define an optional setup section specific to a single `aetest.Testcase`. A method within the `Testcase` class is decorated with `@aetest.setup` to perform prerequisites, configurations, or initializations required for that specific testcase before its test sections run.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/structure.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   setup sections\n\nfrom pyats import aetest\n\n# setup section within Testcases\nclass Testcase(aetest.Testcase):\n\n    # define setup section by applying @setup decorator\n    @aetest.setup\n    def testcase_setup(self):\n        pass\n```\n\n----------------------------------------\n\nTITLE: Using Various Argument Combinations with pcall (Single Target) in Python\nDESCRIPTION: Illustrates how to use different argument types (cargs, iargs, ckwargs, ikwargs, varkwargs) with pyats.async_.pcall when calling a single target function ('func') in parallel. Explains how arguments are combined for each process and the effect of mismatched iterable lengths for instance arguments (iargs/ikwargs), following Python's zip behavior. The target function simply returns the arguments it received.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/async/pcall.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   pcall argument combinations (single target)\n#   (using a lot of tuples instead of lists)\n\n# import pcall\nfrom pyats.async_ import pcall\n\n# define a function to be called by pcall\n# (this function returns all of its arguments back to the caller)\ndef func(*args, **kwargs):\n    return (args, kwargs)\n\n# positional argument building\n# ----------------------------\n#   child 1: args=(1, 2, 3, 4), kwargs= {}\n#   child 2: args=(1, 2, 3, 5), kwargs= {}\n#   child 3: args=(1, 2, 3, 6), kwargs= {}\npcall(func, cargs = (1, 2, 3),\n            iargs = ((4,), (5,), (6,))\n\n# keyword argument building\n# -------------------------\n#   child 1: args=(), kwargs= {'a': 1, 'b': 2, 'c': 3}\n#   child 2: args=(), kwargs= {'a': 1, 'b': 2, 'c': 4}\n#   child 3: args=(), kwargs= {'a': 1, 'b': 2, 'c': 5}\npcall(func, ckwargs = {'a': 1, 'b': 2},\n            ikwargs = [{'c': 3},\n                       {'c': 4},\n                       {'c': 5}])\n\n# variable keyword argument building\n# ----------------------------------\n#   child 1: args=(), kwargs= {'x': 1, 'y': 4, 'z': 7}\n#   child 2: args=(), kwargs= {'x': 2, 'y': 5, 'z': 8}\n#   child 2: args=(), kwargs= {'x': 3, 'y': 6, 'z': 9}\npcall(func, x = (1, 2, 3),\n            y = (4, 5, 6),\n            z = (7, 8, 9))\n\n# combo is always fun\n# -------------------\n#   child 1: args=(1, 2, 3, 6, 7),\n#            kwargs= {'a': 1, 'b': 2, 'c': 3, 'x': 10, 'y': 100}\n#   child 2: args=(1, 2, 3, 8, 9),\n#            kwargs= {'a': 1, 'b': 2, 'c': 4, 'x': 20, 'y': 200}\npcall(func, cargs = (1, 2, 3),\n            iargs = ((6, 7), (8, 9)),\n            ckwargs = {'a': 1, 'b': 2},\n            ikwargs = ({'c': 3}, {'c': 4}),\n            x = (10, 20), y = (100, 200))\n\n# iargs and ikwargs's number of iterations must match\n# ---------------------------------------------------\n#   child 1: args=(1, 2), kwargs= {'a': 1}\n#   child 2: args=(3, 4), kwargs= {'a': 2}\n# there is no child #3, as there is no ikwargs to match (5, 6) of iargs\npcall(func, iargs = ((1, 2), (3, 4), (5, 6)),\n            ikwargs = ({'a': 1}, {'a': 2}))\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic pyATS Job (Python)\nDESCRIPTION: This Python code defines a simple pyATS job file (e.g., `ios_job.py`). It imports the `run` function from `pyats.easypy` and defines a `main` function, which is the entry point for the job. Inside `main`, the `run` function is called to execute a specified testscript (`connectivity_check.py`) as a task within the job.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/getting_started/index.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Example: ios_job.py\n# -------------------\n#\n#   a simple job file for the script above\n\nfrom pyats.easypy import run\n\ndef main():\n\n    # run api launches a testscript as an individual task.\n    run('connectivity_check.py')\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Parameter Relationship in aetest (Pseudo-code)\nDESCRIPTION: This pseudo-code example demonstrates the behavior relationship of object parameters and their parents in aetest. It shows how a Testcase object inherits parameters from its parent TestScript object and how local parameters can override parent parameters. This example shows how parameters are copied and updated to reflect this inheritance.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/parameters.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   pseudo-code, intending to demonstrate the behavior relationship\n#   of object parameters & their parents.\n\n# in this example, assume there are the following objects:\n#\n#   testscript: the TestScript object\n#   testcase:   the Testcase object. (parent=testscript)\n\n# testscript has parameters\ntestscript.parameters = {\n    'param_A': 1,\n    'param_B': 2,\n}\n\n# testcase has the following local parameters\n# note that \"param_A\" is already defined at its parent level\n# but \"param_C\" is new\ntestcase.parameters = {\n    'param_A': 100,\n    'param_C': 3,\n}\n\n# during runtime, the combined parameters seen at the\n# testcase level, would be equivalent to the following:\n#   - take the testscript parameters as basis\n#   - and add to it, testcase parameters\n#\n# eg:\nnew_testcase_parameters = testscript.parameters.copy()\nnew_testcase_parameters.update(testcase.parameters)\ntestcase.parameters = new_testcase_parameters\n\n# so that the new parameters seen at the testcase\n# level, is:\ntestcase.parameters\n# {'param_A': 100, 'param_B': 2, 'param_C': 3}\n```\n\n----------------------------------------\n\nTITLE: Instantiating TestScript from a Module in Python\nDESCRIPTION: Demonstrates how `aetest` internally wraps a test script Python module (e.g., `l3vpn_traffic.py`) into a `TestScript` instance. It requires importing the test script as a module and the `TestScript` class from `pyats.aetest.script`. The code asserts that the imported script is a module type before creating the `TestScript` object.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/objects.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n# Example\n# -------\n#\n#   what this means...\n#   assuming there's a script called l3vpn_traffic.py\n\n# importing some helper modules for demonstration\nimport types\n\n# import the script as a module\nimport l3vpn_traffic\n\n# l3vpn_traffic is a module\nassert isinstance(l3vpn_traffic, types.ModuleType)\n# True\n\n# TestScript is created with the module as input:\nfrom pyats.aetest.script import TestScript\ntestscript = TestScript(module = l3vpn_traffic)\n```\n\n----------------------------------------\n\nTITLE: Specifying Submitter User ID for AEtest Scripts - Python and Bash\nDESCRIPTION: Overrides the default submitter user ID (which defaults to the current shell user) by specifying a string user ID. This metadata can be useful for tracking or auditing purposes. Input is a string username; output tags the test script metadata. Supported via command-line option or API call.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/run.rst#_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\nbash$ python testscript.py -submitter=\"tonystark\"\n```\n\nLANGUAGE: python\nCODE:\n```\naetest.main('testscript.py', submitter=\"blackwidow\")\n```\n\nLANGUAGE: python\nCODE:\n```\nrun(testscript = 'testscript.py', submitter=\"warmachine68\")\n```\n\n----------------------------------------\n\nTITLE: Checking File Existence with FileUtils in Python\nDESCRIPTION: Example demonstrating the checkfile API to verify file existence on a remote server, with an option to check file stability to ensure it's not being modified.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/file_transfer_utilities.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.utils.fileutils import FileUtils\nwith FileUtils(testbed=tb) as futils:\n    futils.checkfile(\"sftp://server.domain.com/path/to/file\")\n```\n\n----------------------------------------\n\nTITLE: Usage and Subcommands of pyats run Command\nDESCRIPTION: Documents the main syntax and subcommands ('job' and 'robot') for 'pyats run', including general options for help, verbosity, and quiet mode, providing users with an overview of available CLI operations.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/cli/pyats_run.rst#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nUsage:\n  pyats run <subcommand> [options]\n\nSubcommands:\n   job                 runs the provided pyATS job file\n   robot               runs the provided RobotFramework script\n\nGeneral Options:\n  -h, --help            Show help\n  -v, --verbose         Give more output, additive up to 3 times.\n  -q, --quiet           Give less output, additive up to 3 times, corresponding to WARNING, ERROR,\n                        and CRITICAL logging levels\n```\n\n----------------------------------------\n\nTITLE: Install RobotFramework Support for pyATS\nDESCRIPTION: Installs the `pyats.robot` package, enabling RobotFramework support within pyATS. This is a required step before leveraging RobotFramework within pyATS. The command is different for DevNet Community and Cisco Internal Developers.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/robot/index.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Installing RobotFramework support for pyATS\n# -------------------------------------------\n\n# DevNet Community\nbash$ pip install --upgrade pyats.robot\n\n# Cisco Internal Developers\nbash$ pip install --upgrade ats.robot\n```\n\n----------------------------------------\n\nTITLE: Looping with args and argvs in PyATS\nDESCRIPTION: This code snippet demonstrates looping a test case using the `@aetest.test.loop` decorator in PyATS with the `args` and `argvs` parameters.  `args` defines the parameter names, and `argvs` provides the corresponding values for each iteration.  The positions of values in argvs correspond to args names. The output shows the values of a, b, and c for each iteration.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/loop.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats import aetest\n\nclass Testcase(aetest.Testcase):\n\n    # loop this test with arguments \"a\", \"b\", and \"c\"\n    # provide all of its iteration arguments together using method one\n    # the positions of each value in argvs corresponds to its args name\n    @aetest.test.loop(args=('a', 'b', 'c'), \n                      argvs=((1, 2, 3),\n                             (4, 5, 6)))\n    def test_one(self, a, b, c):\n        print(\"a=%s, b=%s, c=%s\" % (a, b, c))\n```\n\n----------------------------------------\n\nTITLE: Defining Retry on Sections Using Python Decorators\nDESCRIPTION: Shows how to apply the @aetest.retry decorator on test sections and testcases in Python to enable retrying of test steps. The decorator accepts parameters retries (number of retries) and retry_wait (wait time between retries). This facilitates re-execution of specific test sections upon failure.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/retry.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom pyats import aetest\n\n# defining a testcase that retries\n# this testcase also contains a test section that is retried twice\n@aetest.retry(retries=3, retry_wait=2)\nclass MyTestcase_1(aetest.Testcase):\n\n    # test section\n    @aetest.retry(retries=2, retry_wait=2)\n    @aetest.test\n    def testcase1(self):\n        pass\n```\n\n----------------------------------------\n\nTITLE: Breaking Down a Test Section into Steps in pyATS AEtest\nDESCRIPTION: Demonstrates how to break a test section into smaller steps using the 'steps' reserved parameter. The example shows creating steps with descriptive names and descriptions, and how they appear in the test output.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/steps.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   breaking a test section into smaller steps\n\nfrom pyats import aetest\n\n# using a testcase as example\n# applies to all sections (subsection/setup/cleanup/test)\nclass NeilArmstrong(aetest.Testcase):\n\n    # define section method with 'steps' reserved parameter argument\n    # this enables the engine to pass steps object to the local scope\n    @aetest.test\n    def says(self, steps):\n\n        # breaking down this test into two steps\n        # using python \"with\" statement and steps parameter\n        with steps.start('first step',\n                         description = 'this is the first step'):\n            print('one small step for [a] man')\n\n        with steps.start('second step',\n                         description = 'this is the second step'):\n            print('one giant leap for mankind')\n```\n\n----------------------------------------\n\nTITLE: Destroying Multiple Device Connections in Parallel\nDESCRIPTION: This snippet shows how to destroy connections to multiple testbed devices using the `Testbed.destroy()` function, which removes the connection objects. It utilizes threads for asynchronous operation. It mirrors the `.connect()` and `.disconnect()` examples using various methods.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/topology/usage.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n# destroy devices in parallel\n# using the sample topology file from\nfrom pyats import topology\ntestbed = topology.loader.load('your-testbed-file.yaml')\n\n# connect to all devices in this testbed\ntestbed.connect()\n# destroy all devices in this testbed\ntestbed.destroy()\n# destroy some devices in this testbed\ntestbed.destroy(testbed.devices['uut'],\n                testbed.devices['helper'])\n# destroy some devices in this testbed\n# and provide unique vias\ntestbed.destroy(testbed.devices['uut'],\n                testbed.devices['helper'],\n                vias = {'uut': 'cli',\n                        'helper': 'console'})\n# destroy some devices in this testbed\n# using unique vias per device, and shared kwargs\n# shared keyword-arguments will be passed to every single connection\ntestbed.destroy(testbed.devices['uut'],\n                testbed.devices['helper'],\n                vias = {'uut': 'cli',\n                        'helper': 'console'},\n                        log_stdout = False)\n```\n\n----------------------------------------\n\nTITLE: Connecting to Multiple Devices in Parallel\nDESCRIPTION: This snippet demonstrates connecting to multiple devices in parallel using the `Testbed.connect()` function. It leverages the `pyats.topology` module to load a testbed file and then connects to devices specified within the testbed.  Various methods are shown including connecting to all, some, and providing unique vias for connections.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/topology/usage.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n# connecting to devices in parallel\n\n# using the sample topology file from\nfrom pyats import topology\n\ntestbedfile = os.path.join('sampleTestbed.yaml')\ntestbed = topology.loader.load(testbedfile)\n\n# connect to all devices in this testbed\ntestbed.connect()\n\n# connect to some devices in this testbed\ntestbed.connect(testbed.devices['uut'],\n                testbed.devices['helper'])\n\n# connect to some devices in this testbed\n# and provide unique vias\ntestbed.connect(testbed.devices['uut'],\n                testbed.devices['helper'],\n                vias = {'uut': 'cli',\n                        'helper': 'console'})\n\n# connect to some devices in this testbed\n# using unique vias per device, and shared kwargs (eg, log_stdout = False)\n# shared keyword-arguments will be passed to every single connection\ntestbed.connect(testbed.devices['uut'],\n                testbed.devices['helper'],\n                vias = {'uut': 'cli',\n                        'helper': 'console'},\n                log_stdout = False)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating PDB on Failure in AEtest\nDESCRIPTION: This code demonstrates the use of `pdb = True` flag in AEtest to automatically trigger a post-mortem debugging session when an error or exception occurs. The example defines a test case that deliberately raises a `NameError` (by calling `blablabla()`) to trigger the debugger. The output illustrates how the debugger is activated, allowing the user to inspect the stack frame and diagnose the failure. This method is useful for automatically entering the debugger on exceptions in test scripts.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/debugging.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats import aetest\n\nclass CommonSetup(aetest.CommonSetup):\n    @aetest.subsection\n    def subsection(self):\n        pass\n\nclass TestcaseOne(aetest.Testcase):\n\n    @aetest.setup\n    def setup(self):\n        pass\n\n    @aetest.test\n    def test(self):\n        # raise an exception by calling something that doesn't exist\n        blablabla()\n\n    @aetest.cleanup\n    def cleanup(self):\n        pass\n\nclass CommonCleanup(aetest.CommonCleanup):\n    @aetest.subsection\n    def subsection(self):\n        pass\n\naetest.main(pdb = True)\n```\n\n----------------------------------------\n\nTITLE: Defining Requisite Testcases in pyATS (Python)\nDESCRIPTION: Shows how to mark a specific testcase as 'requisite' or 'must pass' by setting the class attribute `must_pass = True`. If a testcase marked this way fails, pyATS aborts the current script execution, jumps to the `CommonCleanup` section, and marks subsequent testcases as 'BLOCKED'. Requires `pyats.aetest`.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/control.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   must_pass feature demonstration\n\nfrom pyats import aetest\n\n\nclass TestcaseOne(aetest.Testcase):\n\n    must_pass = True\n\n    @aetest.test\n    def test(self):\n        self.failed('boom!')\n\nclass TestcaseTwo(aetest.Testcase):\n    pass\n\nclass CommonCleanup(aetest.CommonCleanup)\n\n    @aetest.subsection\n    def subsection(self):\n        pass\n```\n\n----------------------------------------\n\nTITLE: Simple print statement for current section\nDESCRIPTION: This snippet demonstrates printing the current section's unique identifier, useful for debugging or logging in test scripts. It relies on the 'section.uid' property to output the section's identifier.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/loop.rst#_snippet_12\n\nLANGUAGE: Python\nCODE:\n```\nprint(\"current section: %s\" % section.uid)\n```\n\n----------------------------------------\n\nTITLE: Controlling TaskLog and Handlers in pyATS (Advanced)\nDESCRIPTION: This snippet showcases advanced logging features for manipulating the current TaskLog file and managed handlers within a pyATS environment. It imports `managed_handlers` from `pyats.log` to modify the log file and reconfigure handlers. Key functionality includes changing the TaskLog file path, and removing and adding handlers back to the root logger. It requires an EasyPy environment with root handlers configured.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/log/examples.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport logging\nfrom pyats.log import managed_handers\n\n# create a logger for this module\nlogger = logging.getLogger(__name__)\n\n# now your log calls should work\nlogger.info('info messages')\nlogger.critical('critical messages')\nlogger.debug('debug messages')\nlogger.warning('warning messages')\nlogger.error('error messages')\n\n# to change the current TaskLog file:\nmanaged_handlers['tasklog'].changeFile('/path/to/new/logfile.txt')\n\n# new log messages go to new file\nlogger.info('new info messages')\nlogger.critical('new critical messages')\nlogger.debug('new debug messages')\nlogger.warning('new warning messages')\nlogger.error('new error messages')\n\n# removing handlers from root\nlogging.root.removeHandler(managed_handlers['tasklog'])\nlogging.root.removeHandler(managed_handlers['screen'])\n\n# adding handlers back to root\nlogging.root.addHandler(managed_handlers['tasklog'])\nlogging.root.addHandler(managed_handlers['screen'])\n```\n\n----------------------------------------\n\nTITLE: Navigating Topology Hierarchy via Attributes (pyATS Python)\nDESCRIPTION: Explains how to traverse the topology structure by chaining attribute access from an interface object (`intf`) upwards through its `link`, the link's `interfaces`, and the remote interface's `device`, finally reaching the device's `testbed`. It also confirms object identity.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/topology/usage.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# the entire topology is chained by attributes\nintf.link.interfaces\n# WeakList([<Interface Ethernet4/2 at 0xf744eeac>,\n#           <Interface Ethernet5/2 at 0xf744d74c>])\nintf.link.interfaces[1].device\n# <Device ott-tb1-n7k5 at 0xf744e16c>\nintf.link.interfaces[1].device.testbed\n# <pyats.topology.testbed.Testbed object at 0xf76b5f0c>\nintf.link.interfaces[1].device is n7k5\n# True\n```\n\n----------------------------------------\n\nTITLE: Accessing Devices and Checking Types/Membership (pyATS Python)\nDESCRIPTION: Demonstrates retrieving specific device objects from a loaded testbed dictionary, verifying their type using `type()`, and checking if devices exist in the testbed using the `in` operator with both object references and names.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/topology/usage.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# grab both device\nn7k4 = testbed.devices['ott-tb1-n7k4']\nn7k5 = testbed.devices['ott-tb1-n7k5']\n\n# confirm that this is a Device object\ntype(n7k4) is Device and type(n7k5) is Device\n# True\n\n# note that you can check whether devices exists in a testbed\n# by using either the device object or its name\nn7k4 in testbed and n7k5 in testbed\n# True\n```\n\n----------------------------------------\n\nTITLE: Using `run()` API for Sequential Task Execution with Result Checking in Python\nDESCRIPTION: This Python code snippet exemplifies using the `pyats.easypy.run()` API within a job file's `main(runtime)` function. It executes `script_one.py` sequentially, assigns a custom `taskid`, sets a `max_runtime` limit (5 minutes), and captures the execution result. Based on whether the first task passed (`if result:`), it conditionally executes `script_two.py` with similar parameters. This demonstrates basic sequential control flow based on task outcomes. Requires the `pyats.easypy.run` function.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/easypy/jobfile.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   job file run() api example\n\nfrom pyats.easypy import run\n\n# main() function\ndef main(runtime):\n\n    # using run() api to run a task, save the result to variable\n    # (max runtime = 60*5 seconds = 5 minutes)\n    result = run(testscript = 'script_one.py',\n                 runtime = runtime,\n                 taskid = 'example_task_1',\n                 max_runtime = 60*5)\n\n    # check whether the next script should continue\n    # based on previous task's results.\n    if result:\n        # last result passed, run the next task\n        run(testscript = 'script_two.py',\n            runtime = runtime,\n            taskid = 'example_task_1',\n            max_runtime = 60*5)\n```\n\n----------------------------------------\n\nTITLE: Testcase with Expected Pass/Fail Sections\nDESCRIPTION: This `Testcase` class contains two tests, `expected_to_pass` and `expected_to_fail`, which demonstrate how parametrized functions and reserved parameters interact. The `expected_to_pass` section asserts that the `expectation` value is greater than the generated `number`.  The `expected_to_fail` section makes the same assertion, which is expected to fail.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/parameters.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n    # defining two tests under this testcase\n    # ----------------------------------------------\n    # similar to callable parameters, the above parameters\n    # are evaluated when used as function arguments to section\n    # the only difference is the support for parameter function arguments.\n    class Testcase(aetest.Testcase):\n\n        # this section is expected to pass\n        # the generated number is between 1 and 100, and the\n        # expectation is 9999 (as section uid is \"expected_to_pass\")\n        @aetest.test\n        def expected_to_pass(self, number, expectation):\n            # test whether expectation is > than generated number\n            assert expectation > number\n\n        # this section is expected to fail\n        # the generated number is still between 1 and 100, but the\n        # expectation is 0 (as section uid is not \"expected_to_pass\")\n        @aetest.test\n        def expected_to_fail(self, number, expectation):\n            # test whether expectation is > than generated number\n            assert expectation > number\n```\n\n----------------------------------------\n\nTITLE: Implementing BaseCleaner Without Steps (Python)\nDESCRIPTION: This pseudo-code example shows the basic structure of a custom pyats Kleenex cleaner class that does not use the step reporting feature. The class `ExampleCleaner` inherits from `BaseCleaner`, defines a constructor `__init__` to accept configuration arguments, and implements the main `clean` method. The `clean` method receives a device object and is responsible for performing cleaning operations using methods like `device.connect()`, accessing clean-specific info from `device.clean`, and executing tasks like loading images (`_imaginary_load_image_method`), reloading (`_imaginary_device_reload`), and applying configuration (`device.configure`).\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/kleenex/clean.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   a pesudo-code example implementation of a cleaner class\n\n# all clean implementations inherit from BaseCleaner\nclass ExampleCleaner(BaseCleaner):\n    '''BaseCleaner\n\n    demonstrating the details of how cleaners are to be implemented\n    '''\n\n    def __init__(self, arg_1, arg_2, arg_3):\n        '''__init__\n\n        clean class constructor. All clean initialization arguments should\n        be defined as arguments to this method (eg, arg_1, arg_2, arg_3)\n        '''\n\n        # always call the parent __init__()\n        super().__init__()\n\n        # everything else necessary... eg:\n        self.arg_1 = arg_1\n        self.arg_2 = arg_2\n        self.arg_3 = arg_3\n\n    def clean(self, device):\n        '''clean\n\n        main entry point of this clean implementation, this method is called\n        in a subprocess under kleenex runtime, specific to cleaning one\n        particular device.\n\n        A device object representing the device to clean is always provided.\n        '''\n\n        # connect to the device\n        device.connect()\n\n        # look up the details of how to clean this device, eg:\n        clean_info = device.clean\n\n        # do the actual clean, eg, pseudo-code\n        self._imaginary_load_image_method(device = device,\n                                          images = clean_info['images'])\n\n        # maybe reload the device?\n        self._imaginary_device_reload(device = device)\n\n        # apply post-clean config?\n        device.configure(clean_info['post-clean'])\n\n        # we're done!\n        device.disconnect()\n```\n\n----------------------------------------\n\nTITLE: Creating a Logger Object in Python for pyATS\nDESCRIPTION: Demonstrates the standard practice in pyATS for creating a logger instance using Python's `logging` module. It utilizes `logging.getLogger(__name__)` to obtain a logger named after the current module, ensuring proper hierarchical logging within the pyATS framework.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/log/concept.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n# \n#   creating a logger object\n\nimport logging\n\nlogger = logging.getLogger(__name__)\n```\n\n----------------------------------------\n\nTITLE: RobotFramework Example: Initialize Testbed and Connect to Device\nDESCRIPTION: This RobotFramework snippet initializes the test environment by selecting a testbed YAML file and connecting to a specified device using a CLI alias. It uses the `ats.robot.pyATSRobot` library and assumes the existence of `testbed.yaml`.  The `use testbed` keyword sets the active testbed and `connect to device` establishes a connection to the device, allowing for subsequent interactions.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/robot/native.rst#_snippet_0\n\nLANGUAGE: robotframework\nCODE:\n```\n    Initialize\n        # select the testbed to use\n        use testbed \"${testbed}\"\n\n        # connec to testbed device through cli\n        connect to device \"ios\" as alias \"cli\"\n```\n\n----------------------------------------\n\nTITLE: Attaching ScreenHandler Logging Handler in pyATS (Python)\nDESCRIPTION: This snippet demonstrates how to attach the ScreenHandler to a logger using the pyATS framework, allowing log messages to be printed to the console (STDOUT or STDERR). Dependencies include the standard logging module and pyATS's pyats.log library. The user creates a handler instance, optionally specifying the output stream, adds it to the logger, logs messages at various levels, and can optionally disable colored output (enabled by default). Expected input is log messages; output is human-readable logs printed to the configured standard stream.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/log/implementation.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nimport logging\nfrom pyats.log import ScreenHandler\n\n# get the root logger\nlogger = logging.getLogger(__name__)\n\n# create handler (defaults to STDOUT)\nhandler = ScreenHandler()\n# or, if you want to output to STDERR, use below instead\nhandler = ScreenHandler(sys.stderr)\n\n# add handler to logger\nlogger.addHandler(handler)\n\n# now try logging :)\nlogger.critical('a critical message')\n\n# disable coloured output\n# (default to enabled)\nhandler.coloured = False\n```\n\n----------------------------------------\n\nTITLE: Using pyats FileUtils for File Operations on Linux (Default Plugin)\nDESCRIPTION: This snippet demonstrates performing various file operations like copy, delete, chmod, and stat on a Linux client using the default FileUtils plugin. It shows how to specify server URLs, manage local paths, and handle different URL schemes such as FTP, SCP, and SFTP. It also includes examples for directory listings.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/file_transfer_utilities.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.utils.fileutils import FileUtils\nfrom pyats.topology import loader\ntb = loader.load('tb.yaml')\n\nwith FileUtils(testbed=tb) as futils:\n    futils.copyfile(\n        source = '/local/path/to/file',\n        destination = 'ftp://server_alias/remote/path/to/file')\n    futils.copyfile(\n        source = 'file:///local/path/to/file',\n        destination = 'tftp://myserver.domain.com/remote/path/to/file',\n        timeout_seconds=80)\n    futils.copyfile(\n        source = 'scp://1.1.1.1/path/to/file',\n        destination = '/local/path/to/file')\n    import os\n    os.chdir('/local/path/to')\n    futils.copyfile(\n        source = 'scp://1.1.1.1/path/to/file',\n        destination = './file')\n    os.chdir('/local/path/to')\n    futils.copyfile(\n        source = 'scp://1.1.1.1/path/to/file',\n        destination = '~/file')\n    os.chdir('/local/path/to')\n    futils.copyfile(\n        source = 'scp://1.1.1.1/path/to/file',\n        destination = '~nameduser/file')\n    futils.deletefile(target = 'sftp://myserver.domain.com/remote/path/to/file')\n    import stat\n    mode  = stat.S_IRWXU | stat.S_IRGRP | stat.S_IXGRP | stat.S_IXOTH\n    futils.chmod(target = 'ftp://myserver.domain.com/remote/path/to/file', mode=mode)\n    file_details = futils.stat(\n        target = 'sftp://myserver.domain.com/remote/path/to/file')\n    import stat\n    stat.filemode(file_details.st_mode)\n    '-rwxrwxrwx'\n    \n```\n\n----------------------------------------\n\nTITLE: Running AEtest scripts using Easypy job files in Python\nDESCRIPTION: Illustrates creating a basic pyATS Easypy job file that runs AEtest test scripts by using the run() method from pyats.easypy. The job file defines a main() function that invokes run() with the testscript path. This execution mode manages logging, reporting, and environment setup automatically. It supports passing additional keyword arguments to the testscript as parameters. The example demonstrates integration of AEtest scripts into Easypy workflows. Easypy must be installed and used to launch the job file for correct environment behavior.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/run.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.easypy import run\n\ndef main():\n    run(testscript='/path/to/your/script.py')\n```\n\n----------------------------------------\n\nTITLE: Upgrading Pyats - Bash\nDESCRIPTION: This snippet provides the command to upgrade the Pyats package using pip.  It's tailored for users within the DevNet community. The command downloads and installs the latest version of Pyats and its dependencies. It requires pip and an active internet connection.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2024/january.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats\n```\n\n----------------------------------------\n\nTITLE: Looping with custom filler in PyATS\nDESCRIPTION: This example shows how to use the `filler` parameter to replace `None` with a custom value when parameter sets have a different amount of values. This allows customization of what value is used when fewer argument values are provided than the number of iterations and when multiple parameters do not contain the same number of values.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/loop.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.aetest import loop\n\n# loop with more uids than parameters, and custom filler\n# ------------------------------------------------------\n#   iteration 1: uid='id_one', a=1, b=3\n#   iteration 2: uid='id_two', a=2, b=4\n#   iteration 1: uid='id_three', a=999, b=999  ---> custom filler\n@loop(uids = ['id_one', 'id_two', 'id_three'], \n      a = [1, 2], b = [3, 4], filler = 999)\n# same as above, using args and argvs\n@loop(uids=['id_one', 'id_two', 'id_three'], \n      args=['a', 'b'], argvs=[(1, 3), (2, 3)], filler=999)\n```\n\n----------------------------------------\n\nTITLE: Alternative pyATS aetest Processor Decorator Syntax (Text)\nDESCRIPTION: Shows alternative syntax for applying only one type of processor (pre, post, or exception) using specific sub-decorators like `@aetest.processors.pre`, `@aetest.processors.post`, and `@aetest.processors.exception`. This allows for more granular application compared to the main `@processors` decorator.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/processors.rst#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nAlternative Syntax\n------------------\n\n    @processor.pre(*list of pre-processors)\n    @processor.post(*list of post-processors)\n    @processor.exception(*list of exception-processors)\n```\n\n----------------------------------------\n\nTITLE: Running Kleenex Module as an Easypy Plugin via Bash\nDESCRIPTION: Shows how to invoke the Kleenex cleaning functionality integrated with Easypy job runs using the pyATS command-line. This mode lets Kleenex run as a plugin for testbed provisioning and cleanup before and after Easypy jobs, useful for regression and standardized environments. The `--invoke-clean` parameter explicitly triggers the Kleenex cleaning process.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/kleenex/usages.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pyats run job myjob.py --testbed-file physical_testbed.yaml\\\n                             --clean-file physical_testbed_clean.yaml\\\n                             --invoke-clean\n```\n\n----------------------------------------\n\nTITLE: Testbed and Device object creation\nDESCRIPTION: This Python snippet demonstrates how to create Testbed and Device objects in pyATS. It showcases creating testbeds with different configurations such as empty testbeds, testbeds with aliases, and testbeds with pre-defined devices. It also demonstrates how to add and remove devices from a testbed dynamically, as well as how to 'squeeze' the testbed.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/topology/concept.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.topology import Testbed, Device\n\n# create some device objects for demonstration's sake\ndevice_a = Device('A')\ndevice_b = Device('B')\ndevice_c = Device('C')\ndevice_d = Device('D')\n\n# creating an empty testbed\ntestbed_a = Testbed(name = 'emptyTestbed')\n\n# creating a testbed with an alias\ntestbed_b = Testbed(name = 'myTestbed',\n                    alias = 'yetAnotherTestbed')\n\n# creating a testbed with devices\ntestbed_c = Testbed(name = 'testbedWithDevicesFromStart',\n                    devices = [device_a, device_b])\n\n# adding devices into testbeds\ntestbed_d = Testbed(name = 'testbedToReceiveDevices')\ntestbed_d.add_device(device_c)\n\n# removing devices from a testbed\ntestbed_e = Testbed(name = 'testbedToRemoveDevices',\n                    devices = [device_d])\ntestbed_e.remove_device(device_d)\n\n# squeezing a testbed to keep only wanted devices\ntestbed_e = Testbed(name = 'testbedToSqueeze',\n                    devices = [device_a, device_b, device_c])\ntestbed_e.squeeze(device_b.name, device_c.name)\n```\n\n----------------------------------------\n\nTITLE: Copying Files with FileUtils in Python\nDESCRIPTION: Example showing how to copy a file between a remote server and the local system using the copyfile method. Supports local to remote or remote to local transfers.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/file_transfer_utilities.rst#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.utils.fileutils import FileUtils\nwith FileUtils(testbed=tb) as futils:\n    futils.copyfile(\n        source = 'scp://1.1.1.1/path/to/file',\n        destination = '/local/path/to/file')\n```\n\n----------------------------------------\n\nTITLE: RobotFramework Example: Run pyATS Common Setup\nDESCRIPTION: This RobotFramework snippet executes a pyATS common setup script within a test case. It utilizes the `run testcase` keyword provided by the `ats.robot.pyATSRobot` library. The `run testcase` keyword calls the specified pyATS script and function (e.g., `basic_example_script.common_setup`), allowing for the reuse of pyATS setup procedures within RobotFramework tests.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/robot/native.rst#_snippet_1\n\nLANGUAGE: robotframework\nCODE:\n```\n    CommonSetup\n        # calling pyats common_setup\n        run testcase \"basic_example_script.common_setup\"\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyats.connections using pip\nDESCRIPTION: Upgrades an existing installation of the pyats.connections package to the latest version available on PyPI using the pip package manager.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/connections/introduction.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npip install pyats.connections --upgrade\n```\n\n----------------------------------------\n\nTITLE: Connecting to Telnet Device\nDESCRIPTION: The `connect` method establishes a Telnet connection to the device. It uses `self.connection_info` (inherited from `BaseConnection`) to get the IP address and port, and logs into the device by sending credentials and waiting for the prompt. The input is the device configuration, which contains IP address, port and credentials.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/connections/class.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef connect(self):\n    '''connect\n\n    opens the telnet connection and log us in.\n    '''\n\n    # open the telnet session\n    # self.connection_info is inherited from BaseConnection\n    self._telnet.open(host = self.connection_info['ip'],\n                      port = self.connection_info['port'])\n\n    # process login\n    self._telnet.read_until(b\"login: \")\n\n    # send the login name\n    self.send(self.device.tacacs['username'])\n\n    # process password\n    self._telnet.read_until(b\"password: \")\n    self.send(self.device.passwords['tacacs'])\n\n    # find the prompt\n    self._telnet.read_until(self._prompt.encode('ascii'))\n```\n\n----------------------------------------\n\nTITLE: Querying Runtime Information in pyATS AEtest Scripts - Python\nDESCRIPTION: Demonstrates how to import and use the aetest.runtime object to access runtime-specific attributes, such as uids and groups, when executing a pyATS script. Requires the pyats library to be installed and the script to be executed via one of the standard AEtest methods. The snippet shows how to assert that input arguments for uids and groups are empty by default. This code expects to be run within an aetest-based testscript context.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/behavior.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   querying runtime information inside testscripts\n\nfrom pyats import aetest\n\nclass CommonSetup(aetest.CommonSetup):\n\n    # this common setup subsection validates \n    # uids and groups input arguments default to empty\n    @subsection\n    def validate_skip_uids(self):\n        assert not aetest.runtime.uids\n        assert not aetest.runtime.groups\n```\n\n----------------------------------------\n\nTITLE: Finding Links Between Devices (pyATS Python)\nDESCRIPTION: Shows how to use the `find_links()` method on a device object to discover and list all link objects connecting it to another specified device.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/topology/usage.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# find the links connecting n7k5 from n7k4\n# using Device.find_links()\nfor link in n7k4.find_links(n7k5):\n    print(repr(link))\n# <Link rtr1-rtr2-2 at 0xf744ef8c>\n# <Link rtr1-rtr2-1 at 0xf744d16c>\n```\n\n----------------------------------------\n\nTITLE: Using the 'pyats create' Command-Line Interface - Text\nDESCRIPTION: Details the usage and options for the pyATS 'create' command, which scaffolds new test automation projects and scripts via templates. Prior to use, you must install optional dependencies with 'pip install pyats[template]'. Subcommands include project creation using cookiecutter templates, and general CLI options for help, verbosity, and logging levels. This snippet outputs the core text usage guide seen with the command's '--help' option.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/cli/pyats_create.rst#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nUsage:\n  pyats create <subcommand> [options]\n\nDescription:\n  Creates script and library components using cookiecutter templates.\n\n  All subcommands equires the following dependencies to be installed:\n      pip install pyats[template]\n\nSubcommands:\n    project             create a new pyATS project from template\n\nGeneral Options:\n  -h, --help            Show help\n  -v, --verbose         Give more output, additive up to 3 times.\n  -q, --quiet           Give less output, additive up to 3 times, corresponding to WARNING, ERROR,\n                        and CRITICAL logging levels\n```\n\n----------------------------------------\n\nTITLE: Step Results Handling in pyATS AEtest\nDESCRIPTION: Demonstrates how step results are determined and how they roll up to the overall section result. Shows examples of passed, failed (via AssertionError), and errored (via general Exception) steps.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/steps.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   step results default\n\nfrom pyats import aetest\n\nclass Testcase(aetest.Testcase):\n\n    @aetest.test\n    def test_one(self, steps):\n\n        # default step result -> Passed\n        with steps.start('the passed step'):\n            pass\n\n        # AssertionErrors -> Failed\n        with steps.start('the failed step'):\n            assert 1 == 0\n\n    @aetest.test\n    def test_two(self, steps):\n\n        # general Exceptions -> Errored\n        with steps.start('the errored step'):\n            # generate a python error\n            {}['non existent key']\n```\n\n----------------------------------------\n\nTITLE: Nesting pyATS Steps in Python\nDESCRIPTION: Shows how to create hierarchical steps within a test section. A new step started inside another step's `with` block becomes a child step. It also demonstrates passing the current step object to a function (`myFunction`) so that the function's steps become child steps of the calling step, enabling modularity with proper step reporting.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/steps.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   step nesting example\n#   (using a function for demonstration)\n\nfrom pyats import aetest\n\n# import Steps\nfrom pyats.aetest.steps import Steps\n\n# defining a function that support child steps.\n# use Steps() as default value for steps, in case the function is called\n# outside the scope of a testscript.\ndef myFunction(steps = Steps()):\n    with steps.start('function step one'):\n        pass\n    with steps.start('function step two'):\n        pass\n\nclass Testcase(aetest.Testcase):\n\n    @aetest.test\n    def test(self, steps):\n\n        # demonstrating a step with multiple child steps\n        with steps.start('test step 1') as step:\n            with step.start('test step 1 substep a'):\n                pass\n            with step.start('test step 1 substep a') as substep:\n                with substep.start('test step 1 sub-step a sub-substep i'):\n                    pass\n                with substep.start('test step 1 sub-step a sub-substep ii'):\n                    pass\n\n        # demonstrating a step where a function is called, and\n        # the function it self takes a few child steps to complete\n        with steps.start('call function step') as step:\n            # call the function, pass current step into it\n            myFunction(step)\n```\n\n----------------------------------------\n\nTITLE: Creating a Testcase with pyATS aetest\nDESCRIPTION: This snippet demonstrates how to create a testcase using pyATS aetest, including a common setup, setup, test, and cleanup sections. It shows the basic structure of an aetest test script.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/objects.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats import aetest\n\n\nclass MyCommonSetup(aetest.CommonSetup):\n    # subsection corresponds to Subsection cls\n    @aetest.subsection\n    def subsection_one(self):\n        pass\n\nclass MyTestcase(aetest.Testcase):\n\n    # setup corresponds to SetupSection cls\n    @aetest.setup\n    def setup(self):\n        pass\n\n    # test corresponds to TestSection cls\n    @aetest.test\n    def test_one(self):\n        pass\n\n    # cleanup corresponds to CleanupSection cls\n    @aetest.cleanup\n    def cleanup(self):\n        pass\n\n# when container instances are iterated,\n# the returned objects are function class instances\ntc = MyTestcase()\nfor obj in tc:\n    print(type(obj))\n    print(obj.function)\n# <class 'pyats.aetest.sections.SetupSection'>\n# <bound method MyTestcase.setup of <class 'MyTestcase' uid='MyTestcase'>>\n# <class 'pyats.aetest.sections.TestSection'>\n# <bound method MyTestcase.test_one of <class 'MyTestcase' uid='MyTestcase'>>\n# <class 'pyats.aetest.sections.CleanupSection'>\n# <bound method MyTestcase.cleanup of <class 'MyTestcase' uid='MyTestcase'>>\n```\n\n----------------------------------------\n\nTITLE: Listing Remote Directory Contents with FTP in Python\nDESCRIPTION: Example showing how to list files in a remote FTP directory using the dir() method of the FileUtils module. This operation requires FTP credentials to be configured in the testbed.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/file_transfer_utilities.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfutils.dir(target = 'ftp://myserver.domain.com/remote/path/to/')\n```\n\n----------------------------------------\n\nTITLE: Enabling Standalone Execution in Python TestScript\nDESCRIPTION: Template for implementing standalone execution capability in a testscript by adding the __main__ block that invokes aetest.main() with optional environment configuration.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/run.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   enabling standalone execution\n\nimport logging\nfrom pyats import aetest\n\n# your testscript sections, testscases & etc\n# ...\n#\n\n# add the following as the absolute last block in your testscript\nif __name__ == '__main__':\n\n    # control the environment\n    # eg, change some log levels for debugging\n    logging.getLogger(__name__).setLevel(logging.DEBUG)\n    logging.getLogger('pyats.aetest').setLevel(logging.DEBUG)\n\n    # aetest.main() api starts the testscript execution.\n    # defaults to aetest.main(testable = '__main__')\n    aetest.main()\n```\n\n----------------------------------------\n\nTITLE: pyATS Job Manifest Schema Structure (YAML)\nDESCRIPTION: This YAML snippet defines the structure for a pyATS job manifest file. It includes required fields like 'version' and 'type' (e.g., 'easypy'), and optional sections for 'arguments', 'description', 'tags', 'command', 'runtimes' (defining execution environments like virtualenv or system), and 'profiles' (allowing variations in arguments, runtime, and Xpresso-specific settings like 'max_runtime', 'priority', 'testbed', 'topology', and 'docker' configurations). Comments within the snippet explain the purpose and format of each field.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/manifest/schema.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nversion: 1 # <integer> schema version for manifest\n           # required\n\nname:  # Name of the job / one-line description\n\ntype:  # type of script: easypy\n       # required\n\narguments:  # arguments for the script (optional)\n\n    <key>: <value>\n\n    key:\n    - val1\n    - val2\n\n    \"--key\": value\n    \"-k\": value\n\n    <key>: \"*N\"\n\n    <key>: true|false\n\n    <key>: \"True\"\n\ndescription: |\n    # This is the description for this script\n    (optional)\n\nnote: |\n    # Note about this script, e.g. instructions or known issues\n    (optional)\n\ntags:\n-  # string with tag keyword\n(optional)\n\ncommand:  # command to execute script. Either `easypy` or `pyats run job`.\n          # (optional)\n          # By default, the command is inferred from the 'type'\n          # e.g. easypy job types use the command: `pyats run job` by default.\n\n# definition of runtimes for the related script\n# (optional)\nruntimes:\n    <name>:  # name of the runtime, e.g. venv\n\n        type:  # supported types: virtualenv, system\n               # 'system' is the existing shell environment\n               # required\n\n        source:  # list of environment files to source (optional)\n        -  # path to file\n\n        environment:  # dictionary of environment variables for the execution of the script\n                      # (optional)\n            <key>: <value>\n\n        # list of files/paths that need to exist for succesfull execution (e.g. library files)\n        # (optional)\n        files:\n            -  # path to file or directory\n\n# Profiles\n# (optional)\nprofiles:\n\n    <name>:  # name of the profile\n\n        runtime:  # name of the runtime to use, if not specified, 'system' is assumed\n                  # (optional)\n\n        description: |\n            # description of the profile\n            # (optional)\n\n        arguments:   # arguments that override the global script arguments\n                     # (optional)\n            <key>: <value>\n\n        # below parameters are for xpresso\n\n        max_runtime: HH:MM,   # max runtime in hours:minutes (optional)\n\n        interest_list:       # list of email addresses (optional)\n            - list@domain\n            - user@domain\n\n        priority:  # job priority (integer) (optional)\n                   # priority ranges from 0-5 where 0 presents the highest priority and 5 represents the lowest priority.\n\n        testbed:   # static testbed defined in xpresso (optional)\n            name:  # name of the testbed\n\n        topology:  # dynamic testbed defined in xpresso (optional)\n            name:  # name of the topology\n\n        docker:  # docker details  (optional)\n            volumes:  # docker volume mounts\n                      # volume mounts are used with container execution using xpresso\n               - \"/path\"\n               - \"/another/path\"\n```\n\n----------------------------------------\n\nTITLE: Context Processor Example, Python\nDESCRIPTION: This code defines a context processor class `ContextProcessor` that prints the section UID on entry, and the section result on exit (or exception details if an exception occurs). It subclasses from `BaseContextProcessor` and its methods `__enter__` and `__exit__` are used to define the pre/post/exception processing. It is attached to a testcase using `@aetest.processors`.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/processors.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats import aetest\nfrom pyats.aetest.processors.bases import BaseContextProcessor\n\n# define a context processor that:\n#   - print the section uid before testcase\n#   - prints the section result after testcase in normal conditions\n#   - prints the exception when an exception occurs\n\nclass ContextProcessor(BaseContextProcessor):\n\n    def __enter__(self):\n        print('current section: ', self.section.uid)\n        # can also access parameters\n        testbed = self.parameters.get('testbed')\n\n    def __exit__(self, type_, value, traceback):\n        if type_:\n            print('An exception occured!')\n            print('exception : ', exc_type, exc_value)\n        else:\n            print('section result: ', self.section.result)\n\n# attach above context processor to a Testcase\n@aetest.processors(ContextProcessor)\nclass Testcase(aetest.Testcase):\n\n    @aetest.test\n    def test(self):\n        print('running testcase test section')\n\n    @aetest.test\n    def testException(self):\n        raise Exception('running testcase testException section')\n```\n\n----------------------------------------\n\nTITLE: Example of defining run uids function to execute specific testcases in pyATS\nDESCRIPTION: Shows how to define a callable function that controls which testcases to run based on current uids, enabling selective execution before or during test run, using the run() method with uids parameter.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/control.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.easypy import run\n\n# function determining whether we should run testcase_A\n# currently executing uids is always a list of:\n#       [ <container uid>, <section uid>]\n# eg, ['common_setup', 'subsection_one']\n# thus varargs (using *) is required for the function input.\ndef run_only_testcase_A(*ids):\n    # check that we are running testcase_A\n    return 'testcase_A' in uids\n\n# run only testcase_A and its contents (using callable)\n# executing uids has testcase_A:\nrun('example_script.py', uids=run_only_testcase_A)\n```\n\n----------------------------------------\n\nTITLE: Using Legacy Imports in Python\nDESCRIPTION: This code shows how to use the `__legacy_imports__` utility to maintain compatibility with older import paths. By importing `from pyats.utils import __legacy_imports__` at the top of the script, you enable the use of legacy import statements.  It allows users to continue using old import paths (e.g., `import my_module`) even when the package has been updated to use a new import path (e.g., `import my_package.my_module`). This is useful for scripts to continue functioning when packages change their import structure.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/import_utils.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.utils import __legacy_imports__\n\n# assume for instance, a package changed its imports in a new release\n# from:\nimport my_module\n\n# to:\nimport my_package.my_module\n\n# in you script, as long as you do this first:\nfrom pyats.utils import __legacy_imports__\n\n# you'll be able to continue to\nimport my_module\n```\n\n----------------------------------------\n\nTITLE: Defining a CommonCleanup Section in pyATS AEtest (Python)\nDESCRIPTION: This Python code snippet shows the beginning of a `CommonCleanup` section definition in a pyATS AEtest script. It demonstrates creating a class that inherits from `aetest.CommonCleanup`. This section is intended for defining methods decorated with `@aetest.subsection` to perform cleanup tasks (like removing configurations) that should run after all testcases, regardless of their outcome. Requires importing `aetest` from the `pyats` library. The provided example is incomplete and lacks actual subsection methods.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/structure.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   an example common cleanup\n\n# import the aetest module\nfrom pyats import aetest\n\n# define a common cleanup section by inherting from aetest\nclass ScriptCommonCleanup(aetest.CommonCleanup):\n    # Subsections for cleanup would be defined here\n    pass # Placeholder for actual cleanup subsections\n```\n\n----------------------------------------\n\nTITLE: Renaming a Remote File with FTP in Python\nDESCRIPTION: Example demonstrating how to rename a file on a remote FTP server using the renamefile() method. This requires source and destination paths on the same FTP server.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/file_transfer_utilities.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfutils.renamefile(\n    source = 'ftp://myserver.domain.com/remote/path/to/file',\n    destination = 'ftp://myserver.domain.com/remote/path/to/renamed_file')\n```\n\n----------------------------------------\n\nTITLE: Using Goto for Control Flow in pyATS Tests (Python)\nDESCRIPTION: Presents the pseudo-code syntax for using the `goto` keyword argument within pyATS result APIs (like `self.passed`, `self.failed`, etc.). This allows for explicit, one-way, forward jumps to target sections such as 'cleanup', 'next_tc', 'common_cleanup', or 'exit', enabling early termination or skipping of sections based on test outcomes. Requires `pyats.aetest`.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/control.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   goto syntax\n#   (pseudo code, not showing the entire testcase)\n\nfrom pyats import aetest\n\n# Syntax:\n#   <resultAPI>(goto = ['target_1', 'target_2', ... , 'target_x'])\n```\n\n----------------------------------------\n\nTITLE: Generator Context Processor Example, Python\nDESCRIPTION: This code defines a generator-style context processor `context_processor` that prints the section UID on entry, and the section result on exit (or exception details if an exception occurs). It uses the `@aetest.processors.context` decorator. It is attached to a testcase using `@aetest.processors`.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/processors.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats import aetest\n\n@aetest.processors.context\ndef context_processor(section, processor):\n    print('current section: ', section.uid)\n    # accessing parameters\n    testbed = processor.parameters.get('testbed')\n\n    try:\n        yield\n\n    except Exception as e:\n        print('An exception occurred!')\n        print('exception : ', exc_type, exc_value)\n        # we are not raising e, so it will be suppressed\n    else:\n        print('section result: ', section.result)\n\n\n# attach above context processor to a Testcase\n@aetest.processors(context_processor)\nclass Testcase(aetest.Testcase):\n\n    @aetest.test\n    def test(self):\n        print('running testcase test section')\n\n    @aetest.test\n    def testException(self):\n        raise Exception('running testcase testException section')\n```\n\n----------------------------------------\n\nTITLE: Getting Remote File Details with FileUtils in Python\nDESCRIPTION: Example demonstrating how to retrieve details about a remote file using the stat method, which returns a structure similar to that of os.stat.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/file_transfer_utilities.rst#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.utils.fileutils import FileUtils\nwith FileUtils(testbed=tb) as futils:\n    file_details = futils.stat(\"sftp://server.domain.com/path/to/file\")\n\n    import stat\n    print(stat.filemode(file_details.st_mode))\n\n'-rwxrwxrwx'\n```\n\n----------------------------------------\n\nTITLE: Setting/Getting Tcl Variables with dict interface (Python)\nDESCRIPTION: Illustrates the dictionary-style access provided by `tcl.vars` for setting and getting Tcl variables. This interface allows accessing scalar variables and array elements in Tcl as if they were entries in a Python dictionary, simplifying variable manipulation. Requires the `pyats.tcl` library.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/tcl/variables.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n# \n#   dict style setting & getting variables\n\nfrom pyats import tcl\n\n# setting variables\ntcl.vars['myVar'] = 1\n\n# getting variables\nvalue = tcl.vars['myVar']\n\n# this also works with array elements\ntcl.vars['myArray(ironman)'] = 'tony stark'\ntcl.vars['myArray(mk1,color)'] = 'steel silver'\n# myArray(ironman)   = tony stark\n# myArray(mk1,color) = steel silver\n\n# reading array elements\nname = tcl.vars['myArray(ironman)']\n```\n\n----------------------------------------\n\nTITLE: Managing FileUtils Sessions with Try-Finally in Python\nDESCRIPTION: Example showing how to manually manage FileUtils sessions using try-finally blocks to ensure proper closure of protocol sessions after use.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/file_transfer_utilities.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.utils.fileutils import FileUtils\nfutils = FileUtils(testbed=tb)\ntry:\n    file_details = futils.stat(\"sftp://server.domain.com/path/to/file\")\n    file2_details = futils.stat(\"sftp://server.domain.com/path/to/file2\")\nfinally:\n    futils.close()\n```\n\n----------------------------------------\n\nTITLE: Loading Testbed YAML File in Python\nDESCRIPTION: Python code showing how to manually load a testbed YAML file, which is the equivalent of what pyATS shell does automatically. This demonstrates the low-level API that pyATS shell wraps.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/cli/pyats_shell.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.topology import loader\ntestbed = loader.load('/path/to/your/testbed.yaml')\n```\n\n----------------------------------------\n\nTITLE: Dynamic pyATS Processor Management Example - Python\nDESCRIPTION: Provides a comprehensive example demonstrating dynamic management of processors within a pyATS test script structure. It shows how to define custom processor functions, use `aetest.processors.affix()` to attach them to Testcase and test sections, and use `aetest.processors.get()` to inspect attached processors during runtime.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/processors.rst#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats import aetest\n\ndef print_parameters(section):\n    print(section.parameters)\n\ndef print_exception_message(section, exc_type, exc_value, exc_traceback):\n    print('exception : ', exc_type, exc_value)\n    return True\n\nclass CommonSetup(aetest.CommonSetup):\n\n    @aetest.subsection\n    def subsection(self):\n        # affix pre-processors and exception-processors to testcase\n        aetest.processors.affix(Testcase, pre = [print_parameters],\n                                exception = [print_exception_message])\n\nclass Testcase(aetest.Testcase):\n\n    @aetest.setup\n    def setup(self):\n        # check if testcase has processors\n        for type_ in ('pre', 'post', 'exception'):\n            if aetest.processors.get(self, type_):\n                print('Testcase has %s-processors' % type_)\n\n        # affix post-processors to test function\n        aetest.processors.affix(self.test, post = [print_parameters])\n\n        # affix exception-processors to testException function\n        aetest.processors.affix(self.testException,\n                                exception = [print_exception_message])\n\n    @aetest.test\n    def test(self):\n        pass\n\n    @aetest.test\n    def testException(self):\n        pyATS()\n```\n\n----------------------------------------\n\nTITLE: Example Clean YAML File for Kleenex Configuration in YAML\nDESCRIPTION: A sample YAML configuration file defining the cleaner class, module, and target devices used by Kleenex. This file specifies a cleaner named `PyatsDeviceClean` located in the `genie.libs.clean` module, targeting the device named `r1`. The device section lists image binaries that may be used during the cleaning process. These configurations guide Kleenex on how to perform device clean operations.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/kleenex/usages.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n--- # clean.yaml\ncleaners:\n    PyatsDeviceClean:\n        module: genie.libs.clean\n        devices: [r1]\n\ndevices:\n    r1:\n        images:\n            - /path/to/6500-test-image.bin\n```\n\n----------------------------------------\n\nTITLE: Disconnecting Device Connections with pyATS ConnectionManager (Python)\nDESCRIPTION: Illustrates how to disconnect single or aliased connections using device.disconnect(), and shows equivalency with both connection manager methods and direct object disconnect calls. The alias parameter identifies which connection to operate on (defaulting to 'default'). The affected object remains instantiated, allowing reconnection by calling .connect() again. Inputs are the alias (optional), and no output is returned apart from a change in connection state.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/connections/manager.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# disconnect the default aliased connection\ndevice.disconnect()\n# equivalent to: device.connectionmgr.disconnect(alias = 'default')\n\n# disconnect a specific alias\ndevice.disconnect(alias = 'vty_1')\n# equivalent to: device.connectionmgr.disconnect(alias = 'vty_1')\n\n# in effect, it is the same as doing:\ndevice.connectionmgr.connections['vty_1'].disconnect()\n```\n\n----------------------------------------\n\nTITLE: Using FileServer as a Context Manager for Temporary File Transfers\nDESCRIPTION: This Python example demonstrates how to instantiate a `FileServer` as a context manager, allowing temporary server setup for file transfers during a test. It shows how to specify protocol, root path, and testbed integration, enabling dynamic server management and cleanup.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/file_transfer_server.rst#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nfrom genie.libs.filetransferutils import FileServer\nwith FileServer(protocol='ftp',\n                path='/path/to/root/dir',\n                testbed=testbed,\n                name='mycontextserver') as fs:\n    uut.api.copy_to_device(protocol='ftp',\n                           server='mycontextserver',\n                           remote_path='myimage.bin',\n                           local_path='flash:/)\n```\n\n----------------------------------------\n\nTITLE: Copying Files to Devices Using the API with an FTP Server\nDESCRIPTION: This Python code snippet shows how to use the Genie API to copy a file to a device via an FTP server defined in the testbed. It specifies protocol, server name, remote and local paths, enabling automated file transfer during tests.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/file_transfer_server.rst#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nuut.api.copy_to_device(protocol='ftp',\n                       server='myftpserver',\n                       remote_path='myimage.bin',\n                       local_path='flash:/)\n```\n\n----------------------------------------\n\nTITLE: Representing Nested Dictionary using ListDict in Python\nDESCRIPTION: Shows how to convert a nested dictionary into a ListDict structure, which breaks down nested dictionaries into a list of path-value pairs for easier manipulation.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/datastructures/listdict.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Representing Nested Dict using path/value\n# -----------------------------------------\n#\n#   reusing the dictionary 'd' from before\n\nfrom pyats.datastructures import ListDict\n\n# ListDict format:\n#   [(path_x, value_x), \n#    (path_y, value_y),\n#     ... ]\n#\n# where path is of the form tuple():\n#   (nesting_a, nesting_b, ... , final_key)\n\nld = ListDict(d)\n# [DictItem(path=('x', 'y', 'z'), value=100), \n#  DictItem(path=('a', 'b', 'c', 'd'), value='value')]\n```\n\n----------------------------------------\n\nTITLE: Receiving Data from Telnet\nDESCRIPTION: The `receive` method receives data from the Telnet session. It uses `self._telnet.read_eager()` to read all available data from the buffer and decodes it into a string.  It requires no direct input but returns a string.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/connections/class.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef receive(self):\n    '''receive\n\n    low-level api: reads from the telnet session and returns whatever is\n    currently in the buffer\n    '''\n\n    # remember to convert back from bytes to string\n    return self._telnet.read_eager().decode('utf-8')\n```\n\n----------------------------------------\n\nTITLE: Specifying Test Sections to Run with pyATS AEtest - Python and Bash\nDESCRIPTION: Controls which test script sections (uids) are executed by passing a callable expression that returns True or False for each uid. This can be specified via command-line using Python-syntax evaluatable inputs, or programmatically via aetest.main or easypy.run calls. Dependencies include the pyats.datastructures.logic module for logical operators. Input is a string or callable filtering section uids, output controls executed sections. Limitations include the requirement for valid Python syntax and evaluatable expressions.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/run.rst#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nbash$ python testscript.py -uids \"And('pattern_1', 'pattern_2')\"\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.datastructures.logic import Or\naetest.main('testscript.py', uids = Or('common_setup',\n                                           '^test_.*',\n                                           'common_cleanup'))\n```\n\nLANGUAGE: python\nCODE:\n```\nrun(testscript = 'testscript.py', uids = lambda tc, section=None: tc in ['common_setup', 'test_one'])\n```\n\n----------------------------------------\n\nTITLE: Checking Connection State with pyATS ConnectionManager.is_connected (Python)\nDESCRIPTION: Demonstrates checking if a specified connection (by alias) is currently established, using device.is_connected(). Returns a boolean based on the .connected property of the underlying connection, returning False if neither a connection nor an alias exists. Inputs are an optional alias, output is True or False.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/connections/manager.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# lookup the default aliased connection\ndevice.is_connected()\n# equivalent to: device.connectionmgr.is_connected(alias = 'default')\n\n# lookup a specific alias\ndevice.is_connected(alias = 'vty_1')\n# equivalent to: device.connectionmgr.is_connected(alias = 'vty_1')\n\n# in effect, it is the same as doing:\ndevice.connectionmgr.connections['vty_1'].connected\n```\n\n----------------------------------------\n\nTITLE: Multiple Device Connection Syntax with pyATS\nDESCRIPTION: This snippet showcases the syntax for establishing and managing multiple connections to a device using aliases in pyATS. It details how to connect to a device using a specific alias and path, disconnect from an alias, and call services associated with each alias.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/connections/integration.rst#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nSyntax\n------\n\n    # [] denotes optional arguments\n    # *args, **kwargs denotes all other possible arguments\n\n    # connect to alias and disconnect from alias\n    device.connect(alias = \"alias\", [via = \"path\"], [**kwargs])\n    device.<alias>.disconnect()\n\n    # calling services of an alias\n    device.<alias>.<services>([*args], [**kwargs])\n```\n\n----------------------------------------\n\nTITLE: Mega Looping in pyATS aetest: comprehensive looping and nested testcases in Python\nDESCRIPTION: This complex example demonstrates all major pyATS aetest looping techniques, including static variable list, subsections with loop decorators, dynamic marking of testcases for looping, and nested testcases with their own loops. It incorporates argument parsing for testbed and interface parameters, dynamically setting up tests based on runtime inputs, and showcases how to control flow with nested loops and data-driven testing. Dependencies include pyats.aetest, argparse, and pyats.topology.loader. This pattern enables extensive parameterized testing for network automation scenarios.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/examples.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   loop everything!\n\nimport logging\nfrom pyats import aetest\n\nlogger = logging.getLogger(__name__)\n\n# static variable\nVLANS = list(range(1, 4096))\n\nclass CommonSetup(aetest.CommonSetup):\n\n    @aetest.subsection\n    def check_testbed(self, testbed):\n        '''\n        checking testbed information\n        '''\n\n        logger.info('Testbed = %s' % testbed)\n        # do some testbed checking\n        # ...\n\n    @aetest.subsection.loop(vlan=VLANS)\n    def configure_vlan(self, vlan):\n        '''\n        configure every vlan, each being a subsection\n        '''\n\n        logger.info(\"configuring vlan: %s\" % vlan)\n        # do the configuration\n        # ...\n\n    # dynamically assign looping of Testcase based on script argument information\n    @aetest.subsection\n    def mark_testcase_for_looping(self, interfaces):\n        '''\n        marking testcase for looping based on script argument interfaces\n        '''\n\n        aetest.loop.mark(InterfaceFlapping, interface=interfaces)\n\nclass InterfaceFlapping(aetest.Testcase):\n    '''\n    tests interface flapping, requires parameter 'interface'\n    '''\n\n    @aetest.setup\n    def setup(self, interface):\n        logger.info('testing interface: %s' % interface)\n\n    @aetest.test.loop(status=['up', 'down'])\n    def test_status(self, status):\n        '''\n        check that intf status can be flapped\n        '''\n        logger.info('configure interface status to: %s' % status)\n        # do testing\n        # ...\n\n@aetest.loop(vlan=VLANS)\nclass Traffic(aetest.Testcase):\n    '''\n    send traffic on all vlans on all interfaces\n    '''\n\n    @aetest.setup\n    def setup(self, interfaces):\n        '''\n        mark traffic test with looping through interfaces\n        '''\n        aetest.loop.mark(self.test, interface=interfaces)\n\n    def test(self, interface, vlan):\n        '''\n        send traffic to vlan + interface\n        '''\n        logger.info('interface: %s' % interface)\n        logger.info('vlan: %s' % vlan)\n        # send traffic\n        # ...\n\nclass CommonCleanup(aetest.CommonCleanup):\n\n    @aetest.subsection.loop(vlan=VLANS)\n    def unconfigure_vlan(self, vlan):\n        '''\n        unconfigure every vlan, each being a subsection\n        '''\n\n        logger.info(\"configuring vlan: %s\" % vlan)\n        # do the configuration\n        # ...\n\n# main() execution block\nif __name__ == '__main__':\n\n    # set logger level\n    logger.setLevel(logging.INFO)\n\n    # local imports\n    import sys\n    import argparse\n    from pyats.topology import loader\n\n    parser = argparse.ArgumentParser(description = \"standalone parser\")\n    parser.add_argument('--testbed', dest = 'testbed')\n    parser.add_argument('--interfaces', dest = 'interfaces')\n\n    # parse args\n    args, sys.argv[1:] = parser.parse_known_args(sys.argv[1:])\n\n    # post-parsing processing\n    testbed = loader.load(args.testbed)\n    interfaces = args.interfaces.split(',')\n\n    # pass arguments to aetest.main()\n    aetest.main(testbed=testbed, interfaces=interfaces)\n\n# Command to run standalone:\n# bash$ python mega_looping.py --testbed tb.yaml --interfaces=\"Ethernet1/1,Ethernet1/2\"\n\n# To run under Easypy, create a job file:\n#\n# from pyats.easypy import run\n#\n# def main():\n#     run('mega_looping.py', interfaces=['Ethernet1/1', 'Ethernet1/2'])\n\n# And execute with:\n# bash$ pyats run job mega_looping_job.py --testbed-file tb.yaml\n```\n\n----------------------------------------\n\nTITLE: Nested Access Methods in NestedAttrDict - pyATS - Python\nDESCRIPTION: Illustrates how NestedAttrDict enhances standard dictionary methods like `get`, `del`, and item assignment (`[]`) to support nested key paths using dot separators. This allows manipulating deeply nested values with concise syntax. Requires a NestedAttrDict instance.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/datastructures/attrdict.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#     various object access\n\nmy_dict = {\n    'a': 1,\n    'b': 2,\n    'c': {\n        'x': 10,\n        'y': 20,\n        'z': {\n            'value': 100,\n        },\n    },\n}\n\nobj = NestedAttrDict(my_dict)\n\n# get api\nobj.get('c.y')\n# 20\n\nobj.get('a')\n# 1\n\n# get with default\nobj.get('c.z.non_existent_value', 1000)\n# 1000\n\n# delete\ndel obj['c.x']\n# NestedAttrDict({'a': 1,\n#                 'b': 2,\n#                 'c': NestedAttrDict({'y': 20,\n#                                      'z': NestedAttrDict({'value': 100})})})\n\n# set\nobj['c.z.value_two'] = 200\n```\n\n----------------------------------------\n\nTITLE: Upgrading Pyats - Cisco Internal - Bash\nDESCRIPTION: This command upgrades the pyats package, designed for Cisco internal developers using pip. It retrieves the latest Pyats version and updates the installation. Requires pip and an active network connection to access the package repository.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2024/january.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Cisco Internal Developers\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Demonstrating All-In-One Tcl-Python Variable Conversion in pyATS\nDESCRIPTION: This comprehensive example demonstrates how to use the all-in-one shortcut methods to get and set various Tcl data types (integers, doubles, booleans, lists, arrays, and keyed lists) and convert them to equivalent Python objects. Each section shows setting the Tcl variable, verifying its value in Tcl, and retrieving it as a Python object.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/tcl/variables.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats import tcl\n\n# Tcl Integers\n# ------------\ntcl.set_int('myInteger', 9999)\ntcl.vars['myInteger']\n'9999'\nintVar = tcl.get_int('myInteger')\n9999\n\n# Tcl Doubles\n# -----------\ntcl.set_double('myDouble', 3.1415926)\ntcl.vars['myDouble']\n'3.1415926'\nintVar = tcl.get_int('myDouble')\n3.1415926\n\n# casting Tcl Booleans\n# --------------------\ntcl.set_boolean('myBool', True)\ntcl.vars['myBool']\n'1'\nintVar = tcl.get_boolean('myBool')\nTrue\n\n# Tcl Lists\n# ----------\ntcl.set_list('myList', [1, 2, 3, 4, 5])\ntcl.vars['myList']\n'1 2 3 4 5'\nlistVar = tcl.get_list('myList')\n('1', '2', '3', '4', '5')\n\n\n# Tcl Arrays\n# ----------\ntcl.set_array('myArray', tcl.Array(a = 1, b = 2, c = 3))\ntcl.eval('parray myArray')\n# myarray(a) = 1\n# myarray(b) = 2\n# myarray(c) = 3\n\n# reading tcl arrays by name and typecasting\narray = tcl.get_array('myArray)')\nArray({'c': '3', 'b': '2', 'a': '1'})\n\n# Tcl Keyed Lists\n# ---------------\ntcl.set_keyed_list('myKlist', tcl.KeyedList(a = 1, b = 2, c = 3))\ntcl.vars['myKlist']\n'{c 3} {b 2} {a 1}'\n\n# reading tcl arrays by name and typecasting\nklist = tcl.get_keyed_list('myKlist')\nKeyedList({'c': '3', 'b': '2', 'a': '1'})\n```\n\n----------------------------------------\n\nTITLE: Setting Testbed Credentials\nDESCRIPTION: This Python snippet demonstrates how to set and access credentials within a pyATS Testbed object. It uses a dictionary to store usernames and passwords, and then accesses these credentials via dot notation. The `testbed_a` object is assumed to be initialized.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/topology/concept.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Setting default credentials on a testbed\n# Note that, once set, credentials may be accessed via dot notation.\ntestbed_a.credentials['default'] = dict(username='defaultuser', password='defaultpw')\nassert testbed_a.credentials.default.username == 'defaultuser'\n\n# Setting credentials on a testbed\n# Note that, once set, credentials may be accessed via dot notation.\ntestbed_a.credentials['tbcreds'] = dict(username='tbuser', password='tbpw')\nassert testbed_a.credentials.tbcreds.username == 'tbuser'\n```\n\n----------------------------------------\n\nTITLE: Attaching and Using TaskLogHandler for File Logging in pyATS (Python)\nDESCRIPTION: This example demonstrates attaching TaskLogHandler to a logger for logging messages to a CiscoLog-compliant file, dynamically changing the output file during runtime, toggling colored output (default disabled), and enabling or disabling behavior for forked child processes. Dependencies include pyATS's pyats.log, and the standard logging module. The user can specify absolute or relative file paths for logging and dynamically switch file output via handler.changeFile(). No special input is required except file paths and log messages; output is written to logfile(s) in CiscoLog format, possibly with ANSI coloring if enabled.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/log/implementation.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport logging\nfrom pyats.log import TaskLogHandler\n\n# get the root logger\nlogger = logging.getLogger(__name__)\n\n# create handler (with full path to log file)\nhandler = TaskLogHandler('/path/to/my/TaskLog-A.log')\n\n# add handler to logger\nlogger.addHandler(handler)\n\n# set logging level a bit lower to enable INFO\nlogger.setLevel(logging.INFO)\n\n# now try logging\nlogger.info('an info message')\n\n# get current log directory and file\nlogdir = handler.logdir\nlogfile = handler.logfile\n\n# change log file to a different file\nhandler.changeFile('/path/to/my/TaskLog-B.log')\n\n# log again, it appears in second file\nlogger.info('another info message')\n\n# enable/disable on-fork create new logfile\n# (this behavior is inherited in child processes)\nhandler.enableForked()\nhandler.disableForked()\n\n# enable coloured output\n# (default to disabled - enabling will cause ANSI colour codes to appear\n#  in your task log, which the log viewer may not support)\nhandler.coloured = True\n```\n\n----------------------------------------\n\nTITLE: Command for Updating pyATS Packages with 'pyats version update' (Text)\nDESCRIPTION: This snippet explains the 'pyats version update' subcommand, which facilitates a one-click update of pyATS and its dependencies, automating the upgrade process. It also details options like '--yes' to bypass prompts and specify version targets.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/cli/pyats_version.rst#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\npyats version update\n--------------------\n\nThis subcommand performs a one-click update of all your pyATS and its dependency\npackages. The intent is to simplify common upgrade/downgrade process, eliminate\nthe need to fiddle with `pip` command, and maintain a seamless user experience\nthrough packaging refactor/changes.\n\nIt performs the following actions in sequence:\n\n1. check whether your environment has package mismatches\n\n2. removes all current pyATS packages\n\n3. installs the newly specified versions.\n\nOptions\n^^^^^^^\n\n``version``\n    update your pyATS packages to this version. If not provided, defaults to\n    current latest version\n\n``--yes``\n    skip the prompt that confirms wehether you want to do the environment\n    update, and auto-providing consent.\n\n.. tip::\n\n    this command is perfect for restoring an out-of-shape, out-of-date and/or\n    corrupted environment back in order.\n```\n\n----------------------------------------\n\nTITLE: Looping with Callable Arguments in PyATS\nDESCRIPTION: This snippet demonstrates the use of a callable (a function in this case) as an argument to a loop in PyATS. The function `my_function` is defined and used as the value for parameter 'a' in the loop. The function is called before its looped sections are created, and its return values are then used for each iteration of the loop.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/loop.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats import aetest\n\n# defining a function\n# functions are callable\ndef my_function():\n    value = [1, 2, 3]\n    print(\"returning %s\" % value)\n    return value\n\nclass Testcase(aetest.Testcase):\n\n    # creating test section with parameter \"a\" as a function\n    # note that the function object is passed, not its values\n    @aetest.test.loop(a=my_function)\n    def test_one(self, a):\n        print(\"a = %s\" % a)\n```\n\n----------------------------------------\n\nTITLE: Running multiprocessing processes with pyATS in Python\nDESCRIPTION: This snippet provides a sample pyATS test script that demonstrates creating child processes using the Python multiprocessing module. It defines simple worker functions that are executed in separate processes and uses pyATS aetest framework to structure tests. The multiprocessing.Process class is used to run a function that sleeps for a duration, and multiprocessing.Pool is used to map a computation-heavy function to multiple processes concurrently. Dependencies include the pyATS framework, standard multiprocessing and logging modules. The inputs are the arguments passed to target functions, and the expected outputs are logged results and proper process management and synchronization using join() and pool context management.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/async/multiprocessing.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport time\nimport logging\nimport multiprocessing\n\nfrom pyats import aetest\n\nlogger = logging.getLogger(__name__)\n\n# define some functions to be called in forked processes\ndef f(x):\n    result = x*x\n    logger.info('%s * %s == %s' % (x,x, result))\n    return result\n\ndef sleep(x):\n    logger.info('sleeping for %s seconds' % x)\n    time.sleep(x)\n    logger.info('done sleeping, fully recharged :)')\n\nclass Testcase(aetest.Testcase):\n\n    # create a child process to run the sleep function & block\n    @aetest.test\n    def sleep_test(self):\n        p = multiprocessing.Process(target = sleep, args = (30,))\n        p.start()\n        p.join()\n\n    # create a pool of child processes to do computing\n    # (not that this makes sense... for example's sake)\n    @aetest.test\n    def pool_test(self):\n        with multiprocessing.Pool(2) as pool:\n            result = pool.map(f, range(20))\n\n        logger.info('result = %s' % result)\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyATS version\nDESCRIPTION: This command upgrades the pyATS package to the latest version using pip. It ensures that you have the newest features and bug fixes.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2016/july.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Accessing and Using Q Magic in pyATS Tcl Interpreter Python\nDESCRIPTION: This snippet demonstrates how to create Tcl procedures and namespaces from Python using pyATS's tcl.eval, then invoke them using the Q magic object for object-style attribute access. It covers setting and retrieving variables, handling keyed lists, invoking namespaced Tcl functions via chained attributes, and mapping positional and keyword arguments from Python to Tcl. Dependencies include the pyats.tcl module. Inputs are Tcl procedure definitions as strings and function call arguments; outputs are results from Tcl procedure or variable operations with automatic typecasting to Python types where possible.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/tcl/q.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n# \n#   how to make fun of Q, 007 style.\n\nfrom pyats import tcl\n\n# create some procs/namespaces for use during this example\ntcl.eval('''\n    # for testing casting\n    keylset klist a \"some value\"\n    keylset klist b \"more values\"\n    keylset klist c.d.e \"nested keys\"\n\n    # for testing positional arguments\n    proc testPositionalArgs {a b c} {\n        return [list $a $b $c]\n    }\n\n    # for testing dashed arguments\n    proc testDashedArgs {args} {\n        return $args\n    }\n\n    # for testing mixed style arguments\n    proc testMixedArgs {a b args} {\n        return [list $a $b $args]\n    }\n\n    # for nesting namespaces\n    namespace eval ::a {\n        namespace eval b {\n            proc c {args} {\n                return $args\n            }\n        }\n    }\n''')\n\n# what is this... Q?\ntcl.q\n# <pyats.tcl.Q magic, referring Tcl code>\n\n# q is Q - the lowercase was only created to avoid pressing shift :)\nassert tcl.q is tcl.Q\nTrue\n\n# setting and getting variables\ntcl.q.set('myVar', 1)\nret = tcl.q.set('myVar')\n\n# Q always performs a typecast (using Interpreter.cast_any) on the return\ntcl.q.set('myVar')\n1\ntcl.q.set('klist')\nKeyedList({'b': 'more values', \n           'c': KeyedList({\n                'd': KeyedList({\n                    'e': 'nested keys'\n                })\n            }), \n           'a': 'some value'})\n\n\n# calling namespace APIS\n# notice the chaining in arguments\nresult = tcl.q.a.b.c()\n\n# calling with positional arguments\ntcl.q.testPositionalArgs(\"pos 1\", \"pos 2\", \"pos 3\")\n# {pos 1} {pos 2} {pos 3} \n\n# calling with kwargs: they get mapped to dashed args\ntcl.q.testDashedArgs(arg_a = 'a string', arg_b = 1, arg_c = 1)\n# -arg_a {a string} -arg_b 1 -arg_c 1\n\n# calling with mixed arguments\ntcl.q.testMixedargs('position 1', \n                    'position 2', \n                    arg_a = 'a string', arg_b = 1, arg_c = 1)\n# {position 1} {position 2} {-arg_b 1 -arg_c true -arg_a {a string}}\n```\n\n----------------------------------------\n\nTITLE: Creating Local Tcl Interpreter Instances with pyATS in Python\nDESCRIPTION: This snippet demonstrates how to import and instantiate a local Interpreter object from pyATS, enabling independent Tcl interpreters per instance. It shows how to execute Tcl 'eval' commands, retrieve environment variables, and call Tcl procedures within this isolated interpreter. Users must import Interpreter from pyats.tcl and create an instance to make Tcl calls. Each instance manages its own Tcl environment, variables, and procedure namespaces independently of others.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/tcl/tcl.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.tcl import Interpreter\n\ntcl = Interpreter()\n\nats_tcl_tree_path = tcl.eval('set ::env(AUTOTEST)')\n\n# getting tcl version\ntcl.eval('info patchlevel')\n```\n\n----------------------------------------\n\nTITLE: Installing pyATS Upgrade Command\nDESCRIPTION: Command to upgrade pyATS to the latest version using pip. This is the recommended method for users upgrading from v2.0.1+.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2016/february.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: TestScript Class Attributes and Properties\nDESCRIPTION: Provides an ASCII table outlining the key attributes (module, source) and properties (uid, description, result, parameters) of the `aetest` `TestScript` class, which serves as the top-level container for a test execution.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/objects.rst#_snippet_1\n\nLANGUAGE: Text\nCODE:\n```\n+--------------------------------------------------------------------------+\n| TestScript (base cls: TestItem)                                          |\n+==========================================================================+\n| attribute       | description                                            |\n|-----------------+--------------------------------------------------------|\n| module          | testscript module object                               |\n| source          | full path/name of the testscript file                  |\n+==========================================================================+\n| properties      | description                                            |\n|-----------------+--------------------------------------------------------|\n| uid             | name of the testscript                                 |\n| description     | testscript header (module docstring)                   |\n| result          | rolled-up result of entire testscript                  |\n| parameters      | dictionary of parameters relative to this testscript   |\n+--------------------------------------------------------------------------+\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyATS Core Framework Using pip - Bash\nDESCRIPTION: This Bash snippet upgrades the core pyATS package (ats) to the latest version available via pip. It requires pip to be installed and accessible on the system. Users should execute the command in a terminal or shell; it will download and install the latest release of 'ats', resolving dependencies as needed. Input: None. Output: Package installation/upgrade logs from pip. Limitations: Requires network access and the correct Python environment.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2016/november.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# install new pyATS version\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Creating pyATS Project via Interactive Prompts - Bash\nDESCRIPTION: Demonstrates how to create a pyATS project interactively by running 'pyats create project' with no arguments. The CLI prompts the user for a project name, testcase names, and datafile settings, then generates the folder and template files accordingly. Output includes a directory listing to show the generated project structure. Requires that all dependencies are installed, particularly the optional '[template]' extra package.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/cli/pyats_create.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# Example\n# -------\n#\n#   creating a pyats project by entering everything through the prompts\n\nbash$ pyats create project\nProject Name: test_project\nTestcase names [enter to finish]:\n  1. testcase_one\n  2. testcase_two\n  3.\nWill you be using testcase datafiles [Y/n]: y\nGenerating your project...\n\n# this will create a new folder with your provided project name, containing\n# the template files\n\nbash $ tree test_project/\ntest_project/\n|--  test_project.py\n|--  test_project_data.yaml\n`--  test_project_job.py\n```\n\n----------------------------------------\n\nTITLE: Checking Available Disk Space with FileUtils in Python\nDESCRIPTION: Example showing how to check available disk space at a target directory location on a remote server using the getspace method. Returns space in bytes.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/file_transfer_utilities.rst#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.utils.fileutils import FileUtils\nwith FileUtils(testbed=tb) as futils:\n    futils.getspace(\"sftp://server.domain.com/path/to/\")\n\n29832314880\n```\n\n----------------------------------------\n\nTITLE: Deleting Remote Files with FileUtils in Python\nDESCRIPTION: Example demonstrating how to delete a file on a remote server using the deletefile method. This operation is supported by FTP and SFTP protocols.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/file_transfer_utilities.rst#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.utils.fileutils import FileUtils\nwith FileUtils(testbed=tb) as futils:\n    futils.deletefile(\"sftp://server.domain.com/path/to/file\")\n```\n\n----------------------------------------\n\nTITLE: Creating a title message with pyATS\nDESCRIPTION: This example demonstrates how to create a title message using the `pyats.log.utils.title` function. It shows how to print the title directly to the console and how to log it using the standard Python logging module. The width and margin of the title are also customized.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/log/utilities.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.log.utils import title\n\n# printing directly\nmsg = title('a title message')\nprint(msg)\nprint(title('aReallyLongMessageThatIsLongerThanMaxWidthIsChoppedUp',\n             width = 38))\n\n# printing to log\nimport logging\nlogger = logging.getLogger(__name__)\n\nlogger.info(title('an informational message title'))\nlogger.error(title('an error message\\nwith newline'))\n\n# Changing margin\nmsg = title('a message', margin='!')\nprint(msg)\n```\n\n----------------------------------------\n\nTITLE: Multiple Connection Instance Example with pyATS\nDESCRIPTION: This example demonstrates how to establish and manage multiple connection instances to a device using pyATS. It covers defining multiple connections in the testbed, connecting to them using unique aliases, executing commands on each connection, and disconnecting them individually or all at once.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/connections/integration.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   multiple connection instance example \n\n# following the example above, let's make the testbed\n# connection description slightly more complicated\n# (edit this to whatever your testbed looks like)\ntestbed = topology.loader.load('''\ntestbed:\n    name: my-inline-testbed\n\ndevices:\n    tplana-hath:\n        type: iosxe\n        os: iosxe\n        connections:\n            a:\n                protocol: telnet\n                ip: 10.1.1.1\n                port: 10000\n            mgmt:\n                protocol: telnet\n                ip: 10.1.1.1\n                port: 20000\n''')\n\n# pick the device\ndevice = testbed.devices['tplana-hath']\n\n# make multiple connections to mgmt port (which accepts multi sessions)\n# each should be provided a unique alias and the exact path eg:\ndevice.connect(alias = 'vty_1', via = 'mgmt')\ndevice.connect(alias = 'vty_2', via = 'mgmt')\ndevice.connect(alias = 'vty_3', via = 'mgmt')\n\n# now we can use each instance independent of the others\nassert device.vty_1.connected\nassert device.vty_2.connected\nassert device.vty_3.connected\n\n# each instance has its own services\n# eg, configure different terminal width for each session\ndevice.vty_1.configure('terminal width 100')\ndevice.vty_2.configure('terminal width 200')\ndevice.vty_2.configure('terminal width 300')\n\n# disconnect each independently \ndevice.vty_1.disconnect()\ndevice.vty_2.disconnect()\ndevice.vty_3.disconnect()\n\n# or disconnect everything altogether\ndevice.disconnect_all()\n```\n\n----------------------------------------\n\nTITLE: Changing pyATS AEtest Logger Level - Python and Bash\nDESCRIPTION: Adjusts the verbosity level of the AEtest logger module by specifying standard logging levels such as DEBUG, INFO, or WARNING. Defaults to INFO. Input is a string log level; output affects log message filtering. Passed via command-line argument or API call.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/run.rst#_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\nbash$ python testscript.py -loglevel=DEBUG\n```\n\nLANGUAGE: python\nCODE:\n```\naetest.main('testscript.py', loglevel=\"DEBUG\")\n```\n\nLANGUAGE: python\nCODE:\n```\nrun(testscript = 'testscript.py', loglevel=\"WARNING\")\n```\n\n----------------------------------------\n\nTITLE: Creating and Managing Interface Objects in pyATS\nDESCRIPTION: Shows how to create Interface objects, associate them with devices and links, and set interface properties. The examples demonstrate the various ways to initialize and configure interfaces in the pyATS topology system.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/topology/concept.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   creating interface objects\n\nfrom pyats.topology import Device, Link\n# creating some objects to be used in demonstration\ndevice = Device('myDevice')\nlink = Link('newlink')\n\n# create a simple interface\ninterface_a = Interface('Ethernet1/1', type = 'ethernet')\n\n# create an interface that belongs to a device\ninterface_b = Interface('Ethernet1/1',\n                        type = 'ethernet',\n                        device = device)\n\n# create another interface that belongs to another device\n# and also connected to a link\ninterface_c = Interface('Ethernet2/1',\n                        type = 'ethernet',\n                        alias = 'myinterface',\n                        link = link,\n                        device = device)\n\n# manually connecting a link to an interface\ninterface_b.link = link\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyATS Packages with pip (May 26, 2020)\nDESCRIPTION: This snippet provides instructions for upgrading pyATS packages using pip. It includes separate commands for DevNet Community users and Cisco internal developers to upgrade their pyATS installations to the latest version.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2020/may.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats\n\n# Cisco Internal Developers\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Configuring logging with Handlers in pyATS (from scratch)\nDESCRIPTION: This snippet illustrates how to configure logging from scratch using custom handlers in a standalone script, particularly for when not running in an EasyPy environment. It imports `ScreenHandler` and `TaskLogHandler` from `pyats.log`. It creates a logger, screen and tasklog handlers, attaches the handlers to the logger, and sets the log level to debug. The output goes to the screen and a specified log file.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/log/examples.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport logging\n\nfrom pyats.log import ScreenHandler, TaskLogHandler\n\n# create a logger\nlogger = logging.getLogger(__name__)\n\n# creating a handler\nscreen_handler = ScreenHandler()\ntasklog_handler = TaskLogHandler('/path/to/logfile.txt')\n\n# attach to your logger\nlogger.addHandler(screen_handler)\nlogger.addHandler(tasklog_handler)\n\n# set log level to show everything\nlogger.setLevel(logging.DEBUG)\n```\n\n----------------------------------------\n\nTITLE: Evaluating Logic Operators with List Inputs in pyATS (Python)\nDESCRIPTION: Demonstrates how the logic operator classes And and Not evaluate multiple arguments or list-type inputs by applying predicates or regexes to each. For And and Or, logic is applied as a logical OR among input arguments, while for Not every argument must not match to return True (logical AND). Shows how behavior changes when input is a list or variadic arguments. Prerequisites: logic module, inputs must be compatible with underlying predicates or regexes. Outputs are boolean values reflecting logical composition. Limitation: for Not, all arguments must be non-matching; for And/Or, at least one argument must match.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/datastructures/logic.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   operators and list inputs\n\nfrom pyats.datastructures.logic import And, Not, Or\n\ntest_expr = And(lambda x: bool(x), lambda y: isinstance(y, int))\ntest_not_expr = Not(\"^bgp.*\", \"sanity$\")\n\n# do some testing\n# ---------------\ntest_expr(0, 1)\nTrue\n\ntest_expr(0, None)\nFalse\n\ntest_not_expr(\"bgp_sanity\", \"routing_regression\")\nFalse\n\ntest_not_expr(\"ospf_regression\", \"routing_regression\")\nTrue\n\n# consider this as logical OR between the input lists for truth testing:\n# test_expr(0, None) is interpretered as:\n# test_expr(0) or test_expr(None)\n#\n# note that in the case of Not(), this is a logical AND\n# test_not_expr(0, 1) is the same as:\n# test_not_expr(0) and test_not_expr(1)\n\n```\n\n----------------------------------------\n\nTITLE: Defining Script Arguments - Python\nDESCRIPTION: This code explains how script arguments are handled in pyATS. It demonstrates that arguments passed to the test script at startup become part of the `TestScript` parameters. It creates a `testscript.parameters` by combining base parameters defined in script and adding/overwriting them with script arguments, allowing for dynamic test behavior.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/parameters.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nscript_arguments = {\n        'arg_a': 100,\n        'arg_c': 3,\n    }\n\n    # and that the script file has the following parameters defined\n    parameters = {\n        'arg_a': 1,\n        'arg_b': 2,\n    }\n\n    # the TestScript parameter would be built as follows\n    testscript.parameters = parameters\n    testscript.parameters.update(script_arguments)\n\n    # the resulting values\n    testscript.parameters\n```\n\n----------------------------------------\n\nTITLE: Invoking Basic Parallel Function Calls with pcall in Python\nDESCRIPTION: Demonstrates a simple usage of pyats.async_.pcall to execute the 'add' function in parallel with different sets of arguments (1+4, 2+5, 3+6). Requires importing pcall and defining the target function. Variable keyword arguments (`x`, `y`) provide the iterables for parallel execution, and results are returned as a tuple in the order of the input arguments.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/async/pcall.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   a simple parallel call\n\n# import pcall\nfrom pyats.async_ import pcall\n\n# define a function to be called in parallel\ndef add(x, y):\n    return x + y\n\n# invoke parallel calling of the above function\n# to calculate 1 + 4, 2 + 5, 3 + 6\nresult = pcall(add, x = (1, 2, 3), y = (4, 5, 6))\n# (5, 7, 9)\n```\n\n----------------------------------------\n\nTITLE: Accessing Device Connection Manager\nDESCRIPTION: This snippet demonstrates how to access a device's connection manager and verify its type. It showcases that each device instance has its unique connection manager.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/connections/manager.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndevice\n# <Device phoenix at 0xf7714c0c>\n\n# it always features its own connection manager\ndevice.connectionmgr\n# <pyats.connections.ConnectionManager object at 0xf76f1c4c>\n```\n\n----------------------------------------\n\nTITLE: Python Job File Example for Rerun\nDESCRIPTION: Demonstrates the structure of a Python job file used in pyATS for test execution, suitable for rerunning tests. The `main` function imports `run` from `pyats.easypy`, determines the test script's location, and then executes the test script using `run()` with the `runtime` context.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/easypy/rerun.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport os\nfrom pyats.easypy import run\n\n# All run() must be inside a main function\ndef main(runtime):\n    # Find the location of the script in relation to the job file\n    test_path = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\n    testscript = os.path.join(test_path, 'basic_example_script.py')\n\n    # Execute the testscript\n    run(testscript=testscript, runtime = runtime)\n    run(testscript=testscript, runtime = runtime)\n```\n\n----------------------------------------\n\nTITLE: Running Robot Scripts Directly via pyats run robot CLI in Bash\nDESCRIPTION: Bash command demonstrating the `pyats run robot` shortcut to execute a single Robot Framework script directly within the Easypy environment without an explicit job file. It takes the path to the `.robot` file and other standard `pyats run` arguments like `--testbed-file`.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/robot/easypy.rst#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n# Example\n# -------\n#\n#   running a robot file directly in Easypy environment\n\nbash$ pyats run robot /path/to/my_robot_script.robot --testbed-file /path/to/tb.yaml\n```\n\n----------------------------------------\n\nTITLE: Documenting pyats.utils.fileutils.core.plugin_manager\nDESCRIPTION: This reStructuredText snippet uses the automodule directive to document the `pyats.utils.fileutils.core.plugin_manager` submodule. It includes all members, undocumented members, and displays the inheritance hierarchy.  This aids in understanding the structure and functionality of the plugin management aspects within the file utilities.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/apidoc/utils/pyats.utils.fileutils.core.rst#_snippet_1\n\nLANGUAGE: reStructuredText\nCODE:\n```\n\n.. automodule:: pyats.utils.fileutils.core.plugin_manager\n   :members:\n   :undoc-members:\n   :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyATS and Reporter via pip for DevNet and Cisco Developers - Bash\nDESCRIPTION: These bash shell snippets demonstrate how both DevNet Community members and Cisco Internal Developers can upgrade the pyATS and pyATS Reporter Python packages to the latest versions via pip. Users should have pip installed and be in an environment where either 'pyats' or 'ats' and their respective plugins are available. For Cisco internal users, alternate package names ('ats') are required. No input/output beyond command-line feedback of pip is expected. There are no special constraints except needing network access to the appropriate package repository.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2020/feb.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats\nbash$ pip install --upgrade pyats.reporter\n\n# Cisco Internal Developers\nbash$ pip install --upgrade ats\nbash$ pip install --upgrade ats.reporter\n```\n\n----------------------------------------\n\nTITLE: pyATS Validate Testbed Usage\nDESCRIPTION: This shows how to use the `pyats validate testbed` subcommand. It is used to validate the content of a testbed YAML file for syntax and content completeness.  It also allows checking device connections and skipping linting.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/cli/pyats_validate.rst#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nUsage:\n  pyats validate testbed [file] [options]\n\nDescription:\n  Validates the provided testbed YAML file for syntax and content completeness.\n\nTestbed Options:\n  [file]                Testbed YAML file to validate\n  --connect             Test each device's connections\n  --no-lint             Do not lint the testbed YAML file\n```\n\n----------------------------------------\n\nTITLE: Launching AEtest scripts interactively using pyATS main() in Python shell\nDESCRIPTION: Illustrates launching AEtest test scripts from a Python interactive shell by importing aetest.main and specifying the testable script to run. This snippet shows how to invoke AEtest execution programmatically without command line invocation, facilitating interactive debugging and testing. The user provides the path to the test script as the testable argument. This requires pyATS installation and the specified script to be compatible with AEtest.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/run.rst#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n>>> from pyats.aetest import main\n>>> main(testable = '/path/to/your/script.py')\n```\n\n----------------------------------------\n\nTITLE: Creating FileUtils Instance from Device in Python\nDESCRIPTION: Example showing how to create a FileUtils instance from a device object, typically used to access client-side file utilities on a non-Linux host.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/file_transfer_utilities.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfutils = FileUtils.from_device(device=testbed.devices['my_xyz_device'])\n```\n\n----------------------------------------\n\nTITLE: Installing pyats.connections using pip\nDESCRIPTION: Installs the pyats.connections module, which is part of the pyATS framework, using the pip package manager. This module is a prerequisite for the topology module.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/connections/introduction.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install pyats.connections\n```\n\n----------------------------------------\n\nTITLE: Device Clean Configuration Example in YAML\nDESCRIPTION: Example showing device cleaning configuration with an image directory, include/exclude patterns, custom configuration, and timeout settings. This demonstrates how to specify image sources with filtering patterns.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/kleenex/inputs.rst#_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\nbase_dir:  sftp://img_svr.domain.com/path/to/device/images/\n           # Is dir due to trailing slash.\n           # It is ignored if there is not at least one\n           # <role_name>/include pattern specified.\n           cardinality: 1\nrp:\n    include: r\\d+\\.\\d\\.\\d\\.bin\n    exclude: file_pat_to_exclude\n\n# Static clean information may also be specified in the clean file\n# instead of only the testbed file.  Note how the markup refers\n# to content in the testbed file's block for this device.\napply_configuration:\n    configuration: |\n        switchname another-example-device\n        username admin password cisco123\n        no password strength-check\n        interface mgmt0\n            ip address %{testbed.self.clean.mgt_itf.ipv4.address} %{testbed.self.clean.mgt_itf.ipv4.net.mask}\n            no shutdown\n        vrf context management\n            ip route 0.0.0.0/0 1.1.1.1\n        feature telnet\n\nawesomeclean:\n    check_image_md5: True\n\ntimeout: 900\n```\n\n----------------------------------------\n\nTITLE: Creating and Manipulating Link Objects - Python\nDESCRIPTION: This Python snippet demonstrates creating and manipulating Link objects within the pyATS framework.  It imports the necessary classes, creates Interface objects, creates Link objects (both empty and pre-populated), adds interfaces to links, checks if an interface is connected, and iterates through the interfaces of a link. It requires the pyats.topology module and initialized Interface objects.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/topology/concept.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.topology import Interface, Link\n# creating some objects to be used in demonstration\ninterface_a = Interface('Ethernet1/1', type = 'ethernet')\ninterface_b = Interface('Ethernet2/1', type = 'ethernet')\ninterface_c = Interface('Ethernet2/1', type = 'ethernet')\n\n# creating an empty link\nlink_a = Link('emptyLink')\n\n# creating a link with a few interface\nlink_b = Link('newLink',\n                  alias = 'myLink',\n                  interfaces = [interface_a, interface_b])\n\n# adding interfaces to links\nlink_b.connect_interface(interface_c)\n\n# check whether an interface obj is connected to a link\n# using the 'in' operator\nassert interface_c in link_b\n\n# loop through interfaces\nfor intf in link_b:\n    print(intf.name)\n```\n\n----------------------------------------\n\nTITLE: Calling Wrapped Service Method in Python\nDESCRIPTION: Defines the call_service method to invoke the wrapped service multiple times with given arguments, collecting outputs and logging exceptions. This method returns a list of results and handles exceptions internally by logging them. It depends on a logger for exception logging and assumes self.service is the callable service method. Inputs are arbitrary positional and keyword arguments for the wrapped service; output is a list of returned values from multiple calls.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/connections/wrapper.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef call_service(self, *args, **kwargs) -> Any:\n    \"\"\"Call the service three times\"\"\"\n    ret_list = []\n    for _ in range(3):\n        try:\n            ret_list.append(self.service(*args, **kwargs))\n        except Exception as e:\n            logger.exception(f\"Exception occurred: {e}\")\n    return ret_list\n```\n\n----------------------------------------\n\nTITLE: Using Global pyATS Tcl Interpreter Instance for Tcl Calls in Python\nDESCRIPTION: This snippet describes how to use the global Interpreter instance embedded in the pyats.tcl module, which eliminates the need to instantiate Interpreter objects explicitly. The global instance maintains a single Tcl interpreter throughout the Python process, ensuring consistent namespace and loaded libraries. Code shows importing pyats.tcl and making Tcl calls via the module's eval method. Assertions verify that the module is also an Interpreter instance and that multiple imports return the same object reference.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/tcl/tcl.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats import tcl\n\ntcl.eval('set myVar 1')\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats import tcl\n\nassert isinstance(tcl, tcl.Interpreter)\n\nimport pyats.tcl\nassert pyats.tcl is tcl\nassert id(pyats.tcl) == id(tcl)\n```\n\n----------------------------------------\n\nTITLE: Enabling Processor Reporting in Configuration\nDESCRIPTION: This snippet demonstrates how to enable processor reporting in the PyATS configuration file (pyats.conf). The configuration setting 'processors.report = True' is used to specify whether to report processor output in the log viewer. This replaces the `aereport.processors` option.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2020/aug.rst#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n[aetest]\nprocessors.report = True\n```\n\n----------------------------------------\n\nTITLE: Using clean-group-image Parameter in pyATS\nDESCRIPTION: Shows how to use the --clean-group-image parameter to specify images for cleaning based on device groups. This command allows targeting specific groups of devices for image cleaning operations.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/kleenex/usages.rst#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pyats run job jobfile.py --testbed-file /path/to/my/testbed.yaml\\\n                                   --clean-file /path/to/my/clean.yaml\n                                   --invoke-clean\n                                   --clean-group-image group1:/path/to/clean_image.bin\n```\n\n----------------------------------------\n\nTITLE: Using clean-os-image Parameter in pyATS\nDESCRIPTION: Demonstrates how to use the --clean-os-image parameter to specify images for cleaning based on OS type. This command requires a testbed file, clean file, and invokes the clean operation with a specific image path for an OS type.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/kleenex/usages.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pyats run job jobfile.py --testbed-file /path/to/my/testbed.yaml\\\n                                   --clean-file /path/to/my/clean.yaml\n                                   --invoke-clean\n                                   --clean-os-image iosxe:/path/to/clean_image.bin\n```\n\n----------------------------------------\n\nTITLE: Default pyATS Easypy User Directory Structure (Text)\nDESCRIPTION: This text block outlines the default directory structure created by pyATS Easypy within the 'users/' directory under the pyATS root (<pyats_root>). It shows the per-user folders (<userid>) containing 'runinfo' (runtime logs and artifacts), 'archive' (past run log archives), 'jobs' (user-specific job file storage), and 'etc' (other user-specific files). This structure facilitates multi-user environments on a single pyATS instance.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/easypy/behavior.rst#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\n# Easypy Users Directory Strcture\n# -------------------------------\n\n<pyats_root>\n|\n|-- users\n.   |-- <userid>\n    .   |-- runinfo              -> runtime/runinfo folder\n        |-- archive              -> past run log archives\n        |-- jobs                 -> user specific job file storage\n        `-- etc                  -> anything else\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Discovery Classes with Python Inheritance\nDESCRIPTION: This snippet provides examples of how to define custom discovery classes by subclassing ScriptDiscovery, TestcaseDiscovery, and CommonDiscovery in Python. Each class demonstrates a custom discover method, specifying which test sections or cases to return for test execution. Dependencies include pyATS AEtest library and its discovery classes. Expected input is a valid test script object structure; outputs are lists of discoverable test sections. The approach can be extended for project-specific test granularity.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/control.rst#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nclass MyCustomScriptDiscovery(ScriptDiscovery):\n    def discover(self):\n        # some logic\n        return [self.target.module.tc_one, self.target.module.common_cleanup]\n\nclass MyCustomTestcaseDiscovery(TestcaseDiscovery):\n    def discover(self):\n        #some logic\n        return [self.target.my_section1]\n\nclass MyCustomCommonDiscovery(CommonDiscovery):\n    def discover(self):\n        # some logic\n        return [self.target.subsection1]\n```\n\n----------------------------------------\n\nTITLE: Renaming Remote Files with FileUtils in Python\nDESCRIPTION: Example demonstrating how to rename a file on a remote server using the renamefile method. Requires specifying both source and destination URLs.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/file_transfer_utilities.rst#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.utils.fileutils import FileUtils\nwith FileUtils(testbed=tb) as futils:\n    futils.renamefile(\n        source = 'ftp://myserver.domain.com/remote/path/to/file',\n        destination = 'ftp://myserver.domain.com/remote/path/to/renamed_file')\n```\n\n----------------------------------------\n\nTITLE: Schema Definition for Retry Settings in Configuration Files\nDESCRIPTION: Provides a Python dictionary schema for YAML/JSON retry configurations, allowing specification of sections, section results, testcases with retries and wait times, and overall retries. Values are case-insensitive to improve flexibility.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/retry.rst#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\n    {\n        Optional('sections'): list, # sections that needs to be retried. Eg  - Testcase, Subsection, Setupsection, Cleanupsection, Testsection\n        Optional('section_results'): list, # section that needs to be retried based on its results. Eg Failed, Errored. Default: Failed\n        Optional('testcases'): { # aetest testcases\n            Any(): { # section name\n                Optional('retries'): Default(int, 3), # number of retries\n                Optional('retry_wait'): Default(int, 10), # retry delay between each retry\n            }\n        },\n        'retries': Default(int, 3),\n        'retry_wait': Default(int, 10),\n    }\n```\n\n----------------------------------------\n\nTITLE: Registering pyATS Service Wrapper as a Package Entry Point - Python\nDESCRIPTION: Illustrates how to declare a pyATS service wrapper as a package entry point using setuptools' 'setup' function. The 'entry_points' argument includes the 'pyats.connections.wrapper' descriptor with a mapping from the wrapper name to its Python import path. Prerequisites are setuptools and the implemented wrapper class. This enables pyATS to discover and integrate the service wrapper automatically upon package installation.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/connections/wrapper.rst#_snippet_11\n\nLANGUAGE: Python\nCODE:\n```\nsetup(\n  ...,\n\n  # console entry point\n  entry_points = {\n      'pyats.connections.wrapper': [\n          'example_wrapper = path.to.path:ExampleWrapper'\n        ]\n    }\n)\n```\n\n----------------------------------------\n\nTITLE: Example Robot Framework Test Script\nDESCRIPTION: A sample Robot Framework script (`hello_world.robot`) used to illustrate integration with Easypy. It defines several test cases that call keywords from an external Python library (`hello_world.py`) to demonstrate different outcomes like pass, fail, logging, and checking for the testbed.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/robot/easypy.rst#_snippet_4\n\nLANGUAGE: robotframework\nCODE:\n```\n*** Settings ***\nLibrary         hello_world.py\n\n*** Test Cases ***\nShould Pass\n    Hello World\n\nShould Fail\n    Raise Exception\n\nLogging Test\n    Do Logging\n\nCheck Testbed Provided\n    Check Testbed\n```\n\n----------------------------------------\n\nTITLE: Custom pyATS Service Wrapper Implementation with Step-Based Reporting - Python\nDESCRIPTION: Defines an example subclass of the ServiceWrapper base class, implementing pre_service, post_service, call_service, and exception_service methods with step-based context reporting. Each method utilizes the 'steps.start' context to log successful execution of distinct wrapper phases. This approach requires the pyats.connections.ServiceWrapper base and a Testcase context for the 'steps' argument. The snippet demonstrates comprehensive integration of step reporting for all stages of service invocation.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/connections/wrapper.rst#_snippet_9\n\nLANGUAGE: Python\nCODE:\n```\nfrom pyats.connections import ServiceWrapper\n\nclass ExampleWrapper(ServiceWrapper):\n    @classmethod\n    def applicable(cls, connection, *args, **kwargs) -> bool:\n        return True\n\n    def pre_service(self, steps, *args, **kwargs) -> None:\n        with steps.start('Pre Service Step') as step:\n            step.passed('Sucessfully ran pre service step')\n\n    def post_service(self, output, steps, *args, **kwargs) -> None:\n        with steps.start('Post Service Step') as step:\n            step.passed('Sucessfully ran post service step')\n\n    def call_service(self, steps, *args, **kwargs) -> None:\n        with steps.start('Call Service Step') as step:\n            step.passed('Sucessfully ran call service step')\n\n    def exception_service(self, e, steps, *args, **kwargs) -> None:\n        with steps.start('Exception Service Step') as step:\n            step.passed('Sucessfully ran exception service step')\n```\n\n----------------------------------------\n\nTITLE: Demonstrating pyATS TaskLogHandler Multiprocessing Integration in Python\nDESCRIPTION: Example showing how to configure pyATS logging to use the managed TaskLogHandler to support automatic logging during multiprocessing. The snippet sets the root logger's level, attaches the managed tasklog handler, changes the log output file, and enables the handler's process awareness with enableForked(). It illustrates how child processes automatically write to their own log files with process ID postfixes, enhancing log separation and traceability in concurrent executions. Dependencies include pyATS logging framework and Python's standard logging and multiprocessing modules.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/log/integration.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport logging\nimport multiprocessing\n\nfrom pyats import log\n\nlogger = logging.getLogger()\nlogger.setLevel(logging.INFO)\n\n# attach managed_handler to logger\nlogger.addHandler(log.managed_handlers.tasklog)\n\n# change tasklog to a meaninful file & enable forking behavior\nlog.managed_handlers.tasklog.changeFile('/tmp/logfile.txt')\n\n# now all log messages go into /tmp/logfile.txt\nlogging.info('this is an informational message')\n\n# now let's define a function to be called in a child process\n# and print some log messages\ndef func():\n    logger.info('this is a message in child process')\n\n# turn on enableForked()\nlog.managed_handlers.tasklog.enableForked()\n\n# call the function using multiprocessing fork\nmultiprocessing.Process(target = func).start()\n```\n\n----------------------------------------\n\nTITLE: Disabling Easypy plugins at runtime (Python)\nDESCRIPTION: This code snippet illustrates how to disable a loaded Easypy plugin during runtime by setting its `enabled` attribute to `False`. This allows preventing a plugin from running again after it has already been loaded, providing a dynamic way to control plugin execution.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/easypy/plugins.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n    # Example\n    # -------\n    #\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyats using pip (Cisco Internal)\nDESCRIPTION: This code snippet demonstrates how to upgrade the pyats package using pip for Cisco Internal Developers. It uses the `pip install --upgrade ats` command to update to the latest available version of the ats package, which is an internal alias for pyats.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2024/july.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Syntax of Logic Operator Class Application (Python)\nDESCRIPTION: Provides a concise reference for the syntax of And, Or, and Not logic operator class instantiation and evaluation with multiple expressions in the pyATS logic module. Showcases typical usage patterns for constructing compound Boolean logic expressions. There are no dependencies aside from the logic module. Expressions can be callables or regex strings; outputs are boolean results. Limitations: only expressions conforming to the expected callable or regex interface are supported.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/datastructures/logic.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nAnd(*expressions):\n\n    expression_1(inputs) and expression_2(inputs)  and ...\n\nOr(*expressions):\n\n    expression_1(inputs) or expression_2(inputs) or ...\n\nNot(*expressions):\n    \n    not expression_1(inputs) and not expression_2(inputs) and not ...\n\n```\n\n----------------------------------------\n\nTITLE: Defining Testscript and Testcase Parameters in aetest\nDESCRIPTION: This example shows how to define default parameters at the testscript and testcase levels in aetest.  A dictionary named `parameters` is used to define the parameters. This sets the baseline for the `parameters` property of corresponding section objects.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/parameters.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   an aetest testscript with lots of parameters pre-defined\n#   (pre-definition: defining parameters within the script directly)\n\nfrom pyats import aetest\n\n# testscript level default parameters can be defined by\n# setting a dictionary within your testscript named \"parameters\"\n# (this is a reserved keyword)\nparameters = {\n    'testscript_param_A': 'some value',\n    'testscript_param_B': [],\n    'generic_param_A': 100\n}\n\n# using Testcase to demonstrate TestContainer-type parameters definitions\n# note that this also is applicable to CommonSetup & CommonCleanup\nclass Testcase(aetest.Testcase):\n\n    # all default parameters specific to this testcase is declared\n    # in its own parameters dictionary.\n    parameters = {\n        'generic_param_A': 200\n    }\n\n    # etc ...\n```\n\n----------------------------------------\n\nTITLE: Making AEReport API Calls for Test Reporting in Python\nDESCRIPTION: Shows a sequence of `AEClient` method calls in Python to structure a test report as part of the AEReport tutorial. It demonstrates starting/stopping various contexts (testsuite, jobexecution, testscript, testcase), adding metadata (`add_ats_packages`), specifying log file paths for contexts, setting results (`set_result`), and finally stopping the contexts in reverse order.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aereport/index.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> clt.start_testsuite(**{'jobname':'job1',\n>>>                            'submitter':'aUser'})\n>>> clt.add_ats_packages(packages=[('Csccon', '1.1'), ('aetest', '1.2')])\n>>> clt.start_jobexecution()\n>>> clt.start_testscript(logfilepath='/tmp/logfile.log')\n>>> clt.start_testcase (tcid='some_tc_id2',\n>>>                              logfilepath='/tmp/logfile.log',\n>>>                              comment='starting our beautiful testcase2')\n>>> clt.set_result(result={'mode':'override','value':'failed'})\n>>> clt.stop_testcase()\n>>> clt.stop_testscript()\n>>> clt.stop_jobexecution()\n>>> clt.stop_testsuite()\n```\n\n----------------------------------------\n\nTITLE: Running pyATS Test Scripts on Multiple Testbeds in Parallel (Python)\nDESCRIPTION: This Python example demonstrates how to run a single test script against multiple, distinct testbeds concurrently using pyATS Easypy. It involves manually loading testbed files using 'pyats.topology.loader.load()', creating separate 'Task' instances for each testbed, and explicitly passing the loaded 'testbed' object and 'runtime' object to each task's constructor. The tasks are then started ('task.start()') and awaited ('task.wait()') for parallel execution, overriding the default single testbed provided via '--testbed-file'.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/easypy/behavior.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   a jobfile that runs a script on 3 separate testbeds in parallel\n#   (cannot be done with --testbed-file argument)\n\nfrom pyats.easypy import run, Task\n\n# import topology module\nfrom pyats import topology\n\n# manually load your testbed files\ntestbed_1 = topology.loader.load('/path/to/testbed_1.yaml')\ntestbed_2 = topology.loader.load('/path/to/testbed_2.yaml')\ntestbed_3 = topology.loader.load('/path/to/testbed_3.yaml')\n\ndef main(runtime):\n\n    # create the tasks and manually provide a testbed to run on.\n    task_1 = Task(testscript = '/path/to/my/testscript.py',\n                   runtime = runtime,\n                   testbed = testbed_1)\n    task_2 = Task(testscript = '/path/to/my/testscript.py',\n                   runtime = runtime,\n                   testbed = testbed_2)\n    task_3 = Task(testscript = '/path/to/my/testscript.py',\n                   runtime = runtime,\n                   testbed = testbed_3)\n\n    # now start all tasks in parallel\n    task_1.start()\n    task_2.start()\n    task_3.start()\n\n\n    # wait for all tasks to finish\n    task_1.wait()\n    task_2.wait()\n    task_3.wait()\n```\n\n----------------------------------------\n\nTITLE: Initializing a pyATS Test Bench with Interactive Prompt (Python)\nDESCRIPTION: This snippet demonstrates setting up a reusable Python test bench template for pyATS development. It imports necessary packages, provides placeholders for test case or API development, and establishes a main execution block. Key dependencies are Python (>=3.8), pyATS, and optionally IPython for the interactive shell. The main routine sets up the testing environment, allows the user to enter an interactive session (via IPython or alternatives), and performs cleanup. Expects a suitable testing environment, and proper device setup if connecting to real hardware.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/resources/testbench.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   example test bench (testbench.py)\n\n#! /bin/env python\n\n# import any modules/libraries/packages & etc\nimport sys\n# ...\n\n# code here\n# --------------------------------------------------------------------------\n# \n#   develop your test case, library apis & etc here.\n\n# ...\n\n# main block to execute the above test code\n# --------------------------------------------------------------------------\nif __name__ == '__main__':\n\n    # setup test bench\n    # ----------------\n    #   setup your work environment, eg:\n    #       - load yaml\n    #       - connect to devices\n    #       - require necessary tcl packages\n    #       - etc\n\n    # ...\n\n    # go interactive\n    # --------------\n    #   note that there's a few ways to go into interactive:\n    #       - using IPython\n    #       - using pdb.set_trace()\n    #       - using code.interact()\n\n    # uncomment/pick one of these:\n    from IPython import embed; embed()\n    # import code; code.interact(local = locals())\n    # import pdb; pdb.set_trace()\n    # import ipdb; ipdb.set_trace()\n\n    # cleanup work bench\n    # ------------------\n    #   do any necessary cleaning, such as:\n    #       - remove lingering configurations\n    #       - disconnecting from tb devices\n    #       - etc\n\n    # ...\n\n    # exit script\n    # -----------\n    sys.exit()\n\n\n    # any code from here onwards is just for your copy/paste purposes\n    # ---------------------------------------------------------------\n    #   use this space for anything you'd do to copy/paste into your\n    #   interactive prompt. \n\n    # ...\n\n```\n\n----------------------------------------\n\nTITLE: Adding features to result code objects including .tims and sum support\nDESCRIPTION: This snippet highlights extended capabilities of result code objects, including returning ``.tims`` result codes, supporting summation for result aggregation, and ensuring that a rollup with any ``Aborted`` status yields ``Aborted``. These changes facilitate efficient result processing and reporting within the test framework.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2015/june.rst#_snippet_18\n\nLANGUAGE: Python\nCODE:\n```\nresult code object supports ``.tims`` and sum() operations. ``Aborted`` status takes precedence in rollups.\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyATS Framework via pip - bash\nDESCRIPTION: Provides pip commands to upgrade the core pyATS framework (`pyats`) for the DevNet community and the internal Cisco `ats` package for Cisco internal developers. Requires pip to be installed and configured to access the appropriate package repositories.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2019/aug.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats\n```\n\nLANGUAGE: bash\nCODE:\n```\n# Cisco Internal Developers\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Setting/Getting Tcl Variables with eval and manual cast (Python)\nDESCRIPTION: Demonstrates the traditional method of interacting with Tcl variables using `tcl.eval` to execute Tcl `set` commands. Shows how to retrieve the string value returned by Tcl and then manually typecast it to a Python integer using built-in Python functions. Requires the `pyats.tcl` library.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/tcl/variables.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n# \n#   setting & getting variables with Tcl and typecasting them.\n\nfrom pyats import tcl\n\n# setting variables\ntcl.eval('set myVar 1')\n\n# getting variables\nvalue = tcl.eval('set myVar')\n\n# typecasting to int\nvalue = int(value)\n```\n\n----------------------------------------\n\nTITLE: Global Processors Declaration, Python\nDESCRIPTION: This code shows how to define and use global processors in a pyATS aetest script.  Global processors are defined in a dictionary called `global_processors` with 'pre', 'post', and 'exception' as keys. Each key contains a list of processor functions to run globally before, after, or on exception of each test section. Demonstrates defining functions and assigning them as global pre, post and exception processors.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/processors.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   script using global processors\n\nfrom pyats import aetest\n\n# define a function that prints the section's uid\ndef print_uid(section):\n    print('current section: ', section.uid)\n\n# define a function that prints the section result\ndef print_result(section):\n    print('section result: ', section.result)\n\n# define another function that prints the exception message and suppress the\n# exception\ndef print_exception_message(section, exc_type, exc_value, exc_traceback):\n    print('exception : ', exc_type, exc_value)\n    return True\n\n# use the above functions global pre/post processors\n#   global pre-processor  : print_uid\n#   global post-processor : print_result\n#   global exception-processor : print_exception_message\nglobal_processors = {\n    'pre': [print_uid,],\n    'post': [print_result,],\n    'exception': [print_exception_message,],\n}\n\nclass Testcase(aetest.Testcase):\n\n    @aetest.test\n    def test(self):\n        print('running testcase test section')\n\n    @aetest.test\n    def testException(self):\n        pyATS()\n```\n\n----------------------------------------\n\nTITLE: Running Kleenex Module in Decoupled Mode Using Bash\nDESCRIPTION: Demonstrates how to invoke the Kleenex module in decoupled mode using the pyATS command-line interface. This mode allows direct orchestration and cleaning of a testbed topology independently of any scripts. It is well suited for script development or manual testbed recovery. The command specifies the testbed YAML file and the clean configuration YAML file to use as inputs.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/kleenex/usages.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pyats clean --testbed-file physical_testbed.yaml --clean-file clean.yaml\n```\n\n----------------------------------------\n\nTITLE: Accessing and Modifying Python Arrays\nDESCRIPTION: This code continues from the previous example, demonstrating how to interact with a Python `Array` object. It shows how to check for the existence of keys, retrieve all keys, access array elements (which are strings), and add new elements. The `Array` object extends the Python dictionary, providing dictionary-like functionality. It explains how modifications to the Python array do not affect the Tcl source array and how the values remain in string format unless typecasted.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/tcl/datastructures.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# continuing from last code...\n\n# check that array contains index 'a'\nassert 'a' in array\n\n# check all array index are in the array\nassert set(['a','b','c']) == set(array.keys())\n\n# accessing the array\n# note that the value is still string - not typecasted\nassert array['a'] == '1'\n\n# adding more to the array\n# note that this only adds to the local variable\narray['zzz'] = 999\n```\n\n----------------------------------------\n\nTITLE: Assigning Interface to Device - Python\nDESCRIPTION: This snippet manually assigns an interface to a device in a pyATS testbed.  It utilizes the assignment operator to set the device property of an interface object.  This action implicitly calls the device.add_interface() method to maintain consistency. The primary dependency is the presence of initialized 'interface_a' and 'device' objects.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/topology/concept.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ninterface_a.device = device\n```\n\n----------------------------------------\n\nTITLE: Affixing pyATS Processors to Section - Python\nDESCRIPTION: Illustrates using `aetest.processors.affix()` to dynamically assign a new list of processors to a section, overwriting any previously defined processors of that type (context, pre, post, or exception). This allows changing processor lists at runtime.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/processors.rst#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats import aetest\n\n# testcase with two lambda functions as pre-processors (false)\n@aetest.processors.pre(lambda: False, lambda: False)\nclass Testcase(aetest.Testcase):\n    pass\n\n# replace the two functions to Testcase\naetest.processors.affix(Testcase, pre = [lambda: True, lambda: True])\n```\n\n----------------------------------------\n\nTITLE: Invoking Python Debugger on AEtest Failures - Python and Bash\nDESCRIPTION: Enables automatic entry into the Python debugger (pdb) when failures or errors occur during test execution. Useful for interactively inspecting failure causes. Input is a boolean flag; output triggers pdb on error states. Passed through command-line switches or API parameters. Requires Python environment supporting pdb.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/run.rst#_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\nbash$ python testscript.py -pdb\n```\n\nLANGUAGE: python\nCODE:\n```\naetest.main('testscript.py', pdb = True)\n```\n\nLANGUAGE: python\nCODE:\n```\nrun(testscript = 'testscript.py', pdb = True)\n```\n\n----------------------------------------\n\nTITLE: Configuring env.csh to Set pip Environment Variables in C-Shell\nDESCRIPTION: This snippet provides the commands to be appended to the env.csh file for c-shell users. The script sets environment variables to configure pip to use the custom ATS PyPI server and disables pip version checking, similar to the env.sh bash configuration. This adjustment is necessary for systems using c-shell where environment variables are set via 'setenv' commands.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2015/july.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# BEGIN CUSTOM pyATS CONTENT\nsetenv PIP_TRUSTED_HOST ats-pypi-server.cisco.com\nsetenv PIP_INDEX_URL http://ats-pypi-server.cisco.com/simple\nsetenv PIP_DISABLE_PIP_VERSION_CHECK 1\n```\n\n----------------------------------------\n\nTITLE: Command Usage Syntax for pyATS Shell\nDESCRIPTION: Displays the command-line syntax and options for the pyATS shell command that loads a testbed configuration into a Python interactive environment.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/cli/pyats_shell.rst#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nUsage:\n  pyats shell [options]\n\nDescription:\n  Enters typical python interactive shell, setting a global variable named\n  'testbed' which contains the loaded testbed YAML file\n\nShell Options:\n  --testbed-file FILE   testbed file to load\n  --no-ipython          do not use IPython\n```\n\n----------------------------------------\n\nTITLE: Declaring pyATS Test Execution Control API Functions in Python\nDESCRIPTION: These function definitions are part of the control surface for pyATS test automation. Each API method (e.g., set_result, set_attribute, set_runinfo, etc.) is designed to receive a dictionary of keyword arguments and apply relevant actions on the test execution context, such as recording results, setting attributes, controlling flow (pause/abort), and toggling run-time flags. The methods require a test context (typically as self) and support passing context-specific parameters via kwargs. Inputs are typically dictionaries with boolean, string, or structure values for detailed configuration.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aereport/index.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef set_result (self, kwargs):\ndef set_attribute (self, kwargs):\ndef set_runinfo (self, kwargs):\ndef set_initinfo (self, kwargs):\ndef set_ats (self, kwargs):\ndef add_ats_packages (self, kwargs):\ndef set_tims (self, kwargs):\ndef set_summary (self, kwargs):\n```\n\n----------------------------------------\n\nTITLE: pyATS 'pause_on' with Code Action Example\nDESCRIPTION: This Python code snippet demonstrates how to use the 'pause_on' feature within a pyATS test script, setting the action to 'code'. When the script encounters the specified pattern ('i should pause'), it will pause and open an interactive code shell, enabling debugging and inspection.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/debugging.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Example 1\n# ---------\n#\n#   pause on phrase with code action\n\nfrom pyats import aetest\n\nimport logging\n\nlogger = logging.getLogger()\n\nclass CommonSetup(aetest.CommonSetup):\n    @aetest.subsection\n    def subsection(self):\n        pass\n\nclass tc_one(aetest.Testcase):\n\n    @aetest.setup\n    def setup(self):\n        pass\n\n    @aetest.test\n    def test(self):\n        logger.info('i should pause')\n\n    @aetest.cleanup\n    def cleanup(self):\n        pass\n\nclass CommonCleanup(aetest.CommonCleanup):\n    @aetest.subsection\n    def subsection(self):\n        pass\n\nif __name__ == '__main__':\n    logging.root.setLevel(logging.INFO)\n    aetest.main(pause_on = dict(action = 'code',\n                                patterns = [{'pattern': 'i should pause'}]))\n```\n\n----------------------------------------\n\nTITLE: Configuring Sphinx Table of Contents for 2019 pyATS Documentation Archive\nDESCRIPTION: This reStructuredText snippet configures a Sphinx toctree directive to organize monthly documentation pages for the year 2019. The toctree is set to display with a maximum depth of 2 levels and includes links to documentation for each month of the year.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2019/index.rst#_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. toctree::\n    :maxdepth: 2\n\n    dec\n    nov\n    oct\n    sept\n    aug\n    july\n    june\n    may\n    apr\n    mar\n    jan\n```\n\n----------------------------------------\n\nTITLE: Python Script with Datafile Integration\nDESCRIPTION: This Python code defines a PyATS test script. It initializes module and class level variables.  It also defines a testcase and tests that use parameters passed from a datafile. It logs information about the script's execution and the data being used.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/datafile.rst#_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\n    # Example\n    # -------\n    #\n    #   short script designed to be run with a datafile\n    #   (notice many expected values/parameters undefined)\n\n    import logging\n\n    from pyats import aetest\n\n    logger = logging.getLogger(__name__)\n\n    # Initialize module level data variables,\n    # the values are set via the datafile.\n    module_var_a: None\n    module_var_b: None\n\n    class MyTestcase(aetest.Testcase):\n\n        # Initialize testcase class data variables,\n        # the values will be set via the datafile.\n        class_var_a: None\n        class_var_b: None\n\n        @aetest.test\n        def uid_and_groups(self):\n            logger.info('notice how testcase uid/groups are modified')\n            logger.info('  uid = %s' % self.uid)\n            logger.info('  groups = %s' % self.groups)\n\n        @aetest.test\n        def script_params(self, script_param_a, script_param_b):\n            logger.info('the following parameters are script-level')\n            logger.info('  script_param_a = %s' % script_param_a)\n            logger.info('  script_param_b = %s' % script_param_b)\n\n        @aetest.test\n        def testcase_params(self, tc_param_a, tc_param_b):\n            logger.info('the following parameters are local to this testcase')\n            logger.info('  tc_param_a = %s' % tc_param_a)\n            logger.info('  tc_param_b = %s' % tc_param_b)\n\n        @aetest.test\n        def module_variables(self):\n            logger.info('the following variables are defined at module level')\n            logger.info('  module_var_a = %s' % module_var_a)\n            logger.info('  module_var_b = %s' % module_var_b)\n\n        @aetest.test\n        def class_attributes(self):\n            logger.info('the following attributes are defined at class level')\n            logger.info('  class_var_a = %s' % self.class_var_a)\n            logger.info('  class_var_b = %s' % self.class_var_b)\n\n    if __name__ == '__main__':\n        aetest.main()\n```\n\n----------------------------------------\n\nTITLE: Setting/Getting Tcl Variables with dict interface and namespaces (Python)\nDESCRIPTION: Extends the use of the `tcl.vars` dictionary interface to access Tcl variables using full namespace qualifiers (e.g., `::aGlobalVar`). This demonstrates how to interact with variables defined in different Tcl namespaces or the global scope directly from Python. Requires the `pyats.tcl` library.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/tcl/variables.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n# \n#   dict style setting & getting variables using full qualifiers\n\nfrom pyats import tcl\n\n# setting variables\ntcl.vars['::aGlobalVar'] = 999\n\n# getting variables\ntcl_auto_path = tcl.vars['::auto_path']\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyATS Reporter Module with pip - Bash\nDESCRIPTION: This bash code snippet demonstrates how to upgrade the pyATS Reporter module to the latest version using pip. It includes separate commands for DevNet Community members (external users) and Cisco Internal Developers, indicating the appropriate package name for each audience. The 'pip install --upgrade' command will fetch and install the newest available version of 'pyats.reporter' for external users, or 'ats.reporter' for internal developers. The expected output is a successfully upgraded reporter module; network connectivity and pip pre-installation are required prerequisites.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2020/nov.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats.reporter\n\n# Cisco Internal Developers\nbash$ pip install --upgrade ats.reporter\n```\n\n----------------------------------------\n\nTITLE: YAML rerun.results File Example\nDESCRIPTION: Provides an example of a `rerun.results` file in YAML format. This file stores information about the test cases from a previous run, including the task, common setup and cleanup results, testcase names, and their results. This file is used in conjunction with the `--rerun-file` parameter to rerun specific test cases based on their previous outcomes.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/easypy/rerun.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\n# rerun.results file that contains the information of each task and their\n# testcases.\nTask-1:\n  commonCleanup: {name: common_cleanup, result: PASSED}\n  commonSetup: {name: common_setup, result: PASSED}\n  testcases:\n  - {name: tc_one, result: FAILED}\n  - {name: tc_two, result: PASSED}\n  testscript:   path/to/script\nTask-2:\n  commonCleanup: {name: common_cleanup, result: PASSED}\n  commonSetup: {name: common_setup, result: PASSED}\n  testcases:\n  - {name: tc_one, result: PASSED}\n  - {name: tc_two, result: PASSED}\n  testscript:   path/to/script\n```\n\n----------------------------------------\n\nTITLE: pyATS Validate Testbed Example\nDESCRIPTION: This is an example of validating a testbed input file using `pyats validate testbed`. It shows the command, loading process, testbed name, devices and warning messages, if any.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/cli/pyats_validate.rst#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n# Example\n# -------\n#\n#   validating a testbed input file\n\nbash$ pyats validate testbed N7K-EZ-HW-7-SSR.yaml\nLoading testbed file: N7K-EZ-HW-7-SSR.yaml\n--------------------------------------------------------------------------------\n\nTestbed Name:\n    N7K-EZ-HW-7-SSR\n\nTestbed Devices:\n.\n|-- P1 [router/nxos]\n|   `-- Ethernet3/9 ----------> link-1\n`-- PE1 [router/nxos]\n    `-- Ethernet3/9 ----------> link-1\n\nWarning Messages\n----------------\n - Device 'P1' missing 'platform' definition\n - Device 'PE1' missing 'platform' definition\n```\n\n----------------------------------------\n\nTITLE: YAML Datafile Example Configuration\nDESCRIPTION: This YAML snippet defines a complete example of a datafile, demonstrating how to configure parameters, processors, and testcases with their respective attributes. It showcases setting parameters and groups within a testcase, and how to extend another YAML file.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/datafile.rst#_snippet_4\n\nLANGUAGE: YAML\nCODE:\n```\n    # Example\n    # -------\n    #\n    #   the following is an example datafile yaml file\n\n    extends: sanity_data.yaml\n\n    parameters:\n        ip_seed: 1.1.1.1\n        vlan: 4382\n        traffic_streams: 50\n\n    processors:\n        pre:\n            - cflow.init_instrumentation\n            - router_health.reset\n\n        post:\n            - cflow.collect_results\n            - router_health.collect_health_info\n\n    testcases:\n        MyTestcase_One:\n            uid: alternative_uid_1\n            groups: [sanity, regression, ha]\n\n            parameters:\n                input_one: 1000\n                input_two: 2000\n\n            expected_routes: 35\n\n        MyTestcase_Two:\n            uid: alternative_uid_2\n            groups: [sanity, regression, ha, stability]\n\n            parameters:\n                input_x: 2000\n                input_y: 3000\n```\n\n----------------------------------------\n\nTITLE: Executing a pyATS job script to run multiprocessing testscript in Python\nDESCRIPTION: This snippet shows a minimal pyATS Easypy job script used to invoke the multiprocessing test script. It uses the pyats.easypy.run() function to execute the testscript file. There are no parameters or inputs beyond the filename. This snippet complements the multiprocessing example by demonstrating how to run the multiprocessing test code within the pyATS Easypy job framework.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/async/multiprocessing.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.easypy import run\n\ndef main():\n    run('multiprocess_example.py')\n```\n\n----------------------------------------\n\nTITLE: Defining CommonCleanup with Subsections in pyATS aetest (Python)\nDESCRIPTION: This snippet shows how to define a global common cleanup section for a pyATS aetest script by inheriting from `aetest.CommonCleanup`. Individual cleanup steps are implemented as methods within this class, decorated with `@aetest.subsection`. These subsections are executed to ensure the environment is clean after the test run, regardless of test results.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/structure.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats import aetest\n\n# define a common cleanup section by inherting from aetest\nclass ScriptCommonCleanup(aetest.CommonCleanup):\n\n    @aetest.subsection\n    def remove_testbed_configurations(self):\n        pass\n\n    @aetest.subsection\n    def disconnect_from_devices(self):\n        pass\n```\n\n----------------------------------------\n\nTITLE: RobotFramework Settings and Variables Example\nDESCRIPTION: This RobotFramework snippet illustrates the declaration of settings and variables within a RobotFramework test suite for use with pyATS.  It imports the `ats.robot.pyATSRobot` library and defines variables such as `${datafile}` and `${testbed}`. These variables can be used within the test cases to specify data files and testbed topologies, and can be overridden at runtime using command-line arguments.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/robot/native.rst#_snippet_3\n\nLANGUAGE: robotframework\nCODE:\n```\n    *** Settings ***\n    # Importing test libraries, resource files and variable files.\n\n    Library        ats.robot.pyATSRobot\n\n    *** Variables ***\n    # Defining variables that can be used elsewhere in the test data.\n    # Can also be driven as dash argument at runtime\n\n    ${datafile}     datafile.yaml\n    ${testbed}      testbed.yaml\n```\n\n----------------------------------------\n\nTITLE: Writing and Running pyATS AEtest Testcases in a Test Bench (Python)\nDESCRIPTION: This code illustrates creating, structuring, and running a pyATS AEtest Testcase interactively within a test bench, utilizing dynamic device connection. It depends on pyATS (aetest, topology modules), Genie utils, and a Python interpreter (with IPython for best interactivity). Snippet shows defining setup and test methods using decorators, device interaction via execute/parse/configure, and manual or YAML-based device instantiation. Inputs are testbed YAML files, device objects, and optional interface specification; outputs are assertion results shown in the interactive session. Constraints include appropriate device access and up-to-date pyATS/Genie installations.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/resources/testbench.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   aetest test bench with device connections\n\n# import what's necessary\nimport sys\nfrom pyats import aetest, topology\nfrom genie.utils import Dq\n\n# write a testcase here\n# --------------------------------------------------------------------------\n\nclass Testcase(aetest.Testcase):\n    '''\n    a testcase written in a test bench environment\n    '''\n\n    @aetest.setup\n    def setup(self, uut, intf = None):\n\n        if intf is None:\n            # default to picking the first available interface\n            intf = next(iter(uut.interfaces.values()))\n\n        self.intf = intf\n\n    @aetest.test\n    def check_version_string_has_iosxe(self, uut):\n        version = uut.execute('show version')\n        assert 'IOS XE' in version\n\n    @aetest.test\n    def interface_can_be_configured(self, uut):\n        # interface is assumed down, configure it\n        uut.configure('''\n            interface %s\n                ip address 1.1.1.1 255.255.255.0\n                no shutdown\n        ''' % self.intf.name)\n\n        # get the interface information from router_show\n        result = uut.parse('show interfaces %s' % self.intf.name)\n\n        # check that the status is reflected \n        assert Dq(result).get_values('enabled') == [True]\n        assert Dq(result).get_values('ip') == ['1.1.1.1']\n\n    @aetest.test\n    def hostname_can_be_changed(self, uut):\n        # configure hostname\n        uut.configure('hostname %s' % uut.name)\n\n        config = uut.execute('show running-config | include hostname')\n\n        assert uut.name in config\n\n        \n# run test code\n# --------------------------------------------------------------------------\nif __name__ == '__main__':\n\n    # load testbed from yaml file &\n    # grab a device by its alias (uut) for testing\n    testbed = topology.loader.load('/path/to/testbed.yaml')\n    uut = testbed.devices['uut']\n\n    # connect to the device\n    uut.connect()\n\n    # go interactive, do whatever\n    from IPython import embed; embed()\n    \n    # exit\n    sys.exit()\n\n    # copy paste code from here onwards..\n    # -----------------------------------\n\n    # create a testcase instance from the above code\n    tc = Testcase()\n\n    # run the testcase by calling it and providing it with\n    # necessary parameters (in this case uut)\n    # the result is printed to screen\n    tc(uut = uut)\n\n    # --------------------- BACKUP CODE ---------------------\n\n    # Manually Creating Objects\n    # -------------------------\n    # note that alternatively, instead of loading from YAML, you may also\n    # elect to create device and interface objects manually. this avoids the\n    # usage of a testbed input file.\n\n    # create a uut device\n    uut = topology.Device(name = 'iol',\n                          type = 'iol',\n                          connections = {\n                             'a': {'protocol': 'telnet',\n                                               'ip': '1.2.3.4',\n                                               'port': 10000}\n                          },\n                          credentials = {\n                              'default' : {'username': 'admin',\n                                           'password': 'adminpw'},\n                              'enable' : {'password': 'lab'},\n                          })\n\n    # add an interface to it\n    uut.add_interface(topology.Interface(name = 'Ethernet1/1',\n                                         type = 'Ethernet'))\n\n```\n\n----------------------------------------\n\nTITLE: Custom HTML Template Example (html)\nDESCRIPTION: This HTML code block shows how to create a custom HTML template for email reports using Jinja2 templating.  It extends the base email template and overrides the `head` and `custom_content` blocks.  This allows users to add custom CSS styles and content, injecting dynamic content, such as data from a Python dictionary (my_dict), into the report.  The template is then included in the email report.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/easypy/email.rst#_snippet_3\n\nLANGUAGE: html\nCODE:\n```\n<!--extend base template-->\n{% extends email_template %}\n\n<!--add your custom stylesheets here-->\n{% block head %}\n    <link rel=\"stylesheet\" href=\"style.css\" />\n{% endblock %}\n\n<!--add any custom content, displayed end of email report-->\n{% block custom_content %}\n    <h1>Index</h1>\n    <p class=\"important\">\n      Testing results:\n    </p>\n    {% for key, value in my_dict.iteritems() %}\n      <dt>{{ key }}</dt>\n      <dd>{{ value }}</dd>\n    {% endfor %}\n{% endblock %}\n```\n\n----------------------------------------\n\nTITLE: Converting Python Objects to Tcl String Format with tclstr (Python)\nDESCRIPTION: Shows the use of the `tclstr()` function to convert various Python objects (lists, dictionaries, `tcl.Array`, `tcl.KeyedList`) into their corresponding Tcl string representations. This function is designed to produce output suitable for Tcl evaluation, often by calling a special `__tclstr__()` method if implemented by the object. Requires `pyats.tcl` and `pyats.tcl.tclstr`.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/tcl/variables.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n# \n#   using tclstr() API\n\nfrom pyats import tcl\nfrom pyats.tcl import tclstr\n\n# casting list of list to Tcl format\nlist_of_list = [1, 2, [3, 4]]\ntclstr(list_of_list)\n'1 2 {3 4}'\n\n# casting a dict into a tcl array. note the usage\ndictionary = {'my key': 'my value', 'a': 'b'}\ntclstr(dictionary)\n'{my key} {my value} a b'\ntcl.eval('array set myArray {%s}' % tclstr(dictionary))\n\n# call an object's __tclstr__ attribute and return its Tcl format.\narray = tcl.Array(a = 1, b = 2, c = 3)\ntcl.eval('array set myArray {%s}' % tclstr(array))\n# myArray(a) = 1\n# myArray(b) = 2\n# myArray(c) = 3\n\nklist = tcl.KeyedList()\nklist['key.subkey'] = 'value'\ntcl.vars['klist'] = tclstr(klist)\n'{key {{subkey value}}}'\n```\n\n----------------------------------------\n\nTITLE: Upgrading ats.kleenex Using pip in Bash\nDESCRIPTION: This bash command upgrades the ats.kleenex Python module to the latest available version via pip. Users should run this command in a terminal to ensure their installation of ats.kleenex is up-to-date, especially after new releases or bug fixes. Requires Python and pip to be installed; outputs the upgrade process status and completes successfully when the module is updated.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2016/june.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats.kleenex\n```\n\n----------------------------------------\n\nTITLE: Instantiating and connecting\nDESCRIPTION: This snippet shows the device connection manager object. It shows how to access it.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/connections/manager.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# given a device connection manager object\ndevice.connectionmgr\n# <pyats.connections.ConnectionManager object at 0xf76f1c4c>\n```\n\n----------------------------------------\n\nTITLE: Complex Import Translation in Python\nDESCRIPTION: This code shows an alternative approach to translating legacy import names by using functions. The example defines `to_new` and `to_old` functions, which translate import names to the new or legacy names accordingly. The `IMPORT_MAPPING` variable becomes a tuple of these functions, thus allowing more complex transformations. The developer must provide both functions for completeness.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/import_utils.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef to_new(name):\n    if name == 'my_package' or if name.startswith('my_package.'):\n        return name.replace('my_package', 'your_package', 1)\n\ndef to_old(name):\n    if name == 'your_package' or if name.startswith('your_package.'):\n        return name.replace('your_package', 'my_package', 1)\n\nIMPORT_MAPPING = (to_new, to_old)\n```\n\n----------------------------------------\n\nTITLE: Defining Subsections in pyATS CommonSetup/Cleanup (Python)\nDESCRIPTION: This example illustrates how subsections are defined within both `aetest.CommonSetup` and `aetest.CommonCleanup` classes using the `@aetest.subsection` decorator. Each decorated method becomes an independent, identifiable action within the larger common section, allowing for modular setup or cleanup steps.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/structure.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   subsections\n\nfrom pyats import aetest\n\n# subsections exists within CommonSetup\nclass ScriptCommonSetup(aetest.CommonSetup):\n\n    # define subsections by applying @subsection decorator\n    @aetest.subsection\n    def common_setup_subsections(self):\n        pass\n\n# -------------------------------------------\n\n# subsections exists within CommonCleanup\nclass ScriptCommonCleanup(aetest.CommonCleanup):\n\n    # define subsections by applying @subsection decorator\n    @aetest.subsection\n    def common_cleanup_subsections(self):\n        pass\n```\n\n----------------------------------------\n\nTITLE: Encoding a String with pyATS Secret Encode - Text\nDESCRIPTION: This snippet details usage of the 'pyats secret encode' subcommand, which encodes plaintext strings into secure encoded representations. Users can be prompted for a string or use the '--string' option to supply it. Representation and encryption can be customized in the pyATS configuration, and a private key may be required. The '--prefix' option selects alternative configuration namespaces.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/cli/pyats_secret.rst#_snippet_2\n\nLANGUAGE: Text\nCODE:\n```\nUsage:\n  pyats secret encode [options]\n\nDescription:\n  Encodes a plaintext string into an encoded form.\n\n  The encoding used may be changed by specifying the pyats configuration:\n  [secrets] string.representer = representer_module.representer_class\n\n  Otherwise, a default cipher encoding is used.\n\n  The encoding may be personalized by using the pyats configuration:\n  [secrets] string.key = <generated_key>\n\n  where <generated_key> refers to the key generated with the \"pyats secret keygen\"\n  command.\n\n  If specified, --prefix selects other representers defined in the pyats\n  configuration.  The following are expected to be present:\n  [secrets] <prefix>.representer\n  [secrets] <prefix>.key\n\nEncode Options:\n  --string [string]     String to encode (Optional)\n  --prefix [prefix]     Cfg prefix to use (Optional)\n\nGeneral Options:\n  -h, --help            Show help\n  -v, --verbose         Give more output, additive up to 3 times.\n  -q, --quiet           Give less output, additive up to 3 times, corresponding to WARNING, ERROR,\n                        and CRITICAL logging levels\n```\n\n----------------------------------------\n\nTITLE: Using gTask for Genie Tasks in pyATS\nDESCRIPTION: This snippet illustrates how to use the gTask class (from genie.harness.main) to define and start a Genie task, specifying trigger and configuration data files. It then waits for the task to complete.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/easypy/jobfile.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n    # Example\n    # -------\n    #\n    #   job file tasks using gTask() api\n\n    from genie.harness.main import gTask\n\n    def main(runtime):\n\n        # using Task class to create a task object\n        task_1 = gTask(trigger_datafile='trigger_data.yaml',\n                       config_datafile='config_data.yaml',\n                       subsection_datafile='subsection_data.yaml',\n                       trigger_uids='TestBgp',\n                       taskid='task1')\n\n        # start the task\n        task_1.start()\n\n        # wait for a max runtime of 60*5 seconds = 5 minutes\n        task_1.wait(60*5)\n```\n\n----------------------------------------\n\nTITLE: Applying Markups in a pyATS Testbed File (YAML)\nDESCRIPTION: Shows a pyATS testbed YAML file utilizing various markups like `%CALLABLE{mylib.get_device_type}`, `%{self.clean.mgt_itf.ipv4.address}`, `%ENV{DEFAULT_INTERFACE_TYPE}`, `%CALLABLE{mylib.create_device(...)}`, and `%INCLUDE{...}` to dynamically define device types, connection IP addresses, interface types, create entire device definitions via function calls, and include interface configurations from external files.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/yaml_markup.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\n# Example\n# -------\n#\n#   yaml testbed using markup\n#   notice how markups were used as information references.\ndevices:\n    example_device:\n        type: \"%CALLABLE{mylib.get_device_type}\"\n        connections:\n          a:\n            protocol: telnet\n            ip: \"1.1.1.1\"\n            port: 2001\n          alt:\n            protocol: telnet\n            ip: \"%{self.clean.mgt_itf.ipv4.address}\"\n\n    dynamic_device: \"%CALLABLE{mylib.create_device(2.2.2.2)}\"\ntopology:\n    example_device:\n        interfaces:\n            Ethernet4/6:\n                alias: my_logical_interface\n                link: link-x\n                type: \"%ENV{DEFAULT_INTERFACE_TYPE}\"\n    dynamic_device: \"%INCLUDE{/path/to/dynamic/generated/device/interfaces/file}\"\n```\n\n----------------------------------------\n\nTITLE: Creating Keyed Lists on the Fly\nDESCRIPTION: This Python snippet shows how to dynamically create `KeyedList` objects and populate them with key-value pairs. It demonstrates adding keys and subkeys, and how the nested structure of the keyed list is maintained. It also provides an example of creating a keyed list from keyword arguments, but the description mentions the limitation when using kwargs which prevents the use of '.' in the key names.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/tcl/datastructures.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.tcl import KeyedList\n\n# create a blank object\nklist = KeyedList()\n\n# add some keys and subkeys\nklist['a.x'] = 1\nklist['b.y.z'] = 2\nklist['c'] = 3\n\n# let's see the output.\n# note how sub-keys were automatically created into keyed lists.\nklist\n# {'b': {'y': {'z': 2}}, 'a': {'x': 1}, 'c': 3}\n\n# you can also create a klist from kwargs\n# but this limits you to one key only, as Python does not support\n# kwargs keys to contain .\nKeyedList(a = 1, b = 2)\n# output: {'b': 2, 'a': 1}\n# hence this isn't really the best way of creating a python keyed list.\n```\n\n----------------------------------------\n\nTITLE: Calling AEtest Container Class Instances to Execute Sections in Python\nDESCRIPTION: Shows that `aetest` container class instances are callable, effectively running the sections they contain. Continuing the previous example, calling the `common_setup` instance executes its subsections and returns the overall result object for that container.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/objects.rst#_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\n# Example\n# -------\n#\n#   calling container class instance\n\n# continuing from last example..\n\n# run the common setup section instance\n# save into result variable\nresult = common_setup()\n# hello world\n\n# print the result variable\nprint(result)\n# passed\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyats.kleenex via pip (DevNet)\nDESCRIPTION: This command upgrades the pyats.kleenex module using pip for DevNet community users. It ensures that the latest version of the module is installed, providing access to new features and bug fixes.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2019/jan.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade pyats.kleenex\n```\n\n----------------------------------------\n\nTITLE: Setting Custom Common Discovery Class in pyATS AETEST\nDESCRIPTION: Shows how to change the default common discovery class by setting the runtime.discoverer.common property. Custom discovery classes must inherit from the default CommonDiscovery class.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/control.rst#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.aetest import runtime\nruntime.discoverer.common = MyCustomCommonDiscovery\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.aetest import runtime\nfrom pyats.aetest.discovery import CommonDiscovery\n\nclass MyCustomCommonDiscovery(CommonDiscovery):\n    pass\n\nruntime.discoverer.common = MyCustomCommonDiscovery\n```\n\n----------------------------------------\n\nTITLE: Configuring Device Images via Paths or URLs (YAML)\nDESCRIPTION: Illustrates how to define device images within the configuration using direct file paths (single or list) or URLs. Supported URL protocols like ftp, tftp, sftp, and scp are mentioned. This provides flexibility in sourcing image files.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/kleenex/inputs.rst#_snippet_6\n\nLANGUAGE: YAML\nCODE:\n```\n# For example:\n#   images:\n#     kick: /path/to/kick.img\n#     system: /path/to/system.img\n#     smu: [/path/to/smu1.img, /path/to/smu2.img]\n#\n# Images are assumed to be filesystem-based unless\n# they are specified as URLs of the following form:\n# <protocol>://<server>.<domain>:<port>/path/to/image/my_image\n# where available <protocol> values are platform\n# dependent but could be one of the following :\n# ftp, tftp, sftp, scp\n#\n# For example:\n#  images:\n#    kick:\n#      file: [ftp://server.com/path/to/my/image]\n```\n\n----------------------------------------\n\nTITLE: Parametrized Expectation Function\nDESCRIPTION: This function, named `expectation`, is a parametrized function that determines its return value based on the current section's UID. It takes the `section` object as input. If the `section.uid` is 'expected_to_pass', it returns 9999; otherwise, it returns 0. It is used in conjunction with other test cases to determine expected outcomes.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/parameters.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n    # defining a parametrized function named \"expectation\"\n    # ----------------------------------------------------\n    # this is a smart function: it can decide what to return\n    # based on the current section object information.\n    # it accepts the current section as input, and\n    # returns 999 when the section uid is 'expected_to_pass', or 0 otherwise.\n    @aetest.parameters.parametrize\n    def expectation(section):\n        if section.uid == 'expected_to_pass':\n            return 9999\n        else:\n            return 0\n```\n\n----------------------------------------\n\nTITLE: Documenting pyats.async.exceptions Module with Sphinx\nDESCRIPTION: This snippet employs the `automodule` directive to document the `pyats.async_.exceptions` module. Similar to the previous snippet, it lists members, excludes undocumented members, and shows inheritance.  It relies on Sphinx and the pyats library for proper functioning.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/apidoc/async/index.rst#_snippet_1\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: pyats.async_.exceptions\n   :members:\n   :undoc-members:\n   :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: Defining a Base pyATS Testbed File (YAML)\nDESCRIPTION: Presents a base pyATS testbed configuration file (`tb1.yaml`) defining a single device (`xr-1`) with its connections (CLI via SSH), default and enable credentials, OS (`iosxr`), and type (`iosxr`). This file is intended to be extended by another YAML file.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/yaml_markup.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\ndevices:\n  xr-1:\n    connections:\n      cli:\n        ip: 10.1.1.1\n        protocol: ssh\n    credentials:\n      default:\n        password: cisco\n        username: cisco\n      enable:\n        password: cisco\n    os: iosxr\n    type: iosxr\n```\n\n----------------------------------------\n\nTITLE: Upgrading PyATS using pip (DevNet)\nDESCRIPTION: This command upgrades the PyATS package to the latest version using pip. It's intended for users in the DevNet community. The command utilizes the `--upgrade` flag to ensure that all dependencies are updated as well.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2022/may.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade pyats\n```\n\n----------------------------------------\n\nTITLE: Converting Python Keyed List to Tcl String\nDESCRIPTION: This code converts a Python `KeyedList` object back to a Tcl-compatible string format using the `tclstr()` function. The resulting string is then used within a Tcl `set` command to create a new Tcl variable. Following this, the example uses Tcl to get the keys from the keyed list using keylkeys. In conclusion, it illustrates how the conversion works and also provides an alternative approach, the `set_keyed_list` API.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/tcl/datastructures.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# continuing from above section\n\n# let's see some output\ntclstr(klist)\n# '{b {{y {{z 2}}}}} {a {{x 1}}} {c 3}\n\n# set it back to Tcl\ntcl.eval('set newKlist {%s}' % (tclstr(klist),))\n\n# let's see the keys\ntcl.eval('keylkeys newKlist')\n# 'b a c'\n\n# alternatively, use set_keyed_list API\ntcl.set_keyed_list('altKList', klist)\ntcl.eval('keylkeys altKList')\n# 'b a c'\n```\n\n----------------------------------------\n\nTITLE: Listing Remote Directory Contents with FileUtils in Python\nDESCRIPTION: Example showing how to list files in a remote directory using the dir method. Returns a list of file URLs at the top level of the specified directory.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/file_transfer_utilities.rst#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.utils.fileutils import FileUtils\nwith FileUtils(testbed=tb) as futils:\n    futils.dir(\"sftp://server.domain.com/path/to/\")\n\n['sftp://server.domain.com/path/to/file',]\n```\n\n----------------------------------------\n\nTITLE: Configuring Clean Timeout (YAML)\nDESCRIPTION: Defines the optional 'timeout' parameter used within the clean configuration block. This parameter specifies the maximum duration in seconds that the clean worker should run before timing out. If omitted, the clean process will run indefinitely.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/kleenex/inputs.rst#_snippet_8\n\nLANGUAGE: YAML\nCODE:\n```\ntimeout:        # clean timeout in seconds.\n# if not timeout is specified, clean worker will\n# run without timing out.\n# (optional)\n```\n\n----------------------------------------\n\nTITLE: Passing Environment Variables as Arguments in a pyATS Job File (Python)\nDESCRIPTION: This Python snippet demonstrates how to read environment variables (`SCRIPT_ARG_A`, `SCRIPT_ARG_B`) within a pyATS job file using `os.environ.get()`. It shows how to construct relative paths for testscripts using `os.path.dirname(__file__)` and `os.path.join()`, and passes the retrieved environment variable values as keyword arguments to the `easypy.run()` function for `script_two.py`. Requires the `os` module and `pyats.easypy.run` function.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/easypy/jobfile.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   job file with environment variable processing\n\nimport os\nfrom pyats.easypy import run\n\n# using this file's path to compute the relative location of script file\n# and collecting some arguments from environment variables\nhere = os.path.dirname(__file__)\nargA = os.environ.get('SCRIPT_ARG_A', 'argument value a')\nargB = os.environ.get('SCRIPT_ARG_B', 'argument value b')\n\n# entry point\ndef main(runtime):\n\n    # relative script path/file based on this file's location\n    run(testscript = os.path.join(here, 'path', 'to', 'script_one.py'),\n        runtime = runtime)\n\n\n    # passing script arguments collected from environment variable\n    run(testscript = os.path.join(here, 'path', 'to', 'script_two.py'),\n        runtime = runtime,\n        argument_A = argA,\n        argument_B = argB)\n```\n\n----------------------------------------\n\nTITLE: Looping with uids in PyATS\nDESCRIPTION: This code snippet illustrates how to use the `uids` parameter with the `@loop` decorator in PyATS. When `uids` are provided, the number of iterations equals the number of uids. Extra values are discarded if the number of parameter values exceeds the number of `uids`. The uids provide unique identifiers for the test iterations.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/loop.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.aetest import loop\n\n# loop with 2 iterations using uids argument\n# ------------------------------------------\n#   iteration 1: uid='id_one'\n#   iteration 2: uid='id_two'\n@loop(uids=['id_one', 'id_two'])\n```\n\n----------------------------------------\n\nTITLE: Function Arguments for Retry: Handling Retry State in Test Methods\nDESCRIPTION: Demonstrates passing retry-related parameters retries and retry_count into test functions, enabling conditional logic based on retry attempts. These parameters help determine whether a test is being retried and track the retry count during test execution.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/retry.rst#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n        @aetest.retry()\n        @aetest.test\n        def connect_testcase(self, steps, retry, retry_count):\n            with steps.start('Failure case') as step:\n                if retry and retry_count > 1:\n                    step.passed()\n                step.failed()\n```\n\n----------------------------------------\n\nTITLE: Setting Log Levels in pyATS Jobfiles\nDESCRIPTION: This snippet demonstrates how to configure log levels for various modules within a pyATS jobfile. It shows how to set different log levels for different modules and how to affect all loggers by setting the root logger's level.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/easypy/jobfile.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n    # Example\n    # -------\n    #\n    #   controlling log levels from job file\n\n    from pyats.easypy import run\n\n    # import logging module\n    import logging\n\n    # relative script path based on pyats root.\n    prefix = sys.prefix\n\n    # main block\n    def main(runtime):\n\n        # set logging levels for various modules\n        # eg, setting aetest log level to INFO\n        # and setting 'mylibrary' to DEBUG\n        logging.getLogger('pyats.aetest').setLevel('INFO')\n        logging.getLogger('mylibrary').setLevel('DEBUG')\n        # if you set the root logger's log level, then it affects all\n        # loggers as per rules of logger parent-child relationship\n        # eg, turning on DEBUG for all loggers.\n        logging.root.setLevel('DEBUG')\n\n        # you can now provide those new values to your pyATS script.\n        run(testscript = os.path.join(prefix, 'path', 'to', 'script_two.py'),\n            runtime = runtime)\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyATS using pip (Cisco Internal)\nDESCRIPTION: This code snippet demonstrates upgrading pyATS for Cisco internal developers. It utilizes pip to upgrade the 'ats' package. It is intended to bring the internal installation of pyATS to the most recent version.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2022/october.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Installing pyATS Package\nDESCRIPTION: This command installs or upgrades the specified pyATS package using pip. The `--upgrade` flag ensures that the latest version is installed. This is a standard installation command for pyATS packages.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2016/may.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats.aetest\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyats via pip (Cisco Internal)\nDESCRIPTION: This command upgrades the core ats package using pip for Cisco internal developers.  It ensures the latest version is installed, providing access to internal features, bug fixes, and module updates.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2019/jan.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Upgrading Pyats via pip (Cisco Internal)\nDESCRIPTION: This command upgrades the Pyats package for Cisco internal developers using pip. It installs the latest version available from the internal repository. The `--upgrade` flag ensures the existing Pyats installation is updated. The output provides information about the installation status and version.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2023/october.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Cisco Internal Developers\n    bash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Sample AEReport ResultsDetails.xml Excerpt\nDESCRIPTION: Presents a partial example of the ResultsDetails.xml file generated by AEReport. It details the hierarchical structure of a test run, including testsuite, jobexecution, testscript, and testcase elements with their respective start/stop times, results, runtime information, and other execution details.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aereport/index.rst#_snippet_1\n\nLANGUAGE: xml\nCODE:\n```\n<?xml version=\"1.0\" ?>\n<aereport xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n <testsuite>\n  <starttime>2014-06-02T10:12:01</starttime>\n  <initinfo>\n   <name>run_jb</name>\n   <ats>\n    <path>/ws/jeaubin-ott/py</path>\n    <version>5.3.0</version>\n   </ats>\n  </initinfo>\n  <jobexecution>\n   <runinfo/>\n   <starttime>2014-06-02T10:12:01</starttime>\n   <stoptime>2014-06-02T10:12:03</stoptime>\n   <result mode=\"auto\"/>\n   <testscript>\n    <starttime>2014-06-02T10:12:01</starttime>\n    <initinfo>\n        ...\n    <runinfo/>\n    <testcase>\n     <starttime>2014-06-02T10:12:03</starttime>\n     <stoptime>2014-06-02T10:12:03</stoptime>\n     <result mode=\"auto\">skipped</result><runtime>00:00:00</runtime>\n    </testcase>\n    <stoptime>2014-06-02T10:12:03</stoptime>\n    <runtime>00:00:02</runtime>\n    <summary>\n     <abort>0</abort>\n     <fail>0</fail>\n     <block>0</block>\n     <skip>0</skip>\n     <error>0</error>\n     <unknown>0</unknown>\n    </summary>\n    <pass>0</pass>\n   </testscript>\n   <runtime>00:00:02</runtime>\n   ...\n  </jobexecution>\n  <tims bgPost=\"False\">\n   <post>\n    <status/>\n    <cmd/>\n   </post>\n   <dnsname/>\n  </tims>\n  <runinfo/>\n  <archivefile>atseasy/jeaubin/archive/14-06/run_jb.2014Jun02_10:12:00.zip</archivefile>\n  <stoptime>2014-06-02T10:12:03</stoptime>\n  <runtime>00:00:02</runtime>\n  <summary>\n   <abort>0</abort>\n   <fail>1</fail>\n   <block>0</block>\n   <skip>2</skip>\n   <error>0</error>\n   <unknown>0</unknown>\n  </summary>\n  <pass>0</pass>\n </testsuite>\n</aereport>\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyATS Modules Using pip - Bash\nDESCRIPTION: This snippet demonstrates the shell commands necessary to upgrade individual pyATS components or the entire pyATS package using pip for both DevNet Community users and Cisco Internal Developers. It requires Python and pip to be installed on the target system. Users must run the commands in a terminal, using different package namespaces ('pyats.' vs 'ats.') depending on their environment. The commands upgrade modules such as aetest, kleenex, results, and log to the latest versions.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2020/sep.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats.aetest pyats.kleenex pyats.results pyats.log\n\n# Cisco Internal Developers\nbash$ pip install --upgrade ats.aetest ats.kleenex ats.results ats.log\n```\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats\n\n# Cisco Internal Developers\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Enabling Testcase Randomization in pyATS (Python)\nDESCRIPTION: Demonstrates how to enable pseudo-random execution order for testcases within a script by passing `random=True` to the `aetest.main()` function. This shuffles the defined `Testcase` classes before execution, while `CommonSetup` and `CommonCleanup` retain their fixed positions. Requires `pyats.aetest`.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/control.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n# randomization of testcases feature demonstration\n\nfrom pyats import aetest\n\n# define a couple testcases\nclass TestcaseOne(aetest.Testcase):\n    pass\n\nclass TestcaseTwo(aetest.Testcase):\n    pass\n\nclass TestcaseThree(aetest.Testcase):\n    pass\n\n# run it\naetest.main(random = True)\n```\n\n----------------------------------------\n\nTITLE: Visualizing Kleenex Clean Engine Flow (Text)\nDESCRIPTION: This text diagram illustrates the workflow of the Kleenex Clean Engine. It shows how input files (clean file and testbed file) are processed by the engine, which then forks separate processes for each device, running the corresponding cleaner class on a target device.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/kleenex/clean.rst#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nPictorial View of Clean Engine\n------------------------------\n\n+--------------+\n|  clean file  |---.             +-------------+\n+--------------+    \\   input    |             |\n                         >---------> | CleanEngine |\n+--------------+    /            |             |\n| testbed file |---'             +-------------+\n+--------------+                        |\n                                            |\n                                            |  fork   +--------------------+\n                                            |---------| cleaner: Cleaner-1 |\n                                            |         | target : Device-1  |\n                                            |         +--------------------+\n                                            |\n                                            |  fork   +--------------------+\n                                            |---------| cleaner: Cleaner-2 |\n                                            |         | target : Device-2  |\n                                            |         +--------------------+\n                                            |\n                                            |  fork   +--------------------+\n                                            |---------| cleaner: Cleaner-3 |\n                                            |         | target : Device-3  |\n                                            +--------------------+\n                                            |\n                                           etc...\n```\n\n----------------------------------------\n\nTITLE: Comprehensive Example: Custom Discovery and Ordering Classes Integration in pyATS (Python)\nDESCRIPTION: This complete example demonstrates how to implement and configure custom discovery and ordering classes for scripts, testcases, and common sections in pyATS AEtest using Python. It covers subclassing, method overriding, and runtime integration via runtime.discoverer. The sample also shows the use of per-section discoverer overrides and results in a tailored test execution sequence. All dependencies are within the pyATS AEtest suite. Inputs are AEtest script objects and subclasses; outputs are custom-ordered test executions.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/control.rst#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats import aetest\n\n# importing the runtime to have access to the runtime.discoverer\nfrom pyats.aetest import runtime\n\n# importing ScriptDiscovery, TestcaseDiscovery and CommonDiscovery classes\n# for inheritance\nfrom pyats.aetest.discovery import ScriptDiscovery, TestcaseDiscovery,\\\n                                 CommonDiscovery\n\n# Custom Script Discovery class that changes only the discover method\n# which will return common_setup and tc_one\nclass CustomScriptDiscovery(ScriptDiscovery):\n    def discover(self):\n        return [self.target.module.common_setup, self.target.module.tc_one]\n\n# Custom Testcase Discovery Class that changes both discover and order\n# classes. This class returns nothing from the discover method to the order\n# so, nothing will run in the provided tetscase\nclass CustomTestcaseDiscovery_1(TestcaseDiscovery):\n    def discover(self):\n        return []\n\n    def order(self, setup=None, testcases=list(), cleanup=None):\n        if setup is not None:\n            testcases.insert(0, setup)\n        if cleanup is not None:\n            testcases.append(cleanup)\n\n        return testcases\n\n# Common Discovery Class that returns nothing to be run\nclass CustomCommonDiscovery_1(CommonDiscovery):\n    def discover(self):\n        return []\n\n    def order(self, *sections):\n        return sections\n\n# Custom Common Discovery Class, order method returns sample_subsection_1\n# so it's the only test section that will run for the provided testcase\nclass CustomCommonDiscovery_2(CommonDiscovery):\n    def order(self, *sections):\n        return [self.target.sample_subsection_1]\n\n# setting runtime.discoverer properties so that default discovery classes\n# will change to user defined ones.\nruntime.discoverer.script = CustomScriptDiscovery\nruntime.discoverer.testcase = CustomTestcaseDiscovery_1\nruntime.discoverer.common = CustomCommonDiscovery_1\n\n# This testcase has discoverer attribte so that, runtime.discoverer.common\n#  will be ignored\nclass common_setup(aetest.CommonSetup):\n    discoverer = CustomCommonDiscovery_2\n\n    @aetest.subsection\n    def sample_subsection_1(self):\n        pass\n\n    @aetest.subsection\n    def sample_subsection_2(self, section):\n        pass\n\nclass tc_one(aetest.Testcase):\n\n    @aetest.setup\n    def prepare_testcase(self, section):\n        pass\n\n    @ aetest.test\n    def simple_test_1(self):\n        pass\n\n    @ aetest.test\n    def simple_test_2(self):\n        pass\n\n    @aetest.cleanup\n    def clean_testcase(self):\n        pass\n\nclass common_cleanup(aetest.CommonCleanup):\n    @aetest.subsection\n    def clean_everything(self):\n        pass\n```\n\n----------------------------------------\n\nTITLE: Handling Service Calls and Exception Management in pyATS Service Wrapper - Python\nDESCRIPTION: Implements core methods for invoking a service and managing exceptions within a pyATS service wrapper. The 'call_service' method logs the requested service and delegates execution, handling exceptions by invoking 'exception_service', which logs errors and provides a formatted error message. Dependencies include a logger instance and the relevant service references. Inputs are arbitrary arguments for the service, with output being the result or a string describing the exception encountered. Exception details are captured and logged for diagnostic purposes.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/connections/wrapper.rst#_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\ndef call_service(self, *args, **kwargs) -> Any:\n    try:\n        self.logger.info(f\"Calling service: {self.service_name}\")\n        return self.service(*args, **kwargs)\n    except Exception as e:\n        return self.exception_service(e, *args, **kwargs)\n\ndef exception_service(self, e, *args, **kwargs):\n    self.logger.exception(f\"Exception occurred: {e}\")\n    return f'Exception occurred: {e}'\n```\n\n----------------------------------------\n\nTITLE: pyats develop command general usage\nDESCRIPTION: This snippet shows the general syntax for the `pyats develop` command. It indicates that the command can be followed by one or more package names (packages...) and various optional flags ([options]).\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/cli/pyats_develop.rst#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nUsage:\n  pyats develop [packages...] [options]\n```\n\n----------------------------------------\n\nTITLE: Setting Log Directory for Kleenex in pyATS\nDESCRIPTION: Demonstrates how to use the --logdir parameter to specify a custom directory for Kleenex logs. By default, it uses the Easypy runinfo directory or creates a timestamped folder in the current working directory.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/kleenex/usages.rst#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pyats clean --testbed-file /path/to/my/testbed.yaml\\\n                      --clean-file /path/to/my/clean.yaml\\\n                      --logdir /tmp\n```\n\n----------------------------------------\n\nTITLE: Copying Examples and Templates to the pyATS Instance\nDESCRIPTION: This bash script snippet copies examples and templates to a pyATS instance. It navigates to the virtual environment, backs up existing directories, and copies the new examples and templates from a specified location.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2015/june.rst#_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\nbash$ cd $VIRTUAL_ENV\nbash$ mv examples examples_bak\nbash$ mv templates templates_bak\nbash$ cp -r /auto/pyats/examples .\nbash$ cp -r /auto/pyats/templates .\n```\n\n----------------------------------------\n\nTITLE: Upgrading Complete pyATS Framework via pip - Bash\nDESCRIPTION: Provides pip commands to upgrade the entire pyATS framework for DevNet community or Cisco internal users to v19.0. This requires pip and is the standard, simpler way to upgrade all pyATS components at once.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2019/mar.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats\n```\n\nLANGUAGE: bash\nCODE:\n```\n# Cisco Internal Developers\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Example Structure for EXTEND_LIST Value Markup (YAML)\nDESCRIPTION: This YAML snippet illustrates a configuration structure under `parameters.base_config` defining BGP address families and neighbors. It provides context for potentially using the `%EXTEND_LIST{path.to.list1, path.to.list2}` value markup (though not explicitly shown here) to create a new list by combining existing lists, such as aggregating neighbor lists from different sections.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/yaml_markup.rst#_snippet_9\n\nLANGUAGE: yaml\nCODE:\n```\nparameters:\n    base_config:\n        CE1:\n            bgp:\n                address_families:\n                    ipv4:\n                        neighbors:\n                            1.1.1.1: {}\n                            1.1.1.2: {}\n                    ipv6:\n                        neighbors:\n                            - 1::1\n                            - 1::2\n```\n\n----------------------------------------\n\nTITLE: Creating and Configuring Device Objects in pyATS\nDESCRIPTION: Demonstrates how to create Device objects with various configurations, add interfaces, set device properties like OS type and alias, and work with device associations to testbeds and credentials.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/topology/concept.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   creating device objects\n\nfrom pyats.topology import Testbed, Device, Interface\n\n# create some interfaces for adding to devices\nintf_a = Interface('Eth1/1', 'ethernet')\nintf_b = Interface('Eth2/1', 'ethernet')\n\n# creating a testbed for demonstration's sake\ntestbed = Testbed('exampleTestbed')\n\n# creating an empty device\ndevice_a = Device('emptyDevice')\n\n# giving device a different alias\ndevice_a.alias = 'newAlias'\n\n# set device os\ndevice_a.os = 'iosxe'\n\n# creating a device with connection parameters\ndevice_b = Device('deviceThatCanBeConnected',\n                  os='iosxe',\n                  connections={\n                      'mgmt': {\n                          'protocol': 'telnet',\n                          'ip': '1.1.1.1'\n                      },\n                  })\n\n# adding interface to device objects\ndevice_b.add_interface(intf_a)\n\n# creating device with interfaces\ndevice_c = Device('deviceCreatedWithIntfs',\n                  os='iosxe',\n                  interfaces = [intf_b])\n\n# associating a device to a testbed can be done either by performing\n# a testbed.add_device() call, or directly by setting a device's testbed\n# attribute, which automatically performs the parent add_device() call\ndevice_c.testbed = testbed\n\n# checking if an intf object belongs to a device can be done\n# using the in operator\nassert intf_b in device_c\n\n# loop through interfaces on a device\nfor intf in device_c:\n    print(intf.name)\n\n# Setting credentials on a device\n#\n# Testbed credentials may be read via device credentials\n# if they have not been defined at a device level and the device has\n# an assigned testbed.\n#\n# Once set, credentials may be accessed via dot notation.\ntestbed.credentials['default'] = dict(username='defaultuser', password='defaultpw')\nassert testbed.credentials.default.username == 'defaultuser'\n\ntestbed.credentials['tbcreds'] = dict(username='tbuser', password='tbpw')\ndevice_c.credentials['devcreds'] = dict(username='devuser', password='devpw')\nassert 'tbcreds' in device_c.credentials\nassert 'devcreds' in device_c.credentials\n\n# Missing credentials fall back to default credential if present\nassert testbed.credentials.unknowncred.username == 'defaultuser'\n\n# Although credential passwords are encoded and not directly readable\n# once set, it is possible to convert them back to plaintext.\nfrom pyats.utils.secret_strings import to_plaintext\nassert to_plaintext(device_c.credentials.devcreds.password) == 'devpw'\n\n# Setting credentials on a connection\n#\n# Device credentials may be read via connection credentials\n# if they have not been defined at a connection level.\n#\n# Testbed credentials may also be read via connection credentials\n# if they have not been defined at a device level and the device has an\n# assigned testbed.\n#\n# Once set, credentials may be accessed via dot notation.\ncon = device_b.connections.mgmt\ndevice_b.testbed = testbed\ncon.credentials['concreds'] = dict(username='connuser', password='conpw')\nassert 'tbcreds' in con.credentials\nassert 'concreds' in con.credentials\n\n# Provide a connection-level default credential\ncon.credentials['default'] = dict(username='condefun', password='condefpw')\n```\n\n----------------------------------------\n\nTITLE: Serializing and Deserializing Python Objects Using Pickle in Python\nDESCRIPTION: Demonstrates how to use the Python pickle module to serialize (pickle) and deserialize (unpickle) Python data structures for inter-process communication. The snippet creates a dictionary object, serializes it into a byte stream, and then reconstructs the original object from the serialized data. Dependencies include the standard 'pickle' module. Inputs are Python objects that must be pickleable; output is the serialized byte stream and the deserialized object identical in content but a different instance. This technique is necessary for passing data through multiprocessing Pipes or Queues in pyATS.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/async/integration.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pickle\n\n# create an object\n# create a datastructure\ndata = dict(name = 'tony stark',\n            callsign = 'ironman',\n            also_known_as = ('genius',\n                             'billionaire',\n                             'playboy',\n                             'philanthropist'))\n\n# pickle the data into a bytestream\nserialized_data = pickle.dumps(data)\n\n# unpickle recreates the data structure\nreconstructed_data = pickle.loads(serialized_data)\n\n# data is the same before and after pickling\nassert data == reconstructed_data\n\n# however, they are two different copies (different object id)\nid(data)\nid(reconstructed_data)\n```\n\n----------------------------------------\n\nTITLE: Running a RobotFramework Script with 'pyats run robot' CLI Subcommand\nDESCRIPTION: Provides usage, examples, and options for executing a RobotFramework script within the pyATS environment, functioning similarly to 'pyats run job' but tailored for Robot scripts. It requires specifying the script file and supports configuration, mailing, reporting, live view, testbed, and cleaning options.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/cli/pyats_run.rst#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nUsage:\n  pyats run robot [file] [options]\n\nExample\n-------\n  pyats run robot /path/to/my_robot_script.robot\n  pyats run robot /path/to/my_robot_script.robot --testbed-file /path/to/testbed.yaml\n\nDescription:\n  Runs a RobotFramework script with the provided arguments, generating & report\n  result.\n\nConfiguration:\n  -C, --configuration FILE\n                        easypy configuration yaml file for plugins\n\nRobot Script Info:\n  FILE                  target RobotFramework script to be run\n  --job-uid             Unique ID identifiying this job run\n\nMailing:\n  --no-mail             disable report email notifications\n  --mail-to             list of report email recipients\n  --mail-subject        report email subject header\n  --mail-html           enable html format report email\n\nReporting:\n  --submitter           Specify the current submitter user id\n  --image               Specify the image under test\n  --release             Specify the release being tested\n  --branch              Specify the branch being tested\n  --meta                Specify some meta information as a dict (supports base64 encoded strings)\n  --no-xml-report       Disable generation of the XML Report\n\nRuninfo:\n  --no-archive          disable archive creation\n  --no-archive-subdir   disable archive subdirectory creation\n  --runinfo-dir         specify alternate runinfo directory\n  --archive-dir         specify alternate archive directory\n  --archive-name        specify alternate archive file name\n\nLiveview:\n  --liveview            Starts a liveview server in a separate process\n  --liveview-host HOST  Specify host for liveview server. Default is localhost\n  --liveview-port PORT  Specify port for liveview server.\n  --liveview-hostname HOSTNAME\n                        Displayed hostname for liveview.\n  --liveview-displayed-url LIVEVIEW_DISPLAYED_URL\n                        Displayed url for liveview, for example, http://<liveview_hostname>:<port>\n  --liveview-keepalive  Keep log viewer server alive after the run finishes.\n  --liveview-callback-url LIVEVIEW_CALLBACK_URL\n                        Specify xpresso callback url for jenkins run.\n  --liveview-callback-token LIVEVIEW_CALLBACK_TOKEN\n                        Specify xpresso token for jenkins run.\n\nTestbed:\n  -t, --testbed-file    Specify testbed file location\n\nClean:\n  --clean-file FILE [FILE ...]\n                        Specify clean file location(s). Multiple clean files can be specified by\n                        separating them with spaces.\n  --clean-devices [ [ ...]]\n                        Specify list of devices to clean, separated by spaces. To clean groups of\n                        devices sequentially, specify as \"[[dev1, dev2], dev3]\".\n  --clean-scope {job,task}\n                        Specify whether clean runs before job or per task\n  --invoke-clean        Clean is only invoked if this parameter is specified.\n  --clean-device-image        space separated images per device with format device:/path/to/image.bin\n  --clean-os-image            space separated images per OS with format os:/path/to/image.bin\n  --clean-group-image         space separated images per group with format group:/path/to/image.bin\n  --clean-platform-image      space separated images per platform with format platform:/path/to/image.bin\n```\n\n----------------------------------------\n\nTITLE: Upgrading PyATS with pip - Bash\nDESCRIPTION: Provides command-line instructions using pip to upgrade PyATS to version 23.6. It includes separate commands for users from the Cisco DevNet community and Cisco internal developers, reflecting different package sources or names. Requires a working Python environment with pip installed and configured for the appropriate package repository.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2023/june.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats\n```\n\nLANGUAGE: bash\nCODE:\n```\n# Cisco Internal Developers\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Developing all pyATS packages\nDESCRIPTION: This example demonstrates how to use the `pyats develop` command with the 'all' argument. This tells the command to clone and put all available pyATS packages into development mode.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/cli/pyats_develop.rst#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\npyats develop all\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyats.utils (bash)\nDESCRIPTION: This bash script upgrades the `pyats.utils` module using `pip`. The script upgrades the `pyats.utils` module to its latest version. Prerequisites: `pip` and the shell environment must be set up. Expected Output: The script will install upgraded version of the specified PyATS library. It upgrades the user's instance of `pyats.utils`.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2018/sep.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\n    bash$ pip install --upgrade pyats.utils\n```\n\nLANGUAGE: bash\nCODE:\n```\n# Cisco Internal Developers\n    bash$ pip install --upgrade ats.utils\n```\n\n----------------------------------------\n\nTITLE: Referencing Container Parenthood in pyATS AEtest Testcases - Python\nDESCRIPTION: Illustrates the use of the parent attribute to reference the container hierarchy within AEtest Testcase classes. The snippet includes checks to confirm that self refers to its container instance and that self.parent references the TestScript class instance. Requires an active AEtest execution environment and the pyats.aetest import. This code helps ensure parent-child relationships are correctly established and verifies linkage to the module object.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/behavior.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   parenthood is not easy\n#\n#   note that the same relationships described below\n#   also applies to CommonSetup & CommonCleanup\n\nimport sys\nfrom pyats import aetest\n\nclass Testcase(aetest.Testcase):\n    @aetest.setup\n    def setup(self):\n        # within a method (subsection/setup/test/cleanup)\n        # self refers to its parent. (trivial)\n        assert isinstance(self, aetest.Testcase)\n\n    @aetest.test\n    def test(self):\n        # within a method (subsection/setup/test/cleanup)\n        # self.parent refers to the Testcase parent\n        # note that Object Models: TestScript.module refers to this module\n        # so let's test this.\n        assert self.parent.module is sys.modules[__name__]\n```\n\n----------------------------------------\n\nTITLE: Invoking Tcl Procedures by String Using pyATS Tcl Interpreter eval Python\nDESCRIPTION: This snippet demonstrates how to bypass Q magic function limitations by directly invoking Tcl procedures and namespaces (including those with special characters or empty names) using tcl.eval. It is recommended for rare cases where procedure names are incompatible with Python identifiers, highlighting eval as the fallback mechanism. Takes Tcl procedure names as string literals and executes them in the interpreter context.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/tcl/q.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# continuing from the above example ...\n\ntcl.eval('procedureWith:Colon')\n\ntcl.eval('procedureWith-Dash')\n\ntcl.eval('namespaceWith/\\Slash')\n\ntcl.eval('{}')\n```\n\n----------------------------------------\n\nTITLE: Instantiating AttrDict - pyATS - Python\nDESCRIPTION: Illustrates different methods for creating AttrDict objects, including using keyword arguments, a dictionary, or a list of tuples. It behaves similarly to standard Python dictionary initialization. Requires importing AttrDict.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/datastructures/attrdict.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   attribute dictionary creations\n\nfrom pyats.datastructures import AttrDict\n\n# instantiate an AttrDict the same as how you'd instantiate a dict\nattrdict = AttrDict(key = 'value', a = 1)\n# AttrDict({'a': 1, 'key': 'value'})\n\n# you can also instantiate using a dictionary as input\nattrdict = AttrDict({'a': 1, 'key': 'value'})\n\n# or an iterable of item size 2\nattrdict = AttrDict([('a', 1), ('key', 'value')])\n```\n\n----------------------------------------\n\nTITLE: Dynamically Setting Testcase Groups at Runtime in pyATS (Python)\nDESCRIPTION: Illustrates setting the testcase execution groups dynamically during runtime within an `aetest.CommonSetup` section. This uses `aetest.runtime.groups` and logic objects (`And`, `Not`) to filter testcases based on conditions determined during the setup phase. Requires `pyats.aetest` and `pyats.datastructures.logic`.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/control.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   setting groups dynamically\n\nfrom pyats import aetest\nfrom pyats.datastructures.logic import And, Not\n\nclass CommonSetup(aetest.CommonSetup):\n\n    @aetest.subsection\n    def subsection(self):\n\n        # set groups dynamically during runtime\n        aetest.runtime.groups = And('sanity', Not('traffic'))\n```\n\n----------------------------------------\n\nTITLE: Changing Default Behavior of ConnectionManager\nDESCRIPTION: This example illustrates changing the defaults of the ConnectionManager by modifying the 'connections' attribute of the device object. It showcases how to specify a custom connection class, alias, and via path.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/connections/manager.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# if the device object had the following connections attribute\n# (note that this could be coming from loading YAML file, or set manually)\ndevice.connections = {\n    'defaults': {\n        'class': MyConnectionClass,\n        'alias': 'ironman',\n        'via': 'highway'\n    },\n    'highway': {\n        'protocol': 'telnet',\n        'ip': '1.1.1.1',\n    }\n}\n\n# the following call\n#  - would use MyConnectionClass() as the connection class,\n#  - would have a default alias of 'ironman'\n#  - and via 'highway'\ndevice.connect()\n\n# and thus the following would be true instead\ndevice.execute == device.connectionmgr.connections['highway'].execute\ntype(device.connectionmgr.connections['highway']) is MyConnectionClass\ndevice.connectionmgr.connections['highway'].via == 'highway'\n```\n\n----------------------------------------\n\nTITLE: Instantiating and Starting a pyATS Task using the `Task` Class in Python\nDESCRIPTION: This Python snippet demonstrates creating and starting a pyATS task using the `pyats.easypy.Task` class within the `main(runtime)` function. It instantiates a `Task` object for `script_one.py`, providing the `runtime` object and a custom `taskid`. The task process is then explicitly initiated by calling the `task_1.start()` method. This approach provides more control than the `run()` API but requires manual handling of starting and potentially joining/waiting for the task process. Requires the `pyats.easypy.Task` class.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/easypy/jobfile.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   job file tasks using Task() api (sequential execution)\n#   (recreating the same job file as run() api example using Task class)\n\nfrom pyats.easypy import Task\n\n# main() function\ndef main(runtime):\n\n    # using Task class to create a task object\n    # (max runtime = 60*5 seconds = 5 minutes)\n    task_1 = Task(testscript = 'script_one.py',\n                  runtime = runtime,\n                  taskid = 'example_task_1')\n\n    # start the task\n    task_1.start()\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Task Execution in pyATS\nDESCRIPTION: This snippet demonstrates how to use the Task class to create and start two tasks that run asynchronously. It includes polling to check if tasks are alive and handling potential timeouts.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/easypy/jobfile.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n    # Example\n    # -------\n    #\n    #   job file tasks using Task() api (asynchronous execution)\n\n    import time\n    from datetime import datetime, timedelta\n    from pyats.easypy import Task\n\n    # main() function\n    def main(runtime):\n\n        # using Task class to create a two tasks\n        # (max runtime = 60*5 seconds = 5 minutes)\n        task_1 = Task(testscript = 'script_one.py',\n                      runtime = runtime,\n                      taskid = 'example_task_1')\n\n        task_2 = Task(testscript = 'script_two.py',\n                      runtime = runtime,\n                      taskid = 'example_task_1')\n\n        # start both tasks simultaneously\n        task_1.start()\n        task_2.start()\n\n        # poll for tasks to finish (max of 5minutes)\n        counter = timedelta(minutes = 5)\n\n        while counter:\n            # check if processes are alive, if so, continue to wait\n            if task_1.is_alive() or task_2.is_alive():\n                time.sleep(1)\n                counter -= timedelta(seconds=1)\n            else:\n                # all is good\n                break\n        else:\n            # exceeded runtime\n            task_1.terminate()\n            task_1.join()\n            task_2.terminate()\n            task_2.join()\n\n            # raise exception\n            raise TimeoutError('Not all tasks finished in 5 minutes!')\n```\n\n----------------------------------------\n\nTITLE: YAML Pause Configuration Example\nDESCRIPTION: This YAML snippet demonstrates how to configure the 'pause_on' feature using a YAML file. It includes a timeout setting and a list of patterns to search for in log messages. Each pattern can optionally be associated with a specific section UID to limit the scope of the pause.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/debugging.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\n# Example\n# -------\n#\n#   yaml input pause file\n\ntimeout: 600        # pause a maximum of 10 minutes\n\npatterns:\n    - pattern: '.*pass.*'           # pause on all log messages including\n                                    # .*pass.* in them globally\n\n    - pattern: '.*state: down.*'    # pause whenever  'state: down' is found\n      section: '^common_setup\\..*$' # enable for all common_setup sections\n\n    - pattern: '.*should pause.*'      # pause whenever 'should pause' is found\n      section: '^TestcaseTwo\\.setup$'  # pause on TestcaseTwo setup section\n```\n\n----------------------------------------\n\nTITLE: Clean File Markup Syntax\nDESCRIPTION: This code block illustrates the supported markup syntax within clean YAML files for referencing attributes and dynamically generating content. It shows various forms of references including attributes within the clean file, device name, and testbed attributes. These markups allow for dynamic configuration of clean files.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/kleenex/inputs.rst#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n    # Syntax\n    # ------\n    #\n    #   Clean YAML markup syntax\n\n    # reference to arbitrary attribute within the clean file\n    %{a.b.c}\n\n    # reference to current clean device name.\n    # This also works under the platforms: block.\n    %{self}\n\n    # reference to attributes within the current clean device section\n    # This also works under the platforms: block.\n    %{self.x.y.z}\n\n    # reference to attributes within the testbed content.\n    %{testbed.x.y.z}\n\n    # reference to attributes within the testbed device section corresponding\n    # to the current clean device name.\n    # This also works under the platforms: block.\n    %{testbed.self.x.y.z}\n```\n\n----------------------------------------\n\nTITLE: Creating pyATS Project with CLI Arguments and Prompts - Bash\nDESCRIPTION: Shows how to use both command-line options and interactive prompts when running 'pyats create project'. Arguments specified on the CLI (e.g., project name, testbed name) are not prompted, while others still require user input. The example illustrates installation checks, datafile prompts, and final project folder generation. Requires pyATS with '[template]' extras and optionally a testbed definition.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/cli/pyats_create.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# Example\n# -------\n#\n#   creating a pyats project by adding some options and arguments in the command line and the rest through prompts\n#   notes:\n#   - the arguments that were specified through the CLI command will not be prompted\n#   - the arguments that were not specified through the CLI command will be prompted\n#   - the order of the arguments does not matter\n\nbash$ pyats create project --project_name my-project --testbed_name my-testbed\nChecking if cookiecutter is installed...\ninclude_datafile: yes\ndatafile_name: my-datafile\nnumber_of_test_cases: 2\nGenerating your project...\nmy-project has been generated in your current directory\n```\n\n----------------------------------------\n\nTITLE: Accessing Runtime Information in pyATS Easypy Jobfile (Python)\nDESCRIPTION: This Python snippet illustrates how to access the 'runtime' object provided by Easypy within a job file's 'main' function. It demonstrates passing the runtime directory ('runtime.directory') as an argument to a test script launched using the 'run()' function. The 'runtime' object is automatically injected by the Easypy engine when defined as a parameter in 'main', providing access to various job and environment details.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/easypy/behavior.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   querying runtime information inside jobfile\n\nfrom pyats import easypy\n\n# use special argument runtime in main() argument list\n# the engine automatically passes in the runtime object\ndef main(runtime)\n\n    # pass in runtime directory as an argument to testscript\n    run('script.py', directory = runtime.directory)\n```\n\n----------------------------------------\n\nTITLE: Upgrading multiple PyATS modules for April 5, 2018 release\nDESCRIPTION: Bash commands to upgrade multiple PyATS packages including aetest, easypy, topology, and utils. Separate commands are provided for DevNet Community and Cisco Internal Developers.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2018/apr.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats.aetest pyats.easypy pyats.topology pyats.utils\n\n# Cisco Internal Developers\nbash$ pip install --upgrade ats.aetest ats.easypy ats.cisco ats.topology ats.utils\n```\n\n----------------------------------------\n\nTITLE: pyATS Logs Usage\nDESCRIPTION: Displays the general usage and available subcommands for the `pyats logs` command.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/cli/pyats_logs.rst#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nUsage:\n  pyats logs <subcommand> [options]\n\nSubcommands:\n    list                list all log archives\n    view                open and view log archives in browser\n\nGeneral Options:\n  -h, --help            Show help\n  -v, --verbose         Give more output, additive up to 3 times.\n  -q, --quiet           Give less output, additive up to 3 times, corresponding to WARNING, ERROR,\n                        and CRITICAL logging levels\n```\n\n----------------------------------------\n\nTITLE: Testing ats.results Boolean Evaluation - Python\nDESCRIPTION: Demonstrates how result objects from 'ats.results' are evaluated as boolean values, with 'Passed' or 'Passx' returning True and other results returning False. Requires the 'ats.results' module. Intended for use in automation logic or reporting scripts that need quick pass/fail checks based on test result objects.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2015/june.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom ats.results import *\n\nbool(Passed)\n```\n\n----------------------------------------\n\nTITLE: Defining Telnet Connection Class\nDESCRIPTION: This snippet defines the `TelnetConnection` class, which inherits from `BaseConnection`. This class provides a sample implementation of a Telnet connection, demonstrating how to use the BaseConnection class.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/connections/class.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass TelnetConnection(BaseConnection):\n    '''TelnetConnection\n\n    Sample implementation of Telnet connection to linux, based on pyATS\n    BaseConnection, allowing devices to telnet to end routers\n    '''\n```\n\n----------------------------------------\n\nTITLE: Importing and Inheriting AEtest Testcases in Python\nDESCRIPTION: Shows how to import a testcase class from another script in Python using AEtest. Importing alone (`from another_script import AnotherTestcase`) makes the class available but doesn't execute it. To include and run the testcase, it must be inherited by a local class (`class LocalTestcase(AnotherTestcase): pass`).\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/introduction.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# this only imports it for inheriting options.\n# does not run it\nfrom another_script import AnotherTestcase\n\n# this includes it into this script\nclass LocalTestcase(AnotherTestcase):\n    pass\n```\n\n----------------------------------------\n\nTITLE: Example Output of pyATS Rerun\nDESCRIPTION: Demonstrates the expected output from running a pyATS job with the `--rerun-file` and `--rerun-condition` parameters.  It shows the execution of `Task-1` and skips `Task-2` because the `rerun-condition` is set to 'Failed'. It includes the output from the common setup, testcase execution and cleanup.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/easypy/rerun.rst#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\nbash$ pyats run job basic_example_job.py --rerun-file path/to/rerun.results --rerun-condition Failed\n%EASYPY-INFO: Starting job run: basic_example_job\n%EASYPY-INFO: Starting task execution: Task-1\n%EASYPY-INFO:     test harness = ats.aetest\n%EASYPY-INFO:     testscript   = path/to/script\n%AETEST-INFO: +------------------------------------------------------------------------------+\n%AETEST-INFO: |                            Starting common setup                             |\n%AETEST-INFO: +------------------------------------------------------------------------------+\n%AETEST-INFO: +------------------------------------------------------------------------------+\n%AETEST-INFO: |                   Starting subsection sample_subsection_1                    |\n%AETEST-INFO: +------------------------------------------------------------------------------+\n%SCRIPT-INFO: Aetest Common Setup\n%AETEST-INFO: The result of subsection sample_subsection_1 is => PASSED\n%AETEST-INFO: +------------------------------------------------------------------------------+\n%AETEST-INFO: |                   Starting subsection sample_subsection_2                    |\n%AETEST-INFO: +------------------------------------------------------------------------------+\n%SCRIPT-INFO: Inside subsection sample_subsection_2\n%SCRIPT-INFO: Inside class common_setup\n%AETEST-INFO: The result of subsection sample_subsection_2 is => PASSED\n%AETEST-INFO: The result of common setup is => PASSED\n%AETEST-INFO: +------------------------------------------------------------------------------+\n%AETEST-INFO: |                           Starting testcase tc_one                           |\n%AETEST-INFO: +------------------------------------------------------------------------------+\n%AETEST-INFO: +------------------------------------------------------------------------------+\n%AETEST-INFO: |                      Starting section prepare_testcase                       |\n%AETEST-INFO: +------------------------------------------------------------------------------+\n%SCRIPT-INFO: Preparing the test\n%SCRIPT-INFO: section prepare_testcase\n%AETEST-INFO: The result of section prepare_testcase is => PASSED\n%AETEST-INFO: +------------------------------------------------------------------------------+\n%AETEST-INFO: |                        Starting section simple_test_1                        |\n%AETEST-INFO: +------------------------------------------------------------------------------+\n%SCRIPT-INFO: First test section\n%AETEST-INFO: The result of section simple_test_1 is => PASSED\n%AETEST-INFO: +------------------------------------------------------------------------------+\n%AETEST-INFO: |                        Starting section simple_test_2                        |\n%AETEST-INFO: +------------------------------------------------------------------------------+\n%SCRIPT-INFO: Second test section\n%AETEST-INFO: The result of section simple_test_2 is => PASSED\n%AETEST-INFO: +------------------------------------------------------------------------------+\n%AETEST-INFO: |                       Starting section clean_testcase                        |\n%AETEST-INFO: +------------------------------------------------------------------------------+\n%SCRIPT-INFO: Pass testcase cleanup\n%AETEST-INFO: The result of section clean_testcase is => PASSED\n%AETEST-INFO: The result of testcase tc_one is => PASSED\n%AETEST-INFO: +------------------------------------------------------------------------------+\n%AETEST-INFO: |                           Starting testcase tc_two                           |\n%AETEST-INFO: +------------------------------------------------------------------------------+\n%AETEST-WARNING: Section 'tc_two' does not match up to: Or('common_setup', 'tc_one', 'common_cleanup')\n%AETEST-WARNING: Skipping section...\n%AETEST-INFO: The result of testcase tc_two is => SKIPPED\n%AETEST-INFO: +------------------------------------------------------------------------------+\n%AETEST-INFO: |                           Starting common cleanup                            |\n```\n\n----------------------------------------\n\nTITLE: Upgrading PyATS utils and easypy modules for April 11, 2018 release\nDESCRIPTION: Bash command to upgrade ats.utils and ats.easypy packages to versions 4.1.2. This command is specifically for Cisco Internal Developers.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2018/apr.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# Cisco Internal Developers\nbash$ pip install --upgrade ats.utils ats.easypy\n```\n\n----------------------------------------\n\nTITLE: pyATS Validate Usage\nDESCRIPTION: This shows the general usage of the `pyats validate` command with its subcommands. It illustrates how to access help and adjust verbosity levels.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/cli/pyats_validate.rst#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nUsage:\n  pyats validate <subcommand> [options]\n\nSubcommands:\n    datafile            validate your YAML-based datafile syntax\n    jinja2_config       validate genie config file jinja2 rendering\n    testbed             validate your testbed file yaml syntax\n\nGeneral Options:\n  -h, --help            Show help\n  -v, --verbose         Give more output, additive up to 3 times.\n  -q, --quiet           Give less output, additive up to 3 times, corresponding to WARNING, ERROR,\n                        and CRITICAL logging levels\n```\n\n----------------------------------------\n\nTITLE: Upgrading ats.kleenex and ats.easypy using pip (Bash)\nDESCRIPTION: This shell command utilizes pip, the Python package installer, to upgrade the specified Python packages (ats.kleenex and ats.easypy) to their latest available versions. Requires pip to be installed and accessible in the execution environment.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2017/oct.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install --upgrade ats.kleenex ats.easypy\n```\n\n----------------------------------------\n\nTITLE: Upgrading ats.kleenex Module Using pip - Bash\nDESCRIPTION: This Bash snippet upgrades the ats.kleenex module via pip package manager. It is used to update topology and bringup capabilities for the pyATS framework. Prerequisites: Ensure pip is installed and the user has sufficient permissions. The input is implicit; execution outputs pip logs indicating the update status. Limitations: The command expects internet access and correct Python environment setup.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2016/november.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats.kleenex\n```\n\n----------------------------------------\n\nTITLE: pyATS Run Manifest Usage\nDESCRIPTION: This snippet shows the command-line usage of the `pyats run manifest` subcommand. It outlines the command syntax for executing a test script based on a manifest file. Key options include specifying the manifest filename and providing an optional execution profile.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/cli/pyats_run.rst#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nUsage:\n  pyats run manifest [options]\n\nExample\n-------\n  pyats run manifest <filename>\n  pyats run manifest <filename> --profile s2c\n  pyats run manifest <filename> --profile local\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Section Execution Order and Inheritance in AEtest Scripts - Python\nDESCRIPTION: Demonstrates how AEtest script containers and section methods are executed in a specific, logical order, with parent classes' test sections running before child extensions. Requires pyats.aetest and a base_script module defining a BaseTestcase with @aetest.test methods. The code shows inheritance in action and prints output to confirm the order of test execution. Suitable for illustrating inheritance, ordering, and framework conventions in AEtest.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/behavior.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nExample\n# -------\n#\n#   section ordering example\n\nfrom pyats import aetest\n\n# assume that we are importing another testcase from a base_script\n# and inheriting it to create a new, extended testcase\nfrom base_script import BaseTestcase\n\n# pretend that the BaseTase looks like this\n# class BaseTestcase(self):\n#\n#     @aetest.test\n#     def test_one(self):\n#         print('i am test 1')\n#\n#     @aetest.test\n#     def test_two(self):\n#         print('i am test 2')\n\n# the local testcase inherits it\nclass LocalTestcase(BaseTestcase):\n\n    @aetest.test\n    def test_three(self):\n        print('i am test 3')\n\n# when this local test is run,\n# the two tests from parent class runs first.\ntc = LocalTestcase()\nprint(tc())\n# i am test 1\n# i am test 2\n# i am test 3\n```\n\n----------------------------------------\n\nTITLE: Configuring logging with Formatters in pyATS\nDESCRIPTION: This snippet demonstrates configuring logging using standard handlers and formatters within the pyATS framework, especially when running standalone or outside of EasyPy. It imports the necessary formatter classes, creates standard logging handlers (StreamHandler and FileHandler), sets the formatters for each handler, attaches the handlers to a logger, and sets the logging level to DEBUG. The output appears on the screen and to a specified file with the pyATS formatting.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/log/examples.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nimport logging\n\nfrom pyats.log import ScreenFormatter, TaskLogFormatter\n\n# create a logger\nlogger = logging.getLogger(__name__)\n\n# creating handlers using logging standard handlers\nscreen_handler = logging.StreamHandler(stream = sys.stdout)\ntasklog_handler = logging.FileHandler('/path/to/logfile.txt')\n\n# set handler to use ats format and screen format\nscreen_handler.setFormatter(ScreenFormatter())\ntasklog_handler.setFormatter(TaskLogFormatter())\n\n# attach to your logger\nlogger.addHandler(screen_handler)\nlogger.addHandler(tasklog_handler)\n\n# set log level to show everything\nlogger.setLevel(logging.DEBUG)\n```\n\n----------------------------------------\n\nTITLE: Looping with uids and parameters in PyATS\nDESCRIPTION: This example shows how to use `uids`, `args`, and `argvs` together to control loop iterations.  The number of iterations is determined by the number of `uids`. If the number of parameters is greater than the number of uids the additional values will be discarded. The code demonstrates two approaches (args/argvs and keyword args) to pass parameter values within each iteration with matching uids.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/loop.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.aetest import loop\n\n# loop with 2 iterations, and extra arguments are discarded due to uids\n# ---------------------------------------------------------------------\n#   iteration 1: uid='id_one', a=1, b=2\n#   iteration 2: uid='id_two', a=3, b=4\n# extra argument values 5/6 are discarded because there are no matching uids\n@loop(uids=['id_one', 'id_two'],\n      args=['a', 'b'],\n      argvs=[(1, 2),\n             (3, 4),\n             (5, 6)])\n# same example as above but using per-parameter values\n@loop(uids=['id_one', 'id_two'],\n      a=[1, 3, 5], b=[2, 4, 6])\n```\n\n----------------------------------------\n\nTITLE: Defining pyATS YAML Markup Syntax (Text)\nDESCRIPTION: Provides the syntax reference for various pyATS YAML markups, including variable substitution (%{}), interface mapping (%INTF{}), environment variables (%ENV{}), callable execution (%CALLABLE{}), file inclusion (%INCLUDE{}), user prompts (%ASK{}), encoded strings (%ENC{}), CLI argument handling (%CLI{}), and list extension (%EXTEND_LIST{}). Explains the purpose and basic usage rules for each markup form.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/yaml_markup.rst#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n# Syntax\n# ------\n#\n#   YAML markup syntax\n\n# basic syntax\n# ------------\n#   %{<path>.<path>.<...>}\n#   %{<path>.<path>.<...>.keys()}\n#   %INTF{logical_interface_name}\n#   %ENV{environment_variable_name}\n#   %CALLABLE{path_to_callable}\n#   %CALLABLE{path_to_callable(param1,param2,param3)}\n#   %CALLABLE{path_to_callable(param1='val1',param2='val2')}\n#   %INCLUDE{yaml_file_path}\n#   %ASK{optional prompt text}\n#   %ENC{encoded text}\n#   %ENC{encoded text, prefix=x}\n#   %CLI{cli_argument_name}\n#   %CLI{another_cli_arg, default=<value>}\n#   %CLI{another_list, default=[<value>,<value>]}\n#   %EXTEND_LIST{key}\n#   %EXTEND_LIST{path.to.value1,path.to.value2}\n#\n#   - use %{ } to denote the begin and end of a markup block\n#   - use . to separate reference path\n#   - use 'self' as first word to reference current device\n#   - use '.keys()' to get the key values for a path\n#   - The %INTF{ } form causes the logical interface name to be\n#     replaced with the actual interface name from the\n#     device's topology block.\n#   - The %ENV{ } form causes the environment variable name to be\n#     replaced with the actual environment value from the os.\n#   - The %CALLABLE{ } form causes the callable to be replaced with the\n#     actual return value from the callable. All defined parameters\n#     will be passed to the callable.\n#   - The %INCLUDE{ } form causes the yaml file path to be replaced\n#     with the actual content of the yaml file.\n#   - The %ASK{ } form causes the user to be prompted to enter information\n#     manually.\n#   - The %ENC{ } form causes an encoded string to be replaced with a\n#     decoded string or secret string which supports decoding.\n#   - The %CLI{ } form replaces the variable name with the value provided\n#     from the command line argument. If no command line argument was\n#     provided for this variable, the value will be an empty string.\n#     Supports single and double dash argument style. A default value\n#     can be specified using `, default=` syntax. A list can be specified\n#     as default value.\n#   - The %EXTEND_LIST{ } form can be used for keys to extend a list\n#     from another YAML file. The same syntax can also be used to create\n#     a value by extending one or more list references.\n```\n\n----------------------------------------\n\nTITLE: Initializing and Connecting AEClient to AEReport Server in Python\nDESCRIPTION: Illustrates the Python code for creating an `AEClient` instance, providing the server's port and name obtained from starting the server (`start_server`), and then connecting to it using the `connect()` method. This step is part of the AEReport usage tutorial and establishes communication between the test script and the reporting server.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aereport/index.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> from pyats.aereport.client import AEClient\n>>> clt = AEClient(port=svrport,servername=servername)\n>>> clt.connect()\n```\n\n----------------------------------------\n\nTITLE: Accessing the Step Object in pyATS AEtest\nDESCRIPTION: Shows how to access and use the step object returned by steps.start() using the 'as' keyword. The example demonstrates accessing the step's index attribute.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/steps.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   referring to the step object\n\nfrom pyats import aetest\n\nclass Testcase(aetest.Testcase):\n\n    @aetest.test\n    def test(self, steps):\n\n        # create step into 'step' variable\n        with steps.start('the first step') as step:\n            # eg, each step is automatically assigned a unique,\n            # numeric index number, and can be accessed using the\n            # \"index\" attribute.\n            print('Current step index: ', step.index)\n            # Current step index: 1\n```\n\n----------------------------------------\n\nTITLE: Developing multiple pyATS packages from external repos\nDESCRIPTION: This example demonstrates putting multiple packages (`genie.libs.parser` and `genie.trafficgen`) into development mode. The `--external` flag forces the command to clone public external repositories instead of internal ones, which is particularly useful when using an internal Cisco pyATS installation but wanting to work with public code.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/cli/pyats_develop.rst#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\npyats develop genie.libs.parser genie.trafficgen --external\n```\n\n----------------------------------------\n\nTITLE: Applying pyATS aetest Processors to Testcases and Sections (Python)\nDESCRIPTION: Provides a practical pyATS aetest script demonstrating the usage of pre-, post-, and exception processors. It shows defining processor functions that accept `section`, `processor`, or exception details, and attaching them using decorators to a Testcase and a specific test method, including an example of handling exceptions and modifying test results.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/processors.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   simple pre/post/exception processor example\n\nfrom pyats import aetest\n\n# define a function that prints the section's uid\ndef print_uid(section):\n    print('current section: ', section.uid)\n\n# define a function that prints the section result\ndef print_result(section):\n    print('section result: ', section.result)\n\n# define another function that prints the exception message and suppress the\n# exception\ndef print_exception_message(section, exc_type, exc_value, exc_traceback):\n    print('exception : ', exc_type, exc_value)\n    return True\n\n# use the above functions as pre/post/exception processors to a Testcase\n#   pre-processor  : print_uid\n#   post-processor : print_result\n#   exception-processor : print_exception_message\n@aetest.processors(pre = [print_uid],\n                   post = [print_result],\n                   exception = [print_exception_message])\nclass Testcase(aetest.Testcase):\n\n    @aetest.test\n    def test(self):\n        print('running testcase test section')\n\n    @aetest.test\n    def testException(self):\n        raise Exception('running testcase testException section')\n\n# define a function that fails when a section does not set a parameter, this\n# will propagate the failure to the parent section\ndef fail_if_not_a(processor):\n    a = processor.parameters.get('a')\n    if not a:\n        processor.failed('a was not set to True')\n\nclass Testcase2(aetest.Testcase):\n    # use fail_if_not_a as a post-processor on only this test section\n    @aetest.processors.post(fail_if_not_a)\n    @aetest.test\n    def test(self):\n        self.parameters['a'] = False\n\n# script output\n#   - notice that the processors ran immediately before and after the\n#     testcase execution.\n#\n#     +------------------------------------------------------------------------------+\n#     |                          Starting testcase Testcase                          |\n#     +------------------------------------------------------------------------------+\n#     +------------------------------------------------------------------------------+\n# ->  |                     Starting PreProcessor-1 'print_uid'                      |\n#     +------------------------------------------------------------------------------+\n# ->  current section:  Testcase\n#     +------------------------------------------------------------------------------+\n#     |                            Starting section test                             |\n#     +------------------------------------------------------------------------------+\n#     running testcase test section\n#     The result of section test is => PASSED\n#     +------------------------------------------------------------------------------+\n#     |                        Starting section testException                        |\n#     +------------------------------------------------------------------------------+\n#     +------------------------------------------------------------------------------+\n# ->  |           Starting ExceptionProcessor-1 'print_exception_message'            |\n#     +------------------------------------------------------------------------------+\n# ->  exception :  <class 'Exception'> running testcase testException section\n# ->  The result of section testException is => PASSED\n#     +------------------------------------------------------------------------------+\n# ->  |                   Starting PostProcessor-1 'print_result'                    |\n#     +------------------------------------------------------------------------------+\n# ->  section result:  passed\n#     The result of testcase Testcase is => PASSED\n#     +------------------------------------------------------------------------------+\n#     |                         Starting testcase Testcase2                          |\n#     +------------------------------------------------------------------------------+\n#     +------------------------------------------------------------------------------+\n#     |                            Starting section test                             |\n#     +------------------------------------------------------------------------------+\n#     +------------------------------------------------------------------------------+\n# ->  |                   Starting PostProcessor-1 'fail_if_not_a'                   |\n#     +------------------------------------------------------------------------------+\n#     The result of PostProcessor-1 'fail_if_not_a' is => FAILED\n#     The result of section test is => FAILED\n#     The result of testcase Testcase2 is => FAILED\n```\n\n----------------------------------------\n\nTITLE: Creating Tcl Keyed Lists in Python\nDESCRIPTION: This code demonstrates the creation and usage of Tcl keyed lists within Python using the `pyats.tcl` module and the `KeyedList` class. It shows how to create a keyed list in Tcl using the `keylset` command and then reads it into a Python `KeyedList` object using `get_keyed_list`. It shows how to access key-value pairs, including nested keyed lists using a '.' separator. The `KeyedList` behaves like a nested dictionary and allows for chaining.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/tcl/datastructures.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats import tcl\nfrom pyats.tcl import KeyedList\n\n# create a keyed-list in Tcl\ntcl.eval('keylset myKeyedList a.x 1 a.y 2 b 3')\n# the content is now:\n# {'a': {'y': '2', 'x': '1'}, 'b': '3'}\n\n# now read it to Python\nklist = tcl.get_keyed_list('myKeyedList') \n\n# note the behaviors:\n#  - keys and subkeys separator via .\n#  - the content of a keyed list can be also another keyed list\nassert 'a' in klist\nassert 'a.y' in klist\nassert type(klist['a']) is KeyedList\n\n# getting values\nsub_klist_a = klist['a']\n# this returns another keyed-list\n# with content: {'y': '2', 'x': '1'}\n\n# getting key.subkey values\nassert klist['a.x'] == '1'\n\n# because key a contains sub-keyedlist with x and y\n# in Python we can chain the index [] behavior without using .\nassert klist['a']['x'] is klist['a.x']\n# note that it's probably easier to use .\n# but the idea here is to show how the objects work\n```\n\n----------------------------------------\n\nTITLE: Using pyATS Clean Standard Arguments in Bash\nDESCRIPTION: Examples demonstrating usage of command line arguments accepted by Kleenex in both decoupled and Easypy modes. The snippets show how to specify testbed files, clean files, and selectively clean specific devices, including complex nested device groups. These arguments control device targeting and configuration for cleaning workflows.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/kleenex/usages.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pyats clean -help\n```\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pyats clean -testbed_file /path/to/my/testbed.yaml\n```\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pyats clean --testbed-file /path/to/my/testbed.yaml\\\n              --clean-file /path/to/my/clean.yaml\n```\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pyats run job jobfile.py --testbed-file /path/to/my/testbed.yaml\\\n                               --clean-file /path/to/my/clean.yaml\\\n                               --clean-devices device_a device_b device_c\\\n                               --invoke-clean\n```\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pyats run job jobfile.py --testbed-file /path/to/my/testbed.yaml\\\n                               --clean-file /path/to/my/clean.yaml\\\n                               --clean-devices \"[[device_a, device_b, device_c], [device_d, device_e]]\"\\\n                               --invoke-clean\n```\n\n----------------------------------------\n\nTITLE: pyATS Validate Datafile Schema Example\nDESCRIPTION: This example validates an AEtest datafile against a schema using `pyats validate datafile` with the `--schema` option. It shows the loaded datafile content and YAML lint messages after schema validation.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/cli/pyats_validate.rst#_snippet_5\n\nLANGUAGE: text\nCODE:\n```\n# Example\n# -------\n#\n#   validating an AEtest datafile against schema\n#   (eg, datafile schema is available as:\n#    from pyats.aetest.datafile.schema import datafile_schema)\n\nbash$ pyats validate datafile examples/comprehensive/data/base_datafile.yaml --schema pyats.aetest.datafile.schema.datafile_schema\nLoading datafile: examples/comprehensive/data/base_datafile.yaml\n--------------------------------------------------------------------------------\n{'parameters': {'parameter_A': 'datafile value A',\n                    'parameter_B': 'datafile value B'},\n'testcases': {'ExampleTestcase': {'data_A': 'attribute data A',\n                                      'data_B': 'attribute data B',\n                                      'description': 'block of text describing '\n                                                      'what this testcase does\\n',\n                                      'groups': ['group_A',\n                                                  'group_B',\n                                                  'group_C',\n                                                  'group_D'],\n                                      'parameters': {'local_A': 'datafile value A',\n                                                      'local_B': 'datafile value '\n                                                                'B'},\n                                      'uid': 'ExampleTestcaseDatafileID'},\n                  'LoopedTestcase': {'groups': []},\n                  'TestcaseWithSteps': {'uid': 'TestcaseWithStepsDatafileID'}}}\n\nYAML Lint Messages\n------------------\n  5:75      error    trailing spaces  (trailing-spaces)\n  19:42     error    trailing spaces  (trailing-spaces)\n  53:1      error    trailing spaces  (trailing-spaces)\n  72:41     error    no new line character at the end of file  (new-line-at-end-of-file)\n```\n\n----------------------------------------\n\nTITLE: pyATS Logs View Usage\nDESCRIPTION: Displays the usage and options for the `pyats logs view` subcommand, which opens pyATS archive zip files or runinfo directories and hosts them through an HTTP server. It lists options for specifying the archive, host, port, and browser behavior.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/cli/pyats_logs.rst#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nUsage:\n  pyats logs view [archive] [options]\n\nDescription:\n  Opens pyATS generated archive zip files and host them through HTTP server.\n\n  Behavior:\n      - List all archives stored in standard known archive locations in reverse\n        order on webpage.\n      - Click to view detail results of an archive.\n      - set environment variable $BROWSER to your browser executable to force using\n        your provided browser\n      - if liveview is enabled, opens the lastest running job.\n\n  Examples:\n      # opens the archive list page\n      $ pyats logs view\n\n      # open the last archive file\n      $ pyats logs view --latest\n\n      # open a specific archive file\n      $ pyats logs view /path/to/archive.zip\n\nView Options:\n  [archive/runinfo_dir] Archive zip file or runinfo directory to open and view.\n  --latest              If provided, open last archive file, else, open result list page.\n  --host [host]         Host interface to bind to. Default to: localhost\n  --port [port]         Interface port to bind to. Default to: 0\n  --hostname [hostname] Displayed hostname for logviewer/liveview.\n  --reuse-port          Flag when set, reuses a TCP port in TIME_WAIT state\n  --no-browser          Flag to turn off the default behavior of opening a new browser window.\n  --liveview            Flag to enable liveview. Default to: False\n\nGeneral Options:\n  -h, --help            Show help\n  -v, --verbose         Give more output, additive up to 3 times.\n  -q, --quiet           Give less output, additive up to 3 times, corresponding to WARNING, ERROR,\n                        and CRITICAL logging levels\n```\n\n----------------------------------------\n\nTITLE: Full pyATS Package Upgrade Instructions Using Bash\nDESCRIPTION: Bash shell commands for fully upgrading the pyATS framework packages to the April 28, 2020 release versions. These instructions differentiate between DevNet Community users, who upgrade 'pyats' packages, and Cisco Internal Developers, who upgrade 'ats' packages. Executing these commands updates multiple modules to version 20.4 or newer as specified in the release notes, enabling new features such as improved Reporter subscriptions, Liveview UI, and pyats.contrib package availability.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2020/apr.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats\n\n# Cisco Internal Developers\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Specific Tcl to Python Typecasting with cast_* methods (Python)\nDESCRIPTION: Illustrates using dedicated casting methods like `tcl.cast_int()`, `tcl.cast_double()`, `tcl.cast_boolean()`, `tcl.cast_list()`, `tcl.cast_array()`, and `tcl.cast_keyed_list()` for explicit and safer conversion of Tcl string representations into specific Python object types (int, float, bool, tuple, Tcl.Array, Tcl.KeyedList). This provides more control over the conversion process than automatic casting. Requires the `pyats.tcl` library.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/tcl/variables.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n# \n#   performing specific casting of returns from Tcl\n\nfrom pyats import tcl\n\n# Tcl Integers\n# ------------\ntcl.cast_int('9999')\n9999\n\n# Tcl Doubles\n# -----------\ntcl.cast_double('3.1415926')\n3.1415926\n\n# casting Tcl Booleans\n# --------------------\ntcl.cast_boolean('1')\nTrue\ntcl.cast_boolean('0')\nFalse\n\n# Tcl Lists\n# ----------\n#   casting a Tcl list into Python tuple\ntcl.cast_list('a b c')\n('1', '2', '3')\ntcl.cast_list('a b c {1 2 3}')\n('a', 'b', 'c', '1 2 3')\n# casting Tcl list and also convert list element into Python objects\ntcl.cast_list('1 2 3', item_cast=int)\n(1, 2, 3)\n\n# Tcl Arrays\n# ----------\n#   casting a Tcl array into ats.tcl.Array class\n#   note that this expects an array in the form of [array get name], eg.\n#   a list of key/value pairs.\ntcl.eval('set myArray(a) 1')\ntcl.eval('set myArray(b) 2')\narray_string = tcl.eval('array get myArray')\ntcl.cast_array(array_string)\nArray({'a': '1', 'b': '2'})\n# casting arrays and also converting array content into Python objects\ntcl.cast_array(array_string, int)\nArray({'a': 1, 'b': 2})\n\n# Tcl Keyed Lists\n# ---------------\n#   casting Tcl keyed lists into ats.tcl.KeyedList class\ntcl.eval('keylset klist a 1 b.c 2 d.e.f 3')\nklist_string = tcl.vars['klist']\ntcl.cast_keyed_list(klist_string)\nKeyedList({'a': '1', \n               'b': KeyedList({'c': '0'}), \n               'd': KeyedList({'e': KeyedList({'f': '1'})})})\n# casting keyed lists and converting their content into Python objects\ntcl.cast_keyed_list(klist_string, bool)\nKeyedList({'a': True, \n               'b': KeyedList({'c': False}), \n               'd': KeyedList({'e': KeyedList({'f': True})})})\n```\n\n----------------------------------------\n\nTITLE: Retrieving Authentication Credentials using get_auth (Python)\nDESCRIPTION: Demonstrates calling the `get_auth` method on a `FileUtils` instance (initialized with a testbed `tb`), passing a server name or IP address (`server_name`). This method retrieves the corresponding username and password stored within the associated `pyats` testbed configuration for that server, returning them as a tuple.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/file_transfer_utilities.rst#_snippet_29\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.utils.fileutils import FileUtils\nfutils = FileUtils(testbed=tb)\nusername, password = futils.get_auth(server_name)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Raw Tcl String Returns from pyATS Interpreter in Python\nDESCRIPTION: This snippet shows how to get return values from Tcl commands as raw Python strings via the pyATS Interpreter eval() method. It demonstrates setting a Tcl variable to a number, reading it back into Python as a string, creating and calling a Tcl procedure returning its arguments, and verifying that the returned values are strings consistent with Tcl's string-based data model. It also explains the difference between reading variables via 'set' versus output-only commands like 'puts'.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/tcl/tcl.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats import tcl\n\ntcl.eval('set myVariable %s' % 9999)\nmyVar = tcl.eval('set myVariable')\nassert type(myVar) is str\n\ntcl.eval('proc myTestProcedure {args} {return $args}')\nret = tcl.eval('myTestProcedure -argA 1 -argB 2')\nassert ret == '-argA 1 -argB 2'\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyATS Using pip in Bash\nDESCRIPTION: This snippet demonstrates how to upgrade the pyATS framework to version 24.5 using the pip package manager in a bash shell environment. Users are instructed to run the command according to their user group: DevNet Community should install the 'pyats' package and Cisco Internal Developers should upgrade the 'ats' package. No additional dependencies are required besides pip and network access to the appropriate package index. The expected input is a bash command line and the output is an upgraded pyATS installation. The snippet should be executed within a shell with the correct permissions.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2024/may.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats\n\n# Cisco Internal Developers\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Illustrating pyATS YAML Markup Usage (Text)\nDESCRIPTION: Demonstrates practical examples of using pyATS YAML markups for referencing device attributes (%{self.*}), logical interfaces (%INTF{}), arbitrary YAML attributes (%{a.b.c}), attribute keys (%{d.e.keys()}), environment variables (%ENV{}), calling functions with and without parameters (%CALLABLE{}), including other YAML files (%INCLUDE{}), prompting users (%ASK{}), handling encoded secrets (%ENC{}), and processing command-line arguments (%CLI{}) including flags, lists, typed values, and defaults.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/yaml_markup.rst#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n# reference to current device name\n%{self}\n\n# reference to attributes within current device\n%{self.x.y.z}\n\n# reference to logical interface within current device\n# (replaced with actual interface name)\n%INTF{logical_interface_name}\n\n# reference to arbitrary attribute within this YAML file\n%{a.b.c}\n\n# reference to the list of keys of this attribute within this YAML file\n%{d.e.keys()}\n\n# reference to environment variable from the os\n# (replaced with actual environment variable name)\n%ENV{environment_variable_name}\n\n# reference to callable without parameter\n# (replaced with actual path to callable)\n%CALLABLE{path.to.callable}\n\n# reference to callable with parameters param1, param2 and param3\n# (replaced with actual path to callable)\n%CALLABLE{path.to.callable(param1,param2,param3)}\n\n# reference to callable with paramter param1 and\n# kwarg style parameter param2\n%CALLABLE{path.to.callable(param1, param2='val1')}\n\n# reference to content from other YAML file\n# (replaced with actual path to YAML file)\n%INCLUDE{yaml_file_path}\n\n# prompt user to enter string content manually\n%ASK{optional prompt text}\n\n# Reference to text encoded with \"pyats secret encode\" command\n# Encoded credential passwords are substituted by secret strings.\n# Other encoded references are substituted with their decoded string.\n# See secret strings documentation for details.\n%ENC{<encoded text>}\n\n# Reference to text encoded with \"pyats secret encode --prefix x\" command.\n# Encoded credential passwords are substituted by secret strings.\n# Other encoded references are substituted with their decoded string.\n# See secret strings documentation for details.\n%ENC{<encoded text>, prefix=x}\n\n# Reference to \"some_arg\" will be replaced by \"some_value\" if\n# the command line \"pyats run job --some_arg some_value\" is used.\n%CLI{some_arg}\n\n# If the command line argument is provided without a value,\n# the value is set to boolean 'True'. The following command line\n# sets the value for \"some_flag\" to True.\n# \"pyats run job --some_flag\"\n%CLI{some_flag}\n\n# If the command line argument has multiple values,\n# the variable is replaced with a list of values.\n# The following command line argument creates a list\n# of values in place of the devices variable.\n# \"pyats run job --devices R1 R2\"\n%CLI{devices}\n\n# If the command line argument contains a number value,\n# either integer or float, the variable is converted from\n# a string to an integer or float.\n# \"pyats run job --retries 3\"\n%CLI{retries}\n\n# A default value can be specified for the %CLI markup.\n%CLI{another_flag, default=12}\n\n# A default value can be a list\n%CLI{another_flag, default=[1,2]}\n```\n\n----------------------------------------\n\nTITLE: Upgrading specific pyATS Module using pip (Bash)\nDESCRIPTION: Provides the standard command to upgrade a specific pyATS module (e.g., ats.aetest, ats.connections) using the pip package manager in a bash shell. This instruction is applicable for upgrading from version v2.0.1+ onwards. Requires Python and pip installed and configured.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2015/october.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats.aetest\n```\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats.connections\n```\n\n----------------------------------------\n\nTITLE: pyATS Validate Jinja2 Config Usage\nDESCRIPTION: Shows the usage of `pyats validate jinja2_config`.  It validates Genie configuration datafiles for Jinja2 rendering, requires a testbed file, and allows specifying devices and sequences.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/cli/pyats_validate.rst#_snippet_6\n\nLANGUAGE: text\nCODE:\n```\nUsage:\n  pyats validate jinja2_config [file] [options]\n\nDescription:\n  Validates the provided genie config file for jinja2 rendering.\n\nJinja2_config Options:\n  [file]                Genie config datafile to validate\n  --testbed-file TESTBED\n                            Testbed file (required)\n  --devices DEVICES [DEVICES ...]\n                            Devices to render configs for (optional)\n  --sequence SEQUENCE [SEQUENCE ...]\n                            Sequence(s) to render (optional)\n\nGeneral Options:\n  -h, --help            Show help\n  -v, --verbose         Give more output, additive up to 3 times.\n  -q, --quiet           Give less output, additive up to 3 times, corresponding to WARNING, ERROR,\n                        and CRITICAL logging levels\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyats.easypy (Community) - bash\nDESCRIPTION: This bash command upgrades the `pyats.easypy` module for DevNet Community users using the pip package manager. It requires pip to be installed and configured correctly to fetch packages from the standard Python Package Index.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2018/aug.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats.easypy\n```\n\n----------------------------------------\n\nTITLE: Upgrading ats.robot/pyats.robot using pip (Bash)\nDESCRIPTION: Provides Bash commands using pip to upgrade the ats.robot module for Cisco Internal Developers and the pyats.robot module for the DevNet Community. This update corresponds to version v4.1.1 released on May 3, 2018.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2018/may.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats.robot\n\n# Cisco Internal Developers\nbash$ pip install --upgrade ats.robot\n```\n\n----------------------------------------\n\nTITLE: Custom Python to Tcl Conversion with __tclstr__ method (Python)\nDESCRIPTION: Demonstrates creating a custom Python class (inheriting from `dict`) that implements the special `__tclstr__` method. This method allows defining a custom logic for converting instances of this class into a specific Tcl string format when the `tclstr()` function is called on them, enabling seamless integration with Tcl commands like `array set`. Requires `pyats.tcl` and `pyats.tcl.tclstr`.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/tcl/variables.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n# \n#   creating a tcl compatible dictionary\n\nfrom pyats import tcl\nfrom pyats.tcl import tclstr\n\n# define my custom class by inhering Python dict\nclass TclDict(dict):\n\n    def __tclstr__(self):\n        '''converts this dictionary to Tcl array format'''\n        \n        return ' '.join(['%s {%s}' % (k,v) for k, v in self.items()])\n\n# let's test it by creating a dictionary\nobj = {'a': 1,\n           'b': 2,\n           'c': 3,}\n\n# convert the dictionary to TclDict type\nobj = TclDict(obj)\n\n# call tclstr on it\ntclstr(obj)\n'a {1} c {3} b {2}'\n\n# does it work with Tcl?\ntcl.eval('array set myArray {%s}' % tclstr(obj))\n# myArray(a)         = 1\n# myArray(b)         = 2\n```\n\n----------------------------------------\n\nTITLE: Upgrading ATS Easypy Module Using Bash pip\nDESCRIPTION: This bash snippet upgrades the 'ats.easypy' module to a newer version using the pip package manager. It requires Python and pip installed and is executed in a shell. The command ensures the 'ats.easypy' package is updated to the latest available version for improved functionality and bug fixes.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2017/june.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats.easypy\n```\n\n----------------------------------------\n\nTITLE: Real-world Q Magic Usage Examples with pyATS Tcl Interpreter Python\nDESCRIPTION: This snippet illustrates practical applications of the Q magic interface in pyATS Tcl interpreter, such as sourcing Tcl script files, deleting array elements, appending list items, mutating keyed lists, and loading Tcl packages. Each operation translates a natural Python function call into a Tcl command. Dependencies include os module for path handling and pyats.tcl for interpreter execution; outputs and side effects depend on the state of Tcl variables and the filesystem.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/tcl/q.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n# \n#   some actual examples of how to abuse Q\n#   (don't forget to return his gadgets in a broken state)\n\nimport os\nfrom pyats import tcl\n\n# source some files\ntcl.q.source(os.path.join('path','to','lib.tcl'))\n\n# delete an array element\ntcl.q.unset('myArray(index)')\n\n# list appends\ntcl.q.lappend('myList', 'value 1', 'value 2')\n\n# keyed list operations\ntcl.q.keylset('myKlist', 'key_a', 'value', 'key.subkey', 'value')\n\n# load up some packages\ntcl.q.package('require', 'Expect')\n```\n\n----------------------------------------\n\nTITLE: Container Class Attributes and Properties (CommonSetup, Testcase, CommonCleanup)\nDESCRIPTION: Provides an ASCII table outlining the key attributes (source) and properties (uid, description, parent, result, parameters) of the `aetest` container classes (`CommonSetup`, `Testcase`, `CommonCleanup`). These classes inherit from `TestContainer` and group related test sections.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/objects.rst#_snippet_2\n\nLANGUAGE: Text\nCODE:\n```\n+--------------------------------------------------------------------------+\n| CommonSetup, CommonCleanup, Testcase (base cls: TestContainer)           |\n+==========================================================================+\n| attribute       | description                                            |\n|-----------------+--------------------------------------------------------|\n| source          | file/line information where the class was defined      |\n+==========================================================================+\n| properties      | description                                            |\n|-----------------+--------------------------------------------------------|\n| uid             | common_setup/common_cleanup, or uid of Testcase        |\n| description     | class header (docstring)                               |\n| parent          | TestScript object                                      |\n| result          | rolled-up result of this section                       |\n| parameters      | dictionary of parameters relative to this section      |\n+--------------------------------------------------------------------------+\n```\n\n----------------------------------------\n\nTITLE: Using Datafile Input with AEtest\nDESCRIPTION: Demonstrates different ways to provide a datafile to an AEtest script, including as a standalone argument, through jobfile, as a command-line argument, or as a dictionary.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/datafile.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   example usages of datafile input\n#   (pseudo-code, snippet)\n\n# as a standalone run argument\nif __name__ == '__main__':\n    aetest.main(datafile = '/path/to/your/datafile.yaml')\n\n# through jobfile run/Task argument\ndef main():\n    run(script, datafile = '/path/to/your/datafile.yaml')\n\n# as command-line argument\n# python script.py -datafile=/path/to/your/datafile.yaml\n\n# as a dictionary\ndata = {\"parameters\": {\"param_a\": 1, \"param_b\": 2}}\ndef main():\n    run(script, datafile = data)\n```\n\n----------------------------------------\n\nTITLE: Upgrading PyATS using pip (Cisco Internal)\nDESCRIPTION: This code snippet demonstrates how to upgrade the pyats package using pip for Cisco Internal Developers. It utilizes the `pip install --upgrade ats` command. Assuming that 'ats' is a custom package for internal use, hosted in a private repository or index, and 'pyats' in the previous snippet is the public one.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2022/november.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: AEtest Datafile Schema in YAML\nDESCRIPTION: Defines the complete schema for AEtest datafiles, including extends, parameters, processors, common_setup, testcases, and related attributes. Shows the structure and options available when creating datafiles.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/datafile.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n# Datafile Schema\n# ---------------\n\nextends:    # Datafile(s) to extend/build on.\n            # Use this field to extend an existing datafile.\n            # Allows datafiles to be chained together in extension\n            # relationships.\n            # Supports full path/names or name of file in the same dir.\n            # The content of the last file on the list forms the base and\n            # is updated with the preceding file, and so on,\n            # until the existing file content is updated last.\n            # (optional)\n\nparameters:   # testscript parameters\n              # all key/values here becomes the testscript's base parameters\n              # (optional)\n\nprocessors:   # global processors\n              # pre/post processors to be used as part of this script run\n              # (optional)\n\n    pre:      # list of global pre-processors\n              #   eg: mylib.mymodule.preprocessor_func\n              #\n              # or, list of global pre-processors with arguments\n              #   eg: - processor: mylib.mymodule.preprocessor_func\n              #         args: <list of positional arguments>\n              #         kwargs:\n              #           <key>: <value>\n              # (optional)\n\n\n    post:     # list of global post-processors\n              #   eg: mylib.mymodule.postprocessor_func\n              #\n              # or, list of global post-processors with arguments\n              #   eg: - processor: mylib.mymodule.postprocessor_func\n              #         args: <list of positional arguments>\n              #         kwargs:\n              #           <key>: <value>\n              # (optional)\n\ncommon_setup:   # common_setup block\n                # everything related to script's common_setup section\n                # (optional)\n\n    parameters:   # common_setup parameters\n                  # key/values becomes parameters belonging to common_setup\n                  # section.\n                  # (optional)\n\n    processors:   # common_setup local processors\n                  # pre/post processors to be used on common_setup\n                  # (optional)\n\n        pre:      # list of pre-processors for common_setup section\n                  #   eg: mylib.mymodule.preprocessor_func\n                  #\n                  # or, list of common_setup pre-processors with arguments\n                  #   eg: - processor: mylib.mymodule.preprocessor_func\n                  #         args: <list of positional arguments>\n                  #         kwargs:\n                  #           <key>: <value>\n                  # (optional)\n\n        post:     # list of post-processors for common_setup section\n                  #   eg: mylib.mymodule.postprocessor_func\n                  #\n                  # or, list of common_setup post-processors with arguments\n                  #   eg: - processor: mylib.mymodule.postprocessor_func\n                  #         args: <list of positional arguments>\n                  #         kwargs:\n                  #           <key>: <value>\n                  # (optional)\n\n    # any custom key/value pairs to be set as data (attributes) to\n    # your script's common_setup section\n    <key>: <value>\n\ntestcases:      # testcases block\n                # all testcase related info gets defined under here\n                # (optional)\n\n    <name>:     # testcase class name\n                # this needs to match the testcase's class definition.\n                # do not confuse with the testcase's uid\n                #   eg: MyTestcase\n                # (mandatory)\n\n        uid:    # testcase's string uid\n                # use this to alter the testcase's reported uid\n                # (optional)\n\n        groups:     # testcase grouping\n                    # list of groups this testcase belongs to. See testcase\n                    # grouping feature under flow control documentation.\n                    # (optional)\n\n        name:       # testcase name\n                    # define a testcase's descriptive name. Use this to\n                    # give your testcase a more descriptive name\n                    # (useful only when run in Easypy mode)\n                    # (optional)\n\n        description:  # testcase description\n                      # string describing what this testcase does\n                      # (optional)\n\n        parameters:   # testcase parameters\n                      # key/values become parameters belonging to testcase\n                      # sections.\n                      # (optional)\n\n        processors:   # testcase's local processors\n                      # pre/post processors to be used in this testcase\n                      # (optional)\n\n            pre:      # list of pre-processors for this testcase\n                      #   eg: mylib.mymodule.preprocessor_func\n                      #\n```\n\n----------------------------------------\n\nTITLE: Upgrading ats.topology and ats.utils (Internal) - bash\nDESCRIPTION: This bash command upgrades the `ats.topology` and `ats.utils` modules for Cisco Internal Developers using the pip package manager. It requires pip to be installed and configured correctly, likely pointing to an internal package repository.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2018/aug.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Cisco Internal Developers\nbash$ pip install --upgrade ats.topology ats.utils\n```\n\n----------------------------------------\n\nTITLE: Example Datafile for Python Test Script\nDESCRIPTION: This YAML file provides an example of a data file, configuring the module, class, and testcase parameters and variables used by the Python script. It sets values for module-level variables, script parameters, testcase parameters, and class-level attributes, demonstrating data-driven testing.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/datafile.rst#_snippet_6\n\nLANGUAGE: YAML\nCODE:\n```\n    # Example\n    # -------\n    #\n    #   yaml datafile\n\n    module_var_a: some string value\n    module_var_b: 99999\n\n    parameters:\n        script_param_a: 3.1415926\n        script_param_b: 2016-01-01\n\n    testcases:\n        MyTestcase:\n            uid: customized_uid_from_datafile\n            groups: [demo, datafile, awesomeness]\n\n            parameters:\n                tc_param_a: 100\n                tc_param_b: 200\n\n            class_var_a: [1,2,3,4,5]\n            class_var_b: datafile feature is just that awesome\n```\n\n----------------------------------------\n\nTITLE: pyATS Validate Datafile Usage\nDESCRIPTION: Shows the usage of the `pyats validate datafile` subcommand. Validates the content of a pyATS YAML datafile for syntax and completeness. Supports schema validation and JSON output.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/cli/pyats_validate.rst#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nUsage:\n  pyats validate datafile [file] [options]\n\nDescription:\n  Validates the provided YAML datafile for syntax and content completeness.\n\n  Note:\n    This command also understands the pyATS datafile 'extends:' syntax, and\n    returns the complete, full data content with extensions fulfilled.\n\nDatafile Options:\n  [file]                Datafile to validate\n  --schema              Schema to validate datafile structure\n  --json                Output in JSON format\n  --no-lint             Do not lint the YAML datafile\n\nGeneral Options:\n  -h, --help            Show help\n  -v, --verbose         Give more output, additive up to 3 times.\n  -q, --quiet           Give less output, additive up to 3 times, corresponding to WARNING, ERROR,\n                        and CRITICAL logging levels\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyATS using pip (Bash)\nDESCRIPTION: Provides the pip commands to upgrade the pyATS framework. Separate commands are shown for DevNet community users (upgrading 'pyats') and Cisco internal developers (upgrading 'ats'). Requires pip to be installed and network access to the appropriate Python package index (PyPI or internal).\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2019/may.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats\n\n# Cisco Internal Developers\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Using History Markers in pyATS\nDESCRIPTION: This code demonstrates how to use markers in the pyATS Tcl Interpreter's history to track events. It creates two markers ('testMarker' and 'testMarker2'), runs Tcl code under each marker, and then stops the markers. It shows how to filter the history to view calls specific to each marker or to view all calls in the master marker.  It requires importing the pyats.tcl module.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/tcl/history.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats import tcl\n\n    # run some Tcl code\n    tcl.eval('set test 1')\n\n    # create a new marker\n    tcl.history.start_marker('testMarker')\n\n    # run code under new marker\n    tcl.eval('set a 1')\n\n    # now create another marker\n    tcl.history.start_marker('testMarker2')\n\n    # run code under new marker as well\n    tcl.eval('set b 2')\n\n    # stop the markers\n    tcl.history.end_marker('testMarker')\n    tcl.history.end_marker('testMarker2')\n\n    # run more code\n    tcl.eval('set c 3')\n    \n    # now let's see history vs marker behavior\n    # all calls are in the master (default) marker\n    tcl.history.filter()\n\n    # 'testMarker' only has 1 calls\n    tcl.history.filter(marker='testMarker')\n\n    # 'testMarker2' only contains 1 call\n    tcl.history.filter(marker='testMarker2')\n```\n\n----------------------------------------\n\nTITLE: Running Easypy Job with Custom Email Subject - Bash\nDESCRIPTION: This command-line example demonstrates how to execute a pyATS easypy job file and specify a custom subject for the job's email notification. It uses the `-mail_subject` argument followed by the desired subject string.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2015/march.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\neasypy /path/to/job/file -mail_subject \"my subject here\"\n```\n\n----------------------------------------\n\nTITLE: Function Class Attributes and Properties (Subsection, Setup/Test/CleanupSection)\nDESCRIPTION: Provides an ASCII table outlining the key attributes (function, source) and properties (uid, description, parent, result, parameters) of the `aetest` function classes (`Subsection`, `SetupSection`, `TestSection`, `CleanupSection`). These classes inherit from `TestFunction` and represent the decorated methods within container classes.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/objects.rst#_snippet_6\n\nLANGUAGE: Text\nCODE:\n```\n+--------------------------------------------------------------------------+\n| Subsection, [Setup|Test|Cleanup]Section (base cls: TestFunction)         |\n+==========================================================================+\n| attribute       | description                                            |\n|-----------------+--------------------------------------------------------|\n| function        | function/method that was decorated to be this section  |\n| source          | file/line information where the method was defined     |\n+==========================================================================+\n| properties      | description                                            |\n|-----------------+--------------------------------------------------------|\n| uid             | name of the function/method                            |\n| description     | function header (docstring)                            |\n| parent          | container (CommonSetup/Testcase/CommonCleanup)         |\n| result          | rolled-up result of this test function                 |\n| parameters      | dictionary of parameters relative to this function     |\n+--------------------------------------------------------------------------+\n```\n\n----------------------------------------\n\nTITLE: Executing a Multi-Step Device Clean in Python\nDESCRIPTION: This Python snippet outlines a device cleaning function. It accepts a `device` object and an optional `steps` object. The function connects to the device, retrieves device-specific cleaning instructions, and executes sequential cleaning tasks (e.g., loading an image, reloading the device, applying post-clean configuration) encapsulated within `steps.start()` blocks for detailed logging and reporting. Finally, it disconnects from the device. Assumes the `device` object has `connect()`, `disconnect()`, `configure()` methods and a `clean` attribute containing necessary details like 'images' and 'post-clean' configuration.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/kleenex/clean.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# connect to the device\ndevice.connect()\n\n# look up the details of how to clean this device, eg:\nclean_info = device.clean\n\nwith steps.start('Clean the device'):\n    # do the actual clean, eg, pseudo-code\n    self._imaginary_load_image_method(device = device,\n                                      images = clean_info['images'])\n\nwith steps.start('Reload the device'):\n    # maybe reload the device?\n    self._imaginary_device_reload(device = device)\n\nwith steps.start('Apply post-clean configuration'):\n    # apply post-clean config?\n    device.configure(clean_info['post-clean'])\n\n# we're done!\ndevice.disconnect()\n```\n\n----------------------------------------\n\nTITLE: Generating XML Reports and Terminating pyATS Server in Python\nDESCRIPTION: These example commands show how to programmatically generate final XML reports and properly shut down the report server after test execution. The generate_xml_reports function produces report files to a specified file path, while terminate_server cleans up the server instance. Both operations require an active AEClient/AERunner context and accept arguments such as output file paths.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aereport/index.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nclt.generate_xml_reports(path='/tmp/')\nAERunner.terminate_server()\n```\n\n----------------------------------------\n\nTITLE: Suggested Package Layout for pyats FileUtils Plugins (Text)\nDESCRIPTION: Illustrates the recommended directory structure for creating a custom `FileUtils` plugin package within the `pyats` ecosystem. It details the placement of configuration files (`.gitignore`, `setup.py`, `MANIFEST.in`), documentation (`README.rst`, `docs`), tests (`tests`), and source code (`src`), including the organization of OS-specific plugins and optional protocol subplugins.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/file_transfer_utilities.rst#_snippet_22\n\nLANGUAGE: text\nCODE:\n```\n|-- .gitignore                        Tell git to ignore many common file types\n|-- README.rst                        Points to src/myfutils/README.rst\n|-- DESCRIPTION.rst                   Long description of package\n|-- MANIFEST.in                       Extra files to be packaged\n|-- setup.py                          For PyPi distribution of your package and\n|                                     unit test execution.\n|-- tests                             Sym-link to the src/myfutils/tests folder\n|-- docs                              Sphinx online documentation for your package\n|   |-- README.rst\n|   `-- changelog\n`-- src                               All sources for package myfutils\n    |-- __init__.py                   Module declaration file\n    `-- myfutils\n        |-- __init__.py               Module declaration file\n        |-- README.rst                Instructions to the installing user.\n        |-- fileutils.py              Top-level fileutils, inherits from\n        |                             ats.utils.fileutils.FileUtils\n        |-- plugins                   All FileUtils OS plugins are under this directory\n        |   |-- xyz                   Plugin module providing support for OS xyz\n        |       |-- __init__.py       Module declaration file\n        |       |-- fileutils.py      Fileutils module for OS xyz\n        |       `-- ftp               Optional subplugin (child) module providing\n        |           |                 support for protocol ftp on OS xyz\n        |           `-- __init__.py   Module declaration file\n        |           `-- fileutils.py  Fileutils module providing ftp services\n        |                             for OS xyz\n        |-- tests                     Unit tests for the package\n```\n\n----------------------------------------\n\nTITLE: Custom Report Section (python)\nDESCRIPTION: This Python snippet demonstrates adding a custom section to the email report during runtime. It accesses the `runtime.mail_report.contents` dictionary to add a new section with a custom title and content. It also specifies a custom HTML template. Modifying `runtime.mail_report.contents` will change the email body, and modifying `runtime.mail_report.custom_template` provides a path to override the default template.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/easypy/email.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   adding custom report sections\n#   (always do this in the jobfile/main easypy process)\n\n# use the runtime object\ndef main(runtime):\n\n    # add a custom section\n    runtime.mail_report.contents['My Custom Section'] = \"My Custom Text\"\n    # path to the custom template\n    runtime.mail_report.custom_template = '/ws/aalfakhr-ott/templates/custom.html'\n\n    # -----------------------\n    # when the above job file is run, the following\n    # is added to the bottom of the email notification report\n    # +------------------------------------------------------------------------------+\n    # |                              My Custom Section                               |\n    # +------------------------------------------------------------------------------+\n    # My Custom Text\n```\n\n----------------------------------------\n\nTITLE: Generating a Secret Key with pyATS Secret Keygen - Text\nDESCRIPTION: This snippet shows usage of the 'pyats secret keygen' subcommand, which generates a unique key for encoding and decoding secret strings. It describes usage, the key's configuration integration via [secrets] string.key, and selection of representers and prefixes. The only parameter is '--prefix', which lets users choose configuration namespaces. The generated key should be secured as it grants access to secret decoding.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/cli/pyats_secret.rst#_snippet_1\n\nLANGUAGE: Text\nCODE:\n```\nUsage:\n  pyats secret keygen [options]\n\nDescription:\n  Generates a new personalized key used to encode/decode a secret string.\n\n  This key, once generated, would typically be manually placed in the pyats\n  configuration:\n  [secrets] string.key = <generated_key>\n\n  The chosen representer controls the format of the returned key.\n  The format of the returned key depends upon the representer specified\n  via the pyats configuration:\n  [secrets] string.representer = representer_module.representer_class\n\n  IMPORTANT: Please ensure any pyats configuration file(s) containing this key\n  are locked down with appropriate permissions to ensure only authorized parties\n  may read it.\n\n  If specified, --prefix selects other representers defined in the pyats\n  configuration.  The following is expected to be present:\n  [secrets] <prefix>.representer\n\nKeygen Options:\n  --prefix [prefix]     Cfg prefix to use (Optional)\n\nGeneral Options:\n  -h, --help            Show help\n  -v, --verbose         Give more output, additive up to 3 times.\n  -q, --quiet           Give less output, additive up to 3 times, corresponding to WARNING, ERROR,\n                        and CRITICAL logging levels\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyATS Modules in DevNet Community and Cisco Internal (v4.1.1)\nDESCRIPTION: Commands for upgrading pyATS modules to version 4.1.1. Shows instructions for both DevNet Community users and Cisco Internal developers to update the aetest and cisco modules.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2018/mar.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats.aetest pyats.cisco\n\n# Cisco Internal Developers\nbash$ pip install --upgrade ats.aetest ats.cisco\n```\n\n----------------------------------------\n\nTITLE: Controlling Test Run State and Checkpoints with pyATS in Python\nDESCRIPTION: These functions handle the runtime flow of tests by providing methods to pause, abort, add checkpoints, or inject user-defined information during test execution. Functions like add_checkpoint, abort, pause, and their counterparts modify the test flow dynamically, with each accepting keyword arguments specifying details such as checkpoint names or user comments. These functions are intended to be invoked as part of orchestrated test sequences and may impact the execution timeline or reporting depending on their parameters.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aereport/index.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef add_checkpoint (self, kwargs):\ndef add_userdef (self, kwargs):\ndef abort (self, kwargs):\ndef abort_testsuite (self, kwargs):\ndef pause (self, kwargs):\ndef unpause (self, kwargs):\n```\n\n----------------------------------------\n\nTITLE: Defining Pre/Post Processors in YAML\nDESCRIPTION: This snippet demonstrates how to define pre and post-processors in a YAML configuration file for a testcase and common cleanup section.  It shows both simple processor definitions and those with arguments.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/datafile.rst#_snippet_2\n\nLANGUAGE: YAML\nCODE:\n```\n                post:     # list of post-processors for this testcase\n                          #   eg: mylib.mymodule.postprocessor_func\n                          #\n                          # or, list of testcase post-processors with arguments\n                          #   eg: - processor: mylib.mymodule.postprocessor_func\n                          #         args: <list of positional arguments>\n                          #         kwargs:\n                          #           <key>: <value>\n                          # (optional)\n```\n\nLANGUAGE: YAML\nCODE:\n```\n            pre:      # list of pre-processors for common_cleanup section\n                      #   eg: mylib.mymodule.preprocessor_func\n                      #\n                      # or, list of common_cleanup pre-processors with args\n                      #   eg: - processor: mylib.mymodule.preprocessor_func\n                      #         args: <list of positional arguments>\n                      #         kwargs:\n                      #           <key>: <value>\n                      # (optional)\n```\n\nLANGUAGE: YAML\nCODE:\n```\n            post:     # list of post-processors for common_cleanup section\n                      #   eg: mylib.mymodule.postprocessor_func\n                      #\n                      # or, list of common_cleanup post-processors with args\n                      #   eg: - processor: mylib.mymodule.postprocessor_func\n                      #         args: <list of positional arguments>\n                      #         kwargs:\n                      #           <key>: <value>\n                      # (optional)\n```\n\n----------------------------------------\n\nTITLE: Configure Method with Exception\nDESCRIPTION: The `configure` method raises a `NotImplementedError`. This indicates that the implementation of configuration should be done via the `execute` API. It is a placeholder for future extensions and maintains API consistency.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/connections/class.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef configure(self, *args, **kwargs):\n    raise NotImplementedError('just configure using execute api!')\n```\n\n----------------------------------------\n\nTITLE: Configuring Kleenex Cleaner in YAML (YAML)\nDESCRIPTION: This YAML snippet demonstrates how a custom cleaner class (`AwesomeClean`) is configured within the `cleaners` section of a pyats clean file. It specifies the Python module where the class resides, the target devices or groups the cleaner should apply to, and parameters (timeout, loglevel, retry) that will be passed to the cleaner's constructor upon instantiation.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/kleenex/clean.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n# Example\n# -------\n#\n#   a sample clean file (only showing the cleaners block)\n\ncleaners:\n    AwesomeClean:\n        module: mollymaid.cleaners\n        devices: [example-device, ]\n        timeout: 100\n        loglevel: INFO\n        retry: 3\n```\n\n----------------------------------------\n\nTITLE: Loading Clean File Example\nDESCRIPTION: This YAML code block provides an example that demonstrates how clean file content is loaded and applied to device objects. It showcases specifying image roles with associated file paths, inclusion patterns, exclusion patterns, and cardinality. It also displays setting up server authentication details for secure image retrieval, along with an example of a device configuration and cleaner configurations.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/kleenex/inputs.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\n    # Example\n    # -------\n    #\n    #   demonstrating how clean file content is loaded\n    #   and applied to device objects for user reference\n\n    --- # assuming we have this simple testbed.yaml file\n    testbed:\n        servers:\n            golden_img_svr.domain.com:\n                # Auth details for svr to allow below url to work.\n                credentials:\n                    default:\n                        username: jdoe\n                        password: my_pw\n\n            img_svr.domain.com:\n                # Auth details for svr to allow below urls to work.\n                credentials:\n                    default:\n                        username: jdoe\n                        password: my_pw\n\n    devices:\n        example-device:\n            type: example-type\n            connections:\n                default:\n                    protocol: telnet\n                    ip: 1.1.1.10\n                    port: 500\n\n        another-example-device:\n            type: example-type\n            connections:\n                default:\n                    protocol: telnet\n                    ip: 1.1.1.10\n                    port: 501\n    ...\n\n    --- # and we had this clean.yaml clean-file for this testbed\n    cleaners:\n        AwesomeClean:\n            module: mollymaid.cleaners\n            devices: [example-device, ]\n            timeout: 1200\n\n    devices:\n        example-device:\n            images:\n                rp:\n                    file: /path/to/device/image/r99.9.9.bin\n                    include: r\\d+\\.\\d\\.\\d\\.bin\n                    exclude: file_pat_to_exclude\n                    cardinality: 1\n\n                pie:\n                    file: ftp://img_svr.domain.com/path/to/mypies/k9sec.bin\n                    include: k9sec\n                    cardinality: ANY\n\n\n        another-example-device:\n            images:\n                role_defaults:\n```\n\n----------------------------------------\n\nTITLE: Connecting to Device During Pause (pyATS)\nDESCRIPTION: This Python snippet illustrates how to disconnect and reconnect to a device within a pyATS testbed while the test is paused. This allows direct interaction with the device in a separate terminal for debugging purposes, after which the device connection can be re-established to resume the test.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/debugging.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> import pyats.easypy as ep\n>>> dev = ep.runtime.testbed.devices['<device>']\n>>> dev.disconnect()\n\n# the device can now be connected to in a separate terminal. Once ready to resume the test,\n# break the connection and reattach with\n\n>>> dev.connect()\n```\n\n----------------------------------------\n\nTITLE: Defining Embedded File Transfer Server in pyATS Testbed YAML\nDESCRIPTION: This text-based configuration example illustrates how to define an embedded FTP server in a pyATS testbed YAML file. By specifying parameters such as 'dynamic', 'protocol', 'subnet', and 'path' under 'servers', users enable automated startup of a local file transfer server through the 'genie.libs.filetransferutils' plugin during test execution. Inputs: YAML conforming to the specified structure. Outputs: Activation of the file transfer server upon testbed initialization if configured properly. The path must be accessible and the subnet specification should match the testbed's network configuration.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2020/dec.rst#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\ntestbed:\n  servers:\n    myftpserver:\n      dynamic: true\n      protocol: ftp\n      subnet: 10.0.0.0/8\n      path: /path/to/root/dir\n```\n\n----------------------------------------\n\nTITLE: Loading Extended YAML with pyATS Loader (Python)\nDESCRIPTION: Provides Python code using `pyats.utils.yaml.Loader` initialized with `enable_extensions=True` to load an extending YAML file (`b.yaml`). This demonstrates programmatically how the pyATS loader processes the `extends` directive and the `%EXTEND_LIST` key markup to merge and modify data from multiple YAML files.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/yaml_markup.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.utils.yaml import Loader\nloader = Loader(enable_extensions=True)\ndata = loader.load('b.yaml')\nprint(data)\n```\n\n----------------------------------------\n\nTITLE: Upgrade 'ats.easypy' module to previous version via pip\nDESCRIPTION: This command upgrades the 'ats.easypy' module to version 3.3.8, potentially used for compatibility or regression testing. It depends on Python's pip package manager and should be executed in a terminal. Useful when specific older features of this version are required.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2017/nov.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats.easypy\n```\n\n----------------------------------------\n\nTITLE: Developing multiple pyATS packages in custom directory, deleting existing repos\nDESCRIPTION: This comprehensive example shows how to develop multiple packages (`unicon.plugins` and `genie.libs`). The `--delete-repos` flag is used to remove existing repositories in the target directory before cloning, and `--directory my_repos` specifies that repositories should be cloned into the 'my_repos' sub-directory instead of the default location ($VIRTUAL_ENV/pypi). Backing up work is recommended before using `--delete-repos`.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/cli/pyats_develop.rst#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\npyats develop unicon.plugins genie.libs --delete-repos --directory my_repos\n```\n\n----------------------------------------\n\nTITLE: Setting Logger Level in Python\nDESCRIPTION: Illustrates how to configure the logging level for a specific logger instance in Python. This example imports the `logging` module, retrieves a logger (presumably named after the module), and sets its threshold level to `logging.INFO` using the `setLevel()` method, thereby controlling which messages are processed.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/log/concept.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n# \n#   setting logger level\n#\n#   available levels:\n#       logging.INFO\n#       logging.CRITICAL\n#       logging.ERROR\n#       logging.WARNING\n#       logging.DEBUG\n\nimport logging\n\nlogger = logging.getLogger(__name__)\n\nlogger.setLevel(logging.INFO)\n```\n\n----------------------------------------\n\nTITLE: Upgrading ats.aetest Module Using Bash\nDESCRIPTION: Provides the bash command to upgrade the ats.aetest module to the latest version using pip. This snippet assumes a Python environment with pip installed and targets users wishing to update the ats.aetest package to ensure bug fixes and improvements are applied.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2016/october.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats.aetest\n```\n\n----------------------------------------\n\nTITLE: Installing Examples and Templates using pip\nDESCRIPTION: This snippet shows how to install examples and templates from the pyATS project using the pip package manager. It specifies the packages and the intended installation location, under the root instance folder as `examples/` and `templates/`.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2015/june.rst#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install ats.examples\nbash$ pip install ats.templates\n```\n\n----------------------------------------\n\nTITLE: Detailed Information and Usage for 'pyats version check' Subcommand (Text)\nDESCRIPTION: This snippet describes the functionality of the 'pyats version check' subcommand, which displays the current pyATS version within the environment and checks for package updates on PyPI. It covers the options '--outdated' and '--include [...]' for checking available upgrades and specific packages.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/cli/pyats_version.rst#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\npyats version check\n-------------------\n\nThis subcommand displays the currently installed pyATS version (within this\nvirtual environment), and gives you the ability to check whether there are\nany available package updates.\n\nOptions\n^^^^^^^\n\n``--outdated``\n    checks PyPI for any available package upgrades, and displays the appropriate\n    upgrade api.\n\n    .. note::\n\n        this requires connecting to PyPI server and getting package metadata,\n        a somewhat slow process. Be patient while it computes.\n\n``--include [...]``\n    list of other packages to display/check for in the displayed version table.\n    Useful if you want to check for possible upgrades for some of your other\n    installed packages.\n\nExample\n^^^^^^^\n\n.. code-block:: text\n\n    # Example\n    # -------\n    #\n    #   check for outdated package versions, including genie\n\n    bash$ pyats version check --outdated\n    You are currently running pyATS version: 19.12\n\n    Checking for outdated packages...\n\n      Package                      Version Latest\n      ---------------------------- ------- ------\n      pyats                        19.12   20.1\n      pyats.aereport               19.12   20.1\n      pyats.aetest                 19.12   20.1\n      pyats.async                  19.12   20.1\n      pyats.connections            19.12   20.1\n      pyats.datastructures         19.12   20.1\n      pyats.easypy                 19.12   20.1\n      pyats.examples               19.12   20.1\n      pyats.kleenex                19.12   20.1\n      pyats.log                    19.12   20.1\n      pyats.results                19.12   20.1\n      pyats.robot                  19.12   20.1\n      pyats.tcl                    19.12   20.1\n      pyats.templates              19.12   20.1\n      pyats.topology               19.12   20.1\n      pyats.utils                  19.12   20.1\n      genie                        19.12   20.1\n      genie.abstract               19.12   20.1\n      genie.conf                   19.12   20.1\n      genie.examples               19.12   20.1\n      genie.harness                19.12   20.1\n      genie.libs.conf              19.12   20.1\n      genie.libs.filetransferutils 19.12   20.1\n      genie.libs.ops               19.12   20.1\n      genie.libs.parser            19.12   20.1\n      genie.libs.robot             19.12   20.1\n      genie.libs.sdk               19.12   20.1\n      genie.libs.telemetry         19.12   20.1\n      genie.metaparser             19.12   20.1\n      genie.ops                    19.12   20.1\n      genie.parsergen              19.12   20.1\n      genie.predcore               19.12   20.1\n      genie.telemetry              19.12   20.1\n      genie.utils                  19.12   20.1\n\n    Note - you can upgrade outdated packages with:\n        pip install --upgrade pyats.easypy pyats.kleenex pyats.utils\n        pip install --upgrade genie.conf genie.examples genie.harness\n        pip install --upgrade genie.libs.parser genie.libs.telemetry genie.ops\n        pip install --upgrade genie.parsergen genie.predcore genie.telemetry\n        pip install --upgrade genie.utils\n```\n\n----------------------------------------\n\nTITLE: Invoking Tcl Q Magic Functions with ats.tcl - Python\nDESCRIPTION: Illustrates the integration of Tcl code via the Q magic function in the ats.tcl module, allowing Tcl commands to be called as Python methods and objects. Requires the ats.tcl package and a compatible environment where Tcl is available. The code demonstrates calling Tcl commands such as info, package, and custom load_lib with specified arguments. Inputs are Tcl command strings and their arguments, outputs are the results of those Tcl expressions wrapped for use in Python. Refer to pyATS Tcl documentation for deeper integration details.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2014/december.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom ats import tcl\n\ntcl.q.info('exists', 'auto_path')\n\ntcl.q.package('require', 'cAAs')\n\ntcl.q.load_lib(file = '/path/to/file.tcl', \n               os = 'NXOS',\n               functional = 1)\n```\n\n----------------------------------------\n\nTITLE: Documenting pyats.utils.fileutils.core\nDESCRIPTION: This reStructuredText snippet uses the automodule directive to document the `pyats.utils.fileutils.core` module. The directive specifies that all members, including those that are undocumented, are to be included, and that the inheritance hierarchy should be displayed. This is a standard method for generating documentation of Python modules using Sphinx or a similar documentation generator.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/apidoc/utils/pyats.utils.fileutils.core.rst#_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: pyats.utils.fileutils.core\n   :members:\n   :undoc-members:\n   :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: Using Configuration class in pyATS\nDESCRIPTION: Demonstrates how to instantiate a Configuration object and load configurations from INI files, YAML files, and Python entrypoints. Shows the resulting nested configuration structure.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/datastructures/configuration.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n# Example\n# -------\n# \n#   using Configuration() class\n\nfrom pyats.datastructures import Configuration\n\n# instantiating it\ncfg = Configuration()\n\n# loading some INI style config files\ncfg.load_cfgs('/path/to/file.ini')\ncfg.load_cfgs('/path/to/file.conf')\n\n# load yaml style config files\ncfg.load_yamls('/path/to/config.yaml')\n\n# loading python entrypoints\ncfg.load_entrypoint(group = 'entrypoint.group.name')\n\ncfg\n# Configuration({\n#     'email': Configuration({\n#         'smtp': Configuration({\n#             'host': 'mail.cisco.com', \n#             'port': 25}), \n#         'default_domain': 'cisco.com'})}\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyATS Modules Using Bash\nDESCRIPTION: These bash snippets provide commands to upgrade pyATS Python modules such as ats.easypy and ats.topology. They specify the pip install commands needed for different developer environments: DevNet Community users and Cisco Internal Developers. Each snippet corresponds to a module upgrade for a specific version and ensures that the user's environment has the latest module features and bug fixes.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2018/june.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats.easypy\n```\n\nLANGUAGE: bash\nCODE:\n```\n# Cisco Internal Developers\nbash$ pip install --upgrade ats.easypy\n```\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats.topology\n```\n\nLANGUAGE: bash\nCODE:\n```\n# Cisco Internal Developers\nbash$ pip install --upgrade ats.topology\n```\n\n----------------------------------------\n\nTITLE: Parsing script arguments using pyATS AEtest in Python standalone mode\nDESCRIPTION: Demonstrates how to parse command line arguments in a standalone AEtest Python script by using argparse to add custom arguments and passing them as keyword arguments to aetest.main(). Dependencies include pyats.aetest and pyats.topology for topology loading. The example includes a simple testcase printing the parameters received, showing how inputs like --testbed and --vlan are handled. Output confirms the parameters propagated correctly. Users must ensure argument parsing uses parse_known_args() to allow aetest to capture additional arguments. This snippet is suited for custom argument handling in AEtest scripts run independently.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/run.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats import aetest\n\nclass Testcase(aetest.Testcase):\n\n    @aetest.test\n    def test(self):\n        print('Parameters = ', self.parameters)\n\nif __name__ == '__main__':\n\n    import sys\n    import argparse\n    from pyats import topology\n\n    parser = argparse.ArgumentParser(description = \"standalone parser\")\n    parser.add_argument('--testbed', dest = 'testbed',\n                        type = topology.loader.load)\n    parser.add_argument('--vlan', dest = 'vlan', type = int)\n\n    args, sys.argv[1:] = parser.parse_known_args(sys.argv[1:])\n\n    aetest.main(testbed = args.testbed, vlan = args.vlan)\n```\n\n----------------------------------------\n\nTITLE: Implementing BaseCleaner With Steps Signature (Python)\nDESCRIPTION: This partial pseudo-code snippet shows the required signature for the `clean()` method in a pyats Kleenex cleaner class that intends to utilize the step reporting feature. By including the `steps` parameter, the cleaner gains access to the context manager object necessary for defining individual, reportable cleaning steps via the `steps.start` API within the method.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/kleenex/clean.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   a pesudo-code example implementation of a cleaner class\n\n# all clean implementations inherit from BaseCleaner\nclass ExampleCleanerWithSteps(ExampleCleaner):\n    '''BaseCleaner\n\n    demonstrating the use of steps in a cleaner implementation.\n\n    '''\n\n    def clean(self, device, steps):\n        '''clean\n\n        main entry point of this clean implementation, this method is called\n        in a subprocess under kleenex runtime, specific to cleaning one\n        particular device.\n\n\n```\n\n----------------------------------------\n\nTITLE: Upgrading ats.aetest Module using pip - bash\nDESCRIPTION: This snippet demonstrates how to upgrade the ats.aetest module using the pip package manager. The command ensures that the latest version of the module is installed, resolving known bugs and incorporating recent enhancements.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2016/december.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats.aetest\n```\n\n----------------------------------------\n\nTITLE: AEReport API Signatures for Main Contexts in Python\nDESCRIPTION: Lists example Python method signatures for starting and stopping primary execution contexts within AEReport, such as `start_testsuite`, `stop_testsuite`, `start_jobexecution`, `stop_jobexecution`, `start_testscript`, and `stop_testscript`. These APIs are fundamental for signaling the beginning and end of major test phases to structure the XML report.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aereport/index.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef start_testsuite (self, kwargs):\ndef stop_testsuite (self, kwargs):\ndef start_jobexecution (self, kwargs):\ndef stop_jobexecution (self, kwargs):\ndef start_testscript (self, kwargs):\ndef stop_testscript (self, kwargs):\n...\n```\n\n----------------------------------------\n\nTITLE: Configuring Network Topology Links in YAML\nDESCRIPTION: This section allows defining network links explicitly under the 'topology' block with optional aliasing, custom class extension for links, and other custom key-value parameters. It supports extending base Link class functionalities by specifying module paths to alternative Link subclasses, facilitating richer link models in the testbed.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/topology/schema.rst#_snippet_4\n\nLANGUAGE: YAML\nCODE:\n```\ntopology:\\n\\n    links:\\n        # section describing the links used in this testbed.\\n        # this section is optional. It is only needed if there's a need\\n        # to specify additional/custom values for the named link.\\n        # (optional)\\n\\n        <name>: # link name. each link that has extended descriptions\\n                # needs to have its own section under links\\n                # (optional)\\n\\n            alias:  # link alias.\\n                    # (default: same as link name)\\n                    # (optional)\\n\\n            class:  # link object class.\\n                    # use this field to provide an alternative subclass of\\n                    # Link to instantiate this link block to. can be used\\n                    # to extend the base Link class functionalities\\n                    #   Eg: module.submodule.myLinkClass\\n                    # (default: ats.topology.Link)\\n                    # (optional)\\n\\n            <key>: <value>  # any other key/values custom to this link\\n                            # goes here as standard yaml syntax\\n                            # (optional)\n```\n\n----------------------------------------\n\nTITLE: Sending Data via Telnet\nDESCRIPTION: The `send` method sends data to the device over the Telnet connection. It takes a string `text` as input, encodes it to bytes, appends a newline character, and writes it to the Telnet session.  It uses `self._telnet.write()` to send data. It requires the input to be a string.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/connections/class.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef send(self, text):\n    '''send\n\n    low-level api: sends raw text through telnet session.\n    '''\n\n    # remember to convert string to bytes\n    return self._telnet.write(text.encode('ascii') + '\\n')\n```\n\n----------------------------------------\n\nTITLE: Importing Modules for Telnet Connection\nDESCRIPTION: This snippet imports the necessary modules for a Telnet connection class. It imports `telnetlib` from the standard library, which provides the Telnet client functionality, and `BaseConnection` from pyATS to build the Telnet class upon.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/connections/class.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport telnetlib\n\nfrom pyats.connections import BaseConnection\n```\n\n----------------------------------------\n\nTITLE: Documenting pyats.async Package with Sphinx\nDESCRIPTION: This snippet utilizes Sphinx's `automodule` directive to generate documentation for the `pyats.async_` package. It automatically includes members, excludes undocumented members, and displays inheritance information. No dependencies are directly specified in this particular snippet, as it relies on the broader Sphinx setup.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/apidoc/async/index.rst#_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: pyats.async_\n   :members:\n   :undoc-members:\n   :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: Upgrade 'ats.easypy' module via pip\nDESCRIPTION: This code snippet provides the command to upgrade the 'ats.easypy' module to its latest version using pip. It is intended for users who need to ensure they are using the most recent features and bug fixes. Dependencies include Python's pip package manager. The command can be run in a terminal or command prompt.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2017/nov.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats.easypy\n```\n\n----------------------------------------\n\nTITLE: Step Debugging Configuration Using YAML in pyats\nDESCRIPTION: This snippet illustrates how to configure step debugging in pyats using a YAML input file, enabling pre- and post-step custom commands and functions on specified devices based on step name patterns and execution results. It supports inheritance, regular expressions, and detailed control over debugging actions during test runs, with parameters 'when', 'device', 'cmd', and 'func' to specify behaviors.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/steps.rst#_snippet_7\n\nLANGUAGE: YAML\nCODE:\n```\n# Schema\n# -------\n#\n# step debug input file\n\nextends:    # Step debug file(s) to extend/build on.\n            # Use this field to extend an existing yaml step debug file,\n            # allowing you to create an inheritance hierarchy.\n            # Supports full path/names or name of file in the same dir.\n            # The content of the last file on the list forms the base and\n            # is updated with the preceding file, and so on,\n            # until the existing file content is updated last.\n            # (optional)\n\n<step_name>:  # A regular expression of the step name\n    - when:   # A list that is consist of 'start', 'end' or any result type,\n              # like 'passed'\n              # (mandatory)\n      device: # List of devices that will be passed to the functions and\n              # will run the commands.\n              # (mandatory)\n      cmd:    # List of cli commands to be run on devices,\n              # (optional)\n      func:   # Functions list,\n              # (optional)\n\n# Example\n# -------\n#\n# step debug input file\n\nstep.*:\n\n    - when:\n        - 'start'\n        - 'failed'\n\n      device:\n        - 'device.*'\n\n      cmd:\n        - 'mycommand1'\n        - 'my_command2'\n\n      func:\n        - 'path.to.myscript.myfunction1'\n        - 'path.to.myscript.myfunction2'\n\n    - when:\n        - 'end'\n\n      device:\n        - 'device1'\n\n      cmd:\n        - 'my_command'\n\n      func:\n        - 'path.to.myscript.myfunction1'\n\n# About Matching and Execution\n# ----------------------------\n#\n# The system matches current step name and action against these definitions.\n# Devices, commands, and functions are then executed as specified, with output\n# logged and errors handled gracefully. Supports regex for flexible matching.\n\n```\n\n----------------------------------------\n\nTITLE: Customizing History Length in pyATS\nDESCRIPTION: This code shows how to customize the maximum history length in the pyATS Tcl Interpreter by replacing the default History instance with a new one.  It highlights that replacing the history attribute will delete all previous historical events. The code depends on the pyats.tcl module.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/tcl/history.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# continuing from above...\n\n    # replace the history tracker with a new, bigger one\n    tcl.history = History(max_history = 15000)\n\n    # note that this deletes all historical event up until now\n    tcl.history\n```\n\n----------------------------------------\n\nTITLE: TestcaseDiscovery Implementation Structure\nDESCRIPTION: Shows the implementation structure of the TestcaseDiscovery class. This class is responsible for discovering test sections within a testcase and ordering them properly for execution.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/control.rst#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nclass TestcaseDiscovery():\n    def __init__(self, target):\n        self.target = target\n\n    def __iter__(self):\n        # some default logic written here\n        ...\n        for test in self.discover():\n            yeild instantiated_test\n\n    def discover(self):\n        # some default logic written here\n        ...\n        return self.order(setup, testcases, cleanup)\n\n    def order(self, setup=None, tests=list(), cleanup=None):\n        # some default logic written here\n        ...\n        return ordered_tests\n```\n\n----------------------------------------\n\nTITLE: Installing pyATS Package\nDESCRIPTION: This command installs or upgrades the specified pyATS package using pip. The `--upgrade` flag ensures that the latest version is installed. This is a standard installation command for pyATS packages.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2016/may.rst#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats.aetest ats.easypy ats.kleenex\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for TFTP Fileutils Submodule (reStructuredText)\nDESCRIPTION: Uses the Sphinx `automodule` directive in reStructuredText to automatically generate documentation for the `pyats.utils.fileutils.plugins.localhost.curl.tftp.fileutils` Python submodule. Similar to the package-level directive, it includes all members, undocumented members, and inheritance details using the standard Sphinx automodule options.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/apidoc/utils/pyats.utils.fileutils.plugins.localhost.curl.tftp.rst#_snippet_1\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: pyats.utils.fileutils.plugins.localhost.curl.tftp.fileutils\n   :members:\n   :undoc-members:\n   :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: Counting Test Results in pyATS AEtest Test Containers Using Python\nDESCRIPTION: This snippet illustrates a typical test script using pyATS AEtest that includes CommonSetup with subsections and a Testcase with multiple tests and a cleanup method. It shows how only TestContainer classes (CommonSetup, Testcase, CommonCleanup) contribute to the overall summary result count while subsections do not increase the counted results independently. The example includes a test that explicitly fails, affecting the summary output to illustrate the result counting behavior.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/results.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats import aetest\n\nclass CommonSetup(aetest.CommonSetup):\n\n    @aetest.subsection\n    def subsection_one(self): pass\n\n    @aetest.subsection\n    def subsection_two(self): pass\n\nclass TestcaseOne(aetest.Testcase):\n\n    @aetest.setup\n    def setup(self): pass\n\n    @aetest.test\n    def test_one(self): pass\n\n    @aetest.test\n    def test_two(self):\n        self.failed()\n\n    @aetest.cleanup\n    def cleanup(self): pass\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyATS Robot Module via pip - bash\nDESCRIPTION: Explains how to upgrade the `ats.robot` module using the pip package manager. This command is specifically for Cisco Internal Developers accessing internal repositories. Requires pip to be installed and configured.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2019/aug.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# Cisco Internal Developers\nbash$ pip install --upgrade ats.robot\n```\n\n----------------------------------------\n\nTITLE: Complete End-to-End Test Automation Workflow with pyATS in Python\nDESCRIPTION: This comprehensive example demonstrates the entire process for setting up, running, and reporting a pyATS automated test session. It includes server/process initialization, client connection, starting test suites and various test steps, setting attributes/results, handling checkpoints, starting/stopping different test phases, and generating final XML output. The workflow assumes the presence of pyATS core libraries and modules (aereport.aerunner, aereport.client) and typically operates in a testing-oriented Python environment. Expected inputs are test parameters, job definitions, configuration dictionaries, and file paths; outputs are coordinated test run results and XML reports.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aereport/index.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nimport time\nimport subprocess\nfrom pyats.aereport.aerunner import AERunner\nfrom pyats.aereport.client import AEClient\nsvrpid, svrport, servername = AERunner.start_server(logsdir='/tmp/ttt/',\n                                            logfilename='logfile.log')\nclt = AEClient(port=svrport,servername=servername)\nclt.connect()\nclt.start_testsuite(**{'jobname':'job1',\n                           'submitter':'anUser'})\nclt.add_ats_packages(packages=[('Csccon', '1.1'), ('aetest', '1.2')])\nargs = {'dnsname':'aDnsName',\n'post':{'status':'aStatus',\n        'cmd':'aCmd'},\n        'bgPost':False,\n        'attributes':[{'name':'aName',\n                     'value':'aSuperValue'},\n                     {'name':'secondName',\n                     'value':'superValue2'}]}\nclt.set_tims(**args)\nclt.start_clean()\ntime.sleep(0.4)\nclt.set_initinfo(script='aScript',\n                      pargs='pargs')\nclt.set_runinfo(comment='aComment')\nclt.stop_clean()\nclt.set_initinfo(host='aHost',\n                       params={'cli':'aCli',\n                              'errors':'10',\n                              'reason':'aReason',\n                              'type':'aReportType',\n                              'sem':{'alignment':True,\n                                     'traceback':False}},\n                           )\nclt.set_ats(path= '/aPath/',\n                 versions= '5.3.0',\n                 packages=[('aPackage','1.0')])\nclt.start_jobexecution()\nclt.start_testscript(logfilepath='/tmp/logfile.log')\nclt.start_commonsetup(logfilepath='/tmp/logfile.log')\nclt.stop_commonsetup()\nclt.start_testcase (tcid='some_tc_id2',\n                         logfilepath='/tmp/logfile.log',\n                         comment='starting our beautiful testcase2')\nargs = {'name':'initinfo_name',\n        'description':'initinfo_description',\n        'fwversion': 'initinfo_fwversion',\n        'hwversion': 'initinfo_hwversion',\n        'swversion': 'initinfo_swversion',\n        'tstversion': 'initinfo_tstversion',\n        'interface': 'initinfo_interface',\n        'platform':'platform',\n        'pargs':'initinfo_pargs',\n        'uut':'initinfo_uut',\n        'logfile':{'begin':'55',\n                   'size':'10'},\n        'xref':{'file':'/init/info/file',\n                'lone':'30'},\n        'id':{'variance':'id_variance',\n              'testplan':'id_testplan',\n              'tims':{'case':'tims_case',\n                      'config':'tims_config'}}\n        }\nclt.set_initinfo(**args)\nclt.set_result(result={'mode':'override','value':'failed'})\nclt.add_userdef(name='aUserDefName',\n                     value='aSuperValue')\nclt.start_pretestcasehandler(name='apretestcasehandler')\nclt.stop_pretestcasehandler()\nclt.start_testsection(sectionid='aTestcaseSection',\n                           logfilepath='/tmp/logfile.log',\n                           xref={'file':'/init/info/file',\n                                    'line':'30'})\nclt.add_checkpoint(name='aTestcaseaCheckpoint',\n                        result='Pass')\nclt.add_checkpoint(name='aTestcaseCheckpoint2',\n                        result='Pass')\nclt.stop_testsection()\n# Start a subtest\nclt.start_subtest(subtcid='some_subtest_id',\n                       logfilepath='/tmp/logfile.log',\n                       variance='MyVariance',\n                       id={'name':'aName',\n                           'md5':'123123'},\n                       name='aName')\nclt.stop_subtest()\nclt.stop_testcase()\nclt.stop_testscript()\nclt.start_testscript(logfilepath='/tmp/logfile.log')\nclt.stop_testscript()\nclt.stop_jobexecution()\nclt.stop_testsuite()\nclt.generate_xml_reports(path='/tmp/')\nAERunner.terminate_server()\n```\n\n----------------------------------------\n\nTITLE: Upgrading the AEtest Package using pip\nDESCRIPTION: Provides the Bash command using `pip` to upgrade an existing installation of the `pyats.aetest` package to the latest version available on the Python Package Index (PyPI).\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/introduction.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npip install pyats.aetest --upgrade\n```\n\n----------------------------------------\n\nTITLE: Filtering History with Regex in pyATS\nDESCRIPTION: This code demonstrates how to filter history entries in the pyATS Tcl Interpreter using a regular expression. It uses the `filter` method of the History class to find entries that match a specific pattern (in this case, 'testVar 1'). The code requires an existing pyATS Tcl Interpreter instance with a history.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/tcl/history.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# continuing from above (but assuming we didn't reset the history)\n    tcl.history.filter(regex = 'testVar 1')\n```\n\n----------------------------------------\n\nTITLE: Specifying Test Cases for Rerun (YAML)\nDESCRIPTION: This YAML snippet defines which test cases within specific tasks should be re-executed. It specifies the task and testcase names and their associated test scripts. The file is used to configure pyATS to rerun specific tests.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/easypy/rerun.rst#_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\nTask-1:\n  testcases:\n  - name: tc_two\n  testscript: path/to/script\nTask-2:\n  testcases:\n  - name: tc_one\n  testscript: path/to/script\n```\n\n----------------------------------------\n\nTITLE: Applying Clean Content to Device Objects\nDESCRIPTION: This Python code presents a simplified view of how clean content is applied to device objects during runtime.  It shows how the clean information, specified in YAML, is integrated into the `Device.clean` dictionary. The output illustrates the combined effect of the testbed and clean files. The output represents the state of the testbed after the YAML examples above have been parsed and loaded.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/kleenex/inputs.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n    # Example\n    # -------\n    #\n    #   pseduo-code demonstrating how clean content is applied to device objects\n\n    # after the above testbed is loaded, you start with the following:\n    testbed\n    # <pyats.topology.testbed.Testbed object at 0xf705c40c>\n    testbed.devices\n    # {'example-device': <Device example-device at 0xf705cccc>}\n\n    # the device would only have the static clean information\n    # defined within the testbed yaml file\n    testbed.devices['example-device'].clean\n    # {'golden_image': '/path/to/golden/image.bin',\n    #  'preclean': 'switchname example-device\\n'\n    #              'username admin password cisco123\\n'\n    #              'no password strength-check\\n'\n    #              'interface mgmt0\\n'\n    #              '    ip address 1.1.1.10 255.255.255.0\\n'\n    #              '    no shutdown\\n'\n    #              'vrf context management\\n'\n    #              '    ip route 0.0.0.0/0 1.1.1.1\\n'\n    #              'feature telnet\\n',\n    #  }\n\n    # --------------------------------------------------\n    # once the clean information is applied, it is added\n    # directly to the device's clean dictionary, and the\n    # resulting device.clean becomes the following:\n    testbed.devices['example-device'].clean\n    # {'awesomeclean': {'check_image_md5': True},\n    #  'golden_image': '/path/to/golden/image.bin',\n    #  'images': ['/path/to/device/image/r99.9.9.bin'],\n    #  'preclean': 'switchname example-device\\n'\n    #              'username admin password cisco123\\n'\n    #              'no password strength-check\\n'\n    #              'interface mgmt0\\n'\n    #              '    ip address 1.1.1.10 255.255.255.0\\n'\n    #              '    no shutdown\\n'\n    #              'vrf context management\\n'\n    #              '    ip route 0.0.0.0/0 1.1.1.1\\n'\n    #              'feature telnet\\n',\n    #  'timeout': 900}\n```\n\n----------------------------------------\n\nTITLE: Rerun Task CLI Argument Example - Bash\nDESCRIPTION: Demonstrates the use of the `--rerun-task` CLI argument to rerun specific tasks and test cases. The argument is provided multiple times for each task to be run. The example shows running `tc1` and `tc2` from `Task-1`, and all test cases from `Task-2`.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/easypy/rerun.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n--rerun-task Task-1 /path/to/script1 tc1 tc2 --rerun-task Task-2 /path/to/script2\n```\n\n----------------------------------------\n\nTITLE: Using NestedAttrDict for Nested Data - pyATS - Python\nDESCRIPTION: Shows how NestedAttrDict automatically converts nested standard dictionaries into NestedAttrDict instances upon creation. This enables seamless attribute-based access (`.`) through multiple levels of nesting. Requires importing NestedAttrDict.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/datastructures/attrdict.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   NestedAttrDict use case\n\nfrom pyats.datastructures import NestedAttrDict\n\n# if we had a big nested dict structure\nmy_dict = {\n    'a': 1,\n    'b': 2,\n    'c': {\n        'x': 10,\n        'y': 20,\n        'z': {\n            'value': 100,\n        },\n    },\n}\n\n# create a nested attribute dictionary\nobj = NestedAttrDict(my_dict)\n\n# now you can access it via chaining\nobj.c.z.value\n# 100\n\n# it looks & feels like class instances, but is really just a\n# dictionary doing the dirty heavy lifting\n# (notice all child dicts got turned into NestedAttrDict)\nobj\n```\n\n----------------------------------------\n\nTITLE: Modify Recipient List (python)\nDESCRIPTION: This Python snippet shows how to modify the recipient list for email notifications at runtime. It demonstrates accessing the `runtime.mailbot.mailto` attribute and setting it to a list of email addresses.  This will overwrite the default recipients with the provided list. The submitter is included in the mailto list, while users passed to the mailto are appended.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/easypy/email.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# use the runtime object\ndef main(runtime):\n    mailto_list = ['userA', 'userB']\n    runtime.mailbot.mailto = mailto_list\n```\n\n----------------------------------------\n\nTITLE: Enabling and Disabling Test Execution Flags with pyATS in Python\nDESCRIPTION: This set of API functions allows toggling various configuration flags that affect test execution features such as reruns, uniqueness constraints, sorting, error handling, alignment, and traceback generation. Each method (enable/disable_*) is used to activate or deactivate a specific behavior at runtime, receiving its settings via a dictionary of keyword arguments. Inputs control boolean flags or features, and no outputs are generally produced beyond updated state in the test controller.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aereport/index.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndef enable_rerun (self, kwargs):\ndef disable_rerun (self, kwargs):\ndef enable_uniquetid (self, kwargs):\ndef disable_uniquetid (self, kwargs):\ndef enable_sort (self, kwargs):\ndef disable_sort (self, kwargs):\ndef enable_outofrange (self, kwargs):\ndef disable_outofrange (self, kwargs):\ndef enable_uniquesuites (self, kwargs):\ndef disable_uniquesuites (self, kwargs):\ndef enable_alignment (self, kwargs):\ndef disable_alignment (self, kwargs):\ndef enable_traceback (self, kwargs):\ndef disable_traceback (self, kwargs):\n```\n\n----------------------------------------\n\nTITLE: AEReport API Signatures for Handler Contexts in Python\nDESCRIPTION: Shows example Python method signatures for AEReport APIs related to handler contexts, like setup, prerun, and AE handlers (`start_setuphandler`, `stop_setuphandler`, `start_prerunhandler`, `stop_prerunhandler`, `start_aehandler`, `stop_aehandler`). These are typically used for preparation, cleanup, or post-execution tasks associated with main execution contexts.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aereport/index.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef start_setuphandler (self, kwargs):\ndef stop_setuphandler (self, kwargs):\ndef start_prerunhandler (self, kwargs):\ndef stop_prerunhandler (self, kwargs):\ndef start_aehandler (self, kwargs):\ndef stop_aehandler (self, kwargs):\n...\n```\n\n----------------------------------------\n\nTITLE: Accessing pyATS Version and Author Information\nDESCRIPTION: This snippet demonstrates how to access the version, author, and contact information for the `aetest` module within the pyATS framework.  It uses the `__version__`, `__author__`, and `__contact__` attributes of the module.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2015/june.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom ats import aetest\n\naetest.__version__\n# 2.0.0\n\naetest.__author__\n# ASG/ATS Team\n\naetest.__contact__\n# pyats-support@cisco.com\n```\n\n----------------------------------------\n\nTITLE: Executing Multiple Target Functions in Parallel with pcall in Python\nDESCRIPTION: Shows how to invoke multiple distinct functions (func1, func2, func3) in parallel using pyats.async_.pcall by passing a list of callables as the first argument. Details how common arguments (cargs, ckwargs) and instance arguments (iargs, ikwargs) are applied. Instance arguments correspond positionally to the provided list of target functions. The number of parallel processes is determined by the number of targets, and argument lists must match.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/async/pcall.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   pcall argument combinations (multiple target)\n#   (using a lot of lists this time for a change)\n\n# import pcall\nfrom pyats.async_ import pcall\n\n# define a couple function to be called by pcall\ndef func1(*args, **kwargs):\n    return dict(name = 'func1', arg = args, kwargs = kwargs)\n\ndef func2(*args, **kwargs):\n    return dict(name = 'func2', arg = args, kwargs = kwargs)\n\ndef func3(*args, **kwargs):\n    return dict(name = 'func3', arg = args, kwargs = kwargs)\n\n# positional argument building\n# ----------------------------\n#   child 1: name='func1', args=(1, 2, 3, 4, 5, 6), kwargs={}\n#   child 2: name='func2', args=(1, 2, 3, 7, 8, 9), kwargs={}\n#   child 3: name='func3', args=(1, 2, 3, 9, 10, 11), kwargs={}\npcall([func1, func2, func3], cargs = [1, 2 ,3],\n                             iargs = [[4, 5, 6], [7, 8, 9], [9, 10, 11]])\n\n# keyword argument building\n# ----------------------------\n#   child 1: name='func1', args=(), kwargs={'a': 1, 'b': 2, 'c': 3}\n#   child 2: name='func2', args=(), kwargs={'a': 1, 'b': 2, 'c': 4}\n#   child 3: name='func3', args=(), kwargs={'a': 1, 'b': 2, 'c': 5}\npcall([func1, func2, func3], ckwargs = {'a': 1, 'b': 2},\n                             ikwargs = [{'c': 3},\n                                        {'c': 4},\n                                        {'c': 5}])\n\n# combine it all together\n# -----------------------\n#   child 1: name='func1',\n#            args=(1, 2, 3, 6, 7),\n#            kwargs= {'a': 1, 'b': 2, 'c': 3, 'x': 10, 'y': 100}\n#   child 2: name='func2',\n#            args=(1, 2, 3, 8, 9),\n#            kwargs= {'a': 1, 'b': 2, 'c': 4, 'x': 20, 'y': 200}\npcall([func1, func2], cargs = (1, 2, 3),\n                      iargs = ((6, 7), (8, 9)),\n                      ckwargs = {'a': 1, 'b': 2},\n                      ikwargs = ({'c': 3}, {'c': 4}),\n                      x = (10, 20), y = (100, 200))\n\n# as usual, iargs and ikwargs's number of iterations must match\n# -------------------------------------------------------------\n#   child 1: name='func1', args=(1, 2), kwargs= {'a': 1}\n#   child 2: name='func2', args=(3, 4), kwargs= {'a': 2}\n# there is no child #3, as there is no ikwargs to match (5, 6) of iargs, and\n# thus not enough knowledge on how to call func3\npcall([func1, func2, func3], iargs = ((1, 2), (3, 4), (5, 6)),\n                             ikwargs = ({'a': 1}, {'a': 2}))\n```\n\n----------------------------------------\n\nTITLE: Defining pyATS Test Bed Devices and Topology (YAML)\nDESCRIPTION: This YAML snippet shows the configuration format for defining devices and their interfaces for use in pyATS topology loading. It covers specifying device name, type, alias, connection parameters (protocol, IP, port), and populating topology interfaces with optional alias and interface type. Required for test benches that need dynamic device connection via YAML. Inputs include device and interface details; outputs are testbed objects to be consumed by pyATS Python code. Ensure correct indentation and field values for successful parsing.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/resources/testbench.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\n# Example\n# -------\n#\n#   testbench YAML testbed file\n\ndevices:\n    device_name:                            # use actual device name here\n        type: \"device_type\"\n        alias: \"alias of device\"            # optional\n        connections:\n          a:                                # define a single connection\n            protocol: \"telnet\"\n            ip: 1.1.1.1\n            port: 8888\n\ntopology:\n    device_name:                            # use actual device name here\n        interfaces:\n            Ethernet1/1:                    # define a single interface\n                alias: \"test_intf\"          # optional\n                type: \"ethernet\"\n\n```\n\n----------------------------------------\n\nTITLE: Executing Unittests in Shell\nDESCRIPTION: This shell script demonstrates how to execute unittests within the user environment after installing PyPI packages. It navigates to the tests directory and uses the unittest module to discover and run the tests. Requires a virtual environment set up with the necessary PyPI packages installed.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2015/april.rst#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncd $VIRTUAL_ENV/lib/python3.4/ats/topology/tests/\n\npython -m unittest discover\n```\n\n----------------------------------------\n\nTITLE: Accessing Reserved Parameters Example\nDESCRIPTION: This code defines a `CommonSetup` class and demonstrates how to access reserved parameters such as `testscript`, `section`, and `steps`. It creates a local parameter named `steps` with the same name as a reserved parameter, and shows how the reserved parameters take precedence. It then uses the reserved parameters as keyword arguments to a method, and accesses the `testscript` object, `section` object, and a `steps` object.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/parameters.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n    # Example\n    # -------\n    #\n    #   accessing reserved parameters\n\n    from pyats import aetest\n\n    # using CommonSetup as an example\n    # also applicable to other TestContainer classes\n    class CommonSetup(aetest.CommonSetup):\n\n        # create a local parameter with the same name\n        # as the reserved parameter\n        parameters = {\n            'steps': object(),\n        }\n\n        # access reserved parameters by providing their\n        # names as keyword arguments to methods\n        @aetest.subsection\n        def subsection_one(self, testscript, section, steps):\n            # testscript object has an attribute called module\n            # which is this testscript's module\n            print (testscript.module)\n            # <module 'example_script' from '/path/to/example.py'>\n\n            # current section object is Subsection\n            # and subsections have a unique uid\n            print(section.uid)\n            # subsection_one\n\n            # steps object enables the usages of steps\n            with steps.start('a new demo step'):\n                pass\n\n        # reserved parameters do not show up in **kwargs\n        @aetest.subsection\n        def subsection_two(self, **kwargs):\n\n            # only the locally defined steps parameter show up\n            print(kwargs)\n            # {'steps': <object object at 0xf76fec80}>\n\n        # reserved paramters takes precedence when resolved.\n        @aetest.subsection\n        def subsection_three(self, steps):\n\n            # test steps is not the same as local paramter\n            steps is not self.parameters['steps']\n            # True\n```\n\n----------------------------------------\n\nTITLE: ScriptDiscovery Implementation Structure\nDESCRIPTION: Shows the implementation structure of the ScriptDiscovery class. This class is responsible for discovering testcases in a script file and ordering them properly for execution.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/control.rst#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nclass ScriptDiscovery():\n    def __init__(self, target):\n        self.target = target\n\n    def __iter__(self):\n        # some default logic written here\n        ...\n        for testcase in self.discover():\n            yeild instantiated_testcase\n\n    def discover(self):\n        # some default logic written here\n        ...\n        return self.order(setup, testcases, cleanup)\n\n    def order(self, setup=None, testcases=list(), cleanup=None):\n        # some default logic written here\n        ...\n        return ordered_testcases\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Script Ordering Using Python in pyATS\nDESCRIPTION: This example demonstrates how to define a custom order method in a ScriptDiscovery subclass to specify a precise execution order for setup, testcases, and cleanup sections. Dependencies include the pyATS discovery architecture and inheritance from ScriptDiscovery. The order method receives test sections as arguments and returns their desired execution sequence. Users must provide this class to runtime.discoverer.script for custom script-level ordering.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/control.rst#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nclass MyCustomScriptDiscovery(ScriptDiscovery):\n    def order(self, setup=None, testcases=list(), cleanup=None):\n        # some logic\n        return [\\\n            self.module.common_setup,\\\n            self.module.tc_two,\\\n            self.module.tc_one,\\\n            self.module.common_cleanup]\n```\n\n----------------------------------------\n\nTITLE: Email Report Default Content (text)\nDESCRIPTION: This snippet shows the default content structure of the email report subject and body. The subject and body contain dynamic fields, e.g., job name, user, and results, that are populated during runtime by Easypy.  The user is able to modify the subject and body contents in job files.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/easypy/email.rst#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n# Default Email Subject\n# ---------------------\npyATS Report - job: {runtime.job.name} by: {runtime.env.user}, total: {runtime.job.results[total]} (P:{runtime.job.results[passed]}, PX:{runtime.job.results[passx]}, F:{runtime.job.results[failed]} ...)\n\n\n# Default Email Body\n# ------------------\npyATS Instance   : {runtime.env.prefix}\nPython Version   : {runtime.env.python.name}-{runtime.env.python.version} ({runtime.env.python.architecture})\nCLI Arguments    : {runtime.env.argv.all}\nUser             : {runtime.env.user}\nHost Server      : {runtime.env.host.name}\nHost OS Version  : {runtime.env.host.distro} ({runtime.env.host.architecture})\n\nJob Information\n    Name         : {runtime.job.name}\n    Start time   : {runtime.job.starttime}\n    Stop time    : {runtime.job.stoptime}\n    Elapsed time : {runtime.job.elapsedtime}\n    Archive      : {runtime.archive}\n\nTotal Tasks    : {runtime.tasks.count} {runtime.tasks.error_str}\n\nOverall Stats\n    Passed     : {runtime.job.results[passed]}\n    Passx      : {runtime.job.results[passx]}\n    Failed     : {runtime.job.results[failed]}\n    Aborted    : {runtime.job.results[aborted]}\n    Blocked    : {runtime.job.results[blocked]}\n    Skipped    : {runtime.job.results[skipped]}\n    Errored    : {runtime.job.results[errored]}\n\n    TOTAL      : {runtime.job.results[total]}\n\nSuccess Rate   : {runtime.job.results[success_rate]:.02f}\n\nSection Stats\n    Passed     : {runtime.job.section_results[passed]}\n    Passx      : {runtime.job.section_results[passx]}\n    Failed     : {runtime.job.section_results[failed]}\n    Aborted    : {runtime.job.section_results[aborted]}\n    Blocked    : {runtime.job.section_results[blocked]}\n    Skipped    : {runtime.job.section_results[skipped]}\n    Errored    : {runtime.job.section_results[errored]}\n\n    TOTAL      : {runtime.job.section_results[total]}\n\nSection Success Rate   : {runtime.job.section_results[success_rate]:.02f}\n\n+------------------------------------------------------------------------------+\n|                             Task Result Summary                              |\n+------------------------------------------------------------------------------+\n{taskid}: {script}.{section}                                            {result}\n\n+------------------------------------------------------------------------------+\n|                             Task Result Details                              |\n+------------------------------------------------------------------------------+\n{taskid}: {script}\n|-- {section}                                                           {result}\n|   |-- {subsection}                                                    {result}\n|   |   |-- Step 1: {step}                                              {result}\n|   |   |-- Step 1.1: {substep}                                         {result}\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyATS using pip (DevNet)\nDESCRIPTION: This code snippet shows how to upgrade pyATS to the latest version using pip. It is intended for users in the DevNet community. The command upgrades the pyats package to the newest available release.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2022/october.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade pyats\n```\n\n----------------------------------------\n\nTITLE: Remote Device File Operations using pyats FileUtils Plugin\nDESCRIPTION: This code showcases how to perform file transfer operations on a remote device in a pyats testbed environment by utilizing the FileUtils class with a device-specific context. It demonstrates copying files from a local path to a remote server specified by URL, requiring an external plugin for remote device support.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/file_transfer_utilities.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.utils.fileutils import FileUtils\nfrom pyats.topology import loader\ntb = loader.load('tb.yaml')\n\nfutils = FileUtils.from_device(tb.devices['my_xyz_device'])\n futils.copyfile(\n    source = 'file:/device/local/path/to/file',\n    destination = 'ftp://myserver.domain.com/remote/path/to/file')\n```\n\n----------------------------------------\n\nTITLE: Defining Pagent and Ixia Devices in Testbed - YAML\nDESCRIPTION: Presents a YAML-formatted testbed snippet illustrating the configuration of pagent and ixia devices, including connection and authentication parameters. The example covers required fields such as device type, protocol, IP, port, and any passwords or usernames needed for automated connectivity. Targeted for use with pyATS topology loader or similar testbed management utilities, the structure allows programmatic access to device objects from automation scripts. All keys and nested sections must conform to the pyATS device specification.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2015/june.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\ndevices:\n    mypagent:\n        type: pagent\n        connections:\n            a:\n                protocol: 'telnet'\n                ip: '1.1.1.1'\n                port: 1000\n        passwords:\n            enable: lab\n    ixia:\n        type: ixia\n        connections:\n            ixia:\n                protocol: ixia\n                ip: 1.1.1.1\n                tcl_server: 1.2.2.2\n                username: ixiausername\n```\n\n----------------------------------------\n\nTITLE: Sharing States Between Tasks in pyATS\nDESCRIPTION: This snippet shows how to share information between tasks using runtime.synchro to create shared dictionary and list objects.  The testscript updates shared objects and their values synchronize to the jobfile level.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/easypy/jobfile.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n    # Example\n    # -------\n    #\n    #   passing information back from a task to the jobfile\n    #   (using runtime.synchro to create shared dict/list objects)\n\n    from pyats.easypy import run\n\n    # main() function\n    def main(runtime):\n\n        # runtime provides a multiprocessing manager instance\n        # called runtime.synchro\n\n        # create two shared objects: a dictionary and a list\n        shared_dict = runtime.synchro.dict()\n        shared_list = runtime.synchro.list()\n\n        # run the task, and pass the shared objects in as parameters\n        # if the testscript updates the shared objects, their values\n        # are also synchronized to this jobfile level\n        run(testscript = 'script_one.py',\n            runtime = runtime,\n            shared_dict = shared_dict,\n            shared_list = shared_list)\n\n        # now you can access the shared objects's values, and do more\n        # eg, check for testbed sanity flag\n        if shared_dict['testbed_is_sane']:\n            # pass it along to the next task\n            run(testscript = 'script_two.py',\n                runtime = runtime,\n                shared_dict = shared_dict,\n                shared_list = shared_list)\n```\n\n----------------------------------------\n\nTITLE: pyATS Validate Jinja2 Config Example\nDESCRIPTION: An example using `pyats validate jinja2_config` to validate a Genie configuration datafile.  Includes a testbed file and a specific sequence, showing the rendered configuration for devices R1 and R2.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/cli/pyats_validate.rst#_snippet_7\n\nLANGUAGE: text\nCODE:\n```\n$ pyats validate jinja2_config data/config_datafile.yaml --testbed-file data/testbed.yaml --sequence 1\n\nDevice R1 sequence 1:\ninterface Loopback0\nno shutdown\nip address 1.1.1.1 255.255.255.255\n\n\nDevice R2 sequence 1:\ninterface Loopback0\nno shutdown\nip address 2.2.2.2 255.255.255.255\n```\n\n----------------------------------------\n\nTITLE: Using the pyATS Secret CLI - Text\nDESCRIPTION: This snippet demonstrates general usage of the 'pyats secret' CLI tool, outlining its subcommands: 'decode', 'encode', and 'keygen'. It also lists available generic command line options such as help, verbose, and quiet. No software dependencies beyond the pyATS environment are required. The snippet expects users to substitute the appropriate subcommand to perform the desired operation and outputs either help information or subcommand results to the terminal.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/cli/pyats_secret.rst#_snippet_0\n\nLANGUAGE: Text\nCODE:\n```\nUsage:\n  pyats secret <subcommand> [options]\n\nSubcommands:\n    decode              decode an encoded string\n    encode              encode a plaintext string\n    keygen              generate a key used to encode/decode a secret string\n\nGeneral Options:\n  -h, --help            Show help\n  -v, --verbose         Give more output, additive up to 3 times.\n  -q, --quiet           Give less output, additive up to 3 times, corresponding to WARNING, ERROR,\n                        and CRITICAL logging levels\n```\n\n----------------------------------------\n\nTITLE: Instantiating Topology Objects with Name and Alias (pyATS Python)\nDESCRIPTION: Shows how to create basic `Testbed` and `Link` objects, illustrating that they have both mandatory `name` and optional `alias` attributes, which default to the name if not provided.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/topology/usage.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   Topology objects have names and aliases\n\nfrom pyats import topology\n\n# testbed object example\ntestbed = Testbed('myTestbed')\ntestbed.name\n# myTestbed\ntestbed.alias\n# myTestbed\n\n# Link object example\nlink = Link('myLink', alias = 'newLink')\nlink.name\n# myLink\nlink.alias\n# newLink\n```\n\n----------------------------------------\n\nTITLE: Encoding pyATS Secret String (Python)\nDESCRIPTION: This Python method encodes a contained plaintext string object. It utilizes the `my_encode` function, passing the configured secret key (`self.key`) and the data from the object (`self.obj.data`). This function assumes `self.key` has been validated and `self.obj.data` contains the string to be encoded. Requires the `my_encode` function to be available.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/secret_strings.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n        def encode(self):\n            \"\"\" Encode a contained plaintext string object \"\"\"\n            return my_encode(key=self.key, data=self.obj.data)\n```\n\n----------------------------------------\n\nTITLE: Using pyATS Pcall Class for Parallel Execution - Python\nDESCRIPTION: This snippet demonstrates how to use the `pyats.async_.Pcall` class to execute a single function (`add`) with multiple sets of arguments in parallel. It involves importing `Pcall`, defining the target function, instantiating `Pcall` with the function and arguments, starting the parallel processes, waiting for their completion using `join()`, and finally collecting the results from the `results` attribute.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/async/pcall.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   using the Pcall class\n\nfrom pyats.async_ import Pcall\n\n# define a function to be called in\ndef add(x, y):\n    return x + y\n\n# create a Pcall object\np = Pcall(add, x = (1, 2, 3), y = (4, 5, 6))\n\n# start all child processes\np.start()\n\n# wait for everything to finish\np.join()\n\n# collect results\nresults = p.results\n```\n\n----------------------------------------\n\nTITLE: Example: Passing Additional Arguments to Device Commands in PyATS\nDESCRIPTION: Shows how to connect to a device, execute commands with extended parameters such as timeout, reply patterns for prompts, and configuration commands with additional flags, using 'ats.topology' and 'collections.OrderedDict'. It highlights handling interactive prompts and command customization during automation tasks.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2015/january.rst#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nfrom ats.topology import Testbed\nimport collections\n\nt = Testbed(config_file='conf.yaml')\nrtr1 = t.devices['Router1']\nrtr1.connect()\n\nresult = rtr1.execute(\"show clock\", timeout=600)\nresult = rtr1.execute(\"show andndnk\", 'fail_invalid')\n\n# Execute command on standby\nresult = rtr1.execute(\"show redundancy state\", 'standby')\n\n# To provide answers to router interactive-prompts exec commands\nresponse = collections.OrderedDict()\nresponse[\"Confirm [y/n]\"] = \"send y ; expect_continue\"\nresponse[\"Confirm \"] = \"send n ; expect_continue\"\nrtr1.execute(\"show clock\", \"fail_invalid\", saveto='var', reply=response)\n\n#Config command with additional csccon flags\nrtr1.config(\"hostname 7200-28-41\", \"no logging con\", \"line con 0\", \"fail_invalid\", saveto='var')\n\n# Config command with interactive-prompts\nresponse = collections.OrderedDict()\nresponse[\"Confirm [y/n]\"] = \"send y ; expect_continue\"\nresponse[\"Confirm \"] = \"send n ; expect_continue\"\nrtr1.config(\"hostname halib-65\", \"no logging console\", \"line con 0\", \"fail_invalid\", saveto='var', reply=response)\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyats.topology and pyats.utils (Community) - bash\nDESCRIPTION: This bash command upgrades the `pyats.topology` and `pyats.utils` modules for DevNet Community users using the pip package manager. It requires pip to be installed and configured correctly to fetch packages from the standard Python Package Index.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2018/aug.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats.topology pyats.utils\n```\n\n----------------------------------------\n\nTITLE: Accessing Testbed Path in Robot Framework\nDESCRIPTION: Robot Framework script snippet demonstrating how to access the testbed file path provided via the `--testbed-file` argument during `pyats run job`. It uses the `ats.robot.pyATSRobot` library and retrieves the path from the `TESTBED` environment variable set by Easypy.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/robot/easypy.rst#_snippet_3\n\nLANGUAGE: robotframework\nCODE:\n```\n*** Settings ***\n# load pyATS framework\nLibrary        ats.robot.pyATSRobot\n\n*** Variables ***\n# set testbed to use from env variable TESTBED\n${testbed}     %{TESTBED}\n```\n\n----------------------------------------\n\nTITLE: Removing Child FileUtils Object in pyats and Cleaning Up Resources\nDESCRIPTION: Deletes a cached child FileUtils object after deallocating its resources by invoking its close method, maintaining clean resource management and preventing memory leaks in the test environment.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/file_transfer_utilities.rst#_snippet_33\n\nLANGUAGE: Python\nCODE:\n```\nfrom pyats.utils.fileutils import FileUtils\nfutils = FileUtils(testbed=tb)\nfutils_ftp = futils.get_child('ftp')\nassert futils_ftp.parent is futils\n```\n\n----------------------------------------\n\nTITLE: Tgn Module Transition to cisco-shared HLTAPI Package\nDESCRIPTION: This snippet explains the migration of the tgn module into the cisco-shared HLTAPI package, including support for new device APIs, especially Spirent TestCenter, and updated import statements to reflect the new module structure. It emphasizes non-backwards compatibility changes and new feature integration.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2016/may.rst#_snippet_12\n\nLANGUAGE: Python\nCODE:\n```\n  - The old tgn module is now moved as an independent cisco-shared\n    ``hltapi`` package with new features added. Refer to `HLTAPI Changelog`_\n\n    This is a *non-backwards compatible change*. Modify your scripts and change\n    your import statements:\n\n    .. code-block:: python\n\n        # before\n        from ats.tgn.hltapi import Ixia, Pagent\n\n        # after\n        from hltapi import Ixia, Pagent\n\n  - added support for Spirent TestCenter HLTAPIs in the new HLTAPI cisco-shared\n    package\n\n  - added support for tight integration with topology YAML files and device\n    objects in the new HLTAPI cisco-shared package\n```\n\n----------------------------------------\n\nTITLE: Upgrading PyATS using pip (DevNet)\nDESCRIPTION: This code snippet demonstrates how to upgrade the pyats package using pip for DevNet Community users. It utilizes the `pip install --upgrade pyats` command to ensure the latest version is installed from the public PyPI repository.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2022/november.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade pyats\n```\n\n----------------------------------------\n\nTITLE: Defining Testcase Cleanup with pyATS AEtest in Python\nDESCRIPTION: This snippet defines a cleanup method within a test case class using the pyATS AEtest framework in Python, utilizing the @aetest.cleanup decorator to register the method as the designated cleanup section. No dependencies beyond pyATS are required, though pyATS must be installed and appropriately imported. The 'testcase_cleanup' method receives 'self' and is intended as the location for any resource cleanup logic needed after test execution; currently, the function body contains no implementation (pass).\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/structure.rst#_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\n# define cleanup section by applying @cleanup decorator\n@aetest.cleanup\ndef testcase_cleanup(self):\n    pass\n```\n\n----------------------------------------\n\nTITLE: Enabling Testcase Randomization in AEtest Execution - Python and Bash\nDESCRIPTION: Activates randomization of testcase execution order, allowing testcases to be shuffled before running. This can be enabled via command-line flag or API arguments. Dependencies include AEtest's randomization features and potential seeding for reproducibility. The input is a boolean flag; outputs affect testcase order. Random_seed can also be specified to reproduce specific sequences. Use with caution as it impacts test predictability.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/run.rst#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nbash$ python testscript.py -random\n```\n\nLANGUAGE: python\nCODE:\n```\naetest.main('testscript.py', random = True)\n```\n\nLANGUAGE: python\nCODE:\n```\nrun(testscript = 'testscript.py', random = True)\n```\n\n----------------------------------------\n\nTITLE: Upgrading core pyATS package (bash)\nDESCRIPTION: This snippet provides the standard command to upgrade the core 'ats' package, which includes many pyATS modules. This is typically used for major releases like v3.3.0, updating the entire framework.\nDependencies: Python environment with pip installed, internet access.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2017/may.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Example Easypy Output for Robot Script Execution\nDESCRIPTION: Illustrative text output showing how Easypy reports the results of running the `hello_world.robot` script. It displays the task result summary and detailed breakdown, mapping Robot test cases to Easypy tasks and Robot keywords to Easypy test sections.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/robot/easypy.rst#_snippet_5\n\nLANGUAGE: text\nCODE:\n```\n+------------------------------------------------------------------------------+\n|                             Task Result Summary                              |\n+------------------------------------------------------------------------------+\nTask-1: hello_world.Should Pass                                           PASSED\nTask-1: hello_world.Should Fail                                           FAILED\nTask-1: hello_world.Logging Test                                          PASSED\nTask-1: hello_world.Check Testbed Provided                                FAILED\n\n+------------------------------------------------------------------------------+\n|                             Task Result Details                              |\n+------------------------------------------------------------------------------+\nTask-1: hello_world\n|-- Should Pass                                                           PASSED\n|   `-- 1_Hello World                                                     PASSED\n|-- Should Fail                                                           FAILED\n|   `-- 1_Raise Exception                                                 FAILED\n|-- Logging Test                                                          PASSED\n|   `-- 1_Do Logging                                                      PASSED\n`-- Check Testbed Provided                                                FAILED\n    `-- 1_Check Testbed                                                   FAILED\n```\n\n----------------------------------------\n\nTITLE: pyATS Easypy Job Runinfo Directory Structure (Text)\nDESCRIPTION: This text block illustrates the typical structure of the 'runinfo' directory generated during a pyATS Easypy job execution. It contains timestamped directories for each specific job run (e.g., 'example_job.2015Sept14_10:05:13'), holding all logs and artifacts for that run. Additionally, a symbolic link named after the job (e.g., 'example_job') points to the most recent run directory for easy access.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/easypy/behavior.rst#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\n# Typical runinfo Structure\n# -------------------------\n#\n#   assuming the current job name is \"example_job\" and is running\n\nruninfo\n|-- example_job                           -> symlink to job runinfo\n|-- example_job.2015Sept14_10:05:13       -> job runinfo directory\n```\n\n----------------------------------------\n\nTITLE: Installing Pyats Package with pip (Bash)\nDESCRIPTION: This snippet provides the command to upgrade the Pyats package using pip.  It installs the latest version of the pyats package.  For DevNet community users, it uses the standard pip install command.  For Cisco internal developers, it also uses pip install, but the specific package location might differ.  The primary dependency is Python and the pip package manager.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2023/march.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\n# Upgrading Pyats package\nbash$ pip install --upgrade pyats\n```\n\nLANGUAGE: bash\nCODE:\n```\n# Cisco Internal Developers\n# Upgrading Pyats package\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Locked Connection Usage with Pcall in Python\nDESCRIPTION: Shows how to use a multiprocessing-safe connection (like the locked `TelnetConnection`) with `pyats.async_.Pcall` to execute multiple commands concurrently. The locks ensure that commands are executed sequentially on the single connection instance, preventing interference between processes. Assumes a `device` object is available and connected using the locked `TelnetConnection`.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/connections/sharing.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   demonstrating the above code in a multiprocessing environment\n#   (using async_.pcall as an example)\n\nfrom pyats.async_ import Pcall\n\n# assuming we had an imaginary device object...\n\n# using the above device and TelnetConnection, create a session\n# device.connect(cls = TelnetConnection, via = 'console') # Assumed setup\n\n# now let's use Pcall to perfrom two commands at the same time\n# in forked, child processes\n# output = Pcall(device.execute, \n#                command = ['show version', 'show running-config']) \n# Placeholder for actual execution\n\n```\n\n----------------------------------------\n\nTITLE: Usage Example of EmailMsg Class for Sending Email with pyATS\nDESCRIPTION: This snippet demonstrates how to instantiate the EmailMsg class, set email parameters such as sender, recipients, subject, and message body, and invoke the send() method to dispatch the email. It also shows how to send an HTML email and attach files by configuring respective parameters before sending.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/easypy/email.rst#_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\n# Import EmailMsg class\nfrom pyats.utils.email import EmailMsg\n\n# Create email message object\nmail = EmailMsg(\n    from_email=email_from_address,\n    to_email=email_to_address,\n    subject=email_subject,\n    body=email_body)\n\n# Send email\nmail.send()\n\n# Sending HTML email\nhtml_mail = EmailMsg(\n    from_email=email_from_address,\n    to_email=email_to_address,\n    subject=email_subject,\n    html_email=True,\n    html_body=html_body)\n\n# Adding attachments\nattach_mail = EmailMsg(\n    from_email=email_from_address,\n    to_email=email_to_address,\n    subject=email_subject,\n    body=email_body,\n    attachments=['/path/to/file'])\n```\n\n----------------------------------------\n\nTITLE: Cloning and Running pyATS Examples (Bash)\nDESCRIPTION: This sequence of Bash commands demonstrates how to set up and run pyATS examples from the command line. It includes activating the pyATS virtual environment (`source env.sh`), cloning the examples repository from GitHub (`git clone`), changing into the examples directory (`cd examples`), and finally executing a specific example job file (`basic/basic_example_job.py`) using the `pyats run job` command.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/getting_started/index.rst#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n# Example\n# -------\n#\n#   launching pyats from the command line\n\n# activating pyats instance\n# (if you have not yet activated)\n[tony@jarvis:~]$ cd /ws/tony-stark/pyats\n[tony@jarvis:pyats]$ source env.sh\n\n# clone example folder\n(pyats) [tony@jarvis:pyats]$ git clone https://github.com/CiscoTestAutomation/examples\n(pyats) [tony@jarvis:pyats]$ cd examples\n\n# start with executing the basic examples jobfiles.\n# this is a basic example demonstrating the usage of a jobfiles,\n# and running through a single aetest testscript.\n(pyats) [tony@jarvis:examples]$ pyats run job basic/basic_example_job.py\n```\n\n----------------------------------------\n\nTITLE: Sample Results File in YAML Format\nDESCRIPTION: An example of a results.yaml file generated by the Reporter package, showing the hierarchical structure with a TestSuite containing a Task with CommonSetup section. The example demonstrates actual field values and formatting.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/reporter/overview.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nversion: '2'\nreport:\n  type: TestSuite\n  id: example_job.2019Sep19_19:56:06.569499\n  name: example_job\n  starttime: 2019-09-19 19:56:07.603283\n  stoptime: 2019-09-19 19:56:19.951458\n  runtime: 12.35\n  cli: pyats run job job/example_job.py --testbed-file etc/example_testbed.yaml\n    --no-mail\n  jobfile: /Users/user/examples/comprehensive/job/example_job.py\n  jobfile_hash: 2a452a8683f4f5e5c146d62c78a9a5253198e19c3fb6c8c1771bdf0eea622086\n  pyatspath: /Users/user/env\n  pyatsversion: '19.11'\n  host: HOSTNAME\n  submitter: user\n  archivefile: /Users/user/env/users/user/archive/19-09/example_job.2019Sep19_19:56:06.569499.zip\n  summary:\n    passed: 13\n    passx: 0\n    failed: 1\n    errored: 12\n    aborted: 0\n    blocked: 4\n    skipped: 0\n    total: 30\n    success_rate: 43.33\n  extra:\n    testbed: example_testbed\n  tasks:\n    - type: Task\n      id: Task-1\n      name: base_example\n      starttime: 2019-09-19 19:56:08.432390\n      stoptime: 2019-09-19 19:56:08.617640\n      runtime: 0.19\n      description: |+\n        base_example.py\n\n        This is a comprehensive example base script that walks users through AEtest\n        infrastructure features, what they are for, how they are used, how it impacts\n        their testing, etc.\n\n      logfile: TaskLog.Task-1\n      testscript: /Users/user/examples/comprehensive/base_example.py\n      testscript_hash: 2938f2d2efbf9be144a9fe68667dd1c12753b84017a56e7d04caefe46edc0602\n      parameters:\n        labels: {}\n        links: []\n        parameter_A: jobfile value A\n        routers: []\n        testbed: <pyats.topology.testbed.Testbed object at 0x106da92b0>\n        tgns: []\n      summary:\n        passed: 3\n        passx: 0\n        failed: 0\n        errored: 3\n        aborted: 0\n        blocked: 0\n        skipped: 0\n        total: 6\n        success_rate: 50.0\n      sections:\n        - type: CommonSetup\n          id: common_setup\n          name: common_setup\n          starttime: 2019-09-19 19:56:08.434411\n          stoptime: 2019-09-19 19:56:08.458939\n          runtime: 0.02\n          description: |+\n            Common Setup Section\n\n                This is the docstring for your common setup section. Users should document\n                the number of common setup subsections so that by reading this block of\n                comments, it gives a generic feeling as to how CommonSetup is built and run.\n\n          xref:\n            file: /Users/user/examples/comprehensive/base_example.py\n            line: 191\n            source_hash: c366a269e45838deb9bed54d28fef648b921c4f19a1753fc1e46e4c9ba3f9264\n          logs:\n            begin: 0\n            file: TaskLog.Task-1\n            size: 4317\n```\n\n----------------------------------------\n\nTITLE: Validating pyATS Secrets Key (Python)\nDESCRIPTION: This code snippet checks if a secret key is specified in the pyATS configuration under the `[secrets]` string.key path. If the key is not found, it raises an Exception, guiding the user to configure or generate a key using the `pyats secret keygen` command. This ensures that encoding and decoding operations have a valid key.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/secret_strings.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n                raise Exception(\"A key must be specified as pyATS \"\n                    \"configuration under [secrets] string.key.\\n\"\n                    \"This key may be generated with \"\n                    \"the 'pyats secret keygen' command\")\n            return key\n```\n\n----------------------------------------\n\nTITLE: Using Manual Result Settings in aetest\nDESCRIPTION: This snippet demonstrates how to manually set results within aetest using the provided APIs (passed, failed, skipped). It showcases the immediate termination of a section upon calling these APIs, and demonstrates how to add reasons for the result.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/results.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats import aetest\n\n# using common setup as an example for a change\nclass CommonSetup(aetest.CommonSetup):\n\n    @aetest.subsection\n    def subsection_that_passes(self):\n        self.passed(\"failure is not an option\")\n\n        # any code after a result api is not executed\n        evenThisAPICallThatDoesNotExist()\n\n    @aetest.subsection\n    def subsection_that_fails(self):\n        self.failed(\"failure... is a must in this test\")\n\n    @aetest.subsection\n    def subsection_that_is_skipped(self):\n        self.skipped(\"i don't want to run this section.\")\n```\n\n----------------------------------------\n\nTITLE: Summary of Recent Changes and Bug Fixes in pyATS v19.6\nDESCRIPTION: Summarizes key modifications in the latest pyATS release, including bug fixes such as regex bugs in FTP plugins, job loader improvements, SMTP server documentation updates, and internal bug resolutions related to TIMS uploading. These updates enhance stability, security, and functionality.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2019/june.rst#_snippet_2\n\nLANGUAGE: reStructuredText\nCODE:\n```\nChanges\n^^^^^^^\n\n- now prints deprecation warnings in pyats cli\n\n- fixed a bug with regex for file listing match in FileUtils ftp plugin\n\n- fixed a bug with Easypy job file loader where it does not add job directory to ``sys.path``.\n\n- updated SMTP server customization documentation to reflect latest uses of pyATS configuration file\n\n- [Cisco Internal only] fixed a bug in ``pyats.cisco`` TIMS uploading module where ``archive_file`` is not uploaded as an attribute field\n```\n\n----------------------------------------\n\nTITLE: Importing pyats.async (Legacy) - Python\nDESCRIPTION: Shows the import statement `from pyats.async import pcall`. This import path is for pyATS versions prior to v19.0. It is not directly compatible with Python 3.7+ or pyATS v19.0+ due to the `async` keyword becoming reserved.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2019/mar.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# eg, from this\nfrom pyats.async import pcall\n```\n\n----------------------------------------\n\nTITLE: Loading pyATS Testbed from YAML - Python\nDESCRIPTION: This Python snippet shows the new method for loading a pyATS testbed configuration from a YAML file. It utilizes the `loader` function from the `ats.topology` module to parse the file and return the corresponding topology objects within a `Testbed` instance.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2015/march.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom ats.topology import loader\ntestbed = loader.load('/path/to/yaml')\n```\n\n----------------------------------------\n\nTITLE: pyATS Validate Datafile Example\nDESCRIPTION: An example of validating an AEtest datafile using `pyats validate datafile`. It shows the command, the loaded datafile content and any YAML lint messages.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/cli/pyats_validate.rst#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\n# Example\n# -------\n#\n#   validating an AEtest datafile\n\nbash$ pyats validate datafile $VIRTUAL_ENV/examples/comprehensive/data/base_datafile.yaml\nLoading datafile: examples/comprehensive/data/base_datafile.yaml\n--------------------------------------------------------------------------------\nparameters:\n  parameter_A: datafile value A\n  parameter_B: datafile value B\ntestcases:\n  ExampleTestcase:\n    uid: ExampleTestcaseDatafileID\n    description: 'block of text describing what this testcase does\n\n      '\n    groups:\n    - group_A\n    - group_B\n    - group_C\n    - group_D\n    parameters:\n      local_A: datafile value A\n      local_B: datafile value B\n    data_A: attribute data A\n    data_B: attribute data B\n  LoopedTestcase:\n    groups: []\n  TestcaseWithSteps:\n    uid: TestcaseWithStepsDatafileID\n\n\nYAML Lint Messages\n------------------\n  5:75      error    trailing spaces  (trailing-spaces)\n  19:42     error    trailing spaces  (trailing-spaces)\n  53:1      error    trailing spaces  (trailing-spaces)\n  72:41     error    no new line character at the end of file  (new-line-at-end-of-file)\n```\n\n----------------------------------------\n\nTITLE: Defining Cleanup Section in pyATS Testcase (Python)\nDESCRIPTION: This snippet illustrates defining an optional cleanup section for a specific `aetest.Testcase`. A method within the `Testcase` class, decorated with `@aetest.cleanup`, is executed after all other sections in that testcase to revert configurations and return the environment to its original state.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/structure.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   cleanup sections\n\nfrom pyats import aetest\n\n# cleanup section within Testcases\nclass Testcase(aetest.Testcase):\n\n    # define cleanup section by applying @cleanup decorator\n    @aetest.cleanup\n    def testcase_cleanup(self):\n        pass\n```\n\n----------------------------------------\n\nTITLE: Listing pyATS Runtime Environment Attributes (Text)\nDESCRIPTION: This text block lists the various attributes available under the 'runtime.env' object in pyATS Easypy. These attributes provide details about the execution environment, including command-line arguments, pyATS paths, Python version and architecture, user information, and host system details (hostname, OS distribution, kernel, architecture).\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/easypy/behavior.rst#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n# Runtime Environment Attributes\n# ------------------------------\n\nenv.argv.all              command line arguments easypy was called with\nenv.argv.custom           all user arguments not recognized by easypy\nenv.prefix                pyATS virtual environment root path\nenv.python.tag            python tag, eg, cpython-34\nenv.python.name           python name, eg, cpython\nenv.python.version        python version, eg, 3.4.1\nenv.python.architecture   python build architecture, eg, 32bit/64bit\nenv.env.user              user id (whoami)\nenv.host.name             exec server hostname\nenv.host.distro           exec server's Linux distribution\nenv.host.kernel           exec server's Linux kernel version string\nenv.host.architecture     exec server's system architecture\n```\n\n----------------------------------------\n\nTITLE: Retrieving Server Configuration Block in pyats FileUtils\nDESCRIPTION: Fetches the server block dictionary from the testbed given a server name or IP address, allowing access to configuration details related to that server. This method relies on the pyats.utils.fileutils.FileUtils class and the existing testbed object.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/file_transfer_utilities.rst#_snippet_31\n\nLANGUAGE: Python\nCODE:\n```\nfrom pyats.utils.fileutils import FileUtils\nfutils = FileUtils(testbed=tb)\nserver_block = futils.get_server_block(server_name)\n```\n\n----------------------------------------\n\nTITLE: Installing pyATS - bash\nDESCRIPTION: This snippet provides the command to upgrade pyATS using pip.  It's split into two scenarios: DevNet community users and Cisco internal developers. The command uses `pip install --upgrade` to ensure the latest version is installed, updating the pyATS library and its dependencies.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2019/july.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats\n```\n\nLANGUAGE: bash\nCODE:\n```\n# Cisco Internal Developers\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Upgrading ats.kleenex version\nDESCRIPTION: This command upgrades the ats.kleenex package to the latest version using pip. This is a specific upgrade instruction for the kleenex module.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2016/july.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats.kleenex\n```\n\n----------------------------------------\n\nTITLE: Using clean-platform-image Parameter in pyATS\nDESCRIPTION: Illustrates how to use the --clean-platform-image parameter to specify images for cleaning based on device platform. This allows targeting specific hardware platforms for image cleaning operations.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/kleenex/usages.rst#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pyats run job jobfile.py --testbed-file /path/to/my/testbed.yaml\\\n                                   --clean-file /path/to/my/clean.yaml\n                                   --invoke-clean\n                                   --clean-platform-image n9k:/path/to/clean_image.bin\n```\n\n----------------------------------------\n\nTITLE: Report Section Configuration (ini)\nDESCRIPTION: This code block is an example of report configuration using INI format.  It configures which sections are counted for reporting. The `report.sections` option determines which sections (TestSection, SetupSection, CleanupSection) are included in the email report.  This setting affects how the statistics are calculated and displayed.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/easypy/email.rst#_snippet_1\n\nLANGUAGE: ini\nCODE:\n```\n# report configuration\n[report]\nsections = TestSection SetupSection CleanupSection\n```\n\n----------------------------------------\n\nTITLE: Defining the EmailMsg Class for Sending Emails in Python\nDESCRIPTION: The EmailMsg class acts as a wrapper around Python's email and smtplib modules, facilitating the creation and sending of email messages. It supports setting sender and recipient addresses, subject, plain text and HTML bodies, and file attachments. All parameters are optional and can be adjusted before invoking send(). The class enables sending emails with support for multiple recipients, HTML formatting, and attachments.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/easypy/email.rst#_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\nclass EmailMsg:\n    \"\"\"Wrapper around Python email and smtplib modules for sending emails.\"\"\"\n    def __init__(self, from_email=None, to_email=None, subject=None, body=None, attachments=None, html_email=False, html_body=None):\n        self.from_email = from_email\n        self.to_email = to_email\n        self.subject = subject\n        self.body = body\n        self.attachments = attachments if attachments else []\n        self.html_email = html_email\n        self.html_body = html_body\n    def send(self):\n        # Implementation to send email via SMTP\n        pass\n```\n\n----------------------------------------\n\nTITLE: Implementing Method Locks for TelnetConnection in Python\nDESCRIPTION: Illustrates how to add thread-safety to a custom `TelnetConnection` class by applying the `@BaseConnection.locked` decorator to methods performing connection actions (`connect`, `send`, `receive`, `execute`, `configure`). This ensures that only one process or thread can execute these methods on a given instance at a time, preventing race conditions. Requires inheriting from `pyats.connections.BaseConnection`.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/connections/sharing.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   adding locking & unlocking to our rudimentary telnetlib implementation\n\nimport telnetlib\n\nfrom pyats.connections import BaseConnection\n\nclass TelnetConnection(BaseConnection):\n    '''TelnetConnection\n\n    the same TelnetConnection class as previous chapter, now with locking\n    '''\n\n    def __init__(self, *args, **kwargs):\n        # ...\n        # same code as before\n        pass # Placeholder for actual implementation\n\n    @BaseConnection.locked\n    def connect(self):\n        # ...\n        # same code as before\n        pass # Placeholder for actual implementation\n\n    @BaseConnection.locked\n    def send(self, text):\n        # ...\n        # same code as before\n        pass # Placeholder for actual implementation\n\n    @BaseConnection.locked\n    def receive(self):\n        # ...\n        # same code as before\n        pass # Placeholder for actual implementation\n\n    @BaseConnection.locked\n    def execute(self, command):\n        # ...\n        # same code as before\n        pass # Placeholder for actual implementation\n\n    @BaseConnection.locked\n    def configure(self, *args, **kwargs):\n        # ...\n        # same code as before\n        pass # Placeholder for actual implementation\n```\n\n----------------------------------------\n\nTITLE: Upgrading Pyats via pip Bash Commands\nDESCRIPTION: Provides shell commands to upgrade the Pyats framework to the latest version using pip. The snippet differentiates between commands for DevNet Community users and Cisco internal developers. It requires an environment with pip installed and appropriate permissions for package installation. The commands expect a network connection to PyPI or the internal package repository and output success messages or errors based on the upgrade process.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2024/march.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats\n\n# Cisco Internal Developers\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Executing Commands on Testbed Devices\nDESCRIPTION: This Python snippet demonstrates how to execute commands on devices within a pyATS testbed in parallel. It assumes a 'testbed' object exists, which contains the device information.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/topology/concept.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# execute commands against all devices in parallel\ntestbed.execute('show version')\n```\n\n----------------------------------------\n\nTITLE: Defining pyATS aetest Processors Syntax (Text)\nDESCRIPTION: Shows the general syntax for the `@processors` decorator used to attach lists of pre-processors, post-processors, and exception-processors to a test section or container in pyATS aetest. It uses keywords `pre`, `post`, and `exception` to specify the processor types.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/processors.rst#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nSyntax\n------\n\n    @processors(pre = [list of pre-processor objects],\n                post = [list of post-processor objects],\n                exception = [list of exception-processor objects])\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyats.kleenex via pip (Cisco Internal)\nDESCRIPTION: This command upgrades the ats.kleenex module using pip for Cisco internal developers. It ensures that the latest version of the module is installed, providing access to internal features and bug fixes.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2019/jan.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats.kleenex\n```\n\n----------------------------------------\n\nTITLE: Creating Child FileUtils Object in pyats for OS-specific Operations\nDESCRIPTION: Returns a cached or new instance of a child FileUtils object for a specific protocol or abstraction layer, establishing a parent-child relationship. This supports modular handling of different OS or protocol-specific utilities within the testbed.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/file_transfer_utilities.rst#_snippet_32\n\nLANGUAGE: Python\nCODE:\n```\nfrom pyats.utils.fileutils import FileUtils\nfutils = FileUtils(testbed=tb)\nfutils_ftp = futils.get_child('ftp')\nassert futils_ftp.parent is futils\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyats using pip (DevNet)\nDESCRIPTION: This code snippet demonstrates how to upgrade the pyats package using pip for users within the DevNet Community. It uses the `pip install --upgrade pyats` command to update to the latest available version.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2024/july.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade pyats\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for the bases Package using Sphinx\nDESCRIPTION: Uses the Sphinx `automodule` directive to automatically generate documentation for the `pyats.utils.fileutils.bases` Python package. The options `:members:`, `:undoc-members:`, and `:show-inheritance:` instruct Sphinx to include documentation for all members (including those without docstrings) and to display the inheritance diagram.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/apidoc/utils/pyats.utils.fileutils.bases.rst#_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: pyats.utils.fileutils.bases\n   :members:\n   :undoc-members:\n   :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyATS modules using pip\nDESCRIPTION: This code snippet demonstrates how to upgrade the ats.topology, ats.examples, and ats.bringup modules using the pip package manager. It uses the `--upgrade` flag to ensure that the latest versions of the modules are installed. The command should be executed in a bash shell environment.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2015/november.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install --upgrade ats.topology ats.examples ats.bringup\n```\n\n----------------------------------------\n\nTITLE: Uninstalling Legacy pyATS Packages (Python-2) - Bash\nDESCRIPTION: Lists a sequence of pip uninstall commands to remove all pyATS module packages with '-py2' postfix, preparing the environment for Python 2 compatible wheels. Intended for use before installing the consolidated 'ats' package; necessary if upgrading from older pyATS installations. Each command targets a specific submodule and should be run sequentially. After executing, the user should re-install pyATS using pip for Python-2 support.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2015/june.rst#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip uninstall ats \nbash$ pip uninstall ats.aereport \nbash$ pip uninstall ats.aetest \nbash$ pip uninstall ats.atslog \nbash$ pip uninstall ats.clean \nbash$ pip uninstall ats.connections \nbash$ pip uninstall ats.datastructures \nbash$ pip uninstall ats.easypy \nbash$ pip uninstall ats.examples \nbash$ pip uninstall ats.results \nbash$ pip uninstall ats.tcl \nbash$ pip uninstall ats.templates \nbash$ pip uninstall ats.tgn \nbash$ pip uninstall ats.tims \nbash$ pip uninstall ats.topology \nbash$ pip uninstall ats.utils \n```\n\n----------------------------------------\n\nTITLE: Upgrade pyATS Framework Using Bash Commands\nDESCRIPTION: Provides shell commands to upgrade the pyATS framework for different user groups. The commands utilize pip to install the latest version, ensuring the environment has the most recent features and fixes.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2019/june.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats\n\n# Cisco Internal Developers\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Defining Basic pyATS Processor Function - Python\nDESCRIPTION: Illustrates the basic function signature for a pyATS processor that receives the current executing section as an argument. This signature is used when defining processor functions.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/processors.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef processorFunc(section):\n    pass\n```\n\n----------------------------------------\n\nTITLE: Upgrading ats.aetest module (bash)\nDESCRIPTION: This snippet provides the command to upgrade the 'ats.aetest' module to the latest version using pip. It ensures users have the newest features and bug fixes for the AEtest test execution engine.\nDependencies: Python environment with pip installed, internet access.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2017/may.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats.aetest\n```\n\n----------------------------------------\n\nTITLE: Configuring Device Images via Directory with Validation (YAML)\nDESCRIPTION: Shows how to specify images by providing a base directory (which can be a URL) and using additional parameters like 'include' to validate or search for images within that directory. This is useful for managing images based on roles or patterns.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/kleenex/inputs.rst#_snippet_7\n\nLANGUAGE: YAML\nCODE:\n```\n# For example:\n#  images:\n#    role_defaults:\n#      base_dir : ftp://server.com/path/to/images\n#      cardinality: 1\n#    kick:\n#      include: '.*kick.*\\.bin'\n```\n\n----------------------------------------\n\nTITLE: Upgrading PyATS Framework - Bash\nDESCRIPTION: This snippet provides bash commands to upgrade the PyATS framework and its dependencies. It includes distinct instructions for general users from the DevNet community and Cisco internal developers. It relies on pip package manager to update PyATS related packages to the latest version.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2022/april.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats\n\n# Cisco Internal Developers\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Setting Custom Key/Value Pairs in YAML\nDESCRIPTION: This snippet illustrates setting custom key/value pairs as attributes within a testcase and also within the common_cleanup section. This allows for passing arbitrary data to the test.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/datafile.rst#_snippet_3\n\nLANGUAGE: YAML\nCODE:\n```\n            # any custom key/value pairs to be set as data (attributes) to\n            # this testcase class\n            <key>: <value>\n```\n\nLANGUAGE: YAML\nCODE:\n```\n        # any custom key/value pairs to be set as data (attributes) to\n        # your script's common_cleanup section\n        <key>: <value>\n```\n\nLANGUAGE: YAML\nCODE:\n```\n    # any other key/value pairs to be set as variables/attributes directly\n    # into your testscript module\n    <key>: <value>\n```\n\n----------------------------------------\n\nTITLE: Customizing Common Discovery Section Ordering in pyATS with Python\nDESCRIPTION: This snippet shows how to implement an order method in a CommonDiscovery subclass to provide a specific ordering of subsections. The method receives sections as arguments and returns the preferred ordering, enabling fine-grained control over common setup or cleanup flows. Dependencies: pyATS CommonDiscovery base class. Expected usage: assign to runtime.discoverer.common or use per section with a discoverer attribute.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/control.rst#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nclass MyCustomCommonDiscovery(CommonDiscovery):\n    def order(self, *sections):\n        # some logic\n        return [\\\n            self.target.subsection1,\\\n            self.target.subsection2]\n```\n\n----------------------------------------\n\nTITLE: Filtering Testcases using Logical Groups in pyATS (Python)\nDESCRIPTION: Demonstrates importing `And`, `Not` from `pyats.datastructures.logic` and using them with the `groups` argument either programmatically in a script runner function or via the command line. This allows selectively executing testcases based on assigned group tags like 'sanity' and 'traffic'.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/control.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# import the logic objects\nfrom pyats.datastructures.logic import And, Not\n\n# same as above, run sanity non-traffic testcases\nrun('example_script.py', groups = And('sanity', Not('traffic')))\n```\n\nLANGUAGE: bash\nCODE:\n```\n# or, from command line:\n# python example.py -groups=\"And('sanity', Not('traffic'))\"\n```\n\n----------------------------------------\n\nTITLE: Running pyATS Job with Testbed File - Bash\nDESCRIPTION: Demonstrates how to run a pyATS job script and supply a network testbed YAML file via the --testbed-file argument. pyATS will automatically use the topology.loader to parse the YAML file and provide the loaded testbed object to the script. The file path can be either local or a URL to a remote YAML file.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/topology/creation.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npyats run job jobfile.py --testbed-file /path/to/my/testbed/file/testbed.yaml\npyats run job jobfile.py --testbed-file \"https://<url>/testbed.yaml\"\n```\n\n----------------------------------------\n\nTITLE: Using Callable-Based Logic Operators with pyATS (Python)\nDESCRIPTION: Demonstrates how to instantiate and use logical operator classes And, Or, and Not with callable predicate functions to perform Boolean operations. Shows how these operators are composed using user-defined functions (e.g., is_int, is_str, greater_than_10), and how instances are used for logical evaluation. No external dependencies beyond pyATS are required; all callables must be compatible with the logic operator APIs. Inputs are any arguments forwarded to the predicates, and outputs are boolean values derived from the composed logic. Limitations: short-circuiting may occur, and all callables must accept a single input argument.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/datastructures/logic.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   operator using callables\n\nfrom pyats.datastructures.logic import And, Not, Or\n\n# creating some functions to be used for operation testing\ndef is_int(value):\n    # tests if value is a number\n    return isinstance(value, int)\n\ndef is_str(value):\n    # tests if value is a string\n    return isinstance(value, str)\n\ndef greater_than_10(value):\n    # tests if value is greater than 10\n    return value > 10\n\n# create some operations using the function callables\nint_greater_than_10 = And(is_int, greater_than_10)\nint_or_str = Or(is_int, is_str)\nnot_int = Not(is_int)\n\n# do some testing\n# ---------------\n\n# 1 is an integer, but less than 10\nint_greater_than_10(1)\nFalse\n\n# 999 is an integer and also greater than 10\nint_greater_than_10(999)\nTrue\n\n# \"1\" is str, not int.\n# note that the logic is built-around quick evaluations: if the first\n# expression is not True, the logic aborts and returns immediately.\nint_greater_than_10(\"1\")\nFalse\n\nint_or_str(\"1\")\nTrue\n\nnot_int(\"1\")\nTrue\n\n```\n\n----------------------------------------\n\nTITLE: Upgrading PyATS modules for April 30, 2018 release\nDESCRIPTION: Bash commands to upgrade pyats.robot, pyats.easypy, and pyats.utils packages to their latest versions. Separate commands are provided for DevNet Community and Cisco Internal Developers.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2018/apr.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats.robot pyats.easypy pyats.utils\n\n# Cisco Internal Developers\nbash$ pip install --upgrade ats.robot ats.easypy ats.utils\n```\n\n----------------------------------------\n\nTITLE: Documenting pyats.aereport Package Structure using Sphinx\nDESCRIPTION: This snippet uses Sphinx's `automodule` and `toctree` directives to document the structure and contents of the `pyats.aereport` package. It displays the members, undocumented members, and inheritance hierarchy of the specified modules and subpackages. It is essential for automatically generating documentation from Python code.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/apidoc/aereport/index.rst#_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: pyats.aereport\n   :members:\n   :undoc-members:\n   :show-inheritance:\n\n.. toctree::\n\n   pyats.aereport.exceptions\n   pyats.aereport.initinfo\n   pyats.aereport.iou\n   pyats.aereport.logview\n   pyats.aereport.results\n   pyats.aereport.runinfo\n   pyats.aereport.testscript\n   pyats.aereport.testscriptinitinfo\n   pyats.aereport.testsuite\n   pyats.aereport.tims\n   pyats.aereport.toplevel\n   pyats.aereport.tsinitinfo\n   pyats.aereport.utils\n\n\n.. automodule:: pyats.aereport.aerunner\n   :members:\n   :undoc-members:\n   :show-inheritance:\n\n\n.. automodule:: pyats.aereport.clean\n   :members:\n   :undoc-members:\n   :show-inheritance:\n\n\n.. automodule:: pyats.aereport.client\n   :members:\n   :undoc-members:\n   :show-inheritance:\n\n\n.. automodule:: pyats.aereport.clientSection\n   :members:\n   :undoc-members:\n   :show-inheritance:\n\n\n.. automodule:: pyats.aereport.clientSubtest\n   :members:\n   :undoc-members:\n   :show-inheritance:\n\n\n.. automodule:: pyats.aereport.clientTestcase\n   :members:\n   :undoc-members:\n   :show-inheritance:\n\n\n.. automodule:: pyats.aereport.clientTestscript\n   :members:\n   :undoc-members:\n   :show-inheritance:\n\n\n.. automodule:: pyats.aereport.easypy_sim\n   :members:\n   :undoc-members:\n   :show-inheritance:\n\n\n.. automodule:: pyats.aereport.handlers\n   :members:\n   :undoc-members:\n   :show-inheritance:\n\n\n.. automodule:: pyats.aereport.infra\n   :members:\n   :undoc-members:\n   :show-inheritance:\n\n\n.. automodule:: pyats.aereport.template\n   :members:\n   :undoc-members:\n   :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: RobotFramework Example: Run pyATS Testcase\nDESCRIPTION: This RobotFramework snippet demonstrates how to execute a pyATS testcase within a RobotFramework test.  It uses the `run testcase` keyword from the `ats.robot.pyATSRobot` library. The `run testcase` keyword executes the specified pyATS script and function (e.g., `basic_example_script.tc_one`), enabling integration of pyATS test logic into RobotFramework test suites.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/robot/native.rst#_snippet_2\n\nLANGUAGE: robotframework\nCODE:\n```\n    Testcase pass\n        # calling pyats testcase\n        run testcase \"basic_example_script.tc_one\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating AEtest Argument Propagation\nDESCRIPTION: Example showing how AEtest parses command-line arguments, removing known arguments and leaving unknown ones in sys.argv for custom handling.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/run.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nsys.argv = ['python script.py', '-loglevel=INFO', '-my_arg=1', '-your_arg=2']\n```\n\n----------------------------------------\n\nTITLE: Defining and Running a Job main() Function with ats.easypy - Python\nDESCRIPTION: Shows how to structure a job file by defining a main() method that is invoked upon import, as required by the updated ats.easypy API. Assumes the presence of environment variables and the ats.easypy library. The run() function should be called inside main(), with script arguments passed as needed. Input includes OS environment variables, and the output is the execution of the specified Python automation script.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2014/december.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport os\nfrom ats.easypy import run\n\n# process environment variables here\nscript_arg_a = os.environ['script_arg_a']\n\n# all script runs goes into main()\ndef main():\n\n    run('/path/to/my/script.py', script_arg_a = script_arg_a)\n```\n\n----------------------------------------\n\nTITLE: Custom Loop Generator Example: Generating Integer Sequences\nDESCRIPTION: This code sample illustrates creating a custom loop generator class that yields Iteration objects with uids and parameters based on a range of integers. It shows how to integrate the custom generator with the @aetest.loop decorator, allowing a test class to run multiple times with different parameters dynamically generated at runtime.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/loop.rst#_snippet_16\n\nLANGUAGE: Python\nCODE:\n```\nfrom pyats import aetest\nfrom pyats.aetest.loop import Iteration\n\n# Custom loop generator class\nclass DemoGenerator(object):\n    def __init__(self, loopee, a, b):\n        self.numbers = list(range(a, b))\n    def __iter__(self):\n        for i in self.numbers:\n            yield Iteration(uid='iteration_uid_%s' % i,\n                            parameters={'number': i})\n\n# Using custom generator in a test class\n@aetest.loop(generator=DemoGenerator, a=1, b=5)\nclass TestSequence(aetest.Testcase):\n    @aetest.test\n    def test(self, number):\n        print('current number: %s' % number)\n\n# When executed, test method prints each number, and the test sections are named accordingly with their result statuses.\n```\n\n----------------------------------------\n\nTITLE: Upgrading ats.topology Module with pip - Bash\nDESCRIPTION: This bash code snippet installs or upgrades the `ats.topology` module to the latest version using the pip package manager.  It utilizes the `--upgrade` flag to ensure the newest version is installed, resolving any previous installations or dependencies. The output is the result of the pip install command.\n\nDependencies: pip package manager installed.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2017/february.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats.topology\n```\n\n----------------------------------------\n\nTITLE: Example of Linux Client File Operations using pyats FileUtils\nDESCRIPTION: This snippet demonstrates how to use the pyats FileUtils class on a Linux client to perform file copy operations between local and remote servers (via FTP, SCP, TFTP, etc.). It includes approach for initializing FileUtils with a loaded testbed and executing copyfile commands, highlighting URL specifications and connection examples.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/file_transfer_utilities.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.utils.fileutils import FileUtils\nfrom pyats.topology import loader\ntb = loader.load('tb.yaml')\n\nwith FileUtils(testbed=tb) as futils:\n    futils.copyfile(\n        source = 'file:/device/local/path/to/file',\n        destination = 'ftp://myserver.domain.com/remote/path/to/file')\n```\n\n----------------------------------------\n\nTITLE: Specifying Static Device Cleanup Parameters in YAML\nDESCRIPTION: This snippet describes the optional static key-value pairs defined under the 'clean' section for invoking cleaning operations on devices. It integrates with external cleaning frameworks like Kleenex, allowing pre-defined sets of cleanup routines to be associated to devices in the testbed configuration.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/topology/schema.rst#_snippet_2\n\nLANGUAGE: YAML\nCODE:\n```\nclean:\\n    # section containing all static key/value pairs required to\\n    # invoke clean on this device. See <Kleenex Integration> section\\n    # below for usage details.\\n    # (optional)\\n    <key>: <value>\n```\n\n----------------------------------------\n\nTITLE: Example: Retrieving Runtime Information Using ats.easypy.runtime\nDESCRIPTION: Demonstrates how to access and display runtime metrics such as the logs directory and job ID within the PyATS framework using the 'runtime' object from 'ats.easypy'. It is useful for collecting execution context data for troubleshooting or documentation.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2015/january.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom ats.easypy import runtime\n\nprint(\"Logs dir: {}\".format(runtime.directory))\nprint(\"Job id: {}\".format(runtime.jobid))\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for TFTP Package (reStructuredText)\nDESCRIPTION: Uses the Sphinx `automodule` directive in reStructuredText to automatically generate documentation for the `pyats.utils.fileutils.plugins.localhost.curl.tftp` Python package. The options `:members:`, `:undoc-members:`, and `:show-inheritance:` ensure comprehensive documentation including all members, even undocumented ones, and class inheritance diagrams.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/apidoc/utils/pyats.utils.fileutils.plugins.localhost.curl.tftp.rst#_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: pyats.utils.fileutils.plugins.localhost.curl.tftp\n   :members:\n   :undoc-members:\n   :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: Combining BGP IPv4 and IPv6 Neighbors Using PyATS Markup Syntax\nDESCRIPTION: This snippet uses the PyATS %EXTEND_LIST markup to merge IPv4 and IPv6 BGP neighbor lists under 'CE1' from the base configuration parameters. It combines dictionary keys from the IPv4 neighbors and list entries of IPv6 neighbors into a single list 'CE1_neighbors'. The snippet requires a base configuration object structured as nested dictionaries with specific keys representing BGP neighbors. The output is a unified list containing all IPv4 and IPv6 neighbor addresses, enabling simpler access and iteration in subsequent test tasks.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/yaml_markup.rst#_snippet_10\n\nLANGUAGE: markup\nCODE:\n```\nCE1_neighbors: \"%EXTEND_LIST{parameters.base_config.CE1.bgp.address_families.ipv4.neighbors.keys(),parameters.base_config.CE1.bgp.address_families.ipv6.neighbors}\"\n```\n\n----------------------------------------\n\nTITLE: Enhancements in Easypy Test Automation and Reporting\nDESCRIPTION: This snippet outlines improvements in the easypy test execution environment, including automatic diagnostics, better plugin exception handling, and new command-line parameters for testbed specification and device cleaning scope. It also describes internal refactors for test script testing and report management.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2016/may.rst#_snippet_10\n\nLANGUAGE: Python\nCODE:\n```\n  - now generates a diagnostics report (diagreport) as part of a job run.\n\n  - Testbed & clean files are now copied into your log archive.\n\n  - Plugin exception handling has been refactored.\n\n    - If an easypy plugin fails at ``pre_job`` or ``post_job`` stages,\n      an email is sent whose title contains the name of the failing plugin,\n      and a TRADe link is made available to allow the user to inspect the\n      failure.\n\n    - If an easypy plugin fails at ``pre_task`` or ``post_task`` stages,\n      the task is immediately terminated and the name of the failing\n      plugin is added to the exception text.\n\n  - Now different easypy arguments are provided for specifying testbeds of\n    actual devices (``-testbed_file``)\n    and actual/logical devices (``-logical_testbed_file``).\n\n  - Introduced new parameters ``-clean_devices`` and ``-clean_scope`` as\n    part of the new Kleenex model.\n\n  - (internal) aereport start/stop testscript is moved from plugin to runner\n```\n\n----------------------------------------\n\nTITLE: Documenting pyats.async.synchronize Module with Sphinx\nDESCRIPTION: This snippet utilizes the `automodule` directive to generate documentation for the `pyats.async_.synchronize` module.  It lists the members, excludes the undocumented members, and shows inheritance. This requires Sphinx and the pyats library to function correctly.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/apidoc/async/index.rst#_snippet_3\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: pyats.async_.synchronize\n   :members:\n   :undoc-members:\n   :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: Querying the Topology - PyATS\nDESCRIPTION: This snippet demonstrates how to query and access topology objects. It loads a testbed, checks the type, confirms the presence of devices, accesses device objects via the `devices` attribute, and iterates through links. It imports `topology` and `os` and uses functions available in `pyats.topology`.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/topology/usage.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   topology querying\n\nimport os\n\n# import the topology module\nfrom pyats import topology\n\n# load the sample testbed supplied as part of topology module\n# (example testbed file page for reference)\ntestbedfile = os.path.join(os.path.dirname(topology.__file__),\n                           'sampleTestbed.yaml')\ntestbed = topology.loader.load(testbedfile)\n\n# confirming that this is indeed a testbed object\ntype(testbed) is topology.Testbed\n# True\n\n# check that our expected devices are part of the testbed\n'ott-tb1-n7k4' in testbed and 'ott-tb1-n7k5' in testbed\n# True\n\n# access the actual device object from Testbed.devices attribute\ntestbed.devices\n# AttrDict({'ott-tb1-n7k4': <Device ott-tb1-n7k4 at 0xf77190cc>,\n#           'ott-tb1-n7k5': <Device ott-tb1-n7k5 at 0xf744e16c>})\n\n# see how many links this testbed contains:\nfor link in testbed.links:\n    print(repr(link))\n# <Link rtr1-rtr2-1 at 0xf744d16c>\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyATS and Dependencies Using Bash\nDESCRIPTION: Provides shell commands to upgrade the pip package manager and install the latest version of pyATS for both DevNet community users and Cisco internal developers. This snippet assumes a Unix-like environment where pip and bash are available. It instructs to first upgrade pip to ensure compatibility and then upgrade the pyATS package or its internal equivalent 'ats'. This snippet is used to maintain the pyATS environment up-to-date and compatible with the latest fixes and features.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2021/march.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Make sure you are using the latest pip package\nbash$ pip install --upgrade pip\n\n# DevNet Community\nbash$ pip install --upgrade pyats\n\n# Cisco Internal Developers\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Illustrating Chained pyATS Result Rollups - Python\nDESCRIPTION: This example clarifies how multiple results added together in a single expression are evaluated. It shows that chaining additions like `A + B + C` is equivalent to performing sequential pairwise additions: `(A + B) + C`.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/results/rollup.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   performing multiple rollups\n\n# import all result codes\nfrom pyats.results import (Passed, Failed, Aborted, Errored,\n                             Skipped, Blocked, Passx)\n\n# consider this\nPassed + Failed + Aborted + Errored\n\n# the same as performing\nresult = Passed + Failed\nresult = result + Aborted\nresult = result + Errored\n```\n\n----------------------------------------\n\nTITLE: Clean File Schema Structure in YAML\nDESCRIPTION: YAML schema showing the structure of a clean file with extensions, cleaners, platforms, and devices blocks. This schema is used to define how pyATS should clean and configure network devices.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/kleenex/inputs.rst#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\n# Clean File Schema\n# -----------------\n#\n#   production clean file schema with commentary from the devs\n\nextends:    # Clean file(s) to extend/build on.\n            # Use this field to extend an existing yaml clean file,\n            # allowing you to create an inheritance hierarchy.\n            # Supports full path/names or name of file in the same dir.\n            # The content of the last file on the list forms the base and\n            # is updated with the preceding file, and so on,\n            # until the existing file content is updated last.\n            # (optional)\n\n\n# clean_devices\n# -------------\n#\n# This optional key specifies the devices to be cleaned.\n# Devices may be specified by their actual name or their alias.\n#\n# This key may be used to clean devices sequentially.\n#\n# In the following example, device_a, device_b and device_c are\n# cleaned in parallel, and only once complete are device_d and device_e\n# cleaned in parallel.\n#\n# It may be overridden by specifying the CLI parameter clean_devices.\n#\n# clean_devices: [[device_a, device_b, device_c], [device_d, device_e]]\n\n\n# cleaners block\n# --------------\n#\n#   information regarding how kleenex cleaners are to be configured\n#   kleenex support per device/group cleaner mapping\ncleaners:\n\n    <cleaner class>:    # Clean class implementation to instantiate\n                        # This needs to be the actual class definition name\n                        # to be used for cleaning one or more device.\n                        # eg: PyatsDeviceClean\n                        # (mandatory)\n\n        module:         # Module where the cleaner class can be\n                        # imported from. Eg, genie.libs.clean\n                        # (mandatory)\n\n        devices:        # List of cleanable devices using this cleaner class\n                        # devices here need to be defined either in groups\n                        # or as specific devices below.  Any devices\n                        # without a corresponding testbed topology\n                        # entry are ignored with a warning.\n                        # Either device name or device alias may be\n                        # specified.\n                        # (optional)\n\n        platforms:      # list of platforms\n                        # Specify the list of platforms that belong to this\n                        # group. The cleanable devices are derived from\n                        # testbed topology devices with matching platform.\n                        # (optional)\n\n        groups:         # List of groups of cleanable devices using this\n                        # cleaner class. any groups used here need to be\n                        # defined in the groups: block down below\n                        # (optional)\n\n        timeout:        # Clean timeout in seconds.\n                        # At runtime this clean timeout is used\n                        # if not specified at the device level.\n                        # If timeout is specified at neither level,\n                        # the clean worker runs without timing out.\n                        # (optional)\n\n        # any key/value pair to be used to configure this cleaner\n        # these are passed as kwargs to the class's __init__()\n        <key>: <value>\n\n\n# platforms block\n# ---------------\n#\n#   clean information specific to a particular platform.\nplatforms:              # A block of clean information specific to a\n                        # particular platform.\n                        # This block applies to every device in your\n                        # testbed topology file with matching platform\n                        # value.\n\n    <platform name>:    # Platform name\n                        #\n                        # (mandatory)\n        # platform content has an identical schema to the devices block.\n\n\n# devices block\n# -------------\n#\n#   clean information specific to each device.\ndevices:\n\n    <device name>:      # Device name (hostname)\n                        # This defines the block of clean information\n                        # specific to this device. This must correspond to\n                        # the same device in your testbed topology file.\n                        # (mandatory)\n\n\n        images:         # Image(s) to be loaded for this device\n                        # (2 for NXOS N7K, 1 for for most other platforms)\n                        #\n                        # A single image may be specified directly\n                        # without using a list.\n                        #\n                        # Images may also be sub-keyed by role:\n                        # images/<image_role>/[list of images] or\n                        # images/<image_role>/single_image\n                        #\n                        # For example:\n                        #   images:\n                        #     kick: /path/to/kick.img\n                        #     system: /path/to/system.img\n                        #     smu: [/path/to/smu1.img, /path/to/smu2.img]\n                        #\n                        # Images are assumed to be filesystem-based unless\n                        # they are specified as URLs of the following form:\n                        # <protocol>://<server>.<domain>:<port>/path/to/image/my_image\n                        # where available <protocol> values are platform\n                        # dependent but could be one of the following :\n                        # ftp, tftp, sftp, scp\n                        #\n                        # Authentication details are discovered from the\n                        # servers block of the testbed topology via one\n```\n\n----------------------------------------\n\nTITLE: Renaming result code objects to adhere to PEP8 standards\nDESCRIPTION: This code demonstrates renaming of result code objects from uppercase identifiers (e.g., ``PASSED``) to capitalized form (e.g., ``Passed``) within the ``ats.results`` module. It improves code style compliance and clarity. Dependencies include the module imports and ensures backwards compatibility, supporting additional methods like ``.tims`` and arithmetic operations for rollup.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2015/june.rst#_snippet_17\n\nLANGUAGE: Python\nCODE:\n```\nfrom ats.results import (PASSED, FAILED, ABORTED, ERRORED, SKIPPED, BLOCKED, PASSX)\n```\n\nLANGUAGE: Python\nCODE:\n```\nfrom ats.results import (Passed, Failed, Aborted, Errored, Skipped, Blocked, Passx)\n```\n\n----------------------------------------\n\nTITLE: Manually Creating Testbed Topology Objects - pyATS Topology - Python\nDESCRIPTION: Provides a step-by-step example of manually building a testbed topology by instantiating Testbed, Device, Interface, and Link objects from the pyATS topology module. It demonstrates assigning properties, building relationships, and connecting interfaces and devices. Intended for dynamic or non-YAML use cases; this process can be tedious for large topologies.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/topology/creation.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.topology import Testbed, Device, Interface, Link\n\n# create your testbed\ntestbed = Testbed('manuallyCreatedTestbed',\n                  alias = 'iWishThisWasYaml',\n                  passwords = {\n                    'tacacs': 'lab',\n                    'enable': 'lab',\n                  },\n                  servers = {\n                    'tftp': {\n                        'name': 'my-tftp-server',\n                        'address': '10.1.1.1',\n                    },\n                  })\n\n# create your devices\ndevice = Device('tediousProcess',\n                alias = 'gimmyYaml',\n                connections = {\n                    'a': {\n                        'protocol': 'telnet',\n                        'ip': '192.168.1.1',\n                        'port': 80\n                    }\n                })\n\n# create your interfaces\ninterface_a = Interface('Ethernet1/1',\n                        type = 'ethernet',\n                        ipv4 = '1.1.1.1')\ninterface_b = Interface('Ethernet1/2',\n                        type = 'ethernet',\n                        ipv4 = '1.1.1.2')\n\n# create your links\nlink = Link('ethernet-1')\n\n# now let's hook up everything together\n# define the relationship.\ndevice.testbed = testbed\ndevice.add_interface(interface_a)\ndevice.add_interface(interface_b)\ninterface_a.link = link\ninterface_b.link = link\n```\n\n----------------------------------------\n\nTITLE: Pre-Service Hook Method in pyATS Service Wrapper Using Python\nDESCRIPTION: Defines the pre_service method executed prior to the wrapped service call. This hook allows preparatory actions or setup using provided positional and keyword arguments. It logs the invocation of the service and its input parameters for diagnostic purposes. This method is optional and only runs if implemented in the child class, relying on a logger attribute.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/connections/wrapper.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef pre_service(self, *args, **kwargs) -> None:\n    logger.info(f\"Running pre_service on {self.service_name}\")\n    logger.info(f\"{self.service_name} args: {args} kwargs: {kwargs}\")\n```\n\n----------------------------------------\n\nTITLE: Example of Goto Implementation for Skipping Test Sections\nDESCRIPTION: Shows a practical example of using the goto parameter to skip a test and proceed directly to cleanup. The example demonstrates how a test section can mark itself as passed and immediately jump to the cleanup section, skipping any intermediate tests.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/control.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   goto testscript demonstration\n\nfrom pyats import aetest\n\n# this testcase defines two tests\n# in the first test, we'll give it a result and\n# immediately skip forward to cleanup\nclass Testcase(aetest.Testcase):\n\n    @aetest.test\n    def test_one(self):\n        # skip ahead and go to cleanup instead\n        self.passed(goto = ['cleanup'])\n\n    @aetest.test\n    def test_two(self):\n        pass\n\n    @aetest.cleanup\n    def cleanup(self):\n        pass\n```\n\n----------------------------------------\n\nTITLE: Passing Variables to run_robot API in Python\nDESCRIPTION: Python example showing how to pass command-line variables to the Robot Framework engine when using the `run_robot` API. Variables are passed as a list of strings, each formatted as 'name:value', using the `variable` keyword argument.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/robot/easypy.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nrun_robot(..., variable = ['var1:value1',\n                           'var2:value2',\n                           ...])\n```\n\n----------------------------------------\n\nTITLE: Decoding pyATS Secret String (Python)\nDESCRIPTION: This Python method decodes a contained encoded string object. It calls the `my_decode` function, providing the configured secret key (`self.key`) and the data from the object (`self.obj.data`). This function is used to retrieve the original plaintext after it has been encoded. Requires `self.key` to be the correct key used for encoding and the `my_decode` function to be available.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/secret_strings.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n        def decode(self):\n            \"\"\" Decode a contained encoded string object \"\"\"\n            return my_decode(key=self.key, data=self.obj.data)\n```\n\n----------------------------------------\n\nTITLE: Defining Common Setup Section in Python\nDESCRIPTION: This Python code snippet shows how to define a common setup section with a subsection using the aetest library. It defines a class named common_setup that inherits from aetest.CommonSetup. Inside the class, it defines a subsection for checking the environment. This involves using the aetest library, which allows the creation of sections and subsections in test scripts.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2015/april.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass common_setup(aetest.CommonSetup):\n    \"\"\" Common Setup section \"\"\"\n    @aetest.subsection\n    def check_env(self):\n        \"\"\" Common Setup subsection \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Using EXTEND_LIST Key Markup in YAML (YAML)\nDESCRIPTION: Illustrates extending a list defined in another YAML file (`a.yaml`) using the `extends: a.yaml` directive and the `%EXTEND_LIST{sections}` markup as a dictionary key. This file (`b.yaml`) appends the list `[c]` to the `parameters.sections` list inherited from `a.yaml`.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/yaml_markup.rst#_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\nextends: a.yaml\n\nparameters:\n    \"%EXTEND_LIST{sections}\": [c]\n```\n\n----------------------------------------\n\nTITLE: Configuring Easypy plugins using YAML\nDESCRIPTION: This code shows an example of how to configure an Easypy plugin in a YAML file. The configuration specifies the plugin's name, whether it's enabled, the module where it's defined, and its execution order. It also shows how to pass custom arguments to the plugin's class constructor.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/easypy/plugins.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n    # Example\n    # -------\n    #\n    #   example easypy configuration file for plugins\n\n    plugins:                   # top level key for plugins\n\n        HelloWorldPlugin:   # this is the plugin name we defined\n                            # enabled, module and order keys are\n                            # mandatory. Any additional key/values are\n                            # used as arguments to the plugin class\n                            # constructor.\n\n          enabled: True           # flag marking it as \"enabled\"\n                                  # set to False to disable a plugin\n\n          module: module.where.plugin.is.defined      # module path where this\n                                                      # plugin can be imported\n\n          order: 1.0                # defines the order of execution of plugins\n                                    # it's just a number that allows users to\n                                    # specify plugin order.\n                                    # - smaller numbers runs first\n```\n\n----------------------------------------\n\nTITLE: Importing Module by String in Python\nDESCRIPTION: This snippet demonstrates how to import a module using its string name. It utilizes the `import_from_name` function from `pyats.utils.import_utils` to dynamically import a module given its string representation. The example shows how to import a module named `my_package.my_module`.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/import_utils.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.utils.import_utils import import_from_name\nobj = import_from_name('my_package.my_module')\n```\n\n----------------------------------------\n\nTITLE: Installing PyATS - Bash\nDESCRIPTION: This command upgrades the PyATS framework using pip. It is applicable to both DevNet Community and Cisco Internal Developers. The command downloads and installs the latest version of the pyats package and its dependencies.  It is essential for users to have pip installed and properly configured within their environment.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2024/february.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\n    bash$ pip install --upgrade pyats\n```\n\nLANGUAGE: bash\nCODE:\n```\n# Cisco Internal Developers\n    bash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Enabling Debug Mode for Kleenex in pyATS\nDESCRIPTION: Demonstrates how to use the --debug parameter to put Kleenex into debug mode. In this mode, cleaners run sequentially instead of in parallel, and an interactive debugger is started at the point of failure.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/kleenex/usages.rst#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pyats clean --testbed-file /path/to/my/testbed.yaml\\\n                      --clean-file /path/to/my/clean.yaml\\\n                      --debug\n```\n\n----------------------------------------\n\nTITLE: Manually Assigning pyATS Step Results in Python\nDESCRIPTION: Demonstrates how to use the `step` object's result APIs (`passed`, `failed`) within a `with steps.start(...)` block to manually set the outcome of a test step. These APIs only affect the current step's result and do not support the `aetest_goto` feature.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/steps.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   step result APIs\n\nfrom pyats import aetest\n\nclass Testcase(aetest.Testcase):\n\n    @aetest.test\n    def test_one(self, steps):\n\n        with steps.start('the passed step') as step:\n            # manually provide Passed result\n            step.passed('because i want to')\n\n        with steps.start('the failed step') as step:\n            # manually provide Failed result\n            step.failed('because i had to')\n```\n\n----------------------------------------\n\nTITLE: Creating Tcl Arrays in Python\nDESCRIPTION: This code snippet demonstrates how to create and manipulate Tcl arrays within Python using the `pyats.tcl` module. It uses the `eval` function to execute Tcl commands and `get_array` to retrieve the array's content into a Python `Array` object. It showcases how to access and modify the elements of the array, and how the Array object acts like a dictionary. The snippet uses 'tclstr' function to convert the Python array into a Tcl-compatible string.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/tcl/datastructures.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats import tcl\nfrom pyats.tcl import tclstr, Array\n\n# create an array in Tcl\n# using one liner array set instead of ().. for less typing\ntcl.eval('array set testArray \"a 1 b 2 c 3\"')\n\n# copy it to Python\narray = tcl.get_array('testArray')\n\n# notice how we have an Array variable\nassert type(array) is Array\n```\n\n----------------------------------------\n\nTITLE: Extending a pyATS Testbed File (YAML)\nDESCRIPTION: Demonstrates how to extend a base testbed file (`tb1.yaml`) using the `extends: tb1.yaml` directive. This file (`tb2.yaml`) adds a second device (`xr-2`) with similar properties while inheriting the structure from the base file, resulting in a merged testbed containing both `xr-1` and `xr-2`.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/yaml_markup.rst#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\nextends: tb1.yaml\ndevices:\n  xr-2:\n    connections:\n      cli:\n        ip: 10.2.2.2\n        protocol: ssh\n    credentials:\n      default:\n        password: cisco\n        username: cisco\n      enable:\n        password: cisco\n    os: iosxr\n    type: iosxr\n```\n\n----------------------------------------\n\nTITLE: Disabling Email Notifications in pyATS Clean\nDESCRIPTION: Shows how to use the --no-mail parameter to disable sending email notifications when errors or aborts are encountered during the cleaning process.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/kleenex/usages.rst#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pyats clean --testbed-file /path/to/my/testbed.yaml\\\n                      --clean-file /path/to/my/clean.yaml\\\n                      --no-mail\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyATS Reporter (DevNet)\nDESCRIPTION: This snippet provides the pip command to upgrade the pyats.reporter module for users in the DevNet Community. It ensures that the latest version of the module is installed, incorporating recent bug fixes and feature enhancements. It requires pip to be installed.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2020/mar.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade pyats.reporter\n```\n\n----------------------------------------\n\nTITLE: Checking Device Existence in Testbed\nDESCRIPTION: This Python snippet demonstrates how to check if a Device object exists within a Testbed object using the `in` operator. It requires pre-existing Testbed and Device objects to function correctly.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/topology/concept.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# testing whether testbed contains a device\n# use the \"in\" operator\nassert device_d not in testbed_e\nassert device_c in testbed_d\n```\n\n----------------------------------------\n\nTITLE: Initializing Telnet Connection\nDESCRIPTION: The `__init__` method initializes the `TelnetConnection` class. It calls the parent class's `__init__` and creates an instance of `telnetlib.Telnet`. It also defines a default prompt.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/connections/class.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef __init__(self, *args, **kwargs):\n    '''__init__\n\n    instantiate a single connection instance. \n    '''\n\n    # instantiate parent BaseConnection\n    super().__init__(*args, **kwargs)\n\n    # create an instance of telnetlib.Telnet\n    self._telnet = telnetlib.Telnet()\n\n    # let's hard code the expected prompt\n    # (and assume it's a bash shell prompt)\n    self._prompt = 'bash$ '\n```\n\n----------------------------------------\n\nTITLE: Creating a Empty Testcase in aetest\nDESCRIPTION: This snippet demonstrates how a basic, empty testcase in the aetest framework is created and executed. It highlights the default behavior where even an empty testcase results in a 'Passed' outcome.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/results.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats import aetest\n\n# this testcase is entirely empty\nclass Testcase(aetest.Testcase):\n    pass\n\n\n# but if we instantiate this testcase and run it\n# we get Passed, even though it did nothing.\ntc = Testcase()\ntc()\n```\n\n----------------------------------------\n\nTITLE: Navigating to documentation directory\nDESCRIPTION: Command to change directory into the pyATS documentation folder after cloning the repository.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd pyats/docs\n```\n\n----------------------------------------\n\nTITLE: Device Method to ConnectionManager Mapping Example\nDESCRIPTION: This snippet demonstrates the mapping between device-level methods and their corresponding ConnectionManager methods. It shows how the device's connect and execute methods are linked to the connection manager's operations.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/connections/manager.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# given any device, take a look at the repr() of its connection methods\ndevice.connect\n# <bound method ConnectionManager.connect of <pyats.connections.ConnectionManager object at 0xf75d03ec>>\ndevice.disconnect\n# <bound method ConnectionManager.disconnect of <pyats.connections.ConnectionManager object at 0xf75d03ec>>\n\n# connect and take a look at the service bindings\ndevice.connect()\ndevice.execute\n# <connection.services.router_services.ExecService object at 0xf705e1ac>\ndevice.configure\n# <connection.services.router_services.ConfigService object at 0xf705e1ad>\n\n# ergo, the mappings are equal\ndevice.connect == device.connectionmgr.connect\n# True\ndevice.execute == device.connectionmgr.connections['default'].execute\n# True\ndevice.configure == device.connectionmgr.connections['default'].configure\n# True\n```\n\n----------------------------------------\n\nTITLE: Loading Tcl Packages and Accessing Keyed Lists via Tcl Interpreter in Python\nDESCRIPTION: Illustrates loading an external Tcl package (Tclx) into the Tcl interpreter instance and manipulating Tcl keyed lists. Shows how to set a keyed list and retrieve individual keys using eval calls. Highlights the limitation of needing to manually parse and convert Tcl keyed list content without higher-level APIs. Requires tkinter Tcl interpreter with Tclx package availability. Inputs and outputs are Tcl strings evaluated in Python context.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/tcl/introduction.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom tkinter import Tcl\n\ntcl = Tcl()\n\n# load up Tclx\ntcl.eval('package require Tclx')\n\n# create a keyed list\ntcl.eval('keylset myKlist key_a value_a key_b value_b')\n\n# retrieve keyed list values\nkey_a_value = tcl.eval('keylget myKlist key_a')\nkey_b_value = tcl.eval('keylget myKlist key_b')\n```\n\n----------------------------------------\n\nTITLE: Upgrading PyATS Modules via pip in Bash\nDESCRIPTION: Instructions for upgrading PyATS modules for both DevNet Community users and Cisco Internal Developers using pip. The commands install the latest versions of the modules released in November 2018.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2018/nov.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats.utils\n\n# Cisco Internal Developers\nbash$ pip install --upgrade ats.utils ats.cisco\n```\n\n----------------------------------------\n\nTITLE: Upgrading ats.easypy using pip - Bash\nDESCRIPTION: This bash snippet demonstrates how to upgrade the ats.easypy module to the latest version using pip. Requires Python, pip installed, and access to the Python package index (PyPI). The user should replace 'bash$' with their terminal prompt and run the command in a shell with the appropriate permissions. The command downloads the latest release (such as v3.3.4 or v3.3.5) and installs it over any existing version. The command does not specify a version so always fetches the newest one available.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2017/july.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats.easypy\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyATS for DevNet Community and Cisco Internal Developers\nDESCRIPTION: Commands for upgrading pyATS to the latest version. Two different commands are provided: one for DevNet Community users who need to install the 'pyats' package, and another for Cisco Internal Developers who need to install the 'ats' package.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2023/april.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats\n\n# Cisco Internal Developers\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Understanding Paths in ListDict Python Implementation\nDESCRIPTION: Demonstrates how paths in ListDict relate to the original nested dictionary structure and how the same paths always yield the same dictionary.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/datastructures/listdict.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Understanding Paths\n# -------------------\n#\n#   same paths always yield the same dict\n\n# given path ('a', 'b', 'c') and ('a', 'b', 'e')\n# notice that the first two position 'a' and 'b' are similar\n# and only the last position 'c' and 'e' is different.\n\n# this suggests the following nested datastructure:\nsuggest = {\n    'a': {\n        'b': {\n            'c': object(),\n            'e': object(),\n        },\n    },\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Regex-Based Logic Operators with pyATS (Python)\nDESCRIPTION: Shows how to instantiate logical operators And, Or, and Not using string regular expressions as arguments. Each operator compiles strings into Python regex objects and evaluates them against input values (cast to string), searching for matches as part of logic testing. Dependencies: Python's re module (via pyATS internals). Inputs must be compatible with str; outputs are booleans based on regex match logic. Limitations include support only for search-style regex evaluation (not fullmatch by default), and all regex patterns must follow Python syntax.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/datastructures/logic.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   operators using strings and regexes\n\nfrom pyats.datastructures.logic import And, Not, Or\n\n# regular expressions matching to a string that contains\n# both \"sanity\" and \"traffic\"\nsanity_and_traffic = And('.*sanity.*', '.*traffic.*')\n\n# regular expression matching to either \"bgp\" or \"ospf\"\n# note that this is the same as regex: \"bgp|ospf\"\nbgp_or_ospf = Or('bgp', 'ospf')\n\n# regular expressions that end with \"regression\"\n# note this is the same as regex lookahead: \"(?!regression$)\"\nnot_regression = Not('regression$')\n\n# do some testing\n# ---------------\nsanity_and_traffic('bgp_sanity_traffic_testing')\nTrue\n\nbgp_or_ospf('bgp_traffic')\nTrue\n\nnot_regression('l2vpn_regression')\nFalse\n\n```\n\n----------------------------------------\n\nTITLE: Specifying Input Data File for AEtest Script - Python and Bash\nDESCRIPTION: This option specifies a YAML format datafile as input to the test script, which can be provided as a local file path or a URL (including token-based URLs). It is used to inject external test data into the testscript execution context. Inputs are either a filesystem path or HTTP URL string. Outputs influence the test execution environment by supplying test data. Dependencies include the AEtest framework supporting YAML datafile ingestion. Limitations include requiring proper YAML format and access permissions for remote files.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/run.rst#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nbash$ python testscript.py -datafile=\"/path/to/datafile.yaml\"\n```\n\nLANGUAGE: bash\nCODE:\n```\nbash$ python testscript.py -datafile=\"http://<url>/datafile.yaml\"\n```\n\nLANGUAGE: bash\nCODE:\n```\nbash$ python testscript.py -datafile=\"http://<token>@<url>/datafile.yaml\"\n```\n\nLANGUAGE: python\nCODE:\n```\naetest.main('testscript.py', datafile = \"/path/to/datafile.yaml\")\n```\n\nLANGUAGE: python\nCODE:\n```\nrun(testscript = 'testscript.py', datafile = \"/path/to/datafile.yaml\")\n```\n\n----------------------------------------\n\nTITLE: Upgrading Kleenex via pip in Bash\nDESCRIPTION: This bash code snippet upgrades an existing installation of the Kleenex (pyats.kleenex) Python package to the latest version using pip. It requires pip to be present and the user to have the appropriate installation permissions. The '--upgrade' argument ensures that any outdated version of the package is replaced by the latest one released on PyPI. Users should consult the changelog before upgrading to be aware of any breaking changes or new dependencies. The command is suitable for users maintaining automated testbeds and needing the latest cleaning functionality.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/kleenex/introduction.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npip install pyats.kleenex --upgrade\n```\n\n----------------------------------------\n\nTITLE: Defining ForkedPdb Class for Multiprocessing in Python\nDESCRIPTION: This code defines the `ForkedPdb` class, which is a subclass of Python's `pdb.Pdb` debugger. It is designed to be used in multiprocessing environments where the standard pdb debugger may fail because of issues with stdin.  This class overrides the `interaction` method to open `/dev/stdin` before starting the debugger session, thus circumventing the stdin closure issue encountered in child processes.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/debugging.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nimport pdb\n\nclass ForkedPdb(pdb.Pdb):\n    '''A Pdb subclass that may be used\n    from a forked multiprocessing child\n    '''\n\n    def interaction(self, *args, **kwargs):\n        _stdin = sys.stdin\n        try:\n            sys.stdin = open('/dev/stdin')\n            pdb.Pdb.interaction(self, *args, **kwargs)\n        finally:\n            sys.stdin = _stdin\n\n# to use:\nForkedPdb().set_trace()\n```\n\n----------------------------------------\n\nTITLE: Creating a pyATS Project Using Cookiecutter Template - Text\nDESCRIPTION: Explains the 'pyats create project' subcommand syntax and options for generating new pyATS script folders and files from a GitHub-hosted cookiecutter template. It lists all CLI parameters  including project name, testcase names, and datafile options  and outlines how prompts work when arguments are omitted on the CLI. The snippet forms the help/documentation output for this subcommand.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/cli/pyats_create.rst#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nUsage:\n  pyats create project [options]\n\nDescription:\n  create a pyATS script from cookiecutter template, located at:\n      https://github.com/CiscoTestAutomation/pyATS-project-template\n\nProject Options:\n  --name                name of new pyATS project\n  --testcases [ [ ...]]\n                        names of testcases to be generated\n  --datafile            flag to indicate usage of datafiles\n  --no-datafile         disable the usage of datafiles\n\nGeneral Options:\n  -h, --help            Show help\n  -v, --verbose         Give more output, additive up to 3 times.\n  -q, --quiet           Give less output, additive up to 3 times, corresponding to WARNING, ERROR,\n                        and CRITICAL logging levels\n```\n\n----------------------------------------\n\nTITLE: Creating a Nested Dictionary in Python\nDESCRIPTION: Example of a nested dictionary structure with multiple levels of nesting that will be used to demonstrate the ListDict functionality.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/datastructures/listdict.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Nested Dict\n# -----------\n\nd = {\n    'a': {\n        'b': {\n            'c': {\n                'd': 'value',\n            },\n        },\n    },\n    'x': {\n        'y': {\n            'z': 100,\n        },\n    },\n}\n\n\n# accessing 'value', means\nd['a']['b']['c']['d']\n# 'value'\n\n# accessing 100, means\nd['x']['y']['z']\n# 100\n```\n\n----------------------------------------\n\nTITLE: Configuring pyATS Service Wrapper via Configuration File - INI\nDESCRIPTION: Shows how to register a custom service wrapper within the pyATS framework using the configuration file method. This INI configuration maps a service wrapper name to its import location (Python path). Prerequisite is an existing service wrapper class with a known module path. This approach allows the wrapper to be automatically discovered and used by pyATS based on the configuration alone.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/connections/wrapper.rst#_snippet_10\n\nLANGUAGE: INI\nCODE:\n```\n[service_wrapper]\nexample_wrapper = path.to.module:ExampleWrapper\n```\n\n----------------------------------------\n\nTITLE: Refactoring and Enhancements in csccon Connection Module\nDESCRIPTION: This snippet discusses the reorganization and feature additions to the csccon connection module within pyATS, including supporting connection sharing, pool management, and configuration changes for user flexibility. It documents changes such as renaming methods, handling defaults, and enabling custom connection classes.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2016/may.rst#_snippet_9\n\nLANGUAGE: Python\nCODE:\n```\n  - Refactored and moved Csccon wrapper code from core pyATS into an\n    independent Cisco-shared package ``csccon``. See `Csccon Documentation`_.\n\n    This is a *mostly backwards compatible change*. Most users shouldn't be\n    importing Csccon directly, as it was the default connection class used.\n    However, for the select few which this may impact, the following changes\n    will be necessary:\n\n    .. code-block:: python\n\n        # before\n        from ats.connection.csccon.bases import Csccon\n\n        # after\n        from csccon import Csccon\n\n  - Csccon (cisco-shared package) overhauled to support sharing between\n    multiple processes and pooling.\n\n  - internal refactoring for better, modular support for user's own connection\n    implementation\n\n  - support for sharing connections between forked process (no more deadlocks)\n\n  - support for device :ref:`connectionpool`.\n\n  - ``ConnectionManager.destroy_connection()`` has been renamed to\n    ``destroy`` for simplicity and consistency.\n\n  - ``BaseConnection.config()`` is now renamed to ``configure()`` for\n    consistency. As a result, all connection implementations shall now implement\n    ``configure()`` instead. Backward compatibility will be kept, but a warning\n    will be displayed if ``config()`` is used.\n\n  - changed the default connection path behavior: if the user defines a\n    ``defaults/via`` key under the device connections dictionary (from YAML), it\n    will be used as the default ``via`` path in ``device.connect()``.\n\n  - added a mechanism for user to change the default connection class (instead\n    of always defaulting to Csccon)\n\n  - added a mechanism for users to change the default connection alias.\n\n.. _Csccon Documentation: http://wwwin-pyats.cisco.com/cisco-shared/html/csccon/docs/index.html\n```\n\n----------------------------------------\n\nTITLE: Setting Custom Script Discovery Class in pyATS AETEST\nDESCRIPTION: Shows how to change the default script discovery class by setting the runtime.discoverer.script property. Custom discovery classes must inherit from the default ScriptDiscovery class.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/control.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.aetest import runtime\nruntime.discoverer.script = MyCustomScriptDiscovery\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.aetest import runtime\nfrom pyats.aetest.discovery import ScriptDiscovery\n\nclass MyCustomScriptDiscovery(ScriptDiscovery):\n    pass\n\nruntime.discoverer.script = MyCustomScriptDiscovery\n```\n\n----------------------------------------\n\nTITLE: Looping with incomplete parameter sets in PyATS\nDESCRIPTION: This code snippet demonstrates what happens when not all parameters have the same number of values.  If the number of values for any parameter is less than the maximum number of iterations, or if `uids` are not provided, a `filler` (defaulting to `None`) is used to fill in the missing values. This ensures the loop runs with a consistent number of iterations.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/loop.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.aetest import loop\n\n# loop with 3 iterations, and their number of parameters values do not agree\n# --------------------------------------------------------------------------\n#   iteration 1: a=1, b=4\n#   iteration 2: a=2, b=5\n#   iteration 3: a=3, b=None ---> default filler comes in to fill the blanks\n@loop(a=[1, 2, 3], b=[4, 5])\n# same as above, using args and argvs\n@loop(args=['a', 'b'],\n      argvs=[(1, 4),\n             (2, 5),\n             (3, )])\n```\n\n----------------------------------------\n\nTITLE: Starting the AEReport Server using AERunner in Python\nDESCRIPTION: Demonstrates how to start the AEReport server process using the `AERunner.start_server()` static method in Python, as part of the AEReport tutorial. It requires specifying a `logsdir` for server logs and a `logfilename`, and returns the server's process ID (`svrpid`), port (`svrport`), and hostname (`servername`) needed for client connections.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aereport/index.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> from pyats.aereport.aerunner import AERunner\n>>> svrpid, svrport, servername = AERunner.start_server(logsdir='/tmp/ttt/',\n>>>                                             logfilename='logfile.log')\n```\n\n----------------------------------------\n\nTITLE: Listing New Module Versions in CSV Format\nDESCRIPTION: This snippet displays the new versions of specific pyATS modules in CSV table format, indicating module names and their respective versions. It helps in tracking version updates for modules like ats.aetest and ats.tims.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2018/jan.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats.aetest\nbash$ pip install --upgrade ats.tims\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyATS using pip (Bash)\nDESCRIPTION: Provides pip commands to upgrade the pyATS framework. The first command is intended for general DevNet community users, while the second command targets Cisco internal developers using the 'ats' package.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2024/june.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats\n```\n\nLANGUAGE: bash\nCODE:\n```\n# Cisco Internal Developers\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyATS to v23.11 via pip\nDESCRIPTION: Command line instructions for upgrading pyATS packages using pip. Two different commands are provided - one for DevNet Community users and one for Cisco Internal Developers.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2023/november.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats\n\n# Cisco Internal Developers\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyATS Packages Using Bash\nDESCRIPTION: Shell commands to upgrade pyATS related Python packages using pip for two user groups: DevNet Community and Cisco Internal Developers. The commands use the 'pip install --upgrade' option to update pyats.log or ats.log packages as appropriate. These upgrade instructions ensure users can access the latest bug fixes and features documented in this release. No further code dependencies are required beyond a working Python pip environment.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2020/apr.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats.log\n\n# Cisco Internal Developers\nbash$ pip install --upgrade ats.log\n```\n\n----------------------------------------\n\nTITLE: Upgrading ats.kleenex and ats.easypy Python Modules Using Bash\nDESCRIPTION: Provides the Bash command to upgrade both ats.kleenex and ats.easypy Python modules to version 3.2.1 simultaneously. The command requires pip along with a preconfigured pyATS environment. The updates resolve a bug in the Kleenex bringup and clean processes whereby newly brought-up devices were previously ignored during cleaning.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2017/january.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats.kleenex ats.easypy\n```\n\n----------------------------------------\n\nTITLE: Adding pyATS Processors to Section - Python\nDESCRIPTION: Demonstrates using `aetest.processors.add()` to append new processors to the existing list of processors attached to a section. Unlike `affix`, this function does not overwrite the current list but adds to it.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/processors.rst#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats import aetest\n\nclass Testcase(aetest.Testcase):\n    pass\n\n# add two lambda functions to Testcase as post-processors\naetest.processors.add(Testcase, post = [lambda: True, lambda: True])\n```\n\n----------------------------------------\n\nTITLE: Destroying All Device Connections with pyATS ConnectionManager (Python)\nDESCRIPTION: Illustrates how to entirely destroy (disconnect and delete) all managed connections using device.destroy_all(). No arguments are required. The method calls .disconnect() on each connection object, then clears the manager's connection registry. Objects are deleted and cannot be reused until re-instantiated.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/connections/manager.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n# destroy_all everything!\ndevice.destroy_all()\n# equivalent to: device.connectionmgr.destroy_all()\n\n# in effect, it is the same as doing:\nfor conn in device.connectionmgr.connections.values():\n    conn.disconnect()\ndevice.connectionmgr.connections.clear()\n```\n\n----------------------------------------\n\nTITLE: Running Function on Import in Python\nDESCRIPTION: This snippet illustrates the use of the `@on_import` decorator. When a function is decorated with `@on_import`, the function's content will be executed when the module is imported. This is useful for initializing or setting up resources when a module is loaded. The example defines a function `_init` that prints 'hello world'.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/import_utils.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.utils.import_utils import on_import\n\n@on_import\ndef _init():\n    print('hello world')\n```\n\n----------------------------------------\n\nTITLE: Demonstrating WeakList Usage in Python\nDESCRIPTION: This code snippet shows how to use the WeakList class from pyats.datastructures to store weak references to objects. It demonstrates creating NewObject instances, constructing standard and weak lists, and comparing access and equality behaviors between them. The example illustrates how deleting all strong references to an object results in its automatic removal from the WeakList. Dependencies: pyats.datastructures and weakref; key parameters include the initial iterable of objects; input is a collection of weak-referenceable objects; output is a WeakList behaving like a list whose contents may shrink as objects are garbage collected. Limitation: Only objects that support weak referencing can be stored.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/datastructures/weaklist.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   WeakList use case\n\nfrom pyats.datastructures import WeakList\n\n# create a class for demo (base object cannot be weakref'ed)\nclass NewObject(object): \n    pass\n\n# create a couple instances\na = NewObject()\nb = NewObject()\nc = NewObject()\n\n# create a list and its weaklist\nl = [a, b, c]\n# [<NewObject object at 0xf76d65ec>, \n#  <NewObject object at 0xf76d664c>, \n#  <NewObject object at 0xf76d654c>]\n\nwl = WeakList(l)\n# WeakList([<NewObject object at 0xf76d65ec>, \n#           <NewObject object at 0xf76d664c>, \n#           <NewObject object at 0xf76d654c>])\n\n# comparison between a weaklist and a list is the exact same\nl == wl\n# True\n\n# access also yields the same, normal objects\nwl[0]\n# <NewObject object at 0xf76d65ec>\nwc[0] is l[0]\n# True\n\n# removing the actual objects (ref counter = 0) \n# removes the object from weaklist\n# (deleting l as well so that no references to a exists)\ndel a\ndel l\n\n# note now that wl only has 2 items left (b and c)\nwl \n# WeakList([<NewObject object at 0xf76d664c>, \n#           <NewObject object at 0xf76d654c>])\n```\n\n----------------------------------------\n\nTITLE: Connecting to Pagent and Ixia Devices using Device Objects - Python\nDESCRIPTION: Shows how to instantiate Pagent and Ixia objects and connect them using device objects from a pyATS testbed. Requires imports from 'ats.tgn.hltapi' and an initialized 'testbed' object with properly defined devices. The 'connect' method accepts the 'device' keyword to use testbed device data for automatic connection establishment. Input is the device object; output is an established connection or exception on failure.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2015/june.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom ats.tgn.hltapi import Pagent, Ixia\n\npagent = Pagent()\nixia = Ixia()\n\npagent.connect(device=testbed.devices['mypagent'])\nixia.connect(device=testbed.devices['ixia'])\n```\n\n----------------------------------------\n\nTITLE: Upgrading PyATS with pip - Bash\nDESCRIPTION: This snippet demonstrates how to upgrade the PyATS framework to the latest version using pip in a bash shell. The first command is intended for DevNet Community users, instructing them to upgrade the 'pyats' package, while the second command is for Cisco internal developers upgrading the 'ats' package. Ensure that pip is installed in your environment and you have the required permissions. The commands output updated installation statuses and potentially download additional dependencies.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2023/february.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats\n\n# Cisco Internal Developers\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyATS Test Automation Framework - Bash\nDESCRIPTION: This Bash snippet shows the commands required to upgrade the pyATS framework for different user groups. It includes pip commands to upgrade the public pyats package for the DevNet community and the internal ats package for Cisco developers. These commands must run in a shell environment with Python package manager access.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2019/sept.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats\n\n# Cisco Internal Developers\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Installing build dependencies for pyATS documentation\nDESCRIPTION: Command to install all required build dependencies for generating the pyATS documentation.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nmake install_build_deps\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyATS Reporter (Cisco Internal)\nDESCRIPTION: This snippet provides the pip command to upgrade the ats.reporter module for Cisco internal developers. It ensures that the latest version of the module is installed, incorporating recent bug fixes and feature enhancements. It requires pip to be installed.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2020/mar.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats.reporter\n```\n\n----------------------------------------\n\nTITLE: Report Structure Table in Text Format\nDESCRIPTION: A formatted text table that outlines the structure of the test report, showing the fields available for TestSuite, Task, and Section components with their descriptions.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/reporter/overview.rst#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n+---------------+------------------------------------------------------------+\n| Section       | Field           | Description                              |\n+===============+=================+==========================================+\n| TestSuite     | type            | Identifier that this section is the root |\n|               |                 |  TestSuite                               |\n|               | id              | Unique ID for this job execution         |\n|               | name            | Name from jobfile                        |\n|               | starttime       | Timestamp when job execution began       |\n|               | stoptime        | Timestamp when job execution ended       |\n|               | runtime         | Duration of execution                    |\n|               | cli             | Command that started Easypy              |\n|               | jobfile         | Location of jobfile                      |\n|               | jobfile_hash    | SHA256 hash of the jobfile contents      |\n|               | pyatspath       | Python environment executing pyATS       |\n|               | pyatsversion    | Version of pyATS installed               |\n|               | host            | Name of host machine                     |\n|               | submitter       | User that started execution              |\n|               | archivefile     | Path to generated archive file           |\n|               | summary         | Combined summary of all Tasks            |\n|               | details         | Details about any exceptions or errors   |\n|               | extra           | Map of extra info about the TestSuite    |\n|               | tasks           | List of child Tasks                      |\n+---------------+-----------------+------------------------------------------+\n| Task          | type            | Identifier that this section is a Task   |\n|               | id              | Unique ID for this Task                  |\n|               | name            | Name of TestScript                       |\n|               | starttime       | Timestamp when execution began           |\n|               | stoptime        | Timestamp when execution ended           |\n|               | runtime         | Duration of execution                    |\n|               | description     | Description of TestScript                |\n|               | logfile         | Path to logfile for this Task            |\n|               | testscript      | Path to testscript                       |\n|               | testscript_hash | SHA256 hash of the testscript contents   |\n|               | datafile        | Path to the data file                    |\n|               | datafile_hash   | SHA256 hash of the data file contents    |\n|               | parameters      | Any parameters passed to this Task       |\n|               | summary         | Summary of results                       |\n|               | details         | Details about any exceptions or errors   |\n|               | extra           | Map of extra info about the Task         |\n|               | sections        | List of child Sections                   |\n+---------------+-----------------+------------------------------------------+\n| Section       | type            | Specific type of section being           |\n|               |                 |  represented                             |\n|               | id              | Unique ID for this Section               |\n|               | name            | Name of this Section                     |\n|               | starttime       | Timestamp when this Section began        |\n|               | stoptime        | Timestamp when this Section ended        |\n|               | runtime         | Duration of execution                    |\n|               | description     | Description of this Section              |\n|               | xref            | XReference to the code defining this     |\n|               |                 |  Section                                 |\n|               |   source_hash   | SHA256 hash of the source code for       |\n|               |                 |   this Section                           |\n|               | data_hash       | SHA256 hash of the data file input       |\n|               | logs            | Path to logfile showing execution of     |\n|               |                 |  this Section, as well as the beginning  |\n|               |                 |  byte and size in bytes                  |\n|               | parameters      | Any parameters passed to this Section    |\n|               | processors      | Lists of processors that ran for this    |\n|               |                 |  section, both before and after          |\n|               | result          | The test result of this Section          |\n|               | details         | Details about any exceptions or errors   |\n|               | extra           | Map of extra info about this Section     |\n|               | sections        | Any child sections of this section       |\n|               |                 |  (Testcases have TestSections, which can |\n|               |                 |   have Steps, etc.)                      |\n+---------------+-----------------+------------------------------------------+\n```\n\n----------------------------------------\n\nTITLE: Implementing Lockable Class and Decorator Usage (Python)\nDESCRIPTION: This code snippet demonstrates how to create a class that inherits from Lockable and uses the @Lockable.locked decorator to protect methods from race conditions in a multiprocessing environment.  It imports the Lockable class and defines a MySharableClass that overrides __init__ method and decorates methods with @Lockable.locked.  The @Lockable.locked decorator automatically handles the locking and unlocking of the method.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/async/semaphores.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n    # Example\n    # -------\n    #\n    #   async.synchronize.Lockable example\n\n    from pyats.async_.synchronize import Lockable\n\n    class MySharableClass(Lockable):\n\n        def __init__(self):\n            # make sure to always call Lockable class's __init__\n            # (eg, via super)\n            super().__init__()\n\n        @Lockable.locked\n        def do_work_one(self):\n            pass\n\n        @Lockable.locked\n        def do_work_two(self):\n            pass\n```\n\n----------------------------------------\n\nTITLE: pyATS Step Class API Definition (text)\nDESCRIPTION: This plain text snippet provides a reference table outlining the attributes, properties, result APIs, and built-in methods available on the `Step` class in pyATS. It details the purpose of each element, such as `start` for child steps, `result` for roll-up status, `report` for logging, result methods (`passed`, `failed`, etc.), and context manager methods (`__enter__`, `__exit__`). It serves as a static definition of the class's interface.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/steps.rst#_snippet_8\n\nLANGUAGE: text\nCODE:\n```\n+--------------------------------------------------------------------------+\n    | Step  (basecls: Steps)                                                   |\n    +==========================================================================+\n    | attribute       | description                                            |\n    |-----------------+--------------------------------------------------------|\n    | start           | starts a new child step. returns Step instance         |\n    | result          | roll-up result of this step and all child steps ned    |\n    | report          | reports current step details/results to log file       |\n    | steps           | list of child Step objects                             |\n    | description     | description of this step instance                      |\n    +==========================================================================+\n    | properties      | description                                            |\n    |-----------------+--------------------------------------------------------|\n    | details         | list of steps details using StepDetail namedtuple      |\n    +==========================================================================+\n    | result apis     | description                                            |\n    |-----------------+--------------------------------------------------------|\n    | passed          | provides passed result to this step                    |\n    | failed          | provides failed result to this step                    |\n    | aborted         | provides aborted result to this step                   |\n    | blocked         | provides blocked result to this step                   |\n    | skipped         | provides skipped result to this step                   |\n    | errored         | provides errored result to this step                   |\n    | passx           | provides passx result to this step                     |\n    +==========================================================================+\n    | built-in        | description                                            |\n    |-----------------+--------------------------------------------------------|\n    | __enter__       | method called with starting step through with statement|\n    | __exit__        | method called with exiting step through with statement |\n    +--------------------------------------------------------------------------+\n```\n\n----------------------------------------\n\nTITLE: Setting Maximum Testcase Failures in pyATS (Python)\nDESCRIPTION: Illustrates using the `max_failures` argument in `aetest.main()` to set a limit on the number of testcases that can fail before the script automatically aborts. When the threshold is reached, execution jumps to `CommonCleanup`, and remaining testcases are marked as 'BLOCKED'. Requires `pyats.aetest`.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/control.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n# maximum failures feature demonstration\n\nfrom pyats import aetest\n\nclass TestcaseOne(aetest.Testcase):\n\n    @aetest.test\n    def test(self):\n        self.failed()\n\nclass TestcaseTwo(aetest.Testcase):\n\n    @aetest.test\n    def test(self):\n        self.failed()\n\nclass TestcaseThree(aetest.Testcase):\n    pass\n\nclass CommonCleanup(aetest.CommonCleanup):\n    pass\n\n# run it\naetest.main(max_failures = 1)\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyATS with pip - bash\nDESCRIPTION: This snippet provides instructions on upgrading the pyATS library using `pip`. It demonstrates two different methods: one for the DevNet Community and another for Cisco internal developers. The `pip install --upgrade` command is used to update the package to the latest version. The primary dependency is the `pip` package manager.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2021/june.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\n\nbash$ pip install --upgrade pyats\n```\n\nLANGUAGE: bash\nCODE:\n```\n# Cisco Internal Developers\n\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Upgrade Commands for PyATS and ATS\nDESCRIPTION: Provides shell commands to upgrade the PyATS framework and ATS to the latest versions using pip. Instructions are separated for Cisco internal developers and the DevNet Community, ensuring appropriate installation practices.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2022/march.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade pyats\n\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Destroying Device Connections with pyATS ConnectionManager (Python)\nDESCRIPTION: Shows how to completely tear down and delete a specific device connection using device.destroy(), with optional alias targeting. Method first disconnects, then deletes the connection object. Destroys are non-recoverable and remove the object from the connection manager. Inputs include the alias (defaults to default); outcomes are disconnection and object deletion.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/connections/manager.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# destroy the default aliased connection\ndevice.destroy()\n# equivalent to: device.connectionmgr.destroy(alias = 'default')\n\n# destroy a specific alias\ndevice.destroy(alias = 'vty_1')\n# equivalent to: device.connectionmgr.destroy(alias = 'vty_1')\n\n# in effect, it is the same as doing:\ndevice.connectionmgr.connections['vty_1'].disconnect()\ndel device.connectionmgr.connections['vty_1']\n```\n\n----------------------------------------\n\nTITLE: Running Robot Scripts via run_robot API in Python\nDESCRIPTION: Example Python code for a pyATS job file demonstrating how to import and use the `run_robot` function from `pyats.robot.runner` to execute a Robot Framework script (`.robot` file) within the Easypy runtime environment. It requires the path to the robot script and the Easypy `runtime` object.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/robot/easypy.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   job file running a robot script\n\nimport os\n\n# import the run_robot api\nfrom pyats.robot.runner import run_robot\n\n# entry point\ndef main(runtime):\n\n    # run your robot script\n    run_robot(robotscript = os.path.join('path', 'to', 'my_robo_script.robot'),\n              runtime = runtime)\n```\n\n----------------------------------------\n\nTITLE: Upgrading ats.aetest/pyats.aetest using pip (Bash)\nDESCRIPTION: Provides Bash commands using pip to upgrade the ats.aetest module for Cisco Internal Developers and the pyats.aetest module for the DevNet Community. This update corresponds to version v4.1.3 released on May 15, 2018.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2018/may.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats.aetest\n\n# Cisco Internal Developers\nbash$ pip install --upgrade ats.aetest\n```\n\n----------------------------------------\n\nTITLE: Upgrading ats.easypy/pyats.easypy using pip (Bash)\nDESCRIPTION: Provides Bash commands using pip to upgrade the ats.easypy module for Cisco Internal Developers and the pyats.easypy module for the DevNet Community. This update corresponds to version v4.1.5 released on May 17, 2018.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2018/may.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats.easypy\n\n# Cisco Internal Developers\nbash$ pip install --upgrade ats.easypy\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyats.utils (Community) - bash\nDESCRIPTION: This bash command upgrades the `pyats.utils` module for DevNet Community users using the pip package manager. It requires pip to be installed and configured correctly to fetch packages from the standard Python Package Index.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2018/aug.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats.utils\n```\n\n----------------------------------------\n\nTITLE: Upgrading ats.easypy (Internal) - bash\nDESCRIPTION: This bash command upgrades the `ats.easypy` module for Cisco Internal Developers using the pip package manager. It requires pip to be installed and configured correctly, likely pointing to an internal package repository.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2018/aug.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n# Cisco Internal Developers\nbash$ pip install --upgrade ats.easypy\n```\n\n----------------------------------------\n\nTITLE: Disconnecting All Device Connections with pyATS ConnectionManager (Python)\nDESCRIPTION: Shows how to disconnect all connections managed by the connection manager using device.disconnect_all(). No arguments are required. Internally, each connection's .disconnect() is called, changing each state to disconnected, but leaving the objects instanced. No output is produced beyond state transitions.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/connections/manager.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n# disconnect everything!\ndevice.disconnect_all()\n# equivalent to: device.connectionmgr.disconnect_all()\n\n# in effect, it is the same as doing:\nfor conn in device.connectionmgr.connections.values():\n    conn.disconnect()\n```\n\n----------------------------------------\n\nTITLE: Controlling Q Return Value Casting in pyATS Tcl Interpreter Python\nDESCRIPTION: This example demonstrates toggling the auto-typecasting behavior of Q magic function calls in pyATS Tcl interpreter using the cast_ argument. By default, results are converted to Python objects; setting cast_=False returns Tcl string representations instead. The snippet shows both use cases and discusses the purpose of the cast_ trailing underscore for argument name collision avoidance. Dependencies include pyats.tcl and proper variable initialization in Tcl.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/tcl/q.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#   Q casting on/off\n\nfrom pyats import tcl.\n\ntcl.eval('set myVar 1')\n\n# by default, Q casting is always on:\ntype(tcl.q.set('myVar'))\n# <type 'int'>\n\n# turn it off using cast_ argument\ntype(tcl.q.set('myVar', cast_ = False))\n# <type 'str'>\n```\n\n----------------------------------------\n\nTITLE: Checking Remote File Stability with FTP in Python\nDESCRIPTION: Example showing how to verify a remote file exists and has a stable length (not being written to) using the checkfile() method with the check_stability parameter.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/file_transfer_utilities.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfutils.checkfile(\n    target = 'ftp://myserver.domain.com/remote/path/to/file',\n    check_stability=True)\n```\n\n----------------------------------------\n\nTITLE: Creating and Accessing Nested AttrDict - pyATS - Python\nDESCRIPTION: Shows how to create nested AttrDict instances and assign/access values using dot notation, mimicking class attribute access. Requires importing AttrDict from pyats.datastructures. This allows building nested data structures that feel like objects.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/datastructures/attrdict.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   AttrDict use case\n\nfrom pyats.datastructures import AttrDict\n\n# create a nested AttrDict chain\nobj = AttrDict()\nobj.a = AttrDict()\nobj.a.b = AttrDict()\n\n# now you can access it via chaining\nobj.a.b.c = 'value'\n\n# it looks & feels like class instances, but is really just a\n# dictionary doing the dirty heavy lifting\nobj\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyATS via pip\nDESCRIPTION: This snippet provides the command to upgrade the pyATS package using pip, both for DevNet Community and Cisco Internal Developers.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2024/april.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats\n\n# Cisco Internal Developers\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Modifying and Looping through ListDict in Python\nDESCRIPTION: Shows how to modify a ListDict by adding new path-value pairs and how to iterate through all entries, demonstrating the mutable nature of ListDict objects.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/datastructures/listdict.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   modifying and looping ListDict\n\n# continuing from above example...\n\n# appending a new path/value\nld.append((('a', 'b', 'x'), object()))\n# [DictItem(path=('a', 'b', 'c'), value=<object object at 0xf7692d00>), \n#  DictItem(path=('a', 'b', 'e'), value=<object object at 0xf7692f40>),\n#  DictItem(path=('a', 'b', 'x'), value=<object object at 0xf7692ea8>)]\n\n# looping through\nfor i in ld:\n    print(i)\n# DictItem(path=('a', 'b', 'c'), value=<object object at 0xf7692d00>)\n# DictItem(path=('a', 'b', 'e'), value=<object object at 0xf7692f40>)\n# DictItem(path=('a', 'b', 'x'), value=<object object at 0xf7692ea8>)\n\n# etc..\n```\n\n----------------------------------------\n\nTITLE: Checking for Remote URLs using is_remote (Python)\nDESCRIPTION: Illustrates using the `is_remote` method of a `FileUtils` instance (initialized with a testbed `tb`) to determine if a URL string (`ftp://server.com/path/to/remote/file`) points to a remote, non-local resource. The method returns `True` for remote URLs.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/file_transfer_utilities.rst#_snippet_27\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.utils.fileutils import FileUtils\nfutils = FileUtils(testbed=tb)\nassert futils.is_remote(\"ftp://server.com/path/to/remote/file\"\n```\n\n----------------------------------------\n\nTITLE: Getting Hostname from Server in pyats FileUtils\nDESCRIPTION: Retrieves the hostname for a given server name or IP address from the server list, returning the first network-reachable address, the server's contents if available, its alias, or None if not found. It depends on the pyats.utils.fileutils.FileUtils class and the testbed context.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/file_transfer_utilities.rst#_snippet_30\n\nLANGUAGE: Python\nCODE:\n```\nfrom pyats.utils.fileutils import FileUtils\nfutils = FileUtils(testbed=tb)\nhostname = futils.get_hostname(server_name)\n```\n\n----------------------------------------\n\nTITLE: Developing specific pyATS package with skip-version-check\nDESCRIPTION: This example shows how to use `pyats develop` to specifically target the `genie.libs.sdk` package. The `--skip-version-check` option is used to bypass the default check that verifies pyATS packages are up to date before execution. Use this option with caution as it may lead to conflicts.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/cli/pyats_develop.rst#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\npyats develop genie.libs.sdk --skip-version-check\n```\n\n----------------------------------------\n\nTITLE: Checking for Local URLs using is_local (Python)\nDESCRIPTION: Demonstrates initializing a `FileUtils` instance with a testbed object (`tb`) and using its `is_local` method to check if a URL string (`file:///path/to/local/file`) refers to a local file system resource. The method returns `True` for local URLs.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/file_transfer_utilities.rst#_snippet_26\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.utils.fileutils import FileUtils\nfutils = FileUtils(testbed=tb)\nassert futils.is_local(\"file:///path/to/local/file\"\n```\n\n----------------------------------------\n\nTITLE: Extracting URL Protocol using get_protocol (Python)\nDESCRIPTION: Shows how to use the `get_protocol` method of a `FileUtils` instance to extract the protocol scheme (e.g., 'ftp') from a given URL string (`ftp://server.com/path/to/remote/file`). The method returns the scheme part of the URL.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/file_transfer_utilities.rst#_snippet_28\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.utils.fileutils import FileUtils\nfutils = FileUtils(testbed=tb)\nassert futils.get_protocol(\"ftp://server.com/path/to/remote/file\") == 'ftp'\n```\n\n----------------------------------------\n\nTITLE: Post-processor failing a section, Python\nDESCRIPTION: This code defines a post-processor function `section_failed` that marks the section as failed. It's attached to a test section using `@aetest.processors.post`, causing the test section to fail despite otherwise passing. Demonstrates how processors can override section results.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/processors.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef section_failed(section):\n    section.failed()\n\nclass Testcase(aetest.Testcase):\n\n    @aetest.processors.post(section_failed)\n    @aetest.test\n    def test(self):\n        pass\n        # This test section would regularly pass, but the processor will cause\n        # the result to be Failed\n```\n\n----------------------------------------\n\nTITLE: Decoding a String with pyATS Secret Decode - Text\nDESCRIPTION: This snippet explains usage of the 'pyats secret decode' subcommand for converting encoded strings back to plaintext. The string to decode is supplied as an argument. Users may need to configure a specific representer and key via pyATS configuration files, with '--prefix' supporting alternate config sets. The command output is the decoded secret, and improper keys/configuration may result in failures.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/cli/pyats_secret.rst#_snippet_3\n\nLANGUAGE: Text\nCODE:\n```\nUsage:\n  pyats secret decode [string] [options]\n\nDescription:\n  Decodes an encoded string into plaintext form.\n\n  The decoding used may be changed by specifying the pyats configuration:\n  [secrets] string.representer = representer_module.representer_class\n\n  Otherwise, a default cipher encoding is expected.\n\n  The decoding may be personalized by using the pyats configuration:\n  [secrets] string.key = <generated_key>\n\n  where <generated_key> refers to the key generated with the \"pyats secret keygen\"\n  command.\n\n  If specified, --prefix selects other representers defined in the pyats\n  configuration.  The following are expected to be present:\n  [secrets] <prefix>.representer\n  [secrets] <prefix>.key\n\nDecode Options:\n  [string]              String to decode\n  --prefix [prefix]     Cfg prefix to use (Optional)\n\nGeneral Options:\n  -h, --help            Show help\n  -v, --verbose         Give more output, additive up to 3 times.\n  -q, --quiet           Give less output, additive up to 3 times, corresponding to WARNING, ERROR,\n                        and CRITICAL logging levels\n```\n\n----------------------------------------\n\nTITLE: Post-Service Hook Method in pyATS Service Wrapper Using Python\nDESCRIPTION: Implements the post_service method which is called after the wrapped service method returns. It receives the output of the service call along with the original parameters, enabling post-processing or logging results. This method logs the service name and output, providing a place to add any additional handling needed after the service completes. It is optional and requires an existing logger.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/connections/wrapper.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef post_service(self, output: Any, *args, **kwargs) -> None:\n    logger.info(f\"Running post_service on {self.service_name}\")\n    logger.info(f\"{self.service_name} output: {output}\")\n```\n\n----------------------------------------\n\nTITLE: Executing Tcl Commands with pyATS Interpreter eval() in Python\nDESCRIPTION: This snippet illustrates how to execute arbitrary Tcl commands via the eval() method of the Interpreter instance or the global tcl instance. It shows examples like retrieving global variables, defining Tcl procedures, and loading Tcl packages. The eval() method accepts Tcl commands as strings and returns raw string results from Tcl. It highlights how Tcl commands interact with Python strings, with an emphasis on correct string quoting.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/tcl/tcl.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats import tcl\n\ntcl.eval('info global')\ntcl.eval('proc testProc {args} {puts $args}')\ntcl.eval('package require Tclx')\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyats.aetest Module via pip (Bash)\nDESCRIPTION: Provides the pip commands to upgrade only the `pyats.aetest` module for both DevNet Community users (`pyats.aetest`) and Cisco Internal Developers (`ats.aetest`). These commands apply to the v20.9.2 release of `pyats.aetest` from October 1, 2020.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2020/oct.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats.aetest\n\n# Cisco Internal Developers\nbash$ pip install --upgrade ats.aetest\n```\n\n----------------------------------------\n\nTITLE: Illustrating pyATS Versioning Scheme - Text\nDESCRIPTION: Shows example versions following the new YY.N(.M) calendar-year based pyATS versioning scheme. Explains how minor releases (N) and optional patchlevels (M) are represented (e.g., 19.0, 19.0.0, 19.0.1).\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2019/mar.rst#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nExample Versions\n----------------\n     19.0       - this release\n     19.0.0     - exactly the same as 19.0\n     19.0.1     - first patch/bug fix for this release\n```\n\n----------------------------------------\n\nTITLE: Upgrading ats.easypy and ats.aereport Modules Using pip - Bash\nDESCRIPTION: This Bash command upgrades both ats.easypy and ats.aereport modules concurrently using pip. It is suitable for multi-package upgrades to synchronize the framework's runtime and reporting capabilities. Dependencies: pip needs to be present. Execution: Run in terminal; no inputs other than the command itself. Output: Terminal feedback regarding package downloads and installations. Constraints: Multiple upgrades could take more time and require network access.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2016/november.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats.easypy ats.aereport\n```\n\n----------------------------------------\n\nTITLE: Upgrading Pyats via pip (bash)\nDESCRIPTION: This bash script installs or upgrades the pyats package using pip.  It uses the `pip install --upgrade` command which ensures the latest version of the pyats framework and its dependencies are installed. The snippet provides commands for both DevNet community and Cisco internal developers. Requires pip installed on your system.  Output is typically installation progress and success messages.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2023/august.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\n#bash$ pip install --upgrade pyats\n\n# Cisco Internal Developers\n#bash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Iterating Over AEtest Container Class Instances in Python\nDESCRIPTION: Demonstrates that `aetest` container class instances (like `CommonSetup`) are iterable. The example defines a `CommonSetup` class with two subsections, instantiates it, and then iterates through the instance, printing the name (UID) of each contained subsection.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/objects.rst#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\n# Example\n# -------\n#\n#   looping on container class instances\n\nfrom pyats import aetest\n\n# define a container & some inhabitants\nclass MyCommonSetup(aetest.CommonSetup):\n    @aetest.subsection\n    def subsection_one(self):\n        self.a = 1\n        print('hello world')\n\n    @aetest.subsection\n    def subsection_two(self):\n        assert self.a == 1\n\n# let's instantiate the class\ncommon_setup = MyCommonSetup()\n\n# loop through to see what we get:\nfor i in common_setup:\n    print(i)\n# subsection_one\n# subsection_two\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyATS to version 21.12\nDESCRIPTION: Instructions for upgrading pyATS to version 21.12. The commands differ based on whether you are a DevNet Community user or a Cisco Internal Developer.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2021/december.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats\n\n# Cisco Internal Developers\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Disabling Exception Raise in TGN hltapi Calls - Python\nDESCRIPTION: Shows how to disable exceptions from being raised when using the hltapi interface's traffic_stats method by passing 'raise_ = False'. Assumes 'ixia' object is already instantiated and that the supporting ats.tgn.hltapi API is imported. The 'port_handle' argument specifies the targeted port, and 'raise_' is a boolean flag. Expects the function to return a status keyed-list without raising exceptions for status=0. Requires the 'ats.tgn.hltapi' Python package.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2015/june.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nixia.traffic_stats(port_handle='1/1/3', raise_ = False)\n```\n\n----------------------------------------\n\nTITLE: Using FileUtils as Context Manager in Python\nDESCRIPTION: Example demonstrating how to use FileUtils as a context manager to ensure sessions are properly closed, with reuse of protocol sessions within the context block.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/file_transfer_utilities.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.utils.fileutils import FileUtils\nwith FileUtils(testbed=tb) as futils:\n    file_details = futils.stat(\"sftp://server.domain.com/path/to/file\")\n    file2_details = futils.stat(\"sftp://server.domain.com/path/to/file2\")\n```\n\n----------------------------------------\n\nTITLE: Disabling pyATS Easypy Plugin during Pre-Job (Python)\nDESCRIPTION: This Python class inherits from BasePlugin and demonstrates how a plugin can disable itself during the pre_job execution phase. By setting `self.enabled` to `False`, the plugin prevents its subsequent stages from being executed by the Easypy plugin manager.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/easypy/plugins.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass MyControlPlugin(BasePlugin):\n\n    def pre_job(self):\n        self.enabled = False\n        return\n```\n\n----------------------------------------\n\nTITLE: Disabling Auto-Casting in Tcl Q Module - Python\nDESCRIPTION: Demonstrates how to utilize the Q magic flag 'cast_ = False' when calling 'set' in pyATS Tcl API to prevent automatic casting of keyed lists. Requires the 'ats.tcl' module to be available and imported. The example first creates a keyed list and then queries it both with and without auto-casting enabled, highlighting the difference in returned types (KeyedList vs string). Intended for enhanced debug or stricter type control; outputs are a structured object or string, respectively.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2015/june.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom ats import tcl\n\ntcl.eval('keylset klist a 1 b 2 c 3')\n\ntcl.q.set('klist')\n# KeyedList({'a': '1', 'c': '3', 'b': '2'})\n\ntcl.q.set('klist', cast_ = False)\n# '{a 1} {b 2} {c 3}'\n```\n\n----------------------------------------\n\nTITLE: Loading Testbed and Inspecting Objects - Text\nDESCRIPTION: This code demonstrates loading a testbed file using pyATS and interacting with the resulting testbed and device objects. It uses the `pyats shell` command and imports `load` from `pyats.topology.loader`. It then prints the type of the testbed and device objects.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2021/february.rst#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n$ pyats shell --testbed-file testbed.yaml\nWelcome to pyATS Interactive Shell\n==================================\nPython 3.8.7 (v3.8.7:6503f05dd5, Dec 21 2020, 12:45:15)\n[Clang 6.0 (clang-600.0.57)]\n\n>>> from pyats.topology.loader import load\n>>> testbed = load('testbed.yaml')\n-------------------------------------------------------------------------------\nIn [1]: type(testbed)\nOut[1]: genie.libs.conf.testbed.Testbed\n\nIn [2]: dev=testbed.devices.R1\n\nIn [3]: type(dev)\nOut[3]: genie.libs.conf.device.iosxe.device.Device\n```\n\n----------------------------------------\n\nTITLE: Simplified String Regex Pause Input\nDESCRIPTION: This example demonstrates how to use a simple string as input to 'pause_on', primarily for local debugging.  It pauses the script whenever 'some phrase' is encountered in the logs. The default action in this simplified mode is to enter the pdb debugger.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/debugging.rst#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\n# Example\n# -------\n#\n#   using simple string regex inputs\n\n# pause on all instances of 'some phrase'\nbash$ python testscript.py -pause_on='.*some phrase.*'\n```\n\n----------------------------------------\n\nTITLE: Example JSON Output Showing Combined BGP Neighbors\nDESCRIPTION: This snippet provides an example output in JSON format illustrating the expanded data structure after processing the PyATS markup. It shows the original nested parameter structure of IPv4 and IPv6 neighbors and the resulting consolidated list 'CE1_neighbors'. This demonstrates how the markup evaluation translates into a combined array of neighbor IP addresses from both address families.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/yaml_markup.rst#_snippet_11\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"parameters\": {\n        \"base_config\": {\n            \"CE1\": {\n                \"bgp\": {\n                    \"address_families\": {\n                        \"ipv4\": {\n                            \"neighbors\": {\n                                \"1.1.1.1\": {},\n                                \"1.1.1.2\": {}\n                            }\n                        },\n                        \"ipv6\": {\n                            \"neighbors\": [\n                                \"1::1\",\n                                \"1::2\"\n                            ]\n                        }\n                    }\n                }\n            }\n        },\n        \"CE1_neighbors\": [\n            \"1.1.1.1\",\n            \"1.1.1.2\",\n            \"1::1\",\n            \"1::2\"\n        ]\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Kleenex via pip in Bash\nDESCRIPTION: This bash code snippet shows how to install the Kleenex module, which is part of the pyats.kleenex package, from the PyPI server using pip. It assumes that pip is already installed on your system and that you have the necessary permissions to install Python packages. This command will install the kleenex module within the pyats namespace, and is required for users wishing to perform device cleaning operations with Kleenex. The expected input is a shell environment where pip is accessible; successful completion results in the Kleenex package being available in your Python environment.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/kleenex/introduction.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install pyats.kleenex\n```\n\n----------------------------------------\n\nTITLE: Launching pyATS Job File with Robot Script via Bash\nDESCRIPTION: Bash command to launch a pyATS job file (e.g., `robot_job.py`) that contains calls to `run_robot`. It uses the `pyats run` command and specifies the testbed file using the `--testbed-file` argument, making it available to the job and subsequent Robot tasks.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/robot/easypy.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pyats run robot_job.py --testbed-file /path/to/tb.yaml\n```\n\n----------------------------------------\n\nTITLE: Finding Self-Links and Intersecting with Testbed Links (pyATS Python)\nDESCRIPTION: Demonstrates using `find_links()` on a device to find links connected back to itself (potentially loopbacks or internal links) and how to find the intersection of these links with the set of all links known to the testbed.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/topology/usage.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# and all properties are computed on the fly\nn7k4.find_links(n7k4) & set(testbed.links)\n# <Link ethernet-1 at 0xf744ee8c>\n# <Link ethernet-2 at 0xf744efac>\n```\n\n----------------------------------------\n\nTITLE: Specifying Step Debug File for AEtest - Python and Bash\nDESCRIPTION: Points to a file containing debug commands for stepwise debugging during testcase execution. This file is read and used by AEtest to control debug interactions at each test step. Input is a file path string; output affects debugging behavior in AEtest steps. Passed via command-line argument or API parameter.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/run.rst#_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\nbash$ python testscript.py -step_debug=\"/path/to/my/stepdebugfile\"\n```\n\nLANGUAGE: python\nCODE:\n```\naetest.main('testscript.py', step_debug = \"/path/to/my/stepdebugfile\")\n```\n\nLANGUAGE: python\nCODE:\n```\nrun(testscript = 'testscript.py', step_debug = \"/path/to/my/stepdebugfile\")\n```\n\n----------------------------------------\n\nTITLE: Implementing Child FTP FileUtils Plugin (Python)\nDESCRIPTION: Shows a sample child `FileUtils` class specifically for handling the FTP protocol, inheriting from its parent OS-specific class (`FileUtilsXyzBase`). It implements the `copyfile` method, parsing source/destination URLs using `urlparse`, extracting server details (hostname, port, path), retrieving authentication credentials via `self.get_auth`, and calling protocol-specific functions (`upload_ftp_file`, `download_ftp_file`) with details like paths, device object (from `self.parent.device`), credentials, and timeout to perform the transfer.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/file_transfer_utilities.rst#_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nfrom urllib.parse import urlparse\nfrom .. import FileUtils as FileUtilsXyzBase\n\nclass FileUtils(FileUtilsXyzBase):\n\n    def copyfile(self, source, destination,\n            timeout_seconds = DEFAULT_COPY_TIMEOUT_SECONDS,\n            *args, upload, **kwargs):\n\n        from_parsed_url = urlparse(source)\n        to_parsed_url = urlparse(destination)\n        if upload:\n            from_path = from_parsed_url.path\n\n            to_server_name = to_parsed_url.hostname\n            to_parsed_port = to_parsed_url.port\n            to_path = to_parsed_url.path\n            server_name = to_server_name\n            port = to_parsed_port\n        else:\n            to_path = to_parsed_url.path\n            from_server_name = from_parsed_url.hostname\n            from_parsed_port = from_parsed_url.port\n            from_path = from_parsed_url.path\n\n            server_name = from_server_name\n            port = from_parsed_port\n\n        # Get auth details\n        username, password = self.get_auth(server_name)\n\n        # Transfer the file by executing commands on the device.\n        if upload:\n            upload_ftp_file(\n                from_path=from_path,\n                to_path=to_path,\n                device=self.parent.device,\n                username=username,\n                password=password,\n                timeout=timeout_seconds)\n        else:\n            download_ftp_file(\n                from_path=from_path,\n                to_path=to_path,\n                device=self.parent.device,\n                username=username,\n                password=password,\n                timeout=timeout_seconds)\n```\n\n----------------------------------------\n\nTITLE: Dynamically Changing Log Files Using TaskLogHandler in pyATS (Python)\nDESCRIPTION: This snippet illustrates advanced usage of TaskLogHandler for changing log files and directories at runtime without requiring a logger instance. It shows the effects of using absolute or relative file paths, and how the current log directory is managed. A handler can be instantiated with a path or with None for stream-to-null behavior. This method is useful for granular log management in long-running or multi-phase processes. Only TaskLogHandler is used directly; logging is not shown.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/log/implementation.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.log import TaskLogHandler\n\n# create handler (with full path to log file)\nhandler = TaskLogHandler('/path/to/my/logdir/TaskLog-A.log')\n\n# now the logging active directory is \"/path/to/my/logdir/\"\n# let's change the tasklog file:\nhandler.changeFile('TaskLog-B.log')\n# following logging behavior, TaskLog-B.log is created under\n# \"/path/to/my/logdir/TaskLog-B.log\"\n\n# but if we provide an absolute path\nhandler.changeFile('/path/to/newdir/TaskLog-C.log')\n# logging directory changes to \"/path/to/newdir/\n\n# to use present-working-directory, create handler with logfile as None\nhandler = TaskLogHandler(None)\n# note that if you only change current logfile to None, the last logdir\n# does not change\n```\n\n----------------------------------------\n\nTITLE: Configuring PyATS Reporter Git Information Collection - INI\nDESCRIPTION: This snippet shows configuration settings to enable or disable git information collection by the PyATS reporter. It must be added to the pyATS config file under the [report] section. The 'git_info' boolean controls whether git metadata about tested files and repos is included in reports.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/reporter/overview.rst#_snippet_2\n\nLANGUAGE: ini\nCODE:\n```\n# configuration related to the report\n[report]\n# Collect git info, default is True.\ngit_info = False\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyATS using pip (Bash)\nDESCRIPTION: Provides the bash commands to upgrade the pyATS installation using pip. It distinguishes between commands for the DevNet Community (`pip install --upgrade pyats`) and Cisco Internal Developers (`pip install --upgrade ats`). These commands ensure the user installs the latest available version (v23.1 as per the document) of the pyATS framework and its components.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2023/january.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats\n\n# Cisco Internal Developers\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Q Magic Call Conventions and Argument Mapping with pyATS Tcl Interpreter Python\nDESCRIPTION: This snippet outlines various call patterns for invoking Tcl commands through the Q magic object in pyATS. It highlights how Python attribute access maps to Tcl namespaces and commands, and how *args and **kwargs are translated to Tcl positional and dashed (flag-like) arguments. Inputs include Tcl command and function names, positional and keyword arguments; outputs are mapped Tcl command invocations with results delivered as Python types. The Q object adheres to specific rules to handle namespace resolution and argument casting automatically.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/tcl/q.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# refer to Tcl's set command (built-in)\ntcl.q.set\n\n# refers to Tcl ::a::b::c procedure\ntcl.q.a.b.c\n\n# making a call\ntcl.info('patchlevel')\n\n# notice that set takes two arguments: name and value\ntcl.q.set('varName', 'varValue')\n\n# representation -a 1 -b 2 dashed arguments\ntcl.q.testProc(a = 1, b = 2)\n```\n\n----------------------------------------\n\nTITLE: Creating a ListDict Instance in Python\nDESCRIPTION: Shows how to instantiate a ListDict object from a nested dictionary. ListDict can only be created from an existing dictionary structure.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/datastructures/listdict.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   Creating ListDict\n\nfrom pyats.datastructures import ListDict\n\n# reusing 'suggest' variable from previous section\nld = ListDict(suggest)\n# [DictItem(path=('a', 'b', 'e'), value=<object object at 0xf7683f40>), \n#  DictItem(path=('a', 'b', 'c'), value=<object object at 0xf7683d00>)]\n```\n\n----------------------------------------\n\nTITLE: Upgrading Pyats via pip (DevNet)\nDESCRIPTION: This command upgrades the Pyats package using pip, the Python package installer. It installs the latest version available from the DevNet community. The `--upgrade` flag ensures that the existing Pyats installation is updated to the latest version. This is a prerequisite for using updated Pyats features and bug fixes.  The output will indicate the installation status and version.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2023/october.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\n    bash$ pip install --upgrade pyats\n```\n\n----------------------------------------\n\nTITLE: Skipping Section with AssertionError in Pre-processor - Python\nDESCRIPTION: Demonstrates how an `AssertionError` raised within a pre-processor function causes the remaining pre-processors to be skipped and the test section to receive a 'Skipped' result. Post-processors are also skipped in this scenario.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/processors.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef preprocessorAssertionError():\n    # assertion error causes all remaining pre-processors to be skipped\n    # and the test section also receives a result of Skipped\n    assert 'vim' is 'great'\n```\n\n----------------------------------------\n\nTITLE: Upgrading ats.kleenex, ats.easypy, and ats.utils Modules via pip (Bash)\nDESCRIPTION: This bash command demonstrates how to upgrade the ats.kleenex, ats.easypy, and ats.utils Python modules to their latest available versions using pip. It requires pip to be installed on the host system and assumes that Python packages are available in the configured repositories. No additional arguments are needed other than specifying the package names; the --upgrade flag ensures that any older versions are updated. Outputs will indicate success or failure, and users must have appropriate permissions to install or upgrade Python packages.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2017/sep.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats.kleenex ats.easypy ats.utils\n```\n\n----------------------------------------\n\nTITLE: Installing Multiple pyATS Packages\nDESCRIPTION: This command upgrades multiple specified pyATS packages using pip. The `--upgrade` flag ensures that the latest versions of all packages are installed simultaneously.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2016/may.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats.aetest ats.connections ats.topology ats.kleenex\n```\n\n----------------------------------------\n\nTITLE: Changing Remote File Permissions with FileUtils in Python\nDESCRIPTION: Example showing how to change the permissions of a remote file using the chmod method. Uses the same permission format as os.chmod.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/file_transfer_utilities.rst#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.utils.fileutils import FileUtils\nwith FileUtils(testbed=tb) as futils:\n    import stat\n    mode  = stat.S_IRWXU | stat.S_IRGRP | stat.S_IXGRP | stat.S_IXOTH\n    futils.chmod(target = 'ftp://myserver.domain.com/remote/path/to/file', mode=mode)\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyATS Framework (Bash)\nDESCRIPTION: Provides commands to upgrade the pyATS framework using the pip package installer. Separate commands are shown for DevNet Community users (`pip install --upgrade pyats`) and Cisco Internal Developers (`pip install --upgrade ats`).\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2022/september.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats\n\n# Cisco Internal Developers\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Accessing ListDict Elements in Python\nDESCRIPTION: Demonstrates how to access individual elements of a ListDict object, including accessing the path and value components of each DictItem.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/datastructures/listdict.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   Accessing ListDict\n\nfrom pyats.datastructures import ListDict\n\n# reusing 'ld' from above\nld[0]\n# DictItem(path=('a', 'b', 'e'), value=<object object at 0xf7683f40>)\nld[0].path\n# ('a', 'b', 'e')\nld[0].value\n# <object object at 0xf7683f40>\n```\n\n----------------------------------------\n\nTITLE: Running AEtest Script in Standalone Mode\nDESCRIPTION: Example command and output demonstrating how to execute an AEtest script directly through the Python executable. The output shows test execution results with detailed reporting.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/run.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# Example\n# -------\n#\n#   running an aetest script standalone using python executable\n#   (output timestamp removed for legibility purpose)\n\n(pyats) [tony@jarvis:pyats]$ python /path/to/your/script.py\n\n    +------------------------------------------------------------------------------+\n    |                            Starting common setup                             |\n    +------------------------------------------------------------------------------+\n    +------------------------------------------------------------------------------+\n    |                      Starting subsection subsection_one                      |\n    +------------------------------------------------------------------------------+\n    The result of subsection subsection_one is => PASSED\n    +------------------------------------------------------------------------------+\n    |                      Starting subsection subsection_two                      |\n    +------------------------------------------------------------------------------+\n    The result of subsection subsection_two is => PASSED\n    The result of common setup is => PASSED\n    +------------------------------------------------------------------------------+\n    |                          Starting testcase Testcase                          |\n    +------------------------------------------------------------------------------+\n    +------------------------------------------------------------------------------+\n    |                          Starting section test_one                           |\n    +------------------------------------------------------------------------------+\n    The result of section test_one is => PASSED\n    +------------------------------------------------------------------------------+\n    |                          Starting section test_two                           |\n    +------------------------------------------------------------------------------+\n    The result of section test_two is => PASSED\n    +------------------------------------------------------------------------------+\n    |                         Starting section test_three                          |\n    +------------------------------------------------------------------------------+\n    The result of section test_three is => PASSED\n    The result of testcase Testcase is => PASSED\n    +------------------------------------------------------------------------------+\n    |                               Detailed Results                               |\n    +------------------------------------------------------------------------------+\n     SECTIONS/TESTCASES                                                    RESULT\n    --------------------------------------------------------------------------------\n     .\n     |-- CommonSetup                                                       PASSED\n     |   |-- subsection_one                                                PASSED\n     |   `-- subsection_two                                                PASSED\n     `-- Testcase                                                          PASSED\n         |-- test_one                                                      PASSED\n         |-- test_two                                                      PASSED\n         `-- test_three                                                    PASSED\n    +------------------------------------------------------------------------------+\n    |                                   Summary                                    |\n    +------------------------------------------------------------------------------+\n     Number of ABORTED                                                            0\n     Number of BLOCKED                                                            0\n     Number of ERRORED                                                            0\n     Number of FAILED                                                             0\n     Number of PASSED                                                             2\n     Number of PASSX                                                              0\n     Number of SKIPPED                                                            0\n    --------------------------------------------------------------------------------\n```\n\n----------------------------------------\n\nTITLE: Installing pyATS via pip\nDESCRIPTION: This snippet demonstrates how to install the pyATS framework and its dependencies using pip. The `[full]` option includes all optional dependencies and features.  You must have Python and pip installed on your system to execute this command. The output will indicate the installation progress and any errors encountered.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ pip install pyats[full]\n```\n\n----------------------------------------\n\nTITLE: Upgrading ats.topology Python Module Using Bash\nDESCRIPTION: Provides the Bash command to upgrade the ats.topology Python module to version 3.2.1. This requires pip and a functional Python environment with pyATS installed. The upgrade includes a new option 'extend_devices_from_links' to the 'testbed.squeeze' functionality, enabling more granular control over device topology extension.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2017/january.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats.topology\n```\n\n----------------------------------------\n\nTITLE: Testing Parameter Propagation in aetest TestScript - Python\nDESCRIPTION: Illustrates how updates to a mutable parameter dictionary propagate into an aetest.TestScript within the pyATS test framework. Requires 'ats.aetest' import and a flexible testbed environment. The example extends a parameters dict within the setup phase and verifies availability in both the setup and test steps, confirming correct object linkage. Inputs include the initial empty parameters dict; outputs are assertion results indicating correct update propagation.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2015/june.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom ats import aetest\n\nparameters = {}\n\nclass Testcase(aetest.Testcase):\n\n    @aetest.setup\n    def setup(self):\n        # add new stuff to parameters\n        parameters['new'] = 1\n\n        # propagates to parameters\n        assert 'new' in self.parameters\n\n    @aetest.test\n    def test(self, new):\n        # and useable\n        assert new == 1\n```\n\n----------------------------------------\n\nTITLE: Finding Interface Connected to Remote Device/Link (pyATS Python)\nDESCRIPTION: Illustrates iterating through a device's interfaces to locate a specific interface connected to a particular remote device and associated with a named link. It uses the `remote_devices` attribute and checks the `link.name`.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/topology/usage.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# loop through interfaces and find a interface that connects\n# to a particular link\nfor intf in n7k4:\n    if n7k5 in intf.remote_devices and intf.link.name == 'rtr1-rtr2-2':\n        break\nelse:\n    intf = None\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyATS (Full Package) via pip (Bash)\nDESCRIPTION: Provides the pip commands to upgrade the entire pyATS package for both DevNet Community users (`pyats`) and Cisco Internal Developers (`ats`). These commands apply to the v20.10 release from October 27, 2020.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2020/oct.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats\n\n# Cisco Internal Developers\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Rolling Up pyATS Results using '+' Operator - Python\nDESCRIPTION: This snippet demonstrates how to combine multiple pyATS result objects using the standard Python addition operator (`+`). It shows basic combinations and how to use the augmented assignment operator (`+=`) to roll up results into a variable.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/results/rollup.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   rolling multiple results objects\n\n# import all result codes\nfrom pyats.results import (Passed, Failed, Aborted, Errored,\n                             Skipped, Blocked, Passx)\n\n# roll up some results together\nPassed + Failed\n# Failed\n\nPassx + Errored\n# Errored\n\n# chaining multiples\nPassed + Aborted + Blocked\n# Blocked\n\n# assign a result to variable\nresult = Passed\n\n# roll up that result against another\nresult += Failed\n```\n\n----------------------------------------\n\nTITLE: Upgrading ats.utils Python Module Using Bash\nDESCRIPTION: Provides the Bash command to upgrade the ats.utils Python module to version 3.2.1. It requires the pip package manager and assumes Python and pyATS environment are properly configured. The command installs the latest compatible version of ats.utils, addressing minor refactoring changes to fix recent breakages in the ats.topology module.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2017/january.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats.utils\n```\n\n----------------------------------------\n\nTITLE: Upgrading PyATS TCL module for April 27, 2018 release\nDESCRIPTION: Bash commands to upgrade the pyats.tcl package to version 4.1.1. Separate commands are provided for DevNet Community and Cisco Internal Developers.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2018/apr.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats.tcl\n\n# Cisco Internal Developers\nbash$ pip install --upgrade ats.tcl\n```\n\n----------------------------------------\n\nTITLE: Validating Testbed in Python\nDESCRIPTION: This Python snippet illustrates how to programmatically validate a testbed using the `pyats.topology.utils` module.  It imports `validate_testbed`, calls it with a testbed dictionary, and then checks for warnings and exceptions.  Dependencies include `pyats.topology.utils`.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2020/aug.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.topology.utils import validate_testbed\n\ntestbed = {...}\n\nproblems = validate_testbed(testbed)\n\nif problems['warnings']:\n    log.warning('Warnings generated')\nfor warn in problems['warnings']:\n    log.warning(warn)\n\nif problems['exceptions']:\n    log.error('Failed to validate testbed')\nfor exc in problems['exceptions']:\n    log.error(exc)\n```\n\n----------------------------------------\n\nTITLE: Configuring a pyATS Testbed YAML for Dynamic File Transfer Server\nDESCRIPTION: This YAML snippet demonstrates how to define a dynamic file transfer server within a pyATS testbed. It specifies server attributes such as protocol, subnet, and root path, enabling the pyATS FileServer plugin to automatically start and manage the server when running tests.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/file_transfer_server.rst#_snippet_0\n\nLANGUAGE: YAML\nCODE:\n```\ntestbed:\n  servers:\n    myftpserver:\n      dynamic: true\n      protocol: ftp\n      subnet: 10.0.0.0/8  # Optional\n      path: /path/to/root/dir\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyats.kleenex and pyats.easypy (Cisco Internal)\nDESCRIPTION: This command upgrades both ats.kleenex and ats.easypy modules using pip for Cisco internal developers. It ensures that the latest versions are installed, providing access to internal features and bug fixes across these modules.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2019/jan.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats.kleenex ats.easypy\n```\n\n----------------------------------------\n\nTITLE: Upgrading ats.templates Module using pip - bash\nDESCRIPTION: This snippet shows how to upgrade the ats.templates module using pip. It ensures that the latest version is installed, which includes bug fixes and potential improvements to the module.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2016/december.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats.templates\n```\n\n----------------------------------------\n\nTITLE: Applying Different Discovery Classes to Common Sections\nDESCRIPTION: Demonstrates how to apply different discovery classes to common setup and cleanup sections using the discoverer attribute. This allows customization of how subsections are discovered within common sections.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/control.rst#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats import aetest\nfrom pyats.aetest import runtime\n\nruntime.discoverer.common = MyDefaultDiscovery\n\nclass common_setup(aetest.CommonSetup):\n    pass\n\nclass common_cleanup(aetest.CommonCleanup):\n    discoverer = MyCommonDiscovery1\n```\n\n----------------------------------------\n\nTITLE: Internal workings of aetest loop decorators and generators\nDESCRIPTION: This detailed explanatory section describes how the @loop decorator and loop.mark() function mark sections for looping, with the loop behavior driven by loop generator classes. It includes pseudocode demonstrating the process of expanding a loop into multiple iterations, creating subsections with unique uids and parameters. It emphasizes that loop generators are the core components producing Iteration objects, which control the loop's execution flow.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/loop.rst#_snippet_15\n\nLANGUAGE: Markdown\nCODE:\n```\n# pseudo code demonstrating @loop decorator functionality\n\ndef loop(generator=DefaultLooper, *args, **kwargs):\n    # the actual loop generator gets called with all of the arguments\n    # to loop decorator, and generates each section iteration\n    return generator(*args, **kwargs)\n\n# pseudo code illustrating internals during runtime\nfor iteration in loop(*args, **kwargs):\n    # create a section from iteration info and run it\n    subsection = Subsection(uid=iteration.uid, \n                            parameters=iteration.parameters)\n    # append subsection to list\n    common_setup.subsections.append(subsection)\n\n# loop generators are classes returning Iteration instances, which contain uid and parameters.\n# example uses a default generator, with code showing how parameters are propagated to subsections.\n```\n\n----------------------------------------\n\nTITLE: Setting Randomization Seed for AEtest - Python and Bash\nDESCRIPTION: Specifies an integer seed value to control testcase randomization reproducibly. Requires randomization to be enabled first. This helps in debugging by reproducing the same randomized testcase order. Input is an integer seed; output is repeatable testcase order. Used as command-line argument or in API calls.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/run.rst#_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nbash$ python testscript.py -random -random_seed 42\n```\n\nLANGUAGE: python\nCODE:\n```\naetest.main('testscript.py', random = True, random_seed = 42)\n```\n\nLANGUAGE: python\nCODE:\n```\nrun(testscript = 'testscript.py', random = True, random_seed = 42)\n```\n\n----------------------------------------\n\nTITLE: YAML File Format Example for Rerun Configuration\nDESCRIPTION: Illustrates the structure of a YAML file used for specifying tasks and test cases to be rerun. This file defines the task ID, the path to the test script, common setup and cleanup, and a list of test cases with their results. This file structure can be used for both selection and results rerun files.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/easypy/rerun.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n# The task-id is the key for each task\nTask-1:\n  # the path to this task's testscript is mandatory.\n  testscript: /path/to/testscript.py\n  # commonSetup and commonCleanup are seperate from Testcases, and they will\n  # only be executed if present in the file.\n  commonSetup:\n    name: common_setup\n    result: PASSED\n  commonCleanup:\n    name: common_cleanup\n    result: PASSED\n  # list of all testcases in Task-1\n  testcases:\n  - name: tc_one\n    # result is only necessary for a results rerun file. A selection rerun\n    # file would omit these.\n    result: PASSED\n  - name: tc_two\n    result: PASSED\nTask-2:\n  testscript: /path/to/testscript.py\n  commonSetup:\n    name: common_setup\n    result: PASSED\n  commonCleanup:\n    name: common_setup\n    result: PASSED\n  testcases:\n  - name: tc_one\n    result: FAILED\n  - name: tc_two\n    result: ERRORED\n```\n\n----------------------------------------\n\nTITLE: Implementing Parent FileUtils Class for an OS (Python)\nDESCRIPTION: Provides a sample implementation of a parent `FileUtils` class for a hypothetical OS, inheriting from `pyats.utils.fileutils.FileUtils`. It demonstrates overriding `close` to delegate to children and `copyfile` to determine locality (local/remote), select the appropriate protocol-specific child plugin via `get_child`, and delegate the copy operation. It also includes logic to prevent unsupported local-to-local and remote-to-remote copies.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/file_transfer_utilities.rst#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.utils.fileutils import FileUtils as FileUtilsBase\n\nclass FileUtils(FileUtilsBase):\n  DEFAULT_COPY_TIMEOUT_SECONDS = 1200\n\n  def close(self):\n      \"\"\" Deallocate any resources being held.  \"\"\"\n      for child_name, child_obj in self.children.items():\n          child_obj.close()\n\n\n  def copyfile(self, source, destination,\n          timeout_seconds = DEFAULT_COPY_TIMEOUT_SECONDS,\n          *args, **kwargs):\n      \"\"\" Copy a file to/from a remote server. \"\"\"\n\n      from_scheme = self.get_scheme(source)\n      to_scheme = self.get_scheme(destination)\n\n      from_scheme_is_local = self.is_local(source)\n      to_scheme_is_local = self.is_local(destination)\n\n      if from_scheme_is_local and to_scheme_is_local:\n          raise Exception(\"fileutils module {} does not allow \"\n              \"copying between two local files.\".format(self.__module__))\n\n      if not from_scheme_is_local and not to_scheme_is_local:\n          raise Exception(\"fileutils module {} does not allow \"\n              \"copying between two remote files.\".format(self.__module__))\n\n\n      abstraction_scheme = to_scheme if from_scheme_is_local else from_scheme\n\n      # Get implementation\n      child = self.get_child(abstraction_scheme, **kwargs)\n\n      # Execute copy\n      return child.copyfile(source, destination, timeout_seconds,\n          *args, upload=from_scheme_is_local, **kwargs)\n```\n\n----------------------------------------\n\nTITLE: Output of Loading YAML with EXTEND_LIST Key Markup (Text)\nDESCRIPTION: Shows the resulting Python dictionary after loading the extended YAML file (`b.yaml`) using the pyATS loader with extensions enabled. It confirms that the `parameters.sections` list has been successfully extended from the base file's `['a', 'b']` to `['a', 'b', 'c']` by processing the `%EXTEND_LIST{sections}` markup.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/yaml_markup.rst#_snippet_8\n\nLANGUAGE: text\nCODE:\n```\n{'parameters': {'sections': ['a', 'b', 'c']}}\n```\n\n----------------------------------------\n\nTITLE: Defining Plugin Entry Point in setup.py (Python)\nDESCRIPTION: Shows how to register a custom OS-specific `FileUtils` plugin (`myfutils.plugins.xyz`) in the `setup.py` file using the `entry_points` mechanism. This makes the plugin discoverable by the core `pyats` framework under the `pyats.utils.fileutils.plugins` group, allowing it to be automatically loaded.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/file_transfer_utilities.rst#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\n# setup.py\n...\n# console entry point\nentry_points = {\n    'pyats.utils.fileutils.plugins' : [\n        'xyz = myfutils.plugins.xyz',\n    ],\n},\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyATS via pip for DevNet and Cisco Developers - Bash\nDESCRIPTION: This bash code snippet explains how to upgrade the pyATS package for both external (DevNet Community) and internal Cisco developers using pip. For Cisco's internal environment, the package 'ats' must be used in place of 'pyats'. These commands update installed packages to the latest available versions and only require pip to be installed and access to the network. No inputs or outputs are required other than the pip process logs.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2020/feb.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats\n\n# Cisco Internal Developers\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Connecting with default settings\nDESCRIPTION: This snippet showcases how to establish a default connection to a device using its connection manager. It shows how to access the connection manager and then retrieve the connections it manages.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/connections/manager.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# if we make the default connection\ndevice.connect()\n\n# and dice things further\n# eg, single out the connection manager\nmanager = device.connectionmgr\n\n# notice that each manager is unique to its parent device\nmanager.device\n# <Device phoenix at 0xf7714c0c>\n\n# and contains a dictionary of connections it currently knows\n# stored as alias: object mapping\n# note how the default connection is assigned with alias \"default\"\nmanager.connections\n# AttrDict({'default': <Connection phoenix at 0xf76c3d08>})\n```\n\n----------------------------------------\n\nTITLE: Device Connect/Disconnect Syntax with pyATS\nDESCRIPTION: This snippet illustrates the syntax for connecting to and disconnecting from a device using the `device.connect()` and `device.disconnect()` methods in pyATS. It highlights the use of optional arguments such as `via` and `**kwargs` for customization.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/connections/integration.rst#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nSyntax\n------\n\n    # [] denotes optional arguments\n    # *args, **kwargs denotes all other possible arguments\n\n    # connect & disconnect\n    device.connect([via = \"path\"], [**kwargs])\n    device.disconnect()\n\n    # calling services\n    device.<services>([*args], [**kwargs])\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyATS using pip\nDESCRIPTION: This code snippet demonstrates how to upgrade the pyATS library using the pip package manager. It ensures the latest version is installed, incorporating bug fixes and feature enhancements. This command is suitable for upgrading from version v2.0.1 or later.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2015/september.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Implementing a Processor in pyATS AEtest - Python\nDESCRIPTION: This Python snippet demonstrates how to implement and use a custom processor function within a pyATS AEtest test case. It depends on the 'pyats.aetest' module and defines a processor with typed parameters, then attaches it to a test method using the '@aetest.processors.post' decorator. Required arguments include the section, processor, testbed, steps, and custom parameters (e.g., 'param_a'). The processor evaluates 'param_a' and marks the processor as failed if the condition is not met. The example also shows how to set test parameters within the test method.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2020/sep.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats import aetest\n\ndef my_processor(section, processor, testbed, steps, param_a):\n    if not param_a:\n        processor.failed('param_a is False')\n\nclass MyTestcase(aetest.Testcase):\n    @aetest.processors.post(my_processor)\n    @aetest.test\n    def test_method(self):\n        self.parameters['param_a'] = False\n```\n\n----------------------------------------\n\nTITLE: YAML Testbed Configuration Example\nDESCRIPTION: Example of a YAML testbed configuration file defining a device named 'jarvis' with its type, alias, connections, role, and custom attributes. Demonstrates the hierarchical structure used in pyATS topology files.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/topology/introduction.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\ndevices:\n    jarvis:\n        type: \"Artificial Intelligence Computer\"\n        alias: \"J.A.R.V.I.S\"\n        connections:\n            voice:\n                protocol: english\n        role: \"Tony Stark's housekeeper\"\n        custom:\n            appeared_in:\n                - Iron Man\n                - Iron Man 2\n                - The Avengers\n                - Iron Man 3\n                - Avengers - Age of Ultron\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for the fileutils Submodule using Sphinx\nDESCRIPTION: Uses the Sphinx `automodule` directive to automatically generate documentation for the `pyats.utils.fileutils.bases.fileutils` Python submodule. Similar to the package-level directive, it includes all members, undocumented members, and inheritance information.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/apidoc/utils/pyats.utils.fileutils.bases.rst#_snippet_1\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: pyats.utils.fileutils.bases.fileutils\n   :members:\n   :undoc-members:\n   :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: Checking Remote File Existence with FTP in Python\nDESCRIPTION: Example showing how to verify if a file exists on a remote FTP server using the checkfile() method. This returns a boolean indicating whether the file exists.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/file_transfer_utilities.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfutils.checkfile(target = 'ftp://myserver.domain.com/remote/path/to/file')\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyATS AEReport Module via pip - bash\nDESCRIPTION: Explains how to upgrade the `ats.report` module (referred to internally as `ats.aereport`) using the pip package manager. This command is specifically for Cisco Internal Developers accessing internal repositories. Requires pip to be installed and configured.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2019/aug.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# Cisco Internal Developers\nbash$ pip install --upgrade ats.report\n```\n\n----------------------------------------\n\nTITLE: Updating connection class connection check from method to property\nDESCRIPTION: This snippet refactors the connection status check from using the method ``.is_connected()`` to the property ``.connected``. It simplifies status verification of device or session connections within the framework, removing the need to call as a method. Dependencies include the connection class from the framework, and it targets improved code readability and efficiency.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2015/june.rst#_snippet_14\n\nLANGUAGE: Python\nCODE:\n```\nconnection.is_connected()\n```\n\n----------------------------------------\n\nTITLE: Setting Log Level for Kleenex in pyATS\nDESCRIPTION: Shows how to use the --loglevel parameter to control the logging verbosity of the Kleenex module. This is useful for debugging purposes and can be specified in uppercase or lowercase.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/kleenex/usages.rst#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pyats clean --testbed-file /path/to/my/testbed.yaml\\\n                      --clean-file /path/to/my/clean.yaml\\\n                      --loglevel DEBUG\n```\n\n----------------------------------------\n\nTITLE: Reconstructing Dictionary from ListDict in Python\nDESCRIPTION: Demonstrates how to convert a ListDict back into its original nested dictionary format using the reconstruct() method, creating a new dictionary object.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/datastructures/listdict.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   reconstructing a dict from ListDict\n\n# continuing from above example...\nnew_dict = ld.reconstruct()\n# {'a': {\n#     'b': {\n#         'x': <object object at 0xf7716ce8>, \n#         'c': <object object at 0xf7716f40>, \n#         'e': <object object at 0xf7716ea8>}\n#     }\n# }\n\n# id(new_dict) is not the same as id(suggest)\nid(new_dict) == id(suggest)\n# False\n```\n\n----------------------------------------\n\nTITLE: Default Alias Connection Example with pyATS\nDESCRIPTION: This example illustrates how a default alias ('default') is used when establishing a single connection without specifying an alias. It demonstrates that calling device.execute() is equivalent to device.default.execute() in this scenario.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/connections/integration.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   default alias is \"default\"\n\n# in the case of single connections above\ndevice.connect()\n\n# you only get ONE connection, and\n# this connection bears the alias \"default\", eg:\ndevice.execute('show clock')\n\n# is the exact same as:\ndevice.default.execute('show clock')\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyATS Using pip\nDESCRIPTION: This snippet provides the command to upgrade the pyATS instance using pip. It advises to activate your pyATS instance before running the command, also mentions a note about using `uts ats-py2` for python-2 version of pyATS.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2015/june.rst#_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Setting Custom Testcase Discovery Class in pyATS AETEST\nDESCRIPTION: Shows how to change the default testcase discovery class by setting the runtime.discoverer.testcase property. Custom discovery classes must inherit from the default TestcaseDiscovery class.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/control.rst#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.aetest import runtime\nruntime.discoverer.testcase = MyCustomTestcaseDiscovery\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.aetest import runtime\nfrom pyats.aetest.discovery import TestcaseDiscovery\n\nclass MyCustomTestcaseDiscovery(TestcaseDiscovery):\n    pass\n\nruntime.discoverer.testcase = MyCustomTestcaseDiscovery\n```\n\n----------------------------------------\n\nTITLE: Loading AEtest Testable Objects via Loader Module - Python\nDESCRIPTION: Demonstrates how to use the AEtest loader module to load a Python file or module into a TestScript instance, which can then be executed as a testscript. This is used to programmatically instantiate testable objects from file paths or modules. The dependency is the pyats.aetest.loader module. The input can be a file path string or a module object; output is a TestScript instance. The snippet includes examples of acceptable testables (Python files, module names, non-built-in module objects).\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/run.rst#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.aetest import loader\n\n# load a testscript file directly into an object\n# and check the object type.\nobj = loader.load(testable = '/path/to/testScript.py')\nobj\n# <class 'TestScript' uid='pyats.aetest.testscript'>\n```\n\nLANGUAGE: python\nCODE:\n```\naetest.main(testable = '/paty/to/your/test/script/file.py')\n```\n\nLANGUAGE: python\nCODE:\n```\naetest.main(testable = 'regression.bgp.traffic_suite')\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom regression.bgp import traffic_suite\n\naetest.main(testable = traffic_suite)\n```\n\n----------------------------------------\n\nTITLE: Building pyATS documentation\nDESCRIPTION: Command to generate the pyATS documentation in HTML format. The built documentation will be stored in the __build__ directory.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nmake docs\n```\n\n----------------------------------------\n\nTITLE: Upgrading ats.utils (Internal) - bash\nDESCRIPTION: This bash command upgrades the `ats.utils` module for Cisco Internal Developers using the pip package manager. It requires pip to be installed and configured correctly, likely pointing to an internal package repository.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2018/aug.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# Cisco Internal Developers\nbash$ pip install --upgrade ats.utils\n```\n\n----------------------------------------\n\nTITLE: Introducing boolean logic module in datastructures.logic\nDESCRIPTION: This snippet references the new ``datastructures.logic`` module, which provides classes implementing boolean logic operations such as ``And``, ``Or``, and ``Not``. These classes facilitate complex logical evaluations within the framework's data structures, enabling more expressive automation scripts and conditions.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2015/june.rst#_snippet_19\n\nLANGUAGE: Python\nCODE:\n```\nimport datastructures.logic\n```\n\n----------------------------------------\n\nTITLE: pyATS Migrate Abstract Subcommand Usage\nDESCRIPTION: Shows the specific usage and options for the 'abstract' subcommand of the pyATS migrate command. It is used to discover necessary changes to conform to the new token discovery.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/cli/pyats_migrate.rst#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nUsage:\n  pyats migrate abstract [options]\n\nDescription:\n  Discover what changes must be made to existing test environments to conform to the new token discovery.\n\nAbstract Options:\n  path                  Path to start searching for files\n  --init                Only process __init__.py files\n  --python              Only process Python files\n  --yaml                Only process YAML files\n  --threads THREADS     Max number of threads to run while processing files (default 100)\n```\n\n----------------------------------------\n\nTITLE: Parsing Logic Expressions from Strings with logic_str (Python)\nDESCRIPTION: Illustrates how to use the pyATS logic_str function to convert string representations of logic expressions into logic operator objects. This enables parsing of logical operators from CLI or external configuration and subsequent Boolean evaluation. Dependencies: logic and logic_str from pyats.datastructures.logic. Input is a string formatted as valid Python code for logic operator instantiation; output is a logic operator object that can be called with test values for evaluation. Limitation: logic_str only supports string (regex) style inputs and lambda functions.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/datastructures/logic.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   string to logic objects\n\nfrom pyats.datastructures.logic import logic_str\n\n# creating an And regex logic from string\nobj = logic_str(\"And('a', 'b')\")\n\ntype(obj)\n# <class 'pyats.datastructures.logic.And'>\n\nobj('ab')\nTrue\n\nobj('cd')\nFalse\n\n```\n\n----------------------------------------\n\nTITLE: Upgrading PyATS via Pip (Cisco Internal) - Bash\nDESCRIPTION: Command to upgrade the 'ats' package, which is the Cisco internal distribution of PyATS, using the pip package manager. This command is specifically intended for Cisco Internal Developers to update their PyATS installation.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2023/may.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyats via pip (DevNet)\nDESCRIPTION: This command upgrades the core pyats package using pip for DevNet community users. It ensures the latest version is installed, providing access to new features, bug fixes, and module updates.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2019/jan.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade pyats\n```\n\n----------------------------------------\n\nTITLE: Subscribing to pyATS Reporter Events - Python\nDESCRIPTION: Demonstrates how to use the `pyats.reporter.ReportClient.subscribe` async function to receive live updates. It requires an async callback function to process events and uses `asyncio` to run the subscription loop.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/reporter/subscribe.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\n\nfrom pyats.reporter import ReportClient\n\nasync def my_callback(event):\n    # handle event data\n    pass\n\nclient = ReportClient(path_to_socket)\nloop = asyncio.get_event_loop()\nloop.run_until_complete(client.subscribe(my_callback))\n```\n\n----------------------------------------\n\nTITLE: Parametrized Function Example - Python\nDESCRIPTION: This is a placeholder.  The full example is incomplete. This section illustrates the concept of parametrized functions in pyATS, using the `parametrize` decorator. Parametrized functions are callable parameters that can also accept arguments. They automatically become part of the `TestScript` parameters and can be used to define the function argument during runtime.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/parameters.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nimport random\n    from pyats import aetest\n\n    # defining a parametrized function called \"number\"\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyATS v22.2 for DevNet Community and Cisco Internal Developers\nDESCRIPTION: Commands for upgrading pyATS to version 22.2. The first command is for DevNet Community users to upgrade the pyATS package, while the second command is for Cisco Internal Developers to upgrade the ats package.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2022/february.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats\n\n# Cisco Internal Developers\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Installing the AEtest Package using pip\nDESCRIPTION: Provides the Bash command using `pip` to install the `pyats.aetest` package independently. This command fetches and installs the AEtest module from the Python Package Index (PyPI).\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/introduction.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npip install pyats.aetest\n```\n\n----------------------------------------\n\nTITLE: Getting pyATS Processors for Section - Python\nDESCRIPTION: Demonstrates using `aetest.processors.get()` to retrieve lists of pre, post, or exception processors attached to a given section (like a Testcase). The `incl_globals=True` argument shows how to include globally defined processors of the specified type in the result.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/processors.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats import aetest\n\n# create a global processor\nglobal_processors = dict(pre = [lambda: True])\n\n# testcase with two lambda functions as pre-processors\n@aetest.processors.pre(lambda: True, lambda: True)\nclass Testcase(aetest.Testcase):\n    pass\n\n\naetest.processors.get(Testcase, type_ = 'pre')\n# [<function <lambda> at 0xf758e734>,\n#  <function <lambda> at 0xf769e0bc>]\n\naetest.processors.get(Testcase, type_ = 'post')\n# []\n\naetest.processors.get(Testcase, type_ = 'exception')\n# []\n\naetest.processors.get(Testcase, type_ = 'pre', incl_globals = True)\n# [<function <lambda> at 0xf756b305>\n#  <function <lambda> at 0xf758e734>,\n#  <function <lambda> at 0xf769e0bc>]\n```\n\n----------------------------------------\n\nTITLE: Creating and manipulating OrderableDict in Python\nDESCRIPTION: This snippet demonstrates how to instantiate an OrderableDict, add key-value pairs, move an existing key to a new position, and insert a new key at a specific position. It illustrates the core functionalities of the data structure, including its methods move() and insert().\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/datastructures/orderabledict.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n# Example\n# -------\n#\n#   using OrderableDict\n\nfrom pyats.datastructures import OrderableDict\n\n# create a blank OrderableDict\nobj = OrderableDict()\n\n# all added keys are remembered in the order as they are added\nobj['A'] = 1\nobj['B'] = 2\nobj['C'] = 3\n# OrderableDict([('A', 1), ('B', 2), ('C', 3)])\n\n# use move() api to move an existing key to a new positions\n# eg, moving 'C' key and value to first position\nobj.move('C', 0)\n# OrderableDict([('C', 3), ('A', 1), ('B', 2)])\n\n# use insert() to insert new keys into arbitrary positions\n# eg, insert 'D' key into 2nd position\nobj.insert('D', 4, position = 1)\n# OrderableDict([('C', 3), ('D', 4), ('A', 1), ('B', 2)])\n```\n\n----------------------------------------\n\nTITLE: Converting Python Array to Tcl String\nDESCRIPTION: This snippet illustrates how to convert the Python `Array` object back to a Tcl-compatible string format using the `tclstr()` function. It shows how to use the converted string in a Tcl command (`array set`) to modify a Tcl array and then utilizes the 'parray' Tcl command to show its content. Also, demonstrates the alternative API `set_array` to update the Tcl array. The warning describes how `array set` behaves with an existing array (update) .\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/tcl/datastructures.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# continuing where we left off...\n\n# calling tclstr() to get a glimpse of the output\ntclstr(array)\n# output: 'a 1 c 3 b 2 zzz 999'\n# note how it's a Tcl [array get <arrayName>] format\n\n# setting it back to Tcl using native commands\ntcl.eval('array set newArray {%s}' % (tclstr(array),))\n\n# checkout the content\ntcl.eval('parray newArray')\n# newArray(a) = 1\n# newArray(b) = 2\n# newArray(c) = 3\n# newArray(zzz) = 999\n\n# of course, you can always call the set_array API\ntcl.set_array('newArray', array)\n```\n\n----------------------------------------\n\nTITLE: Handling Tcl String Substitution Safely with pyATS Interpreter in Python\nDESCRIPTION: This snippet demonstrates proper string substitution techniques when passing Python strings into Tcl commands using the pyATS Interpreter's eval() method. It warns against omitting braces around substituted strings, which leads to argument parsing errors in Tcl, and shows the correct approach by enclosing substituted strings within braces to treat them as single arguments. It includes an example of a failed substitution causing a Tcl error, followed by the correct usage. It also verifies interpreter instance uniqueness between local and global interpreters.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/tcl/tcl.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.tcl import Interpreter\n\ntcl = Interpreter()\n\nimport pyats.tcl\nassert tcl is not pyats.tcl\n\ninfo = 'list information'\n\ntry:\n    tcl.eval('set var %s' % info)\nexcept Exception as e:\n    print(e)\n\n# Correct substitution\n\ntcl.eval('set var {%s}' % info)\n\nassert tcl.eval('set var') == info\n```\n\n----------------------------------------\n\nTITLE: Example Usage of pyATS Shell Command\nDESCRIPTION: A complete terminal session example showing how to start the pyATS shell with a testbed file, examine the loaded devices, and connect to a network device. Demonstrates the full workflow of interactive device testing.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/cli/pyats_shell.rst#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n$ pyats shell --testbed-file tb.yaml\nWelcome to pyATS Interactive Shell\n==================================\nPython 3.7.0 (default, Sep  6 2018, 16:54:40)\n[Clang 10.0.0 (clang-1000.10.25.5)]\n\n>>> from pyats.topology import loader\n>>> testbed = loader.load('tb.yaml')\n-------------------------------------------------------------------------------\n>>> testbed.devices\nTopologyDict({'nx-osv-1': <Device nx-osv-1 at 0x1134f5cc0>, 'csr1000v-1': <Device csr1000v-1 at 0x112af5ba8>})\n>>> testbed.devices['nx-osv-1'].connect()\n[2019-02-11 12:27:54,780] +++ nx-osv-1 logfile /tmp/nx-osv-1-default-20190211T122754780.log +++\n[2019-02-11 12:27:54,781] +++ Unicon plugin nxos +++\n[2019-02-11 12:27:54,784] +++ connection to spawn: telnet 172.25.192.90 17003, id: 4620986912 +++\n[2019-02-11 12:27:54,785] connection to nx-osv-1\n[2019-02-11 12:27:54,787] telnet 172.25.192.90 17003\nTrying 172.25.192.90...\nConnected to asg-virl-ubuntu.cisco.com.\nEscape character is '^]'.\n\nnx-osv-1#\n[2019-02-11 12:27:55,655] +++ initializing handle +++\n[2019-02-11 12:27:55,656] +++ nx-osv-1: executing command 'term length 0' +++\nterm length 0\nnx-osv-1#\n[2019-02-11 12:27:55,824] +++ nx-osv-1: executing command 'term width 511' +++\nterm width 511\nnx-osv-1#\n[2019-02-11 12:27:55,991] +++ nx-osv-1: executing command 'terminal session-timeout 0' +++\nterminal session-timeout 0\nnx-osv-1#\n[2019-02-11 12:27:56,161] +++ nx-osv-1: config +++\nconfig term\nEnter configuration commands, one per line.  End with CNTL/Z.\nnx-osv-1(config)# no logging console\nnx-osv-1(config)# line console\nnx-osv-1(config-console)# exec-timeout 0\nnx-osv-1(config-console)# terminal width 511\nnx-osv-1(config-console)# end\nnx-osv-1#\n\"Escape character is '^]'.\\r\\n\\r\\r\\n\\rnx-osv-1# \"\n>>>\nnow exiting InteractiveConsole...\n```\n\n----------------------------------------\n\nTITLE: Installing SCP Support for FileUtils in Python\nDESCRIPTION: Command to install the required dependencies for SCP protocol support in FileUtils. Requires pip installation of scp and paramiko packages.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/file_transfer_utilities.rst#_snippet_20\n\nLANGUAGE: bash\nCODE:\n```\npip install scp paramiko\n```\n\n----------------------------------------\n\nTITLE: Upgrading PyATS via pip in Bash\nDESCRIPTION: Provides bash commands to upgrade the pyATS library using the pip package installer. Includes separate commands for users installing from the DevNet Community source ('pyats') and internal Cisco developers using an internal source ('ats'). The '--upgrade' flag ensures the latest version is installed.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2022/august.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats\n\n# Cisco Internal Developers\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Defining a Base YAML File for List Extension (YAML)\nDESCRIPTION: Shows a simple YAML file (`a.yaml`) containing a list `[a, b]` under the key path `parameters.sections`. This file serves as the base configuration that will be extended using the `%EXTEND_LIST` key markup in another file.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/yaml_markup.rst#_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\nparameters:\n    sections: [a, b]\n```\n\n----------------------------------------\n\nTITLE: Connecting pyATS Device with Via Argument - Python\nDESCRIPTION: This snippet illustrates the updated syntax for the `via` argument in the `Device.connect()` method. It shows the previous requirement of prefixing alternative connection names with `connections.` and the new, simplified syntax where the prefix is no longer needed.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2015/march.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# before:\ndevice.connect(via = 'connections.alt')\n\n# now:\ndevice.connect(via = 'alt')\n```\n\n----------------------------------------\n\nTITLE: Upgrading PyATS using pip (Cisco Internal)\nDESCRIPTION: This command upgrades the ATS (presumably a distribution of PyATS) package to the latest version using pip. This command is designed for internal Cisco developers. It uses the `--upgrade` flag to update the package and its dependencies.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2022/may.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyATS Framework to v4.1.0\nDESCRIPTION: Commands for upgrading the entire pyATS framework to version 4.1.0. Shows instructions for both DevNet Community users and Cisco Internal developers, including a note to uninstall the deprecated ats.tims package.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2018/mar.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats\n\n# Cisco Internal Developers\n# (remember to remove defunct packages)\nbash$ pip install --upgrade ats\nbash$ pip uninstall ats.tims\n```\n\n----------------------------------------\n\nTITLE: Implementing pyATS WebInteraction for Manual User Input in Python\nDESCRIPTION: This snippet demonstrates how to use the WebInteraction class from pyATS AEtest to pause a test and request manual input from a user through a web form linked via email. It requires pyATS aetest framework and setting up a test case method with the WebInteraction constructor, which takes parameters such as a brief subject, a descriptive message, the calling test section, and an optional timeout. The method .interact() is called to initiate the interaction and wait for user input, enabling cases where automated verification depends on external manual validation.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/results.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats import aetest\nfrom pyats.aetest.utils.interaction import WebInteraction\n\nclass TestcaseOne(aetest.Testcase):\n\n    @aetest.setup\n    def setup(self): pass\n\n    @aetest.test\n    def test_one(self, section):\n        WebInteraction('Brief title for this interaction',\n                       'Message for the user about how to assess this test',\n                       section = section,\n                       timeout = 300\n                      ).interact()\n\n    @aetest.cleanup\n    def cleanup(self): pass\n```\n\n----------------------------------------\n\nTITLE: Sample AEReport ResultsSummary.xml Output\nDESCRIPTION: Provides an example of the ResultsSummary.xml file format generated by AEReport. This file contains a high-level summary of a test job run, including job metadata like name, start/stop times, runtime, submitter, host, archive filename, and counts for different test outcomes (passed, failed, skipped, etc.).\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aereport/index.rst#_snippet_0\n\nLANGUAGE: xml\nCODE:\n```\n<?xml version=\"1.0\" ?>\n<jobSummary archiveFilename=\"atseasy/jeaubin/archive/14-06/run_jb.2014Jun02_10:12:00.zip\" atsTreePath=\"/ws/jeaubin-ott/py\">\n   <jobName>run_jb</jobName>\n   <image>TEMP</image>\n   <aborted>0</aborted>\n   <passed>0</passed>\n   <failed>1</failed>\n   <blocked>0</blocked>\n   <skipped>2</skipped>\n   <errored>0</errored>\n   <unknown>0</unknown>\n   <starttime>2014-06-02T10:12:01</starttime>\n   <stoptime>2014-06-02T10:12:03</stoptime>\n   <runtime>00:00:02</runtime>\n   <testbed/>\n   <release/>\n   <submitter>jeaubin</submitter>\n   <debugProfile>0</debugProfile>\n   <host>jeaubin-dev</host>\n</jobSummary>\n```\n\n----------------------------------------\n\nTITLE: Cloning forked pyATS repository\nDESCRIPTION: Command to clone the forked pyATS repository to your local machine using git. Replace <your_github_username> with your actual GitHub username.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/<your_github_username>/pyats\n```\n\n----------------------------------------\n\nTITLE: Installing SFTP Support for FileUtils in Python\nDESCRIPTION: Command to install the required dependency for SFTP protocol support in FileUtils. Requires pip installation of the paramiko package.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/file_transfer_utilities.rst#_snippet_21\n\nLANGUAGE: bash\nCODE:\n```\npip install paramiko\n```\n\n----------------------------------------\n\nTITLE: Example pyATS Email Configuration (INI)\nDESCRIPTION: This snippet provides a basic example of configuring email settings within a pyATS INI configuration file. It shows how to define an [email] section and set parameters like SMTP host, port, and default domain. This structure is used by pyATS components needing to send emails.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/configuration/index.rst#_snippet_0\n\nLANGUAGE: INI\nCODE:\n```\n# Example\n# -------\n#\n#   pyATS configuration file\n\n[email]\nsmtp.host = mail.google.com\nsmtp.port = 25\ndefault_domain = gmail.com\n```\n\n----------------------------------------\n\nTITLE: Upgrading ats.easypy Module with pip - Bash\nDESCRIPTION: This bash code snippet installs or upgrades the `ats.easypy` module to the latest version using the pip package manager. It utilizes the `--upgrade` flag to ensure the newest version is installed. This resolves any previous installations or dependencies. The output is the result of the pip install command.\n\nDependencies: pip package manager installed.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2017/february.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats.easypy\n```\n\n----------------------------------------\n\nTITLE: pyATS Configuration Example\nDESCRIPTION: Shows an example of a pyats.conf file defining the archive and runinfo directories for easypy.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/cli/pyats_logs.rst#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n[easypy]\nruninfo.archive = /home/myuser/pyATS/archive\nruninfo.directory = /home/myuser/pyATS/runinfo\n```\n\n----------------------------------------\n\nTITLE: Automatic Tcl to Python Typecasting with cast_any and eval (Python)\nDESCRIPTION: Shows how to leverage `tcl.cast_any()` or the `typecast=True` argument in `tcl.eval()` to automatically convert Tcl string return values into appropriate Python objects. This \"best-effort\" casting attempts to guess the target type (e.g., int, float, bool, KeyedList, string) based on the string content, simplifying common data conversions. Requires the `pyats.tcl` library.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/tcl/variables.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n# \n#   casting anything from Tcl by guesstimating\n\nfrom pyats import tcl\n\n# setting a variable in tcl and returning its value to Python also\n# note that Tcl set API always return the content of the variable as well\nresult = tcl.eval('set var %s' % 1)\n\n# assert that number 1 has been turned into string\nassert type(result) is str\n\n# now try typecasting\nresult = tcl.cast_any(result)\n\n# it becomes an int\nassert type(result) is int\n\n# now try the direct evaluation typecasting\ndirect_result = tcl.eval('set var %s' % 1, typecast=True)\n\n# it's an int already\nassert type(direct_result) is int\n```\n\n----------------------------------------\n\nTITLE: Accessing and Comparing WeakList Contents in Python\nDESCRIPTION: The snippet shows how standard list indexing, slicing, and equality checks operate identically on WeakList instances. You can access elements and compare WeakList to a regular list; object identity and equality are preserved as long as the objects exist. Prerequisites are the creation of a WeakList from weak-referenceable objects. Input is an instance of WeakList and a standard list; outputs demonstrate consistent access and comparison results. Limitation: Only supports objects able to be weakly-referenced.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/datastructures/weaklist.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   WeakList access\n\n# assuming we had a list of objects called 'l'\n# create using another list\nwl = WeakList(l)\n\n# everything is the same\nwl[0] is l[0]\n# True\n\nwl == l\n# True\n\nwl[1:2] == l[1:2]\n# True\n```\n\n----------------------------------------\n\nTITLE: Multi-Homed Server IP Selection for File Operations\nDESCRIPTION: This example illustrates using multiple IP addresses for a server in a pyats testbed, where the FileUtils plugin pings included addresses to determine reachability and caches the successful one for subsequent file operations. It is particularly useful for servers with multiple network interfaces.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/file_transfer_utilities.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.utils.fileutils import FileUtils\nfrom pyats.topology import loader\n\n tb = loader.load('tb.yaml')\n\nfutils = FileUtils(testbed=tb)\n futils.copyfile(\n        source = 'file:/device/local/path/to/file',\n        destination = 'ftp://server_alias/remote/path/to/file')\n```\n\n----------------------------------------\n\nTITLE: pyATS Migrate Command Usage\nDESCRIPTION: Displays the basic usage of the pyATS migrate command.  It shows the available subcommand options.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/cli/pyats_migrate.rst#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nUsage:\n  pyats migrate <subcommand> [options]\n\nSubcommands:\n    abstract            Discover what changes must be made to existing test environments to conform\n                        to the new token discovery.\n```\n\n----------------------------------------\n\nTITLE: Importing pyats.async with Compatibility - Python\nDESCRIPTION: Provides a Python code snippet using `importlib` and a `try/except` block to import `pcall` from either `pyats.async` (older versions) or `pyats.async_` (v19.0+). This ensures code compatibility across different pyATS releases, especially when supporting Python 3.7+.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2019/mar.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# try to import pyats.async\n# if it doesn't exist, try to import pyats.async_\n# note that you can't wrap 'from pyats.async import pcall' in a\n# try/except clause, because merely writing async inline as so\n# will cause the import machinery to reject the file.\nimport importlib\n\ntry:\n    pcall = importlib.import_module('pyats.async').pcall\nexcept ImportError:\n    from pyats.async_ import pcall\n```\n\n----------------------------------------\n\nTITLE: Defining pyATS Easypy Plugin Entrypoint Data (Python)\nDESCRIPTION: This Python dictionary illustrates the structure required for plugin metadata when exposed via the `pyats.easypy.plugins` entry point. It specifies the plugin class, its initial enabled state, keyword arguments, module path, and name, allowing Easypy to discover and load the plugin automatically.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/easypy/plugins.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Easypy plugin dict for user-developed plugin\ncustom_plugin = {\n    'plugins': {\n        'CustomPlugin':\n            {'class': CustomPlugin,\n            'enabled': True,\n            'kwargs': {},\n            'module': 'custom.plugin',\n            'name': 'CustomPlugin',\n            },\n        },\n    }\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyATS Using pip in Bash\nDESCRIPTION: This snippet demonstrates commands to upgrade pyATS and ATS through pip for both DevNet Community users and Cisco Internal Developers. The commands require prior installation of pip and suitable permissions. Inputs are optional arguments to pip; outputs are updated module packages. Ensure appropriate environment setup and network access to official repositories.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2021/may.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats\n\n# Cisco Internal Developers\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Creating a banner message with pyATS\nDESCRIPTION: This example demonstrates how to create a banner message using the `pyats.log.utils.banner` function. It shows how to print the banner directly to the console and also how to log it using the standard Python logging module. Customization of the banner width is also included.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/log/utilities.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.log.utils import banner\n\n# printing directly\nmsg = banner('a banner message')\nprint(msg)\nprint(banner('aReallyLongMessageThatIsLongerThanMaxWidthIsChoppedUp',\n             width = 40))\n\n# printing to log\nimport logging\nlogger = logging.getLogger(__name__)\n\nlogger.info(banner('an informational message banner'))\nlogger.error(banner('an error message\\nwith newline'))\n\n# Changing margin\nmsg = banner('a message', v_margin='!', h_margin='&')\nprint(msg)\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyATS using pip in Bash\nDESCRIPTION: This Bash code snippet demonstrates upgrade commands for pyATS modules using pip. The first command upgrades pyATS via the public PyPI repository for DevNet Community users, while the second is for Cisco internal developers upgrading the 'ats' package. Required: Python and pip must be installed. Expected input is the correct command in a shell terminal; output is the standard pip installation or upgrade logs. No explicit output files are generated. Internet access is required and the user must have the appropriate credentials if behind enterprise proxies.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2020/dec.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats\n\n# Cisco Internal Developers\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Installing/Uninstalling pyATS Package with Cisco Dependencies\nDESCRIPTION: This command uninstalls deprecated packages, and installs new pyATS version and required cisco-shared packages. This ensures proper setup of the latest pyATS environment with necessary dependencies.  This involves both removing legacy packages and installing newer versions and their cisco-shared dependencies.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2016/may.rst#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n# remove deprecated packages\nbash$ pip uninstall ats.clean ats.bringup ats.tgn\n\n# install new pyATS version\nbash$ pip install --upgrade ats\n\n# install new cisco-shared packages\nbash$ pip install csccon tclclean dyntopo hltapi\n```\n\n----------------------------------------\n\nTITLE: Upgrading Pyats using pip - Bash\nDESCRIPTION: This snippet provides the bash commands required to upgrade the Pyats framework to the latest version (v23.9) using pip. The commands support two user groups: the DevNet Community should upgrade using the 'pyats' package, while Cisco internal developers upgrade using the 'ats' package. The prerequisite is an existing Python environment with pip installed. The expected output is an upgraded installation of the Pyats or ATS package, with dependencies resolved by pip. Constraints include the need for appropriate permissions and network access to the package repository.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2023/september.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats\n\n# Cisco Internal Developers\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Initializing and Using Native Tcl Interpreter in Python with Tkinter\nDESCRIPTION: Demonstrates how to import the Tcl interpreter from the tkinter module, create an instance of the Tcl interpreter embedded in the Python process, and execute simple Tcl commands via the eval method. It shows setting Tcl variables and evaluating Tcl expressions within Python. Dependencies include the standard tkinter module compiled with Tcl support. The input is Python code strings representing Tcl commands, and output is the Tcl evaluation results.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/tcl/introduction.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# import the Tcl object\nfrom tkinter import Tcl\n\n# create a new Tcl interpreter\ntcl = Tcl()\n\n# example Tcl calls\ntcl.eval('set myTclVariable {%s}' % 1)\n```\n\n----------------------------------------\n\nTITLE: Upgrading PyATS via Pip (DevNet Community) - Bash\nDESCRIPTION: Command to upgrade the PyATS package for users accessing it through the DevNet Community channel using the pip package manager. It ensures that the latest version of the pyats package is installed.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2023/may.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install --upgrade pyats\n```\n\n----------------------------------------\n\nTITLE: Annotated example output of test execution\nDESCRIPTION: This section shows a textual representation of test case execution results, including setup, test phases, and their individual statuses. It provides context for understanding how test sections and sub-sections are structured and reported in pyATS.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/loop.rst#_snippet_13\n\nLANGUAGE: Markdown\nCODE:\n```\n# output of this testcase\n#   current section: test_one\n#   current section: test_two\n#\n#  SECTIONS/TESTCASES                                                RESULT   \n# --------------------------------------------------------------------------\n#  .\n#  `-- Testcase                                                      PASSED\n#      |-- setup                                                     PASSED\n#      |-- test_one                                                  PASSED\n#      `-- test_two                                                  PASSED\n```\n\n----------------------------------------\n\nTITLE: Tracking and Reading History in pyATS\nDESCRIPTION: This code demonstrates how to track and read history using the pyATS Tcl Interpreter and History classes. It initializes the Interpreter, makes Tcl calls, and then filters and prints the history entries with their timestamps and API calls. It showcases the basic usage of the History class to monitor Tcl command execution within pyATS.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/tcl/history.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pyats.tcl import Interpreter, History\n    \n    tcl = Interpreter()\n    \n    # note the history attribute\n    assert type(tcl.history) is History\n\n    # make some tcl calls\n    tcl.eval('set testVar 1')\n    tcl.eval('set testVar 2')\n\n    # let's take a look at the history\n    tcl.history.filter()\n    # output:\n    #   deque(\n    #    [<HistoryEntry '2014-06-04T23:30:12.939354: set testVar 1' at ...>,\n    #     <HistoryEntry '2014-06-04T23:30:18.665275: set testVar 2' at ...>,\n    #     maxlen=9999])\n\n    # print it in a more usable fashion:\n    for i in tcl.history.filter(): \n        print(i.timestamp, '-', i.api)\n```\n\n----------------------------------------\n\nTITLE: Installing pyATS Package\nDESCRIPTION: This command installs or upgrades the specified pyATS package using pip. The `--upgrade` flag ensures that the latest version is installed. This is a standard installation command for pyATS packages.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2016/may.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats.kleenex\n```\n\n----------------------------------------\n\nTITLE: Installing pyATS Package\nDESCRIPTION: This command installs or upgrades the specified pyATS package using pip. The `--upgrade` flag ensures that the latest version is installed. This is a standard installation command for pyATS packages.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2016/may.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats.async\n```\n\n----------------------------------------\n\nTITLE: Installing pyATS Package\nDESCRIPTION: This command installs or upgrades the specified pyATS package using pip. The `--upgrade` flag ensures that the latest version is installed. This is a standard installation command for pyATS packages.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2016/may.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats.easypy\n```\n\n----------------------------------------\n\nTITLE: Installing pyATS Topology Module\nDESCRIPTION: Command for installing the topology module from PyPI server using pip.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/topology/introduction.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install pyats.topology\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyATS Framework using pip (Bash)\nDESCRIPTION: Provides the standard command to upgrade the core pyATS framework and potentially all installed modules using the pip package manager in a bash shell. This instruction is applicable for upgrading from version v2.0.1+ onwards. Requires Python and pip installed and configured.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2015/october.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyATS with pip (DevNet Community) - bash\nDESCRIPTION: This command line snippet provides instructions for upgrading the pyATS framework for users accessing it through the public DevNet channels. It uses the pip package manager to fetch and install the latest version of the `pyats` package. This ensures you are running the most recent release, like v22.6 mentioned in the notes.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2022/june.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyATS with pip (Cisco Internal) - bash\nDESCRIPTION: This command is for Cisco internal developers who typically install pyATS via the 'ats' package alias. It uses pip to upgrade this specific package, ensuring internal users also receive the latest framework updates and features. This is the standard upgrade method within the Cisco internal environment.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2022/june.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Cisco Internal Developers\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Creating WeakList Instances in Python\nDESCRIPTION: This snippet demonstrates two ways of constructing a WeakList: by passing an existing list of objects or an iterable of objects to the WeakList constructor. It requires pyats.datastructures and an input collection of objects that support weak referencing. The resulting WeakList instance acts like a standard list but automatically removes objects upon their garbage collection. Limitation: Only suitable for objects that can be weakly-referenced; primitives like int or str are not allowed.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/datastructures/weaklist.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   WeakList creation\n\nfrom pyats.datastructures import WeakList\n\n# assuming we had a list of objects called 'l'\n\n# create using another list\nwl = WeakList(l)\n\n# create using an iterable\nwl = WeakList(iter(l))\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyATS v22.7 for DevNet Community and Cisco Internal Developers\nDESCRIPTION: Instructions for upgrading pyATS to version 22.7. Two separate commands are provided - one for DevNet Community users using the public 'pyats' package, and another for Cisco Internal Developers using the internal 'ats' package.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2022/july.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats\n\n# Cisco Internal Developers\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyATS Framework in Bash\nDESCRIPTION: Commands for upgrading the pyATS framework to version 21.1. The first command is for DevNet Community users, while the second is for Cisco Internal Developers. Both commands use pip to perform the upgrade.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2021/january.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats\n\n# Cisco Internal Developers\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Installing pyATS - Bash\nDESCRIPTION: This snippet provides instructions for upgrading the pyATS package using pip. The commands differ based on the user's environment (DevNet Community or Cisco Internal Developers).  It upgrades pyATS and any of its dependencies.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2021/february.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats\n\n# Cisco Internal Developers\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyats.kleenex and pyats.easypy (DevNet)\nDESCRIPTION: This command upgrades both pyats.kleenex and pyats.easypy modules using pip for DevNet community users. It ensures that the latest versions are installed, providing access to new features and bug fixes across these modules.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2019/jan.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade pyats.kleenex pyats.easypy\n```\n\n----------------------------------------\n\nTITLE: Upgrading Specific pyATS Modules via pip - Bash\nDESCRIPTION: Provides pip commands to upgrade individual pyATS modules to v19.0.1. This requires pip installed and is useful for targeted updates rather than upgrading the entire framework. Separate commands are shown for DevNet community and Cisco internal users.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2019/mar.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats.aetest pyats.easypy pyats.kleenex pyats.log pyats.robot pyats.utils\n```\n\nLANGUAGE: bash\nCODE:\n```\n# Cisco Internal Developers\nbash$ pip install --upgrade ats.aetest ats.easypy ats.kleenex ats.log ats.robot ats.utils\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyATS easypy Module using pip - Bash\nDESCRIPTION: Provides bash commands to upgrade the pyats.easypy (or ats.easypy) module using the pip package manager. It includes separate commands for DevNet community users and Cisco internal developers. Requires pip to be installed and configured.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2018/july.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats.easypy\n\n# Cisco Internal Developers\nbash$ pip install --upgrade ats.easypy\n```\n\n----------------------------------------\n\nTITLE: Logging Banner Usage with ats.atslog.utils - Python\nDESCRIPTION: Demonstrates the use of the banner API from the ats.atslog.utils module to generate pre-formatted banner text for logging. Requires the ats.atslog.utils package and Python's logging module to be installed. The logger.info call outputs the formatted banner, but it no longer handles logging within the banner function itself. Input is a text string to display in the log, output is logging the formatted banner message. Ensure logging is configured before invoking this snippet.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2014/december.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport logging\n\nfrom ats.atslog.utils import banner\n\nlogger = logging.getLogger()\n\n# printing a banner\nlogger.info(banner('this is a banner text'))\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Weak Reference Deletion and Garbage Collection in pyATS Topology - Python\nDESCRIPTION: This snippet shows how weak references in pyATS topology impact object lifecycle and garbage collection. It loads a sample topology file with devices and links, then removes a device and illustrates that associated interfaces and links get dereferenced properly, demonstrating how weak referencing supports automatic cleanup. The snippet warns about references held externally preventing cleanup.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/topology/usage.rst#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   weak ref deletions\n\n# using the sample topology file from\nimport os\nfrom pyats import topology\n\ntestbedfile = os.path.join(os.path.dirname(topology.__file__),\n                           'sampleTestbed.yaml')\ntestbed = topology.loader.load(testbedfile)\n\n# let's see how many devices and links we started with\ntestbed.devices\n# AttrDict({'ott-tb1-n7k4': <Device ott-tb1-n7k4 at 0xf73f712c>,\n#           'ott-tb1-n7k5': <Device ott-tb1-n7k5 at 0xf765ef0c>})\ntestbed.links\n# {<Link rtr1-rtr2-2 at 0xf73fa58c>,\n#  <Link ethernet-2 at 0xf73f8fac>,\n#  <Link ethernet-1 at 0xf73f8b6c>,\n#  <Link rtr1-rtr2-1 at 0xf73fa4ec>}\n\n# now remove a device\ntestbed.devices.pop('ott-tb1-n7k4')\n\n# look at devices and lists again in the testbed. it's all gone\ntestbed.devices\n# AttrDict({'ott-tb1-n7k5': <Device ott-tb1-n7k5 at 0xf765ef0c>})\ntestbed.links\n# {<Link rtr1-rtr2-2 at 0xf73fa58c>,\n#  <Link rtr1-rtr2-1 at 0xf73fa4ec>}\n```\n\n----------------------------------------\n\nTITLE: Typical Kleenex Logging Directory Structure in Text Format\nDESCRIPTION: Describes the standard directory and file layout generated by Kleenex during a clean operation. The structure includes a base directory containing time-stamped subdirectories with overall logs (Kleenex.log), per-device logs (Kleenex.device_x.log), and environment dump files (env.txt). This organization supports troubleshooting and result tracking for each cleaning execution.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/kleenex/usages.rst#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nbase                                      -> cwd or directory specified\n|                                         -> via -logdir CLI argument\n|-- Kleenex_2019Mar04_10:41:19.026530     -> kleenex logging directory\n.   |-- Kleenex.log                       -> Top level clean log\n.   |-- Kleenex.device_1.log              -> Device-specific clean log\n.   |-- Kleenex.device_2.log              -> Device-specific clean log\n.   |-- Kleenex.device_3.log              -> Device-specific clean log\n    |-- env.txt                           -> environment debug information\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyATS Topology via pip for DevNet and Cisco Developers - Bash\nDESCRIPTION: This bash snippet demonstrates the upgrade steps for the 'pyats.topology' Python module using pip. For DevNet Community members, 'pyats.topology' is used directly; Cisco employees use the 'ats.topology' package name internally. Prerequisites include an installed pip and the ability to access the package repository. Executes upgrade in place with no required input other than shell access.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2020/feb.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats.topology\n\n# Cisco Internal Developers\nbash$ pip install --upgrade ats.topology\n```\n\n----------------------------------------\n\nTITLE: Upgrading ats.utils using pip - Bash\nDESCRIPTION: This bash snippet demonstrates how to upgrade the ats.utils module to the latest version using pip. It requires Python and pip, and internet access to Python's package repositories. By running this command, the user will fetch and install the current version (such as v3.3.1), overwriting any previous installations. Run this in a shell, replacing 'bash$' with your system prompt if necessary.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2017/july.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats.utils\n```\n\n----------------------------------------\n\nTITLE: Upgrade 'ats.aetest' module via pip\nDESCRIPTION: This command upgrades the 'ats.aetest' module to its latest version using pip, ensuring compatibility with recent features and bug fixes. It requires Python's pip and should be executed in a command-line environment. This helps maintain up-to-date testing capabilities within the automation suite.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2017/nov.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats.aetest\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyats.easypy (bash)\nDESCRIPTION: This bash script upgrades the `pyats.easypy` module using `pip`.  It checks the current PyATS version and upgrades it to the latest available version. Prerequisites:  `pip` installed and accessible in the shell environment.  Expected output: Successful execution should install the new version of `pyats.easypy`. It presents the user with an upgraded version of the specified PyATS library.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2018/sep.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\n    bash$ pip install --upgrade pyats.easypy\n```\n\nLANGUAGE: bash\nCODE:\n```\n# Cisco Internal Developers\n    bash$ pip install --upgrade ats.easypy\n```\n\n----------------------------------------\n\nTITLE: Upgrading ats.aereport and ats.utils modules using pip\nDESCRIPTION: Commands to upgrade both ats.aereport to version 3.3.2 and ats.utils to version 3.3.2 using pip package manager.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2017/aug.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats.aereport\nbash$ pip install --upgrade ats.utils\n```\n\n----------------------------------------\n\nTITLE: Installing Multiple pyATS Packages\nDESCRIPTION: This command upgrades multiple specified pyATS packages using pip. The `--upgrade` flag ensures that the latest versions of all packages are installed simultaneously.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2016/may.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats.aetest ats.async\n```\n\n----------------------------------------\n\nTITLE: Upgrading ats.utils/pyats.utils using pip (Bash)\nDESCRIPTION: Provides Bash commands using pip to upgrade the ats.utils module for Cisco Internal Developers and the pyats.utils module for the DevNet Community. This update corresponds to version v4.1.4 released on May 24, 2018.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2018/may.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats.utils\n\n# Cisco Internal Developers\nbash$ pip install --upgrade ats.utils\n```\n\n----------------------------------------\n\nTITLE: Command Usage Pattern for pyATS Version Management (Text)\nDESCRIPTION: This snippet outlines the general command syntax for managing pyATS versions, including subcommands for checking and updating, along with common options such as help, verbosity, and quiet mode. It provides the command structure example used in the CLI.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/cli/pyats_version.rst#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n  Usage:\n    pyats version <subcommand> [options]\n\n  Subcommands:\n      check               display currently installed pyATS version\n      update              update current pyATS installation to another version\n\n  General Options:\n    -h, --help            Show help\n    -v, --verbose         Give more output, additive up to 3 times.\n    -q, --quiet           Give less output, additive up to 3 times, corresponding to WARNING, ERROR,\n                          and CRITICAL logging levels\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyats.datastructures Package with pip (May 7, 2020)\nDESCRIPTION: This snippet describes how to upgrade the pyats.datastructures module using pip. It includes separate commands tailored for DevNet Community and Cisco internal developers to update their installations.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2020/may.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats.datastructures\n\n# Cisco Internal Developers\nbash$ pip install --upgrade ats.datastructures\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyats.log Package with pip (May 13, 2020)\nDESCRIPTION: This snippet shows how to upgrade the pyats.log module using pip. It provides distinct commands for DevNet Community and Cisco internal users, allowing them to update to the latest version.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2020/may.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats.log\n\n# Cisco Internal Developers\nbash$ pip install --upgrade ats.log\n```\n\n----------------------------------------\n\nTITLE: CommonDiscovery Implementation Structure\nDESCRIPTION: Shows the implementation structure of the CommonDiscovery class. This class is responsible for discovering subsections within common sections like CommonSetup and CommonCleanup.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/control.rst#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nclass CommonDiscovery():\n    def __init__(self, target):\n        self.target = target\n\n    def __iter__(self):\n        # some default logic written here\n        ...\n```\n\n----------------------------------------\n\nTITLE: Visual Representation of Easypy Multiprocessing Tasks Using Text Diagram\nDESCRIPTION: Provides an ASCII art text diagram illustrating the multiprocessing process model used by Easypy. It depicts the main Easypy process forking a Reporter Server and multiple Task processes, indicating their inter-relationships and process IDs (pids). This supports understanding of multiprocessing architecture and process isolation within Easypy. The snippet is purely representational without dependencies or input/output.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/async/integration.rst#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n+--------------------+    fork     +----------------------------+\n| easypy  (pid 1000) |-------------| Reporter Server (pid 1001) |\n+--------------------+             +----------------------------+\n           |\n           | fork          +-------------------------+\n           +---------------| Task Task-1 (pid 1002) |\n           |               +-------------------------+\n           |\n           | fork          +-------------------------+\n           +---------------| Task Task-2 (pid 1003) |\n           |               +-------------------------+\n          etc.\n```\n\n----------------------------------------\n\nTITLE: Upgrading PyATS easypy module for April 20, 2018 release\nDESCRIPTION: Bash commands to upgrade the pyats.easypy package to version 4.1.3. Separate commands are provided for DevNet Community and Cisco Internal Developers.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2018/apr.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats.easypy\n\n# Cisco Internal Developers\nbash$ pip install --upgrade ats.easypy\n```\n\n----------------------------------------\n\nTITLE: Requesting Unsupported Operation Example with TFTP in Python\nDESCRIPTION: Example demonstrating an attempt to use an operation (checkfile) that is not supported by the TFTP protocol, which will throw an exception.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/file_transfer_utilities.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfutils.checkfile(target = 'tftp://myserver.domain.com/remote/path/to/file')\n```\n\n----------------------------------------\n\nTITLE: Upgrading ats.easypy Module Using pip\nDESCRIPTION: Command line instruction for upgrading the ats.easypy module to version 3.3.10 using pip package manager. This upgrade fixes a bug related to Jenkins integration when using the -xunit argument.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2017/dec.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats.easypy\n```\n\n----------------------------------------\n\nTITLE: Upgrading Pyats v22.1 using pip\nDESCRIPTION: Instructions for upgrading to Pyats v22.1 using pip. Two separate commands are provided for DevNet Community users and Cisco Internal Developers.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2022/january.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats\n\n# Cisco Internal Developers\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Upgrading ats.aereport Module Using pip - Bash\nDESCRIPTION: This Bash command upgrades the ats.aereport module of pyATS via pip. It is intended to update the reporting functionality to the latest available version. Prerequisites: pip must be installed and configured. The command should be run in a terminal. Input: None. Output: Progress and result of the upgrade. Limitations: Requires network connectivity and permissions to install Python packages.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2016/november.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats.aereport\n```\n\n----------------------------------------\n\nTITLE: Upgrading multiple pyATS modules (bash)\nDESCRIPTION: This snippet shows the commands to upgrade specific pyATS modules like 'ats.easypy', 'ats.tims', and 'ats.aereport' using pip. This updates these individual components to their latest versions as released on a specific date.\nDependencies: Python environment with pip installed, internet access.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2017/may.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats.easypy\nbash$ pip install --upgrade ats.tims\nbash$ pip install --upgrade ats.aereport\n```\n\n----------------------------------------\n\nTITLE: Handling Tcl Special Character Procedure Names in pyATS Tcl Interpreter Python\nDESCRIPTION: This snippet exposes limitations of calling Tcl procedures and namespaces from Python via the Q magic function when names contain characters invalid in Python (e.g., colons, dashes, slashes, or being reserved words). It shows failed attempts to access such procedures using object notation and explains that these must be invoked using tcl.eval instead. Intended for users facing interoperability or syntax edge cases.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/tcl/q.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   some example that cannot be called with Q\n\nfrom pyats import tcl\n\ntcl.eval('''\n    proc procedureWith:Colon {} {}\n\n    proc procedureWith-Dash {} {}\n\n    namespace eval namespaceWith/\\Slash {} {}\n\n    # the null procedure\n    proc {} {} {}\n''')\n\n# try to call them\ntcl.q.procedureWith:Colon()\n#   File \"<stdin>\", line 1\n#     tcl.q.procedureWith:Colon()\n#                        ^\n# SyntaxError: invalid syntax\n\ntcl.q.procedureWith:Colon \n# Traceback (most recent call last):\n#   File \"<stdin>\", line 1, in <module>\n# NameError: name 'Dash' is not defined\n\ntcl.namespaceWith/\\Slash\n#   File \"<stdin>\", line 1\n#     tcl.namespaceWith/\\Slash\n#                            ^\n# SyntaxError: unexpected character after line continuation character\n\n# and I honestly don't know how to call the null function in Python\n# ...\n```\n\n----------------------------------------\n\nTITLE: Upgrading Multiple pyATS Modules Using pip in Bash\nDESCRIPTION: This bash command performs simultaneous upgrades of the ats.kleenex, ats.utils, and ats.easypy Python modules using pip. Intended for users who need to update all relevant pyATS modules together after a coordinated release. Requires Python, pip, and a compatible system environment; upon completion, all listed modules are updated to their latest versions.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2016/june.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats.kleenex ats.utils ats.easypy\n```\n\n----------------------------------------\n\nTITLE: Cloning a specific pyATS package without development mode\nDESCRIPTION: This example uses the `pyats develop` command with the `--clone-only` flag. This option instructs the command to clone the repository for the specified package (`pyats.config`) but to skip the subsequent step of putting the package into development mode (running 'make develop').\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/cli/pyats_develop.rst#_snippet_5\n\nLANGUAGE: text\nCODE:\n```\npyats develop pyats.config --clone-only\n```\n\n----------------------------------------\n\nTITLE: Renaming id Field to uid\nDESCRIPTION: This code provides an example of how to update the `id` field to `uid` in AEtest for backward compatibility. The purpose is to show how to align code with the new unique id convention.  This is an example of handling deprecated fields and their updated equivalents.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2016/may.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n\nclass Testcase(aetest.Testcase):\n\n    # old style\n    id = 'alt_id_of_testcase'\n\n    # new style\n    uid = 'alt_id_of_testcase'\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyATS AEtest Package Using pip in Bash\nDESCRIPTION: This snippet demonstrates the bash command used to upgrade the pyATS AEtest package via pip. It assumes pip is already installed and configured. The command `pip install --upgrade ats` upgrades pyATS to the latest available version. This step is necessary for users upgrading from version 2.0.1 or later of pyATS AEtest.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2015/july.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Upgrading PyATS Log Module in Bash\nDESCRIPTION: Commands for upgrading the pyats.log module to version 19.12.1. Includes instructions for both DevNet Community users and Cisco Internal Developers.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2020/jan.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\nbash$ pip install --upgrade pyats.log\n\n# Cisco Internal Developers\nbash$ pip install --upgrade ats.log\n```\n\n----------------------------------------\n\nTITLE: Miscellaneous Framework Utilities and Documentation Versioning\nDESCRIPTION: This snippet highlights general utilities and updates, including versioned documentation, support platform (PieStack), internal warning systems, and install script enhancements to alert users about Python version compatibility and default paths.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2016/may.rst#_snippet_14\n\nLANGUAGE: Python\nCODE:\n```\n  - pyATS documentation is now versioned, you can now see old releases and\n    their documentations\n\n  - `PieStack`_ is now officially rolled out as the support platform\n\n  - introduced a new internal warning (specifically, ``DeprecationWarning``)\n    system\n\n  - install script now displays warnings if you are installing Python-2 versions\n    of pyATS\n\n  - install script now hints about the default ATS tree ``/auto/pysw``\n```\n\n----------------------------------------\n\nTITLE: Kleenex Orchestration Standard Model and Topology Enhancements\nDESCRIPTION: This snippet covers the new clean/testbed orchestration model introduced by Kleenex, including moving content into the ats.kleenex package, generating warnings for missing cleaners, and deprecating old modules. It discusses improvements like topology name handling, device key deprecation, and logging scope adjustments.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2016/may.rst#_snippet_11\n\nLANGUAGE: Python\nCODE:\n```\n  - Introducing a new clean / testbed orchestration standard model\n    and base classes.\n\n  - A warning is generated if devices are specified without a cleaner class.\n    The user may choose to ignore these warnings if they are bringing up\n    a dynamic topology of virtual devices.\n\n  - Moved all content from ``ats.bringup`` into ``ats.kleenex``.\n    ``ats.bringup`` package is scheduled for deprecation and attempts to\n    include it now cause warnings.\n\n  - Moved XR-UT orchestrator to cisco_shared ``dyntopo`` package.\n\n    - The ``bringup`` decoupled tool has been scheduled to be deprecated.\n\n    - The ``dyntopo`` cisco_shared package offers an ``xrutbringup``\n      decoupled tool that provides equivalent functionality.\n\n    - The ``-orchestrator`` parameter no longer shows up in the decoupled\n      tools' ``-help`` display (as the orchestrator is now hardcoded for\n      each decoupled bringup tool).\n\n  - If no orchestrator is specified, a warning is thrown and the\n    XR-UT orchestrator is selected by default.  In an upcoming release\n    this behavior will be removed and orchestrator specification will\n    become mandatory.\n\n  - ``-testbed_file`` easypy argument is now used to specify testbeds\n    containing only actual devices.\n\n  - ``-logical_testbed_file`` easypy argument is used to specify\n    testbeds containing actual or logical devices.\n\n  - Bringup reserves the right to create its own topology name.\n    Now when the user specifies a value under ``topology/name`` in their\n    logical testbed file, this value is moved under ``topology/alias``.\n    If the user specifies both ``topology/name`` and ``topology/alias``\n    a warning is generated that states ``topology/name`` is ignored.\n\n  - Deprecated ``is_logical`` device key in the logical testbed file.\n\n  - When ``-clean_scope=job`` is specified via the easypy command line,\n    bringup no longer creates a separate file ``JobLog.bringup``.\n    Instead, all bringup logs are now included in the JobLog.\n\n  - Renamed the ``-bringup_no_mail`` option on the decoupled bringup tool\n    to ``-no_mail`` to better align with the easypy option of the same name.\n\n  - For one release only, the ``-testbed_file`` parameter, if it points to\n    a file that contains logical routers, is treated like the\n    ``-logical_testbed_file`` parameter, and a warning is raised.\n\n  - Introduced support for bringup ``-clean_file`` migration.  This support\n    will be removed in the next release.\n\n  - Added support for \"empty bringup\", where bringup is attempted without\n    any logical devices, but a static ``-testbed_file`` is provided.\n    This was done for bringup/clean integration.\n\n  - The topology is no longer launched and torn down\n    if no logical devices are specified.\n    This allows the kleenex tool to run more efficiently.\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyats.utils and pyats.easypy (bash)\nDESCRIPTION: This bash script upgrades the `pyats.utils` and `pyats.easypy` modules using `pip`. It upgrades these modules to their latest versions. Prerequisites: `pip` should be installed and available in the shell environment. Expected output: The script will install upgraded version of the specified PyATS libraries. It presents the user with upgraded versions of `pyats.utils` and `pyats.easypy`.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2018/sep.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# DevNet Community\n    bash$ pip install --upgrade pyats.utils pyats.easypy\n```\n\nLANGUAGE: bash\nCODE:\n```\n# Cisco Internal Developers\n    bash$ pip install --upgrade ats.utils ats.easypy\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyATS with pip - Bash\nDESCRIPTION: Demonstrates how to upgrade the pyATS package directly via pip for users running v2.0.1 and above. Requires an already installed Python environment and access to the pip tool. The command will update pyATS to the latest available version in your Python environment. No parameters are needed and output is the in-place update of the ats package. Constraints: Only works for pip-based environments with internet connectivity or access to required repositories.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2015/june.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats\n```\n\n----------------------------------------\n\nTITLE: Upgrading pyATS Cisco Module via pip - bash\nDESCRIPTION: Explains how to upgrade the `ats.cisco` module using the pip package manager. This command is specifically for Cisco Internal Developers accessing internal repositories. Requires pip to be installed and configured.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2019/aug.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Cisco Internal Developers\nbash$ pip install --upgrade ats.cisco\n```\n\n----------------------------------------\n\nTITLE: Upgrading ats.utils Module Using Bash\nDESCRIPTION: Provides the bash command to upgrade the ats.utils module to the latest version using pip. This snippet facilitates updating the utils package, ensuring that default HTML templates are included and addressing prior missing data issues.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2016/october.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats.utils\n```\n\n----------------------------------------\n\nTITLE: Serving pyATS documentation locally\nDESCRIPTION: Command to serve the built documentation locally so you can view it in your browser before submitting changes.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/README.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nmake serve\n```\n\n----------------------------------------\n\nTITLE: Upgrading ATS Modules Using Bash pip\nDESCRIPTION: This bash code snippet provides the command to upgrade specified ATS modules ('ats.kleenex' and 'ats.easypy') using pip. It requires that Python and pip are installed on the system. The code is expected to be run in a shell environment and upgrades the installed module packages to the latest specified versions.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2017/june.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats.kleenex ats.easypy\n```\n\n----------------------------------------\n\nTITLE: Upgrading ats.utils to v3.3.3 using pip\nDESCRIPTION: Command to upgrade the ats.utils module to version 3.3.3 using pip package manager.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2017/aug.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip install --upgrade ats.utils\n```\n\n----------------------------------------\n\nTITLE: Enhancing log-banner functionalities in atslog module\nDESCRIPTION: This snippet notes the extension of ``atslog.banner`` with new features, enabling advanced banner logging capabilities. The features are documented under a reference ``log-banner``. Implementation involves modifying the ``atslog`` module to support richer banner outputs, improving user visibility and debugging.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2015/june.rst#_snippet_16\n\nLANGUAGE: Python\nCODE:\n```\natslog.banner has new functionalities. See :ref:`log-banner`\n```\n\n----------------------------------------\n\nTITLE: Invoking Kleenex Cleaner Internally (Python)\nDESCRIPTION: This Python pseudo-code illustrates the internal process by which the Kleenex engine handles a configured cleaner class. It shows the steps of importing the class based on the module and class name specified in the clean file, instantiating it using the provided parameters (excluding devices/groups consumed by the engine), and finally calling the cleaner's `clean()` method, passing the relevant device object from the loaded testbed.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/kleenex/clean.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# -----------------------------------------------------\n# how Kleenex engine internally invokes cleaner classes\n# (pseudo code for demonstrating internals only)\n\n# the class is imported first, based on its class name and module info\nfrom mollymaid.cleaners import AwesomeClean\n\n# then the class is instantiated using kwargs from the clean file\n# definition (devices/groups keys are ignored: they are consumed by the\n# engine instead)\ncleaner = AwesomeClean(timeout = 100,\n                           loglevel = 'INFO',\n                           retry = 3)\n\n# finally, assuming that the testbed is already loaded\n# this clean class is invoked to do cleaning on that device\ncleaner.clean(device = testbed.devices['example-device'])\n```\n\n----------------------------------------\n\nTITLE: Defining and Accessing Function Parameters in Python\nDESCRIPTION: This example demonstrates how to define and access function parameters in Python. The function `add_to_c` takes two parameters, `a` and `b`, and adds them to a static value `c`. The example also shows how to call the function with arguments and how these arguments are mapped to the function parameters.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/parameters.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   parameters & arguments\n\n# static base value\nc = 100\n\n# within the scope of this function definition\n# \"a\" and \"b\" are considered its function parameters\n# and accessible within the function as variables a and b\n# \"c\" is a static data value.\ndef add_to_c(a, b):\n    print(\"a=\", a)\n    print(\"b=\", b)\n    return a+b+c\n\n# when calling this function\n# 1 and 2 are called arguments to this function\n# which is mapped to function parameters positionally as\n# a=1, b=2 within the actual function\nadd_to_c(1, 2)\n# 103\n```\n\n----------------------------------------\n\nTITLE: Searching for ats.aetest using pip\nDESCRIPTION: This command searches the PyPI server for the ats.aetest package using pip search.  It allows users to find information about the package and its availability.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2016/july.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nbash$ pip search ats.aetest\n```\n\n----------------------------------------\n\nTITLE: Installing Specific pyATS Version via pyats-install - Bash\nDESCRIPTION: Shows how to use the 'pyats-install' script to install a specific pyATS version, or the latest by default. Requires access to the '/auto/pyats/bin/pyats-install' script, typically available in Cisco automation environments. The '--version' parameter specifies the desired release; omitting it defaults to the newest. Output is a configured and upgraded pyATS environment for the chosen version.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2015/june.rst#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nbash$ /auto/pyats/bin/pyats-install --version=\"1.0.4\"\n\n# installing latest (default behavior)\nbash$ /auto/pyats/bin/pyats-install\n```\n\n----------------------------------------\n\nTITLE: Comprehensive pyATS Configuration Options (INI)\nDESCRIPTION: This extensive snippet documents the various configuration options available across different pyATS components, organized into sections like [email], [logs], [easypy], [aetest], [report], [timestamp], [topology], [interaction], [filetransfer], and [secrets]. Each option includes a placeholder showing the expected format and a brief description in a comment. It serves as a reference for customizing pyATS behavior.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/configuration/index.rst#_snippet_1\n\nLANGUAGE: INI\nCODE:\n```\n# Configurable Fields\n# -------------------\n\n# configuration related to sending emails\n[email]\n\n# smtp host url/ip and port\nsmtp.host = <value>\nsmtp.port = <port>\n\n# smtp to use TLS/ssl\nsmtp.ssl = <True/False>\n\n# smtp connection timeout (default to 30s)\nsmtp.timeout = <timeout in seconds>\n\n# smtp username/password for authentication\nsmtp.username = <username>\nsmtp.password = <password>\n\n# default domain name\n# (use this to enable setting recipients to just ID without @domain.com)\ndefault_domain = <domain.com>\n\n# subject to use for report email\n# formatted with the easypy runtime object before sending\nsubject = <email subject template>\n\n# configuration related to log viewing\n[logs]\nserver.host = <host interface/ip to start log server on>\nserver.port = <port to start server on>\nbrowser = <path to browser executable to open>\n\n# configuration related to easypy execution\n[easypy]\n\n# archive storage directory\n# (use this to specify where you want pyATS archive zip file to be saved)\nruninfo.archive = <path>\n\n# runinfo directory\n# (specifies the location where the runtime dir is created during execution)\nruninfo.directory = <path to runinfo folder>\n\n# configuration related to aetest\n[aetest]\n\n# Value of steps continue_ when not explicitly set. Default is False.\n# Steps continue_ determines whether a section should continue execution\n# after a step fails, or immediately exit that section.\nsteps.continue = <True/False>\n\n# Enable/disable banners around \"Starting Section\" log entries\nlogging.banners = <True/False>\n\n# Enable/disable reporting for all processors. Using the report or noreport\n# decorators takes priority over this option.\nprocessors.report = <True/False>\n\n# configuration related to the report\n[report]\n# Format of the report file generated at the end of execution.\n# Default is JSON.\nformat = <json/yaml>\n# Collect git info, default is True.\ngit_info = <True/False>\n# section reporting, default is \"SubSection SetupSection CleanupSection TestSection\"\nsections = SubSection SetupSection CleanupSection TestSection\n\n# configuration related to timestamps\n[timestamp]\n# When True, all timestamps are created with UTC time instead of local time\nutc = <True/False>\n\n# configuration related to topology for testbed loading\n[topology]\n\n# import paths for replacing any topology classes.\n# must be subclasses of original topology classes.\n# these will be overwritten by any specified class in the testbed yaml file.\nclass.testbed = <new.testbed.class>\nclass.device = <new.device.class>\nclass.link = <new.link.class>\nclass.interface = <new.interface.class>\n\n# configuration related to interaction calls\n[interaction]\n\n# Address to bind server to\nserver.host = <address>\nserver.port = <value>\n\nemail.disable = <True/False>\n\n# May require authentication for SMTP\nemail.from = <address>\nemail.to = <address>\n\n# This is formatted by jinja2. section_name is one argument that will be\n# populated in a template format.\nemail.subject = <subjectline>\n\n# Set this to one of the possible section results\ntimeout.result = <errored/failed/blocked/etc...>\n\n# This can be inf, for no timeout, otherwise specify a number of seconds.\ntimeout.time = <value>\n\n# Maximum seconds to wait for a response when loading a YAML file from a URL\nmax_wait_time = <value>\n\n# configuration related to file transfer server\n[filetransfer]\n\n# Subnet for devices in testbed to identify correct IP address on execution\n# host to use as the file transfer server address\nsubnet = <subnet_string>\n\n# Default server protocol, defaults to ftp\nprotocol = <ftp/tftp/scp>\n\n# configuration related to secrets\n[secrets]\n\n# This class defines how a secret string is to be encoded and decoded\n# and how keys (if required) are to be generated.\n# (Optional)\n# If not specified, defaults to a class representing a secret string\n# as a non-cryptographically secure cipher.\n# Users must ensure the specified module's directory may be imported\n# by setting their $PYTHONPATH appropriately.\nstring.representer = module.class_name\n\n# This key is used to convert a secret string to plaintext.\n# Some representers may require a key to be set, others may default\n# the key if it is not set.\n# Users are encouraged to secure configuration files containing this key\n# with appropriate permissions.\nstring.key = <my secret string key>\n\n# Set this pattern when using 'pyats run job' to select which environment\n# variables are hidden (encoded as secret strings) prior to being dumped\n# into env.txt.  Environment variables whose names match this pattern are\n# written as ENC(xyz123) and may be decoded via\n# 'pyats secret decode xyz123'.\nenv.hide_pattern = .*PASSWORD.*\n```\n\n----------------------------------------\n\nTITLE: Configuring env.sh to Set pip Environment Variables in Bash\nDESCRIPTION: This bash script snippet shows the required environment variable exports to be added to the env.sh file to configure pip to trust the custom pyATS PyPI server, set the pip index URL, and disable pip version checking. These settings ensure proper package retrieval from Cisco's ATS PyPI server and avoid pip version check interruptions when using version 7.x.x of pip.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2015/july.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# BEGIN CUSTOM pyATS CONTENT\nexport PIP_TRUSTED_HOST=ats-pypi-server.cisco.com\nexport PIP_INDEX_URL=http://ats-pypi-server.cisco.com/simple\nexport PIP_DISABLE_PIP_VERSION_CHECK=1\n```\n\n----------------------------------------\n\nTITLE: Modifying install script argument styles and dependency installations\nDESCRIPTION: This code segment outlines updates to the install script for the framework, shifting all command-line arguments to ``--`` style from short ``-`` forms, and adding validation checks for the install directory's validity and writability. It ensures only the core ``ats`` package is installed directly, with other dependencies managed externally. This helps streamline installations and enforces environment correctness.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2015/june.rst#_snippet_15\n\nLANGUAGE: Shell\nCODE:\n```\n- changed all arguments to ``--`` style. All ``-`` short forms have been removed.\n```\n\nLANGUAGE: Shell\nCODE:\n```\n- added checks for install directory being valid and writable\n```\n\nLANGUAGE: Shell\nCODE:\n```\n- now only installed ``ats`` package. All other PyPI packages should be installed automatically as dependencies.\n```\n\n----------------------------------------\n\nTITLE: Defining Legacy Import Mapping in Python\nDESCRIPTION: This snippet demonstrates how a package developer registers legacy-to-latest import mappings. It outlines the necessary steps to support legacy imports. First, a dictionary `IMPORT_MAPPING` is added to the module, where the key is the legacy import path and the value is the new import path. Secondly, in the package's `setup.py`, the `entry_points` are configured to link the package's name and the import mapping variable. The mapping allows old import statements to be translated to the newer import path.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/utilities/import_utils.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nIMPORT_MAPPING = {\n    'legacy': 'new',\n}\n\n\nsetup(\n    # ... ,\n    entry_points = {\n        'pyats.utils.__legacy_imports__': 'my_pkg = mypkg.my_module.IMPORT_MAPPING',\n    },\n    # ... ,\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Clean File Content\nDESCRIPTION: This YAML snippet demonstrates how clean information is loaded and applied to device objects.  It defines device-specific cleaning parameters, image locations, and other related configurations. It's designed to be an addendum to the testbed file, supplementing device information to enable cleaning processes.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/kleenex/inputs.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n    # Example\n    # -------\n    #\n    #   demonstrating how clean file content is loaded\n    #   and applied to device objects for user reference\n\n    --- # assuming we have this simple testbed.yaml file\n    devices:\n        example-device:\n            type: example-type\n            connections:\n                default:\n                    protocol: telnet\n                    ip: 1.1.1.10\n                    port: 500\n    ...\n\n    --- # and we had this clean.yaml clean-file for this testbed\n    cleaners:\n        AwesomeClean:\n            module: mollymaid.cleaners\n            devices: [example-device, ]\n            timeout: 1200\n\n    devices:\n        example-device:\n            images:\n                - /path/to/device/image/r99.9.9.bin\n\n            awesomeclean:\n                check_image_md5: True\n\n            timeout: 900\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Clean Attributes (YAML)\nDESCRIPTION: Explains that arbitrary key/value pairs can be added under the clean configuration section. These custom attributes are stored directly on the device object's 'Device.clean' attribute, allowing for flexible configuration extensions via nested dictionary updates.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/kleenex/inputs.rst#_snippet_9\n\nLANGUAGE: YAML\nCODE:\n```\n# any key/value pair to be stored to this group's device object's\n# Device.clean attribute. (nested dictionary update)\n<key>: <value>\n```\n\n----------------------------------------\n\nTITLE: Topology File Handling and Schema Updates\nDESCRIPTION: This snippet describes recent enhancements to topology management, including allowing file-like objects for topology files, adding a testbed cropping method, and removing obsolete keys from the configuration schema to improve modularity and maintainability.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2016/may.rst#_snippet_13\n\nLANGUAGE: Python\nCODE:\n```\n  - Now file-like objects may be loaded.\n\n  - Added new `squeeze<ats.topology.testbed.Testbed.squeeze>` method to allow\n    users to crop a testbed to a wanted subset of itself.\n\n  - The key ``iou`` is scheduled for removal in the next release.\n\n  - Removed ``logical`` and ``multinode_requested`` from the testbed YAML\n    schema, since these keys are only used for logical testbed YAML now.\n\n  - Removed ``tcl_clean`` keys from from the testbed YAML schema. Please read\n    :ref:`kleenex_index` and :ref:`topology_kleenex_integration` on how the new\n    model clean integration model works.\n\n  - updated schema to accomodated latest connection manager integration model.\n```\n\n----------------------------------------\n\nTITLE: Listing pyATS Module Versions in reStructuredText Table\nDESCRIPTION: Displays a CSV-styled table listing various pyATS modules along with their version numbers, specifically indicating v19.6 for each. The table aids in quick visual verification of module versions within documentation.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2019/june.rst#_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. csv-table:: New Module Versions\n    :header: \"Modules\", \"Version\"\n\n    ``pyats``, v19.6\n    ``pyats.aereport``, v19.6\n    ``pyats.aetest``, v19.6\n    ``pyats.async``, v19.6\n    ``pyats.cisco``, v19.6\n    ``pyats.connections``, v19.6\n    ``pyats.datastructures``, v19.6\n    ``pyats.easypy``, v19.6\n    ``pyats.examples``, v19.6\n    ``pyats.kleenex``, v19.6\n    ``pyats.log``, v19.6\n    ``pyats.results``, v19.6\n    ``pyats.robot``, v19.6\n    ``pyats.tcl``, v19.6\n    ``pyats.templates``, v19.6\n    ``pyats.topology``, v19.6\n    ``pyats.utils``, v19.6\n```\n\n----------------------------------------\n\nTITLE: Documenting pyats.async.parallelcall Module with Sphinx\nDESCRIPTION: This snippet documents the `pyats.async_.parallelcall` module with the `automodule` directive.  It presents members, excludes undocumented members, and displays inheritance information. This relies on Sphinx for processing and the pyats package.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/apidoc/async/index.rst#_snippet_2\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: pyats.async_.parallelcall\n   :members:\n   :undoc-members:\n   :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: Defining Table of Contents - reStructuredText\nDESCRIPTION: This snippet defines a table of contents (`toctree`) within the reStructuredText format. It includes a `:maxdepth: 2` parameter, which specifies the depth of the table of contents. It lists the files for documentation related to the pyats project organized by month.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2018/index.rst#_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. toctree::\n    :maxdepth: 2\n\n    dec\n    nov\n    oct\n    sep\n    aug\n    july\n    june\n    may\n    apr\n    mar\n    jan\n```\n\n----------------------------------------\n\nTITLE: Introducing Extended pyATS aetest Processor Examples (Python)\nDESCRIPTION: This is a Python comment serving as a marker for the start of a section that will contain more detailed examples demonstrating the use of pre-processors, post-processors, and exception processors in pyATS aetest. It signals the beginning of a new code demonstration block.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/processors.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Example\n# -------\n#\n#   extended pre/post processor/exception examples\n```\n\n----------------------------------------\n\nTITLE: Documentation of loop.mark() arguments and behavior\nDESCRIPTION: This section explains that loop.mark() functions similarly to the @loop decorator but with the first argument being the target section method/class. It emphasizes that only runtime information is available for dynamic variables like script_args and parent, making delay in variable reference essential. The snippet is a descriptive comment block without executable code.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/loop.rst#_snippet_14\n\nLANGUAGE: Markdown\nCODE:\n```\n``loop.mark()`` arguments & behaviors (including loop parameters & etc) are \nexactly identical to its sibling ``@loop`` decorator, with the only exception \that its first input argument must be the target section method/class. Eg: \n``loop.mark(Testcase_Two, a=[1,2,3])``.\n\nThe benefit of this approach is simple: dynamic information, parameters and\nvariables such as :ref:`script_args`, :ref:`parent` etc, are only available \nduring runtime. This information and its corresponding variables are not\navailable when the script is written, and delaying variable references (while\nusing ``@loop`` decorator) in Python is very difficult, if not impossible.\n```\n\n----------------------------------------\n\nTITLE: Removing Examples and Templates Before Upgrade - Bash\nDESCRIPTION: Provides bash commands to remove the 'templates' and 'examples' directories from an existing pyATS virtual environment before upgrading. Assumes the environment variable VIRTUAL_ENV is set and that user has permission to delete these directories. No parameters required. Outputs are the removal of specified directories; user is warned to back up any custom modifications before deletion.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/changelog/2015/june.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nbash$ cd $VIRTUAL_ENV\n# note - this will delete it. If you modified examples/templates,\n# make sure to make local backups\nbash$ rm -rf templates examples\n```\n\n----------------------------------------\n\nTITLE: Inspecting Function Class Internals in Python (Placeholder)\nDESCRIPTION: A placeholder comment indicating where an example demonstrating the internal instantiation and workings of `aetest` function classes (like `Subsection`, `TestSection`) would be placed. These classes wrap the methods decorated with corresponding `aetest` decorators.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/aetest/objects.rst#_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\n# Example\n# -------\n#\n#  peeking into function class internals\n```\n\n----------------------------------------\n\nTITLE: Sample pyATS Job Execution Report (Text)\nDESCRIPTION: This text output shows an example of the Easypy Report generated after running a pyATS job. It includes details about the environment (pyATS instance, Python version, OS), job information (name, start/stop times, archive location), task counts, overall test statistics (Passed, Failed, etc.), success rate, and a summary/detailed breakdown of results for each task executed within the job.\nSOURCE: https://github.com/ciscotestautomation/pyats/blob/main/docs/getting_started/index.rst#_snippet_6\n\nLANGUAGE: text\nCODE:\n```\n+------------------------------------------------------------------------------+\n|                                Easypy Report                                 |\n+------------------------------------------------------------------------------+\npyATS Instance   : /path/to/pyats\nTcl-ATS Tree     :\nPython Version   : cpython-3.4.1 (32bit)\nCLI Arguments    : pyats run job ios_job.py --testbed-file ios_testbed.yaml\nUser             : joe\nHost Server      : automation\nHost OS Version  : Red Hat Enterprise Linux Server 6.6 Santiago (x86_64)\n\nJob Information\n    Name         : ios_job\n    Start time   : 2018-03-15 00:24:05.847263\n    Stop time    : 2018-03-15 00:24:17.066042\n    Elapsed time : 0:00:11.218779\n    Archive      : archive/18-Mar/ios_job.2018Mar15_00:24:04.zip\n\nTotal Tasks    : 1\n\nOverall Stats\n    Passed     : 4\n    Passx      : 0\n    Failed     : 0\n    Aborted    : 0\n    Blocked    : 0\n    Skipped    : 0\n    Errored    : 0\n\n    TOTAL      : 4\n\nSuccess Rate   : 100.00 %\n\n+------------------------------------------------------------------------------+\n|                             Task Result Summary                              |\n+------------------------------------------------------------------------------+\nTask-1: connectivity_check.commonSetup                                    PASSED\nTask-1: connectivity_check.PingTestcase[device=ios1]                      PASSED\nTask-1: connectivity_check.PingTestcase[device=ios2]                      PASSED\nTask-1: connectivity_check.commonCleanup                                  PASSED\n\n+------------------------------------------------------------------------------+\n|                             Task Result Details                              |\n+------------------------------------------------------------------------------+\nTask-1: connectivity_check\n|-- common_setup                                                          PASSED\n|   |-- check_topology                                                    PASSED\n|   `-- establish_connections                                             PASSED\n|       |-- Step 1: Connecting to ios-1                                   PASSED\n|       `-- Step 2: Connecting to ios-2                                   PASSED\n|-- PingTestcase[device=ios1]                                             PASSED\n|   |-- ping[destination=10.10.10.1]                                      PASSED\n|   `-- ping[destination=10.10.10.2]                                      PASSED\n|-- PingTestcase[device=ios2]                                             PASSED\n|   |-- ping[destination=10.10.10.1]                                      PASSED\n|   `-- ping[destination=10.10.10.2]                                      PASSED\n`-- common_cleanup                                                        PASSED\n    `-- disconnect                                                        PASSED\n        |-- Step 1: Disconnecting from ios-1                              PASSED\n        `-- Step 2: Disconnecting from ios-2                              PASSED\n```"
  }
]