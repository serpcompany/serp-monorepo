[
  {
    "owner": "paritytech",
    "repo": "subxt",
    "content": "TITLE: Connecting with Subxt RPC Client Using jsonrpsee (Rust)\nDESCRIPTION: This snippet illustrates how to connect to a local Substrate node using the jsonrpsee-powered subxt-rpcs client and invoke V2 chainhead methods. It demonstrates asynchronous usage, construction of the RPC client, usage of ChainHead RPC methods, and processing events via subscription. Dependencies include the subxt_rpcs crate with the jsonrpsee feature enabled. Input includes the node URL as a string, and output involves processing subscription events received from the chainhead endpoint. Error handling for connection and subscription failures is illustrated via Rust's Result and Option types. The code requires a Tokio runtime and the relevant crates in Cargo.toml.\nSOURCE: https://github.com/paritytech/subxt/blob/master/CHANGELOG.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse subxt_rpcs::{RpcClient, ChainHeadRpcMethods};\n\n// Connect to a local node:\nlet client = RpcClient::from_url(\"ws://127.0.0.1:9944\").await?;\n// Use chainHead/archive V2 methods:\nlet methods = ChainHeadRpcMethods::new(client);\n\n// Call some RPC methods (in this case a subscription):\nlet mut follow_subscription = methods.chainhead_v1_follow(false).await.unwrap();\nwhile let Some(follow_event) = follow_subscription.next().await {\n    // do something with events..\n}\n```\n\n----------------------------------------\n\nTITLE: Signing and Submitting Transactions Using subxt-signer (Rust)\nDESCRIPTION: This snippet showcases how to build, sign, and submit a balance transfer extrinsic to a Polkadot chain using subxt and subxt-signer. It requires subxt, subxt_signer, and a chain runtime module with a balances pallet, all accessible from Rust async context. The code demonstrates generation of dev public keys, preparation of the transfer transaction, signing with a dev key, and sending/watching for finalized events. Suitable for test/dev environments with known dev keys; a valid running Substrate node is required.\nSOURCE: https://github.com/paritytech/subxt/blob/master/CHANGELOG.md#_snippet_23\n\nLANGUAGE: rust\nCODE:\n```\nuse subxt::{OnlineClient, PolkadotConfig};\nuse subxt_signer::sr25519::dev;\n\nlet api = OnlineClient::<PolkadotConfig>::new().await?;\n\n// Build the extrinsic; a transfer to bob:\nlet dest = dev::bob().public_key().into();\nlet balance_transfer_tx = polkadot::tx().balances().transfer(dest, 10_000);\n\n// Sign and submit the balance transfer extrinsic from Alice:\nlet from = dev::alice();\nlet events = api\n    .tx()\n    .sign_and_submit_then_watch_default(&balance_transfer_tx, &from)\n    .await?\n    .wait_for_finalized_success()\n    .await?;\n```\n\n----------------------------------------\n\nTITLE: Static and Dynamic V15 Metadata Runtime API Calls in Subxt (Rust)\nDESCRIPTION: This snippet illustrates two approaches to accessing runtime APIs using the V15 metadata interface in Subxt. The first is a static, type-safe Rust interface generated with #[subxt::subxt], requiring a local metadata.scale file for your target chain. The second uses Subxt's dynamic interface for runtime API calls by module and function name, accepting arbitrary argument value vectors. Both approaches require Subxt 0.30.0+ and V15 metadata support on the target chain. Returns the runtime call handle or value.\nSOURCE: https://github.com/paritytech/subxt/blob/master/CHANGELOG.md#_snippet_22\n\nLANGUAGE: rust\nCODE:\n```\n// We can use the static interface to interact in a type safe way:\n#[subxt::subxt(runtime_metadata_path = \"path/to/metadata.scale\")]\npub mod polkadot {}\n\nlet runtime_call = polkadot::apis()\n    .metadata()\n    .metadata_versions();\n\n// Or we can use the dynamic interface like so:\nuse subxt::dynamic::Value;\n\nlet runtime_call = subxt::dynamic::runtime_api_call(\n    \"Metadata\",\n    \"metadata_versions\",\n    Vec::<Value<()>>::new()\n);\n```\n\n----------------------------------------\n\nTITLE: Current Subxt Dependency Import Structure (Rust)\nDESCRIPTION: Illustrates the current, recommended import structure in Subxt after refactoring for optional Substrate dependencies (PR #760). `sp_core` and `sp_runtime` must be added as direct dependencies and imported directly. Subxt provides its own `AccountId32` in `subxt::utils`. Configuration-related types (`Header`, `Era`, `PlainTip`, etc.) are now located under `subxt::config` and its submodules (e.g., `subxt::config::polkadot`).\nSOURCE: https://github.com/paritytech/subxt/blob/master/CHANGELOG.md#_snippet_35\n\nLANGUAGE: rust\nCODE:\n```\n// `sp_core` and `sp_runtime` are no longer exposed via `ext`; add the crates yourself at matching versions to use:\nuse sp_core::{\n    sr25519,\n    Pair,\n};\nuse subxt::{\n    // You'll often want to use the \"built-in\" `AccountId32` now instead of the `sp_runtime` version:\n    utils::AccountId32,\n    // traits used in our `Config` trait are now provided directly in this module:\n    config::Header,\n    // Polkadot and Substrate specific Config types are now in the relevant Config section:\n    config::polkadot::{\n        Era,\n        PlainTip,\n        PolkadotExtrinsicParamsBuilder\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Blockchain Storage at a Specific Block Using Subxt Rust\nDESCRIPTION: Demonstrates the updated block-centric approach to accessing blockchain storage via Subxt, showing how to fetch storage entries at a given block hash or latest block. The snippet relies on the new `.at()` API for specifying the block context, replacing the older method of passing an optional block hash directly to storage fetch methods. Dependencies include the Subxt Rust client and the staking_bonded storage entry. The input is the storage key and optional block hash; the output is the fetched storage value for that block.\nSOURCE: https://github.com/paritytech/subxt/blob/master/CHANGELOG.md#_snippet_31\n\nLANGUAGE: Rust\nCODE:\n```\nlet a = api.storage().at(None).await?.fetch(&staking_bonded).await?;\n```\n\nLANGUAGE: Rust\nCODE:\n```\nlet block = api.blocks().at(None).await?;\nlet a = block.storage().fetch(&staking_bonded, None).await?;\n```\n\n----------------------------------------\n\nTITLE: Instantiating Light Client and Parachain Connection\nDESCRIPTION: This Rust code snippet shows how to create a light client in Subxt and connect it to both a relay chain (Polkadot) and a parachain (Asset Hub). It utilizes `LightClient::relay_chain` and `lightclient.parachain` to establish these connections, then creates Subxt clients using the resulting RPC clients.\nSOURCE: https://github.com/paritytech/subxt/blob/master/CHANGELOG.md#_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\n#[subxt::subxt(runtime_metadata_path = \"../artifacts/polkadot_metadata_small.scale\")]\npub mod polkadot {}\n\nuse subxt::lightclient::LightClient;\n\n// Instantiate a light client with the Polkadot relay chain given its chain spec.\nlet (lightclient, polkadot_rpc) = LightClient::relay_chain(POLKADOT_SPEC)?;\n// Connect the light client to some parachain by giving a chain spec for it.\nlet asset_hub_rpc = lightclient.parachain(ASSET_HUB_SPEC)?;\n\n// Now, we can create Subxt clients from these Smoldot backed RPC clients:\nlet polkadot_api = OnlineClient::<PolkadotConfig>::from_rpc_client(polkadot_rpc).await?;\nlet asset_hub_api = OnlineClient::<PolkadotConfig>::from_rpc_client(asset_hub_rpc).await?;\n```\n\n----------------------------------------\n\nTITLE: Decoding Extrinsics from Blocks in Subxt Rust\nDESCRIPTION: Demonstrates various methods for accessing and decoding extrinsics within a retrieved block in Subxt. It shows how to find a specific extrinsic by type, iterate through all extrinsics, decode an extrinsic into a specific call type using `as_extrinsic`, or decode any extrinsic into a root enum representing all possible calls using `as_root_extrinsic`.\nSOURCE: https://github.com/paritytech/subxt/blob/master/CHANGELOG.md#_snippet_25\n\nLANGUAGE: Rust\nCODE:\n```\n#[subxt::subxt(runtime_metadata_path = \"polkadot_metadata.scale\")]\npub mod polkadot {}\n\n// Get some block:\nlet block = api.blocks().at_latest().await?;\n\n// Find and decode a specific extrinsic in the block:\nlet remark = block.find::<polkadot::system::calls::Remark>()?;\n\n// Iterate the extrinsics in the block:\nfor ext in block.iter() {\n    // Decode a specific extrinsic into the call data:\n    let remark = ext.as_extrinsic::<polkadot::system::calls::Remark>()?;\n    // Decode any extrinsic into an enum containing the call data:\n    let extrinsic = ext.as_root_extrinsic::<polkadot::Call>()?;\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing Subxt Transaction Submission Between Versions\nDESCRIPTION: Shows how transaction submission worked in the previous version of Subxt compared to the new approach in version 0.23.0. The new version separates creating a transaction from submitting it, providing more flexibility.\nSOURCE: https://github.com/paritytech/subxt/blob/master/CHANGELOG.md#_snippet_36\n\nLANGUAGE: rust\nCODE:\n```\nlet api = ClientBuilder::new()\n    .build()\n    .await?\n    .to_runtime_api::<polkadot::RuntimeApi<DefaultConfig, PolkadotExtrinsicParams<_>>>();\n\nlet balance_transfer = api\n    .tx()\n    .balances()\n    .transfer(dest, 10_000)?\n    .sign_and_submit_then_watch_default(&signer)\n    .await?\n    .wait_for_finalized_success()\n    .await?;\n```\n\nLANGUAGE: rust\nCODE:\n```\nlet api = OnlineClient::<PolkadotConfig>::new().await?;\n\nlet balance_transfer_tx = polkadot::tx().balances().transfer(dest, 10_000);\n\nlet balance_transfer = api\n    .tx()\n    .sign_and_submit_then_watch_default(&balance_transfer_tx, &signer)\n    .await?\n    .wait_for_finalized_success()\n    .await?;\n```\n\n----------------------------------------\n\nTITLE: Generating and Deriving Keys with subxt-signer (Rust)\nDESCRIPTION: This snippet demonstrates keypair creation and derivation for transaction signing using subxt-signer's sr25519 module. It covers generating a keypair from a BIP39 phrase, constructing keys from a URI or using derive junctions (both soft and hard) for deterministic derivation. Requires subxt_signer, a valid BIP39 phrase, and std::str::FromStr. Outputs keypairs suitable for signing transactions on Substrate chains, with support for hierarchical deterministic wallets. Intended for secure key management, not test keys.\nSOURCE: https://github.com/paritytech/subxt/blob/master/CHANGELOG.md#_snippet_24\n\nLANGUAGE: rust\nCODE:\n```\nuse subxt_signer::{ SecretUri, sr25519::Keypair };\nuse std::str::FromStr;\n\n// From a phrase (see `bip39` crate on generating phrases):\nlet phrase = bip39::Mnemonic::parse(phrase).unwrap();\nlet keypair = Keypair::from_phrase(&phrase, Some(\"Password\")).unwrap();\n\n// Or from a URI:\nlet uri = SecretUri::from_str(\"//Alice\").unwrap();\nlet keypair = Keypair::from_uri(&uri).unwrap();\n\n// Deriving a new key from an existing one:\nlet keypair = keypair.derive([\n    DeriveJunction::hard(\"Alice\"),\n    DeriveJunction::soft(\"stash\")\n]);\n```\n\n----------------------------------------\n\nTITLE: Connecting and Interacting with Substrate Chain via Light Client using Subxt (Rust)\nDESCRIPTION: This snippet demonstrates initialization and use of Subxt's experimental light client mode using Smoldot to interact with a local Substrate chain (e.g., Polkadot) over WebSockets. Required dependencies include subxt and subxt_signer, and it shows building the client, configuring the runtime, initiating a balance transfer, and awaiting finalized transaction events. Ensure you have the Polkadot chain spec and light client prerequisites in your Rust environment; connections require asynchronous context. Expects a ws:// public node endpoint and properly initialized dev keys.\nSOURCE: https://github.com/paritytech/subxt/blob/master/CHANGELOG.md#_snippet_21\n\nLANGUAGE: rust\nCODE:\n```\nuse subxt::{\n    client::{LightClient, LightClientBuilder},\n    PolkadotConfig\n};\nuse subxt_signer::sr25519::dev;\n\n// Create a light client:\nlet api = LightClient::<PolkadotConfig>::builder()\n    // You can also pass a chain spec directly using `build`, which is preferred:\n    .build_from_url(\"ws://127.0.0.1:9944\")\n    .await?;\n\n// Working with the interface is then the same as before:\nlet dest = dev::bob().public_key().into();\nlet balance_transfer_tx = polkadot::tx().balances().transfer(dest, 10_000);\nlet events = api\n    .tx()\n    .sign_and_submit_then_watch_default(&balance_transfer_tx, &dev::alice())\n    .await?\n    .wait_for_finalized_success()\n    .await?;\n```\n\n----------------------------------------\n\nTITLE: Iterating Storage Entries with Decoded Keys\nDESCRIPTION: This snippet focuses on querying and iterating through storage entries, demonstrating how to retrieve decoded keys alongside their values using the new storage interface in Subxt. The code retrieves account information and iterates over the results, displaying decoded keys, key bytes, and the corresponding values. Requires an API client configured to talk to a Polkadot node.\nSOURCE: https://github.com/paritytech/subxt/blob/master/CHANGELOG.md#_snippet_4\n\nLANGUAGE: Rust\nCODE:\n```\n#[subxt::subxt(runtime_metadata_path = \"../artifacts/polkadot_metadata_small.scale\")]\npub mod polkadot {}\n\n// Create a new API client, configured to talk to Polkadot nodes.\nlet api = OnlineClient::<PolkadotConfig>::new().await?;\n\n// Build a storage query to iterate over account information.\nlet storage_query = polkadot::storage().system().account_iter();\n\n// Get back an iterator of results (here, we are fetching 10 items at\n// a time from the node, but we always iterate over one at a time).\nlet mut results = api.storage().at_latest().await?.iter(storage_query).await?;\n\nwhile let Some(Ok(kv)) = results.next().await {\n    // We used to get a tuple of key bytes + value. Now we get back a\n    // `kv` struct containing the bytes and value as well as the actual\n    // decoded keys:\n    println!(\"Decoded key(s): {:?}\", kv.keys);\n    println!(\"Key bytes: 0x{}\", hex::encode(&kv.key_bytes));\n    println!(\"Value: {:?}\", kv.value);\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Reconnecting RPC Client\nDESCRIPTION: This snippet demonstrates how to set up and use a reconnecting RPC client in Subxt with an exponential backoff retry policy. It showcases the use of the `Client` builder to configure the retry policy, connection string, and the instantiation of a `Subxt` client using the created RPC client.\nSOURCE: https://github.com/paritytech/subxt/blob/master/CHANGELOG.md#_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\nuse std::time::Duration;\nuse futures::StreamExt;\nuse subxt::backend::rpc::reconnecting_rpc_client::{Client, ExponentialBackoff};\nuse subxt::{OnlineClient, PolkadotConfig};\n\n// Generate an interface that we can use from the node's metadata.\n#[subxt::subxt(runtime_metadata_path = \"../artifacts/polkadot_metadata_small.scale\")]\npub mod polkadot {}\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Create a new client with a reconnecting RPC client.\n    let rpc = Client::builder()\n        // We can configure the retry policy; here to an exponential backoff.\n        // This API accepts an iterator of retry delays, and here we use `take`\n        // to limit the number of retries.\n        .retry_policy(\n            ExponentialBackoff::from_millis(100)\n                .max_delay(Duration::from_secs(10))\n                .take(3),\n        )\n        .build(\"ws://localhost:9944\".to_string())\n        .await?;\n\n    // Use this reconnecting client when instantiating a Subxt client:\n    let api: OnlineClient<PolkadotConfig> = OnlineClient::from_rpc_client(rpc.clone()).await?;\n```\n\n----------------------------------------\n\nTITLE: Implementing Subxt Header Trait on Substrate Header Wrapper (Rust)\nDESCRIPTION: This snippet shows how to bridge a Substrate header type with Subxt by implementing the subxt::config::Header trait for a thin wrapper struct. It is required when migrating from the removed substrate-compat feature, allowing interoperability with custom versions of Substrate types. The wrapper struct takes a generic Substrate header, and the trait implementation provides number and hashing type aliases, along with the number accessor. Inputs are the wrapped header instances; output is compatibility for use in Subxt functions. Prerequisites: both subxt and sp_runtime crates, and familiarity with the Header trait definitions.\nSOURCE: https://github.com/paritytech/subxt/blob/master/CHANGELOG.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// Wrap a substrate header type in this to impl the subxt Header trait:\nstruct SubxtHeader<T>(pub T);\n\n// This basically copies the code removed from Subxt, but on a wrapper type:\nimpl <T> subxt::config::Header for SubxtHeader<T>\nwhere\n    T: sp_runtime::traits::Header,\n    <T as sp_runtime::traits::Header>::Number: Into<u64>,\n{\n    type Number = T::Number;\n    type Hasher = T::Hashing;\n\n    fn number(&self) -> Self::Number {\n        *self.0.number()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Transaction Status - Rust\nDESCRIPTION: Demonstrates how to handle transaction statuses using the lower-level APIs in Subxt after the removal of the `wait_for_in_block` helper method. This involves iterating through transaction statuses and handling different outcomes, including success, errors, and invalid states.\nSOURCE: https://github.com/paritytech/subxt/blob/master/CHANGELOG.md#_snippet_20\n\nLANGUAGE: rust\nCODE:\n```\nwhile let Some(status) = tx.next().await {\n    match status? {\n        TxStatus::InBestBlock(tx_in_block) | TxStatus::InFinalizedBlock(tx_in_block) => {\n            // now, we can attempt to work with the block, eg:\n            tx_in_block.wait_for_success().await?;\n        },\n        TxStatus::Error { message } | TxStatus::Invalid { message } | TxStatus::Dropped { message } => {\n            // Handle any errors:\n            println!(\"Error submitting tx: {message}\");\n        },\n        // Continue otherwise:\n        _ => continue,\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Example of generating formatted code with subxt-cli\nDESCRIPTION: Practical example demonstrating how to generate runtime API code and pipe it through rustfmt for proper formatting with specific edition settings.\nSOURCE: https://github.com/paritytech/subxt/blob/master/cli/README.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nsubxt codegen | rustfmt --edition=2018 --emit=stdout\n```\n\n----------------------------------------\n\nTITLE: Loading Metadata for OfflineClient (Current Method) in Subxt Rust\nDESCRIPTION: Shows the new, simplified method for loading raw metadata bytes directly into the `subxt::metadata::Metadata` type. The `Metadata::decode` method is now capable of decoding the raw wire format directly, replacing the previous two-step conversion process.\nSOURCE: https://github.com/paritytech/subxt/blob/master/CHANGELOG.md#_snippet_27\n\nLANGUAGE: Rust\nCODE:\n```\nuse subxt::metadata::Metadata;\n\nlet metadata = Metadata::decode(&mut &*bytes).unwrap();\n```\n\n----------------------------------------\n\nTITLE: Pipelining Metadata to Subxt Codegen with Stdin - Shell\nDESCRIPTION: Demonstrates using the `subxt codegen` CLI command with the new `--file -` option to read metadata directly from standard input. This allows chaining commands, such as piping metadata exported from a node into `subxt codegen` and then formatting the generated code.\nSOURCE: https://github.com/paritytech/subxt/blob/master/CHANGELOG.md#_snippet_12\n\nLANGUAGE: Shell\nCODE:\n```\nparachain-node export-metadata | subxt codegen --file - | rustfmt > main.rs\n```\n\n----------------------------------------\n\nTITLE: Obtaining Storage Address Bytes (Current Method) in Subxt Rust\nDESCRIPTION: Shows the updated method for obtaining the raw byte representation of a storage address in Subxt. This now requires using the `address_bytes` method on the client's storage interface, passing the storage address object. This method takes metadata into account for correct encoding.\nSOURCE: https://github.com/paritytech/subxt/blob/master/CHANGELOG.md#_snippet_30\n\nLANGUAGE: Rust\nCODE:\n```\nlet addr_bytes = cxt.client().storage().address_bytes(&storage_address).unwrap();\n```\n\n----------------------------------------\n\nTITLE: Substituting Substrate Types with Static Wrapper in Subxt Rust\nDESCRIPTION: Illustrates how to substitute types in the `#[subxt]` macro when the substitute type (like `sp_runtime::multiaddress::MultiAddress`) does not implement the `EncodeAsType` and `DecodeAsType` traits required by the new encoding/decoding mechanism. It shows wrapping the substitute type in the `::subxt::utils::Static` wrapper.\nSOURCE: https://github.com/paritytech/subxt/blob/master/CHANGELOG.md#_snippet_28\n\nLANGUAGE: Rust\nCODE:\n```\n#[subxt::subxt(\n    runtime_metadata_path = \"/path/to/metadata.scale\",\n    substitute_type(\n        type = \"sp_runtime::multiaddress::MultiAddress<A, B>\",\n        with = \"::subxt::utils::Static<::sp_runtime::multiaddress::MultiAddress<A, B>>\"\n    )\n)]\npub mod node_runtime {}\n```\n\n----------------------------------------\n\nTITLE: Comparing Subxt Storage Iteration Between Versions\nDESCRIPTION: Shows how iterating over storage entries worked previously versus the new approach in version 0.23.0. The new version separates building the storage query from executing it.\nSOURCE: https://github.com/paritytech/subxt/blob/master/CHANGELOG.md#_snippet_38\n\nLANGUAGE: rust\nCODE:\n```\nlet api = ClientBuilder::new()\n    .build()\n    .await?\n    .to_runtime_api::<polkadot::RuntimeApi<DefaultConfig, PolkadotExtrinsicParams<DefaultConfig>>>();\n\nlet mut iter = api\n    .storage()\n    .xcm_pallet()\n    .version_notifiers_iter(None)\n    .await?;\n\nwhile let Some((key, value)) = iter.next().await? {\n    // ...\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nlet api = OnlineClient::<PolkadotConfig>::new().await?;\n\nlet key_addr = polkadot::storage()\n    .xcm_pallet()\n    .version_notifiers_root();\n\nlet mut iter = api\n    .storage()\n    .iter(key_addr, 10, None).await?;\n\nwhile let Some((key, value)) = iter.next().await? {\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing Subxt Storage Fetching Between Versions\nDESCRIPTION: Demonstrates how storage fetching worked in the previous version of Subxt compared to the new approach in version 0.23.0. The new version separates building the storage query from fetching it.\nSOURCE: https://github.com/paritytech/subxt/blob/master/CHANGELOG.md#_snippet_37\n\nLANGUAGE: rust\nCODE:\n```\nlet api = ClientBuilder::new()\n    .build()\n    .await?\n    .to_runtime_api::<polkadot::RuntimeApi<DefaultConfig, PolkadotExtrinsicParams<DefaultConfig>>>();\n\nlet entry = api.storage().staking().bonded(&addr, None).await;\n```\n\nLANGUAGE: rust\nCODE:\n```\nlet api = OnlineClient::<PolkadotConfig>::new().await?;\n\nlet staking_bonded = polkadot::storage().staking().bonded(&addr);\n\nlet entry = api.storage().fetch(&staking_bonded, None).await;\n```\n\n----------------------------------------\n\nTITLE: Comparing Subxt Constants Access Between Versions\nDESCRIPTION: Demonstrates how accessing constants worked previously versus the new approach in version 0.23.0. The new version separates building the constant address from fetching it.\nSOURCE: https://github.com/paritytech/subxt/blob/master/CHANGELOG.md#_snippet_39\n\nLANGUAGE: rust\nCODE:\n```\nlet api = ClientBuilder::new()\n    .build()\n    .await?\n    .to_runtime_api::<polkadot::RuntimeApi<DefaultConfig, PolkadotExtrinsicParams<DefaultConfig>>>();\n\nlet existential_deposit = api\n    .constants()\n    .balances()\n    .existential_deposit()?;\n```\n\nLANGUAGE: rust\nCODE:\n```\nlet api = OnlineClient::<PolkadotConfig>::new().await?;\n\nlet address = polkadot::constants()\n    .balances()\n    .existential_deposit();\n\nlet existential_deposit = api.constants().at(&address)?;\n```\n\n----------------------------------------\n\nTITLE: Advanced Generic Type Substitution in Subxt Codegen (Rust)\nDESCRIPTION: Demonstrates the enhanced type substitution feature in Subxt codegen (introduced in PR #735). It uses `substitute_type(type = \"...\", with = \"...\")` within the `#[subxt::subxt(...)]` attribute to precisely map generic parameters from the original type (`sp_arithmetic::per_things::Foo<A, B, C>`) to the substitute type (`crate::Foo<C>`), offering greater flexibility.\nSOURCE: https://github.com/paritytech/subxt/blob/master/CHANGELOG.md#_snippet_33\n\nLANGUAGE: rust\nCODE:\n```\n#[subxt::subxt(\n    runtime_metadata_path = \"../polkadot_metadata.scale\",\n    substitute_type(\n        type = \"sp_arithmetic::per_things::Foo<A, B, C>\",\n        with = \"crate::Foo<C>\"\n    )\n)]\npub mod node_runtime {}\n```\n\n----------------------------------------\n\nTITLE: Decoding Signed Extensions in Extrinsics - Rust\nDESCRIPTION: Example of how to decode signed extensions within extrinsics in a Subxt block. This involves iterating through blocks and their extrinsics, checking for signed extensions, and decoding them into specific types or generic values.\nSOURCE: https://github.com/paritytech/subxt/blob/master/CHANGELOG.md#_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\nlet api = OnlineClient::<PolkadotConfig>::new().await?;\n\n// Get blocks; here we just subscribe to them:\nlet mut blocks_sub = api.blocks().subscribe_finalized().await?;\n\nwhile let Some(block) = blocks_sub.next().await {\n    let block = block?;\n\n    // Fetch the extrinsics in the block:\n    let extrinsics = block.extrinsics().await?;\n\n    // Iterate over them:\n    for extrinsic in extrinsics.iter() {\n\n        // Returns None if the extrinsic isn't signed, so no signed extensions:\n        let Some(signed_exts) = extrinsic.signed_extensions() else {\n            continue;\n        };\n\n        // We can ask for a couple of common values, None if not found:\n        println!(\"Tip: {:?}\", signed_exts.tip());\n        println!(\"Nonce: {:?}\", signed_exts.tip());\n\n        // Or we can find and decode into a static signed extension type\n        // (Err if we hit a decode error first, then None if it's not found):\n        if let Ok(Some(era)) = signed_exts.find::<CheckMortality<PolkadotConfig>>() {\n            println!(\"Era: {era:?}\");\n        }\n\n        // Or we can iterate over the signed extensions to work with them:\n        for signed_ext in signed_exts {\n            println!(\"Signed Extension name: {}\", signed_ext.name());\n\n            // We can try to statically decode each one:\n            if let Ok(Some(era)) = signed_ext.as_signed_extension::<CheckMortality<PolkadotConfig>>() {\n                println!(\"Era: {era:?}\");\n            }\n\n            // Or we can dynamically decode it into a `scale_value::Value`:\n            if let Ok(value) = signed_ext.value() {\n                println!(\"Decoded extension: {value}\");\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Type Substitution in Subxt Codegen (Rust)\nDESCRIPTION: Illustrates the previous method for basic type substitution in Subxt's codegen. This approach uses the `#[subxt::subxt(substitute_type = \"...\")]` attribute to replace a specific type (`sp_arithmetic::per_things::Foo`) with a local type (`crate::Foo`). This method had limitations regarding matching generic parameters.\nSOURCE: https://github.com/paritytech/subxt/blob/master/CHANGELOG.md#_snippet_32\n\nLANGUAGE: rust\nCODE:\n```\n#[subxt::subxt(runtime_metadata_path = \"../polkadot_metadata.scale\")]\npub mod node_runtime {\n    #[subxt::subxt(substitute_type = \"sp_arithmetic::per_things::Foo\")]\n    use crate::Foo;\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Recursive Derives with Subxt Macro (Recursive Flag) - Rust\nDESCRIPTION: Shows the improved method for applying derives using the `subxt` macro's new `recursive` flag. A single `derive_for_type` entry with `recursive` applies the specified derive (`Clone`) to the target type (`MultiLocation`) and all its nested type components automatically, simplifying configuration.\nSOURCE: https://github.com/paritytech/subxt/blob/master/CHANGELOG.md#_snippet_8\n\nLANGUAGE: Rust\nCODE:\n```\n#[subxt::subxt(\n    runtime_metadata_path = \"metadata.scale\",\n    derive_for_type(path = \"xcm::v2::multilocation::MultiLocation\", derive = \"Clone\", recursive),\n)]\npub mod polkadot {}\n```\n\n----------------------------------------\n\nTITLE: Configuring AssetId for ChargeAssetTxPayment - Rust\nDESCRIPTION: Demonstrates how to configure the AssetId type for the ChargeAssetTxPayment extension in Subxt, allowing it to be used with generic AssetIds like MultiLocation, particularly useful on chains like Asset Hub.\nSOURCE: https://github.com/paritytech/subxt/blob/master/CHANGELOG.md#_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\n\n```\n\n----------------------------------------\n\nTITLE: Signed Extension Matching Logic - Rust\nDESCRIPTION: Shows the change in how signed extensions are matched in Subxt, moving from a simple name-based matching to a more flexible approach that allows inspecting the type of the signed extension for more precise matching criteria.\nSOURCE: https://github.com/paritytech/subxt/blob/master/CHANGELOG.md#_snippet_19\n\nLANGUAGE: rust\nCODE:\n```\nimpl<T: Config> SignedExtension<T> for ChargeAssetTxPayment<T> {\n    const NAME: &'static str = \"ChargeAssetTxPayment\";\n    type Decoded = Self;\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nimpl<T: Config> SignedExtension<T> for ChargeAssetTxPayment<T> {\n    type Decoded = Self;\n    fn matches(identifier: &str, type_id: u32, types: &PortableRegistry) -> bool {\n        identifier == \"ChargeAssetTxPayment\"\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Deriving Clone for Runtime Types - Rust\nDESCRIPTION: Example showing how to derive the Clone trait for specific runtime types used in Subxt, especially when dealing with custom types like MultiLocation. This is necessary because the default Subxt setup might not automatically derive Clone for all required types.\nSOURCE: https://github.com/paritytech/subxt/blob/master/CHANGELOG.md#_snippet_18\n\nLANGUAGE: rust\nCODE:\n```\n#[subxt::subxt(\n    runtime_metadata_path = \"../artifacts/polkadot_metadata_full.scale\",\n    derive_for_type(path = \"xcm::v2::multilocation::MultiLocation\", derive = \"Clone\"),\n    derive_for_type(path = \"xcm::v2::multilocation::Junctions\", derive = \"Clone\"),\n    derive_for_type(path = \"xcm::v2::junction::Junction\", derive = \"Clone\"),\n    derive_for_type(path = \"xcm::v2::NetworkId\", derive = \"Clone\"),\n    derive_for_type(path = \"xcm::v2::BodyId\", derive = \"Clone\"),\n    derive_for_type(path = \"xcm::v2::BodyPart\", derive = \"Clone\"),\n    derive_for_type(\n        path = \"bounded_collections::weak_bounded_vec::WeakBoundedVec\",\n        derive = \"Clone\"\n    )\n)]\n```\n\n----------------------------------------\n\nTITLE: Discovering Pallet Events with Subxt CLI - Shell\nDESCRIPTION: Provides a shell command example utilizing the `subxt explore` CLI tool to list and describe the events that can be emitted by a specific pallet (`Balances`). Useful for understanding the available events for a given runtime without consulting external documentation or code.\nSOURCE: https://github.com/paritytech/subxt/blob/master/CHANGELOG.md#_snippet_11\n\nLANGUAGE: Shell\nCODE:\n```\nsubxt explore --url wss://westend-rpc.polkadot.io pallet Balances events\n```\n\n----------------------------------------\n\nTITLE: Executing Runtime API Calls with Subxt CLI - Shell\nDESCRIPTION: Shows a shell command example demonstrating how to execute a runtime API method (`version` within the `core` API) directly from the `subxt explore` CLI using the `-e` flag. Useful for quickly testing API calls and retrieving results without writing Rust code.\nSOURCE: https://github.com/paritytech/subxt/blob/master/CHANGELOG.md#_snippet_10\n\nLANGUAGE: Shell\nCODE:\n```\nsubxt explore --url wss://westend-rpc.polkadot.io api core version -e\n```\n\n----------------------------------------\n\nTITLE: Exploring Runtime API Details with Subxt CLI - Shell\nDESCRIPTION: Provides a shell command example using the `subxt explore` CLI tool to retrieve detailed information about a specific runtime API method (`nominations_quota` within the `StakingAPI`). Demonstrates accessing metadata and understanding API signatures and parameters directly from the command line.\nSOURCE: https://github.com/paritytech/subxt/blob/master/CHANGELOG.md#_snippet_9\n\nLANGUAGE: Shell\nCODE:\n```\nsubxt explore --url wss://westend-rpc.polkadot.io api StakingAPI nominations_quota\n```\n\n----------------------------------------\n\nTITLE: Obtaining Storage Address Bytes (Deprecated Method) in Subxt Rust\nDESCRIPTION: Shows the previous way to get the raw byte representation of a storage address in Subxt. This was done by calling the `.to_bytes()` method directly on the storage address object. This method is no longer the recommended approach following updates to storage address encoding.\nSOURCE: https://github.com/paritytech/subxt/blob/master/CHANGELOG.md#_snippet_29\n\nLANGUAGE: Rust\nCODE:\n```\nlet addr_bytes = storage_address.to_bytes()\n```\n\n----------------------------------------\n\nTITLE: Previous Subxt Dependency Import Structure (Rust)\nDESCRIPTION: Shows the older import structure used in Subxt prior to changes related to optional Substrate dependencies (PR #760). Types from `sp_core` and `sp_runtime` were re-exported under `subxt::ext`, and transaction-related types like `Era` and `PlainTip` were under `subxt::tx`.\nSOURCE: https://github.com/paritytech/subxt/blob/master/CHANGELOG.md#_snippet_34\n\nLANGUAGE: rust\nCODE:\n```\nuse subxt::{\n    ext::{\n        sp_core::{ sr25519, Pair },\n        sp_runtime::{ AccountId32, generic::Header },\n    },\n    tx::{\n        Era,\n        PlainTip,\n        PolkadotExtrinsicParamsBuilder\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Using the metadata subcommand in subxt-cli\nDESCRIPTION: Command structure for the 'metadata' subcommand which downloads metadata from a Substrate node. It provides options for specifying the output format and the URL of the node to query.\nSOURCE: https://github.com/paritytech/subxt/blob/master/cli/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nUSAGE:\n    subxt metadata [OPTIONS]\n\nOPTIONS:\n    -f, --format <format>    the format of the metadata to display: `json`, `hex` or `bytes` [default: json]\n        --url <url>          the url of the substrate node to query for metadata [default: http://localhost:9933]\n```\n\n----------------------------------------\n\nTITLE: Using the codegen subcommand in subxt-cli\nDESCRIPTION: Command structure for the 'codegen' subcommand that generates runtime API client code. It provides options to specify either a file containing encoded metadata or a URL to fetch metadata from a Substrate node.\nSOURCE: https://github.com/paritytech/subxt/blob/master/cli/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nUSAGE:\n    subxt codegen [OPTIONS]\n\nOPTIONS:\n    -f, --file <file>\n            the path to the encoded metadata file\n\n        --url <url>\n            the url of the substrate node to query for metadata for codegen\n```\n\n----------------------------------------\n\nTITLE: Using subxt-cli basic commands\nDESCRIPTION: The main command structure for subxt-cli showing available subcommands including codegen, help, and metadata, along with general flags for help and version information.\nSOURCE: https://github.com/paritytech/subxt/blob/master/cli/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nUSAGE:\nsubxt <SUBCOMMAND>\n\nFLAGS:\n-h, --help\nPrints help information\n\n    -V, --version\n            Prints version information\n\n\nSUBCOMMANDS:\ncodegen     Generate runtime API client code from metadata\nhelp        Prints this message or the help of the given subcommand(s)\nmetadata    Download metadata from a substrate node, for use with `subxt` codegen\n```\n\n----------------------------------------\n\nTITLE: Saving Metadata from Node\nDESCRIPTION: This command uses the `subxt-cli` tool to download the metadata from a running Substrate node and save it to a file named `metadata.scale`. The metadata is encoded in a binary format.\nSOURCE: https://github.com/paritytech/subxt/blob/master/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsubxt metadata -f bytes > metadata.scale\n```\n\n----------------------------------------\n\nTITLE: Configuring Extrinsic Parameters (Old Way) - Rust\nDESCRIPTION: Demonstrates the previous method for configuring `subxt` extrinsic parameters using the `Params` builder, specifically setting a tip and mortality. Shows how to build the parameters and use them with `sign_and_submit`. Required the use of separate functions like `create_signed_with_nonce` for custom nonce.\nSOURCE: https://github.com/paritytech/subxt/blob/master/CHANGELOG.md#_snippet_5\n\nLANGUAGE: Rust\nCODE:\n```\n// Configure the transaction parameters; we give a small tip and set the\n// transaction to live for 32 blocks from the `latest_block` above:\nlet tx_params = Params::new()\n    .tip(1_000)\n    .mortal(latest_block.header(), 32)\n    .build();\n\nlet hash = api.tx().sign_and_submit(&tx, &from, tx_params).await?;\n```\n\n----------------------------------------\n\nTITLE: Installing subxt-cli Tool\nDESCRIPTION: This snippet demonstrates how to install the `subxt-cli` tool using cargo, the Rust package manager.  The tool is used to download metadata from a Substrate node.\nSOURCE: https://github.com/paritytech/subxt/blob/master/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncargo install subxt-cli\n```\n\n----------------------------------------\n\nTITLE: Running the parachain example\nDESCRIPTION: This command executes the `parachain-example` binary, assumed to be a Subxt example program. It interacts with the running parachain after the initial epoch has passed (approximately 2 minutes after the previous step). The command utilizes cargo to run the specified binary.\nSOURCE: https://github.com/paritytech/subxt/blob/master/examples/parachain-example/README.md#_snippet_3\n\nLANGUAGE: Bash\nCODE:\n```\ncargo run --bin parachain-example\n```\n\n----------------------------------------\n\nTITLE: Applying Recursive Derives with Subxt Macro (Old Way) - Rust\nDESCRIPTION: Illustrates the previous method for applying derives to types using the `subxt` macro. It shows how multiple `derive_for_type` entries were required to apply the `Clone` derive to a complex type (`MultiLocation`) and its nested components, highlighting the verbosity before the recursive flag.\nSOURCE: https://github.com/paritytech/subxt/blob/master/CHANGELOG.md#_snippet_7\n\nLANGUAGE: Rust\nCODE:\n```\n#[subxt::subxt(\n    runtime_metadata_path = \"metadata.scale\",\n    derive_for_type(path = \"xcm::v2::multilocation::MultiLocation\", derive = \"Clone\"),\n    derive_for_type(path = \"xcm::v2::multilocation::Junctions\", derive = \"Clone\"),\n    derive_for_type(path = \"xcm::v2::junction::Junction\", derive = \"Clone\"),\n    derive_for_type(path = \"xcm::v2::NetworkId\", derive = \"Clone\"),\n    derive_for_type(path = \"xcm::v2::BodyId\", derive = \"Clone\"),\n    derive_for_type(path = \"xcm::v2::BodyPart\", derive = \"Clone\"),\n    derive_for_type(\n        path = \"bounded_collections::weak_bounded_vec::WeakBoundedVec\",\n        derive = \"Clone\"\n    )\n)]\npub mod polkadot {}\n```\n\n----------------------------------------\n\nTITLE: Running Zombienet to spawn the parachain\nDESCRIPTION: This command uses Zombienet to start a local Asset Hub parachain. It utilizes the `asset-hub-zombienet.toml` configuration file and the `-p native` flag to run without Kubernetes. It starts both validator nodes (using the polkadot binary) and an Asset Hub node (using the polkadot-parachain binary).\nSOURCE: https://github.com/paritytech/subxt/blob/master/examples/parachain-example/README.md#_snippet_2\n\nLANGUAGE: Bash\nCODE:\n```\nzombienet -p native spawn asset-hub-zombienet.toml\n```\n\n----------------------------------------\n\nTITLE: Obtaining metadata for Statemint using subxt cli\nDESCRIPTION: This command uses the subxt-cli tool to fetch and save the metadata for the Statemint parachain. It specifies the RPC URL and the port.  The metadata is written to a file named `statemint_metadata.scale`.  It’s important to explicitly specify the port 443.\nSOURCE: https://github.com/paritytech/subxt/blob/master/examples/parachain-example/README.md#_snippet_4\n\nLANGUAGE: Bash\nCODE:\n```\nsubxt metadata  --url wss://polkadot-asset-hub-rpc.polkadot.io:443 > statemint_metadata.scale\n```\n\n----------------------------------------\n\nTITLE: Applying Recursive Derives with Subxt Codegen CLI - Shell\nDESCRIPTION: Shows how to use the `subxt codegen` CLI command to generate code with recursive derives applied to a specific type. The `recursive` flag simplifies adding derives like `Clone` to a type and all its nested components via the command line.\nSOURCE: https://github.com/paritytech/subxt/blob/master/CHANGELOG.md#_snippet_13\n\nLANGUAGE: Shell\nCODE:\n```\nsubxt codegen --derive-for-type xcm::v2::multilocation::MultiLocation=Clone,recursive\n```\n\n----------------------------------------\n\nTITLE: Installing polkadot-parachain binary\nDESCRIPTION: This snippet clones the cumulus repository, navigates into it, and installs the polkadot-parachain binary using cargo.  This binary is necessary to run Asset Hub nodes.  The command uses `git`, `cd` and `cargo install` similarly to the previous snippet.\nSOURCE: https://github.com/paritytech/subxt/blob/master/examples/parachain-example/README.md#_snippet_1\n\nLANGUAGE: Bash\nCODE:\n```\ngit clone https://github.com/paritytech/cumulus.git\ncd cumulus\ncargo install --path polkadot-parachain\n```\n\n----------------------------------------\n\nTITLE: Installing polkadot binary\nDESCRIPTION: This snippet clones the polkadot repository, navigates into it, and installs the polkadot binary using cargo. This step is required to run a relay chain for the Asset Hub parachain. The command utilizes `git` for cloning, `cd` for navigation, and `cargo install` for installation.\nSOURCE: https://github.com/paritytech/subxt/blob/master/examples/parachain-example/README.md#_snippet_0\n\nLANGUAGE: Bash\nCODE:\n```\ngit clone https://github.com/paritytech/polkadot.git\ncd polkadot\ncargo install --path .\n```\n\n----------------------------------------\n\nTITLE: Example of downloading metadata with subxt-cli\nDESCRIPTION: Practical example showing how to download metadata from a Substrate node in binary format and save it to a file for later use with subxt codegen.\nSOURCE: https://github.com/paritytech/subxt/blob/master/cli/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nsubxt metadata -f bytes > metadata.scale\n```\n\n----------------------------------------\n\nTITLE: Configuring Subxt Macro with Type Derives (Invalid Path) - Rust\nDESCRIPTION: Shows the `subxt` macro configuration for code generation, specifying a metadata path and requesting a derive for a specific type path (`Junctions`). This example is used to demonstrate the macro's new compile-time error reporting and suggestions when the specified type path is invalid.\nSOURCE: https://github.com/paritytech/subxt/blob/master/CHANGELOG.md#_snippet_6\n\nLANGUAGE: Rust\nCODE:\n```\n#[subxt::subxt(\n    runtime_metadata_path = \"metadata.scale\",\n    derive_for_type(path = \"Junctions\", derive = \"Clone\")\n)]\npub mod polkadot {}\n```\n\n----------------------------------------\n\nTITLE: Loading Metadata for OfflineClient (Deprecated Method) in Subxt Rust\nDESCRIPTION: Shows the previous method for loading raw metadata bytes into a `subxt::metadata::Metadata` instance for use with an `OfflineClient`. This method required first decoding into the `frame_metadata::RuntimeMetadataPrefixed` type before converting to the Subxt `Metadata` type. This approach is now superseded by a direct decode method.\nSOURCE: https://github.com/paritytech/subxt/blob/master/CHANGELOG.md#_snippet_26\n\nLANGUAGE: Rust\nCODE:\n```\nuse subxt::ext::frame_metadata::RuntimeMetadataPrefixed;\nuse subxt::metadata::Metadata;\n\nlet metadata = RuntimeMetadataPrefixed::decode(&mut &*bytes).unwrap();\nlet metadata = Metadata::try_from(metadata).unwrap();\n```\n\n----------------------------------------\n\nTITLE: Starting a Local Polkadot Development Node in Shell\nDESCRIPTION: This snippet launches a local Polkadot node in development mode using the `polkadot` binary, which provides a JSON-RPC HTTP server on 127.0.0.1:9933. Running this node locally allows the WASM app to connect and interact with the blockchain network for testing purposes.\nSOURCE: https://github.com/paritytech/subxt/blob/master/examples/wasm-example/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\npolkadot --dev\n```\n\n----------------------------------------\n\nTITLE: Subxt Light Client Parachains Configuration - Rust\nDESCRIPTION: Example of configuring the light client for multiple chains using smoldot and converting it into a subxt OnlineClient. This allows for more arbitrary configuration of the light client implementation.\nSOURCE: https://github.com/paritytech/subxt/blob/master/CHANGELOG.md#_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\n\n```\n\n----------------------------------------\n\nTITLE: Comparing Subxt Event Subscription Between Versions\nDESCRIPTION: Shows how subscribing to events worked previously versus the new approach in version 0.23.0. The approach is similar but the client implementation has changed.\nSOURCE: https://github.com/paritytech/subxt/blob/master/CHANGELOG.md#_snippet_40\n\nLANGUAGE: rust\nCODE:\n```\nlet api = ClientBuilder::new()\n    .build()\n    .await?\n    .to_runtime_api::<polkadot::RuntimeApi<DefaultConfig, PolkadotExtrinsicParams<DefaultConfig>>>();\n\nlet mut event_sub = api.events().subscribe().await?;\n\nwhile let Some(events) = event_sub.next().await {\n    // ...\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nlet api = OnlineClient::<PolkadotConfig>::new().await?;\n\nlet mut event_sub = api.events().subscribe().await?;\n\nwhile let Some(events) = event_sub.next().await {\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Recursive Attributes with Subxt Codegen CLI - Shell\nDESCRIPTION: Provides a shell command example demonstrating the `subxt codegen` CLI command's ability to apply custom attributes (`#[myerror]`) recursively to a target type and its nested types using the `recursive` flag, simplifying code generation customization from the command line.\nSOURCE: https://github.com/paritytech/subxt/blob/master/CHANGELOG.md#_snippet_14\n\nLANGUAGE: Shell\nCODE:\n```\nsubxt codegen --attributes-for-type \"xcm::v2::multilocation::MultiLocation=#[myerror],recursive\"\n```\n\n----------------------------------------\n\nTITLE: Connecting to Substrate Node and Using ChainHead RPC Methods in Rust\nDESCRIPTION: This snippet demonstrates how to create an RPC client connection to a local Substrate node, initialize the ChainHead RPC methods interface, and use a subscription to receive chainhead follow events. The example shows the basic pattern of establishing a connection and processing stream data.\nSOURCE: https://github.com/paritytech/subxt/blob/master/rpcs/README.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse subxt_rpcs::{RpcClient, ChainHeadRpcMethods};\n\n// Connect to a local node:\nlet client = RpcClient::from_url(\"ws://127.0.0.1:9944\").await?;\n// Use a set of methods, here the V2 \"chainHead\" ones:\nlet methods = ChainHeadRpcMethods::new(client);\n\n// Call some RPC methods (in this case a subscription):\nlet mut follow_subscription = methods.chainhead_v1_follow(false).await.unwrap();\nwhile let Some(follow_event) = follow_subscription.next().await {\n    // do something with events..\n}\n```\n\n----------------------------------------\n\nTITLE: Final test execution before Subxt release\nDESCRIPTION: Command to run a comprehensive test suite to ensure everything works before publishing.\nSOURCE: https://github.com/paritytech/subxt/blob/master/RELEASING.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\ncargo test --all-targets\n```\n\n----------------------------------------\n\nTITLE: Publishing second batch of Subxt crates to crates.io\nDESCRIPTION: Commands to publish the remaining Subxt crates after removing dev dependencies from subxt-core.\nSOURCE: https://github.com/paritytech/subxt/blob/master/RELEASING.md#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\n(cd core && cargo publish) && \\\n(cd rpcs && cargo publish) && \\\n(cd subxt && cargo publish) && \\\n(cd signer && cargo publish) && \\\n(cd cli && cargo publish);\n```\n\n----------------------------------------\n\nTITLE: Checking out and updating master branch for Subxt release\nDESCRIPTION: Commands to checkout the master branch and ensure it's up to date before publishing.\nSOURCE: https://github.com/paritytech/subxt/blob/master/RELEASING.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\ngit checkout master && git pull\n```\n\n----------------------------------------\n\nTITLE: Tagging and pushing Subxt release\nDESCRIPTION: Commands to create a signed Git tag for the release and push it to the remote repository.\nSOURCE: https://github.com/paritytech/subxt/blob/master/RELEASING.md#_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\ngit tag -s v0.17.0 # use the version number you've just published to crates.io, not this one\ngit push --tags\n```\n\n----------------------------------------\n\nTITLE: Generating updated lockfile for Subxt\nDESCRIPTION: Command to ensure the Cargo.lock file is up to date before release.\nSOURCE: https://github.com/paritytech/subxt/blob/master/RELEASING.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ncargo generate-lockfile\n```\n\n----------------------------------------\n\nTITLE: Checking external documentation links in Subxt\nDESCRIPTION: Commands to install cargo-deadlinks and verify that external links in documentation are valid.\nSOURCE: https://github.com/paritytech/subxt/blob/master/RELEASING.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncargo install cargo-deadlinks\ncargo deadlinks --check-http\n```\n\n----------------------------------------\n\nTITLE: Publishing first batch of Subxt crates to crates.io\nDESCRIPTION: Commands to publish the first set of Subxt crates in the correct dependency order.\nSOURCE: https://github.com/paritytech/subxt/blob/master/RELEASING.md#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\n(cd metadata && cargo publish) && \\\n(cd lightclient && cargo publish) && \\\n(cd utils/fetch-metadata && cargo publish) && \\\n(cd codegen && cargo publish) && \\\n(cd macro && cargo publish);\n```\n\n----------------------------------------\n\nTITLE: Opening cargo documentation for review in Subxt\nDESCRIPTION: Command to generate and open the Rust documentation for review before release.\nSOURCE: https://github.com/paritytech/subxt/blob/master/RELEASING.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncargo doc --open\n```\n\n----------------------------------------\n\nTITLE: Generating changelog for Subxt release\nDESCRIPTION: Script execution to generate a list of merged PRs between the current and previous release.\nSOURCE: https://github.com/paritytech/subxt/blob/master/RELEASING.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n./scripts/generate_changelog.sh\n```\n\n----------------------------------------\n\nTITLE: Serving the WASM App Locally with Trunk in Shell\nDESCRIPTION: This snippet serves the WASM application locally using the Trunk bundler's built-in development server. The `--open` flag automatically opens the default browser to preview the running WASM app, enabling rapid development and testing of the frontend.\nSOURCE: https://github.com/paritytech/subxt/blob/master/examples/wasm-example/README.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ntrunk serve --open\n```\n\n----------------------------------------\n\nTITLE: Installing Trunk WASM Bundler via Cargo in Shell\nDESCRIPTION: This snippet installs the Trunk bundler, a tool required to build and bundle WASM applications written in Rust, using the Cargo package manager with the --locked flag to ensure dependency versions are fixed. This setup step is necessary before running or building the WASM app.\nSOURCE: https://github.com/paritytech/subxt/blob/master/examples/wasm-example/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncargo install --locked trunk\n```\n\n----------------------------------------\n\nTITLE: Installing a Substrate Executable\nDESCRIPTION: This bash snippet shows how to install a Substrate executable from source using cargo. It specifies a git repository and branch, using the --force flag to ensure installation.\nSOURCE: https://github.com/paritytech/subxt/blob/master/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncargo install --git https://github.com/paritytech/polkadot-sdk staging-node-cli --force\n```"
  }
]