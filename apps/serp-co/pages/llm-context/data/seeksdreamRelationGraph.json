[
  {
    "owner": "seeksdream",
    "repo": "relation-graph",
    "content": "TITLE: Check if Node is Allowed to Show (JS)\nDESCRIPTION: This function determines if a given node is allowed to be shown in the graph visualization. It checks the isShow, isHide, expanded properties of the node and its parents recursively.  A node is allowed to show if its isShow is not explicitly false, isHide is not true, and its parent (if any) is also allowed to show and is expanded.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/play/vue3-demo/src/tmp.txt#_snippet_23\n\nLANGUAGE: javascript\nCODE:\n```\nisAllowShowNode(thisNode) {\n    const _r = thisNode.isShow !== false && thisNode.isHide !== true && (!thisNode.lot.parent || (this.isAllowShowNode(thisNode.lot.parent, false) === true && thisNode.lot.parent.expanded !== false));\n    return _r;\n  }\n```\n\n----------------------------------------\n\nTITLE: Analyze Bidirectional Nodes in Relation Graph (JS)\nDESCRIPTION: This function analyzes nodes in a relation graph considering bidirectional relationships. The levelDirect parameter dictates the direction to traverse (0 for targetNodes, -1 for targetFrom, 1 for targetTo). Similar to analysisNodes, it updates analyticResult with max_length and max_deep.  It calculates node strength based on child count and uses RGGraphMath.isAllowShowNode to filter nodes. It calls itself recursively and RGGraphMath.analysisDataTree to process layout.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/play/vue3-demo/src/tmp.txt#_snippet_20\n\nLANGUAGE: javascript\nCODE:\n```\nanalysisNodes4Didirectional(willLayoutNodes, thisLevelNodes, thisDeep, analyticResult, levelDirect) {\n    if (thisLevelNodes.length > analyticResult.max_length) {\n      analyticResult.max_length = thisLevelNodes.length;\n    }\n    if (thisDeep > analyticResult.max_deep) {\n      analyticResult.max_deep = thisDeep;\n    }\n    const __thisLOT_subling = {\n      level: thisDeep,\n      all_size: thisLevelNodes.length,\n      all_strength: 0\n    };\n    const newLevelNodes = [];\n    thisLevelNodes.forEach(thisNode => {\n      if (!thisNode.lot)thisNode.lot = {};\n      thisNode.lot.eached = true;\n      thisNode.lot.subling = __thisLOT_subling;\n      thisNode.lot.level = thisDeep;\n      willLayoutNodes.push(thisNode);\n    });\n    let __thisLevel_index = 0;\n    // var __prev_node\n    thisLevelNodes.forEach(thisNode => {\n      let __thisNode_child_size = 0;\n      if (levelDirect === 0) {\n        let __thisTargetIndex = 0;\n        thisNode.targetNodes.forEach((thisTarget) => {\n          if (!thisTarget.lot)thisTarget.lot = { eached: false };\n          if (!thisTarget.lot.eached) {\n            if (RGGraphMath.isAllowShowNode(thisTarget)) {\n              thisTarget.lot.eached = true;\n              thisTarget.lot.parent = thisNode;\n              thisTarget.lot.index_of_parent = __thisTargetIndex++;\n              // thisTarget.lot.prevNode = __prev_node\n              // if (__prev_node)__prev_node.lot.nextNode = thisTarget\n              // __prev_node = thisTarget\n              thisNode.lot.childs.push(thisTarget);\n              newLevelNodes.push(thisTarget);\n              __thisNode_child_size++;\n            } else {\n              thisNode.lot.childs.push(thisTarget);\n            }\n          }\n        });\n      } else if (levelDirect === -1) {\n        let __thisTargetIndex = 0;\n        thisNode.targetFrom.forEach((thisTarget) => {\n          if (!thisTarget.lot)thisTarget.lot = { eached: false };\n          if (!thisTarget.lot.eached) {\n            if (RGGraphMath.isAllowShowNode(thisTarget)) {\n              thisTarget.lot.eached = true;\n              thisTarget.lot.parent = thisNode;\n              thisTarget.lot.index_of_parent = __thisTargetIndex++;\n              // thisTarget.lot.prevNode = __prev_node\n              // if (__prev_node)__prev_node.lot.nextNode = thisTarget\n              // __prev_node = thisTarget\n              thisNode.lot.childs.push(thisTarget);\n              newLevelNodes.push(thisTarget);\n              __thisNode_child_size++;\n            } else {\n              thisNode.lot.childs.push(thisTarget);\n            }\n          }\n        });\n      } else {\n        let __thisTargetIndex = 0;\n        thisNode.targetTo.forEach((thisTarget) => {\n          if (!thisTarget.lot)thisTarget.lot = { eached: false };\n          if (!thisTarget.lot.eached) {\n            if (RGGraphMath.isAllowShowNode(thisTarget)) {\n              thisTarget.lot.eached = true;\n              thisTarget.lot.parent = thisNode;\n              thisTarget.lot.index_of_parent = __thisTargetIndex++;\n              // thisTarget.lot.prevNode = __prev_node\n              // if (__prev_node)__prev_node.lot.nextNode = thisTarget\n              // __prev_node = thisTarget\n              thisNode.lot.childs.push(thisTarget);\n              newLevelNodes.push(thisTarget);\n              __thisNode_child_size++;\n            } else {\n              thisNode.lot.childs.push(thisTarget);\n            }\n          }\n        });\n      }\n      thisNode.lot.strength = __thisNode_child_size > 0 ? __thisNode_child_size : 1;\n      __thisLOT_subling.all_strength += thisNode.lot.strength;\n      thisNode.lot.strength_plus = __thisLOT_subling.all_strength;\n      thisNode.lot.index_of_level = __thisLevel_index;\n      thisNode.lot.childs_size = __thisNode_child_size;\n      __thisLevel_index++;\n    });\n    if (__thisLOT_subling.all_strength > analyticResult.max_strength) {\n      analyticResult.max_strength = __thisLOT_subling.all_strength;\n    }\n    if (newLevelNodes.length > 0) {\n      RGGraphMath.analysisNodes4Didirectional(willLayoutNodes, newLevelNodes, thisDeep + (levelDirect === -1 ? -1 : 1), analyticResult, levelDirect);\n    } else {\n      willLayoutNodes.forEach(thisNode => {\n        if (thisNode.lot.childs_size > 0) {\n          thisNode.lot.strengthWithChilds = 0;\n        }\n      });\n      willLayoutNodes.forEach(thisNode => {\n        if (thisNode.lot.childs_size === 0) {\n          thisNode.lot.strengthWithChilds = 1;\n          RGGraphMath.conductStrengthToParents(thisNode);\n        }\n      });\n      RGGraphMath.analysisDataTree([willLayoutNodes[0]], 0, levelDirect);\n      // willLayoutNodes.forEach(thisNode => {\n      //   thisNode.text = thisNode.lot.strengthWithChilds_from + ':' + thisNode.lot.strengthWithChilds + '/' + thisNode.lot.strength\n      // })\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Analyze Nodes in Relation Graph (JS)\nDESCRIPTION: This function recursively analyzes nodes in a relation graph to determine layout properties. It updates the analyticResult object with max_length (maximum number of nodes at a level) and max_deep (maximum depth of the graph). It also calculates and assigns strength values to each node based on the number of its children. It utilizes RGGraphMath.isAllowShowNode to determine if a node should be shown.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/play/vue3-demo/src/tmp.txt#_snippet_19\n\nLANGUAGE: javascript\nCODE:\n```\nanalysisNodes(willLayoutNodes, thisLevelNodes, thisDeep, analyticResult, config) {\n    if (thisLevelNodes.length > analyticResult.max_length) {\n      analyticResult.max_length = thisLevelNodes.length;\n    }\n    if (thisDeep > analyticResult.max_deep) {\n      analyticResult.max_deep = thisDeep;\n    }\n    const __thisLOT_subling = {\n      level: thisDeep,\n      all_size: thisLevelNodes.length,\n      all_strength: 0\n    };\n    const newLevelNodes = [];\n    thisLevelNodes.forEach(thisNode => {\n      if (!thisNode.lot)thisNode.lot = {};\n      thisNode.lot.eached = true;\n      thisNode.lot.subling = __thisLOT_subling;\n      thisNode.lot.level = thisDeep;\n      willLayoutNodes.push(thisNode);\n    });\n    let __thisLevel_index = 0;\n    // var __prev_node\n    thisLevelNodes.forEach(thisNode => {\n      let __thisNode_child_size = 0;\n      if (thisNode.targetNodes) {\n        let __thisTargetIndex = 0;\n        thisNode.targetNodes.forEach((thisTarget) => {\n          if (!thisTarget.lot)thisTarget.lot = { eached: false };\n          if (!thisTarget.lot.eached) {\n            if (RGGraphMath.isAllowShowNode(thisTarget)) {\n              thisTarget.lot.eached = true;\n              thisTarget.lot.parent = thisNode;\n              thisTarget.lot.index_of_parent = __thisTargetIndex++;\n              // thisTarget.lot.prevNode = __prev_node\n              // if (__prev_node)__prev_node.lot.nextNode = thisTarget\n              // __prev_node = thisTarget\n              thisNode.lot.childs.push(thisTarget);\n              newLevelNodes.push(thisTarget);\n              __thisNode_child_size++;\n            } else {\n              thisNode.lot.childs.push(thisTarget);\n            }\n          }\n        });\n      }\n      thisNode.lot.strength = __thisNode_child_size > 0 ? __thisNode_child_size : 1;\n      __thisLOT_subling.all_strength += thisNode.lot.strength;\n      thisNode.lot.strength_plus = __thisLOT_subling.all_strength;\n      thisNode.lot.index_of_level = __thisLevel_index;\n      thisNode.lot.childs_size = __thisNode_child_size;\n      __thisLevel_index++;\n    });\n    if (__thisLOT_subling.all_strength > analyticResult.max_strength) {\n      analyticResult.max_strength = __thisLOT_subling.all_strength;\n    }\n    if (newLevelNodes.length > 0) {\n      this.analysisNodes(willLayoutNodes, newLevelNodes, thisDeep + 1, analyticResult, config);\n    } else {\n      willLayoutNodes.forEach(thisNode => {\n        if (thisNode.lot.childs_size > 0) {\n          thisNode.lot.strengthWithChilds = 0;\n        }\n      });\n      willLayoutNodes.forEach(thisNode => {\n        if (thisNode.lot.childs_size === 0) {\n          thisNode.lot.strengthWithChilds = 1;\n          this.conductStrengthToParents(thisNode);\n        }\n      });\n      this.analysisDataTree([willLayoutNodes[0]], 0);\n      // willLayoutNodes.forEach(thisNode => {\n      //   thisNode.text = thisNode.lot.strengthWithChilds_from + ':' + thisNode.lot.strengthWithChilds + '/' + thisNode.lot.strength\n      // })\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Calculate Basic Rectangle Point\nDESCRIPTION: The `getRectPointBasic` function calculates a point on a rectangle, similar to `getRectPoint`, but uses a different approach based on trigonometric calculations. It calculates the tangent of the angle between the rectangle centers and determines the x and y offsets based on this tangent and the rectangle dimensions. It takes coordinates and dimensions as input and returns the calculated point along with a case indicator.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/play/vue3-demo/src/tmp.txt#_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\ngetRectPointBasic(\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n    n1w: number,\n    n1h: number,\n    n2w: number,\n    n2h: number\n  ) {\n    const fx = x1 + n1w / 2\n    const fy = y1 + n1h / 2\n    const tx = x2 + n2w / 2\n    const ty = y2 + n2h / 2\n    // var x = fx - tx\n    // var y = fy - ty\n    // var z = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2))\n    // var cos = y / z\n    // var radina = Math.acos(cos)// 用反三角函数求弧度\n    // var angle = Math.floor(180 / (Math.PI / radina))// 将弧度转换成角度\n    // n1h = n1h + 10\n    // n1w = n1w + 10\n\n    let __tanA = ty === fy ? 0 : (tx - fx) / (ty - fy)\n    if (__tanA === 0) __tanA = (tx - fx) / (ty - fy + 1)\n    const rectAngle = n1w / n2h\n    let __w = 0\n    let __h = 0\n    let _case = '1'\n    // var __A_angle = Math.atan(__tanA) / (Math.PI / 180)\n    if (-1 * rectAngle < __tanA && __tanA < rectAngle) {\n      _case = '2'\n      if (fy < ty) {\n        __w = (n1h / 2) * __tanA\n        __h = n1h / 2\n      } else {\n        __w = ((-1 * n1h) / 2) * __tanA\n        __h = (-1 * n1h) / 2\n      }\n    } else {\n      if (fx < tx) {\n        __w = (1 * n1w) / 2\n        __h = (1 * n1w) / 2 / __tanA\n      } else {\n        __w = (-1 * n1w) / 2\n        __h = (-1 * n1w) / 2 / __tanA\n      }\n      _case = '3'\n    }\n    // var __w = (n1h / 2) * Math.tan(__A_angle)\n    // var __w = ty === fy ? parseInt(n1w / 2) : parseInt(((n1h / 2) * (tx - fx)) / (ty - fy))\n    // var __h = tx === fx ? parseInt(n1h / 2) : parseInt((__w * (ty - fy)) / (tx - fx))\n    return { x: fx + __w, y: fy + __h, _case }\n  }\n```\n\n----------------------------------------\n\nTITLE: Analyze Nodes in Relation Graph - TypeScript\nDESCRIPTION: Analyzes a set of nodes in a relation graph to determine layout properties such as maximum depth, maximum length, and node strength. It recursively traverses the graph and updates the `analyticResult` object with the calculated values. The function takes a list of nodes to layout, the current level's nodes, the current depth, and the analytic results as input.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/play/vue3-demo/src/tmp.txt#_snippet_45\n\nLANGUAGE: TypeScript\nCODE:\n```\nanalysisNodes(\n    willLayoutNodes: RGNode[],\n    thisLevelNodes: RGNode[],\n    thisDeep: number,\n    analyticResult: NodesAnalyticResult\n  ) {\n    if (thisLevelNodes.length > analyticResult.max_length) {\n      analyticResult.max_length = thisLevelNodes.length\n    }\n    if (thisDeep > analyticResult.max_deep) {\n      analyticResult.max_deep = thisDeep\n    }\n    const __thisLOT_subling = {\n      level: thisDeep,\n      all_size: thisLevelNodes.length,\n      all_strength: 0,\n    }\n    const newLevelNodes: RGNode[] = []\n    thisLevelNodes.forEach((thisNode) => {\n      if (!thisNode.lot) thisNode.lot = { childs: [] }\n      thisNode.lot.eached = true\n      thisNode.lot.subling = __thisLOT_subling\n      thisNode.lot.level = thisDeep\n      willLayoutNodes.push(thisNode)\n    })\n    let __thisLevel_index = 0\n    // var __prev_node\n    thisLevelNodes.forEach((thisNode) => {\n      let __thisNode_child_size = 0\n      if (thisNode.targetNodes) {\n        let __thisTargetIndex = 0\n        thisNode.targetNodes.forEach((thisTarget) => {\n          if (!thisTarget.lot) thisTarget.lot = { childs: [], eached: false }\n          if (!thisTarget.lot.eached) {\n            if (RGGraphMath.isAllowShowNode(thisTarget)) {\n              thisTarget.lot.eached = true\n              thisTarget.lot.parent = thisNode\n              thisTarget.lot.index_of_parent = __thisTargetIndex++\n              // thisTarget.lot.prevNode = __prev_node\n              // if (__prev_node)__prev_node.lot.nextNode = thisTarget\n              // __prev_node = thisTarget\n              thisNode.lot.childs.push(thisTarget)\n              newLevelNodes.push(thisTarget)\n              __thisNode_child_size++\n            } else {\n              thisNode.lot.childs.push(thisTarget)\n            }\n          }\n        })\n      }\n      thisNode.lot.strength =\n        __thisNode_child_size > 0 ? __thisNode_child_size : 1\n      __thisLOT_subling.all_strength += thisNode.lot.strength\n      thisNode.lot.strength_plus = __thisLOT_subling.all_strength\n      thisNode.lot.index_of_level = __thisLevel_index\n      thisNode.lot.childs_size = __thisNode_child_size\n      __thisLevel_index++\n    })\n    if (__thisLOT_subling.all_strength > analyticResult.max_strength) {\n      analyticResult.max_strength = __thisLOT_subling.all_strength\n    }\n    if (newLevelNodes.length > 0) {\n      this.analysisNodes(\n        willLayoutNodes,\n        newLevelNodes,\n        thisDeep + 1,\n        analyticResult\n      )\n    } else {\n      willLayoutNodes.forEach((thisNode) => {\n        if (thisNode.lot.childs_size && thisNode.lot.childs_size > 0) {\n          thisNode.lot.strengthWithChilds = 0\n        }\n      })\n      willLayoutNodes.forEach((thisNode) => {\n        if (thisNode.lot.childs_size === 0) {\n          thisNode.lot.strengthWithChilds = 1\n          this.conductStrengthToParents(thisNode)\n        }\n      })\n      this.analysisDataTree([willLayoutNodes[0]], 0)\n      // willLayoutNodes.forEach(thisNode => {\n      //   thisNode.text = thisNode.lot.strengthWithChilds_from + ':' + thisNode.lot.strengthWithChilds + '/' + thisNode.lot.strength\n      // })\n    }\n  },\n```\n\n----------------------------------------\n\nTITLE: Analyze Nodes in Bidirectional Relation Graph - TypeScript\nDESCRIPTION: Analyzes a set of nodes in a bidirectional relation graph, considering direction (forward, backward, or none) to determine layout properties. It recursively traverses the graph and updates the `analyticResult` object with the calculated values.  Takes a list of nodes, the current level nodes, depth, analytic results, and level direction as input.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/play/vue3-demo/src/tmp.txt#_snippet_46\n\nLANGUAGE: TypeScript\nCODE:\n```\nanalysisNodes4Didirectional(\n    willLayoutNodes: RGNode[],\n    thisLevelNodes: RGNode[],\n    thisDeep: number,\n    analyticResult: NodesAnalyticResult,\n    levelDirect: 1 | 0 | -1\n  ) {\n    if (thisLevelNodes.length > analyticResult.max_length) {\n      analyticResult.max_length = thisLevelNodes.length\n    }\n    if (thisDeep > analyticResult.max_deep) {\n      analyticResult.max_deep = thisDeep\n    }\n    const __thisLOT_subling = {\n      level: thisDeep,\n      all_size: thisLevelNodes.length,\n      all_strength: 0,\n    }\n    const newLevelNodes: RGNode[] = []\n    thisLevelNodes.forEach((thisNode) => {\n      if (!thisNode.lot) thisNode.lot = { childs: [] }\n      thisNode.lot.eached = true\n      thisNode.lot.subling = __thisLOT_subling\n      thisNode.lot.level = thisDeep\n      willLayoutNodes.push(thisNode)\n    })\n    let __thisLevel_index = 0\n    // var __prev_node\n    thisLevelNodes.forEach((thisNode) => {\n      let __thisNode_child_size = 0\n      if (levelDirect === 0) {\n        let __thisTargetIndex = 0\n        thisNode.targetNodes.forEach((thisTarget) => {\n          if (!thisTarget.lot) thisTarget.lot = { childs: [], eached: false }\n          if (!thisTarget.lot.eached) {\n            if (RGGraphMath.isAllowShowNode(thisTarget)) {\n              thisTarget.lot.eached = true\n              thisTarget.lot.parent = thisNode\n              thisTarget.lot.index_of_parent = __thisTargetIndex++\n              // thisTarget.lot.prevNode = __prev_node\n              // if (__prev_node)__prev_node.lot.nextNode = thisTarget\n              // __prev_node = thisTarget\n              thisNode.lot.childs.push(thisTarget)\n              newLevelNodes.push(thisTarget)\n              __thisNode_child_size++\n            } else {\n              thisNode.lot.childs.push(thisTarget)\n            }\n          }\n        })\n      } else if (levelDirect === -1) {\n        let __thisTargetIndex = 0\n        thisNode.targetFrom.forEach((thisTarget) => {\n          if (!thisTarget.lot) thisTarget.lot = { childs: [], eached: false }\n          if (!thisTarget.lot.eached) {\n            if (RGGraphMath.isAllowShowNode(thisTarget)) {\n              thisTarget.lot.eached = true\n              thisTarget.lot.parent = thisNode\n              thisTarget.lot.index_of_parent = __thisTargetIndex++\n              // thisTarget.lot.prevNode = __prev_node\n              // if (__prev_node)__prev_node.lot.nextNode = thisTarget\n              // __prev_node = thisTarget\n              thisNode.lot.childs.push(thisTarget)\n              newLevelNodes.push(thisTarget)\n              __thisNode_child_size++\n            } else {\n              thisNode.lot.childs.push(thisTarget)\n            }\n          }\n        })\n      } else {\n        let __thisTargetIndex = 0\n        thisNode.targetTo.forEach((thisTarget) => {\n          if (!thisTarget.lot) thisTarget.lot = { childs: [], eached: false }\n          if (!thisTarget.lot.eached) {\n            if (RGGraphMath.isAllowShowNode(thisTarget)) {\n              thisTarget.lot.eached = true\n              thisTarget.lot.parent = thisNode\n              thisTarget.lot.index_of_parent = __thisTargetIndex++\n              // thisTarget.lot.prevNode = __prev_node\n              // if (__prev_node)__prev_node.lot.nextNode = thisTarget\n              // __prev_node = thisTarget\n              thisNode.lot.childs.push(thisTarget)\n              newLevelNodes.push(thisTarget)\n              __thisNode_child_size++\n            } else {\n              thisNode.lot.childs.push(thisTarget)\n            }\n          }\n        })\n      }\n      thisNode.lot.strength =\n        __thisNode_child_size > 0 ? __thisNode_child_size : 1\n      __thisLOT_subling.all_strength += thisNode.lot.strength\n      thisNode.lot.strength_plus = __thisLOT_subling.all_strength\n      thisNode.lot.index_of_level = __thisLevel_index\n      thisNode.lot.childs_size = __thisNode_child_size\n      __thisLevel_index++\n    })\n    if (__thisLOT_subling.all_strength > analyticResult.max_strength) {\n      analyticResult.max_strength = __thisLOT_subling.all_strength\n    }\n    if (newLevelNodes.length > 0) {\n      RGGraphMath.analysisNodes4Didirectional(\n        willLayoutNodes,\n        newLevelNodes,\n        thisDeep + (levelDirect === -1 ? -1 : 1),\n        analyticResult,\n        levelDirect\n      )\n    } else {\n      willLayoutNodes.forEach((thisNode) => {\n        if (thisNode.lot.childs_size && thisNode.lot.childs_size > 0) {\n          thisNode.lot.strengthWithChilds = 0\n        }\n      })\n      willLayoutNodes.forEach((thisNode) => {\n        if (thisNode.lot.childs_size === 0) {\n          thisNode.lot.strengthWithChilds = 1\n          RGGraphMath.conductStrengthToParents(thisNode)\n        }\n      })\n      RGGraphMath.analysisDataTree([willLayoutNodes[0]], 0, levelDirect)\n      // willLayoutNodes.forEach(thisNode => {\n      //   thisNode.text = thisNode.lot.strengthWithChilds_from + ':' + thisNode.lot.strengthWithChilds + '/' + thisNode.lot.strength\n      // })\n    }\n  },\n```\n\n----------------------------------------\n\nTITLE: Calculating Basic Rectangle Point in TypeScript\nDESCRIPTION: This function calculates a point on a rectangle's edge, providing a basic approach to finding the intersection point with a line connecting two rectangles. It accounts for different quadrants and aspect ratios. It returns an object containing the x and y coordinates of the point, along with a case identifier.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/play/vue3-demo/src/tmp.txt#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ngetRectPointBasic(x1, y1, x2, y2, n1w, n1h, n2w, n2h) {\n    const fx = x1 + n1w / 2;\n    const fy = y1 + n1h / 2;\n    const tx = x2 + n2w / 2;\n    const ty = y2 + n2h / 2;\n    // var x = fx - tx\n    // var y = fy - ty\n    // var z = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2))\n    // var cos = y / z\n    // var radina = Math.acos(cos)// 用反三角函数求弧度\n    // var angle = Math.floor(180 / (Math.PI / radina))// 将弧度转换成角度\n    // n1h = n1h + 10\n    // n1w = n1w + 10\n\n    let __tanA = ty === fy ? 0 : (tx - fx) / (ty - fy);\n    if (__tanA === 0)__tanA = (tx - fx) / (ty - fy + 1);\n    const rectAngle = n1w / n2h;\n    let __w = 0;\n    let __h = 0;\n    let _case = '1';\n    // var __A_angle = Math.atan(__tanA) / (Math.PI / 180)\n    if ((-1 * rectAngle) < __tanA && __tanA < rectAngle) {\n      _case = '2';\n      if (fy < ty) {\n        __w = n1h / 2 * __tanA;\n        __h = n1h / 2;\n      } else {\n        __w = -1 * n1h / 2 * __tanA;\n        __h = -1 * n1h / 2;\n      }\n    } else {\n      if (fx < tx) {\n        __w = 1 * n1w / 2;\n        __h = 1 * n1w / 2 / __tanA;\n      } else {\n        __w = -1 * n1w / 2;\n        __h = -1 * n1w / 2 / __tanA;\n      }\n      _case = '3';\n    }\n    // var __w = (n1h / 2) * Math.tan(__A_angle)\n    // var __w = ty === fy ? parseInt(n1w / 2) : parseInt(((n1h / 2) * (tx - fx)) / (ty - fy))\n    // var __h = tx === fx ? parseInt(n1h / 2) : parseInt((__w * (ty - fy)) / (tx - fx))\n    return { x: fx + __w, y: fy + __h, _case };\n  },\n```\n\n----------------------------------------\n\nTITLE: Vue Component Implementation using relation-graph\nDESCRIPTION: This Vue component demonstrates how to integrate and use the relation-graph component. It includes the necessary import statement, component registration, data definition for graph options and JSON data, and event handling for node and line clicks. The jsonData defines the nodes and lines to display in the relation graph.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/README-zh.md#_snippet_1\n\nLANGUAGE: vue\nCODE:\n```\n<template>\n  <div>\n    <div style=\"height:calc(100vh - 60px);\"><!-- The size of the parent element determines the size of the graph. -->\n      <RelationGraph\n              ref=\"graphRef\"\n              :options=\"graphOptions\"\n              :on-node-click=\"onNodeClick\"\n              :on-line-click=\"onLineClick\"\n      />\n    </div>\n  </div>\n</template>\n\n<script>\n// relation-graph also supports usage in the main.js file with Vue.use(RelationGraph); this way, you don't need the following line of code for import.\nimport RelationGraph from 'relation-graph'\nexport default {\n  name: 'Demo',\n  components: { RelationGraph },\n  data() {\n    return {\n      graphOptions: {\n        defaultJunctionPoint: 'border'\n        // Here you can refer to the options in \"Graph\" for setting: \n        // https://www.relation-graph.com/#/docs/graph\n        // You can also use this GUI tool to generate configuration content.\n        // https://www.relation-graph.com/#/options-tools\n      }\n    }\n  },\n  mounted() {\n    this.showGraph()\n  },\n  methods: {\n    showGraph() {\n      const jsonData = {\n        rootId: 'a',\n        nodes: [\n          // You can also use slots directly without defining these cumbersome attributes and use CSS styles to define the appearance of your nodes.\n          // Example of using slots: https://www.relation-graph.com/#/demo/node-style\n          { id: 'a', text: 'A', borderColor: 'yellow' },\n          { id: 'b', text: 'B', color: '#43a2f1', fontColor: 'yellow' },\n          { id: 'c', text: 'C', nodeShape: 1, width: 80, height: 60 },\n          { id: 'e', text: 'E', nodeShape: 0, width: 150, height: 150 }\n        ],\n        lines: [\n          { from: 'a', to: 'b', text: 'line1', color: '#43a2f1' },\n          { from: 'a', to: 'c', text: 'line2' },\n          { from: 'a', to: 'e', text: 'line3' },\n          { from: 'b', to: 'e', color: '#67C23A' }\n        ]\n      }\n      // The node and line in the above data can refer to the options in \"Node\" and \"Link & Line\" for configuration.\n      // Node: https://www.relation-graph.com/#/docs/node\n      // Link & Line: https://www.relation-graph.com/#/docs/link\n\n      this.$refs.graphRef.setJsonData(jsonData, (graphInstance) => {\n        // Called when the relation-graph is completed\n      });\n      // The this.refs.graphRef.setJsonData(jsonData, callback) method is a convenient method that is equivalent to the following code:\n      //  const graphInstance = this.refs.graphRef.getInstance();\n      //  graphInstance.addNodes(jsonData.nodes);\n      //  graphInstance.addLines(jsonData.lines);\n      //  graphInstance.rootNode = graphInstance.getNodeById(jsonData.rootId);\n      //  await graphInstance.doLayout(); // Layout using the layouter set in graphOptions\n      //  await graphInstance.moveToCenter(); // Find the center based on node distribution and center the view\n      //  await graphInstance.zoomToFit(); // Zoom to fit, so that all nodes can be displayed in the visible area\n    },\n    onNodeClick(nodeObject, $event) {\n      console.log('onNodeClick:', nodeObject)\n    },\n    onLineClick(lineObject, $event) {\n      console.log('onLineClick:', lineObject)\n    }\n  }\n}\n</script>\n```\n\n----------------------------------------\n\nTITLE: Using relation-graph in a Vue component\nDESCRIPTION: This Vue component demonstrates how to integrate and configure the relation-graph component. It includes setting up the graph options, handling node and line click events, and loading data into the graph using the `setJsonData` method.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/README.md#_snippet_2\n\nLANGUAGE: vue\nCODE:\n```\n<template>\n  <div>\n    <div style=\"height:calc(100vh - 60px);\">\n      <RelationGraph\n              ref=\"graphRef\"\n              :options=\"graphOptions\"\n              :on-node-click=\"onNodeClick\"\n              :on-line-click=\"onLineClick\"\n      />\n    </div>\n  </div>\n</template>\n\n<script>\n// relation-graph also supports usage in the main.js file with Vue.use(RelationGraph); this way, you don't need the following line of code for import.\nimport RelationGraph from 'relation-graph'\nexport default {\n  name: 'Demo',\n  components: { RelationGraph },\n  data() {\n    return {\n      graphOptions: {\n        defaultJunctionPoint: 'border'\n        // Here you can refer to the options in \"Graph\" for setting: \n        // https://www.relation-graph.com/#/docs/graph\n        // You can also use this GUI tool to generate configuration content.\n        // https://www.relation-graph.com/#/options-tools\n      }\n    }\n  },\n  mounted() {\n    this.showGraph()\n  },\n  methods: {\n    showGraph() {\n      const jsonData = {\n        rootId: 'a',\n        nodes: [\n          // You can also use slots directly without defining these cumbersome attributes and use CSS styles to define the appearance of your nodes.\n          // Example of using slots: https://www.relation-graph.com/#/demo/node-style\n          { id: 'a', text: 'A', borderColor: 'yellow' },\n          { id: 'b', text: 'B', color: '#43a2f1', fontColor: 'yellow' },\n          { id: 'c', text: 'C', nodeShape: 1, width: 80, height: 60 },\n          { id: 'e', text: 'E', nodeShape: 0, width: 150, height: 150 }\n        ],\n        lines: [\n          { from: 'a', to: 'b', text: 'line1', color: '#43a2f1' },\n          { from: 'a', to: 'c', text: 'line2' },\n          { from: 'a', to: 'e', text: 'line3' },\n          { from: 'b', to: 'e', color: '#67C23A' }\n        ]\n      }\n      // The node and line in the above data can refer to the options in \"Node\" and \"Link & Line\" for configuration.\n      // Node: https://www.relation-graph.com/#/docs/node\n      // Link & Line: https://www.relation-graph.com/#/docs/link\n\n      this.$refs.graphRef.setJsonData(jsonData, (graphInstance) => {\n        // Called when the relation-graph is completed\n      });\n      // The this.refs.graphRef.setJsonData(jsonData, callback) method is a convenient method that is equivalent to the following code:\n      //  const graphInstance = this.refs.graphRef.getInstance();\n      //  graphInstance.addNodes(jsonData.nodes);\n      //  graphInstance.addLines(jsonData.lines);\n      //  graphInstance.rootNode = graphInstance.getNodeById(jsonData.rootId);\n      //  await graphInstance.doLayout(); // Layout using the layouter set in graphOptions\n      //  await graphInstance.moveToCenter(); // Find the center based on node distribution and center the view\n      //  await graphInstance.zoomToFit(); // Zoom to fit, so that all nodes can be displayed in the visible area\n    },\n    onNodeClick(nodeObject, $event) {\n      console.log('onNodeClick:', nodeObject)\n    },\n    onLineClick(lineObject, $event) {\n      console.log('onLineClick:', lineObject)\n    }\n  }\n}\n</script>\n```\n\n----------------------------------------\n\nTITLE: Calculate Rectangle Point\nDESCRIPTION: This function, `getRectPoint`, calculates a point on a rectangle's edge based on the relative positions of two rectangles. It takes the coordinates and dimensions of both rectangles as input and returns the coordinates of the calculated point. The function determines the intersection point by considering the angle between the centers of the rectangles and the aspect ratio of the first rectangle.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/play/vue3-demo/src/tmp.txt#_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\ngetRectPoint(\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n    n1w: number,\n    n1h: number,\n    n2w: number,\n    n2h: number\n  ) {\n    const fx = x1 + n1w / 2\n    const fy = y1 + n1h / 2\n    const tx = x2 + n2w / 2\n    const ty = y2 + n2h / 2\n    const _ar_x = fx < tx ? 1 : -1\n    const _ar_y = fy < ty ? 1 : -1\n    if (ty === fy) {\n      return { x: fx + (_ar_x * n1w) / 2, y: fy }\n    }\n    const __tan = Math.abs((tx - fx) / (ty - fy))\n    const rectAngle = n1w / n1h\n    let __w = 0\n    let __h = 0\n    if (__tan < rectAngle) {\n      __w = ((_ar_x * n1h) / 2) * __tan\n      __h = (_ar_y * n1h) / 2\n    } else {\n      __w = (_ar_x * n1w) / 2\n      __h = (_ar_y * n1w) / 2 / __tan\n    }\n    return { x: fx + __w, y: fy + __h }\n  }\n```\n\n----------------------------------------\n\nTITLE: Calculate Rectangle Join Point\nDESCRIPTION: The `getRectJoinPoint` function determines a connection point on a rectangle's border based on the angle between the centers of two rectangles. It divides the rectangle's border into four regions (top, right, bottom, left) based on the calculated angle and returns a point within the corresponding region. The function takes coordinates and dimensions as input and returns the coordinates of the calculated connection point.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/play/vue3-demo/src/tmp.txt#_snippet_28\n\nLANGUAGE: typescript\nCODE:\n```\ngetRectJoinPoint(\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n    n1w: number,\n    n1h: number,\n    n2w: number,\n    n2h: number\n  ) {\n    const _from_c_x = x1 + n1w / 2\n    const _from_c_y = y1 + n1h / 2\n    const _to_c_x = x2 + n2w / 2\n    const _to_c_y = y2 + n2h / 2\n    const _atan2 =\n      Math.round(\n        (Math.atan2(_to_c_y - _from_c_y, _to_c_x - _from_c_x) * 180) / 3.14\n      ) + 135\n    if (_atan2 >= 0 && _atan2 < 90) {\n      // top\n      return { x: x1 + n1w / 2, y: y1 - 5 }\n    } else if (_atan2 >= 90 && _atan2 < 180) {\n      // right\n      return { x: x1 + n1w + 5, y: y1 + n1h / 2 }\n    } else if (_atan2 >= 180 && _atan2 < 270) {\n      // bottom\n      return { x: x1 + n1w / 2, y: y1 + n1h + 5 }\n    } else {\n      // left\n      return { x: x1 - 5, y: y1 + n1h / 2 }\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Analyze Data Tree in RGGraphMath (TypeScript)\nDESCRIPTION: This method analyzes a tree structure of `RGNode` objects to calculate and assign strength values based on child nodes and hierarchy. It traverses the tree, updating `strengthWithChilds_from` properties and accumulating `currentLevelStrengthWidthChilds` for each level. It depends on RGNode type.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/play/vue3-demo/src/tmp.txt#_snippet_49\n\nLANGUAGE: typescript\nCODE:\n```\nanalysisDataTree(\n    thisLevelNodes: RGNode[],\n    thisDeep: number,\n    levelDirect?: 1 | 0 | -1\n  ) {\n    if (levelDirect === undefined) levelDirect = 1\n    const newLevelNodes: RGNode[] = []\n    let currentLevelStrengthWidthChilds = 0\n    thisLevelNodes.forEach((thisNode) => {\n      if (\n        thisNode.lot.level === 0 ||\n        levelDirect === (thisNode.lot.level && thisNode.lot.level < 0 ? -1 : 1)\n      ) {\n        if (thisNode.lot.childs_size && thisNode.lot.childs_size > 0) {\n          thisNode.lot.childs.forEach((thisTarget) => {\n            newLevelNodes.push(thisTarget)\n          })\n        }\n        if (\n          thisNode.lot.parent &&\n          thisNode.lot.parent.lot.strengthWithChilds_from &&\n          currentLevelStrengthWidthChilds <\n            thisNode.lot.parent.lot.strengthWithChilds_from\n        ) {\n          currentLevelStrengthWidthChilds =\n            thisNode.lot.parent.lot.strengthWithChilds_from\n        }\n        thisNode.lot.strengthWithChilds_from = currentLevelStrengthWidthChilds\n        currentLevelStrengthWidthChilds += thisNode.lot.strengthWithChilds || 0\n      }\n    })\n    if (newLevelNodes.length > 0) {\n      this.analysisDataTree(newLevelNodes, thisDeep + levelDirect, levelDirect)\n    }\n  },\n```\n\n----------------------------------------\n\nTITLE: Conditional Node Rendering (Vue)\nDESCRIPTION: This snippet conditionally renders node content based on the Vue version and slot usage. If `oldVueVersion` is true and `oldVueVersionUseSlot` is false, it renders either the `innerHTML` or a styled text using `nodeProps`. Otherwise, it uses the `renderSlot` function to render a slot named 'node' with fallback content.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/packages/platforms/vue2/src/core4vue/RGNodeSlotRender.txt#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\n[\n    t.options.oldVueVersion && !t.options.oldVueVersionUseSlot\n        ? [\n            t.nodeProps.innerHTML\n                ? e(\"div\", {\n                    domProps: {\n                        innerHTML: t._s(t.nodeProps.innerHTML),\n                    },\n                })\n                : e(\n                    \"div\",\n                    {\n                        staticClass: \"c-node-text\",\n                        style: {\n                            color:\n                                t.nodeProps.fontColor ||\n                                t.options.defaultNodeFontColor,\n                        },\n                    },\n                    [\n                        e(\"span\", {\n                            domProps: {\n                                innerHTML: t._s(t.nodeProps.text),\n                            },\n                        }),\n                    ]\n                ),\n        ]\n        : renderSlot(\n            \"node\",\n            function () {\n                return [\n                    t.nodeProps.innerHTML\n                        ? e(\"div\", {\n                            domProps: {\n                                innerHTML: t._s(t.nodeProps.innerHTML),\n                            },\n                        })\n                        : e(\n                            \"div\",\n                            {\n                                staticClass: \"c-node-text\",\n                                style: {\n                                    color:\n                                        t.nodeProps.fontColor ||\n                                        t.options.defaultNodeFontColor,\n                                },\n                            },\n                            [\n                                e(\"span\", {\n                                    domProps: {\n                                        innerHTML: t._s(t.nodeProps.text),\n                                    },\n                                }),\n                            ]\n                        ),\n                ];\n            },\n            { node: t.nodeProps }\n        ),\n]\n```\n\n----------------------------------------\n\nTITLE: Calculating Circle Point Position in TypeScript\nDESCRIPTION: This function calculates a point on the edge of a circle closest to another point. It takes the coordinates and dimensions of two circles as input and returns the coordinates of the calculated point. It uses the formula for the intersection of a line and a circle.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/play/vue3-demo/src/tmp.txt#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\ngetCirclePoint(x1, y1, x2, y2, n1w, n1h, n2w, n2h) {\n    const fx = x2 + n2w / 2;\n    const fy = y2 + n2h / 2;\n    const tx = x1 + n1w / 2;\n    const ty = y1 + n1h / 2;\n    const buff_h = fx - tx;\n    if (buff_h === 0) {\n      return { x: tx, y: ty - (n1h / 2) * (fy < ty ? 1 : -1) };\n    }\n    const buff_v = fy - ty;\n    const k = buff_v / buff_h;\n    // var m = ty - tx * k\n    const __x = Math.sqrt(1 / ((1 / (n1w / 2) ** 2) + (k ** 2 / (n1h / 2) ** 2))) * (fx < tx ? 1 : -1);\n    const __y = k * __x;\n    // this.c = Math.sqrt(this.h * this.h + this.s * this.s)\n    // // this.l = this.c - radius\n    // this.v = (this.c - n1w / 2) * this.h / this.c * -1\n    // this.t = (this.c - n1h / 2) * this.s / this.c * -1\n    // alert(this.h+\",\"+this.s+\",\"+this.c+\",\"+this.l+\",\"+this.v+\",\"+this.t);\n    return { x: tx - __x, y: ty - __y };\n  },\n```\n\n----------------------------------------\n\nTITLE: Analyze Data Tree in Relation Graph (JS)\nDESCRIPTION: This function analyzes a data tree structure to determine the strengthWithChilds_from property of each node, which is used for layout. It traverses the tree level by level, calculating the currentLevelStrengthWidthChilds and assigning it to nodes based on their level. It handles cases for bidirectional graphs based on the levelDirect parameter.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/play/vue3-demo/src/tmp.txt#_snippet_22\n\nLANGUAGE: javascript\nCODE:\n```\nanalysisDataTree(thisLevelNodes, thisDeep, levelDirect) {\n    if (levelDirect === undefined) levelDirect = 1;\n    const newLevelNodes = [];\n    let currentLevelStrengthWidthChilds = 0;\n    thisLevelNodes.forEach(thisNode => {\n      if (thisNode.lot.level === 0 || levelDirect === (thisNode.lot.level < 0 ? -1 : 1)) {\n        if (thisNode.lot.childs_size > 0) {\n          thisNode.lot.childs.forEach((thisTarget) => {\n            newLevelNodes.push(thisTarget);\n          });\n        }\n        if (thisNode.lot.parent && currentLevelStrengthWidthChilds < thisNode.lot.parent.lot.strengthWithChilds_from) {\n          currentLevelStrengthWidthChilds = thisNode.lot.parent.lot.strengthWithChilds_from;\n        }\n        thisNode.lot.strengthWithChilds_from = currentLevelStrengthWidthChilds;\n        currentLevelStrengthWidthChilds += thisNode.lot.strengthWithChilds;\n      }\n    });\n    if (newLevelNodes.length > 0) {\n      this.analysisDataTree(newLevelNodes, thisDeep + levelDirect, levelDirect);\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Calculating Rectangle Point Position in TypeScript\nDESCRIPTION: This function calculates a point on the edge of a rectangle closest to another point. It takes the coordinates and dimensions of two rectangles as input and returns the coordinates of the calculated point. It uses tangent to determine whether intersection occurs on the width or height of the rectangle.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/play/vue3-demo/src/tmp.txt#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport const RGGraphMath = {\n  getRectPoint(x1, y1, x2, y2, n1w, n1h, n2w, n2h) {\n    const fx = x1 + n1w / 2;\n    const fy = y1 + n1h / 2;\n    const tx = x2 + n2w / 2;\n    const ty = y2 + n2h / 2;\n    const _ar_x = fx < tx ? 1 : -1;\n    const _ar_y = fy < ty ? 1 : -1;\n    if (ty === fy) {\n      return { x: fx + _ar_x * n1w / 2, y: fy };\n    }\n    const __tan = Math.abs((tx - fx) / (ty - fy));\n    const rectAngle = n1w / n1h;\n    let __w = 0;\n    let __h = 0;\n    if (__tan < rectAngle) {\n      __w = _ar_x * n1h / 2 * __tan;\n      __h = _ar_y * n1h / 2;\n    } else {\n      __w = _ar_x * n1w / 2;\n      __h = _ar_y * n1w / 2 / __tan;\n    }\n    return { x: fx + __w, y: fy + __h };\n  },\n```\n\n----------------------------------------\n\nTITLE: Calculate Basic Circle Point\nDESCRIPTION: The `getCirclePointBasic` function calculates a point on a circle's circumference based on the distance (radius) from another point. It uses trigonometric functions to determine the x and y offsets from the center of the second circle to the intersection point on the circumference of the first circle. The function takes coordinates, dimensions and radius as input and returns the calculated point.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/play/vue3-demo/src/tmp.txt#_snippet_35\n\nLANGUAGE: typescript\nCODE:\n```\ngetCirclePointBasic(\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n    n1w: number,\n    n1h: number,\n    n2w: number,\n    n2h: number,\n    radius: number\n  ) {\n    const fx = x1 + n1w / 2\n    const fy = y1 + n1h / 2\n    const tx = x2 + n2w / 2\n    const ty = y2 + n2h / 2\n    const h = tx - fx\n    const s = ty - fy\n    const c = Math.sqrt(h * h + s * s)\n    const l = c - radius\n    const v = ((l * h) / c) * -1\n    const t = ((l * s) / c) * -1\n    // alert(this.h+\",\"+this.s+\",\"+this.c+\",\"+this.l+\",\"+this.v+\",\"+this.t);\n    return { x: tx + v, y: ty + t }\n  }\n```\n\n----------------------------------------\n\nTITLE: Get Text Angle\nDESCRIPTION: The `getTextAngle` function calculates the angle between two points, which can be used for orienting text. It calculates the angle using `Math.atan` and adjusts the angle based on the quadrants the points lie in. It returns the angle in degrees. The function takes the coordinates of two points (fx, fy) and (tx, ty) as input and returns the calculated angle in degrees.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/play/vue3-demo/src/tmp.txt#_snippet_39\n\nLANGUAGE: typescript\nCODE:\n```\ngetTextAngle(fx: number, fy: number, tx: number, ty: number) {\n    // 除数不能为0\n    let tan = (Math.atan(Math.abs((ty - fy) / (tx - fx))) * 180) / Math.PI\n\n    // return tan\n    if (tx > fx && ty > fy) {\n      // 第一象限\n    } else if (tx > fx && ty < fy) {\n      // 第二象限\n      tan = -tan\n    } else if (tx < fx && ty > fy) {\n      // 第三象限\n      tan = 180 - tan\n    } else {\n      tan = tan - 180\n    }\n    if (Math.abs(tan) > 90) {\n      tan = tan + 180\n    }\n    // if (tan > 90 && tan < 270) {\n    //   tan = 0\n    // }\n    return Math.round(tan)\n  }\n```\n\n----------------------------------------\n\nTITLE: Calculate Plus Circle Point\nDESCRIPTION: The `getCirclePointPlus` function calculates a point on a circle's circumference. It calculates the x and y offsets from the center of the second circle to a point determined by subtracting half the width and height of the first circle from the distance between the centers, scaled by the ratio of the distance components. The function takes coordinates and dimensions as input and returns the calculated point.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/play/vue3-demo/src/tmp.txt#_snippet_36\n\nLANGUAGE: typescript\nCODE:\n```\ngetCirclePointPlus(\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n    n1w: number,\n    n1h: number,\n    n2w: number,\n    n2h: number\n  ) {\n    const fx = x1 + n1w / 2\n    const fy = y1 + n1h / 2\n    const tx = x2 + n2w / 2\n    const ty = y2 + n2h / 2\n    const h = tx - fx\n    const s = ty - fy\n    const c = Math.sqrt(h * h + s * s)\n    // this.l = this.c - radius\n    const v = (((c - n1w / 2) * h) / c) * -1\n    const t = (((c - n1h / 2) * s) / c) * -1\n    return { x: tx + v, y: ty + t }\n  }\n```\n\n----------------------------------------\n\nTITLE: Vue.js Slot Rendering Function\nDESCRIPTION: This function `renderSlot` handles the rendering of both named slots and scoped slots in Vue.js. It checks for the existence of scoped slot functions and falls back to regular slots if no scoped slot is found.  It accepts a slot name, a fallback rendering function, props, and a bind object. If a target slot is provided in props, it creates a template element for that slot.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/packages/platforms/vue2/src/core4vue/RGNodeSlotRender-older.txt#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction renderSlot(name, fallbackRender, props, bindObject) {\n        const scopedSlotFn = this.$scopedSlots[name];\n        let nodes;\n        if (scopedSlotFn) {\n            // scoped slot\n            props = props || {};\n            if (bindObject) {\n                if (process.env.NODE_ENV !== 'production' && !isObject(bindObject)) {\n                    warn$2('slot v-bind without argument expects an Object', this);\n                }\n                props = extend(extend({}, bindObject), props);\n            }\n            nodes =\n                scopedSlotFn(props) ||\n                (isFunction(fallbackRender) ? fallbackRender() : fallbackRender);\n        }\n        else {\n            nodes =\n                this.$slots[name] ||\n                (isFunction(fallbackRender) ? fallbackRender() : fallbackRender);\n        }\n        const target = props && props.slot;\n        if (target) {\n            return this.$createElement('template', { slot: target }, nodes);\n        }\n        else {\n            return nodes;\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: Calculating Rectangle Join Point in TypeScript\nDESCRIPTION: This function calculates the join point on a rectangle based on the angle between two connected rectangles. It determines the side of the rectangle where the connection should occur based on the angle and returns the x and y coordinates of the join point.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/play/vue3-demo/src/tmp.txt#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ngetRectJoinPoint(x1, y1, x2, y2, n1w, n1h, n2w, n2h) {\n    const _from_c_x = x1 + n1w / 2;\n    const _from_c_y = y1 + n1h / 2;\n    const _to_c_x = x2 + n2w / 2;\n    const _to_c_y = y2 + n2h / 2;\n    const _atan2 = Math.round(Math.atan2(_to_c_y - _from_c_y, _to_c_x - _from_c_x) * 180 / 3.14) + 135;\n    if (_atan2 >= 0 && _atan2 < 90) { // top\n      return { x: x1 + n1w / 2, y: y1 - 5 };\n    } else if (_atan2 >= 90 && _atan2 < 180) { // right\n      return { x: x1 + n1w + 5, y: y1 + n1h / 2 };\n    } else if (_atan2 >= 180 && _atan2 < 270) { // bottom\n      return { x: x1 + n1w / 2, y: y1 + n1h + 5 };\n    } else { // left\n      return { x: x1 - 5, y: y1 + n1h / 2 };\n    }\n  },\n```\n\n----------------------------------------\n\nTITLE: Get Border Point (Rectangle or Circle)\nDESCRIPTION: The `getBorderPoint` function serves as a dispatcher to choose between calculating a border point on a circle or a rectangle. It takes a style parameter (`n1style`) that determines which function to call. If `n1style` is 0, it calls `getCirclePoint`; otherwise, it calls `getRectPoint`. It takes the coordinates and dimensions of both shapes, plus the style, as input and returns the coordinates of the calculated point.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/play/vue3-demo/src/tmp.txt#_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\ngetBorderPoint(\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n    n1w: number,\n    n1h: number,\n    n2w: number,\n    n2h: number,\n    n1style: 0 | 1\n  ) {\n    if (n1style === 0) {\n      return this.getCirclePoint(x1, y1, x2, y2, n1w, n1h, n2w, n2h)\n    } else {\n      return this.getRectPoint(x1, y1, x2, y2, n1w, n1h, n2w, n2h)\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Calculating Basic Circle Point Position in TypeScript\nDESCRIPTION: This function calculates a basic point on the edge of a circle based on a given radius. It takes the coordinates and dimensions of two circles as input, along with a radius, and returns the calculated point's coordinates. This function calculates intermediate values (h, s, c, l, v, t) and uses them for the calculation.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/play/vue3-demo/src/tmp.txt#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\ngetCirclePointBasic(x1, y1, x2, y2, n1w, n1h, n2w, n2h, radius) {\n    const fx = x1 + n1w / 2;\n    const fy = y1 + n1h / 2;\n    const tx = x2 + n2w / 2;\n    const ty = y2 + n2h / 2;\n    this.h = tx - fx;\n    this.s = ty - fy;\n    this.c = Math.sqrt(this.h * this.h + this.s * this.s);\n    this.l = this.c - radius;\n    this.v = this.l * this.h / this.c * -1;\n    this.t = this.l * this.s / this.c * -1;\n    // alert(this.h+\",\"+this.s+\",\"+this.c+\",\"+this.l+\",\"+this.v+\",\"+this.t);\n    return { x: tx + this.v, y: ty + this.t };\n  },\n```\n\n----------------------------------------\n\nTITLE: Render Slot Function (Vue)\nDESCRIPTION: This function renders a named slot, handling scoped slots and fallback rendering. It checks for a scoped slot first and renders it with provided props. If no scoped slot is found, it renders the default slot content or executes the fallbackRender function. It also supports specifying a target slot for the rendered content.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/packages/platforms/vue2/src/core4vue/RGNodeSlotRender.txt#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nfunction renderSlot(name, fallbackRender, props, bindObject) {\n    const scopedSlotFn = this.$scopedSlots[name];\n    let nodes;\n    if (scopedSlotFn) {\n        // scoped slot\n        props = props || {};\n        if (bindObject) {\n            if (process.env.NODE_ENV !== 'production' && !isObject(bindObject)) {\n                warn$2('slot v-bind without argument expects an Object', this);\n            }\n            props = extend(extend({}, bindObject), props);\n        }\n        nodes =\n            scopedSlotFn(props) ||\n            (isFunction(fallbackRender) ? fallbackRender() : fallbackRender);\n    }\n    else {\n        nodes =\n            this.$slots[name] ||\n            (isFunction(fallbackRender) ? fallbackRender() : fallbackRender);\n    }\n    const target = props && props.slot;\n    if (target) {\n        return this.$createElement('template', { slot: target }, nodes);\n    }\n    else {\n        return nodes;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Calculate Tree Point from Top Position - TypeScript\nDESCRIPTION: Calculates the coordinates (x, y) for a node in a tree structure, positioned relative to the top. It handles the case where the node is the root node.  The function takes the parent's x and y coordinates, the parent's height, index, the number of siblings, and size information as parameters. It returns an object with the x and y coordinates.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/play/vue3-demo/src/tmp.txt#_snippet_41\n\nLANGUAGE: TypeScript\nCODE:\n```\ngetTreePointFromTop(\n    c_x: number,\n    c_y: number,\n    c_height: number,\n    c_i: number,\n    c_n: number,\n    sizehelper: SizeInfo\n  ) {\n    if (!c_x) {\n      // if root\n      return {\n        x: (sizehelper.canvas_width - sizehelper.node_width) / 2,\n        y: (sizehelper.canvas_height - sizehelper.node_height) / 2 - 200,\n      }\n    }\n    const sssss = {\n      x: c_x - 300 + Math.max(600 / ((c_n === 1 ? 2 : c_n) - 1), 80) * c_i,\n      y: c_y + c_height,\n    }\n    return sssss\n  },\n```\n\n----------------------------------------\n\nTITLE: Calculate Tree Point from Left Position - TypeScript\nDESCRIPTION: Calculates the coordinates (x, y) for a node in a tree structure, positioned relative to the left. It handles the case where the node is the root node.  The function takes the parent's x and y coordinates, the parent's height, index, the number of siblings, and size information as parameters. It returns an object with the x and y coordinates.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/play/vue3-demo/src/tmp.txt#_snippet_44\n\nLANGUAGE: TypeScript\nCODE:\n```\ngetTreePointFromLeft(\n    c_x: number,\n    c_y: number,\n    c_height: number,\n    c_i: number,\n    c_n: number,\n    sizehelper: SizeInfo\n  ) {\n    if (!c_x) {\n      // if root\n      return {\n        x: (sizehelper.canvas_width - sizehelper.node_width) / 2 - 300,\n        y: (sizehelper.canvas_height - sizehelper.node_height) / 2,\n      }\n    }\n    return {\n      x: c_x + c_height,\n      y: c_y - 200 + Math.max(400 / ((c_n === 1 ? 2 : c_n) - 1), 80) * c_i,\n    }\n  },\n```\n\n----------------------------------------\n\nTITLE: Calculate Tree Point from Right Position - TypeScript\nDESCRIPTION: Calculates the coordinates (x, y) for a node in a tree structure, positioned relative to the right. It handles the case where the node is the root node. The function takes the parent's x and y coordinates, the parent's height, index, the number of siblings, and size information as parameters. It returns an object with the x and y coordinates.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/play/vue3-demo/src/tmp.txt#_snippet_42\n\nLANGUAGE: TypeScript\nCODE:\n```\ngetTreePointFromRight(\n    c_x: number,\n    c_y: number,\n    c_height: number,\n    c_i: number,\n    c_n: number,\n    sizehelper: SizeInfo\n  ) {\n    if (!c_x) {\n      // if root\n      return {\n        x: (sizehelper.canvas_width - sizehelper.node_width) / 2 + 300,\n        y: (sizehelper.canvas_height - sizehelper.node_height) / 2,\n      }\n    }\n    return {\n      x: c_x - c_height,\n      y: c_y - 200 + Math.max(400 / ((c_n === 1 ? 2 : c_n) - 1), 80) * c_i,\n    }\n  },\n```\n\n----------------------------------------\n\nTITLE: Calculate Tree Point from Bottom Position - TypeScript\nDESCRIPTION: Calculates the coordinates (x, y) for a node in a tree structure, positioned relative to the bottom. It handles the case where the node is the root node. The function takes the parent's x and y coordinates, the parent's height, index, the number of siblings, and size information as parameters. It returns an object with the x and y coordinates.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/play/vue3-demo/src/tmp.txt#_snippet_43\n\nLANGUAGE: TypeScript\nCODE:\n```\ngetTreePointFromBottom(\n    c_x: number,\n    c_y: number,\n    c_height: number,\n    c_i: number,\n    c_n: number,\n    sizehelper: SizeInfo\n  ) {\n    if (!c_x) {\n      // if root\n      return {\n        x: (sizehelper.canvas_width - sizehelper.node_width) / 2,\n        y: (sizehelper.canvas_height - sizehelper.node_height) / 2 + 200,\n      }\n    }\n    return {\n      x: c_x - 300 + Math.max(600 / ((c_n === 1 ? 2 : c_n) - 1), 80) * c_i,\n      y: c_y - c_height,\n    }\n  },\n```\n\n----------------------------------------\n\nTITLE: Calculate Vertical Rectangle Join Point\nDESCRIPTION: The `getRectVJoinPoint` function calculates a connection point on a rectangle's vertical edge. It checks the relative vertical positions of two rectangles and returns a point on the top or bottom edge of the first rectangle, depending on the positions. The function takes coordinates and dimensions as input and returns the coordinates of the calculated connection point.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/play/vue3-demo/src/tmp.txt#_snippet_30\n\nLANGUAGE: typescript\nCODE:\n```\ngetRectVJoinPoint(\n    x1: number,\n    y1: number,\n    _x2: number,\n    y2: number,\n    n1w: number,\n    n1h: number,\n    _n2w: number,\n    n2h: number\n  ) {\n    const _hW = n1w / 2\n    // var _hW = n1w / 2\n    if (y1 + n1h < y2) {\n      return { y: y1 + n1h + 5, x: x1 + _hW }\n    } else if (y1 + n1h < y2 + n2h) {\n      return { y: y1 - 5, x: x1 + _hW }\n    } else {\n      return { y: y1 - 5, x: x1 + _hW }\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Calculate Circle Point\nDESCRIPTION: The `getCirclePoint` function calculates a point on a circle's circumference based on the relative positions of two shapes (treated as circles). It takes the coordinates and dimensions of the two shapes as input and returns the coordinates of the calculated point on the first circle. The function uses trigonometric calculations to determine the intersection point.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/play/vue3-demo/src/tmp.txt#_snippet_33\n\nLANGUAGE: typescript\nCODE:\n```\ngetCirclePoint(\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n    n1w: number,\n    n1h: number,\n    n2w: number,\n    n2h: number\n  ) {\n    const fx = x2 + n2w / 2\n    const fy = y2 + n2h / 2\n    const tx = x1 + n1w / 2\n    const ty = y1 + n1h / 2\n    const buff_h = fx - tx\n    if (buff_h === 0) {\n      return { x: tx, y: ty - (n1h / 2) * (fy < ty ? 1 : -1) }\n    }\n    const buff_v = fy - ty\n    const k = buff_v / buff_h\n    // var m = ty - tx * k\n    const __x =\n      Math.sqrt(1 / (1 / (n1w / 2) ** 2 + k ** 2 / (n1h / 2) ** 2)) *\n      (fx < tx ? 1 : -1)\n    const __y = k * __x\n    // this.c = Math.sqrt(this.h * this.h + this.s * this.s)\n    // // this.l = this.c - radius\n    // this.v = (this.c - n1w / 2) * this.h / this.c * -1\n    // this.t = (this.c - n1h / 2) * this.s / this.c * -1\n    // alert(this.h+\",\"+this.s+\",\"+this.c+\",\"+this.l+\",\"+this.v+\",\"+this.t);\n    return { x: tx - __x, y: ty - __y }\n  }\n```\n\n----------------------------------------\n\nTITLE: Calculate Horizontal Rectangle Join Point\nDESCRIPTION: The `getRectHJoinPoint` function calculates a connection point on a rectangle's horizontal edge. It checks the relative horizontal positions of two rectangles and returns a point on the left or right edge of the first rectangle, depending on the positions. It takes coordinates and dimensions as input and returns the coordinates of the calculated connection point.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/play/vue3-demo/src/tmp.txt#_snippet_29\n\nLANGUAGE: typescript\nCODE:\n```\ngetRectHJoinPoint(\n    x1: number,\n    y1: number,\n    x2: number,\n    _y2: number,\n    n1w: number,\n    n1h: number,\n    n2w: number\n  ) {\n    const _hH = n1h / 2\n    // var _hW = n1w / 2\n    if (x1 + n1w < x2) {\n      return { x: x1 + n1w + 5, y: y1 + _hH }\n    } else if (x1 + n1w < x2 + n2w) {\n      return { x: x1 - 5, y: y1 + _hH }\n    } else {\n      return { x: x1 - 5, y: y1 + _hH }\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Calculating Tree Point from Top in TypeScript\nDESCRIPTION: This function calculates the position of a node in a tree structure, starting from the top. If it's the root node (c_x is null), it positions it at the top-center of the canvas. Otherwise, it calculates the x and y coordinates based on the parent node's position, height, index, number of siblings, and size helper object.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/play/vue3-demo/src/tmp.txt#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\ngetTreePointFromTop(c_x, c_y, c_height, c_i, c_n, sizehelper) {\n    if (!c_x) { // if root\n      return {\n        x: (sizehelper.canvas_width - sizehelper.node_width) / 2,\n        y: (sizehelper.canvas_height - sizehelper.node_height) / 2 - 200\n      };\n    }\n    const sssss = {\n      x: c_x - 300 + (Math.max(600 / ((c_n === 1 ? 2 : c_n) - 1), 80)) * c_i,\n      y: c_y + c_height\n    };\n    return sssss;\n  },\n```\n\n----------------------------------------\n\nTITLE: Calculating Enhanced Circle Point in TypeScript\nDESCRIPTION: This function calculates a point on the edge of a circle, using a more advanced method compared to `getCirclePointBasic`. It calculates intermediate values (h, s, c, v, t) and uses them for the final calculation of the x and y coordinates.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/play/vue3-demo/src/tmp.txt#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\ngetCirclePointPlus(x1, y1, x2, y2, n1w, n1h, n2w, n2h) {\n    const fx = x1 + n1w / 2;\n    const fy = y1 + n1h / 2;\n    const tx = x2 + n2w / 2;\n    const ty = y2 + n2h / 2;\n    this.h = tx - fx;\n    this.s = ty - fy;\n    this.c = Math.sqrt(this.h * this.h + this.s * this.s);\n    // this.l = this.c - radius\n    this.v = (this.c - n1w / 2) * this.h / this.c * -1;\n    this.t = (this.c - n1h / 2) * this.s / this.c * -1;\n    // alert(this.h+\",\"+this.s+\",\"+this.c+\",\"+this.l+\",\"+this.v+\",\"+this.t);\n    return { x: tx + this.v, y: ty + this.t };\n  },\n```\n\n----------------------------------------\n\nTITLE: Calculating Tree Point from Right in TypeScript\nDESCRIPTION: This function calculates the position of a node in a tree structure, starting from the right. If it's the root node (c_x is null), it positions it at the right-center of the canvas. Otherwise, it calculates the x and y coordinates based on the parent node's position, height, index, number of siblings, and size helper object.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/play/vue3-demo/src/tmp.txt#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\ngetTreePointFromRight(c_x, c_y, c_height, c_i, c_n, sizehelper) {\n    if (!c_x) { // if root\n      return {\n        x: (sizehelper.canvas_width - sizehelper.node_width) / 2 + 300,\n        y: (sizehelper.canvas_height - sizehelper.node_height) / 2\n      };\n    }\n    return {\n      x: c_x - c_height,\n      y: c_y - 200 + (Math.max(400 / ((c_n === 1 ? 2 : c_n) - 1), 80)) * c_i\n    };\n  },\n```\n\n----------------------------------------\n\nTITLE: Calculating Tree Point from Bottom in TypeScript\nDESCRIPTION: This function calculates the position of a node in a tree structure, starting from the bottom. If it's the root node (c_x is null), it positions it at the bottom-center of the canvas. Otherwise, it calculates the x and y coordinates based on the parent node's position, height, index, number of siblings, and size helper object.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/play/vue3-demo/src/tmp.txt#_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\ngetTreePointFromBottom(c_x, c_y, c_height, c_i, c_n, sizehelper) {\n    if (!c_x) { // if root\n      return {\n        x: (sizehelper.canvas_width - sizehelper.node_width) / 2,\n        y: (sizehelper.canvas_height - sizehelper.node_height) / 2 + 200\n      };\n    }\n    return {\n      x: c_x - 300 + (Math.max(600 / ((c_n === 1 ? 2 : c_n) - 1), 80)) * c_i,\n      y: c_y - c_height\n    };\n  },\n```\n\n----------------------------------------\n\nTITLE: Calculating Horizontal Rectangle Join Point in TypeScript\nDESCRIPTION: This function determines the horizontal join point of a rectangle.  It returns a point on the left or right side of the first rectangle depending on its position relative to the second rectangle. It returns the x and y coordinates of the connection point.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/play/vue3-demo/src/tmp.txt#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ngetRectHJoinPoint(x1, y1, x2, y2, n1w, n1h, n2w) {\n    const _hH = n1h / 2;\n    // var _hW = n1w / 2\n    if ((x1 + n1w) < x2) {\n      return { x: x1 + n1w + 5, y: y1 + _hH };\n    } else if ((x1 + n1w) < (x2 + n2w)) {\n      return { x: x1 - 5, y: y1 + _hH };\n    } else {\n      return { x: x1 - 5, y: y1 + _hH };\n    }\n  },\n```\n\n----------------------------------------\n\nTITLE: Calculating Text Angle in TypeScript\nDESCRIPTION: This function calculates the angle of a text label based on the coordinates of two points. It uses the `Math.atan` function to determine the angle and adjusts the angle based on the quadrant in which the two points lie. It returns the angle in degrees, rounded to the nearest integer.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/play/vue3-demo/src/tmp.txt#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\ngetTextAngle(fx, fy, tx, ty) {\n    // 除数不能为0\n    let tan = Math.atan(Math.abs((ty - fy) / (tx - fx))) * 180 / Math.PI;\n\n    // return tan\n    if (tx > fx && ty > fy) { // 第一象限\n    } else if (tx > fx && ty < fy) { // 第二象限\n      tan = -tan;\n    } else if (tx < fx && ty > fy) { // 第三象限\n      tan = 180 - tan;\n    } else {\n      tan = tan - 180;\n    }\n    if (Math.abs(tan) > 90) {\n      tan = tan + 180;\n    }\n    // if (tan > 90 && tan < 270) {\n    //   tan = 0\n    // }\n    return Math.round(tan);\n  },\n```\n\n----------------------------------------\n\nTITLE: Calculate Oval Point\nDESCRIPTION: The `getOvalPoint` function calculates a point on the circumference of an oval. It uses the provided center coordinates, radius, index, and total number of points to calculate the x and y coordinates using sine and cosine functions. The function takes center coordinates, radius, index and total points as input and returns the calculated point.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/play/vue3-demo/src/tmp.txt#_snippet_37\n\nLANGUAGE: typescript\nCODE:\n```\ngetOvalPoint(\n    c_x: number,\n    c_y: number,\n    c_r: number,\n    c_i: number,\n    c_n: number\n  ) {\n    return {\n      x:\n        c_x +\n        c_r *\n          Math.sin(\n            ((STAITC_MAP_ANGLE + c_i * (360 / c_n) + 0) * Math.PI) / 180\n          ),\n      y:\n        c_y +\n        c_r *\n          Math.cos(\n            ((STAITC_MAP_ANGLE + c_i * (360 / c_n) + 0) * Math.PI) / 180\n          ) *\n          -1,\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Check Node Visibility in RGGraphMath (TypeScript)\nDESCRIPTION: This method recursively checks if a given `RGNode` is allowed to be shown based on its `isShow`, `isHide`, and parent node's visibility. It traverses up the parent chain to ensure all ancestors are visible before allowing the current node to be displayed. Relies on RGNode type.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/play/vue3-demo/src/tmp.txt#_snippet_50\n\nLANGUAGE: typescript\nCODE:\n```\nisAllowShowNode(thisNode: RGNode, deep = 0): boolean {\n    // if (deep > 3) return true\n    const _r =\n      thisNode.isShow !== false &&\n      thisNode.isHide !== true &&\n      (!thisNode.lot.parent ||\n        this.isAllowShowNode(thisNode.lot.parent, deep + 1) === true)\n    return _r\n  },\n```\n\n----------------------------------------\n\nTITLE: Conduct Strength to Parents in RGGraphMath (TypeScript)\nDESCRIPTION: This method recursively updates the `strengthWithChilds` property of parent nodes in a relation graph. It starts from a given node and traverses upwards to its ancestors, incrementing their `strengthWithChilds` value. This function is essential for establishing hierarchical relationships based on child strength.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/play/vue3-demo/src/tmp.txt#_snippet_48\n\nLANGUAGE: typescript\nCODE:\n```\nconductStrengthToParents(node: RGNode) {\n    if (!node.lot.parent) {\n      if (node.lot.parent && node.lot.parent.lot) {\n        node.lot.parent.lot.strengthWithChilds = 0\n      }\n      node.lot.parent.lot.strengthWithChilds += 1\n      this.conductStrengthToParents(node.lot.parent)\n    }\n  },\n```\n\n----------------------------------------\n\nTITLE: Selecting Border Point Calculation Method in TypeScript\nDESCRIPTION: This function selects the appropriate border point calculation method based on the specified style. It determines whether to use `getCirclePoint` or `getRectPoint` based on the value of `n1style` and returns the result of the chosen function.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/play/vue3-demo/src/tmp.txt#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\ngetBorderPoint(x1, y1, x2, y2, n1w, n1h, n2w, n2h, n1style) {\n    if (n1style === 0) {\n      return this.getCirclePoint(x1, y1, x2, y2, n1w, n1h, n2w, n2h);\n    } else {\n      return this.getRectPoint(x1, y1, x2, y2, n1w, n1h, n2w, n2h);\n    }\n  },\n```\n\n----------------------------------------\n\nTITLE: Get Tree Point From Top\nDESCRIPTION: The `getTreePointFromTop` function calculates a point for a tree-like structure, positioned from the top. It takes center coordinates, height, index, total number of nodes, and size information as input and returns the coordinates of the calculated point. If the x coordinate is null (indicating a root node), it returns null.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/play/vue3-demo/src/tmp.txt#_snippet_40\n\nLANGUAGE: typescript\nCODE:\n```\ngetTreePointFromTop(\n    c_x: number,\n    c_y: number,\n    c_height: number,\n    c_i: number,\n    c_n: number,\n    sizehelper: SizeInfo\n  ) {\n    if (!c_x) {\n      // if root\n      return {\n```\n\n----------------------------------------\n\nTITLE: Calculating Vertical Rectangle Join Point in TypeScript\nDESCRIPTION: This function determines the vertical join point of a rectangle. It returns a point on the top or bottom side of the first rectangle depending on its position relative to the second rectangle. It returns the x and y coordinates of the connection point.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/play/vue3-demo/src/tmp.txt#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ngetRectVJoinPoint(x1, y1, x2, y2, n1w, n1h, n2w, n2h) {\n    const _hW = n1w / 2;\n    // var _hW = n1w / 2\n    if ((y1 + n1h) < y2) {\n      return { y: y1 + n1h + 5, x: x1 + _hW };\n    } else if ((y1 + n1h) < (y2 + n2h)) {\n      return { y: y1 - 5, x: x1 + _hW };\n    } else {\n      return { y: y1 - 5, x: x1 + _hW };\n    }\n  },\n```\n\n----------------------------------------\n\nTITLE: Selecting Border Point for Multi-Line in TypeScript\nDESCRIPTION: This function selects the appropriate border point calculation method for multi-line scenarios. It determines whether to use `getCirclePoint4MultiLine` or `getRectPoint` based on the value of `n1style` and returns the result of the chosen function.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/play/vue3-demo/src/tmp.txt#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\ngetBorderPoint4MultiLine(x1, y1, x2, y2, n1w, n1h, n2w, n2h, n1style, isReserve, allSize, indexOfAll) {\n    if (n1style === 0) {\n      return this.getCirclePoint4MultiLine(x1, y1, x2, y2, n1w, n1h, n2w, n2h, isReserve, allSize, indexOfAll);\n    } else {\n      return this.getRectPoint(x1, y1, x2, y2, n1w, n1h, n2w, n2h);\n    }\n  },\n```\n\n----------------------------------------\n\nTITLE: Calculate Y Coordinate for Node Position in Relation Graph (JS)\nDESCRIPTION: This code snippet calculates the y-coordinate for positioning a node in a relation graph layout. It takes into account the center y-coordinate (c_y), the number of nodes (c_n), and the index of the current node (c_i). It uses Math.max to determine the spacing between nodes, ensuring a minimum spacing of 80 pixels.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/play/vue3-demo/src/tmp.txt#_snippet_18\n\nLANGUAGE: javascript\nCODE:\n```\ny: c_y - 200 + (Math.max(400 / ((c_n === 1 ? 2 : c_n) - 1), 80)) * c_i\n```\n\n----------------------------------------\n\nTITLE: Get Angle Type (Quadrant)\nDESCRIPTION: The `getAngleType` function determines the quadrant of a point based on its x and y coordinates. It returns an integer representing the quadrant number (1, 2, 3, or 4). The function takes x and y coordinates as input and returns the quadrant number.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/play/vue3-demo/src/tmp.txt#_snippet_38\n\nLANGUAGE: typescript\nCODE:\n```\ngetAngleType(buffer_x: number, buffer_y: number) {\n    if (buffer_x >= 0 && buffer_y >= 0) {\n      // 第一象限\n      return 1\n    } else if (buffer_x < 0 && buffer_y >= 0) {\n      // 第二象限\n      return 2\n    } else if (buffer_x < 0 && buffer_y < 0) {\n      // 第三象限\n      return 3\n    } else if (buffer_x >= 0 && buffer_y < 0) {\n      // 第三象限\n      return 4\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Calculating Oval Point Position in TypeScript\nDESCRIPTION: This function calculates a point on an oval. It uses trigonometric functions (sin and cos) to determine the x and y coordinates based on the center, radius, index, and total number of points.  It returns the x and y coordinates of the calculated point.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/play/vue3-demo/src/tmp.txt#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\ngetOvalPoint(c_x, c_y, c_r, c_i, c_n) {\n    return {\n      x: c_x + c_r * Math.sin((STAITC_MAP_ANGLE + (c_i * (360 / c_n)) + 0) * Math.PI / 180),\n      y: c_y + c_r * Math.cos((STAITC_MAP_ANGLE + (c_i * (360 / c_n)) + 0) * Math.PI / 180) * -1\n    };\n  },\n```\n\n----------------------------------------\n\nTITLE: Get Node Distance in Relation Graph (JS)\nDESCRIPTION: This function calculates the Euclidean distance between two nodes given their x and y coordinates (fx, fy) and (tx, ty). It uses the Pythagorean theorem to compute the hypotenuse, representing the distance between the nodes.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/play/vue3-demo/src/tmp.txt#_snippet_24\n\nLANGUAGE: javascript\nCODE:\n```\nexport const getNodeDistance = (fx, fy, tx, ty) => {\n  const buff_x = fx - tx;\n  const buff_y = fy - ty;\n  const bSquare = buff_x ** 2;\n  const pSquare = buff_y ** 2;\n  const sum = bSquare + pSquare;\n  const hypotenuse = Math.sqrt(sum);\n  return hypotenuse;\n};\n```\n\n----------------------------------------\n\nTITLE: Calculate Node Distance (TypeScript)\nDESCRIPTION: This function calculates the Euclidean distance between two points in a 2D space, given their x and y coordinates. It uses the standard distance formula, computing the square root of the sum of squared differences in x and y coordinates.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/play/vue3-demo/src/tmp.txt#_snippet_51\n\nLANGUAGE: typescript\nCODE:\n```\nexport const getNodeDistance = (\n  fx: number,\n  fy: number,\n  tx: number,\n  ty: number\n) => {\n  const buff_x = fx - tx\n  const buff_y = fy - ty\n  const bSquare = buff_x ** 2\n  const pSquare = buff_y ** 2\n  const sum = bSquare + pSquare\n  const hypotenuse = Math.sqrt(sum)\n  return hypotenuse\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating Tree Point from Left in TypeScript\nDESCRIPTION: This function calculates the position of a node in a tree structure, starting from the left. If it's the root node (c_x is null), it positions it at the left-center of the canvas. Otherwise, it returns the x and y coordinates to position the tree node.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/play/vue3-demo/src/tmp.txt#_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\ngetTreePointFromLeft(c_x, c_y, c_height, c_i, c_n, sizehelper) {\n    if (!c_x) { // if root\n      return {\n        x: (sizehelper.canvas_width - sizehelper.node_width) / 2 - 300,\n        y: (sizehelper.canvas_height - sizehelper.node_height) / 2\n      };\n    }\n    return {\n\n```\n\n----------------------------------------\n\nTITLE: Calculate Circle Point for Multi-Line\nDESCRIPTION: The `getCirclePoint4MultiLine` function calculates a point on a circle's circumference for multi-line connections. It takes parameters for determining the position of the line within the multi-line arrangement (isReserve, allSize, indexOfAll). It calculates the offset based on these parameters and the relative positions of the two shapes. It takes coordinates, dimensions and multi-line parameters as input and returns the calculated point.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/play/vue3-demo/src/tmp.txt#_snippet_34\n\nLANGUAGE: typescript\nCODE:\n```\ngetCirclePoint4MultiLine(\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n    n1w: number,\n    n1h: number,\n    n2w: number,\n    n2h: number,\n    isReserve: boolean,\n    allSize: number,\n    indexOfAll: number\n  ) {\n    if (isReserve) {\n      indexOfAll = allSize - indexOfAll - 1\n    }\n    const to_x = x2 + n2w / 2\n    const to_y = y2 + n2h / 2\n    const from_x = x1 + n1w / 2\n    const from_y = y1 + n1h / 2\n    const buff_h = to_x - from_x\n    if (buff_h === 0) {\n      return { x: from_x, y: from_y - (n1h / 2) * (to_y < from_y ? 1 : -1) }\n    }\n    const distance = (40 / (allSize + 1)) * (indexOfAll + 1) - 20\n    const buff_v = to_y - from_y\n    const b = (Math.sqrt(buff_h ** 2 + buff_v ** 2) * distance) / buff_h\n    const k = buff_v / buff_h\n    const m = n1w / 2\n    const n = n1h / 2\n    const __wow = to_x < from_x ? 1 : -1\n    const __x =\n      (-1 * m ** 2 * k * b +\n        (m * n * Math.sqrt(n ** 2 + k ** 2 * m ** 2 - b ** 2)) / __wow) /\n      (n ** 2 + m ** 2 * k ** 2)\n    const __y = k * __x + b\n    return { x: from_x - __x, y: from_y - __y }\n  }\n```\n\n----------------------------------------\n\nTITLE: Determining Angle Type by Quadrant in TypeScript\nDESCRIPTION: This function determines the quadrant of a point based on its x and y coordinates. It returns an integer representing the quadrant number (1, 2, 3, or 4).\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/play/vue3-demo/src/tmp.txt#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\ngetAngleType(buffer_x, buffer_y) {\n    if (buffer_x >= 0 && buffer_y >= 0) { // 第一象限\n      return 1;\n    } else if (buffer_x < 0 && buffer_y >= 0) { // 第二象限\n      return 2;\n    } else if (buffer_x < 0 && buffer_y < 0) { // 第三象限\n      return 3;\n    } else if (buffer_x >= 0 && buffer_y < 0) { // 第三象限\n      return 4;\n    }\n  },\n```\n\n----------------------------------------\n\nTITLE: Conduct Strength To Parents in Relation Graph (JS)\nDESCRIPTION: This function recursively conducts strength values from a node to its parents in the relation graph. It increments the strengthWithChilds property of each parent node. This is part of the layout algorithm to propagate strength information up the tree.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/play/vue3-demo/src/tmp.txt#_snippet_21\n\nLANGUAGE: javascript\nCODE:\n```\nconductStrengthToParents(node) {\n    if (node.lot.parent) {\n      node.lot.parent.lot.strengthWithChilds += 1;\n      this.conductStrengthToParents(node.lot.parent);\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Conduct Strength to Parents - TypeScript\nDESCRIPTION: Recursively conducts the strength of a node to its parents in the relation graph. If a parent exists, it propagates the strength upwards, accumulating the strengthWithChilds value. The process continues until it reaches the root node or a node that already has its strengthWithChilds value calculated.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/play/vue3-demo/src/tmp.txt#_snippet_47\n\nLANGUAGE: TypeScript\nCODE:\n```\nconductStrengthToParents(node: RGNode) {\n    if (node.lot.parent) {\n```\n\n----------------------------------------\n\nTITLE: Get Border Point for Multi-Line (Rectangle or Circle)\nDESCRIPTION: The `getBorderPoint4MultiLine` function is similar to `getBorderPoint`, but it is designed to handle multi-line connections. It also takes a style parameter (`n1style`) to determine whether to calculate the border point on a circle or a rectangle. If `n1style` is 0, it calls `getCirclePoint4MultiLine`; otherwise, it calls `getRectPoint`. It includes additional parameters for multi-line positioning (isReserve, allSize, indexOfAll).\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/play/vue3-demo/src/tmp.txt#_snippet_32\n\nLANGUAGE: typescript\nCODE:\n```\ngetBorderPoint4MultiLine(\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n    n1w: number,\n    n1h: number,\n    n2w: number,\n    n2h: number,\n    n1style: 0 | 1,\n    isReserve: boolean,\n    allSize: number,\n    indexOfAll: number\n  ) {\n    if (n1style === 0) {\n      return this.getCirclePoint4MultiLine(\n        x1,\n        y1,\n        x2,\n        y2,\n        n1w,\n        n1h,\n        n2w,\n        n2h,\n        isReserve,\n        allSize,\n        indexOfAll\n      )\n    } else {\n      return this.getRectPoint(x1, y1, x2, y2, n1w, n1h, n2w, n2h)\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Importing relation-graph in JavaScript\nDESCRIPTION: These commands import the installed relation-graph component, depending on whether you're using Vue 2, Vue 3, or React. These imports allow you to use the RelationGraph component in your code.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/README.md#_snippet_1\n\nLANGUAGE: shell script\nCODE:\n```\n# Vue2： import RelationGraph from 'relation-graph'\n# Vue3： import RelationGraph from 'relation-graph-vue3'\n# React： import RelationGraph from 'relation-graph-react'\n```\n\n----------------------------------------\n\nTITLE: Installing relation-graph with npm\nDESCRIPTION: These commands install the relation-graph component for Vue 2, Vue 3, and React using npm. These libraries enable displaying relationship data graphs within Vue and React applications.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/README.md#_snippet_0\n\nLANGUAGE: shell script\nCODE:\n```\n# Vue2\nnpm install --save relation-graph\n# Vue3\nnpm install --save relation-graph-vue3\n# React\nnpm install --save relation-graph-react\n```\n\n----------------------------------------\n\nTITLE: Installing relation-graph via npm\nDESCRIPTION: This command installs the relation-graph package from npm, which is required to use the component in your project.  This package supports Vue 2, Vue 3, and React.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/README-zh.md#_snippet_0\n\nLANGUAGE: shell script\nCODE:\n```\nnpm install --save relation-graph\n```\n\n----------------------------------------\n\nTITLE: Calculating Circle Point for Multi-Line in TypeScript\nDESCRIPTION: This function calculates a point on the edge of a circle for multi-line connections, taking into account whether the lines are reversed and their index in the set of lines.  It returns the x and y coordinates of the point.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/play/vue3-demo/src/tmp.txt#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\ngetCirclePoint4MultiLine(x1, y1, x2, y2, n1w, n1h, n2w, n2h, isReserve, allSize, indexOfAll) {\n    if (isReserve) {\n      indexOfAll = allSize - indexOfAll - 1;\n    }\n    const to_x = x2 + n2w / 2;\n    const to_y = y2 + n2h / 2;\n    const from_x = x1 + n1w / 2;\n    const from_y = y1 + n1h / 2;\n    const buff_h = to_x - from_x;\n    if (buff_h === 0) {\n      return { x: from_x, y: from_y - (n1h / 2) * (to_y < from_y ? 1 : -1) };\n    }\n    const distance = ((40 / (allSize + 1)) * (indexOfAll + 1)) - 20;\n    const buff_v = to_y - from_y;\n    const b = Math.sqrt(buff_h ** 2 + buff_v ** 2) * distance / buff_h;\n    const k = buff_v / buff_h;\n    const m = n1w / 2;\n    const n = n1h / 2;\n    const __wow = (to_x < from_x ? 1 : -1);\n    const __x = (-1 * (m ** 2) * k * b + (m * n * Math.sqrt((n ** 2 + (k ** 2) * (m ** 2) - b ** 2), 2)) / __wow) / (n ** 2 + m ** 2 * k ** 2);\n    // var __x = Math.sqrt(1 / ((1 / Math.pow(n1w / 2, 2)) + (k ** 2 / Math.pow(n1h / 2, 2)))) * (to_x < from_x ? 1 : -1)\n    const __y = k * __x + b;\n    // this.c = Math.sqrt(this.h * this.h + this.s * this.s)\n    // // this.l = this.c - radius\n    // this.v = (this.c - n1w / 2) * this.h / this.c * -1\n    // this.t = (this.c - n1h / 2) * this.s / this.c * -1\n    // alert(this.h+\",\"+this.s+\",\"+this.c+\",\"+this.l+\",\"+this.v+\",\"+this.t);\n    return { x: from_x - __x, y: from_y - __y };\n  },\n```\n\n----------------------------------------\n\nTITLE: Export RGGraphMath Object as Default (JS)\nDESCRIPTION: This line exports the RGGraphMath object as the default export of the module, making its functions available for use in other modules that import it.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/play/vue3-demo/src/tmp.txt#_snippet_25\n\nLANGUAGE: javascript\nCODE:\n```\nexport default RGGraphMath;\n```\n\n----------------------------------------\n\nTITLE: Conditional Vue.js Component Rendering\nDESCRIPTION: This snippet conditionally renders a Vue.js component based on the `oldVueVersion` and `oldVueVersionUseSlot` options. It uses ternary operators to decide which rendering path to take, either using innerHTML or creating a nested div structure with specific styling and text content. It uses the `_s` method for string conversion.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/packages/platforms/vue2/src/core4vue/RGNodeSlotRender-older.txt#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n[\n    t.options.oldVueVersion && !t.options.oldVueVersionUseSlot\n        ? [\n            t.nodeProps.innerHTML\n                ? e(\"div\", {\n                    domProps: {\n                        innerHTML: t._s(t.nodeProps.innerHTML),\n                    },\n                })\n                : e(\n                    \"div\",\n                    {\n                        staticClass: \"c-node-text\",\n                        style: {\n                            color:\n                                t.nodeProps.fontColor ||\n                                t.options.defaultNodeFontColor,\n                        },\n                    },\n                    [\n                        e(\"span\", {\n                            domProps: {\n                                innerHTML: t._s(t.nodeProps.text),\n                            },\n                        }),\n                    ]\n                ),\n        ]\n        : t._t(\n            \"node\",\n            [\n                t.nodeProps.innerHTML\n                    ? e(\"div\", {\n                        domProps: {\n                            innerHTML: t._s(t.nodeProps.innerHTML),\n                        },\n                    })\n                    : e(\n                        \"div\",\n                        {\n                            staticClass: \"c-node-text\",\n                            style: {\n                                color:\n                                    t.nodeProps.fontColor ||\n                                    t.options.defaultNodeFontColor,\n                            },\n                        },\n                        [\n                            e(\"span\", {\n                                domProps: {\n                                    innerHTML: t._s(t.nodeProps.text),\n                                },\n                            }),\n                        ]\n                    ),\n            ],\n            { node: t.nodeProps }\n        ),\n]\n```\n\n----------------------------------------\n\nTITLE: Importing relation-graph-vue3 module\nDESCRIPTION: This code snippet demonstrates how to import the `relation-graph-vue3` module using `require`. The imported module is assigned to the `elementPlus` variable.\nSOURCE: https://github.com/seeksdream/relation-graph/blob/master/packages/platforms/vue3/README.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst elementPlus = require('relation-graph-vue3');\n```"
  }
]