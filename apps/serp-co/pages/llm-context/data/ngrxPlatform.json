[
  {
    "owner": "ngrx",
    "repo": "platform",
    "content": "TITLE: Updating NgRx Packages with Angular CLI (Shell)\nDESCRIPTION: This shell command utilizes the Angular CLI (`ng update`) to update the `@ngrx/store` package specifically to version 15. Running this command also triggers available NgRx migration schematics, which help automate code adjustments required due to breaking changes. Requires Angular CLI version 15.x or higher.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v15.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nng update @ngrx/store@15\n```\n\n----------------------------------------\n\nTITLE: Defining a Todos SignalStore with withEntities Feature in NgRx (TypeScript)\nDESCRIPTION: This snippet sets up an NgRx SignalStore named TodosStore with entity management for Todo objects using the withEntities feature. It imports and applies withEntities to manage the entity state, requiring each Todo to have an 'id' property. The feature exposes signals for ids, entity mappings, and the entities array. No dependencies beyond @ngrx/signals and @ngrx/signals/entities are needed; the Todo type must be defined. Expected input is an entity type with a numeric 'id', and the output is a store with enhanced entity management properties.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/entity-management.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { computed } from '@angular/core';\nimport { signalStore } from '@ngrx/signals';\nimport { withEntities } from '@ngrx/signals/entities';\n\ntype Todo = {\n  id: number;\n  text: string;\n  completed: boolean;\n};\n\nexport const TodosStore = signalStore(\n  withEntities<Todo>()\n);\n\n```\n\n----------------------------------------\n\nTITLE: Using createSelector to derive data from multiple state slices\nDESCRIPTION: Combines 'selectedUser' and 'allBooks' slices with 'createSelector' to generate a list of books relevant to the selected user. Ensures the derived data stays current with state updates, highlighting 'createSelector's composability.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/selectors.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { createSelector } from '@ngrx/store';\n\nexport interface User {\n  id: number;\n  name: string;\n}\n\nexport interface Book {\n  id: number;\n  userId: number;\n  name: string;\n}\n\nexport interface AppState {\n  selectedUser: User;\n  allBooks: Book[];\n}\n\nexport const selectUser = (state: AppState) => state.selectedUser;\nexport const selectAllBooks = (state: AppState) => state.allBooks;\n\nexport const selectVisibleBooks = createSelector(\n  selectUser,\n  selectAllBooks,\n  (selectedUser: User, allBooks: Book[]) => {\n    if (selectedUser && allBooks) {\n      return allBooks.filter((book: Book) => book.userId === selectedUser.id);\n    } else {\n      return allBooks;\n    }\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: Using BooksStore in an Angular Component for State Management\nDESCRIPTION: This snippet demonstrates integrating the BooksStore within an Angular component, binding state signals to the template, handling user input events to trigger state updates, and invoking loadByQuery to fetch data reactively whenever the query changes. It showcases dependency injection, component lifecycle hooks, and signal subscriptions.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/index.md#_snippet_11\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { ChangeDetectionStrategy, Component, inject, OnInit } from '@angular/core';\nimport { BooksFilterComponent } from './books-filter.component';\nimport { BookListComponent } from './book-list.component';\nimport { BooksStore } from './books.store';\n\n@Component({\n  imports: [BooksFilterComponent, BookListComponent],\n  template: `\n    &lt;h1&gt;Books ({{ store.booksCount() }})&lt;/h1&gt;\n\n    &lt;ngrx-books-filter\n      [query]=\"store.filter.query()\"\n      [order]=\"store.filter.order()\"\n      (queryChange)=\"store.updateQuery($event)\"\n      (orderChange)=\"store.updateOrder($event)\"\n    /&gt;\n\n    &lt;ngrx-book-list\n      [books]=\"store.sortedBooks()\"\n      [isLoading]=\"store.isLoading()\"\n    /&gt;\n  `,\n  providers: [BooksStore],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class BooksComponent implements OnInit {\n  readonly store = inject(BooksStore);\n\n  ngOnInit(): void {\n    const query = this.store.filter.query;\n    // 👇 Re-fetch books whenever the value of query signal changes.\n    this.store.loadByQuery(query);\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining Reducer Function to Handle Counter State in NgRx (TypeScript)\nDESCRIPTION: Contains a pure reducer function that updates the counter state in response to dispatched actions like increment, decrement, and reset. It accepts the current state and the action object, then returns the new updated state. This function must be pure and avoids side effects. The reducer forms the core logic that governs how the state changes based on action types.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/index.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\n\n```\n\n----------------------------------------\n\nTITLE: Defining NgRx Selector with Strict Projector in V15 (TypeScript)\nDESCRIPTION: Illustrates the behavior of `createSelector` in NgRx v15, where the `projector` function is now type-safe by default. Calling `mySelector.projector()` directly without arguments matching the input selector types results in a compile-time type error. The specific type `projector(s1: string, s2: number): number` is enforced.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v15.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst mySelector = createSelector(\n  () => 'one',\n  () => 2,\n  (one, two) => 3\n)\n\nmySelector.projector() // <- Results in type error. Type is projector(s1: string, s2: number): number\n```\n\n----------------------------------------\n\nTITLE: Initializing MockStore for Unit Testing NgRx Store with provideMockStore in TypeScript\nDESCRIPTION: This snippet demonstrates registering the MockStore in Angular unit tests using provideMockStore() in the TestBed configuration. It initializes a mocked Store with an initial state and injects both the MockStore and the tested AuthGuard service. The tests validate guard behavior based on the logged-in state by expecting observable outputs, leveraging jasmine-marbles for marble testing of observables. Dependencies include Angular core testing utilities and @ngrx/store/testing.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/testing.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { TestBed } from '@angular/core/testing';\nimport { provideMockStore, MockStore } from '@ngrx/store/testing';\nimport { cold } from 'jasmine-marbles';\n\nimport { AuthGuard } from '../guards/auth.guard';\n\ndescribe('Auth Guard', () => {\n  let guard: AuthGuard;\n  let store: MockStore;\n  const initialState = { loggedIn: false };\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      imports: [\n        // any modules needed\n      ],\n      providers: [\n        AuthGuard,\n        provideMockStore({ initialState }),\n        // other providers\n      ],\n    });\n\n    store = TestBed.inject(MockStore);\n    guard = TestBed.inject(AuthGuard);\n  });\n\n  it('should return false if the user state is not logged in', () => {\n    const expected = cold('(a|)', { a: false });\n\n    expect(guard.canActivate()).toBeObservable(expected);\n  });\n\n  it('should return true if the user state is logged in', () => {\n    store.setState({ loggedIn: true });\n\n    const expected = cold('(a|)', { a: true });\n\n    expect(guard.canActivate()).toBeObservable(expected);\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing AppComponent Logic with NgRx Store (TypeScript)\nDESCRIPTION: TypeScript class for the main `AppComponent`. It injects the `Store` and `BooksService`. It uses selectors (`selectBooks`, `selectBookCollection`) to get state observables and dispatches actions (`BooksApiActions.retrievedBookList`, `BooksActions.addBook`, `CollectionActions.removeBook`) in response to service calls and component events.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/walkthrough.md#_snippet_14\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Code from src/app/app.component.ts\n// Main component logic integrating Store, Service, Selectors, and Actions.\n```\n\n----------------------------------------\n\nTITLE: Filtering Actions with ofType in NgRx Effects\nDESCRIPTION: This TypeScript snippet demonstrates how to define an NgRx Effect using `createEffect` and filter the stream of actions using the `ofType` operator. It shows filtering based on a specific Action Creator (`LoginPageActions.login`) and subsequently handles an asynchronous service call (`authService.login`) using `exhaustMap`, mapping success or failure to corresponding API actions (`AuthApiActions.loginSuccess`, `AuthApiActions.loginFailure`). It requires the `@ngrx/effects` library and RxJS operators.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/effects/operators.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Injectable, inject } from '@angular/core';\nimport { Actions, ofType, createEffect } from '@ngrx/effects';\nimport { of } from 'rxjs';\nimport { catchError, exhaustMap, map } from 'rxjs/operators';\nimport {\n  LoginPageActions,\n  AuthApiActions,\n} from '../actions';\nimport { Credentials } from '../models/user';\nimport { AuthService } from '../services/auth.service';\n\n@Injectable()\nexport class AuthEffects {\n  private actions$ = inject(Actions);\n  private authService = inject(AuthService);\n\n  login$ = createEffect(() => {\n    return this.actions$.pipe(\n      // Filters by Action Creator 'login'\n      ofType(LoginPageActions.login),\n      exhaustMap(action =>\n        this.authService.login(action.credentials).pipe(\n          map(user => AuthApiActions.loginSuccess({ user })),\n          catchError(error => of(AuthApiActions.loginFailure({ error })))\n        )\n      )\n    );\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing an NgRx Reducer with Entity Adapter Methods in TypeScript\nDESCRIPTION: Illustrates the implementation of an NgRx reducer using `createReducer` and `on` handlers. It leverages various methods provided by the `EntityAdapter` instance (`addOne`, `setOne`, `upsertOne`, `addMany`, `updateMany`, `removeOne`, `removeMany`, `setAll`, etc.) to handle the defined entity actions and manage the state immutably. It also demonstrates extracting common selectors (`selectIds`, `selectEntities`, `selectAll`, `selectTotal`) using `adapter.getSelectors`.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/entity/adapter.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Action, createReducer, on } from '@ngrx/store';\nimport { EntityState, EntityAdapter, createEntityAdapter } from '@ngrx/entity';\nimport { User } from '../models/user.model';\nimport * as UserActions from '../actions/user.actions';\n\nexport interface State extends EntityState<User> {\n  // additional entities state properties\n  selectedUserId: string | null;\n}\n\nexport const adapter: EntityAdapter<User> = createEntityAdapter<User>();\n\nexport const initialState: State = adapter.getInitialState({\n  // additional entity state properties\n  selectedUserId: null,\n});\n\nexport const userReducer = createReducer(\n  initialState,\n  on(UserActions.addUser, (state, { user }) => {\n    return adapter.addOne(user, state)\n  }),\n  on(UserActions.setUser, (state, { user }) => {\n    return adapter.setOne(user, state)\n  }),\n  on(UserActions.upsertUser, (state, { user }) => {\n    return adapter.upsertOne(user, state);\n  }),\n  on(UserActions.addUsers, (state, { users }) => {\n    return adapter.addMany(users, state);\n  }),\n  on(UserActions.upsertUsers, (state, { users }) => {\n    return adapter.upsertMany(users, state);\n  }),\n  on(UserActions.updateUser, (state, { update }) => {\n    return adapter.updateOne(update, state);\n  }),\n  on(UserActions.updateUsers, (state, { updates }) => {\n    return adapter.updateMany(updates, state);\n  }),\n  on(UserActions.mapUser, (state, { entityMap }) => {\n    return adapter.mapOne(entityMap, state);\n  }),\n  on(UserActions.mapUsers, (state, { entityMap }) => {\n    return adapter.map(entityMap, state);\n  }),\n  on(UserActions.deleteUser, (state, { id }) => {\n    return adapter.removeOne(id, state);\n  }),\n  on(UserActions.deleteUsers, (state, { ids }) => {\n    return adapter.removeMany(ids, state);\n  }),\n  on(UserActions.deleteUsersByPredicate, (state, { predicate }) => {\n    return adapter.removeMany(predicate, state);\n  }),\n  on(UserActions.loadUsers, (state, { users }) => {\n    return adapter.setAll(users, state);\n  }),\n  on(UserActions.setUsers, (state, { users }) => {\n    return adapter.setMany(users, state);\n  }),\n  on(UserActions.clearUsers, state => {\n    return adapter.removeAll({ ...state, selectedUserId: null });\n  })\n);\n\n\nexport const getSelectedUserId = (state: State) => state.selectedUserId;\n\n// get the selectors\nconst {\n  selectIds,\n  selectEntities,\n  selectAll,\n  selectTotal,\n} = adapter.getSelectors();\n\n// select the array of user ids\nexport const selectUserIds = selectIds;\n\n// select the dictionary of user entities\nexport const selectUserEntities = selectEntities;\n\n// select the array of users\nexport const selectAllUsers = selectAll;\n\n// select the total user count\nexport const selectUserTotal = selectTotal;\n```\n\n----------------------------------------\n\nTITLE: Creating Functional Effects in NgRx (TypeScript)\nDESCRIPTION: Example of creating functional effects using the createEffect function with the functional flag set to true. Shows how to inject services using the inject function and handle API calls.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/effects/index.md#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { inject } from '@angular/core';\nimport { catchError, exhaustMap, map, of, tap } from 'rxjs';\nimport { Actions, createEffect, ofType } from '@ngrx/effects';\n\nimport { ActorsService } from './actors.service';\nimport { ActorsPageActions } from './actors-page.actions';\nimport { ActorsApiActions } from './actors-api.actions';\n\nexport const loadActors = createEffect(\n  (actions$ = inject(Actions), actorsService = inject(ActorsService)) => {\n    return actions$.pipe(\n      ofType(ActorsPageActions.opened),\n      exhaustMap(() =>\n        actorsService.getAll().pipe(\n          map((actors) => ActorsApiActions.actorsLoadedSuccess({ actors })),\n          catchError((error: { message: string }) =>\n            of(ActorsApiActions.actorsLoadedFailure({ errorMsg: error.message }))\n          )\n        )\n      )\n    );\n  },\n  { functional: true }\n);\n\nexport const displayErrorAlert = createEffect(\n  () => {\n    return inject(Actions).pipe(\n      ofType(ActorsApiActions.actorsLoadedFailure),\n      tap(({ errorMsg }) => alert(errorMsg))\n    );\n  },\n  { functional: true, dispatch: false }\n);\n```\n\n----------------------------------------\n\nTITLE: Defining NgRx Effects with createEffect Function (v11+)\nDESCRIPTION: Shows the recommended functional approach for defining side effects in NgRx version 11 and later using the `createEffect` function. This replaces the deprecated `@Effect()` decorator.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v11.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nlogin$ = createEffect(() => {\n  return this.actions$.pipe(...);\n});\n```\n\n----------------------------------------\n\nTITLE: Registering Counter Reducer with StoreModule.forRoot in Angular App Module (TypeScript)\nDESCRIPTION: Demonstrates how to add StoreModule.forRoot with an object mapping a state property key ('count') to the counterReducer function inside the imports array of Angular’s AppModule. This registers the global provider of the store that manages the application state and makes it accessible throughout the app. It initializes the store to listen for dispatched actions and run the reducer logic.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/index.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\n\n```\n\n----------------------------------------\n\nTITLE: Implementing an Effect in Angular's NgRx Store with TypeScript\nDESCRIPTION: Defines a `MoviesStore` class extending `ComponentStore` to manage movies state and handle asynchronous fetch operations using effects. Includes `getMovie` effect that fetches movie details by ID, and an `addMovie` updater to update the state Based on fetched data. Demonstrates how effects handle race conditions with `switchMap`, and how errors are caught with `catchError`. The effect is invoked within the component to load specific movies.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/component-store/effect.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\n @Injectable()\n export class MoviesStore extends ComponentStore&lt;MoviesState&gt; {\n   \n   constructor(private readonly moviesService: MoviesService) {\n     super({movies: []});\n   }\n \n   // Effect to fetch a movie by ID, handling race conditions and errors\n   readonly getMovie = this.effect((movieId$: Observable&lt;string&gt;) => {\n     return movieId$.pipe(\n       // Handle race conditions with switchMap\n       switchMap((id) => this.moviesService.fetchMovie(id).pipe(\n         // Act on the fetched movie\n         tap({\n           next: (movie) => this.addMovie(movie),\n           error: (e) => this.logError(e),\n         }),\n         // Handle errors within the inner pipe\n         catchError(() => EMPTY),\n       )),\n     );\n   });\n \n   // Updater to add a fetched movie to state\n   readonly addMovie = this.updater((state, movie: Movie) => ({\n     movies: [...state.movies, movie],\n   }));\n \n   // Method to select a movie from state by ID\n   selectMovie(movieId: string) {\n     return this.select((state) => state.movies.find(m => m.id === movieId));\n   }\n }\n```\n\n----------------------------------------\n\nTITLE: Using a selector for one piece of state with createSelector\nDESCRIPTION: Defines a simple selector for a feature slice 'feature' within the application's state, utilizing 'createSelector' to select the 'counter' property. Demonstrates how to create a memoized selector that efficiently returns specific state data.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/selectors.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { createSelector } from '@ngrx/store';\n\nexport interface FeatureState {\n  counter: number;\n}\n\nexport interface AppState {\n  feature: FeatureState;\n}\n\nexport const selectFeature = (state: AppState) => state.feature;\n\nexport const selectFeatureCount = createSelector(\n  selectFeature,\n  (state: FeatureState) => state.counter\n);\n```\n\n----------------------------------------\n\nTITLE: Creating NgRx Reducer for Book List State in TypeScript\nDESCRIPTION: Defines an NgRx reducer function (`booksReducer`) to manage the state of the available book list. It handles the `'[Book List/API] Retrieve Books Success'` action to update the state with the fetched books.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/walkthrough.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Code from src/app/state/books.reducer.ts\n// Defines the reducer managing the main book list state.\n```\n\n----------------------------------------\n\nTITLE: Registering NgRx Effects at Feature Level (TypeScript)\nDESCRIPTION: Example showing how to register effects at the feature level using the provideEffects method in Angular route configuration.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/effects/index.md#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Route } from '@angular/router';\nimport { provideEffects } from '@ngrx/effects';\n\nimport { MoviesEffects } from './effects/movies.effects';\nimport * as actorsEffects from './effects/actors.effects';\n\nexport const routes: Route[] = [\n  {\n    path: 'movies',\n    providers: [\n      provideEffects(MoviesEffects, actorsEffects)\n    ]\n  }\n];\n```\n\n----------------------------------------\n\nTITLE: Provide DefaultDataServiceConfig in Angular NgModule (TypeScript)\nDESCRIPTION: Provides a custom DefaultDataServiceConfig object in an Angular NgModule to override the default configuration. This makes the custom settings available throughout the application for dependency injection, affecting how DefaultDataService instances behave.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/entity-dataservice.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\n@NgModule({\n  providers: [{ provide: DefaultDataServiceConfig, useValue: defaultDataServiceConfig }]\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing a BooksStore service with SignalState and RxJS integration\nDESCRIPTION: Shows how to create a service using SignalState that handles loading books data with RxJS operators, managing loading state, and error handling.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-state.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { inject, Injectable } from '@angular/core';\nimport { exhaustMap, pipe, tap } from 'rxjs';\nimport { signalState, patchState } from '@ngrx/signals';\nimport { rxMethod } from '@ngrx/signals/rxjs-interop';\nimport { tapResponse } from '@ngrx/operators';\nimport { BooksService } from './books.service';\nimport { Book } from './book.model';\n\ntype BooksState = { books: Book[]; isLoading: boolean };\n\nconst initialState: BooksState = {\n  books: [],\n  isLoading: false,\n};\n\n@Injectable()\nexport class BooksStore {\n  readonly #booksService = inject(BooksService);\n  readonly #state = signalState(initialState);\n\n  readonly books = this.#state.books;\n  readonly isLoading = this.#state.isLoading;\n\n  readonly loadBooks = rxMethod<void>(\n    pipe(\n      tap(() => patchState(this.#state, { isLoading: true })),\n      exhaustMap(() => {\n        return this.#booksService.getAll().pipe(\n          tapResponse({\n            next: (books) => patchState(this.#state, { books }),\n            error: console.error,\n            finalize: () => patchState(this.#state, { isLoading: false }),\n          })\n        );\n      })\n    )\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Importing StoreModule and Counter Reducer in Angular App Module (TypeScript)\nDESCRIPTION: Shows how to import the NgRx StoreModule from '@ngrx/store' and import the defined counter reducer function. These imports are prerequisites to register the reducer as part of the global state in Angular’s AppModule. Proper import statements enable setup of the reactive store infrastructure.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/index.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\n\n```\n\n----------------------------------------\n\nTITLE: Creating a View Model as Combined Observable Dictionary in NgRx ComponentStore (TypeScript)\nDESCRIPTION: Illustrates the creation of a view model observable vm$ that consolidates multiple selectors movies$, userPreferredMovieIds$, and userPreferredMovies$ into a single object stream. This approach simplifies passing state streams to Angular templates by exposing an observable dictionary with all required state slices.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/component-store/read.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nprivate readonly vm$ = this.select({\n  movies: this.movies$,\n  userPreferredMovieIds: this.userPreferredMovieIds$,\n  userPreferredMovies: this.userPreferredMovies$\n});\n```\n\n----------------------------------------\n\nTITLE: Generating a User Feature and Registering in Angular Module - Shell\nDESCRIPTION: Generates a new 'User' NgRx feature set and automatically registers its reducer within the module specified by the '-m app.module.ts' option. Requires Angular CLI and NgRx installed, and the module file should exist. The generated files are structured based on default or specified parameters, and the reducer is imported and added to the targeted Angular module.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/schematics/feature.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nng generate feature User -m app.module.ts\n```\n\n----------------------------------------\n\nTITLE: Implementing a Counter Component with SignalState\nDESCRIPTION: Complete example of using SignalState in an Angular component to implement a counter with increment, decrement, and reset functionality.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-state.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ChangeDetectionStrategy, Component } from '@angular/core';\nimport { signalState, patchState } from '@ngrx/signals';\n\n@Component({\n  selector: 'ngrx-counter',\n  template: `\n    <p>Count: {{ state.count() }}</p>\n\n    <button (click)=\"increment()\">Increment</button>\n    <button (click)=\"decrement()\">Decrement</button>\n    <button (click)=\"reset()\">Reset</button>\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class CounterComponent {\n  readonly state = signalState({ count: 0 });\n\n  increment(): void {\n    patchState(this.state, (state) => ({ count: state.count + 1 }));\n  }\n\n  decrement(): void {\n    patchState(this.state, (state) => ({ count: state.count - 1 }));\n  }\n\n  reset(): void {\n    patchState(this.state, { count: 0 });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Effects using Marble Diagrams\nDESCRIPTION: This snippet illustrates testing an effect using marble diagrams. It utilizes `hot` to create an actions stream, `cold` to mock service responses, and `expect` along with `toBeObservable` to verify the effect's output. This approach is useful when testing effects that are time-sensitive or have complex behavior.  The inputs include an actions stream and mock service responses; the expected output is defined with marble syntax.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/effects/testing.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// create an actions stream to represent a user that is typing\nactions$ = hot('-a-b-', {\n  a: { type: '[Customers Page] Search Customers', name: 'J' },\n  b: { type: '[Customers Page] Search Customers', name: 'Jes' },\n})\n\n// mock the service to prevent an HTTP request to return an array of customers\ncustomersServiceSpy.searchCustomers.and.returnValue(\n  cold('--a|', { a: [...] })\n);\n\n// expect the first action to debounce and not to dispatch\n// expect the second action to result in a SUCCESS action\nconst expected = hot('-------a', {\n  a: {\n    type: '[Customers API] Search Customers Success',\n    customers: [...],\n  },\n});\n\nexpect(\n  effects.searchCustomers$({\n    debounce: 20,\n    scheduler: getTestScheduler(),\n  })\n).toBeObservable(expected);\n```\n\n----------------------------------------\n\nTITLE: Calling EntityCollectionService commands in Angular Component with TypeScript\nDESCRIPTION: This snippet defines component methods that invoke command functions on the EntityCollectionService instance. These commands include getAll() to fetch all entities, add() to add a new entity, delete() to remove an entity by id, and update() to update an existing entity object. Each command dispatches NgRx data actions to either query or modify the cached entity collection and sync with the server asynchronously.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/entity-collection-service.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\ngetHeroes() { this.heroService.getAll(); }\nadd(hero: Hero) { this.heroService.add(hero); }\ndeleteHero(hero: Hero) { this.heroService.delete(hero.id); }\nupdate(hero: Hero) { this.heroService.update(hero); }\n```\n\n----------------------------------------\n\nTITLE: Initializing NgRx SignalStore State Using an Injection Token in TypeScript\nDESCRIPTION: Illustrates using an `InjectionToken` (`BOOKS_STATE`) to provide an initial state factory to the `withState` feature. The factory function uses `inject` to retrieve the state from the token, enabling dependency injection during the store's state initialization.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/index.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst BOOKS_STATE = new InjectionToken<BooksState>('BooksState', {\n  factory: () => initialState,\n});\n\nconst BooksStore = signalStore(\n  withState(() => inject(BOOKS_STATE))\n);\n```\n\n----------------------------------------\n\nTITLE: Defining NgRx EntityState Interface - TypeScript\nDESCRIPTION: This snippet defines the generic `EntityState` interface used by NgRx Entity. It specifies the standard structure for an entity collection, containing an array of primary identifiers (`ids`) and a dictionary mapping identifiers to entity objects (`entities`). The generic type `V` represents the type of the entity objects.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/entity/interfaces.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ninterface EntityState<V> {\n  ids: string[] | number[];\n  entities: { [id: string | id: number]: V };\n}\n```\n\n----------------------------------------\n\nTITLE: Defining NgRx Actions with Proper Hygiene in TypeScript\nDESCRIPTION: Demonstrates the recommended '[Source] Event' pattern for naming NgRx actions using `createAction`. The first code block shows incorrect examples lacking source context, while the second block provides corrected versions that clearly indicate the action's origin (e.g., '[Customers Page]', '[Customers API]') and the event itself.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/good-action-hygiene.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport const customersRefresh = createAction('Refresh Customers');\nexport const customersLoadedSuccess = createAction('Customers Loaded Success');\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport const customersRefresh = createAction(\n  '[Customers Page] Refresh clicked'\n);\nexport const customersLoadedSuccess = createAction(\n  '[Customers API] Customers Loaded Success'\n);\n```\n\n----------------------------------------\n\nTITLE: Enhancing BooksStore with State, Computed Signals, and Methods for Book Management\nDESCRIPTION: This snippet extends the BooksStore by defining its complete state, computed signals for derived data like books count and sorted books, and methods to update query, order, and load books via RxJS pipelines. It integrates dependency injection for BooksService and demonstrates reactive state management patterns.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/index.md#_snippet_10\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { computed, inject } from '@angular/core';\nimport { debounceTime, distinctUntilChanged, pipe, switchMap, tap } from 'rxjs';\nimport {\n  patchState,\n  signalStore,\n  withComputed,\n  withMethods,\n  withState\n} from '@ngrx/signals';\nimport { rxMethod } from '@ngrx/signals/rxjs-interop';\nimport { tapResponse } from '@ngrx/operators';\nimport { Book } from './book.model';\nimport { BooksService } from './books.service';\n\n// Define the shape of the store state including books, loading status, and filters\ntype BooksState = {\n  books: Book[];\n  isLoading: boolean;\n  filter: { query: string; order: 'asc' | 'desc' };\n};\n\n// Initialize the state with default values\nconst initialState: BooksState = {\n  books: [],\n  isLoading: false,\n  filter: { query: '', order: 'asc' },\n};\n\n// Create the SignalStore with state, computed signals, and methods\nexport const BooksStore = signalStore(\n  withState(initialState),\n  withComputed(({ books, filter }) => ({\n    // Computed signal for total number of books\n    booksCount: computed(() => books().length),\n    // Computed signal for sorted list of books based on order\n    sortedBooks: computed(() => {\n      const direction = filter.order() === 'asc' ? 1 : -1;\n      return books().toSorted((a, b) =>\n        direction * a.title.localeCompare(b.title)\n      );\n    }), \n  })),\n  withMethods((store, booksService = inject(BooksService)) => ({\n    // Method to update query in filter\n    updateQuery(query: string): void {\n      patchState(store, (state) => ({ filter: { ...state.filter, query } }));\n    },\n    // Method to update order in filter\n    updateOrder(order: 'asc' | 'desc'): void {\n      patchState(store, (state) => ({ filter: { ...state.filter, order } }));\n    },\n    // Async method to load books based on query using rxMethod\n    loadByQuery: rxMethod<string>(\n      pipe(\n        debounceTime(300),\n        distinctUntilChanged(),\n        tap(() => patchState(store, { isLoading: true })),\n        switchMap((query) => {\n          return booksService.getByQuery(query).pipe(\n            tapResponse({\n              next: (books) => patchState(store, { books }),\n              error: console.error,\n              finalize: () => patchState(store, { isLoading: false }),\n            })\n          );\n        })\n      )\n    ),\n  }))\n);\n```\n\n----------------------------------------\n\nTITLE: Configuring and Managing Entity Store with NgRx Signals in TypeScript\nDESCRIPTION: Defines a strongly typed entity configuration and a Todo store using NgRx Signals. The snippet uses the entityConfig function to set up entity metadata including entity type, collection name, and custom ID selector. It then creates a signalStore with entities and associated methods to add and remove Todo items via patchState. Dependencies include '@ngrx/signals' and '@ngrx/signals/entities'. Inputs are Todo objects; outputs are store state updates reflecting entity additions or removals.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/entity-management.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport {\n  patchState,\n  signalStore,\n  type,\n  withMethods,\n} from '@ngrx/signals';\nimport {\n  addEntity,\n  entityConfig,\n  removeEntity,\n  withEntities,\n} from '@ngrx/signals/entities';\n\ntype Todo = {\n  key: number;\n  text: string;\n  completed: boolean;\n};\n\nconst todoConfig = entityConfig({\n  entity: type<Todo>(),\n  collection: 'todo',\n  selectId: (todo) => todo.key,\n});\n\nexport const TodosStore = signalStore(\n  withEntities(todoConfig),\n  withMethods((store) => ({\n    addTodo(todo: Todo): void {\n      patchState(store, addEntity(todo, todoConfig));\n    },\n    removeTodo(todo: Todo): void {\n      patchState(store, removeEntity(todo, todoConfig));\n    },\n  }))\n);\n```\n\n----------------------------------------\n\nTITLE: Registering NgRx Reducers in AppModule with StoreModule.forRoot (TypeScript)\nDESCRIPTION: Demonstrates registering the defined reducers within the Angular application's root module (`AppModule`). `StoreModule.forRoot` is used in the `imports` array, mapping state slices (`books`, `collection`) to their respective reducers (`booksReducer`, `collectionReducer`).\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/walkthrough.md#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Code from src/app/app.module.ts (storeModuleAddToImports region)\n// Registers the reducers with the StoreModule.\n```\n\n----------------------------------------\n\nTITLE: Managing Paginator State Using ComponentStore in a Service - TypeScript\nDESCRIPTION: Defines a PaginatorStore service that extends Angular's ComponentStore to encapsulate the paginator component's business logic. It uses updaters to handle state mutation triggered by incoming @Input values or user interactions, and effects to derive additional state or handle side effects. The store exposes selectors including a combined ViewModel observable (vm$) for template consumption and a debounced page$ observable emitting PageEvents on state change. Dependencies include Angular ComponentStore and relevant Angular Material paginator types. Inputs like pageIndex and pageSize are passed to updaters to update the internal state; outputs reflect derived states and event notifications.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/component-store/usage.md#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Example snippet showing input updaters in PaginatorStore */\nreadonly setPageIndex = this.updater<number>((state, pageIndex) => ({ ...state, pageIndex }));\nreadonly setPageSize = this.updater<number>((state, pageSize) => ({ ...state, pageSize }));\n\n/* Effect for handling page change emitted on state update, debounced to avoid intermediary emissions */\nreadonly page$ = this.select(\n  this.state$,\n  state => ({ pageIndex: state.pageIndex, pageSize: state.pageSize }),\n  { debounce: true }\n);\n\n/* Exposing a ViewModel observable aggregating multiple selectors for template binding */\nreadonly vm$ = this.select(\n  this.select(state => state.pageIndex),\n  this.select(state => state.pageSize),\n  (pageIndex, pageSize) => ({ pageIndex, pageSize })\n);\n```\n\n----------------------------------------\n\nTITLE: Writing a Basic NgRx Effect in TypeScript\nDESCRIPTION: Illustrates the creation of an NgRx Effect class (`MoviesEffects`). It injects the `Actions` stream and `MoviesService`. The `loadMovies$` effect uses `createEffect`, filters for the `[Movies Page] Load Movies` action with `ofType`, performs the API call via `exhaustMap` and the service, maps the successful result to a `[Movies API] Movies Loaded Success` action, and handles errors minimally by returning `EMPTY`.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/effects/index.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Injectable, inject } from '@angular/core';\nimport { Actions, createEffect, ofType } from '@ngrx/effects';\nimport { EMPTY } from 'rxjs';\nimport { map, exhaustMap, catchError } from 'rxjs/operators';\nimport { MoviesService } from './movies.service';\n\n@Injectable()\nexport class MoviesEffects {\n  private actions$ = inject(Actions);\n  private moviesService = inject(MoviesService);\n\n  loadMovies$ = createEffect(() => {\n    return this.actions$.pipe(\n        ofType('[Movies Page] Load Movies'),\n        exhaustMap(() => this.moviesService.getAll()\n          .pipe(\n            map(movies => ({ type: '[Movies API] Movies Loaded Success', payload: movies })),\n            catchError(() => EMPTY)\n          ))\n    );\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Selecting User Entities and State with NgRx Selectors in TypeScript\nDESCRIPTION: This TypeScript snippet defines state interfaces, combines reducers, and creates multiple selectors for querying user-related data in an NgRx Store setup. It requires NgRx Store and Entity libraries as dependencies and expects user reducers and selectors (fromUser module) to be available. Key parameters include state interfaces, reducer maps, and feature keys such as 'users'; expected inputs are the current application store state, and outputs are observable selections of user IDs, total, entities, and a computed value for the currently selected user. This implementation assumes a normalized entity state structure for users.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/entity/adapter.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  createSelector,\n  createFeatureSelector,\n  ActionReducerMap,\n} from '@ngrx/store';\nimport * as fromUser from './user.reducer';\n\nexport interface State {\n  users: fromUser.State;\n}\n\nexport const reducers: ActionReducerMap<State> = {\n  users: fromUser.reducer,\n};\n\nexport const selectUserState = createFeatureSelector<fromUser.State>('users');\n\nexport const selectUserIds = createSelector(\n  selectUserState,\n  fromUser.selectUserIds // shorthand for usersState => fromUser.selectUserIds(usersState)\n);\nexport const selectUserEntities = createSelector(\n  selectUserState,\n  fromUser.selectUserEntities\n);\nexport const selectAllUsers = createSelector(\n  selectUserState,\n  fromUser.selectAllUsers\n);\nexport const selectUserTotal = createSelector(\n  selectUserState,\n  fromUser.selectUserTotal\n);\nexport const selectCurrentUserId = createSelector(\n  selectUserState,\n  fromUser.getSelectedUserId\n);\n\nexport const selectCurrentUser = createSelector(\n  selectUserEntities,\n  selectCurrentUserId,\n  (userEntities, userId) => userId && userEntities[userId]\n);\n```\n\n----------------------------------------\n\nTITLE: Defining NgRx Selectors for Book State in TypeScript\nDESCRIPTION: Creates NgRx selectors using `createSelector` and `createFeatureSelector` to query specific pieces of state. Includes selectors for the book list (`selectBooks`), the collection IDs (`selectCollection`), and a combined selector (`selectBookCollection`) that maps collection IDs to book objects.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/walkthrough.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Code from src/app/state/books.selectors.ts\n// Defines selectors to retrieve book list and collection data from the store.\n```\n\n----------------------------------------\n\nTITLE: Registering a Custom EntityDataService in Angular Module with NgRx Data (TypeScript)\nDESCRIPTION: This code snippet shows how to register a custom entity data service (HeroDataService) for the Hero entity in Angular's NgRx Data store module. It requires importing EntityDataService and providing the custom service via the module's providers array. Within the EntityStoreModule constructor, the service is registered by calling entityDataService.registerService('Hero', heroDataService). This enables the NgRx Data system to use the supplied custom data service for all Hero entity requests, replacing the default service implementation.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/entity-dataservice.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { EntityDataService } from '@ngrx/data'; // <-- import the NgRx Data data service registry\n\nimport { HeroDataService } from './hero-data-service';\n\n@NgModule({\n  imports: [ ... ],\n  providers: [ HeroDataService ] // <-- provide the data service\n})\nexport class EntityStoreModule {\n  constructor(\n    entityDataService: EntityDataService,\n    heroDataService: HeroDataService,\n  ) {\n    entityDataService.registerService('Hero', heroDataService); // <-- register it\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Errors within an NgRx Effect in TypeScript\nDESCRIPTION: Demonstrates robust error handling within an NgRx effect (`MoviesEffects`). The `loadMovies$` effect uses `catchError` inside the inner pipe (following the service call) to catch potential HTTP errors. Instead of completing the stream or returning `EMPTY`, it returns an Observable of a specific error action (`[Movies API] Movies Loaded Error`), allowing the application to react to the failure while keeping the main effect stream alive.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/effects/index.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Injectable, inject } from '@angular/core';\nimport { Actions, createEffect, ofType } from '@ngrx/effects';\nimport { of } from 'rxjs';\nimport { map, exhaustMap, catchError } from 'rxjs/operators';\nimport { MoviesService } from './movies.service';\n\n@Injectable()\nexport class MoviesEffects {\n  private actions$ = inject(Actions);\n  private moviesService = inject(MoviesService);\n\n  loadMovies$ = createEffect(() => {\n    return this.actions$.pipe(\n      ofType('[Movies Page] Load Movies'),\n      exhaustMap(() => this.moviesService.getAll()\n        .pipe(\n          map(movies => ({ type: '[Movies API] Movies Loaded Success', payload: movies })),\n          catchError(() => of({ type: '[Movies API] Movies Loaded Error' }))\n        )\n      )\n    );\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Using watchState for Synchronous State Tracking in NgRx SignalStore\nDESCRIPTION: Demonstrates how to use watchState for synchronous tracking of state changes in a SignalStore. Unlike effect, which coalesces state updates, watchState executes the provided watcher function for every individual state change, making it suitable for features like undo/redo.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/state-tracking.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { effect } from '@angular/core';\nimport {\n  getState,\n  patchState,\n  signalStore,\n  watchState,\n  withHooks,\n  withState,\n} from '@ngrx/signals';\n\nexport const CounterStore = signalStore(\n  withState({ count: 0 }),\n  withMethods((store) => ({\n    increment(): void {\n      patchState(store, { count: store.count() + 1 });\n    },\n  })),\n  withHooks({\n    onInit(store) {\n      watchState(store, (state) => {\n        console.log('[watchState] counter state', state);\n      }); // logs: { count: 0 }, { count: 1 }, { count: 2 }\n      \n      effect(() => {\n        console.log('[effect] counter state', getState(store));\n      }); // logs: { count: 2 }\n\n      store.increment();\n      store.increment();\n    },\n  })\n);\n```\n\n----------------------------------------\n\nTITLE: Reusing Custom Selectors within NgRx Feature extraSelectors in TypeScript\nDESCRIPTION: Expands on using the `extraSelectors` option to demonstrate defining multiple custom selectors where one selector (`selectFilteredBooksWithRating`) reuses another custom selector (`selectFilteredBooks`) within the factory function provided to `extraSelectors`. This pattern allows for building complex selector chains.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/feature-creators.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createFeature, createReducer, on } from '@ngrx/store';\nimport { Book } from './book.model';\n\nimport * as BookListPageActions from './book-list-page.actions';\n\ninterface State {\n  books: Book[];\n  query: string;\n}\n\nconst initialState: State = {\n  books: [],\n  query: '',\n};\n\nexport const booksFeature = createFeature({\n  name: 'books',\n  reducer: createReducer(\n    initialState,\n    on(BookListPageActions.search, (state, action) => ({\n      ...state,\n      query: action.query,\n    }))\n  ),\n  extraSelectors: ({ selectQuery, selectBooks }) => {\n    const selectFilteredBooks = createSelector(\n      selectQuery,\n      selectBooks,\n      (query, books) => books.filter((book) => book.title.includes(query))\n    );\n    const selectFilteredBooksWithRating = createSelector(\n      selectFilteredBooks,\n      (books) => books.filter((book) => book.ratingsCount >= 1)\n    );\n\n    return { selectFilteredBooks, selectFilteredBooksWithRating };\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic NgRx SignalStore with Initial State in TypeScript\nDESCRIPTION: Defines a basic injectable `BooksStore` service using the `signalStore` function from `@ngrx/signals`. It utilizes the `withState` feature to establish the initial structure and values for the store's state, including `books`, `isLoading`, and a nested `filter` object.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { signalStore, withState } from '@ngrx/signals';\nimport { Book } from './book.model';\n\ntype BooksState = {\n  books: Book[];\n  isLoading: boolean;\n  filter: { query: string; order: 'asc' | 'desc' };\n};\n\nconst initialState: BooksState = {\n  books: [],\n  isLoading: false,\n  filter: { query: '', order: 'asc' },\n};\n\nexport const BooksStore = signalStore(\n  withState(initialState)\n);\n```\n\n----------------------------------------\n\nTITLE: Creating Entity Collection Service for Hero Entity (TypeScript)\nDESCRIPTION: This snippet illustrates creating a specialized service for a single entity type, 'Hero'. It extends `EntityCollectionServiceBase<Hero>` and injects `EntityCollectionServiceElementsFactory`, passing the entity name to the super constructor. This creates a service instance with pre-built methods for managing the 'Hero' collection's state and interacting with a backend.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/index.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Injectable } from '@angular/core';\nimport {\n  EntityCollectionServiceBase,\n  EntityCollectionServiceElementsFactory\n} from '@ngrx/data';\nimport { Hero } from '../core';\n\n@Injectable({ providedIn: 'root' })\nexport class HeroService extends EntityCollectionServiceBase<Hero> {\n  constructor(serviceElementsFactory: EntityCollectionServiceElementsFactory) {\n    super('Hero', serviceElementsFactory);\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining Methods to Update State in an NgRx SignalStore Using `withMethods` in TypeScript\nDESCRIPTION: Shows how to define methods (`updateQuery`, `updateOrder`) within the `BooksStore` using the `withMethods` feature. These methods accept parameters and utilize the `patchState` function, passing the store instance and an updater function to modify specific parts of the store's state immutably.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/index.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { computed } from '@angular/core';\nimport {\n  patchState,\n  signalStore,\n  withComputed,\n  withMethods,\n  withState,\n} from '@ngrx/signals';\nimport { Book } from './book.model';\n\ntype BooksState = { /* ... */ };\n\nconst initialState: BooksState = { /* ... */ };\n\nexport const BooksStore = signalStore(\n  withState(initialState),\n  withComputed(/* ... */),\n  // 👇 Accessing a store instance with previously defined state signals,\n  // properties, and methods.\n  withMethods((store) => ({\n    updateQuery(query: string): void {\n      // 👇 Updating state using the `patchState` function.\n      patchState(store, (state) => ({ filter: { ...state.filter, query } }));\n    },\n    updateOrder(order: 'asc' | 'desc'): void {\n      patchState(store, (state) => ({ filter: { ...state.filter, order } }));\n    },\n  }))\n);\n```\n\n----------------------------------------\n\nTITLE: Generating Root State Management Setup with NgRx Store - Shell\nDESCRIPTION: This command initializes the NgRx store in an Angular project by creating the necessary state management files and registering the root providers in the specified Angular module using StoreModule.forRoot. Dependencies include @ngrx/store, @ngrx/store-devtools, the Angular project, and the specified module file (app.module.ts in this example). The --root flag specifies that the setup is for the global store, and the --module flag defines where registration occurs.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/schematics/store.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nng generate store State --root --module app.module.ts\n```\n\n----------------------------------------\n\nTITLE: Selecting State from Global NgRx Store Combined with ComponentStore Selectors in TypeScript\nDESCRIPTION: Demonstrates integrating an external global NgRx Store selector with ComponentStore selectors by combining them using the select method. This enables accessing global state alongside local state within ComponentStore-based selectors. Requires @ngrx/store and ComponentStore libraries.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/component-store/read.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nprivate readonly fetchMoviesData$ = this.select(\n  this.store.select(getUserId), // 👈 store.select returns an Observable, which is easily mixed within selector\n  moviesPerPage$,\n  currentPageIndex$,\n  (userId, moviesPerPage, currentPageIndex) => ({userId, moviesPerPage, currentPageIndex}),\n);\n```\n\n----------------------------------------\n\nTITLE: Creating Action Stream\nDESCRIPTION: This demonstrates how to assign values to actions$ observable. This can be achieved either by creating an observable explicitly by using 'of()' operator from RxJS library, or by using marble diagram format to represent a sequence of actions over time. This is necessary to feed actions into the effects being tested in order to simulate different scenarios.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/effects/testing.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// by creating an Observable\nactions$ = of({ type: 'Action One' });\n\n// or by using a marble diagram\nactions$ = hot('--a-', { a: { type: 'Action One' } });\n```\n\n----------------------------------------\n\nTITLE: Implementing Book Collection Component Logic (TypeScript)\nDESCRIPTION: TypeScript class for the `BookCollectionComponent`. It defines an `@Input()` for the collection book list (`books`) and an `@Output()` event emitter (`remove`) that emits the book ID when the remove button is clicked.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/walkthrough.md#_snippet_11\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Code from src/app/book-collection/book-collection.component.ts\n// Component logic for displaying the collection and emitting a remove event.\n```\n\n----------------------------------------\n\nTITLE: Defining Computed Properties in an NgRx SignalStore Using `withComputed` in TypeScript\nDESCRIPTION: Illustrates adding derived state (computed signals) to the `BooksStore` using the `withComputed` feature. The factory function receives existing state signals (like `books` and `filter`) and defines new computed signals (`booksCount`, `sortedBooks`) using Angular's `computed` function, which recalculate automatically when their dependencies change.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/index.md#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { computed } from '@angular/core';\nimport { signalStore, withComputed, withState } from '@ngrx/signals';\nimport { Book } from './book.model';\n\ntype BooksState = { /* ... */ };\n\nconst initialState: BooksState = { /* ... */ };\n\nexport const BooksStore = signalStore(\n  withState(initialState),\n  // 👇 Accessing previously defined state signals and properties.\n  withComputed(({ books, filter }) => ({\n    booksCount: computed(() => books().length),\n    sortedBooks: computed(() => {\n      const direction = filter.order() === 'asc' ? 1 : -1;\n\n      return books().toSorted((a, b) =>\n        direction * a.title.localeCompare(b.title)\n      );\n    }),\n  }))\n);\n```\n\n----------------------------------------\n\nTITLE: Defining Private Entity Collections and Exposing Public Properties with NgRx Signals in TypeScript\nDESCRIPTION: Demonstrates using a private collection prefix '_' in entityConfig to create a private entity collection store. The TodosStore exposes the private collection's entity array publicly via withComputed, enabling components to consume the data while maintaining encapsulation. Dependencies include NgRx's signalStore, withEntities, withComputed, and Angular component decorators. The example also shows dependency injection of the store into an Angular component and usage of the store's exposed observable todos. Inputs are private entity collections; outputs are computed public properties for component templates.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/entity-management.md#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst todoConfig = entityConfig({\n  entity: type<Todo>(),\n  // 👇 private collection\n  collection: '_todo',\n});\n\nconst TodosStore = signalStore(\n  withEntities(todoConfig),\n  withComputed(({ _todoEntities }) => ({\n    // 👇 exposing entity array publicly\n    todos: _todoEntities,\n  }))\n);\n\n@Component({\n  /* ... */\n  template: `\n    <h1>Todos</h1>\n    <ngrx-todo-list [todos]=\"store.todos()\" />\n  `,\n  providers: [TodosStore],\n})\nclass TodosComponent {\n  readonly store = inject(TodosStore);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the NgRx Entity Update Interface in TypeScript\nDESCRIPTION: Shows the TypeScript interface definition for `Update<T>`, used by the `updateOne` and `updateMany` adapter methods. This structure enables partial updates by specifying the entity `id` and a `changes` object containing only the properties to modify (`Partial<T>`). It includes variants for string (`UpdateStr`) and number (`UpdateNum`) IDs.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/entity/adapter.md#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\ninterface UpdateStr<T> {\n  id: string;\n  changes: Partial<T>;\n}\n\ninterface UpdateNum<T> {\n  id: number;\n  changes: Partial<T>;\n}\n\ntype Update<T> = UpdateStr<T> | UpdateNum<T>;\n```\n\n----------------------------------------\n\nTITLE: Creating a Globally Provided MoviesStore with SignalStore and withState in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a globally provided SignalStore for movies. The store is configured with an initial state containing a list of movies and is provided at the root level for application-wide access.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/testing.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { signalStore, withState } from '@ngrx/signals';\n\ntype Movie = {\n  id: number;\n  name: string;\n};\n\ntype State = { movies: Movie[] };\n\nexport const MoviesStore = signalStore(\n  { providedIn: 'root' },\n  withState<State>({\n    movies: [\n      { id: 1, name: 'A New Hope' },\n      { id: 2, name: 'Into Darkness' },\n      { id: 3, name: 'The Lord of the Rings' },\n    ],\n  })\n);\n```\n\n----------------------------------------\n\nTITLE: Defining NgRx Actions (Scoreboard Example) - TypeScript\nDESCRIPTION: Defines a set of NgRx actions related to a scoreboard feature using `createAction` and `props`. These actions represent events that can occur and trigger state changes in a reducer. `props` is used to include additional data (payload) with the action.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/reducers.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { createAction, props } from '@ngrx/store';\n\nexport const homeScore = createAction('[Scoreboard Page] Home Score');\nexport const awayScore = createAction('[Scoreboard Page] Away Score');\nexport const resetScore = createAction('[Scoreboard Page] Score Reset');\nexport const setScores = createAction('[Scoreboard Page] Set Scores', props<{game: Game}>());\n```\n\n----------------------------------------\n\nTITLE: Defining Asynchronous Methods for Side Effects in NgRx SignalStore in TypeScript\nDESCRIPTION: Illustrates defining an asynchronous method (`loadAll`) within the `BooksStore` using `withMethods`. This method uses `inject` within the factory to get a dependency (`BooksService`), performs an async operation (fetching books via `booksService.getAll()`), and updates the store's state (`isLoading`, `books`) using `patchState` at different stages of the async flow.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/index.md#_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { computed, inject } from '@angular/core';\nimport { patchState, signalStore, /* ... */ } from '@ngrx/signals';\nimport { Book } from './book.model';\nimport { BooksService } from './books.service';\n\ntype BooksState = { /* ... */ };\n\nconst initialState: BooksState = { /* ... */ };\n\nexport const BooksStore = signalStore(\n  withState(initialState),\n  withComputed(/* ... */),\n  // 👇 `BooksService` can be injected within the `withMethods` factory.\n  withMethods((store, booksService = inject(BooksService)) => ({\n    /* ... */\n    // 👇 Defining a method to load all books.\n    async loadAll(): Promise<void> {\n      patchState(store, { isLoading: true });\n\n      const books = await booksService.getAll();\n      patchState(store, { books, isLoading: false });\n    },\n  }))\n);\n```\n\n----------------------------------------\n\nTITLE: Correct Action Dispatching with Action Creator - TypeScript\nDESCRIPTION: This code snippet demonstrates the correct usage of `dispatch` with ngrx, where action creators should be used. This approach enhances code readability and type safety and is the preferred method for dispatching actions. Action creators encapsulate the action type and any associated payload.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/prefer-action-creator-in-dispatch.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nstore$.dispatch(action);\n\nthis.store$.dispatch(BookActions.load());\n\nthis.store$.dispatch(AuthActions.Login({ payload }));\n```\n\n----------------------------------------\n\nTITLE: Invoking an Effect with Parameters in Angular's NgRx Store\nDESCRIPTION: Illustrates how to use an effect, such as `getMovie`, within an Angular component by passing the necessary parameter. When the input property `movieId` is set, the effect is called with the new ID, triggering a fetch operation. The component also subscribes to the selected movie state for display or further processing.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/component-store/effect.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\n@Component({\n  template: `...`,\n  // NgRx Store injected in constructor\n})\nexport class MovieComponent {\n  movie$: Observable&lt;Movie&gt;;\n\n  @Input()\n  set movieId(value: string) {\n    // Call effect with provided movie ID\n    this.moviesStore.getMovie(value);\n    // Select the movie from state\n    this.movie$ = this.moviesStore.selectMovie(value);\n  }\n\n  constructor(private readonly moviesStore: MoviesStore) {}\n}\n\n```\n\n----------------------------------------\n\nTITLE: Dispatching NgRx Actions from Action Group in Component (TypeScript)\nDESCRIPTION: This snippet shows how to inject the NgRx `Store` service into an Angular component and dispatch actions defined using `createActionGroup`. It demonstrates dispatching an action with no payload (`opened`), an action with an object payload (`paginationChanged`), and an action with a payload generated by a factory function (`queryChanged`). The action creator names are automatically generated from the event names (camelCased).\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/action-groups.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Component, inject, OnInit } from '@angular/core';\nimport { Store } from '@ngrx/store';\n\nimport { ProductsPageActions } from './products-page.actions';\n\n@Component({ /* ... */ })\nexport class ProductsComponent implements OnInit {\n  private readonly store = inject(Store);\n\n  ngOnInit(): void {\n    // action type: [Products Page] Opened\n    this.store.dispatch(ProductsPageActions.opened());\n  }\n\n  onPaginationChange(page: number, offset: number): void {\n    // action type: [Products Page] Pagination Changed\n    this.store.dispatch(\n      ProductsPageActions.paginationChanged({ page, offset })\n    );\n  }\n\n  onQueryChange(query: string): void {\n    // action type: [Products Page] Query Changed\n    this.store.dispatch(ProductsPageActions.queryChanged(query));\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Updating ComponentStore State with Updaters and Effects\nDESCRIPTION: Defines an `updater` function (e.g., `setChecked`) within the `ComponentStore` instance to handle state modifications immutably. Uses this updater within an `@Input` setter to react to parent component changes and within an `effect` (e.g., `onChangeEvent`) to handle component-internal events like user clicks, potentially including side effects.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/component-store/usage.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\n// src/app/slide-toggle.component.ts (region: updater)\nimport { Input } from '@angular/core';\n\n// ... inside SlideToggleComponent class\n\n  // Updater: Defines HOW state changes\n  readonly setChecked = this.store.updater((state, checked: boolean) => ({\n    ...state,\n    checked,\n  }));\n\n  // Input setter using the updater\n  @Input()\n  set checked(value: boolean) {\n    this.setChecked(value);\n  }\n\n  // Effect: Handles user interaction and calls updater\n  readonly onChangeEvent = this.store.effect<Event>((event$) =>\n    event$.pipe(\n      tap((event) => {\n        // Example side effect\n        (event.target as HTMLInputElement).blur(); // Or event.source.stopPropagation()\n        // Update state via the updater\n        this.setChecked((event.target as HTMLInputElement).checked);\n      })\n    )\n  );\n```\n\n----------------------------------------\n\nTITLE: Defining NgRx Actions for Books in TypeScript\nDESCRIPTION: Creates NgRx actions using `createAction` for managing books. Actions defined include retrieving the book list (`'[Book List/API] Retrieve Books Success'`), adding a book to the collection (`'[Book List] Add Book'`), and removing a book from the collection (`'[Book Collection] Remove Book'`).\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/walkthrough.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Code from src/app/state/books.actions.ts\n// Defines actions for book retrieval, adding, and removal.\n```\n\n----------------------------------------\n\nTITLE: Configuring Store Devtools in main.ts (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to configure and integrate @ngrx/store-devtools within an Angular application's `main.ts` file. It imports necessary modules from `@angular/core`, `@angular/platform-browser`, `@ngrx/store`, and `@ngrx/store-devtools`.  It utilizes `bootstrapApplication` to configure the application, providing `provideStore` and `provideStoreDevtools`. The `provideStoreDevtools` function configures the devtools with options such as `maxAge`, `logOnly`, `autoPause`, `trace`, `traceLimit`, and `connectInZone` to customize the extension's behavior. The example checks if the application is in development mode via `isDevMode` from `@angular/core` to set the `logOnly` property.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store-devtools/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { isDevMode } from '@angular/core';\nimport { bootstrapApplication } from '@angular/platform-browser';\nimport { provideStore } from '@ngrx/store';\nimport { provideStoreDevtools } from '@ngrx/store-devtools';\n\nimport { AppComponent } from './app.component';\n\nbootstrapApplication(AppComponent, {\n  providers: [\n    provideStore(),\n    provideStoreDevtools({\n      maxAge: 25, // Retains last 25 states\n      logOnly: !isDevMode(), // Restrict extension to log-only mode\n      autoPause: true, // Pauses recording actions and state changes when the extension window is not open\n      trace: false, //  If set to true, will include stack trace for every dispatched action, so you can see it in trace tab jumping directly to that part of code\n      traceLimit: 75, // maximum stack trace frames to be stored (in case trace option was provided as true)\n      connectInZone: true // If set to true, the connection is established within the Angular zone\n    })\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Generating a Grouped User Action File (Shell)\nDESCRIPTION: Example command showing how to generate a 'User' action file within a dedicated 'actions' subfolder by using the `--group` option. This creates an `actions/` directory if it doesn't exist and places the action file inside.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/schematics/action.md#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\nng generate action User --group\n```\n\n----------------------------------------\n\nTITLE: Creating Selected Entity Feature with ngrx/signals (TypeScript)\nDESCRIPTION: This code creates a `withSelectedEntity` feature that manages the selected entity in a store. It utilizes `signalStoreFeature`, `withState`, and `withComputed` to add the `selectedEntityId` state slice and the `selectedEntity` computed signal.  It also requires the store to have `EntityState` properties defined (e.g., via `withEntities`). The `type` helper function is used to specify the expected state type.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/custom-store-features.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { computed } from '@angular/core';\nimport { signalStoreFeature, type, withComputed, withState } from '@ngrx/signals';\nimport { EntityId, EntityState } from '@ngrx/signals/entities';\n\nexport type SelectedEntityState = { selectedEntityId: EntityId | null };\n\nexport function withSelectedEntity<Entity>() {\n  return signalStoreFeature(\n    { state: type<EntityState<Entity>>() },\n    withState<SelectedEntityState>({ selectedEntityId: null }),\n    withComputed(({ entityMap, selectedEntityId }) => ({\n      selectedEntity: computed(() => {\n        const selectedId = selectedEntityId();\n        return selectedId ? entityMap()[selectedId] : null;\n      }),\n    }))\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Installing NgRx Store with Angular CLI and No Minimal Setup (Shell)\nDESCRIPTION: This command installs @ngrx/store into an Angular project using the Angular CLI while skipping the minimal setup, leading to the generation of state and reducer scaffolding files. It updates package.json, installs dependencies, creates state folder/files, and configures both the StoreModule and metaReducers in the specified module. Dependencies: Angular CLI, existing Angular project. Input: None. Output: Full NgRx store initialization with state and reducer scaffolding. Limitations: Requires Angular CLI and proper project structure.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/install.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nng add @ngrx/store@latest --no-minimal\n```\n\n----------------------------------------\n\nTITLE: Creating a Reusable NgRx Selector Pipeable Operator (TypeScript)\nDESCRIPTION: Defines a reusable custom RxJS pipeable operator named `selectFilteredValues`. It leverages the RxJS `pipe` utility function to combine the NgRx `select` operator (with `selectValues`) and the RxJS `filter` operator (to exclude undefined values), promoting code reuse. The example shows its application to the store.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/selectors.md#_snippet_15\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { select } from '@ngrx/store';\nimport { pipe } from 'rxjs';\nimport { filter } from 'rxjs/operators';\n\nexport const selectFilteredValues = pipe(\n  select(selectValues),\n  filter(val => val !== undefined)\n);\n\nstore.pipe(selectFilteredValues).subscribe(/* .. */);\n```\n\n----------------------------------------\n\nTITLE: Defining Component State Interface in TypeScript\nDESCRIPTION: Defines the TypeScript interface (`SlideToggleState`) representing the shape of the local UI state managed by `ComponentStore` for the `SlideToggleComponent`. This interface typically includes properties relevant to the component's state, such as `checked: boolean`.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/component-store/usage.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\n// src/app/slide-toggle.component.ts (region: state)\ninterface SlideToggleState {\n  checked: boolean;\n  // ... other state properties if any\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing ComponentStore via Constructor in Angular\nDESCRIPTION: This snippet demonstrates how to initialize a `ComponentStore` in Angular using the constructor. The `MoviesStore` class extends `ComponentStore` and initializes the initial state with an empty array of movies. The state is immediately available to the consumers. This method is suitable when the initial state is known during the component's instantiation.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/component-store/initialization.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface MoviesState {\n  movies: Movie[];\n}\n\n@Injectable()\nexport class MoviesStore extends ComponentStore<MoviesState> {\n  \n  constructor() {\n    super({movies: []});\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Manually Destroying Specific rxMethod Subscription - NgRx Signals - TypeScript\nDESCRIPTION: Demonstrates that invoking a reactive method with a Signal or Observable returns an object containing a `destroy()` method. This allows for the explicit cleanup of that specific subscription without affecting other active calls of the same method.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/rxjs-integration.md#_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Component, OnInit } from '@angular/core';\nimport { interval, tap } from 'rxjs';\nimport { rxMethod } from '@ngrx/signals/rxjs-interop';\n\n@Component({ /* ... */ })\nexport class NumbersComponent implements OnInit {\n  readonly logNumber = rxMethod<number>(tap(console.log));\n\n  ngOnInit(): void {\n    const num1$ = interval(500);\n    const num2$ = interval(1_000);\n\n    const num1Ref = this.logNumber(num1$);\n    const num2Ref = this.logNumber(num2$);\n\n    setTimeout(() => {\n      // 👇 Destroy the first reactive method call after 2 seconds.\n      num1Ref.destroy();\n    }, 2_000);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Integration Testing NgRx Store with StoreModule.forRoot in Angular TypeScript Tests\nDESCRIPTION: Integration tests configure a real Store instance by importing StoreModule.forRoot in the TestBed, thus avoiding mocks. This enables verifying interactions between components and the Store in a realistic environment, including action dispatching and selector emissions. The example included asserts that UI interaction, such as button clicks, correctly dispatch expected actions and update state selections.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/testing.md#_snippet_3\n\n\n\n----------------------------------------\n\nTITLE: Testing Effects that uses state\nDESCRIPTION: This snippet illustrates testing an effect that uses state management with `MockStore` and `MockSelectors`. It configures the test bed with mock store and selectors. The input is a mocked state, which lets you test how an effect reacts to different states; the expected output is checked via the `toBeObservable`. This allows testing scenarios based on specific application states.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/effects/testing.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nlet actions$: Observable&lt;Action&gt;;\n\nTestBed.configureTestingModule({\n  providers: [\n    CustomersEffects,\n    provideMockActions(() => actions$),\n    // mock the Store and the selectors that are used within the Effect\n    provideMockStore({\n      selectors: [\n        {\n          selector: selectCustomers,\n          value: {\n            Bob: { name: 'Bob' },\n          },\n        },\n      ],\n    }),\n  ],\n});\n\neffects = TestBed.inject&lt;CustomersEffects&gt;(CustomersEffects);\n\nit('should not fetch if the user is already in the store', () => {\n  actions$ = hot('-a--', {\n    a: { type: '[Customers Page] Search Customers', name: 'Bob' },\n  });\n\n  // there is no output, because Bob is already in the Store state\n  const expected = hot('----');\n\n  expect(effects.getByName$).toBeObservable(expected);\n});\n```\n\n----------------------------------------\n\nTITLE: Correct NgRx Effect Callback with Block Statement - TypeScript\nDESCRIPTION: This snippet demonstrates the correct usage of an NgRx effect callback with a block statement.  The code is functionally equivalent to the incorrect example, but the inclusion of curly braces around the effect logic improves readability and facilitates debugging, especially when working with type errors.  It utilizes `createEffect`, `ofType`, and `concatMap` operators.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/prefer-effect-callback-in-block-statement.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nclass Effect {\n  effectOK = createEffect(() => {\n    return this.actions.pipe(\n      ofType(detailsLoaded),\n      concatMap(() => ...),\n    )\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Composite Selector Using Generated NgRx Feature Selectors in TypeScript\nDESCRIPTION: Demonstrates how to use the selectors automatically generated by `createFeature`. It uses `createSelector` to combine the `selectBooks` and `selectLoading` selectors obtained from the `booksFeature` object to create a new composite selector, `selectBookListPageViewModel`, for a view model.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/feature-creators.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createSelector } from '@ngrx/store';\nimport { booksFeature } from './books.reducer';\n\nexport const selectBookListPageViewModel = createSelector(\n  booksFeature.selectBooks,\n  booksFeature.selectLoading,\n  (books, loading) => ({ books, loading })\n);\n```\n\n----------------------------------------\n\nTITLE: Using createMockStore for Testing (V15.4+) (TypeScript)\nDESCRIPTION: Demonstrates the recommended way to create a mock store for testing in NgRx v15.4 and later, using the `createMockStore` function from `@ngrx/store/testing`. This function replaces the deprecated `getMockStore`.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v15.md#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createMockStore } from '@ngrx/store/testing';\nconst mockStore = createMockStore();\n```\n\n----------------------------------------\n\nTITLE: Correct Implementation of NgRx Effects\nDESCRIPTION: A proper implementation of NgRx effects that follows best practices. Instead of dispatching actions within an effect, this approach creates separate effect streams for different actions, each with a clear, single responsibility.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/no-dispatch-in-effects.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport class Effects {\n  loadData$ = createEffect(() =>\n    this.actions$.pipe(\n      ofType(loadData),\n      exhaustMap(() =>\n        this.dataService.getData().pipe(\n          map((response) => loadDataSuccess(response)),\n          catchError((error) => of(loadDataError(error)))\n        )\n      )\n    )\n  );\n\n  handleCondition$ = createEffect(() =>\n    this.actions$.pipe(\n      ofType(loadDataSuccess),\n      filter((response) => response.condition),\n      exhaustMap(() =>\n        this.dataService.getOtherData().pipe( \n          map((data) => anotherAction(data)), \n          catchError((error) => of(handleConditionError(error)))\n        )\n      )\n    )\n  );\n\n  constructor(private readonly actions$: Actions) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Effects with Observables\nDESCRIPTION: This snippet demonstrates how to test effects using direct Observables. It involves creating an actions stream with `of`, mocking a service response, and subscribing to the effect to verify the dispatched action. This is a simpler approach suitable for basic effects where timing or complex sequences are not the primary focus.  The input is an action stream and a service mock; the output is verified through a subscription to the effect's stream.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/effects/testing.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n// create an actions stream and immediately dispatch a GET action\nactions$ = of({ type: '[Customers Page] Get Customers' });\n\n// mock the service to prevent an HTTP request\ncustomersServiceSpy.getAllCustomers.and.returnValue(of([...]));\n\n// subscribe to the Effect stream and verify it dispatches a SUCCESS action\neffects.getAll$.subscribe(action => {\n  expect(action).toEqual({\n    type: '[Customers API] Get Customers Success',\n    customers: [...],\n  });\n  done();\n});\n```\n\n----------------------------------------\n\nTITLE: Creating User Reducer with NgRx createReducer - TypeScript\nDESCRIPTION: This snippet creates a reducer function for the user feature using NgRx's createReducer and on helpers. It responds to addUser by adding a user entity and to selectUser by updating the selectedUserId property in the state. The reducer depends on the previously defined initialState and UserListPageActions, and makes use of the entity adapter's addOne method for immutability.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/entity/recipes/entity-adapter-with-feature-creator.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createReducer, on } from '@ngrx/store';\nimport { UserListPageActions } from './user-list-page.actions';\n\nconst reducer = createReducer(\n  initialState,\n  on(UserListPageActions.addUser, (state, { user }) =>\n    adapter.addOne(user, state)\n  ),\n  on(UserListPageActions.selectUser, (state, { userId }) => ({\n    ...state,\n    selectedUserId: userId,\n  }))\n);\n\n```\n\n----------------------------------------\n\nTITLE: Creating a signalMethod Processor Function in Angular with TypeScript\nDESCRIPTION: Defines a processor function using signalMethod that accepts an input of type number or Signal<number>. The processor computes a doubled value and logs it, demonstrating flexible input handling with static values or signals. Requires Angular and @ngrx/signals. The processor function can be called multiple times with different inputs and tracks only the Signal parameter explicitly.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-method.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Component } from '@angular/core';\nimport { signalMethod } from '@ngrx/signals';\n\n@Component({ /* ... */ })\nexport class NumbersComponent {\n  // 👇 This method will have an input argument\n  // of type `number | Signal<number>`.\n  readonly logDoubledNumber = signalMethod<number>((num) => {\n    const double = num * 2;\n    console.log(double);\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Using NgRx Data EntitySelectorsFactory to Combine Entity and Application State in TypeScript\nDESCRIPTION: This snippet demonstrates how to create and use entity selectors outside of Angular components by leveraging the EntitySelectorsFactory to generate selectors for a specific entity type ('Owner'). It combines selectors with an existing reducer state ('Cat') using @ngrx/store's createSelector to map entities with related data. Dependencies include NgRx Data and NgRx Store libraries. The snippet imports reducers and models, defines the application state interface, configures reducers, and creates selectors that combine entity collections with related entity maps to produce enriched data views. This approach facilitates advanced state selection logic in reducers or other parts of the application that are not components.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/extension-points.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* src/app/reducers/index.ts */\nimport * as fromCat from './cat.reducer';\nimport { Owner } from '~/app/models'\n\nexport const ownerSelectors = new EntitySelectorsFactory().create<Owner>('Owner');\n\nexport interface State {\n  cat: fromCat.State;\n}\n\nexport const reducers: ActionReducerMap<State> = {\n  cat: fromCat.reducer\n};\n\nexport const selectCatState = (state: State) => state.cat;\n\nexport const {\n  selectAll: selectAllCats\n} = fromCat.adapter.getSelectors(selectCatState);\n\nexport const selectedCatsWithOwners = createSelector(\n  selectAllCats,\n  ownerSelectors.selectEntityMap,\n  (cats, ownerEntityMap) => cats.map(c => ({\n    ...c,\n    owner: ownerEntityMap[c.owner]\n  }))\n);\n```\n\n----------------------------------------\n\nTITLE: Initializing ROOT_EFFECTS_INIT Action Handler in NgRx Effects (TypeScript)\nDESCRIPTION: A code example showing how to use the ROOT_EFFECTS_INIT action as a lifecycle hook in NgRx to execute code after all root effects have been added.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/effects/lifecycle.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninit$ = createEffect(() => {\n  return this.actions$.pipe(\n    ofType(ROOT_EFFECTS_INIT),\n    map(action => ...)\n  );\n});\n```\n\n----------------------------------------\n\nTITLE: Providing an NgRx SignalStore Globally Using `providedIn: 'root'` in TypeScript\nDESCRIPTION: Configures the `BooksStore` to be provided application-wide by setting the `providedIn` property to `'root'` within the `signalStore` definition. This registers the store with the root injector, making it a singleton service accessible throughout the application via dependency injection.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/index.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { signalStore, withState } from '@ngrx/signals';\nimport { Book } from './book.model';\n\ntype BooksState = { /* ... */ };\n\nconst initialState: BooksState = { /* ... */ };\n\nexport const BooksStore = signalStore(\n  // 👇 Providing `BooksStore` at the root level.\n  { providedIn: 'root' },\n  withState(initialState)\n);\n```\n\n----------------------------------------\n\nTITLE: Refactoring Angular Component to Use NgRx Store\nDESCRIPTION: Shows how to refactor the `MoviesPageComponent` to leverage NgRx Store. The component now injects the `Store`, selects the relevant state (`movies$`) as an Observable, and dispatches an action (`[Movies Page] Load Movies`) in `ngOnInit` to trigger the data loading process, delegating the side effect to NgRx Effects.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/effects/index.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Component, inject, OnInit } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\n@Component({\n  template: `\n    <div *ngFor=\"let movie of movies$ | async\">\n      {{ movie.name }}\n    </div>\n  `,\n  imports: [CommonModule],\n})\nexport class MoviesPageComponent implements OnInit {\n  private store = inject(Store<{ movies: Movie[] }>);\n  protected movies$ = this.store.select(state => state.movies);\n\n  ngOnInit() {\n    this.store.dispatch({ type: '[Movies Page] Load Movies' });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering NgRx Root State (Standalone API) - TypeScript\nDESCRIPTION: Registers the root NgRx store and the scoreboard state using the standalone Angular APIs `provideStore` and `provideState`. This setup is used when bootstrapping a standalone Angular application, making the state available under the key 'game'.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/reducers.md#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { bootstrapApplication } from '@angular/platform-browser';\nimport { provideStore, provideState } from '@ngrx/store';\n\nimport { AppComponent } from './app.component';\nimport { scoreboardReducer } from './reducers/scoreboard.reducer';\n\nbootstrapApplication(AppComponent, {\n  providers: [\n    provideStore(),\n    provideState({ name: 'game', reducer: scoreboardReducer })\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Up Root Reducer with Router Reducer in TypeScript\nDESCRIPTION: Defines the application state interface including the router reducer slice and registers the routerReducer within the ActionReducerMap. This setup integrates the router state into the NgRx store, enabling state management for navigation events.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/router-store/configuration.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface State {\n  router: RouterReducerState<any>;\n}\n  \nexport const reducers: ActionReducerMap<State> = {\n  router: routerReducer\n};\n```\n\n----------------------------------------\n\nTITLE: Migrating to Factory Selector in NgRx Store - TypeScript\nDESCRIPTION: This TypeScript snippet illustrates the recommended factory selector approach in NgRx. It defines a selector as a function that takes a customerId argument and returns a createSelector call, improving type safety and memoization. No props argument is required; instead, the function signature directly includes the required parameter. This pattern aligns with modern NgRx practices for better maintainability and performance.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v12.md#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nconst selectCustomer = (customerId: number) =>\n  createSelector(\n    selectCustomers,\n    (customers) => {\n      return customers[customerId];\n    }\n  );\n```\n\n----------------------------------------\n\nTITLE: Correct Implementation Using Dedicated Selectors\nDESCRIPTION: This example shows the recommended approach of defining a separate selector that handles the mapping logic, and then using that selector directly in the component without additional transformations.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/avoid-mapping-selectors.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// in selectors.ts:\nexport selectLoggedInUserName = createSelector(\n  selectLoggedInUser,\n  (user) => user.name\n)\n\n// in component:\nexport class Component {\n  name$ = this.store.select(selectLoggedInUserName)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Books Component with SignalState and Angular template syntax\nDESCRIPTION: Demonstrates a component that uses SignalState through a service to display a list of books, including conditional rendering based on loading state and using Angular's modern template syntax.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-state.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ChangeDetectionStrategy, Component, inject, OnInit } from '@angular/core';\nimport { BooksStore } from './books.store';\n\n@Component({\n  selector: 'ngrx-books',\n  template: `\n    <h1>Books</h1>\n  \n    @if (store.isLoading()) {\n      <p>Loading...</p>\n    } @else {\n      <ul>\n        @for (book of store.books(); track book.id) {\n          <li>{{ book.title }}</li>\n        }\n      </ul>\n    }\n  `,\n  providers: [BooksStore],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class BooksComponent implements OnInit {\n  readonly store = inject(BooksStore);\n\n  ngOnInit(): void {\n    this.store.loadBooks();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering NgRx Root State (NgModule) - TypeScript\nDESCRIPTION: Registers the scoreboard reducer as part of the root state of the NgRx store within an Angular NgModule using `StoreModule.forRoot()`. This makes the reducer available globally upon application startup under the specified key ('game').\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/reducers.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { NgModule } from '@angular/core';\nimport { StoreModule } from '@ngrx/store';\nimport { scoreboardReducer } from './reducers/scoreboard.reducer';\n\n@NgModule({\n  imports: [\n    StoreModule.forRoot({ game: scoreboardReducer })\n  ],\n})\nexport class AppModule {}\n```\n\n----------------------------------------\n\nTITLE: Correct usage of concatLatestFrom in NGRX effect\nDESCRIPTION: This snippet demonstrates the correct pattern by replacing withLatestFrom with concatLatestFrom, ensuring it only triggers when the specified action occurs and the state is ready. Key dependencies include createEffect, ofType, concatLatestFrom, and store selectors.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/prefer-concat-latest-from.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nclass Effect {\n  detail$ = createEffect(() => {\n    return this.actions.pipe(\n      ofType(ProductDetailPage.loaded),\n      concatLatestFrom(() => this.store.select(selectProducts)),\n      mergeMap(([action, products]) => {\n        ...\n      })\n    )\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Installing NgRx Data with ng add in Shell\nDESCRIPTION: Executes the ng add command to install the @ngrx/data package and automatically update your Angular project. This command updates package.json, installs dependencies, and configures your app.module import array. Optional flags allow customization for module, project, effects, migration, and entity configuration. The command requires the Angular CLI and a configured Angular project.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/install.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nng add @ngrx/data@latest\n```\n\n----------------------------------------\n\nTITLE: Using NgRx Selectors in Angular Component - TypeScript\nDESCRIPTION: This Angular component example demonstrates how to inject the NgRx store and use the selectors generated by createFeature for reactive user state querying. The component exposes users$, isUserSelected$, and selectedUser$ as observable streams, allowing the component template to respond to real-time state changes. Dependencies include the Store from NgRx and the previously defined usersFeature's selectors.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/entity/recipes/entity-adapter-with-feature-creator.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { usersFeature } from './users.state';\n\n@Component({ /* ... */ })\nexport class UserListComponent{\n  private readonly store = inject(Store);\n  \n  readonly users$ = this.store.select(usersFeature.selectAll);\n  readonly isUserSelected$ = this.store.select(usersFeature.selectIsUserSelected);\n  readonly selectedUser$ = this.store.select(usersFeature.selectSelectedUser);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Lifecycle Hooks with Object Signature in ngrx/signals\nDESCRIPTION: Example showing how to use withHooks with an object signature to implement onInit and onDestroy hooks in a SignalStore. The onInit hook sets up an interval to increment the counter every 2 seconds using takeUntilDestroyed for automatic cleanup.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/lifecycle-hooks.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { computed } from '@angular/core';\nimport { takeUntilDestroyed } from '@angular/core/rxjs-interop';\nimport { interval } from 'rxjs';\nimport { patchState, signalStore, withState, withHooks, withMethods } from '@ngrx/signals';\n\nexport const CounterStore = signalStore(\n  withState({ count: 0 }),\n  withMethods((store) => ({\n    increment(): void {\n      patchState(store, (state) => ({ count: state.count + 1 }));\n    },\n  })),\n  withHooks({\n    onInit(store) {\n      // 👇 Increment the `count` every 2 seconds.\n      interval(2_000)\n        // 👇 Automatically unsubscribe when the store is destroyed.\n        .pipe(takeUntilDestroyed())\n        .subscribe(() => store.increment());\n    },\n    onDestroy(store) {\n      console.log('count on destroy', store.count());\n    },\n  }),\n);\n```\n\n----------------------------------------\n\nTITLE: Empty NgRx Root State (Standalone API) - TypeScript\nDESCRIPTION: Initializes the root NgRx store using `provideStore()` without registering any state segments initially in a standalone Angular application. This sets up the core store provider, allowing feature states to be registered later.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/reducers.md#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { bootstrapApplication } from '@angular/platform-browser';\nimport { provideStore } from '@ngrx/store';\n\nimport { AppComponent } from './app.component';\n\nbootstrapApplication(AppComponent, {\n  providers: [\n    provideStore()\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Dispatching a Login Action from an Angular Component Method in TypeScript\nDESCRIPTION: This snippet demonstrates how to dispatch the Login action from within an Angular component method, using the NgRx store. The 'onSubmit' function accepts 'username' and 'password', then calls store.dispatch with a properly constructed login action. The component must have access to an injected Store. Inputs: credentials fields; Output: action dispatched to the NgRx Store.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/actions.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nonSubmit(username: string, password: string) {\n  store.dispatch(login({ username: username, password: password }));\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Feature State in Route Configuration - TypeScript\nDESCRIPTION: This snippet demonstrates how to register a feature state within the `providers` array of a route configuration using `provideState`. This enables feature-specific reducers to be available in the application when the corresponding route is activated.  It uses `provideState` from `@ngrx/store` to define the feature state.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/reducers.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Route } from '@angular/router';\nimport { provideState } from '@ngrx/store';\n\nimport { scoreboardFeatureKey, scoreboardReducer } from './reducers/scoreboard.reducer';\n\nexport const routes: Route[] = [\n  {\n    path: 'scoreboard',\n    providers: [\n      provideState({ name: scoreboardFeatureKey, reducer: scoreboardReducer })\n    ]\n  }\n];\n```\n\n----------------------------------------\n\nTITLE: Example of additionalCollectionState configuration (TypeScript)\nDESCRIPTION: This code shows how to add custom properties to the entity collection's state, initializing them with specific values.  This demonstrates adding `foo` and `bar` properties to the test hero metadata.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/entity-metadata.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nadditionalCollectionState: {\n    foo: 'Foo',\n    bar: 3.14\n  }\n```\n\n----------------------------------------\n\nTITLE: Using Custom Entity Identifier with SelectId in NgRx SignalStore (TypeScript)\nDESCRIPTION: This code configures a SignalStore to use a custom key property instead of the default 'id' for entity identification. The selectId function maps the custom entity property. All add, set, and update updaters are provided this selector through an options object. The snippet requires @ngrx/signals, @ngrx/signals/entities, and the definition of a Todo type with a 'key' property. Input functions receive entities; outputs are state mutations. The remove* updaters do not require custom selectors.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/entity-management.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { patchState, signalStore, withMethods } from '@ngrx/signals';\nimport {\n  addEntities,\n  removeEntity,\n  SelectEntityId,\n  setEntity,\n  updateAllEntities,\n  withEntities,\n} from '@ngrx/signals/entities';\n\ntype Todo = {\n  key: number;\n  text: string;\n  completed: boolean;\n};\n\nconst selectId: SelectEntityId<Todo> = (todo) => todo.key;\n\nexport const TodosStore = signalStore(\n  withEntities<Todo>(),\n  withMethods((store) => ({\n    addTodos(todos: Todo[]): void {\n      patchState(store, addEntities(todos, { selectId }));\n    },\n    setTodo(todo: Todo): void {\n      patchState(store, setEntity(todo, { selectId }));\n    },\n    completeAllTodos(): void {\n      patchState(\n        store,\n        updateAllEntities({ completed: true }, { selectId })\n      );\n    },\n    removeTodo(key: number): void {\n      patchState(store, removeEntity(key));\n    },\n  }))\n);\n\n```\n\n----------------------------------------\n\nTITLE: Controlling Effect Lifecycle with OnRunEffects in NgRx (TypeScript)\nDESCRIPTION: Demonstrates how to implement the OnRunEffects interface to control when effects are subscribed to and unsubscribed from, based on specific actions in the application.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/effects/lifecycle.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Injectable } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { exhaustMap, takeUntil, tap } from 'rxjs/operators';\nimport {\n  Actions,\n  OnRunEffects,\n  EffectNotification,\n  ofType,\n  createEffect,\n} from '@ngrx/effects';\n\n@Injectable()\nexport class UserEffects implements OnRunEffects {\n  private actions$ = inject(Actions);\n\n  updateUser$ = createEffect(() => {\n    return this.actions$.pipe(\n        ofType('UPDATE_USER'),\n        tap(action => {\n          console.log(action);\n        })\n      );\n  }, { dispatch: false });\n\n  ngrxOnRunEffects(resolvedEffects$: Observable<EffectNotification>) {\n    return this.actions$.pipe(\n      ofType('LOGGED_IN'),\n      exhaustMap(() =>\n        resolvedEffects$.pipe(\n          takeUntil(this.actions$.pipe(ofType('LOGGED_OUT')))\n        )\n      )\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Injecting Store into Counter Component and Implementing Dispatch Actions (TypeScript)\nDESCRIPTION: Completes the implementation of 'MyCounterComponent' by injecting the NgRx Store service and connecting the count$ observable to select the current counter state from the store. It implements the increment, decrement, and reset methods by dispatching the corresponding actions to modify the global state. This snippet demonstrates integration of reactive state selection and action dispatching within a component class.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/index.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\n\n```\n\n----------------------------------------\n\nTITLE: Using createFeatureSelector to select feature state slice\nDESCRIPTION: Provides a type-safe, top-level selector for a feature state slice using 'createFeatureSelector', simplifying access to feature-specific data within the global store.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/selectors.md#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { createSelector, createFeatureSelector } from '@ngrx/store';\n\nexport const featureKey = 'feature';\n\nexport interface FeatureState {\n  counter: number;\n}\n\nexport const selectFeature = createFeatureSelector<FeatureState>(featureKey);\n\nexport const selectFeatureCount = createSelector(\n  selectFeature,\n  (state: FeatureState) => state.counter\n);\n```\n\n----------------------------------------\n\nTITLE: Registering Feature State on Bootstrap - TypeScript\nDESCRIPTION: This example shows how to register the feature state during application bootstrap using the `provideStore` function. The `bootstrapApplication` function from `@angular/platform-browser` is used. The `provideStore` function is used to provide the reducer for the `scoreboardFeatureKey`. This allows the feature state to be available from the start of the application. It uses the `AppComponent`, and `scoreboardReducer`.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/reducers.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { bootstrapApplication } from '@angular/platform-browser';\nimport { provideStore } from '@ngrx/store';\n\nimport { AppComponent } from './app.component';\nimport { scoreboardFeatureKey, scoreboardReducer } from './reducers/scoreboard.reducer';\n\nbootstrapApplication(AppComponent, {\n  providers: [\n    provideStore({ [scoreboardFeatureKey]: scoreboardReducer }),\n  ]\n});\n```\n\n----------------------------------------\n\nTITLE: Defining rxMethod with Input Type - NgRx Signals - TypeScript\nDESCRIPTION: Demonstrates how to define a reactive method using `rxMethod` and specify the input type using a generic argument. It shows chaining RxJS operators like `map` and `tap` within the `pipe` function to process the input value.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/rxjs-integration.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Component } from '@angular/core';\nimport { map, pipe, tap } from 'rxjs';\nimport { rxMethod } from '@ngrx/signals/rxjs-interop';\n\n@Component({ /* ... */ })\nexport class NumbersComponent {\n  // 👇 This reactive method will have an input argument\n  // of type `number | Signal<number> | Observable<number>`.\n  readonly logDoubledNumber = rxMethod<number>(\n    // 👇 RxJS operators are chained together using the `pipe` function.\n    pipe(\n      map((num) => num * 2),\n      tap(console.log)\n    )\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Selecting and Filtering NgRx State Using RxJS Operators (TypeScript)\nDESCRIPTION: Demonstrates selecting state using a selector function (`selectValues`) applied directly within an RxJS `pipe` on the store observable. It uses the `map` operator to extract the state slice and the `filter` operator to ensure the value is not `undefined` before the subscription logic.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/selectors.md#_snippet_13\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { map, filter } from 'rxjs/operators';\n\nstore\n  .pipe(\n    map(state => selectValues(state)),\n    filter(val => val !== undefined)\n  )\n  .subscribe(/* .. */);\n```\n\n----------------------------------------\n\nTITLE: Creating Request Status Feature with ngrx/signals (TypeScript)\nDESCRIPTION: This code demonstrates how to create a custom feature using `signalStoreFeature` to manage request status in an NgRx SignalStore. It includes a state slice for the request status and computed signals for checking the status. The feature utilizes `withState` to define the initial state and `withComputed` to derive signals based on the state.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/custom-store-features.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { computed } from '@angular/core';\nimport { signalStoreFeature, withComputed, withState } from '@ngrx/signals';\n\nexport type RequestStatus = 'idle' | 'pending' | 'fulfilled' | { error: string };\nexport type RequestStatusState = { requestStatus: RequestStatus };\n\nexport function withRequestStatus() {\n  return signalStoreFeature(\n    withState<RequestStatusState>({ requestStatus: 'idle' }),\n    withComputed(({ requestStatus }) => ({\n      isPending: computed(() => requestStatus() === 'pending'),\n      isFulfilled: computed(() => requestStatus() === 'fulfilled'),\n      error: computed(() => {\n        const status = requestStatus();\n        return typeof status === 'object' ? status.error : null;\n      }),\n    }))\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Registering NgRx Effects at Root Level (TypeScript)\nDESCRIPTION: Example showing how to register both class-based and functional effects at the root level using the provideEffects method in the application's providers array.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/effects/index.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { bootstrapApplication } from '@angular/platform-browser';\nimport { provideStore } from '@ngrx/store';\nimport { provideEffects } from '@ngrx/effects';\n\nimport { AppComponent } from './app.component';\nimport { MoviesEffects } from './effects/movies.effects';\nimport * as actorsEffects from './effects/actors.effects';\n\nbootstrapApplication(AppComponent, {\n  providers: [\n    provideStore(),\n    provideEffects(MoviesEffects, actorsEffects),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Non-dispatching Effects in NgRx (TypeScript)\nDESCRIPTION: Demonstrates how to create an effect that doesn't dispatch an action by using the { dispatch: false } metadata option, useful for side effects like logging or navigation.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/effects/lifecycle.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Injectable, inject } from '@angular/core';\nimport { Actions, createEffect } from '@ngrx/effects';\nimport { tap } from 'rxjs/operators';\n\n@Injectable()\nexport class LogEffects {\n  private actions$ = inject(Actions);\n  \n  logActions$ = createEffect(() => {\n    return this.actions$.pipe(\n        tap(action => console.log(action))\n    );\n    }, { dispatch: false });\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Multiple Named Entity Collections in a Single NgRx SignalStore (TypeScript)\nDESCRIPTION: This example shows a SignalStore configured to manage multiple entity types (Book, Author, Category) in parallel by invoking withEntities multiple times with distinct collection names. The withMethods block demonstrates adding entities to their respective collections using the collection option. Required dependencies are @ngrx/signals, @ngrx/signals/entities, and the definitions of Book, Author, and Category types. Each patchState accepts entity data and the collection name; results are parallel entity collections within a unified store instance.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/entity-management.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport const LibraryStore = signalStore(\n  withEntities({ entity: type<Book>(), collection: 'book' }),\n  withEntities({ entity: type<Author>(), collection: 'author' }),\n  withEntities({ entity: type<Category>(), collection: 'category' }),\n  withMethods((store) => ({\n    addBook(book: Book): void {\n      patchState(store, addEntity(book, { collection: 'book' }));\n    },\n    addAuthor(author: Author): void {\n      patchState(store, addEntity(author, { collection: 'author' }));\n    },\n    addCategory(category: Category): void {\n      patchState(store, addEntity(category, { collection: 'category' }));\n    },\n  }))\n);\n\n```\n\n----------------------------------------\n\nTITLE: Defining Actions Using Classes in NgRx - TypeScript\nDESCRIPTION: This snippet shows examples of incorrect action definitions using class implementations of the Action interface, including the deprecated use of fixed type properties and constructors with payloads. It highlights patterns that the rule discourages to maintain consistency with modern NgRx best practices.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/prefer-action-creator.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nclass Test implements Action {\n  type = '[Customer Page] Load Customer';\n}\n\nclass Test implements ngrx.Action {\n  readonly type = ActionTypes.success;\n\n  constructor(readonly payload: Payload) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Basic NgRx Action Generation Command Syntax (Shell)\nDESCRIPTION: Demonstrates the basic syntax for generating an NgRx action file using the Angular CLI `ng generate action` command. Replace `ActionName` with the desired name for the action set and optionally include command options.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/schematics/action.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nng generate action ActionName [options]\n```\n\n----------------------------------------\n\nTITLE: Filter state in selector (correct approach)\nDESCRIPTION: Demonstrates best practice by selecting individual slices of state and combining them within a selector, enhancing performance and modularity.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/avoid-combining-component-store-selectors.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport class Component extends ComponentStore<MoviesState> {\n  movies$ = this.select((state) => state.movies);\n  selectedId$ = this.select((state) => state.selectedId);\n  movie$ = this.select(\n    this.movies$, \n    this.selectedId$, \n    ([movies, selectedId]) => movies[selectedId]\n  );\n\n  constructor() {\n    super({ movies: [] });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: NgRx Effect Using Custom Observable Source (TypeScript)\nDESCRIPTION: Example of an effect that uses a custom observable source (DOM events) instead of actions, to track user activity and send click events to a monitoring service.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/effects/index.md#_snippet_12\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Injectable, inject } from '@angular/core';\nimport { Observable, fromEvent } from 'rxjs';\nimport { concatMap } from 'rxjs/operators';\nimport { createEffect } from '@ngrx/effects';\n\nimport { UserActivityService } from '../services/user-activity.service';\n\n@Injectable()\nexport class UserActivityEffects {\n  private userActivityService = inject(UserActivityService);\n  \n  trackUserActivity$ = createEffect(() => {\n    return fromEvent(document, 'click').pipe(\n      concatMap(event => this.userActivityService.trackUserActivity(event)),\n    );\n  }, { dispatch: false });\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Initial NgRx Root Store with Schematics\nDESCRIPTION: Angular CLI command utilizing @ngrx/schematics to scaffold the initial root state management structure. It generates necessary files (like reducers/index.ts) for a state slice named 'State', marks it as root (`--root`), and registers the `StoreModule.forRoot()` in the specified application module (`app.module.ts`).\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/schematics/index.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nng generate @ngrx/schematics:store State --root --module app.module.ts\n```\n\n----------------------------------------\n\nTITLE: Defining NgRx Actions for State Updates - TypeScript\nDESCRIPTION: Defines NgRx actions using `createAction` and `props` for updating the state. The `selectUser` action carries a `userId` payload to identify the selected user, intended to update the custom state property. The `loadUsers` action carries an array of `User` entities, intended to update the entity collection.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/entity/recipes/additional-state-properties.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { createAction, props } from '@ngrx/store';\nimport { Update } from '@ngrx/entity';\n\nimport { User } from '../models/user.model';\n\nexport const selectUser = createAction('[Users Page] Select User', props<{ userId: string }>());\nexport const loadUsers = createAction('[User/API] Load Users', props<{ users: User[] }>());\n```\n\n----------------------------------------\n\nTITLE: Extending EntityServices with application-specific AppEntityServices\nDESCRIPTION: Creates a subclass of EntityServices that injects custom services and exposes them via properties for easier access. Also provides a convenient method to get default services like SideKick. This approach simplifies maintaining and accessing multiple entity services in complex applications.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/entity-services.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Injectable } from '@angular/core';\nimport { EntityServicesBase, EntityServicesElements } from '@ngrx/data';\n\nimport { SideKick } from '../../model';\nimport { HeroService, VillainService } from '../../services';\n\n@Injectable()\nexport class AppEntityServices extends EntityServicesBase {\n  constructor(\n    elements: EntityServicesElements,\n    readonly heroesService: HeroService,\n    readonly villainsService: VillainService\n  ) {\n    super(elements);\n    this.registerEntityCollectionServices([heroesService, villainsService]);\n  }\n\n  get sideKicksService() {\n    return this.getEntityCollectionService<SideKick>('SideKick');\n  }\n}\n\n// In AppModule\n@NgModule({\n  providers: [\n    AppEntityServices,\n    { provide: EntityServices, useExisting: AppEntityServices }\n  ]\n})\nexport class EntityStoreModule {}\n\n```\n\n----------------------------------------\n\nTITLE: Counter Component Template with Buttons and Displaying Store State (HTML)\nDESCRIPTION: The HTML template for 'MyCounterComponent' containing buttons to increment, decrement, and reset the counter and a binding to display the current counter state asynchronously through the count$ observable. It hooks user interactions to component methods that dispatch state-changing actions via the store. This template enables UI-driven state management conforming to reactive data streams.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/index.md#_snippet_5\n\nLANGUAGE: HTML\nCODE:\n```\n    <button (click)=\"increment()\">Increment</button>\n\n    <div>Current Count: {{ count$ | async }}</div>\n\n    <button (click)=\"decrement()\">Decrement</button>\n\n    <button (click)=\"reset()\">Reset Counter</button>\n```\n\n----------------------------------------\n\nTITLE: Using Recommended createFeature Signature (V15.2+) (TypeScript)\nDESCRIPTION: Shows the recommended, simplified signature for `createFeature` introduced in NgRx v15.2. This signature omits the root state generic parameter, relying on type inference. This improves feature modularity and reduces boilerplate code.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v15.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nexport const usersFeature = createFeature({\n  name: 'users',\n  reducer: createReducer(initialState, /* case reducers */),\n});\n```\n\n----------------------------------------\n\nTITLE: Using custom state updaters with patchState\nDESCRIPTION: Demonstrates how to use custom state updaters with the patchState function, comparing the before and after approach to show improved readability and maintainability.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-state.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n// Before:\npatchState(userState, (state) => ({\n  user: { ...state.user, firstName: 'Stevie' },\n  isAdmin: true,\n}));\n\n// After:\npatchState(userState, setFirstName('Stevie'), setAdmin());\n```\n\n----------------------------------------\n\nTITLE: Incorrect usage of withLatestFrom in NGRX effect\nDESCRIPTION: This snippet shows an effect implementation that incorrectly uses withLatestFrom, which causes the selector to subscribe immediately regardless of action dispatch, potentially leading to errors if the state isn't initialized. Dependencies include createEffect, ofType, withLatestFrom, and store selectors.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/prefer-concat-latest-from.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nclass Effect {\n  detail$ = createEffect(() => {\n    return this.actions.pipe(\n      ofType(ProductDetailPage.loaded),\n      // ⚠\n      withLatestFrom(this.store.select(selectProducts)),\n      mergeMap(([action, products]) => {\n        ...\n      })\n    )\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing an Updater Method in ComponentStore with TypeScript\nDESCRIPTION: Demonstrates how to create an updater method in a MoviesStore class that extends ComponentStore. The updater adds a movie to the movies array in state while maintaining immutability.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/component-store/write.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n@Injectable()\nexport class MoviesStore extends ComponentStore<MoviesState> {\n  \n  constructor() {\n    super({movies: []});\n  }\n\n  readonly addMovie = this.updater((state, movie: Movie) => ({\n    movies: [...state.movies, movie],\n  }));\n}\n```\n\n----------------------------------------\n\nTITLE: Setting NgRx Initial State (Scoreboard Example) - TypeScript\nDESCRIPTION: Sets the initial default value for the scoreboard state. This value is used when the reducer is first initialized or if the current state is undefined, providing a starting point for the state.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/reducers.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport const initialState: State = {\n  home: 0,\n  away: 0,\n};\n```\n\n----------------------------------------\n\nTITLE: Fix for Immutability Violation in State\nDESCRIPTION: This code snippet provides the correct implementation to fix the immutability violation illustrated in the previous example. It demonstrates creating a new state object using the spread operator and array creation, ensuring that the original state is not modified. This is the correct pattern for working with NgRx.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/configuration/runtime-checks.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nexport const reducer = createReducer(\n  initialState,\n  on(addTodo, (state, { todo }) => ({\n    ...state,\n    todoInput: '',\n    todos: [...state.todos, todo],\n  }))\n);\n```\n```\n\n----------------------------------------\n\nTITLE: Using AsyncPipe to Subscribe to EntityCollectionService Selector Observable in Angular Template with HTML\nDESCRIPTION: This Angular HTML snippet shows template usage where the filteredHeroes$ observable from the EntityCollectionService is asynchronously subscribed using the AsyncPipe with the '*ngIf' structural directive. The resulting heroes array is assigned to a local template variable which can be used within the block to display or process the filtered list reactively as data changes in the NgRx store.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/entity-collection-service.md#_snippet_2\n\nLANGUAGE: HTML\nCODE:\n```\n<div *ngIf=\"filteredHeroes$ | async as heroes\">\n...\n</div>\n```\n\n----------------------------------------\n\nTITLE: Integration Test with HttpClient\nDESCRIPTION: This integration test verifies the interaction between `MoviesComponent` and `MoviesStore`, including the usage of `HttpClient`. It sets up the testing module with `provideHttpClient` and `provideHttpClientTesting`, simulates user input, and checks for the expected HTTP request and response.  Dependencies include @angular/common/http and @angular/common/http/testing, along with the component itself.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/testing.md#_snippet_14\n\nLANGUAGE: TypeScript\nCODE:\n```\nit('should show movies with MoviesStore', async () => {\n  const fixture = TestBed.configureTestingModule({\n    imports: [MoviesComponent],\n    providers: [provideHttpClient(), provideHttpClientTesting()],\n  }).createComponent(MoviesComponent);\n\n  const ctrl = TestBed.inject(HttpTestingController);\n\n  fixture.autoDetectChanges(true);\n\n  const input: HTMLInputElement = fixture.debugElement.query(\n    By.css('input')\n  ).nativeElement;\n  input.value = 'Warner Bros';\n  input.dispatchEvent(new Event('input'));\n\n\n  ctrl.expectOne('https://movies.com/studios?query=Warner%20Bros').flush(\n    [\n      {id: 1, name: 'Harry Potter'},\n      {id: 2, name: 'The Dark Knight'},\n    ]\n  )\n  await fixture.whenStable()\n\n  const movies = fixture.debugElement.queryAll(By.css('p')).map((el) =>\n    el.nativeElement.textContent\n  );\n  expect(movies).toEqual(['1: Harry Potter', '2: The Dark Knight']);\n  ctrl.verify();\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Component-Based Side Effects in Angular\nDESCRIPTION: Demonstrates a standard Angular component that directly injects a service (`MoviesService`) and fetches data within its `ngOnInit` lifecycle hook. The component manages the fetched data (`movies`) as local state. This illustrates the approach before introducing NgRx Effects.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/effects/index.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Component, inject, OnInit } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\n@Component({\n  template: `\n    <li> *ngFor=\"let movie of movies\">\n      {{ movie.name }}\n    </li>\n  `,\n  imports: [CommonModule],\n})\nexport class MoviesPageComponent implements OnInit {\n  private moviesService = inject(MoviesService);\n  protected movies: Movie[] = [];\n\n  ngOnInit() {\n    this.movieService.getAll()\n      .subscribe(movies => this.movies = movies);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Correct ngOnDestroy override in ComponentStore (TypeScript)\nDESCRIPTION: This code demonstrates the correct way to override the ngOnDestroy method in a ComponentStore subclass. It calls super.ngOnDestroy() after performing custom cleanup logic, ensuring proper resource management. This adherence to the rule avoids potential memory leaks and ensures the ComponentStore's internal cleanup processes are executed. This shows a component that extends ComponentStore and correctly calls the super method within the overridden ngOnDestroy.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/require-super-ondestroy.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\n@Injectable()\nexport class BooksStore extends ComponentStore<BooksState> implements OnDestroy\n{\n  // ... other BooksStore class members\n\n  override ngOnDestroy(): void {\n    this.cleanUp();\n    super.ngOnDestroy();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Providing Mock Actions for Testing\nDESCRIPTION: This snippet demonstrates how to provide a mock `Actions` Observable using `provideMockActions` from `@ngrx/effects/testing`.  This mock allows effects to subscribe and react to actions during testing by injecting a mock provider for `Actions` Observable. The provided lambda expression takes an `Observable<Action>` which acts as a stream of actions.  It is used within the `TestBed.configureTestingModule` to set up the test environment.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/effects/testing.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { provideMockActions } from '@ngrx/effects/testing';\n\nlet actions$ = new Observable&lt;Action&gt;();\n\nTestBed.configureTestingModule({\n  providers: [provideMockActions(() => actions$)],\n});\n```\n\n----------------------------------------\n\nTITLE: Testing MovieStore with Observables\nDESCRIPTION: This code tests the `MoviesStore`'s `load` method, verifying its behavior when a new studio name is entered before or after the previous request completes. It uses Jest for mocking and `fakeAsync` to manage asynchronous operations, along with `delay` to simulate network requests.  Dependencies: Jest, rxjs (pipe, delay), @angular/core, @angular/core/testing.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/testing.md#_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\ndescribe('MoviesStore', () => {\n  // ... beforeEach and afterEach omitted\n\n  const setup = () => {\n    const moviesService = {\n      load: jest.fn((studio: string) =>\n        of([\n          studio === 'Warner Bros'\n            ? { id: 1, name: 'Harry Potter' }\n            : { id: 2, name: 'Jurassic Park' }\n        ]).pipe(delay(100))\n      ),\n    };\n\n    TestBed.configureTestingModule({\n      providers: [\n        {\n          provide: MoviesService,\n          useValue: moviesService,\n        },\n      ],\n    });\n\n    return TestBed.inject(MoviesStore);\n  };\n\n  it('should load two times', fakeAsync(() => {\n    const store = setup();\n\n    const studio$ = new Subject<string>();\n    store.load(studio$);\n    studio$.next('Warner Bros');\n\n    tick(100);\n    expect(store.movies()).toEqual([{ id: 1, name: 'Harry Potter' }]);\n\n    studio$.next('Universal');\n    tick(100);\n    expect(store.movies()).toEqual([{ id: 2, name: 'Jurassic Park' }]);\n  }));\n\n  it('should cancel a running request when a new one is made', fakeAsync(() => {\n    const store = setup();\n\n    const studio$ = new Subject<string>();\n    store.load(studio$);\n    studio$.next('Warner Bros');\n\n    tick(50);\n    studio$.next('Universal');\n\n    tick(50);\n    expect(store.movies()).toEqual([]);\n    expect(store.loading()).toBe(true);\n\n    tick(50);\n    expect(store.movies()).toEqual([{ id: 2, name: 'Jurassic Park' }]);\n    expect(store.loading()).toBe(false);\n  }));\n});\n```\n\n----------------------------------------\n\nTITLE: Generating Data Entity Models with Angular CLI using shell\nDESCRIPTION: This snippet shows how to generate data entity model files and associated services using Angular CLI commands. It outlines two equivalent commands, 'ng generate data EntityName [options]' and 'ng generate dt EntityName [options]', which scaffold data structures within the Angular project. The commands accept options such as specifying the project, folder structure (flat or nested), grouping into a 'data' folder, and whether to skip generating test spec files. This is essential for quickly setting up NgRx data models and services in an Angular application. Dependencies include having Angular CLI installed and the NgRx platform configured in the project.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/schematics/data.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nng generate data EntityName [options]\n```\n\nLANGUAGE: shell\nCODE:\n```\nng generate dt EntityName [options]\n```\n\n----------------------------------------\n\nTITLE: Adding ngrx/router-store with Angular CLI\nDESCRIPTION: This snippet demonstrates how to install the @ngrx/router-store package using the Angular CLI's `ng add` command. This command automates several steps, including adding the package as a dependency and setting up the necessary configurations. The command uses the `@ngrx/router-store@latest` package for the latest version. The optional flags can specify project, path, and module for import.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/router-store/install.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nng add @ngrx/router-store@latest\n```\n\n----------------------------------------\n\nTITLE: Implementing Entity Updaters in NgRx SignalStore with withMethods (TypeScript)\nDESCRIPTION: This snippet demonstrates integrating standalone entity updaters into a SignalStore via withMethods to add, remove, and complete all todos. Functions like addEntity, removeEntities, and updateAllEntities from @ngrx/signals/entities work through patchState. The Todo type is assumed to be defined elsewhere. Inputs are entities and updater logic; outputs are state changes in the SignalStore. Dependencies include @ngrx/signals, @ngrx/signals/entities, and entity updaters. Proper types ensure correct parameter usage.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/entity-management.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { patchState, signalStore, withMethods } from '@ngrx/signals';\nimport {\n  addEntity,\n  removeEntities,\n  updateAllEntities,\n  withEntities,\n} from '@ngrx/signals/entities';\n\ntype Todo = { /* ... */ };\n\nexport const TodosStore = signalStore(\n  withEntities<Todo>(),\n  withMethods((store) => ({\n    addTodo(todo: Todo): void {\n      patchState(store, addEntity(todo));\n    },\n    removeEmptyTodos(): void {\n      patchState(store, removeEntities(({ text }) => !text));\n    },\n    completeAllTodos(): void {\n      patchState(store, updateAllEntities({ completed: true }));\n    },\n  }))\n);\n\n```\n\n----------------------------------------\n\nTITLE: Creating MockStore Without TestBed Using Injector.create in Angular NgRx Testing (TypeScript)\nDESCRIPTION: This example demonstrates creating a MockStore instance without Angular's TestBed by using Injector.create with provideMockStore in the providers array. It allows setup of a mocked store with an initial state for components or services that require Store dependencies in isolated tests, providing an alternative to TestBed-based configuration.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/testing.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { MockStore, provideMockStore } from '@ngrx/store/testing';\nimport { Injector } from '@angular/core';\n\ndescribe('Books Component', () => {\n  let store: MockStore;\n  const initialState = { books: ['Book 1', 'Book 2', 'Book 3'] };\n\n  beforeEach(() => {\n    const injector = Injector.create({\n      providers: [\n        provideMockStore({ initialState }),\n      ],\n    });\n    \n    store = injector.get(MockStore);\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Defining SignalStore with Private Members in TypeScript\nDESCRIPTION: This snippet shows how to create a SignalStore using @ngrx/signals, incorporating private state slices, computed signals, properties, and methods. Private members are prefixed with an underscore (_), which restricts their external access while enabling internal encapsulation. The store includes public and private parts, useful for maintaining internal logic and state management.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/private-store-members.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { computed } from '@angular/core';\nimport { toObservable } from '@angular/core/rxjs-interop';\nimport {\n  patchState,\n  signalStore,\n  withComputed,\n  withMethods,\n  withProps,\n  withState\n} from '@ngrx/signals';\n\nexport const CounterStore = signalStore(\n  withState({\n    count1: 0,\n    // 👇 private state slice\n    _count2: 0,\n  }),\n  withComputed(({ count1, _count2 }) => ({\n    // 👇 private computed signal\n    _doubleCount1: computed(() => count1() * 2),\n    doubleCount2: computed(() => _count2() * 2),\n  })),\n  withProps(({ count2, _doubleCount1 }) => ({\n    // 👇 private property\n    _count2$: toObservable(count2),\n    doubleCount1$: toObservable(_doubleCount1),\n  })),\n  withMethods((store) => ({\n    increment1(): void {\n      patchState(store, { count1: store.count1() + 1 });\n    },\n    // 👇 private method\n    _increment2(): void {\n      patchState(store, { _count2: store._count2() + 1 });\n    },\n  }))\n);\n\n```\n\n----------------------------------------\n\nTITLE: Overriding Parameters\nDESCRIPTION: This snippet demonstrates how to override default parameter values for an effect during testing. By passing parameters with specific values, the test can control the behavior of time-dependent effects like `debounceTime`. This is achieved by calling the effect function with the desired parameters. The default values for effect parameters can be overridden using values provided during test execution.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/effects/testing.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// override the default values\neffects.search$({\n  debounce: 30,\n  scheduler: getTestScheduler(),\n});\n```\n\n----------------------------------------\n\nTITLE: Using Debounced Selectors in NgRx ComponentStore for Efficient State Updates with TypeScript\nDESCRIPTION: Shows a ComponentStore with debounced selector fetchMoviesData$ that delays emission until all microtask state changes complete, improving performance by avoiding rapid successive updates. It includes updater methods to update moviesPerPage and currentPageIndex, and an effect that reacts to the debounced data stream to fetch movies asynchronously using a MovieService. Requires RxJS and Angular dependencies.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/component-store/read.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n@Injectable()\nexport class MoviesStore extends ComponentStore<MoviesState> {\n  \n  constructor(private movieService: MovieService) {\n    super({movies: [], moviesPerPage: 10, currentPageIndex: 0});\n \n    // 👇 effect is triggered whenever debounced data is changed\n    this.fetchMovies(this.fetchMoviesData$);\n  }\n\n  // Updates how many movies per page should be displayed\n  readonly updateMoviesPerPage = this.updater((state, moviesPerPage: number) => ({\n    ...state,\n    moviesPerPage, // updates with new value\n  }));\n\n  // Updates which page of movies that the user is currently on\n  readonly updateCurrentPageIndex = this.updater((state, currentPageIndex: number) => ({\n    ...state,\n    currentPageIndex, // updates with new page index\n  }));\n\n  readonly moviesPerPage$ = this.select(state => state.moviesPerPage);\n\n  readonly currentPageIndex$ = this.select(state => state.currentPageIndex);\n\n  private readonly fetchMoviesData$ = this.select({\n    moviesPerPage: this.moviesPerPage$,\n    currentPageIndex: this.currentPageIndex$\n  },{debounce: true}, // 👈 setting this selector to debounce\n  );\n  \n  private readonly fetchMovies = this.effect(\n    (moviePageData$: Observable<{moviesPerPage: number; currentPageIndex: number}>) => {\n      return moviePageData$.pipe(\n        concatMap(({moviesPerPage, currentPageIndex}) => {\n          return this.movieService\n            .loadMovies(moviesPerPage, currentPageIndex)\n            .pipe(tap((results) => this.updateMovieResults(results)));\n        }),\n      );\n    },\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing EntityCollectionService in Angular with TypeScript\nDESCRIPTION: This TypeScript snippet shows a component constructor creating an EntityCollectionService instance for the 'Hero' entity type using EntityCollectionServiceFactory. It demonstrates setting up observable selectors (filteredHeroes$ and loading$) to reactively track filtered entity data and loading state from the NgRx store. The constructor assigns the service instance and observable properties to component fields for use elsewhere in the component.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/entity-collection-service.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nconstructor(EntityCollectionServiceFactory: EntityCollectionServiceFactory) {\n  this.heroService = EntityCollectionServiceFactory.create<Hero>('Hero');\n  this.filteredHeroes$ = this.heroService.filteredEntities$;\n  this.loading$ = this.heroService.loading$;\n}\n```\n\n----------------------------------------\n\nTITLE: Fix for Serializability Violation in State\nDESCRIPTION: This shows the correct way to fix the `strictStateSerializability` violation by converting the `Date` object to a JSON string representation, such as by using `toJSON()`. This makes it serializable and preservable.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/configuration/runtime-checks.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nexport const reducer = createReducer(\n  initialState,\n  on(completeTodo, (state, { id }) => ({\n    ...state,\n    todos: {\n      ...state.todos,\n      [id]: {\n        ...state.todos[id],\n        completedOn: new Date().toJSON(),\n      },\n    },\n  }))\n);\n```\n```\n\n----------------------------------------\n\nTITLE: Selecting state with props in component usage\nDESCRIPTION: Shows how to invoke a selector with specific props within a component to obtain computed values, illustrating dynamic parameter passing at call time.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/selectors.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nngOnInit() {\n  this.counter = this.store.select(fromRoot.selectCount, { multiply: 2 })\n}\n```\n\n----------------------------------------\n\nTITLE: Combining Multiple Selectors in NgRx ComponentStore Using TypeScript\nDESCRIPTION: Demonstrates combining multiple observable selectors (movies and userPreferredMoviesIds) into a derived selector userPreferredMovies$ that filters movies based on user preferences. This shows how to use multiple inputs in the select method to create complex selectors. Requires Angular and '@ngrx/component-store'.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/component-store/read.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface MoviesState {\n  movies: Movie[];\n  userPreferredMoviesIds: string[];\n}\n\n@Injectable()\nexport class MoviesStore extends ComponentStore<MoviesState> {\n  \n  constructor() {\n    super({movies:[], userPreferredMoviesIds:[]});\n  }\n\n  readonly movies$ = this.select(state => state.movies);\n  readonly userPreferredMovieIds$ = this.select(state => state.userPreferredMoviesIds);\n\n  readonly userPreferredMovies$ = this.select(\n        this.movies$,\n        this.userPreferredMovieIds$,\n        (movies, ids) => movies.filter(movie => ids.includes(movie.id))\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Subscribing to State Transition History Using a Custom Operator (TypeScript)\nDESCRIPTION: Demonstrates applying the custom pipeable operator `selectLastStateTransitions` to the NgRx `store`. This example subscribes to the observable returned by the operator, configured to track and emit the last 3 state transitions derived from `selectProjectedValues`.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/selectors.md#_snippet_18\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Subscribe to the store using the custom pipeable operator\nstore.pipe(selectLastStateTransitions(3)).subscribe(/* .. */);\n```\n\n----------------------------------------\n\nTITLE: Defining NgRx Effect with createEffect in V15 (TypeScript)\nDESCRIPTION: Demonstrates the required method for defining an NgRx effect in v15 using the `createEffect` function. The effect logic, encapsulated in an observable stream (e.g., `this.actions$.pipe(...)`), is passed as a factory function to `createEffect`. This replaces the removed `@Effect` decorator.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v15.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\ndata$ = createEffect(() => this.actions$.pipe());\n```\n\n----------------------------------------\n\nTITLE: Generating and Registering a Reducer in an Angular Module (sh)\nDESCRIPTION: Example command to generate a 'User' reducer and automatically register it within a specified Angular Module (`app.module.ts`). The `--module` option ensures the reducer is added to the module's `imports` array using `StoreModule.forFeature`.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/schematics/reducer.md#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\nng generate reducer User --module app.module.ts\n```\n\n----------------------------------------\n\nTITLE: Disabling EntityCacheEffects in TypeScript\nDESCRIPTION: Shows how to disable the default EntityCacheEffects by providing a null implementation in your NgModule configuration, allowing you to handle server interactions manually.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/save-entities.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n{ provide: EntityCacheEffects: useValue: {} }\n```\n\n----------------------------------------\n\nTITLE: Implementing Lifecycle Hooks with Factory Function in ngrx/signals\nDESCRIPTION: Example demonstrating the factory function approach for withHooks, which enables dependency injection and shared state between hooks. This approach is useful when needing to access injected services or when hook implementations need to share variables.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/lifecycle-hooks.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport const CounterStore = signalStore(\n  /* ... */\n  withHooks((store) => {\n    const logger = inject(Logger);\n    let interval = 0;\n\n    return {\n      onInit() {\n        interval = setInterval(() => store.increment(), 2_000);\n      },\n      onDestroy() {\n        logger.info('count on destroy', store.count());\n        clearInterval(interval);\n      },\n    };\n  }),\n);\n```\n\n----------------------------------------\n\nTITLE: Using MockStore.overrideSelector to Mock Selectors in NgRx Testing with TypeScript\nDESCRIPTION: This pattern illustrates how to mock individual selectors in unit tests by overriding them with provideMockStore and MockStore.overrideSelector(). The overridden selectors return preset values irrespective of the current store state. The MemoizedSelector returned by overrideSelector supports updating its result via setResult(), and MockStore.refreshState() triggers selectors to emit updated values. This technique allows precise testing of components or effects dependent on specific selectors.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/testing.md#_snippet_1\n\n\n\n----------------------------------------\n\nTITLE: Registering NgRx Feature Using provideState in Angular Route Configuration\nDESCRIPTION: Illustrates how to register an NgRx feature specifically for a route using `provideState` within the route's `providers` array. This allows for lazy loading of the feature state and reducer when the route is activated.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/feature-creators.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Route } from '@angular/router';\nimport { provideState } from '@ngrx/store';\n\nimport { booksFeature } from './books.reducer';\n\nexport const routes: Route[] = [\n  {\n    path: 'books',\n    providers: [\n      provideState(booksFeature)\n    ]\n  }\n];\n```\n\n----------------------------------------\n\nTITLE: Setting Up NgRx Store DevTools in an Angular Standalone Application\nDESCRIPTION: Example of configuring NgRx Store DevTools in an Angular standalone application using the ApplicationConfig pattern. Shows how to provide the DevTools with custom settings for maximum history size, logging behavior, and selective feature enablement.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store-devtools/config.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport const appConfig: ApplicationConfig = {\n  providers: [\n    provideStoreDevtools({\n      maxAge: 25,\n      logOnly: false,\n      autoPause: true,\n      features: {\n        pause: false,\n        lock: true,\n        persist: true\n      }\n    })\n  ],\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Using DeepSignal with deepComputed in TypeScript\nDESCRIPTION: Example demonstrating how to create a DeepSignal using the deepComputed function from @ngrx/signals. It shows how to initialize signals, create a pagination object with computed properties, and access both the complete object and individual properties as signals.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/deep-computed.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { signal } from '@angular/core';\nimport { deepComputed } from '@ngrx/signals';\n\nconst limit = signal(25);\nconst offset = signal(0);\nconst totalItems = signal(100);\n\nconst pagination = deepComputed(() => ({\n  currentPage: Math.floor(offset() / limit()) + 1,\n  pageSize: limit(),\n  totalPages: Math.ceil(totalItems() / limit()),\n}));\n\nconsole.log(pagination()); // logs: { currentPage: 1, pageSize: 25, totalPages: 4 }\nconsole.log(pagination.currentPage()); // logs: 1\nconsole.log(pagination.pageSize()); // logs: 25\nconsole.log(pagination.totalPages()); // logs: 4\n```\n\n----------------------------------------\n\nTITLE: Defining EntityMetadataMap for Hero and Villain entities (TypeScript)\nDESCRIPTION: This code defines an `EntityMetadataMap` for two entity types, `Hero` and `Villain`. It shows how to specify optional settings like `filterFn`, `sortComparer`, `entityName`, `selectId`, and `entityDispatcherOptions` for each entity. This metadata is used by NgRx Data to manage the entity collections in the store.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/entity-metadata.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport const appEntityMetadata: EntityMetadataMap = {\n  Hero: {\n    /* optional settings */\n    filterFn: nameFilter,\n    sortComparer: sortByName\n  },\n  Villain: {\n    villainSelectId, // necessary if key is not `id`\n\n    /* optional settings */\n    entityName: 'Villain', // optional because same as map key\n    filterFn: nameAndSayingFilter,\n    entityDispatcherOptions: { optimisticAdd: true, optimisticUpdate: true }\n  }\n};\n```\n\n----------------------------------------\n\nTITLE: Creating NgRx Reducer with Explicit Return Type (Correct) - TypeScript\nDESCRIPTION: This snippet shows the correct way to use the `on` function by providing an explicit `AppState` return type for the callback function. This allows TypeScript to enforce that the returned object conforms to the `AppState` interface, preventing the addition of undefined properties and ensuring type safety within the reducer logic.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/on-function-explicit-return-type.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface AppState {\n  username: string;\n}\n\nconst reducer = createReducer<AppState>(\n  { username: '' },\n  on(\n    setUsername,\n    (state, action): AppState => ({\n      ...state,\n      username: action.payload,\n      // adding new properties that do not exist on `AppState` is impossible, as the function return type is explicitly stated\n    })\n  )\n);\n```\n\n----------------------------------------\n\nTITLE: Accessing multiple entity collection services via injected EntityServices\nDESCRIPTION: Illustrates how to retrieve multiple EntityCollectionService instances for different entities within a component, using a single injection of EntityServices. Enhances code clarity and reduces boilerplate in components needing multiple entity collections.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/entity-services.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { EntityCollectionService, EntityServices } from '@ngrx/data';\nimport { Hero } from '../../model';\nimport { SideKick } from '../../model';\nimport { VillainService } from '../../services';\n\n@Component({/* component metadata */})\nexport class CharacterContainerComponent implements OnInit {\n  heroesService: EntityCollectionService<Hero>;\n  sideKicksService: EntityCollectionService<SideKick>;\n  villainService: VillainService;\n\n  heroes$: Observable<Hero[]>;\n\n  constructor(entityServices: EntityServices) {\n    this.heroesService = entityServices.getEntityCollectionService('Hero');\n    this.sideKicksService = entityServices.getEntityCollectionService('SideKick');\n    this.villainService = entityServices.getEntityCollectionService('Villain');\n\n    this.heroes$ = this.heroesService.entities$;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: SignalStore with Asynchronous Methods and Dependencies\nDESCRIPTION: This snippet shows how to create a SignalStore with asynchronous methods that depend on injected services. It includes a load method that retrieves movies by studio and updates the store state accordingly.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/testing.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { signalStore, withState } from '@ngrx/signals';\n\ntype State = { studio: string; movies: Movie[]; loading: boolean };\n\nexport const MoviesStore = signalStore(\n  withState<State>({\n    studio: '',\n    movies: [],\n    loading: false,\n  }),\n  withMethods((store) => {\n    const moviesService = store.inject(MoviesService);\n\n    return {\n      async load(studio: string) {\n        this.patchState({ loading: true });\n        const movies = await moviesService.loadMovies(studio);\n        this.patchState(store, { studio, movies, loading: false });\n      },\n    };\n  })\n);\n```\n\n----------------------------------------\n\nTITLE: Defining ComponentStore Selectors with Proper Internal Mapping - NgRx ComponentStore - TypeScript\nDESCRIPTION: This snippet exemplifies the recommended pattern for creating derived observables in NgRx ComponentStore. Both 'loggedInUser$' and 'name$' are defined directly using 'this.select', with mapping logic for extracting the user's name embedded as the projector function in the second selector. This keeps all transformation logic at the selector level, aligning with the rule's guidance. Dependencies include NgRx ComponentStore, RxJS (optionally, though not used explicitly here), and a type parameter 'UserState'.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/avoid-mapping-component-store-selectors.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport class UserStore extends ComponentStore<UserState> {\n  loggedInUser$ = this.select((state) => state.loggedInUser);\n\n  name$ = this.select(this.loggedInUser$, (user) => user.name);\n}\n```\n\n----------------------------------------\n\nTITLE: Refactoring createSelector Usage in NgRx Store for TypeScript\nDESCRIPTION: Illustrates the updated and recommended way to define selectors in NgRx Store using the createSelector function. The breaking change enforces that selectors must have at least one input selector function before the projector function, improving clarity and type safety. The example shows a selector that retrieves a list of todos by their id, refactored from a single projector function to a selector with an input selector and a projector argument. This requires understanding of NgRx selectors, state schema typing, and proper projector function parameters.\nSOURCE: https://github.com/ngrx/platform/blob/main/CHANGELOG.md#_snippet_45\n\nLANGUAGE: typescript\nCODE:\n```\nconst getTodosById = createSelector((state: TodoAppSchema, id: number) => state.todos.find((p) => p.id === id));\n\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst getTodosById = createSelector(\n  (state: TodoAppSchema) => state.todos,\n  (todos: Todo[], id: number) => todos.find((p) => p.id === id)\n);\n\n```\n\n----------------------------------------\n\nTITLE: Implementing NgRx Reducer for Entity and Custom State - TypeScript\nDESCRIPTION: Implements the reducer logic using NgRx `createReducer` and `on`. It shows how to initialize the state including the custom `selectedUserId` property. The `selectUser` action updates only the custom property manually, while the `loadUsers` action uses the entity adapter (`addMany`) to update the entity collection *while* also manually resetting the `selectedUserId` property.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/entity/recipes/additional-state-properties.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { EntityState, EntityAdapter, createEntityAdapter } from '@ngrx/entity';\nimport { Action, createReducer, on } from '@ngrx/store';\nimport { User } from '../models/user.model';\nimport * as UserActions from '../actions/user.actions';\n\nexport interface State extends EntityState<User> {\n  // additional state property\n  selectedUserId: string | null;\n}\n\nexport const adapter: EntityAdapter<User> = createEntityAdapter<User>();\n\nexport const initialState: State = adapter.getInitialState({\n  // additional entity state properties\n  selectedUserId: null,\n});\n\nexport const reducer = createReducer(\n  initialState,\n  on(UserActions.selectUser, (state, { userId }) => {\n    return { ...state, selectedUserId: userId };\n  }),\n  on(UserActions.loadUsers, (state, { users }) => {\n    return adapter.addMany(users, { ...state, selectedUserId: null });\n  })\n);\n```\n\n----------------------------------------\n\nTITLE: Returning Multiple Actions in an NgRx Effect (TypeScript - Incorrect Example)\nDESCRIPTION: This snippet demonstrates an Effect class where an effect returns an array of actions from within a switchMap, resulting in multiple actions being dispatched. Dependencies include @ngrx/effects (for createEffect and Actions) and RxJS operators such as ofType, exhaustMap, switchMap, and catchError. Inputs are actions emitted via the actions$ stream, and outputs are dispatched actions. This pattern is discouraged, as each effect should only dispatch a single action to ensure maintainability and proper state management.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/no-multiple-actions-in-effects.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport class Effects {\n  loadEmployeeList$ = createEffect(() => {\n    return this.actions$.pipe(\n      ofType(componentLoaded),\n      exhaustMap(() =>\n        this.dataService.loadEmployeeList().pipe(\n          switchMap((response) => [\n            loadEmployeeListSuccess(response),\n            loadCompanyList(),\n            cleanData(),\n          ]),\n          catchError((error) => loadEmployeeListError(error))\n        )\n      )\n    );\n  });\n\n  loadCompanyList$ = createEffect(() => {\n    return this.actions$.pipe(\n      ofType(loadCompanyList)\n      // handle loadCompanyList\n    );\n  });\n\n  cleanData$ = createEffect(() => {\n    return this.actions$.pipe(\n      ofType(cleanData)\n      // handle cleanData\n    );\n  });\n\n  constructor(private readonly actions$: Actions) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Dispatching Actions Based on Signal Changes in Angular Component (TypeScript)\nDESCRIPTION: This TypeScript class demonstrates advanced usage of the NgRx store's dispatch method in an Angular component context, using signal-based state (via input.required<number>()) to drive dynamic action dispatching. The store dispatches the loadBook action whenever the bookId signal changes. This pattern requires Signal support and NgRx Store injection. Inputs: none directly; the signal derives data. Output: action dispatches with updated id.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/actions.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nclass BookComponent {\n  bookId = input.required<number>();\n\n  constructor(store: Store) {\n    store.dispatch(() => loadBook({ id: this.bookId() }));\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using mapResponse in NgRx Effects\nDESCRIPTION: This code demonstrates how to use the `mapResponse` operator in an NgRx effect.  It handles an API call to load movies and maps the successful response to a `moviesLoadedSuccess` action and the error to `moviesLoadedFailure` action. Dependencies include `@ngrx/effects` and a service to fetch the movies.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/operators/operators.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\n  export const loadMovies = createEffect(\n    (actions$ = inject(Actions), moviesService = inject(MoviesService)) => {\n      return actions$.pipe(\n        ofType(MoviesPageActions.opened),\n        exhaustMap(() =>\n          moviesService.getAll().pipe(\n            mapResponse({\n              next: (movies) => MoviesApiActions.moviesLoadedSuccess({ movies }),\n              error: (error: { message: string }) =>\n                MoviesApiActions.moviesLoadedFailure({ errorMsg: error.message }),\n            })\n          )\n        )\n      );\n    },\n    { functional: true }\n  );\n```\n\n----------------------------------------\n\nTITLE: Accessing state properties through generated signals\nDESCRIPTION: Demonstrates how SignalState generates signals for each state property, allowing access to individual properties in a type-safe manner.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-state.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst user = userState.user; // type: DeepSignal<User>\nconst isAdmin = userState.isAdmin; // type: Signal<boolean>\n\nconsole.log(user()); // logs: { firstName: 'Eric', lastName: 'Clapton' }\nconsole.log(isAdmin()); // logs: false\n```\n\n----------------------------------------\n\nTITLE: Creating Custom NgRx Selectors for Nested Route Parameters (TypeScript)\nDESCRIPTION: Demonstrates custom NgRx selectors (`selectRouteNestedParams`, `selectRouteNestedParam`) designed to extract all parameters from a nested route tree by iterating through the router state's root and its children. This contrasts with default `selectRouteParam{s}` which only target the leaf route. Requires `@angular/router` for `Params`, `@ngrx/store` for `createSelector`, and assumes a base `selectRouter` selector exists.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/router-store/selectors.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Params } from '@angular/router';\nimport { createSelector } from '@ngrx/store';\n\nexport const selectRouteNestedParams = createSelector(selectRouter, (router) => {\n  let currentRoute = router?.state?.root;\n  let params: Params = {};\n  while (currentRoute?.firstChild) {\n    currentRoute = currentRoute.firstChild;\n    params = {\n      ...params,\n      ...currentRoute.params,\n    };\n  }\n  return params;\n});\n\nexport const selectRouteNestedParam = (param: string) =>\n  createSelector(selectRouteNestedParams, (params) => params && params[param]);\n```\n\n----------------------------------------\n\nTITLE: Creating an NgRx Entity Adapter in TypeScript\nDESCRIPTION: Demonstrates creating an `EntityAdapter` for a `User` entity using `createEntityAdapter` from `@ngrx/entity`. It defines the `User` interface, the `State` interface extending `EntityState<User>`, and provides optional custom `selectId` and `sortComparer` functions for adapter configuration.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/entity/adapter.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { EntityState, EntityAdapter, createEntityAdapter } from '@ngrx/entity';\n\nexport interface User {\n  id: string;\n  name: string;\n}\n\nexport interface State extends EntityState<User> {\n  // additional entities state properties\n  selectedUserId: string | null;\n}\n\nexport function selectUserId(a: User): string {\n  //In this case this would be optional since primary key is id\n  return a.id;\n}\n\nexport function sortByName(a: User, b: User): number {\n  return a.name.localeCompare(b.name);\n}\n\nexport const adapter: EntityAdapter<User> = createEntityAdapter<User>({\n  selectId: selectUserId,\n  sortComparer: sortByName,\n});\n```\n\n----------------------------------------\n\nTITLE: Loading State Eagerly in AppModule - TypeScript\nDESCRIPTION: This snippet shows how to add the `ScoreboardModule` to the `AppModule`'s imports to eagerly load the state. The `StoreModule.forRoot({})` is also present to register the root store. Dependencies include `@ngrx/store` and the `ScoreboardModule`. It initializes the store in the AppModule.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/reducers.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { NgModule } from '@angular/core';\nimport { StoreModule } from '@ngrx/store';\nimport { ScoreboardModule } from './scoreboard/scoreboard.module';\n\n@NgModule({\n  imports: [\n    StoreModule.forRoot({}),\n    ScoreboardModule\n  ],\n})\nexport class AppModule {}\n\n```\n\n----------------------------------------\n\nTITLE: Testing Asynchronous Methods in MoviesStore with Mocked Dependencies\nDESCRIPTION: This test demonstrates how to test an asynchronous load method in a SignalStore with mocked dependencies. It uses fakeAsync and tick to handle the asynchronous behavior and verifies both loading state and final results.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/testing.md#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\ndescribe('MoviesStore', () => {\n  it('should load movies of Warner Bros', fakeAsync(() => {\n    const moviesService = {\n      load: () =>\n        Promise.resolve([\n          { id: 1, name: 'Harry Potter' },\n          { id: 2, name: 'The Dark Knight' },\n        ]),\n    };\n\n    TestBed.configureTestingModule({\n      providers: [\n        {\n          provide: MoviesService,\n          useValue: moviesService,\n        },\n      ],\n    });\n\n    const store = TestBed.inject(MoviesStore);\n    store.load('Warner Bros');\n    expect(store.loading()).toBe(true);\n    \n    tick();\n\n    expect(store.moviesCount()).toBe(2);\n    expect(store.loading()).toBe(false);\n  }));\n});\n```\n\n----------------------------------------\n\nTITLE: Dispatching Effects on Initialization with OnInitEffects\nDESCRIPTION: This snippet highlights the change in effect dispatching behavior when the `OnInitEffects` lifecycle hook is used. The effect's initial action is now dispatched only once upon first module load, not on every lazy load.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v9.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Effect class implementing OnInitEffects\nclass MyEffect implements OnInitEffects {\n  ngrxOnInitEffects(): Action {\n    return { type: '[MyEffect] Init' };\n  }\n  effect$ = createEffect(() => ...);\n}\n```\n\n----------------------------------------\n\nTITLE: Partial Mocking via Spies\nDESCRIPTION: This test shows partial mocking using spies to test the `MoviesComponent`. It mocks the `MoviesStore`'s `load` method using `jest.spyOn` and allows computed properties to function correctly. Dependencies include @angular/core/testing and @angular/core; the test sets up the testing module and simulates the component's interaction with the store, checking that data is displayed correctly. The test utilizes `patchState` function (assumed implementation for this test context) for managing component state.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/testing.md#_snippet_13\n\nLANGUAGE: TypeScript\nCODE:\n```\nit('should show movies (spy)', () => {\n  TestBed.configureTestingModule({\n    imports: [MoviesComponent],\n    providers: [\n      {\n        provide: MoviesService,\n        useValue: {},\n      },\n    ],\n  });\n\n  const moviesStore = TestBed.inject(MoviesStore);\n  const loadSpy = jest.spyOn(moviesStore, 'load');\n  const fixture = TestBed.createComponent(MoviesComponent);\n\n  fixture.autoDetectChanges(true);\n\n  const studio = loadSpy.mock.calls[0][0];\n  if (studio instanceof Observable || typeof studio === 'string') {\n    throw new Error('Expected signal');\n  }\n\n  const input: HTMLInputElement = fixture.debugElement.query(By.css('input')).nativeElement;\n\n  expect(studio()).toBe('');\n\n  input.value = 'Warner Bros';\n  input.dispatchEvent(new Event('input'));\n  expect(studio()).toBe('Warner Bros');\n\n  patchState(moviesStore, {\n    movies: [\n      { id: 1, name: 'Harry Potter' },\n      { id: 2, name: 'The Dark Knight' },\n    ],\n  });\n\n  fixture.detectChanges();\n\n  const movies = fixture.debugElement.queryAll(By.css('p')).map((el) =>\n    el.nativeElement.textContent\n  );\n  expect(movies).toEqual(['1: Harry Potter', '2: The Dark Knight']);\n});\n```\n\n----------------------------------------\n\nTITLE: Fix for NgZone violation: Dispatch action inside zone\nDESCRIPTION: This code shows how to fix the `strictActionWithinNgZone` violation, ensuring that actions are dispatched inside the Angular `NgZone`. By using the `NgZone.run` method, the asynchronous task which dispatches the action is now running within the zone, triggering change detection and preventing potential stale views.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/configuration/runtime-checks.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { NgZone } from '@angular/core';\n\nconstructor(private ngZone: NgZone){}\n\n// Callback running outside of NgZone brought back in NgZone.\nfunction callbackOutsideNgZone(){\n  this.ngZone.run(() => {\n    this.store.dispatch(clearTodos());\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Reading ComponentStore State with Selectors\nDESCRIPTION: Uses `ComponentStore` selectors to derive and expose state values or aggregate them into a view model (`vm$`) observable for the template. Selectors provide reactive access to the state. Component outputs (`@Output()`) can also be derived directly from state changes using selectors and observables.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/component-store/usage.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\n// src/app/slide-toggle.component.ts (region: selector)\nimport { Output } from '@angular/core';\nimport { map, distinctUntilChanged } from 'rxjs/operators';\n\n// ... inside SlideToggleComponent class\n\n  // Selector for a specific state property\n  readonly isChecked$ = this.store.select(state => state.checked);\n\n  // ViewModel selector for the template\n  readonly vm$ = this.store.select(\n     this.isChecked$,\n     (isChecked) => ({ isChecked })\n     // Select more state/derived values as needed\n  );\n\n  // Output derived from state changes\n  @Output() readonly change = this.store.select(state => state.checked).pipe(\n    // Optional: Skip initial emission or use pairwise if needed\n    distinctUntilChanged(),\n    // Potentially map to a specific output format\n    map(checked => ({ checked }))\n  );\n```\n\n----------------------------------------\n\nTITLE: Creating a Typed Login Action with Metadata via NgRx createAction in TypeScript\nDESCRIPTION: This TypeScript code demonstrates using NgRx's createAction and props utilities to define a type-safe Login action. The action is categorized with '[Login Page] Login' and expects 'username' and 'password' as parameters. Dependencies: @ngrx/store package required. Inputs: 'username' and 'password'; Output: an Action-compliant object. Ensures compile-time safety for action creation and usage.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/actions.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createAction, props } from '@ngrx/store';\n\nexport const login = createAction(\n  '[Login Page] Login',\n  props<{ username: string; password: string }>()\n);\n```\n\n----------------------------------------\n\nTITLE: Using TestScheduler in Testing\nDESCRIPTION: This snippet demonstrates the usage of `TestScheduler` from RxJS for testing effects.  It involves creating and running the `TestScheduler`, creating action and service streams using `hot` and `cold` helper methods, and asserting the effect's output using `expectObservable`.  This facilitates testing time-based operations. The main steps are instantiating the `TestScheduler`, providing mock input observables, and verifying the output against an expected marble diagram.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/effects/testing.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { TestScheduler } from 'rxjs/testing';\n\nlet testScheduler: TestScheduler;\n\nbeforeEach(() => {\n  testScheduler = new TestScheduler((actual, expected) => {\n    expect(actual).toEqual(expected);\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Testing a Locally Provided MoviesStore in TypeScript\nDESCRIPTION: This example demonstrates how to test a locally provided MoviesStore. Unlike globally provided stores, locally provided stores must be explicitly added to the providers array in the TestBed configuration.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/testing.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { MoviesStore } from './movies.store';\n\ndescribe('MoviesStore', () => {\n  it('should verify that three movies are available', () => {\n    TestBed.configureTestingModule({\n      providers: [MoviesStore],\n    });\n\n    const store = TestBed.inject(MoviesStore);\n\n    expect(store.movies()).toHaveLength(3);\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Defining withTotalEntities Feature with computed (Pre-Version 19) - NgRx Signals TypeScript\nDESCRIPTION: This TypeScript snippet defines a SignalStoreFeature using NgRx signals prior to version 19, where the 'computed' property specifies derived state, such as the total count of entities. It relies on @ngrx/signals and @ngrx/signals/entities, mainly utilizing 'computed', 'signalStoreFeature', 'type', and 'withComputed'. Inputs include an Entity type and an 'entities' collection, and the output is a feature supporting computed properties. Limitation: usage of the outdated 'computed' field, which will break in version 19.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v19.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { computed, Signal } from '@angular/core';\nimport {\n  signalStoreFeature,\n  SignalStoreFeature,\n  type,\n  withComputed,\n} from '@ngrx/signals';\nimport { EntityComputed } from '@ngrx/signals/entities';\n\nexport function withTotalEntities<Entity>(): SignalStoreFeature<\n  { state: {}, computed: EntityComputed<Entity>, methods: {} },\n  { state: {}, computed: { total: Signal<number> }, methods: {} },\n> {\n  return signalStoreFeature(\n    { computed: type<EntityComputed<Entity>>() },\n    withComputed(({ entities }) => ({\n      total: computed(() => entities().length),\n    })),\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Feature Store (After v13 Config Removal) - TypeScript\nDESCRIPTION: Examples showing the updated syntax for `StoreModule.forFeature` in v13. The method now only accepts the feature configuration (either a slice or an object with name and reducer) and no longer includes the second configuration object parameter.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v13.md#_snippet_6\n\nLANGUAGE: ts\nCODE:\n```\nStoreModule.forFeature(\n  featureSlice\n);\n```\n\nLANGUAGE: ts\nCODE:\n```\nStoreModule.forFeature(\n  { name: 'feature', reducer: featureReducer },\n);\n```\n\n----------------------------------------\n\nTITLE: Router Store Usage (After)\nDESCRIPTION: This code snippet shows the correct usage of `StoreRouterConnectingModule` after the changes in version 8. The `forRoot()` method is required to be called to correctly initialize the module.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v8.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n@NgModule({\n  imports: [\n    StoreRouterConnectingModule.forRoot()\n  ]\n})\nexport class AppModule {}\n```\n\n----------------------------------------\n\nTITLE: Fix for Action Type Uniqueness\nDESCRIPTION: This snippet provides the solution for fixing the `strictActionTypeUniqueness` violation. It shows how to create distinct action types by giving each action a unique identifier in its type string.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/configuration/runtime-checks.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nexport const customerPageLoaded = createAction('[Customers Page] Loaded');\nexport const customerPageRefreshed = createAction('[Customers Page] Refreshed');\n```\n```\n\n----------------------------------------\n\nTITLE: Changing Effects Registration from Array to Spread Syntax in NgRx\nDESCRIPTION: This snippet highlights the update in how effects are registered via provideEffects, shifting from passing an array to spreading multiple effect instances as arguments. This simplifies the API and improves flexibility in effect registration.\nSOURCE: https://github.com/ngrx/platform/blob/main/CHANGELOG.md#_snippet_27\n\nLANGUAGE: TypeScript\nCODE:\n```\n// previous pattern\nprovideEffects([MyEffect]);\n\n// new pattern\nprovideEffects(MyEffect);\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\n// previous pattern\nprovideEffects([MyEffect, MySecondEffect]);\n\n// new pattern\nprovideEffects(MyEffect, MySecondEffect);\n```\n\n----------------------------------------\n\nTITLE: Testing flushEffects with Synchronous Execution\nDESCRIPTION: Demonstrates the need for `TestBed.flushEffects()` when mocking a service that operates synchronously. The test case checks that without flushing effects, the results of synchronous operations will not be reflected. Requires dependencies such as Jest and Angular's testing utilities. This scenario arises when the mocked `MovieService` behaves synchronously.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/testing.md#_snippet_11\n\nLANGUAGE: TypeScript\nCODE:\n```\ndescribe('MoviesStore', () => {\n  // ... beforeEach, and afterEach omitted\n\n  it('should depend on flushEffects because of synchronous execution', () => {\n    const moviesService = {\n      load: jest.fn((studio: string) =>\n        of([\n          studio === 'Warner Bros'\n            ? { id: 1, name: 'Harry Potter' }\n            : { id: 2, name: 'Jurassic Park' }\n        ])\n      ),\n    };\n\n    TestBed.configureTestingModule({\n      providers: [\n        {\n          provide: MoviesService,\n          useValue: moviesService,\n        },\n      ],\n    });\n\n    const store = TestBed.inject(MoviesStore);\n    const studio = signal('Warner Bros');\n    store.load(studio);\n    TestBed.flushEffects(); // required\n    expect(store.movies()).toEqual([{ id: 1, name: 'Harry Potter' }]);\n\n    studio.set('Universal');\n    TestBed.flushEffects(); // required\n    expect(store.movies()).toEqual([{ id: 2, name: 'Jurassic Park' }]);\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Testing a Globally Provided MoviesStore in TypeScript\nDESCRIPTION: This example shows how to test a globally provided MoviesStore using TestBed. The test verifies that the store has the expected number of movies in its initial state.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/testing.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { MoviesStore } from './movies-store';\nimport { TestBed } from '@angular/core/testing';\n\ndescribe('MoviesStore', () => {\n  it('should verify that three movies are available', () => {\n    const store = TestBed.inject(MoviesStore);\n\n    expect(store.movies()).toHaveLength(3);\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing NgRx ComponentStore with OnStoreInit Lifecycle Hook in TypeScript\nDESCRIPTION: This snippet defines a BooksStore class extending ComponentStore with the OnStoreInit interface. The ngrxOnStoreInit method is implemented to execute custom logic immediately after store instantiation. It includes dependency injection via provideComponentStore to register the store as a provider in an Angular component, ensuring proper lifecycle management.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/component-store/lifecycle.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface BooksState {\n  collection: Book[];\n}\n\nexport const initialState: BooksState = {\n  collection: []\n};\n\n@Injectable()\nexport class BooksStore extends ComponentStore<BooksState> implements OnStoreInit {\n\n  constructor() {\n    super(initialState);\n  }\n\n  ngrxOnStoreInit() {\n    // called after store has been instantiated\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Non-Dispatching Effects\nDESCRIPTION: This demonstrates how to test an effect that doesn't dispatch an action but performs a side effect like navigation. It mocks the dependency (router in this case) and uses a spy to verify that the side effect (navigation) is called with the expected parameters. This approach focuses on verifying the execution of the side effect.  Inputs include an action stream, and the setup of a mocked navigation.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/effects/testing.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nit('should navigate to the customers detail page', () => {\n  actions$ = of({ type: '[Customers Page] Customer Selected', name: 'Bob' });\n  \n  // create a spy to verify the navigation will be called\n  spyOn(router, 'navigateByUrl');\n\n  // subscribe to execute the Effect\n  effects.selectCustomer$.subscribe();\n\n  // verify the navigation has been called\n  expect(router.navigateByUrl).toHaveBeenCalledWith('customers/bob');\n});\n```\n\n----------------------------------------\n\nTITLE: Generating Initial NgRx Root Effects with Schematics\nDESCRIPTION: Angular CLI command employing @ngrx/schematics to generate the initial root effects structure. It creates an 'AppEffects' class file, designates it as root (`--root`), and registers the `EffectsModule.forRoot()` with these effects in the specified application module (`app.module.ts`).\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/schematics/index.md#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\nng generate @ngrx/schematics:effect App --root --module app.module.ts\n```\n\n----------------------------------------\n\nTITLE: Testing Effects with ReplaySubject\nDESCRIPTION: This snippet showcases using `ReplaySubject` to test effects.  It initializes a `ReplaySubject`, mocks a service response, dispatches an action using `next`, and subscribes to the effect to verify the dispatched action.  This is useful for scenarios where you need to replay actions. It includes creating a `ReplaySubject`, simulating action dispatching, and subscribing to verify the results.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/effects/testing.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n// create a ReplaySubject\nactions$ = new ReplaySubject(1);\n\n// mock the service to prevent an HTTP request\ncustomersServiceSpy.getAllCustomers.and.returnValue(of([...]));\n\n// dispatch the GET action\n(actions$ as ReplaySubject).next({ type: '[Customers Page] Get Customers' })\n\n// subscribe to the Effect stream and verify it dispatches a SUCCESS action\neffects.getAll$.subscribe(action => {\n  expect(action).toEqual({\n    type: '[Customers API] Get Customers Success',\n    customers: [...],\n  });\n  done();\n});\n```\n\n----------------------------------------\n\nTITLE: Manual Cleanup for signalMethod by Providing Injector in Angular TypeScript\nDESCRIPTION: Demonstrates providing the local component injector as an option when invoking a signalMethod created in an ancestor injection context. This manual cleanup ensures that the effect is tied to the component lifecycle, preventing memory leaks. Static value inputs do not require injector provision. This pattern depends on Angular's dependency injection and signal handling.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-method.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\n@Component({ /* ... */ })\nexport class NumbersComponent implements OnInit {\n  readonly numbersService = inject(NumbersService);\n  readonly injector = inject(Injector);\n\n  ngOnInit(): void {\n    const value = signal(1);\n    // 👇 Providing the `NumbersComponent` injector\n    // to ensure cleanup on component destroy.\n    this.numbersService.logDoubledNumber(value, {\n      injector: this.injector,\n    });\n  \n    // 👇 No need to provide an injector for static values.\n    this.numbersService.logDoubledNumber(2);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing NgRx Effects with Mock Store and Action Streams - TypeScript\nDESCRIPTION: This test illustrates testing a NgRx effect that interacts with the store by using createMockStore and injecting selectors and mock values. An Actions instance is created using marble syntax for simulating action dispatch. The effect is expected to emit no value because the store is already populated with the requested entity. Prerequisites include the createMockStore helper, Store interface, Actions, and jasmine-marbles for observable assertions.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/effects/testing.md#_snippet_12\n\nLANGUAGE: TypeScript\nCODE:\n```\nit('should get customers', () => {\n  // create the store, and provide selectors.\n  const store = createMockStore({\n      selectors: [\n        { selector: selectCustomers, value: { Bob: { name: 'Bob' } } }\n      ]\n  });\n\n  // instead of using `provideMockActions`,\n  // define the actions stream by creating a new `Actions` instance\n  const actions = new Actions(\n    hot('-a--', {\n      a: { type: '[Search Customers Page] Get Customer', name: 'Bob' },\n    })\n  );\n\n  // create the effect\n  const effects = new CustomersEffects(store as Store, actions, customersServiceSpy);\n\n  // there is no output, because Bob is already in the Store state\n  const expected = hot('----');\n\n  expect(effects.getByName$).toBeObservable(expected);\n});\n```\n\n----------------------------------------\n\nTITLE: Executing rxMethod with Signal Input - NgRx Signals - TypeScript\nDESCRIPTION: Demonstrates passing an Angular Signal as the input to a reactive method created with `rxMethod`. The RxJS chain automatically subscribes to the signal and re-executes whenever the signal's value changes.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/rxjs-integration.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Component, OnInit, signal } from '@angular/core';\nimport { map, pipe, tap } from 'rxjs';\nimport { rxMethod } from '@ngrx/signals/rxjs-interop';\n\n@Component({ /* ... */ })\nexport class NumbersComponent implements OnInit {\n  readonly logDoubledNumber = rxMethod<number>(\n    pipe(\n      map((num) => num * 2),\n      tap(console.log)\n    )\n  );\n\n  ngOnInit(): void {\n    const num = signal(10);\n    this.logDoubledNumber(num);\n    // console output: 20\n\n    num.set(20);\n    // console output: 40\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Selecting NgRx State with String/Props (Incorrect) - TypeScript\nDESCRIPTION: This snippet demonstrates discouraged patterns for selecting data from the NgRx store that violate the `prefer-selector-in-select` rule. It shows accessing state slices using a string key or directly accessing a state property within an inline arrow function, which bypasses the benefits of memoized selectors.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/prefer-selector-in-select.md#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\n// ⚠ Usage of strings to select state slices\nthis.store.select('customers');\nthis.store.pipe(select('customers'));\n\n// ⚠ Usage of props drilling to select state slices\nthis.store.select((state) => state.customers);\nthis.store.pipe(select((state) => state.customers));\n```\n\n----------------------------------------\n\nTITLE: Binding Observables using *ngIf and async Pipe in Angular\nDESCRIPTION: Demonstrates the traditional method of binding an observable (`number$`) to an Angular template using the `async` pipe within an `*ngIf` structural directive. This example highlights a potential issue where falsy emitted values (like 0) from the observable can unintentionally prevent the template block from rendering.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/component/let.md#_snippet_1\n\nLANGUAGE: html\nCODE:\n```\n<ng-container *ngIf=\"number$ | async as n\">\n  <app-number [number]=\"n\"></app-number>\n  \n  <app-number-special [number]=\"n\"></app-number-special>\n</ng-container>\n```\n\n----------------------------------------\n\nTITLE: Configuring Angular CLI to Use @ngrx/schematics by Default\nDESCRIPTION: Angular CLI command to update the `angular.json` configuration file. It adds `@ngrx/schematics` to the `cli.schematicCollections` array, allowing developers to run NgRx schematics without the explicit `@ngrx/schematics:` prefix (e.g., `ng generate store` instead of `ng generate @ngrx/schematics:store`).\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/schematics/index.md#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\nng config cli.schematicCollections \"[\\\"@ngrx/schematics\\\"]\"\n```\n\n----------------------------------------\n\nTITLE: Defining the EntityAction Interface in TypeScript for NgRx Data\nDESCRIPTION: This snippet defines the EntityAction interface as an extension of the NgRx Action interface for use within NgRx Data. It includes a 'type' string and a typed 'payload' which itself conforms to the EntityActionPayload interface. The interface structures the dispatched messages representing operations on entities, supporting generic payload types.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/entity-actions.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface EntityAction<P = any> extends Action {\n  readonly type: string;\n  readonly payload: EntityActionPayload<P>;\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect: Re-dispatching Filtered Action in NgRx Effect\nDESCRIPTION: This TypeScript snippet shows an incorrect NgRx Effect implementation where the `details$` effect listens for the `fromCustomers.pageLoaded` action and then dispatches the same action using `map`. This creates a cyclic dependency and an infinite loop.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/avoid-cyclic-effects.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nclass Effect {\n  details$ = createEffect(() =>\n    this.actions$.pipe(\n      ofType(fromCustomers.pageLoaded),\n      map(() => fromCustomers.pageLoaded()) // Problem: Re-dispatching the same action\n    )\n  );\n\n  constructor(private actions$: Actions) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Importing PushPipe in Angular Component\nDESCRIPTION: This snippet demonstrates how to import and include the `PushPipe` within an Angular component. This is a necessary step to use the `ngrxPush` pipe in a component's template. The `PushPipe` is added to the `imports` array of either a standalone component or an NgModule.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/component/push.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Component } from '@angular/core';\nimport { PushPipe } from '@ngrx/component';\n\n@Component({\n  // ... other metadata\n  imports: [\n    // ... other imports\n    PushPipe,\n  ],\n})\nexport class MyStandaloneComponent {}\n```\n\n----------------------------------------\n\nTITLE: Defining an Entity Model Interface in TypeScript\nDESCRIPTION: Defines a simple `User` interface with `id` (string) and `name` (string) properties. This interface represents the data structure of the entities that will be managed by the NgRx Entity Adapter within the application state.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/entity/adapter.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface User {\n  id: string;\n  name: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Selecting NgRx State with Selector (Correct) - TypeScript\nDESCRIPTION: This snippet demonstrates the recommended pattern for selecting data from the NgRx store using a pre-defined, imported selector function. Using selectors provides memoization benefits for performance and improves testability.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/prefer-selector-in-select.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport * as fromCustomers from '@customers/selectors';\n\nthis.store.select(fromCustomers.selectAllCustomers);\nthis.store.pipe(select(fromCustomers.selectAllCustomers));\n```\n\n----------------------------------------\n\nTITLE: Using Logger Feature in BooksStore with ngrx/signals (TypeScript)\nDESCRIPTION: This code demonstrates how to integrate the `withLogger` feature into a `BooksStore`. It includes `withEntities` to manage book entities and `withRequestStatus` for handling request states. The logger will output state changes to the console.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/custom-store-features.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { signalStore } from '@ngrx/signals';\nimport { withEntities } from '@ngrx/signals/entities';\nimport { withRequestStatus } from './request-status.feature';\nimport { withLogger } from './logger.feature';\nimport { Book } from './book.model';\n\nexport const BooksStore = signalStore(\n  withEntities<Book>(),\n  withRequestStatus(),\n  withLogger('books')\n);\n```\n\n----------------------------------------\n\nTITLE: Registering NgRx Feature State (NgModule) - TypeScript\nDESCRIPTION: Registers the scoreboard reducer as a feature state within an Angular NgModule using `StoreModule.forFeature()`. This method allows for lazy loading of state segments with their corresponding feature modules, organizing the state by application area.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/reducers.md#_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { NgModule } from '@angular/core';\nimport { StoreModule } from '@ngrx/store';\nimport { scoreboardFeatureKey, scoreboardReducer } from './reducers/scoreboard.reducer';\n  \n@NgModule({\n  imports: [\n    StoreModule.forFeature(scoreboardFeatureKey, scoreboardReducer)\n  ],\n})\nexport class ScoreboardModule {}\n```\n\n----------------------------------------\n\nTITLE: Creating NgRx Reducer with Implicit Return Type (Incorrect) - TypeScript\nDESCRIPTION: This snippet demonstrates an incorrect usage pattern where the callback function for the `on` function lacks an explicit return type. Without the explicit type, TypeScript does not prevent the addition of properties (like `newProperty`) that are not defined in the `AppState` interface, potentially leading to runtime issues or unexpected state shapes.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/on-function-explicit-return-type.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface AppState {\n  username: string;\n}\n\nconst reducer = createReducer<AppState>(\n  { username: '' },\n  on(setUsername, (state, action) => ({\n    ...state,\n    username: action.payload,\n    newProperty: 1, // we added a property that does not exist on `AppState`, and TS won't catch this problem\n  }))\n);\n```\n\n----------------------------------------\n\nTITLE: Immutability Violation: Modifying State Directly\nDESCRIPTION: This snippet shows an example of a violation of the `strictStateImmutability` rule. It demonstrates how a developer might inadvertently modify the state object directly, which is not allowed in NgRx. The example modifies `state.todoInput` and uses `push` on the `todos` array.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/configuration/runtime-checks.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nexport const reducer = createReducer(initialState,\n  on(addTodo, (state, { todo }) => {\n    // Violation 1: we assign a new value to `todoInput` directly\n    state.todoInput = '',\n    // Violation 2: `push` modifies the array\n    state.todos.push(todo)\n  })\n);\n```\n```\n\n----------------------------------------\n\nTITLE: Creating Template Aliases for Values with *ngrxLet in Angular\nDESCRIPTION: Illustrates using `*ngrxLet` to create a convenient template alias (`email`) for a static, non-observable value, such as a deeply nested property like `userForm.controls.email`. This technique enhances template readability, especially when dealing with complex objects or reactive form controls.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/component/let.md#_snippet_6\n\nLANGUAGE: html\nCODE:\n```\n<ng-container *ngrxLet=\"userForm.controls.email as email\">\n  <input type=\"text\" [formControl]=\"email\" />\n\n  <ng-container *ngIf=\"email.errors && (email.touched || email.dirty)\">\n    <p *ngIf=\"email.errors.required\">This field is required.</p>\n    <p *ngIf=\"email.errors.email\">This field must be an email.</p>\n  </ng-container>\n</ng-container>\n```\n\n----------------------------------------\n\nTITLE: Testing MovieStore with Signals\nDESCRIPTION: Tests the `MoviesStore`'s `load` method with a Signal as input. It simulates scenarios where the studio changes, testing the store's response. The test uses `fakeAsync` to control time, `signal` to provide the studio name, and `effect` for debugging. Dependencies: Jest, @angular/core, @angular/core/testing.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/testing.md#_snippet_10\n\nLANGUAGE: TypeScript\nCODE:\n```\ndescribe('MoviesStore', () => {\n  // ... setup omitted\n\n  it('should test two sequential loads with a Signal', fakeAsync(() => {\n    const store = setup();\n    const studio = signal('Warner Bros');\n    store.load(studio);\n\n    tick(100);\n    expect(store.movies()).toEqual([{ id: 1, name: 'Harry Potter' }]);\n\n    studio.set('Universal');\n    tick(100);\n    expect(store.movies()).toEqual([{ id: 2, name: 'Jurassic Park' }]);\n  }));\n\n  it('should cancel a running request when a new one is made via a Signal', fakeAsync(() => {\n    const store = setup();\n    const studio = signal('Warner Bros');\n\n    effect(() => {\n      console.log(studio());\n    });\n    store.load(studio);\n\n    tick(50);\n\n    studio.set('Universal');\n    tick(50);\n    expect(store.movies()).toEqual([]);\n    expect(store.loading()).toBe(true);\n\n    tick(50);\n    expect(store.movies()).toEqual([{ id: 2, name: 'Jurassic Park' }]);\n    expect(store.loading()).toBe(false);\n  }));\n});\n```\n\n----------------------------------------\n\nTITLE: Using Angular computed Signals with ComponentStore's state Signal in TypeScript\nDESCRIPTION: Illustrates creating computed signals in Angular based on the entire ComponentStore state signal. It defines users, query, and filteredUsers computed signals deriving reactive state slices for use within Angular components supporting fine-grained reactive updates. Requires Angular signals and ComponentStore.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/component-store/read.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { computed, Injectable } from '@angular/core';\nimport { ComponentStore } from '@ngrx/component-store';\n\nimport { User } from './user.model';\n\ntype UsersState = { users: User[]; query: string };\n\n@Injectable()\nexport class UsersStore extends ComponentStore<UsersState> {\n  readonly users = computed(() => this.state().users);\n  readonly query = computed(() => this.state().query);\n  \n  readonly filteredUsers = computed(() =>\n    this.users().filter(({ name }) => name.includes(this.query()))\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Default HttpUrlGenerator in NgRx Data with a Custom Pluralizing Generator in TypeScript\nDESCRIPTION: This example shows how to extend NgRx Data's DefaultHttpUrlGenerator to create a custom HttpUrlGenerator that pluralizes both entity and collection resource URLs based on injected pluralizer logic. The class overrides the protected getResourceUrls method to construct and cache pluralized URLs dynamically, ensuring consistent resource endpoint naming conventions. The customized generator is provided in the application's root module, replacing the default with dependency injection. This pattern allows for fine-grained control over REST endpoint URL formats, facilitating integration with backend APIs requiring pluralized resource names. Dependencies include Angular core and NgRx Data packages.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/extension-points.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Injectable } from '@angular/core';\nimport {\n  DefaultHttpUrlGenerator,\n  HttpResourceUrls,\n  normalizeRoot,\n  Pluralizer\n} from '@ngrx/data';\n\n@Injectable()\nexport class PluralHttpUrlGenerator extends DefaultHttpUrlGenerator {\n  constructor(private myPluralizer: Pluralizer) {\n    super(myPluralizer);\n  }\n\n  protected getResourceUrls(\n    entityName: string,\n    root: string\n  ): HttpResourceUrls {\n    let resourceUrls = this.knownHttpResourceUrls[entityName];\n    if (!resourceUrls) {\n      const nRoot = normalizeRoot(root);\n      const url = `${nRoot}/${this.myPluralizer.pluralize(\n        entityName\n      )}/`.toLowerCase();\n      resourceUrls = {\n        entityResourceUrl: url,\n        collectionResourceUrl: url\n      };\n      this.registerHttpResourceUrls({ [entityName]: resourceUrls });\n    }\n    return resourceUrls;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Updating NgRx Router Store Registration in TypeScript\nDESCRIPTION: Details the updated setup for `@ngrx/router-store`. The module is now registered via `StoreRouterConnectingModule` in the application module, and the `routerReducer` is included directly in the reducers map provided to `StoreModule.forRoot`.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v4.md#_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as fromRouter from '@ngrx/router-store';\n\nexport interface State {\n  router: fromRouter.RouterState;\n}\n\nconst reducers = {\n  router: fromRouter.routerReducer,\n};\n\nconst rootReducer = combineReducers(reducers);\n\nexport function reducer(state: any, action: any) {\n  return rootReducer(state, action);\n}\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { RouterModule } from '@angular/router';\nimport { RouterStoreModule } from '@ngrx/router-store';\nimport { reducer } from './reducers';\n\n@NgModule({\n  imports: [\n    StoreModule.provideStore(reducer),\n    RouterModule.forRoot([\n      // some routes\n    ]),\n    RouterStoreModule.connectRouter()\n  ]\n})\nexport class AppModule {}\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as fromRouter from '@ngrx/router-store';\n\nexport interface State {\n  routerReducer: fromRouter.RouterReducerState;\n}\n\nexport const reducers = {\n  routerReducer: fromRouter.routerReducer,\n};\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { StoreRouterConnectingModule } from '@ngrx/router-store';\nimport { reducers } from './reducers';\n\n@NgModule({\n  imports: [\n    StoreModule.forRoot(reducers),\n    RouterModule.forRoot([\n      // some routes\n    ]),\n    StoreRouterConnectingModule,\n  ],\n})\nexport class AppModule {}\n```\n\n----------------------------------------\n\nTITLE: Updating createSelector Generic Type Specification in NgRx Store\nDESCRIPTION: Demonstrates the breaking change in how to specify generic arguments for createSelector in NgRx store. The selector's list of selector return values now needs to be specified as a tuple.\nSOURCE: https://github.com/ngrx/platform/blob/main/CHANGELOG.md#_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\ncreateSelector<Story[], Story[], Story[][]>;\n```\n\nLANGUAGE: typescript\nCODE:\n```\n//        needs to be a tuple 👇\ncreateSelector<Story[], [Story[]], Story[][]>;\n```\n\n----------------------------------------\n\nTITLE: Generating an NgRx Reducer (Basic Command & Alias)\nDESCRIPTION: Shows the basic Angular CLI command and its alias (`r`) to generate an NgRx reducer file. This command creates a state interface, an initial state object, and a reducer function. Replace `ReducerName` with the desired name and use `[options]` for further customization as detailed in the options section.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/schematics/reducer.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nng generate reducer ReducerName [options]\n```\n\nLANGUAGE: sh\nCODE:\n```\nng generate r ReducerName [options]\n```\n\n----------------------------------------\n\nTITLE: Creating NgRx Reducer Function (Scoreboard Example) - TypeScript\nDESCRIPTION: Creates the reducer function for the scoreboard state using the `createReducer` and `on` functions from NgRx. The reducer handles specific actions by returning a new state object immutably based on the current state and the action payload. The spread operator (`...`) is used for shallow copying the existing state.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/reducers.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport const scoreboardReducer = createReducer(\n  initialState,\n  on(ScoreboardPageActions.homeScore, state => ({ ...state, home: state.home + 1 })),\n  on(ScoreboardPageActions.awayScore, state => ({ ...state, away: state.away + 1 })),\n  on(ScoreboardPageActions.resetScore, state => ({ home: 0, away: 0 })),\n  on(ScoreboardPageActions.setScores, (state, { game }) => ({ home: game.home, away: game.away }))\n);\n```\n\n----------------------------------------\n\nTITLE: Installing NgRx ComponentStore with yarn Shell Command\nDESCRIPTION: This shell command installs the @ngrx/component-store package using yarn and adds it to the project's dependencies. It requires yarn to be installed and configured. This installation method is common in projects using yarn as a package manager.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/component-store/install.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nyarn add @ngrx/component-store\n```\n\n----------------------------------------\n\nTITLE: Creating an Angular Service for HTTP Data Fetching\nDESCRIPTION: Defines a standard injectable Angular service (`MoviesService`) responsible for fetching data. It utilizes the `HttpClient` to perform a GET request to the '/movies' endpoint and returns an Observable of `Movie[]`.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/effects/index.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Injectable, inject } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { Observable } from 'rxjs';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class MoviesService {\n  private http = inject(HttpClient);\n\n  getAll(): Observable<Movie[]> {\n    return this.http.get<Movie[]>('/movies');\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a class-based SignalStore in Angular with TypeScript\nDESCRIPTION: This snippet demonstrates how to define a class that extends the `signalStore` function, enabling an object-oriented approach to managing state. It includes defining state, creating a computed property, and updating state via `patchState`. Dependencies include `signalStore`, `withState`, and `patchState` functions from the `@ngrx/signals` library.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/faq.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\n```ts\n@Injectable()\nexport class CounterStore extends signalStore(\n  { protectedState: false },\n  withState({ count: 0 })\n) {\n  readonly doubleCount = computed(() => this.count() * 2);\n\n  increment(): void {\n    patchState(this, { count: this.count() + 1 });\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Manually Destroying All rxMethod Subscriptions - NgRx Signals - TypeScript\nDESCRIPTION: Illustrates how to explicitly clean up all active subscriptions associated with a reactive method by calling its `destroy()` method. This allows termination before the component or service injector is destroyed.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/rxjs-integration.md#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Component, OnInit } from '@angular/core';\nimport { interval, tap } from 'rxjs';\nimport { rxMethod } from '@ngrx/signals/rxjs-interop';\n\n@Component({ /* ... */ })\nexport class NumbersComponent implements OnInit {\n  readonly logNumber = rxMethod<number>(tap(console.log));\n\n  ngOnInit(): void {\n    const num1$ = interval(500);\n    const num2$ = interval(1_000);\n\n    this.logNumber(num1$);\n    this.logNumber(num2$);\n\n    setTimeout(() => {\n      // 👇 Destroy the reactive method after 3 seconds.\n      this.logNumber.destroy();\n    }, 3_000);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Ngrx Container with State Configuration (Shell)\nDESCRIPTION: Demonstrates how to generate a container component (`UsersPage`) while specifying the path to the state reducers file (`reducers/index.ts`) and a custom state interface name (`MyState`) using the `--state` and `--state-interface` options. This helps the schematic correctly type the injected `Store`.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/schematics/container.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nng generate container UsersPage --state reducers/index.ts --state-interface MyState\n```\n\n----------------------------------------\n\nTITLE: Incorrect ngOnDestroy override in ComponentStore (TypeScript)\nDESCRIPTION: This code shows an incorrect implementation of ngOnDestroy in a ComponentStore subclass. It overrides the ngOnDestroy method but does not call super.ngOnDestroy(), leading to potential resource leaks or improper cleanup. The rule enforces the call to super.ngOnDestroy() to ensure that the ComponentStore's cleanup logic is executed. This example demonstrates a component that extends ComponentStore but neglects to call the super method within the overridden ngOnDestroy.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/require-super-ondestroy.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\n@Injectable()\nexport class BooksStore extends ComponentStore<BooksState> implements OnDestroy\n{\n  // ... other BooksStore class members\n\n  override ngOnDestroy(): void {\n    this.cleanUp(); // custom cleanup logic\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining User Actions with NgRx createActionGroup - TypeScript\nDESCRIPTION: This snippet defines two user actions, addUser and selectUser, using NgRx's createActionGroup for concise grouping and strong typing. Dependencies include @ngrx/store and the User model. The actions are parameterized to accept a User when adding and a userId (string) for selecting, structuring action events for later use in reducers.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/entity/recipes/entity-adapter-with-feature-creator.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createActionGroup, props } from '@ngrx/store';\nimport { User } from './user.model';\n\nexport const UserListPageActions = createActionGroup({\n  source: 'User List Page',\n  events: {\n    addUser: props<{ user: User }>(),\n    selectUser: props<{ userId: string }>(),\n  },\n});\n\n```\n\n----------------------------------------\n\nTITLE: Creating Signals with selectSignal Method in NgRx ComponentStore with TypeScript\nDESCRIPTION: Demonstrates usage of selectSignal method in Angular ComponentStore to create signals representing state slices. It shows creating signals from state projectors and combining multiple signals to derive filtered results reactively. Enables more direct reactive programming using Angular signals with NgRx state management.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/component-store/read.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Injectable } from '@angular/core';\nimport { ComponentStore } from '@ngrx/component-store';\n\nimport { User } from './user.model';\n\ntype UsersState = { users: User[]; query: string };\n\n@Injectable()\nexport class UsersStore extends ComponentStore<UsersState> {\n  // type: Signal<User[]>\n  readonly users = this.selectSignal((s) => s.users);\n  // type: Signal<string>\n  readonly query = this.selectSignal((s) => s.query);\n  // type: Signal<User[]>\n  readonly filteredUsers = this.selectSignal(\n    this.users,\n    this.query,\n    (users, query) =>\n      users.filter(({ name }) => name.includes(query))\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using Standalone API in AppModule - TypeScript\nDESCRIPTION: This snippet demonstrates the usage of both `StoreModule.forRoot` and `provideStore` functions in module-based Angular applications that use standalone components to register the root store. This registers both a root store and feature states. Dependencies are `@ngrx/store` and `scoreboardReducer`. The `StoreModule.forRoot` provides for dependency injection, while `provideStore` can be used to register feature state with standalone components.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/reducers.md#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\n  import { NgModule } from '@angular/core';\n  import { StoreModule, provideStore } from '@ngrx/store';\n  import { scoreboardReducer } from './reducers/scoreboard.reducer';\n\n  @NgModule({\n    imports: [\n      StoreModule.forRoot({ game: scoreboardReducer })\n    ],\n    providers: [\n      provideStore({ game: scoreboardReducer })\n    ]\n  })\n  export class AppModule {}\n```\n\n----------------------------------------\n\nTITLE: Calling an Effect Without Parameters in Angular's NgRx Store with TypeScript\nDESCRIPTION: Demonstrates invoking an effect that does not require input parameters by setting the generic type to `void`. The `getAllMovies` effect fetches all movies when triggered, using operators like `exhaustMap` to manage concurrency, and handles results or errors with `tapResponse`. This pattern is useful for effects triggered by events like button clicks or initialization.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/component-store/effect.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\n readonly getAllMovies = this.effect&lt;void&gt;(\n   // Source stream can be any stream, commonly named trigger$\n   (trigger$) => trigger$.pipe(\n     // Use exhaustMap to ensure only one fetch at a time\n     exhaustMap(() =>\n       this.moviesService.fetchAllMovies().pipe(\n         tapResponse({\n           next: (movies) => this.addAllMovies(movies),\n           error: (error: HttpErrorResponse) => this.logError(error),\n         })\n       )\n     )\n   )\n );\n```\n\n----------------------------------------\n\nTITLE: Importing LetModule and PushModule in V15 (TypeScript)\nDESCRIPTION: Demonstrates the updated approach in NgRx v15 for using `@ngrx/component` features. Instead of `ReactiveComponentModule`, developers should import `LetModule` for the `*ngrxLet` directive and `PushModule` for the `push` pipe separately into their Angular module.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v15.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { LetModule, PushModule } from '@ngrx/component';\n\n@NgModule({\n  imports: [\n    // ... other imports\n    LetModule,\n    PushModule,\n  ],\n})\nexport class MyFeatureModule {}\n```\n\n----------------------------------------\n\nTITLE: Initializing rxMethod outside of injection context in Angular with rxjs\nDESCRIPTION: This code demonstrates how to initialize a reactive method (`rxMethod`) outside of Angular's injection context by providing an explicit `Injector`. It uses Angular's `inject` function to obtain an `Injector` instance, then creates a reactive method that logs a number to the console, showcasing dependency injection, rxjs integration, and Angular component lifecycle (`OnInit`). Dependencies include Angular core modules, rxjs, and the `@ngrx/signals/rxjs-interop` package. This pattern allows reactive methods to be used in scenarios where Angular's dependency injection isn't directly available.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/rxjs-integration.md#_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Component, inject, Injector, OnInit } from '@angular/core';\nimport { tap } from 'rxjs';\nimport { rxMethod } from '@ngrx/signals/rxjs-interop';\n\n@Component({ /* ... */ })\nexport class NumbersComponent implements OnInit {\n  readonly #injector = inject(Injector);\n\n  ngOnInit(): void {\n    const logNumber = rxMethod<number>(\n      tap(console.log),\n      { injector: this.#injector }\n    );\n\n    logNumber(10);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Effects Error Handler in NgRx (TypeScript)\nDESCRIPTION: Demonstrates how to provide a custom error handler for effects by using the EFFECTS_ERROR_HANDLER injection token. This allows for customized retry logic based on different types of errors.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/effects/lifecycle.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ErrorHandler, NgModule } from '@angular/core';\nimport { Observable, throwError } from 'rxjs';\nimport { retryWhen, mergeMap } from 'rxjs/operators';\nimport { Action } from '@ngrx/store';\nimport { EffectsModule, EFFECTS_ERROR_HANDLER } from '@ngrx/effects';\nimport { MoviesEffects } from './effects/movies.effects';\nimport { CustomErrorHandler, isRetryable } from '../custom-error-handler';\n\nexport function effectResubscriptionHandler<T extends Action>(\n  observable$: Observable<T>,\n  errorHandler?: CustomErrorHandler\n): Observable<T> {\n  return observable$.pipe(\n    retryWhen(errors =>\n      errors.pipe(\n        mergeMap(e => {\n          if (isRetryable(e)) {\n            return errorHandler.handleRetryableError(e);\n          }\n\n          errorHandler.handleError(e);\n          return throwError(() => e);\n        })\n      )\n    )\n  );\n}\n\nbootstrapApplication(\n  AppComponent,\n  {\n    providers: [\n      {\n        provide: EFFECTS_ERROR_HANDLER,\n        useValue: effectResubscriptionHandler,\n      },\n      {\n        provide: ErrorHandler,\n        useClass: CustomErrorHandler\n      }\n    ],\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Disabling Runtime Immutability Checks in Angular NgRx Store\nDESCRIPTION: This TypeScript snippet shows how to disable default runtime immutability checks in NgRx Store by configuring the `StoreModule.forRoot` method with `runtimeChecks` settings. It requires importing NgRx StoreModule and configuring the module in Angular's `@NgModule` imports array.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v9.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\n@NgModule({\n  imports: [\n    StoreModule.forRoot(reducers, {\n      runtimeChecks: {\n        strictStateImmutability: false,\n        strictActionImmutability: false,\n      },\n    }),\n  ],\n})\nexport class AppModule {}\n```\n\n----------------------------------------\n\nTITLE: Correct Selector Naming Patterns for NgRx in TypeScript\nDESCRIPTION: This snippet provides examples of properly named selector functions in NgRx using the recommended 'select' prefix. It includes selectors created with createSelector, createFeatureSelector, and selectors returning memoized selectors with clear, descriptive names. These examples demonstrate adherence to best practices for naming selectors for improved readability and maintainability.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/prefix-selectors-with-select.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport const selectFeature = createSelector((state: AppState) => state.feature);\n\nexport const selectFeature: MemoizedSelector<any, any> = (state: AppState) =>\n  state.feature;\n\nconst selectFeature = createFeatureSelector<FeatureState>(featureKey);\n\nexport const selectThing = (id: string) =>\n  createSelector(selectThings, (things) => things[id]);\n```\n\n----------------------------------------\n\nTITLE: Using Named Collection Updaters in NgRx SignalStore (TypeScript)\nDESCRIPTION: This code shows how to mutate a named entity collection in a SignalStore. Updaters like addEntity and removeEntity are provided a collection name via an options object. Dependencies include @ngrx/signals, @ngrx/signals/entities, and the Todo type (structure assumed defined elsewhere). Input parameters specify the Todo entity and collection name; the output is a modified store state for the corresponding named collection. Required for managing multiple collections inside a store.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/entity-management.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  patchState,\n  signalStore,\n  type,\n  withMethods,\n} from '@ngrx/signals';\nimport { addEntity, removeEntity, withEntities } from '@ngrx/signals/entities';\n\ntype Todo = { /* ... */ };\n\nexport const TodosStore = signalStore(\n  withEntities({ entity: type<Todo>(), collection: 'todo' }),\n  withMethods((store) => ({\n    addTodo(todo: Todo): void {\n      patchState(store, addEntity(todo, { collection: 'todo' }));\n    },\n    removeTodo(id: number): void {\n      patchState(store, removeEntity(id, { collection: 'todo' }));\n    },\n  }))\n);\n\n```\n\n----------------------------------------\n\nTITLE: Using getState and effect for Reactive State Tracking in NgRx SignalStore\nDESCRIPTION: Example of implementing a counter store that uses getState within an effect to track state changes reactively. The effect is re-executed automatically when state changes, with Angular's built-in glitch-free behavior that coalesces multiple state changes in the same tick.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/state-tracking.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { effect } from '@angular/core';\nimport {\n  getState,\n  patchState,\n  signalStore,\n  withHooks,\n  withMethods,\n  withState,\n} from '@ngrx/signals';\n\nexport const CounterStore = signalStore(\n  withState({ count: 0 }),\n  withMethods((store) => ({\n    increment(): void {\n      patchState(store, { count: store.count() + 1 });\n    },\n  })),\n  withHooks({\n    onInit(store) {\n      effect(() => {\n        // 👇 The effect is re-executed on state change.\n        const state = getState(store);\n        console.log('counter state', state);\n      });\n\n      setInterval(() => store.increment(), 1_000);\n    },\n  })\n);\n```\n\n----------------------------------------\n\nTITLE: Using ComponentStore Updater in Angular Component\nDESCRIPTION: Shows how to use a ComponentStore updater method within an Angular component. The example includes a button that triggers the addMovie method when clicked.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/component-store/write.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n@Component({\n  template: `\n    <button (click)=\"add('New Movie')\">Add a Movie</button>\n  `,\n  providers: [MoviesStore],\n})\nexport class MoviesPageComponent {\n\n  constructor(private readonly moviesStore: MoviesStore) {}\n\n  add(movie: string) {\n    this.moviesStore.addMovie({ name: movie, id: generateId() });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing NgRx Selector Projector Functions in TypeScript\nDESCRIPTION: This pattern tests the pure projector function part of NgRx selectors directly by accessing the selector's .projector property. Testing projector functions in isolation enables verifying selector logic without needing to configure full Store instances or states, thus simplifying unit testing of selector transformations.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/testing.md#_snippet_4\n\n\n\n----------------------------------------\n\nTITLE: Creating NgRx EntityAdapter Instance - TypeScript\nDESCRIPTION: This snippet demonstrates how to create an instance of the `EntityAdapter` for a specific entity type (`User`) using the `createEntityAdapter` factory function from NgRx Entity. The returned `adapter` object contains methods for performing common CRUD operations and selections on state structured according to the `EntityState<User>` interface. This adapter is typically used within a reducer function.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/entity/interfaces.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport const adapter: EntityAdapter<User> = createEntityAdapter<User>();\n```\n\n----------------------------------------\n\nTITLE: Resetting MockStore in Jest Tests - TypeScript\nDESCRIPTION: Snippet demonstrating how to manually reset the `MockStore` using an `afterEach` hook in Jest test suites. This replaces the automatic reset behavior from previous versions and requires injecting `MockStore` (e.g., from `TestBed`).\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v13.md#_snippet_8\n\nLANGUAGE: ts\nCODE:\n```\nimport { MockStore } from '@ngrx/store/testing';\n\nafterEach(() => {\n  TestBed.inject(MockStore)?.resetSelectors();\n});\n```\n\n----------------------------------------\n\nTITLE: Lazy Initialization of ComponentStore in Angular\nDESCRIPTION: This snippet illustrates lazy initialization of a `ComponentStore` using `setState`. The `MoviesPageComponent` component initializes its state in the `ngOnInit` lifecycle hook. It selects the `movies` property from the state, displaying them in a template.  This allows the state to be initialized at a later time, potentially based on asynchronous data, or user interactions.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/component-store/initialization.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\n@Component({\n  template: `\n    <li *ngFor=\"let movie of (movies$ | async)\">\n      {{ movie.name }}\n    </li>\n  `,\n  providers: [ComponentStore],\n})\nexport class MoviesPageComponent {\n  readonly movies$ = this.componentStore.select(state => state.movies);\n\n  constructor(\n    private readonly componentStore: ComponentStore<{movies: Movie[]}>\n  ) {}\n\n  ngOnInit() {\n    this.componentStore.setState({movies: []});\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a custom EntityCollectionService by extending EntityCollectionServiceBase\nDESCRIPTION: Defines a custom service class for 'Hero' entities by extending EntityCollectionServiceBase, adding custom capabilities. Provided in an Angular module for dependency injection, enabling use with Angular's injection system and improve maintainability.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/entity-services.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Injectable } from '@angular/core';\nimport { EntityCollectionServiceBase, EntityCollectionServiceElementsFactory } from '@ngrx/data';\n\nimport { Hero } from '../model';\n\n@Injectable()\nexport class HeroesService extends EntityCollectionServiceBase<Hero> {\n  constructor(elementsFactory: EntityCollectionServiceElementsFactory) {\n    super('Hero', elementsFactory);\n  }\n\n  // Add custom methods here\n}\n```\n\n----------------------------------------\n\nTITLE: Executing rxMethod with Observable Input - NgRx Signals - TypeScript\nDESCRIPTION: Shows how a reactive method defined with `rxMethod` can accept an RxJS Observable as input. The method subscribes to the observable, processing each emitted value through the defined RxJS pipeline.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/rxjs-integration.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Component, OnInit } from '@angular/core';\nimport { interval, map, of, pipe, tap } from 'rxjs';\nimport { rxMethod } from '@ngrx/signals/rxjs-interop';\n\n@Component({ /* ... */ })\nexport class NumbersComponent implements OnInit {\n  readonly logDoubledNumber = rxMethod<number>(\n    pipe(\n      map((num) => num * 2),\n      tap(console.log)\n    )\n  );\n\n  ngOnInit(): void {\n    const num1$ = of(100, 200, 300);\n    this.logDoubledNumber(num1$);\n    // console output: 200, 400, 600\n\n    const num2$ = interval(2_000);\n    this.logDoubledNumber(num2$);\n    // console output: 0, 2, 4, 6, 8, 10, ... (every 2 seconds)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Updating NgRx using Angular CLI\nDESCRIPTION: Command to update NgRx packages to version 16 using the Angular CLI ng update command.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v16.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nng update @ngrx/store@16\n```\n\n----------------------------------------\n\nTITLE: Example of selectId function (TypeScript)\nDESCRIPTION: This function specifies how to extract the primary key from a `Villain` entity, where the primary key is stored in the `key` property instead of the default `id` property.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/entity-metadata.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nselectId: (villain: Villain) => villain.key;\n```\n\n----------------------------------------\n\nTITLE: Using unprotected Function to Test Protected State in SignalStore\nDESCRIPTION: This example shows how to use the unprotected function from @ngrx/signals/testing to bypass state encapsulation for testing purposes. It demonstrates testing state changes and their impacts on computed values.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/testing.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\n// counter.store.ts\nconst CounterStore = signalStore(\n  { providedIn: 'root' },\n  withState({ count: 1 }),\n  withComputed(({ count }) => ({\n    doubleCount: computed(() => count() * 2),\n  })),\n);\n\n// counter.store.spec.ts\nimport { TestBed } from '@angular/core/testing';\nimport { unprotected } from '@ngrx/signals/testing';\n\ndescribe('CounterStore', () => {\n  it('recomputes doubleCount on count changes', () => {\n    const counterStore = TestBed.inject(CounterStore);\n\n    patchState(unprotected(counterStore), { count: 10 });\n    expect(counterStore.doubleCount()).toBe(20);\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Correct Effect implementation with OnInitEffects interface - TypeScript\nDESCRIPTION: This example demonstrates the correct way to implement the `OnInitEffects` interface. The class `Effect` implements the `OnInitEffects` interface, and the `ngrxOnInitEffects` method is correctly defined within the class.  Import statement is included.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/use-effects-lifecycle-interface.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { OnInitEffects } from '@ngrx/effects';\n\nclass Effect implements OnInitEffects {\n  ngrxOnInitEffects(): Action {\n    return { type: '[Effect] Init' };\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Action Logging Meta-Reducer in NgRx TypeScript\nDESCRIPTION: This snippet demonstrates how to create a simple meta-reducer function (`debug`) that logs the current state and the dispatched action to the console before the action is processed by the main reducers. It also shows how to configure this meta-reducer within the `StoreModule.forRoot` setup in an Angular module (`AppModule`). This is useful for debugging.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/metareducers.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { StoreModule, ActionReducer, MetaReducer } from '@ngrx/store';\nimport { reducers } from './reducers';\n\n// console.log all actions\nexport function debug(reducer: ActionReducer<any>): ActionReducer<any> {\n  return function(state, action) {\n    console.log('state', state);\n    console.log('action', action);\n\n    return reducer(state, action);\n  };\n}\n\nexport const metaReducers: MetaReducer<any>[] = [debug];\n\n@NgModule({\n  imports: [\n    StoreModule.forRoot(reducers, { metaReducers })\n  ],\n})\nexport class AppModule {}\n```\n\n----------------------------------------\n\nTITLE: Defining Classes with Consistent NgRx Store Naming in TypeScript\nDESCRIPTION: This snippet illustrates correct usage following the lint rule: both classes inject the Store service and assign it to a property named store. Requires the @ngrx/store package and ensures naming uniformity for maintainability. Ensures all class constructors use the consistent identifier as configured.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/use-consistent-global-store-name.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport class ClassOne {\n  constructor(private store: Store) {}\n}\n\nexport class ClassTwo {\n  constructor(private store: Store) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Example of nameFilter function (TypeScript)\nDESCRIPTION: This function filters an array of entities, returning only those whose `name` property contains the specified `search` string. It takes an array of entities and a search string as input and returns a filtered array of entities.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/entity-metadata.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport function nameFilter(entities: { name: string }[], search: string) {\n  return entities.filter(e => -1 < e.name.indexOf(search));\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing signalMethod Outside Injection Context with Injector Provided in Angular TypeScript\nDESCRIPTION: Highlights the necessity of passing an injector option when initializing signalMethod outside an Angular injection context. This enables proper effect lifecycle management and avoids memory leaks. The example shows signalMethod constructed within ngOnInit with explicit injector reference, enabling processor function creation outside component construction scope.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-method.md#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\n@Component({ /* ... */ })\nexport class NumbersComponent implements OnInit {\n  readonly injector = inject(Injector);\n\n  ngOnInit() {\n    const logDoubledNumber = signalMethod<number>(\n      (num) => console.log(num * 2),\n      { injector: this.injector },\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing ComponentStore State in TypeScript\nDESCRIPTION: Initializes the `ComponentStore` state using the `setState` method, typically within the component's constructor or `ngOnInit`. This sets the initial value according to the defined state interface (`SlideToggleState`). It's crucial to initialize the state before updaters are called.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/component-store/usage.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\n// src/app/slide-toggle.component.ts (region: init)\nconstructor(private readonly store: ComponentStore<SlideToggleState>) {\n  // Initialize the state with default values\n  this.store.setState({ checked: false });\n}\n```\n\n----------------------------------------\n\nTITLE: Selecting State with NgRx ComponentStore in TypeScript\nDESCRIPTION: Defines a ComponentStore that manages a movies state with an observable selector for movies. The selector emits updates when the movies list changes, using the select method to transform state into observable streams. Requires Angular and '@ngrx/component-store'.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/component-store/read.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface MoviesState {\n  movies: Movie[];\n}\n\n@Injectable()\nexport class MoviesStore extends ComponentStore<MoviesState> {\n  \n  constructor() {\n    super({movies:[]});\n  }\n\n  readonly movies$: Observable<Movie[]> = this.select(state => state.movies);\n}\n```\n\n----------------------------------------\n\nTITLE: Empty NgRx Root State (NgModule) - TypeScript\nDESCRIPTION: Initializes the root NgRx store with an empty object using `StoreModule.forRoot({})` in an Angular NgModule. This sets up the core store provider without registering any specific state segments initially.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/reducers.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { NgModule } from '@angular/core';\nimport { StoreModule } from '@ngrx/store';\n\n@NgModule({\n  imports: [\n    StoreModule.forRoot({})\n  ],\n})\nexport class AppModule {}\n```\n\n----------------------------------------\n\nTITLE: Providing ComponentStore in an Angular Component\nDESCRIPTION: Provides the `ComponentStore` within the `providers` array of the Angular component decorator (`@Component`). This ensures each component instance gets its own isolated store. The `ComponentStore` is then injected into the component's constructor. Note: Providing a dedicated service extending ComponentStore is often preferred.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/component-store/usage.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\n// src/app/slide-toggle.component.ts (region: providers)\nimport { Component } from '@angular/core';\nimport { ComponentStore } from '@ngrx/component-store';\nimport { SlideToggleState } from './slide-toggle.state'; // Assuming state interface is defined\n\n@Component({\n  selector: 'app-slide-toggle',\n  templateUrl: './slide-toggle.html',\n  // Provide ComponentStore directly (alternative: provide a dedicated store service)\n  providers: [ComponentStore],\n})\nexport class SlideToggleComponent {\n  constructor(private readonly store: ComponentStore<SlideToggleState>) {\n    // ... component logic\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: NgRx Effect with Action Props (TypeScript)\nDESCRIPTION: Example of an effect that consumes action metadata passed through props to call a service method with specific credentials.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/effects/index.md#_snippet_10\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Injectable, inject } from '@angular/core';\nimport { Actions, ofType, createEffect } from '@ngrx/effects';\nimport { of } from 'rxjs';\nimport { catchError, exhaustMap, map } from 'rxjs/operators';\nimport {\n  LoginPageActions,\n  AuthApiActions,\n} from '../actions';\nimport { Credentials } from '../models/user';\nimport { AuthService } from '../services/auth.service';\n\n@Injectable()\nexport class AuthEffects {\n  private actions$ = inject(Actions);\n  private authService = inject(AuthService);\n\n  login$ = createEffect(() => {\n    return this.actions$.pipe(\n      ofType(LoginPageActions.login),\n      exhaustMap(action =>\n        this.authService.login(action.credentials).pipe(\n          map(user => AuthApiActions.loginSuccess({ user })),\n          catchError(error => of(AuthApiActions.loginFailure({ error })))\n        )\n      )\n    );  \n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Effects: Resubscribe on Error Example\nDESCRIPTION: This snippet illustrates the use of `createEffect` with the `resubscribeOnError` option. It shows the before and after states, highlighting the change to disable resubscription on errors. The `mapToAction` operator is used in the example. The example demonstrates handling errors and disabling resubscription for effects that should not automatically retry.\nSOURCE: https://github.com/ngrx/platform/blob/main/CHANGELOG.md#_snippet_42\n\nLANGUAGE: TypeScript\nCODE:\n```\nlogin$ = createEffect(() =>\n  this.actions$.pipe(\n    ofType(LoginPageActions.login),\n    mapToAction(\n      // Happy path callback\n      (action) => this.authService.login(action.credentials).pipe(map((user) => AuthApiActions.loginSuccess({ user }))),\n      // error callback\n      (error) => AuthApiActions.loginFailure({ error })\n    )\n  )\n);\n\n```\n\n----------------------------------------\n\nTITLE: Correct Usage: Initializing NgRx Signal State with Objects (TypeScript)\nDESCRIPTION: Demonstrates valid ways to initialize NgRx Signal State using `withState`. The root state must be an object (record/dictionary), although properties within that object can hold array values. These examples comply with the 'signal-state-no-arrays-at-root-level' rule.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/signal-state-no-arrays-at-root-level.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst store = withState({ foo: 'bar' });\n\nconst store = withState({ arrayAsProperty: ['foo', 'bar'] })\n\nconst initialState = {};\nconst store = signalStore(withState(initialState));\n```\n\n----------------------------------------\n\nTITLE: Creating Feature and Selectors with NgRx createFeature - TypeScript\nDESCRIPTION: This snippet uses NgRx's createFeature to generate the users feature, including automatic and custom selectors for accessing pieces of user state. It combines adapter-provided selectors with additional ones: selectIsUserSelected and selectSelectedUser. Dependencies include NgRx store and entity adapter; key inputs are reducer and adapter functions. The selectors allow querying for the full user list, selection status, and the selected user entity.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/entity/recipes/entity-adapter-with-feature-creator.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createFeature, createSelector } from '@ngrx/store';\n\nexport const usersFeature = createFeature({\n  name: 'users',\n  reducer,\n  extraSelectors: ({ selectUsersState, selectEntities, selectSelectedUserId }) => ({\n    ...adapter.getSelectors(selectUsersState),\n    selectIsUserSelected: createSelector(\n      selectSelectedUserId,\n      (selectedId) => selectedId !== null\n    ),\n    selectSelectedUser: createSelector(\n      selectSelectedUserId,\n      selectEntities,\n      (selectedId, entities) => selectedId ? entities[selectedId] : null\n    ),\n  }),\n});\n\n```\n\n----------------------------------------\n\nTITLE: Creating parameterized selectors using factory functions for multiple counters\nDESCRIPTION: Defines a factory function returning a selector tailored to an 'id' and 'multiply' factor, enabling multiple independent selector instances for different counters with memoization benefits.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/selectors.md#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport const selectCount = () =>\n  createSelector(\n    (state, props) => state.counter[props.id],\n    (counter, props) => counter * props.multiply\n  );\n```\n\n----------------------------------------\n\nTITLE: Store DevtoolsModule Configuration (After - actionsSafelist)\nDESCRIPTION: This code snippet shows the configuration of `StoreDevtoolsModule` in version 8. The `actionsWhitelist` property has been renamed to `actionsSafelist`.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v8.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nStoreDevtoolsModule.instrument({\n  actionsSafelist: ['...'],\n})\n```\n\n----------------------------------------\n\nTITLE: Filter state in component using combineLatest (incorrect approach)\nDESCRIPTION: Shows an incorrect method of filtering state within a component by combining observables and applying map directly, which bypasses selector composition best practices.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/avoid-combining-component-store-selectors.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport class Component extends ComponentStore<MoviesState> {\n  movie$ = combineLatest(\n    this.select((state) => state.movies),\n    this.select((state) => state.selectedId)\n  ).pipe(map(([movies, selectedId]) => movies[selectedId]));\n\n  constructor() {\n    super({ movies: [] });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining RouterStore Configuration Interface in TypeScript\nDESCRIPTION: Defines the StoreRouterConfig interface for configuring NgRx Router Store options such as the state key, custom serializer class, navigation action dispatch timing, and router state serialization strategy. This interface allows flexible configuration for managing router-related state within the NgRx store.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/router-store/configuration.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ninterface StoreRouterConfig {\n  stateKey?: string | Selector<any, RouterReducerState<T>>;\n  serializer?: new (...args: any[]) => RouterStateSerializer;\n  navigationActionTiming?: NavigationActionTiming;\n  routerState?: RouterState;\n}\n```\n\n----------------------------------------\n\nTITLE: Store DevtoolsModule Configuration (After - actionsBlocklist)\nDESCRIPTION: This code snippet shows the configuration of `StoreDevtoolsModule` in version 8. The `actionsBlacklist` property has been renamed to `actionsBlocklist`.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v8.md#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nStoreDevtoolsModule.instrument({\n  actionsBlocklist: ['...']\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring environment.ts to include Store Devtools\nDESCRIPTION: This snippet shows how to conditionally include the Store Devtools provider in the environment configuration file (`environment.ts`) during development. It imports `provideStoreDevtools` from `@ngrx/store-devtools`, and adds it to the `providers` array with specific options, such as `maxAge` for state history. The environment file is intended to be replaced with `environment.prod.ts` in production to exclude Devtools.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store-devtools/recipes/exclude.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { provideStoreDevtools } from '@ngrx/store-devtools';\n\nexport const environment = {\n    production: false,\n    providers: [\n        provideStoreDevtools({ maxAge: 25 })\n    ],\n};\n```\n\n----------------------------------------\n\nTITLE: Testing moviesCount Computed Property in MoviesStore\nDESCRIPTION: This test verifies that the moviesCount computed property correctly returns the number of movies in the store. It demonstrates a simple approach to testing computed values in a SignalStore.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/testing.md#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { MoviesStore } from './movies.store';\n\ndescribe('MoviesStore', () => {\n  it('should verify that three movies are available', () => {\n    const store = TestBed.inject(MoviesStore);\n\n    expect(store.moviesCount()).toBe(3);\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Registering NgRx ComponentStore in Angular Component with provideComponentStore\nDESCRIPTION: This snippet shows how to register a BooksStore instance within an Angular component using the provideComponentStore() function. The provider array includes this registration for proper dependency injection, enabling lifecycle hooks like OnStoreInit to trigger when the component initializes.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/component-store/lifecycle.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\n@Component({\n  // ... other metadata\n  providers: [\n    provideComponentStore(BooksStore)\n  ]\n})\nexport class BooksPageComponent {\n  constructor(private booksStore: BooksStore) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Router State Serializer in TypeScript for NgRx Router Store\nDESCRIPTION: Provides a custom serializer class implementing RouterStateSerializer to transform the Angular RouterStateSnapshot into a pared-down RouterStateUrl containing only the URL, route params, and query params. This approach optimizes the payload size for store actions and improves performance when using store devtools. The serializer depends on Angular's RouterStateSnapshot and NgRx router-store packages.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/router-store/configuration.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Params, RouterStateSnapshot } from '@angular/router';\nimport { RouterStateSerializer } from '@ngrx/router-store';\n\nexport interface RouterStateUrl {\n  url: string;\n  params: Params;\n  queryParams: Params;\n}\n\nexport class CustomSerializer implements RouterStateSerializer<RouterStateUrl> {\n  serialize(routerState: RouterStateSnapshot): RouterStateUrl {\n    let route = routerState.root;\n\n    while (route.firstChild) {\n      route = route.firstChild;\n    }\n\n    const {\n      url,\n      root: { queryParams },\n    } = routerState;\n    const { params } = route;\n\n    // Only return an object including the URL, params and query params\n    // instead of the entire snapshot\n    return { url, params, queryParams };\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Providing Custom EntityDispatcherDefaultOptions in TypeScript\nDESCRIPTION: Illustrates how to provide custom default options for entity dispatchers, potentially overriding the default pessimistic save behavior for saveEntities.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/save-entities.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n{\n  provide: EntityDispatcherDefaultOptions,\n  useValue: myDispatcherDefaultOptions\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Action with Object Props (After v13 Restriction) - TypeScript\nDESCRIPTION: Example showing the required syntax for `createAction` in v13, where the generic type for `props` must be an object type (e.g., `{ name: string }`), not a primitive type. Error messages are more explicit.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v13.md#_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\nconst action = createAction('[Source] Event', props<{ name: string }>());\n```\n\n----------------------------------------\n\nTITLE: Defining NgRx Effects with @Effect Decorator (Deprecated)\nDESCRIPTION: Illustrates the previous method of defining side effects in NgRx using the `@Effect()` decorator applied to a class property. This approach is deprecated in v11 in favor of the `createEffect` function.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v11.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n@Effect()\nlogin$ = this.actions$.pipe(...);\n```\n\n----------------------------------------\n\nTITLE: Declaring a Login Action with Credentials as POJO in JSON\nDESCRIPTION: This snippet defines a user-initiated login action as a JSON object, including 'type' along with 'username' and 'password' properties for credential delivery. This structure is commonly used when an action needs to carry user input or payload to reducers or effects. Dependencies: must follow the NgRx action format; constraints: provides sensitive information, so use securely.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/actions.md#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"type\": \"[Login Page] Login\",\n  \"username\": \"string\",\n  \"password\": \"string\"\n}\n```\n\n----------------------------------------\n\nTITLE: Registering NgRx Feature Using StoreModule.forFeature in Angular Module\nDESCRIPTION: Demonstrates how to register an NgRx feature defined by `createFeature` using the traditional module-based approach. The entire `booksFeature` object is passed to `StoreModule.forFeature` within the `imports` array of an Angular NgModule.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/feature-creators.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { NgModule } from '@angular/core';\nimport { StoreModule } from '@ngrx/store';\n\nimport { booksFeature } from './books.reducer';\n\n@NgModule({\n  imports: [StoreModule.forFeature(booksFeature)],\n})\nexport class BooksModule {}\n```\n\n----------------------------------------\n\nTITLE: Correcting NgRx State Interface for createFeature with Nullable/Undefined Properties in TypeScript\nDESCRIPTION: Demonstrates the correct way to define state properties that may not always have a value when using `createFeature`. Instead of using the optional `?` syntax, properties are typed using `| null` or `| undefined`, and the initial state explicitly provides a default value (e.g., `null` or `undefined`) for these properties.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/feature-creators.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\ninterface State {\n  books: Book[];\n  activeBookId: string | null;\n  // or activeBookId: string | undefined;\n}\n\nconst initialState: State = {\n  books: [],\n  activeBookId: null,\n  // or activeBookId: undefined,\n};\n```\n\n----------------------------------------\n\nTITLE: Using ComponentStore Directly Within PaginatorComponent - TypeScript\nDESCRIPTION: Illustrates an approach where the ComponentStore instance is embedded inside the PaginatorComponent itself, organizing state mutation and observation directly within the component. The component contains delineated updater, selector, and effect sections managing paginator inputs and interactions, thus reducing imperative change detection calls and fostering reactive patterns. Though this makes the component smaller and more reactive, it may become harder to read and maintain compared to a dedicated store service. Requires Angular ComponentStore and Angular Material paginator types. Inputs are handled via updaters, state read via selectors, and side effects managed within effects.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/component-store/usage.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Simplified example of ComponentStore usage within a PaginatorComponent\n@Component({ selector: 'paginator', templateUrl: './paginator.component.html' })\nexport class PaginatorComponent {\n  private readonly store = new ComponentStore<PaginatorState>({ pageIndex: 0, pageSize: 10 });\n\n  readonly vm$ = this.store.select(state => ({ pageIndex: state.pageIndex, pageSize: state.pageSize }));\n\n  @Input() set pageIndex(value: number) {\n    this.store.updater((state, pageIndex) => ({ ...state, pageIndex }))(value);\n  }\n\n  @Input() set pageSize(value: number) {\n    this.store.updater((state, pageSize) => ({ ...state, pageSize }))(value);\n  }\n\n  // Effects and other logic follow\n}\n```\n\n----------------------------------------\n\nTITLE: Correct global Store injection without explicit typing in Angular component\nDESCRIPTION: This snippet illustrates the recommended approach where the Store is injected without specifying a type parameter, leveraging type safety with selectors and maintaining a single Store instance. It ensures adherence to ngrx guidelines by avoiding unnecessary generic parameters.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/no-typed-global-store.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport class Component {\n  data$ = this.store.select(data);\n\n  constructor(private readonly store: Store) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Feature Selector (After v13 Two Generics Deprecation) - TypeScript\nDESCRIPTION: Example showing the updated syntax for `createFeatureSelector` in v13. The method now only requires a single generic type argument representing the Feature State. A migration schematic is provided.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v13.md#_snippet_10\n\nLANGUAGE: ts\nCODE:\n```\nconst selectFeature = createFeatureSelector<Feature>('feature');\n```\n\n----------------------------------------\n\nTITLE: Creating Counter Component with Store State Observables and Action Dispatching (TypeScript)\nDESCRIPTION: Defines an Angular component 'MyCounterComponent' that declares an observable 'count$' to subscribe to the current counter state from the store. It includes increment, decrement, and reset methods stubbed out to dispatch corresponding actions to the store when called. This snippet shows connecting component UI with the store’s state and dispatching events to trigger state updates. It requires Angular, RxJS, and NgRx store injection for usage.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/index.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Component } from '@angular/core';\nimport { Observable } from 'rxjs';\n\n@Component({\n  selector: 'app-my-counter',\n  templateUrl: './my-counter.component.html',\n})\nexport class MyCounterComponent {\n  count$: Observable<number>\n\n  constructor() {\n    // TODO: Connect `this.count$` stream to the current store `count` state\n  }\n\n  increment() {\n    // TODO: Dispatch an increment action\n  }\n\n  decrement() {\n    // TODO: Dispatch a decrement action\n  }\n\n  reset() {\n    // TODO: Dispatch a reset action\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Importing environment configuration into app.config.ts\nDESCRIPTION: This snippet demonstrates how to import the environment settings into the application's main configuration file (`app.config.ts`). It imports the `environment` object and incorporates its `providers` array into the overall application providers, enabling conditional inclusion of Store Devtools based on the environment. This setup helps ensure Devtools are excluded in production by using the production environment file.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store-devtools/recipes/exclude.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { environment } from '../environments/environment';\n\nexport const appConfig: ApplicationConfig = {\n    providers: [\n        provideStore(),\n        environment.providers,\n    ]\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing NgRx ComponentStore with OnStateInit Lifecycle Hook in TypeScript (Eager Initialization)\nDESCRIPTION: This snippet demonstrates a BooksStore class implementing OnStateInit. The constructor performs eager initialization by invoking super() with the initial state. The ngrxOnStateInit method is used for logic that should run once after the state is first set, making it suitable for immediate post-initialization side effects.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/component-store/lifecycle.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface BooksState {\n  collection: Book[];\n}\n\nexport const initialState: BooksState = {\n  collection: []\n};\n\n@Injectable()\nexport class BooksStore extends ComponentStore<BooksState> implements OnStateInit {\n  constructor() {\n    // eager state initialization\n    super(initialState);\n  }\n\n  ngrxOnStateInit() {\n    // called once after state has been first initialized\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Handling of a Single Action in NgRx Reducer\nDESCRIPTION: This snippet demonstrates a proper reducer setup where each action is handled exactly once, ensuring clear and maintainable state management. Handling an action only once prevents bugs and aligns with best practices unless specific conditions suggest otherwise.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/avoid-duplicate-actions-in-reducer.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport const reducer = createReducer(\n  initialState,\n  on(customerLoaded, (state) => ({ ...state, status: 'loaded' }))\n);\n```\n\n----------------------------------------\n\nTITLE: Correct implementation with EffectsModule.forFeature()\nDESCRIPTION: This example shows correct code where an effect class is only added to EffectsModule.forFeature() and not declared in the providers array.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/no-effects-in-providers.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n@NgModule({\n  imports: [EffectsModule.forFeature([CustomersEffect])],\n})\nexport class CustomersModule {}\n```\n\n----------------------------------------\n\nTITLE: StoreModule Configuration with Invalid Initial State\nDESCRIPTION: Example showing how type checking for initialState has been improved in NgRx store. Previously, missing properties were valid but now a type error is produced when initialState doesn't match the store/feature.\nSOURCE: https://github.com/ngrx/platform/blob/main/CHANGELOG.md#_snippet_32\n\nLANGUAGE: typescript\nCODE:\n```\nStoreModule.forRoot(reducers, {\n  initialState: { notExisting: 3 },\n  metaReducers: [metaReducer],\n});\n```\n\n----------------------------------------\n\nTITLE: Defining NgRx Actions with Loose Props (Before v11)\nDESCRIPTION: Demonstrates the previous way of defining an NgRx action using `createAction` with `props<{}>()`. This allowed primitive types as payloads, which is disallowed in v11 due to stricter type checking that prevents ambiguity.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v11.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst customerPageLoaded = createAction('[Customer Page] Loaded', props<{}>());\n\ncustomerPageLoaded({}); // ✔️\ncustomerPageLoaded({ foo: 'bar' }); // ✔️\ncustomerPageLoaded(0); // 👈 no error\ncustomerPageLoaded(false); // 👈 no error\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Ngrx Router Navigation Actions\nDESCRIPTION: Provides the TypeScript definitions for custom Ngrx actions that represent router navigation events. These actions (`GO`, `BACK`, `FORWARD`) replace the deprecated built-in ones and are designed to be dispatched from components or services.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v4.md#_snippet_10\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Action } from '@ngrx/store';\nimport { NavigationExtras } from '@angular/router';\n\nexport const GO = '[Router] Go';\nexport const BACK = '[Router] Back';\nexport const FORWARD = '[Router] Forward';\n\nexport class Go implements Action {\n  readonly type = GO;\n\n  constructor(\n    public payload: {\n      path: any[];\n      query?: object;\n      extras?: NavigationExtras;\n    }\n  ) {}\n}\n\nexport class Back implements Action {\n  readonly type = BACK;\n}\n\nexport class Forward implements Action {\n  readonly type = FORWARD;\n}\n\nexport type Actions = Go | Back | Forward;\n```\n\n----------------------------------------\n\nTITLE: NgRx Effect with State Access (TypeScript)\nDESCRIPTION: Example of an effect that accesses store state using concatLatestFrom to display different alerts based on the collection size after a successful action.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/effects/index.md#_snippet_11\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Injectable, inject } from '@angular/core';\nimport { Store } from '@ngrx/store';\nimport { Actions, ofType, createEffect, concatLatestFrom } from '@ngrx/effects';\nimport { tap } from 'rxjs/operators';\nimport { CollectionApiActions } from '../actions';\nimport * as fromBooks from '../reducers';\n\n@Injectable()\nexport class CollectionEffects {\n  private actions$ = inject(Actions);\n  private store = inject(Store<fromBooks.State>);\n\n  addBookToCollectionSuccess$ = createEffect(\n    () => {\n      return this.actions$.pipe(\n        ofType(CollectionApiActions.addBookSuccess),\n        concatLatestFrom(_action => this.store.select(fromBooks.getCollectionBookIds)),\n        tap(([_action, bookCollection]) => {\n          if (bookCollection.length === 1) {\n            window.alert('Congrats on adding your first book!');\n          } else {\n            window.alert('You have added book number ' + bookCollection.length);\n          }\n        })\n      );\n    },\n    { dispatch: false });\n}\n```\n\n----------------------------------------\n\nTITLE: Update NgRx packages using Angular CLI\nDESCRIPTION: This command updates the @ngrx/store package to version 18 using the Angular CLI. It also runs migration schematics to address breaking changes.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v18.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nng update @ngrx/store@18\n```\n\n----------------------------------------\n\nTITLE: Implementing Book Collection Component Template (HTML)\nDESCRIPTION: HTML template for the `BookCollectionComponent`. It iterates over the user's book collection (`*ngFor=\"let book of books | async\"`) and displays book information. Includes a button for each book to trigger the `(remove)` output event.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/walkthrough.md#_snippet_10\n\nLANGUAGE: HTML\nCODE:\n```\n<!-- Code from src/app/book-collection/book-collection.component.html -->\n<!-- Displays the user's book collection with a 'Remove from Collection' button. -->\n```\n\n----------------------------------------\n\nTITLE: Defining NgRx Selector Before V15 (TypeScript)\nDESCRIPTION: Shows the definition of an NgRx selector using `createSelector` before version 15. In these older versions, the selector's `projector` function was not strictly type-checked against the input selectors, potentially allowing runtime errors if the types didn't align. The type of `mySelector.projector()` was inferred broadly as `projector(...args: any[]): number`.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v15.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst mySelector = createSelector(\n  () => 'one',\n  () => 2,\n  (one, two) => 3\n)\n\nmySelector.projector() // <- type is projector(...args: any[]): number\n```\n\n----------------------------------------\n\nTITLE: Providing an alternative EntityCacheDataService Implementation (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to override the default `EntityCacheDataService` with a custom implementation. This allows developers to customize the data saving and retrieval logic according to their specific application requirements.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/save-entities.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n{ provide: EntityCacheDataService: useClass: MyCacheDataService }\n```\n\n----------------------------------------\n\nTITLE: Using tapResponse in NgRx Component Store\nDESCRIPTION: This snippet shows the use of `tapResponse` within an NgRx component store effect. It fetches a movie by its ID and uses `tapResponse` to handle success and error scenarios.  The `tapResponse` operator takes two callbacks: one for handling successful responses (addMovie) and one for handling errors (logError). The effect uses `switchMap` to handle potential race conditions.  Dependencies include `@ngrx/component-store` and potentially an HTTP service (moviesService) .\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/operators/operators.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\n  readonly getMovie = this.effect((movieId$: Observable<string>) => {\n    return movieId$.pipe(\n      // 👇 Handle race condition with the proper choice of the flattening operator.\n      switchMap((id) => this.moviesService.fetchMovie(id).pipe(\n        //👇 Act on the result within inner pipe.\n        tapResponse(\n          (movie) => this.addMovie(movie),\n          (error: HttpErrorResponse) => this.logError(error),\n        ),\n      )),\n    );\n  });\n```\n\n----------------------------------------\n\nTITLE: Adding Extra Custom Selectors to NgRx Feature with createFeature in TypeScript\nDESCRIPTION: Shows how to add custom selectors to the feature using the `extraSelectors` option within `createFeature`. The `extraSelectors` function receives the auto-generated selectors as arguments, allowing them to be used as input for creating new selectors like `selectFilteredBooks`.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/feature-creators.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createFeature, createReducer, on } from '@ngrx/store';\nimport { Book } from './book.model';\n\nimport * as BookListPageActions from './book-list-page.actions';\n\ninterface State {\n  books: Book[];\n  query: string;\n}\n\nconst initialState: State = {\n  books: [],\n  query: '',\n};\n\nexport const booksFeature = createFeature({\n  name: 'books',\n  reducer: createReducer(\n    initialState,\n    on(BookListPageActions.search, (state, action) => ({\n      ...state,\n      query: action.query,\n    })),\n  ),\n  extraSelectors: ({ selectQuery, selectBooks }) => ({\n    selectFilteredBooks: createSelector(\n      selectQuery,\n      selectBooks,\n      (query, books) => books.filter(book => book.title.includes(query)),\n    ),\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Feature Selector (Before v13 Two Generics Deprecation) - TypeScript\nDESCRIPTION: Example showing the deprecated syntax for `createFeatureSelector` which required two generic type arguments (Root State and Feature State). This form is deprecated in v13.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v13.md#_snippet_9\n\nLANGUAGE: ts\nCODE:\n```\nconst selectFeature = createFeatureSelector<State, Feature>('feature');\n```\n\n----------------------------------------\n\nTITLE: Simplifying StoreModule.forRoot Configuration in TypeScript\nDESCRIPTION: This snippet shows a change in the recommended default configuration of StoreModule in Angular NgRx applications. The before snippet illustrates passing reducers, metaReducers, and runtimeChecks explicitly to StoreModule.forRoot. The after snippet demonstrates a minimal setup passing an empty object for reducers, reflecting default runtime behaviors introduced in this version including immutability checks. This change reduces boilerplate and enforces stricter state management by default.\nSOURCE: https://github.com/ngrx/platform/blob/main/CHANGELOG.md#_snippet_41\n\nLANGUAGE: TypeScript\nCODE:\n```\n@NgModule({\n  declarations: [\n    AppComponent,\n  ],\n  imports: [\n    BrowserModule,\n    StoreModule.forRoot(reducers, {\n      metaReducers,\n      runtimeChecks: {\n        strictStateImmutability: true,\n        strictActionImmutability: true\n      }\n    }),\n    .....\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\n@NgModule({\n  declarations: [\n    AppComponent,\n  ],\n  imports: [\n    BrowserModule,\n    StoreModule.forRoot({})\n    ....\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\n```\n\n----------------------------------------\n\nTITLE: Incorrect Signal Store Feature Definition (TypeScript)\nDESCRIPTION: This snippet demonstrates incorrect implementations of Signal Store features in TypeScript. These examples fail to define a generic type for the feature's state. This can lead to type-related issues and reduce code flexibility and maintainability. The code utilizes `signalStoreFeature`, `withState`, and `type` to define and initialize the feature.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/signal-store-feature-should-use-generic-type.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst withY = () => signalStoreFeature(\n    { state: type<{ y: number }>() },\n    withState({})\n  );\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst withY = () => {\n  return signalStoreFeature(\n    type<{ state: { y: number } }>(),\n    withState({})\n  );\n}\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction withY() {\n  return signalStoreFeature(\n    type<{ state: { y: number } }>(),\n    withState({})\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Correct: Non-Dispatching NgRx Effect with Side Effect\nDESCRIPTION: This TypeScript snippet shows a correct way to handle side effects without dispatching actions. The `details$` effect listens for `fromCustomers.pageLoaded` and performs a side effect using `tap`. Crucially, it includes `{ dispatch: false }` in the `createEffect` options, preventing any action from being dispatched and thus avoiding a potential loop.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/avoid-cyclic-effects.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nclass Effect {\n  details$ = createEffect(\n    () =>\n      this.actions$.pipe(\n        ofType(fromCustomers.pageLoaded),\n        tap(() => alert('Customers loaded'))\n      ),\n    { dispatch: false } // Correct: Explicitly disable dispatch\n  );\n\n  constructor(private actions$: Actions) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Using Request Status Feature in BooksStore with ngrx/signals (TypeScript)\nDESCRIPTION: This code demonstrates how to integrate the `withRequestStatus` feature and associated updaters into a `BooksStore` using NgRx Signals. It showcases the usage of `patchState` for updating the store's state, including setting the request status to pending and fulfilled. The store also utilizes `withEntities` to manage book entities.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/custom-store-features.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { inject } from '@angular/core';\nimport { patchState, signalStore, withMethods } from '@ngrx/signals';\nimport { setAllEntities, withEntities } from '@ngrx/signals/entities';\nimport { setFulfilled, setPending, withRequestStatus } from './request-status.feature';\nimport { Book } from './book.model';\nimport { BooksService } from './books.service';\n\nexport const BooksStore = signalStore(\n  withEntities<Book>(),\n  withRequestStatus(),\n  withMethods((store, booksService = inject(BooksService)) => ({\n    async loadAll() {\n      patchState(store, setPending());\n\n      const books = await booksService.getAll();\n      patchState(store, setAllEntities(books), setFulfilled());\n    },\n  })),\n);\n```\n\n----------------------------------------\n\nTITLE: Defining Book Model Interface in TypeScript\nDESCRIPTION: Defines the `Book` interface using TypeScript to structure the data for books used throughout the application. This model specifies the properties like 'id', 'volumeInfo', etc., ensuring type safety.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/walkthrough.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Code from src/app/book-list/books.model.ts\n// Defines the structure for a Book object.\n```\n\n----------------------------------------\n\nTITLE: Importing NgRx LetDirective in Angular Component\nDESCRIPTION: Shows how to import the standalone `LetDirective` from `@ngrx/component` into an Angular standalone component's `imports` array. This makes the `*ngrxLet` directive available for use within the component's template.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/component/let.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Component } from '@angular/core';\nimport { LetDirective } from '@ngrx/component';\n\n@Component({\n  // ... other metadata\n  imports: [\n    // ... other imports\n    LetDirective,\n  ],\n})\nexport class MyStandaloneComponent {}\n```\n\n----------------------------------------\n\nTITLE: Registering Custom HttpUrlGenerator Provider in Angular Root Module in TypeScript\nDESCRIPTION: This snippet illustrates how to replace the default HttpUrlGenerator with a custom implementation by providing it in the Angular root AppModule. It modifies the providers array to use the PluralHttpUrlGenerator class for the HttpUrlGenerator token, ensuring that EntityDataModule uses the customized URL generator throughout the application. This configuration provides a straightforward method of dependency injection replacement consistent with Angular design patterns.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/extension-points.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\n@NgModule({\n  // ...\n  imports: [\n    // ...\n    EntityDataModule.forRoot({})\n  ],\n  providers: [\n    // ...\n    { provide: HttpUrlGenerator, useClass: PluralHttpUrlGenerator }\n  ]\n})\nexport class AppModule {}\n```\n\n----------------------------------------\n\nTITLE: Installing NgRx Operators with yarn\nDESCRIPTION: This command installs the `@ngrx/operators` package using `yarn`. Yarn is a package manager that can be used as an alternative to npm.  This installation method requires yarn to be installed and configured correctly.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/operators/install.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nyarn add @ngrx/operators\n```\n\n----------------------------------------\n\nTITLE: Breaking Change: Replacing getSelectors with getRouterSelectors\nDESCRIPTION: Example showing the replacement of getSelectors function with getRouterSelectors in the router-store module.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v16.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getSelectors } from '@ngrx/router-store';\n\nconst routerSelectors = getSelectors();\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getRouterSelectors } from '@ngrx/router-store';\n\nconst routerSelectors = getRouterSelectors();\n```\n\n----------------------------------------\n\nTITLE: Correct NgRx Action Props Definition using Inline Types (Object Syntax)\nDESCRIPTION: This code demonstrates proper usage of inline types in NgRx createAction by directly defining the props inline with an object type. It specifies a functional, self-descriptive type declaration within the createAction call, improving readability and ease of use. Dependencies involve NgRx's createAction and props functions. This pattern ensures type safety without separate interface declarations, providing clearer intent and better tooling support.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/prefer-inline-action-props.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport const addUser = createAction(\n  '[Users] Add User',\n  props<{ id: number; fullName: string }>()\n);\n```\n\n----------------------------------------\n\nTITLE: Integrating Components in AppComponent Template (HTML)\nDESCRIPTION: Shows how the `BookListComponent` and `BookCollectionComponent` are used within the main `AppComponent` template. It binds the relevant state observables (`books$`, `bookCollection$`) to the component inputs and wires up the output events (`(add)`, `(remove)`) to methods in the `AppComponent` class.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/walkthrough.md#_snippet_12\n\nLANGUAGE: HTML\nCODE:\n```\n<!-- Code from src/app/app.component.html (components region) -->\n<!-- Uses BookListComponent and BookCollectionComponent, binding data and events. -->\n```\n\n----------------------------------------\n\nTITLE: Bypassing Strict Selector Projector Type Check in V15 (TypeScript)\nDESCRIPTION: Demonstrates how to bypass the default strict type checking for the selector's `projector` function introduced in NgRx v15. By asserting the `projector` property to the `any` type (`as any`), the previous, less type-safe behavior can be restored, allowing the projector to be invoked without strict compile-time argument matching.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v15.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst mySelector = createSelector(\n  () => 'one',\n  () => 2,\n  (one, two) => 3\n)\n\n(mySelector.projector as any)()\n```\n\n----------------------------------------\n\nTITLE: Extending NgRx Data - Creating EntityCollectionReducerMethodsFactory\nDESCRIPTION: This snippet demonstrates how to create a factory class `AdditionalEntityCollectionReducerMethodsFactory` to create the custom reducer methods that will overwrite the default ones used in NgRx Data. It uses the `EntityDefinitionService` to retrieve entity definitions based on the entity name, which is then used to instantiate `AdditionalEntityCollectionReducerMethods`. This method is then used in the NgModule configuration in the next snippet.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/entity-metadata.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\n@Injectable()\nexport class AdditionalEntityCollectionReducerMethodsFactory {\n  constructor(private entityDefinitionService: EntityDefinitionService) {}\n   /** Create the  {EntityCollectionReducerMethods} for the named entity type */\n  create<T>(entityName: string): EntityCollectionReducerMethodMap<T> {\n    const definition = this.entityDefinitionService.getDefinition<T>(entityName);\n    const methodsClass = new AdditionalEntityCollectionReducerMethods(entityName, definition);\n     return methodsClass.methods;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing NgRx Component Package with npm install - shell\nDESCRIPTION: Runs the command `npm install @ngrx/component --save` to add the NgRx Component package to your project dependencies using npm. Ensures the package is saved into the package.json file. Requires that Node.js and npm are installed and properly configured.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/component/install.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nnpm install @ngrx/component --save\n```\n\n----------------------------------------\n\nTITLE: Using signalMethod with Automatic Cleanup in Angular TypeScript\nDESCRIPTION: Illustrates that signalMethod internally utilizes an effect that runs in the caller's injection context. When the processor is used inside a component, cleanup occurs automatically upon component destruction, even if the call happens outside of the injection context (e.g., ngOnInit). Inputs are Signals or static values and effects are cleaned up to prevent memory leaks within Angular's lifecycle.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-method.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\n@Component({ /* ... */ })\nexport class NumbersComponent implements OnInit {\n  readonly logDoubledNumber = signalMethod<number>((num) => {\n    const double = num * 2;\n    console.log(double);\n  });\n\n  ngOnInit(): void {\n    const value = signal(2);\n    // 👇 Uses the injection context of the `NumbersComponent`.\n    this.logDoubledNumber(value);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: NgRx Data Action Log Entries Illustrating EntityAction Dispatch Results in Shell\nDESCRIPTION: These shell output examples show the logged NgRx store actions resulting from dispatching an EntityAction created by the factory both with and without a custom tag, and also when created manually. They illustrate how tags affect the readability and context of action log entries and demonstrate the two-step request/response lifecycle managed by NgRx Data effects.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/entity-actions.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n[Hero] ngrx/data/query-all\n[Hero] ngrx/data/query-all/success\n```\n\nLANGUAGE: shell\nCODE:\n```\n[Load Heroes On Start] ngrx/data/query-all\n[Load Heroes On Start] ngrx/data/query-all/success\n```\n\nLANGUAGE: shell\nCODE:\n```\nsome/arbitrary/action/type\n[Hero] NgRx Data/query-all-success\n```\n\n----------------------------------------\n\nTITLE: Defining Classes with Inconsistent NgRx Store Names in TypeScript\nDESCRIPTION: This snippet shows an example where two classes inject the Store service but use different private property names (store and customersStore), which is discouraged by the lint rule. No external dependencies aside from @ngrx/store are implied. This demonstrates a violation of naming consistency for the global store variable.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/use-consistent-global-store-name.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport class ClassOne {\n  constructor(private store: Store) {}\n}\n\nexport class ClassTwo {\n  constructor(private customersStore: Store) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Example of sortByName function (TypeScript)\nDESCRIPTION: This function defines a custom sort comparer for entities with a `name` property. It sorts the entities alphabetically by name using the `localeCompare` method.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/entity-metadata.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nexport function sortByName(a: { name: string }, b: { name: string }): number {\n  return a.name.localeCompare(b.name);\n}\n```\n\n----------------------------------------\n\nTITLE: Using factory-created selectors inside component for multiple counters\nDESCRIPTION: Shows how to instantiate distinct selectors with different 'props' for multiple counters, ensuring memoization per instance and avoiding recomputation across different parameters.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/selectors.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nngOnInit() {\n  this.counter2 = this.store.select(fromRoot.selectCount(), { id: 'counter2', multiply: 2 });\n  this.counter4 = this.store.select(fromRoot.selectCount(), { id: 'counter4', multiply: 4 });\n  this.counter6 = this.store.select(fromRoot.selectCount(), { id: 'counter6', multiply: 6 });\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the ChangeSetOperation Enum in TypeScript\nDESCRIPTION: Shows the TypeScript enum defining the types of change operations that can be included in a ChangeSet: Add, Delete, Update, and Upsert.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/save-entities.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport enum ChangeSetOperation {\n  Add = 'Add',\n  Delete = 'Delete',\n  Update = 'Update',\n  Upsert = 'Upsert'\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Effect implementation with OnRunEffects interface - TypeScript\nDESCRIPTION: This example illustrates the correct implementation of the `OnRunEffects` interface. The class `Effect` now implements the `OnRunEffects` interface, and the `ngrxOnRunEffects` method is appropriately defined within the class, preventing the linting error. Import statement is included.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/use-effects-lifecycle-interface.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { OnRunEffects } from '@ngrx/effects';\n\nclass Effect implements OnRunEffects {\n  constructor(private actions$: Actions) {}\n  ngrxOnRunEffects(resolvedEffects$: Observable<EffectNotification>) {\n    return this.actions$.pipe(\n      ofType('LOGGED_IN'),\n      exhaustMap(() =>\n        resolvedEffects$.pipe(\n          takeUntil(this.actions$.pipe(ofType('LOGGED_OUT')))\n        )\n      )\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing @ngrx/signals with npm\nDESCRIPTION: This snippet shows how to install the @ngrx/signals package using npm. The `--save` flag ensures the package is added to the project's `package.json` dependencies. Requires npm to be installed and a valid project setup.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/install.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nnpm install @ngrx/signals --save\n```\n\n----------------------------------------\n\nTITLE: Implementing OnInitEffects Interface in NgRx (TypeScript)\nDESCRIPTION: Shows how to implement the OnInitEffects interface to dispatch a custom action after an effect has been registered, providing a hook for initialization logic.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/effects/lifecycle.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nclass UserEffects implements OnInitEffects {\n  ngrxOnInitEffects(): Action {\n    return { type: '[UserEffects]: Init' };\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Request Status Updaters for ngrx/signals (TypeScript)\nDESCRIPTION: These functions define state updaters for modifying the request status within an NgRx SignalStore. These functions are designed to be used with `patchState` to update the `requestStatus` state slice. Defining updaters as standalone functions promotes tree-shaking and simplifies testing.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/custom-store-features.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport function setPending(): RequestStatusState {\n  return { requestStatus: 'pending' };\n}\n\nexport function setFulfilled(): RequestStatusState {\n  return { requestStatus: 'fulfilled' };\n}\n\nexport function setError(error: string): RequestStatusState {\n  return { requestStatus: { error } };\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Feature with Properties and Methods as Input with ngrx/signals (TypeScript)\nDESCRIPTION: This code demonstrates creating a feature (`withBaz`) that expects specific properties (foo) and methods (bar) to be defined in the store where it's used.  It uses the `type` helper function to specify the expected types for properties and methods. The feature's logic relies on the existence of these inputs.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/custom-store-features.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Signal } from '@angular/core';\nimport { signalStoreFeature, type, withMethods } from '@ngrx/signals';\n\nexport function withBaz<Foo extends string | number>() {\n  return signalStoreFeature(\n    {\n      props: type<{ foo: Signal<Foo> }>(),\n      methods: type<{ bar(foo: number): void }>(),\n    },\n    withMethods((store) => ({\n      baz(): void {\n        const foo = store.foo();\n        store.bar(typeof foo === 'number' ? foo : Number(foo));\n      },\n    }))\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Importing NgRx StoreModule and Reducers in AppModule (TypeScript)\nDESCRIPTION: Shows the necessary top-level imports in `app.module.ts` for integrating NgRx Store. This includes importing `StoreModule` from `@ngrx/store` and the previously defined `booksReducer` and `collectionReducer`.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/walkthrough.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Code from src/app/app.module.ts (partialTopLevelImports region)\n// Imports StoreModule and the application's reducers.\n```\n\n----------------------------------------\n\nTITLE: Generating a Basic User Action File (Shell)\nDESCRIPTION: Example command to generate a 'User' action file along with its corresponding spec file using the default settings. This will create `user.actions.ts` and `user.actions.spec.ts` in the current or default path.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/schematics/action.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nng generate action User\n```\n\n----------------------------------------\n\nTITLE: Changing Default Effect Configuration in NgRx Effects Schematics\nDESCRIPTION: This demonstrates configuring the Effects module with default settings, where `Effect` creators are enabled by default, removing the need for explicit decorators, and only registering `EffectsModule.forRoot()` with an empty array.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v9.md#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\n@NgModule({\n  imports: [\n    EffectsModule.forRoot([]),\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Testing Functional NgRx Effects with Fake Dependencies - TypeScript\nDESCRIPTION: This test verifies a functional NgRx effect by passing in mock arguments for actions and services, eliminating the need for Angular's TestBed. It constructs an observable actions stream and supplies a mock ActorsService with a getAll method returning a value. The test confirms that the effect emits a success action with the correct payload. Dependencies include RxJS 'of', the loadActors effect function, and mock service/action creators. Key parameters are the input stream and service; expected output is a success action observable. The pattern enables isolated function-level testing.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/effects/testing.md#_snippet_13\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { of } from 'rxjs';\n\nimport { loadActors } from './actors.effects';\nimport { ActorsService } from './actors.service';\nimport { actorsMock } from './actors.mock';\nimport { ActorsPageActions } from './actors-page.actions';\nimport { ActorsApiActions } from './actors-api.actions';\n\nit('loads actors successfully', (done) => {\n  const actorsServiceMock = {\n    getAll: () => of(actorsMock),\n  } as ActorsService;\n  const actionsMock$ = of(ActorsPageActions.opened());\n\n  loadActors(actionsMock$, actorsServiceMock).subscribe((action) => {\n    expect(action).toEqual(\n      ActorsApiActions.actorsLoadedSuccess({ actors: actorsMock })\n    );\n    done();\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Generating a Nested User Action File (Shell)\nDESCRIPTION: Example command demonstrating how to generate a 'User' action file nested within a folder named 'user' by using the `--flat false` option. This overrides the default `flat=true` behavior.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/schematics/action.md#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\nng generate action User --flat false\n```\n\n----------------------------------------\n\nTITLE: Generating a Feature Set with NgRx using Angular CLI - Shell\nDESCRIPTION: Executes the Angular CLI command to generate a feature with corresponding actions, effects, reducer, and selectors files. The command requires the Angular CLI with NgRx schematics installed as a dependency. 'FeatureName' is a placeholder for the new state feature, and '[options]' can include project, grouping, module, reducers, API scaffolding, or test generation toggles. The output files are automatically structured into the intended location per the provided options.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/schematics/feature.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nng generate feature FeatureName [options]\n```\n\n----------------------------------------\n\nTITLE: Configure DefaultDataService using DefaultDataServiceConfig (TypeScript)\nDESCRIPTION: Defines a configuration object for the DefaultDataService using the DefaultDataServiceConfig interface. This allows customizing properties like the API root URL and request timeout. This object is then provided via dependency injection to configure the default data service behavior.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/entity-dataservice.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst defaultDataServiceConfig: DefaultDataServiceConfig = {\n  root: 'https://my-api-domain.com:8000/api/v1',\n  timeout: 3000 // request timeout\n}\n```\n\n----------------------------------------\n\nTITLE: Installing NgRx Component Package with Angular CLI using ng add - shell\nDESCRIPTION: Executes the Angular CLI command `ng add @ngrx/component@latest` to add the NgRx Component package to the project. This automates updating the project's package.json dependencies and runs the package manager to install the package. Requires Angular CLI to be installed and your project to be an Angular workspace.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/component/install.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nng add @ngrx/component@latest\n```\n\n----------------------------------------\n\nTITLE: Defining withTotalEntities Feature with props (Post-Version 19) - NgRx Signals TypeScript\nDESCRIPTION: This TypeScript code demonstrates the updated pattern for defining a SignalStoreFeature in NgRx v19+, replacing the deprecated 'computed' property with 'props'. It utilizes the new 'EntityProps' type from '@ngrx/signals/entities'. The function takes an Entity type and an 'entities' collection and returns a feature exposing computed props such as the entity total. Dependencies include @ngrx/signals and @ngrx/signals/entities. The migrated code ensures compatibility with the latest API.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v19.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { computed, Signal } from '@angular/core';\nimport {\n  signalStoreFeature,\n  SignalStoreFeature,\n  type,\n  withComputed,\n} from '@ngrx/signals';\nimport { EntityProps } from '@ngrx/signals/entities';\n\nexport function withTotalEntities<Entity>(): SignalStoreFeature<\n  { state: {}, props: EntityProps<Entity>, methods: {} },\n  { state: {}, props: { total: Signal<number> }, methods: {} },\n> {\n  return signalStoreFeature(\n    { props: type<EntityProps<Entity>>() },\n    withComputed(({ entities }) => ({\n      total: computed(() => entities().length),\n    })),\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Deprecation of addAll Method in NgRx Entity\nDESCRIPTION: This snippet shows how to replace the deprecated `addAll` method of the NgRx entity adapter with the recommended `setAll`, which has an identical effect but better reflects the method's purpose.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v9.md#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Deprecated\nadapter.addAll([entity1, entity2], state);\n\n// Updated\nadapter.setAll([entity1, entity2], state);\n```\n\n----------------------------------------\n\nTITLE: Using Deprecated getMockStore for Testing (TypeScript)\nDESCRIPTION: Illustrates the usage of the `getMockStore` function from `@ngrx/store/testing`, which was deprecated in v15.4. This function was previously used to create a mock `Store` instance for testing purposes.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v15.md#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getMockStore } from '@ngrx/store/testing';\nconst mockStore = getMockStore();\n```\n\n----------------------------------------\n\nTITLE: Correct ofType Usage with Action Creators - TypeScript\nDESCRIPTION: This code snippet shows the correct way to use `ofType` in NgRx effects.  It uses the `.type` property of action creators (e.g., `userActions.ping.type`) which makes the code type-safe and allows for refactoring and renaming without breaking the code.  The dependencies are the NgRx libraries, installed as part of the project. The input is the action stream, and the output is filtered by the action creators' type. No limitations.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/prefer-action-creator-in-of-type.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\neffectOK = createEffect(() =>\n  this.actions$.pipe(ofType(userActions.ping.type))\n);\n```\n\n----------------------------------------\n\nTITLE: Using SignalState with Angular computed signals and effects\nDESCRIPTION: Shows how SignalState works with Angular's computed and effect functions. This demonstrates that SignalState possesses all the capabilities of a read-only signal.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-state.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { computed, effect } from '@angular/core';\n\n// 👇 Creating computed signals.\nconst userStateStr = computed(() => JSON.stringify(userState()));\n\n// 👇 Performing side effects.\neffect(() => console.log('userState', userState()));\n```\n\n----------------------------------------\n\nTITLE: Breaking Change: createFeature Before\nDESCRIPTION: Shows the previous implementation of `createFeature` with root state. This signature is now deprecated. The code demonstrates defining a feature with an explicit `AppState` interface.\nSOURCE: https://github.com/ngrx/platform/blob/main/CHANGELOG.md#_snippet_18\n\nLANGUAGE: TypeScript\nCODE:\n```\ninterface AppState {\n  users: State;\n}\n\nexport const usersFeature = createFeature<AppState>({\n  name: 'users',\n  reducer: createReducer(initialState /* case reducers */),\n});\n```\n\n----------------------------------------\n\nTITLE: Creating ChangeSetItems using changeSetItemFactory in TypeScript\nDESCRIPTION: Shows a more concise way to create an array of ChangeSetItem objects using the changeSetItemFactory helper function.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/save-entities.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { changeSetItemFactory as cif } from '@ngrx/data';\n...\nconst changes: ChangeSetItem[] = [\n  cif.add('Hero', hero),\n  cif.delete('Villain', [2, 3])\n];\n```\n\n----------------------------------------\n\nTITLE: Defining the ChangeSet Interface in TypeScript\nDESCRIPTION: Provides the TypeScript interface definition for ChangeSet, which represents a collection of changes (ChangeSetItems) to be applied to multiple entities. It includes properties for the changes array, optional extras, and an optional tag.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/save-entities.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface ChangeSet<T = any> {\n  /** An array of ChangeSetItems to be processed in the array order */\n  changes: ChangeSetItem[];\n\n  /**\n   * An arbitrary, serializable object that should travel with the ChangeSet.\n   * Meaningful to the ChangeSet producer and consumer. Ignored by NgRx Data.\n   */\n  extras?: T;\n\n  /** An arbitrary string, identifying the ChangeSet and perhaps its purpose */\n  tag?: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating MockStore Without TestBed Using createMockStore Function in NgRx Tests (TypeScript)\nDESCRIPTION: This snippet shows how to create a MockStore for testing without TestBed by using the createMockStore() function from '@ngrx/store/testing'. It accepts an optional initial state and returns a MockStore instance, facilitating simplified mock store setup in unit tests.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/testing.md#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { MockStore, createMockStore } from '@ngrx/store/testing';\n\ndescribe('Books Component', () => {\n  let store: MockStore;\n  const initialState = { books: ['Book 1', 'Book 2', 'Book 3'] };\n\n  beforeEach(() => {    \n    store = createMockStore({ initialState });\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Option: Integrate Entity Reducer into Reducers File\nDESCRIPTION: Allows specifying a path to a reducers file that contains the application's state interface and ActionReducerMap, enabling the schematic to import and add the generated entity reducer accordingly.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/schematics/entity.md#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\n--reducers\n-r\n```\n\n----------------------------------------\n\nTITLE: Incorrect Effect implementation without OnInitEffects interface - TypeScript\nDESCRIPTION: This example demonstrates an incorrect implementation of an effect lifecycle hook without implementing the corresponding `OnInitEffects` interface. This violates the `use-effects-lifecycle-interface` rule and can lead to potential errors or unexpected behavior. The function `ngrxOnInitEffects` is defined in the class `Effect` without implementing the `OnInitEffects` interface.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/use-effects-lifecycle-interface.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nclass Effect {\n  ngrxOnInitEffects(): Action {\n    return { type: '[Effect] Init' };\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Feature Loaded Action Changes - TypeScript (AFTER)\nDESCRIPTION: This TypeScript code snippet illustrates the change in actions dispatched when adding or removing feature reducers in NgRx v7.  It shows the difference between dispatching individual actions per feature in the 'BEFORE' state and using a single action with an array of features in the 'AFTER' state. This involves changes in the action payload structure to accommodate multiple feature updates efficiently.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v7.md#_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\n{type: '@ngrx/store/update-reducers', features: ['feat1']}\n```\n\n----------------------------------------\n\nTITLE: Installing NgRx Operators with ng add (Angular CLI)\nDESCRIPTION: This command utilizes the Angular CLI's `ng add` functionality to install the `@ngrx/operators` package. It automatically updates the `package.json` file and installs the dependency. This method simplifies the installation process by automating several steps.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/operators/install.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nng add @ngrx/operators@latest\n```\n\n----------------------------------------\n\nTITLE: Example of correct single store injection in TypeScript\nDESCRIPTION: This code snippet demonstrates the proper usage where only one Store is injected into the class. This approach ensures adherence to the rule of a single global store, promoting better store management and reducing potential issues.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/no-multiple-global-stores.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport class Component {\n  constructor(private readonly store: Store) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Using getRouterSelectors from @ngrx/router-store (V15.2+) (TypeScript)\nDESCRIPTION: Demonstrates the recommended way to obtain router state selectors in NgRx v15.2 and later, using the `getRouterSelectors` function from `@ngrx/router-store`. This function replaces the deprecated `getSelectors`.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v15.md#_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getRouterSelectors } from '@ngrx/router-store';\n\nconst routerSelectors = getRouterSelectors();\n```\n\n----------------------------------------\n\nTITLE: Configuring Plural Names - Using the Singular to Plural Map\nDESCRIPTION: This code snippet demonstrates how to use the `pluralNames` map when configuring the `EntityDataModule`. It is used to help customize HTTP requests in NgRx Data, specifically when dealing with pluralization of entity names.  The `EntityDataModule.forRoot` configuration object is used to inject the custom plural names when the application initializes.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/entity-metadata.md#_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nEntityDataModule.forRoot({\n      ...\n      pluralNames: pluralNames\n    })\n\n```\n\n----------------------------------------\n\nTITLE: Creating Play Tracking Extension with NgRx SignalStore in TypeScript\nDESCRIPTION: Defines a SignalStore feature extension, `withPlayTracking`, responsible for managing movie playback state and tracking total time spent watching each movie by ID. It uses an internal state object with properties for current movie ID, play status, start time, and accumulated tracked data. The extension exposes `play` and `stop` methods to update the state accordingly and calculate elapsed time. Dependencies include NgRx's `signalStoreFeature`, `withState` for state initialization, and `withMethods` for method injection. The extension manages immutable state updates by patching the store and provides continuous tracking across multiple play sessions.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/testing.md#_snippet_15\n\nLANGUAGE: TypeScript\nCODE:\n```\ntype PlayTrackingState = {\n  _currentId: number;\n  _status: 'playing' | 'stopped';\n  _startedAt: Date | undefined;\n  trackedData: Record<number, number>;\n};\n\nconst initialState: PlayTrackingState = {\n  _currentId: 0,\n  _status: 'stopped',\n  _startedAt: undefined,\n  trackedData: {},\n};\n\nexport const withPlayTracking = () =>\n  signalStoreFeature(\n    withState(initialState),\n    withMethods((store) => {\n      const stop = () => {\n        const startedAt = store._startedAt();\n        if (!startedAt || store._status() === 'stopped') {\n          return;\n        }\n\n        const timeSpent = new Date().getTime() - startedAt.getTime();\n        const alreadySpent = store.trackedData()[store._currentId()] ?? 0;\n        patchState(store, (state) => ({\n          _currentId: 0,\n          _status: 'stopped' as const,\n          trackedData: { ...state.trackedData, [state._currentId]: alreadySpent + timeSpent },\n        }));\n      };\n\n      return {\n        play(id: number) {\n          stop();\n          patchState(store, {\n            _currentId: id,\n            _status: 'playing',\n            _startedAt: new Date(),\n          });\n        },\n        stop,\n      };\n    })\n  );\n```\n\n----------------------------------------\n\nTITLE: Displaying a Suspense Template with *ngrxLet in Angular\nDESCRIPTION: Shows how to utilize the `suspenseTpl` input property of the `*ngrxLet` directive to specify a template (`#loading`) that should be displayed while waiting for the primary observable (`number$`) to emit its first value, error, or complete signal. This provides a way to show loading indicators.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/component/let.md#_snippet_5\n\nLANGUAGE: html\nCODE:\n```\n<ng-container *ngrxLet=\"number$ as n; suspenseTpl: loading\">\n  <app-number [number]=\"n\"></app-number>\n</ng-container>\n\n<ng-template #loading>\n  <p>Loading...</p>\n</ng-template>\n```\n\n----------------------------------------\n\nTITLE: Defining NgRx Entity State with Additional Property - TypeScript\nDESCRIPTION: Defines the TypeScript interfaces for a User entity and the application state which extends `EntityState<User>` and includes a custom property `selectedUserId`. It also initializes the NgRx entity adapter for the User type. This sets up the data structure for managing entities and custom state data together.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/entity/recipes/additional-state-properties.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { EntityState, EntityAdapter, createEntityAdapter } from '@ngrx/entity';\n\nexport interface User {\n  id: string;\n  name: string;\n}\n\nexport interface State extends EntityState<User> {\n  // additional state property\n  selectedUserId: string | null;\n}\n\nexport const adapter: EntityAdapter<User> = createEntityAdapter<User>();\n```\n\n----------------------------------------\n\nTITLE: EntityChangeTracker - Removing from ChangeState\nDESCRIPTION: Shows which `EntityOps` remove entities from the `changeState` map, effectively marking them as unchanged.  These operations typically occur after successful server responses or when loading data.  Dependencies include the NgRx Data library and entity actions.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/entity-change-tracker.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nQUERY_ALL_SUCCESS\nQUERY_BY_KEY_SUCCESS\nQUERY_LOAD_SUCCESS\nQUERY_MANY_SUCCESS\nSAVE_ADD_ONE_SUCCESS\nSAVE_ADD_MANY_SUCCESS\nSAVE_DELETE_ONE_SUCCESS\nSAVE_DELETE_MANY_SUCCESS\nSAVE_UPDATE_ONE_SUCCESS\nSAVE_UPDATE_MANY_SUCCESS\nSAVE_UPSERT_ONE_SUCCESS\nSAVE_UPSERT_MANY_SUCCESS\nCOMMIT_ONE\nCOMMIT_MANY\nUNDO_ONE\nUNDO_MANY\n```\n\n----------------------------------------\n\nTITLE: Configuring Ngrx Store Devtools (Older API)\nDESCRIPTION: Shows the deprecated methods (`instrumentStore`, `instrumentOnlyWithExtension`) formerly used to configure the `StoreDevtoolsModule` within the `imports` array of an Angular NgModule. These methods have been replaced by the `instrument` method.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v4.md#_snippet_13\n\nLANGUAGE: TypeScript\nCODE:\n```\n`app.module.ts`\n\nimport { StoreDevtoolsModule } from '@ngrx/store-devtools';\n\n@NgModule({\n  imports: [\n    StoreDevtoolsModule.instrumentStore({ maxAge: 50 }),\n    // OR\n    StoreDevtoolsModule.instrumentOnlyWithExtension({\n      maxAge: 50,\n    }),\n  ],\n})\nexport class AppModule {}\n```\n\n----------------------------------------\n\nTITLE: Updating NgRx Packages with ng update - Shell\nDESCRIPTION: This command updates NgRx packages to the latest released version using the Angular CLI. It leverages the `ng update` command to manage dependencies and apply necessary changes for the specified package, in this case, `@ngrx/store@7`.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v7.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nng update @ngrx/store@7\n```\n\n----------------------------------------\n\nTITLE: EntityAdapter upsertOne Before Change (TypeScript)\nDESCRIPTION: Demonstrates the usage of `entityAdapter.upsertOne` *before* a breaking change in the NgRx EntityAdapter API. It shows how to pass an object with `id` and `changes` properties to update an entity's state.\nSOURCE: https://github.com/ngrx/platform/blob/main/CHANGELOG.md#_snippet_47\n\nLANGUAGE: typescript\nCODE:\n```\nentityAdapter.upsertOne(\n    {\n      id: 'Entity ID',\n      changes: { id: 'Entity ID', name: 'Entity Name' },\n    },\n    state\n  );\n```\n\n----------------------------------------\n\nTITLE: Object Literal Return Type (After)\nDESCRIPTION: This code snippet demonstrates how to resolve type mismatch issues caused by object literals returned from selectors in version 8.  It adds the return type to the `projector` function. This fixes the breaking change.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v8.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport const getNews: MemoizedSelector<State, Reaction> = createSelector(\n  newsState,\n  (news): Reaction => {\n    if (news.isFake) {\n      return {\n        happy: false,\n        tweet: 'blah blah blah',\n      }\n    }\n    return {\n      happy: true,\n      tweet: 'anyway',\n    }\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: Incorrect Action Dispatching with Object or New Keyword - TypeScript\nDESCRIPTION: This code snippet demonstrates examples of incorrect usage of `dispatch` with ngrx. It illustrates how to avoid dispatching actions as objects directly. It also highlights the wrong way to create actions with the 'new' keyword. This results in potential maintainability issues and makes debugging harder.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/prefer-action-creator-in-dispatch.md#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nstore$.dispatch(new CustomAction());\n\nthis.store$.dispatch(new AuthActions.Login({ type }));\n\nthis.store$.dispatch({ type: 'custom' });\n```\n\n----------------------------------------\n\nTITLE: Registering EntityMetadataMap directly with EntityDefinitionService (TypeScript)\nDESCRIPTION: This code demonstrates how to register metadata directly with the `EntityDefinitionService` within a lazy-loaded module. This approach is necessary because the `ENTITY_METADATA_TOKEN` provider is already consumed when the lazy-loaded module is loaded.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/entity-metadata.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n@NgModule({...})\nclass LazyModule {\n  constructor(eds: EntityDefinitionService) {\n    eds.registerMetadataMap(this.lazyMetadataMap);\n  }\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Extending NgRx Data - Overriding handleSuccess Method\nDESCRIPTION: This snippet defines a custom `AdditionalPersistenceResultHandler` that extends `DefaultPersistenceResultHandler`. Its purpose is to intercept and modify the data received from the `DataService` before it's processed by the default reducer.  The `handleSuccess` method is overwritten to extract a property (e.g., `foo`) from the received data and then save it to the `action.payload`. It requires the `EntityAction` type and assumes the existence of `actionHandler` from the super class.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/entity-metadata.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nexport class AdditionalPersistenceResultHandler extends DefaultPersistenceResultHandler {\n  handleSuccess(originalAction: EntityAction): (data: any) => Action {\n    const actionHandler = super.handleSuccess(originalAction);\n    // return a factory to get a data handler to\n    // parse data from DataService and save to action.payload\n    return function(data: any) {\n      const action = actionHandler.call(this, data);\n      if (action && data && data.foo) {\n        // save the data.foo to action.payload.foo\n        (action as any).payload.foo = data.foo;\n      }\n      return action;\n    };\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering EntityMetadataMap with EntityDataModule (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to register the `EntityMetadataMap` with the NgRx Data `EntityDataModule` during initialization. The `entityMetadata` property is used to pass the metadata map, allowing NgRx Data to understand and manage the specified entity collections.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/entity-metadata.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nEntityDataModule.forRoot({\n      ...\n      entityMetadata: appEntityMetadata,\n      ...\n    })\n```\n\n----------------------------------------\n\nTITLE: Extending NgRx Data - Overwriting queryManySuccess Method\nDESCRIPTION: This snippet defines a custom `AdditionalEntityCollectionReducerMethods` class which extends `EntityCollectionReducerMethods`. It overrides `queryManySuccess` to save the `foo` property, extracted from the action payload, to the `EntityCollection` instance. It depends on having already modified the action payload to include the additional property in the prior step, or elsewhere. It relies on `EntityCollection` and `EntityAction` types. This implementation ensures that the additional property is available in the entity collection after a successful queryMany operation.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/entity-metadata.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nexport class AdditionalEntityCollectionReducerMethods<T> extends EntityCollectionReducerMethods<T> {\n  constructor(public entityName: string, public definition: EntityDefinition<T>) {\n    super(entityName, definition);\n  }\n   protected queryManySuccess(\n    collection: EntityCollection<T>,\n    action: EntityAction<T[]>\n  ): EntityCollection<T> {\n    const ec = super.queryManySuccess(collection, action);\n    if ((action.payload as any).foo) {\n      // save the foo property from action.payload to entityCollection instance\n      (ec as any).foo = (action.payload as any).foo;\n    }\n    return ec;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Updating NgRx Store Packages Using Angular CLI - Shell\nDESCRIPTION: This shell snippet provides the command necessary to trigger an automatic upgrade of @ngrx/store to version 19 via the Angular CLI. It includes built-in migration schematics for a smoother upgrade process. The expected input is a shell environment with the Angular CLI installed, and the output is an in-place update of the project's dependencies and code modifications as appropriate.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v19.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nng update @ngrx/store@19\n```\n\n----------------------------------------\n\nTITLE: Using *ngrxLet with Renamed Context Variables in V15 (HTML)\nDESCRIPTION: Illustrates the updated usage of the `*ngrxLet` directive in NgRx v15 and later. The `$` prefix has been removed from the context variable names within the template, so `$error` becomes `error` and `$complete` becomes `complete`.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v15.md#_snippet_9\n\nLANGUAGE: html\nCODE:\n```\n<ng-container *ngrxLet=\"obs$; error as e; complete as c\">\n  ...\n</ng-container>\n```\n\n----------------------------------------\n\nTITLE: Overwriting Entities with addAll (Before @ngrx/entity v11)\nDESCRIPTION: Illustrates the usage of the `adapter.addAll` method from `@ngrx/entity` prior to version 11. This method was used to replace all entities in the collection but was renamed in v11 for clarity.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v11.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nadapter.addAll(action.entities, state);\n```\n\n----------------------------------------\n\nTITLE: Incorrect Implementation: Dispatching Multiple Actions Sequentially in NgRx\nDESCRIPTION: This example shows an antipattern where multiple actions are dispatched sequentially in a component's ngOnInit method, which the linting rule warns against.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/avoid-dispatching-multiple-actions-sequentially.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport class Component implement OnInit {\n  constructor(\n    private readonly store: Store,\n  ) {}\n\n  ngOnInit() {\n    // ⚠ multiple actions dispatched\n    this.store.dispatch(loadEmployeeList());\n    this.store.dispatch(loadCompanyList());\n    this.store.dispatch(cleanData());\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Store DevtoolsModule Configuration (Before)\nDESCRIPTION: This code snippet shows the configuration of `StoreDevtoolsModule` before the renaming of `actionsWhitelist` to `actionsSafelist` and `actionsBlacklist` to `actionsBlocklist`. This will produce an error when using version 8.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v8.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nStoreDevtoolsModule.instrument({\n  actionsWhitelist: ['...'],\n})\n```\n\n----------------------------------------\n\nTITLE: Creating signalMethod in Ancestor Injection Context Causing Potential Memory Leaks in Angular TypeScript\nDESCRIPTION: Shows a scenario where signalMethod is created in a service provider at root level and invoked within a component. Because the effect’s injection context is the root service, the side effect outlives the component, potentially causing memory leaks. Inputs include Signals managed via Angular dependency injection, emphasizing the need for explicit cleanup.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-method.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\n@Injectable({ providedIn: 'root' })\nexport class NumbersService {\n  readonly logDoubledNumber = signalMethod<number>((num) => {\n    const double = num * 2;\n    console.log(double);\n  });\n}\n\n@Component({ /* ... */ })\nexport class NumbersComponent implements OnInit {\n  readonly numbersService = inject(NumbersService);\n\n  ngOnInit(): void {\n    const value = signal(2);\n    // 👇 Uses the injection context of the `NumbersService`, which is root.\n    this.numbersService.logDoubledNumber(value);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Deprecated getSelectors from @ngrx/router-store (TypeScript)\nDESCRIPTION: Shows the usage of the `getSelectors` function from `@ngrx/router-store`, which was deprecated in v15.2. This function provided a set of selectors for accessing router state information managed by NgRx.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v15.md#_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getSelectors } from '@ngrx/router-store';\n\nconst routerSelectors = getSelectors();\n```\n\n----------------------------------------\n\nTITLE: Extending DefaultDataService for Custom EntityDataService in NgRx Data (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates a custom implementation of EntityCollectionDataService for the Hero entity, extending NgRx Data's DefaultDataService. It customizes entity fetching by overriding getAll, getById, and getWithQuery methods to attach a dateLoaded timestamp to each entity. Dependencies include Angular's HttpClient, HttpUrlGenerator, and a Logger, all injected via the constructor. The data service is injectable and intended to be registered with the EntityDataService registry. The service expects Hero entities as input and output, ensuring they are augmented with the dateLoaded property. The main limitation is that it only modifies load operations without customizing save/update behaviors.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/entity-dataservice.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport {\n  EntityCollectionDataService,\n  DefaultDataService,\n  HttpUrlGenerator,\n  Logger,\n  QueryParams\n} from '@ngrx/data';\n\nimport { Observable } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport { Hero } from '../../core';\n\n@Injectable()\nexport class HeroDataService extends DefaultDataService<Hero> {\n  constructor(http: HttpClient, httpUrlGenerator: HttpUrlGenerator, logger: Logger) {\n    super('Hero', http, httpUrlGenerator);\n    logger.log('Created custom Hero EntityDataService');\n  }\n\n  getAll(): Observable<Hero[]> {\n    return super.getAll().pipe(map(heroes => heroes.map(hero => this.mapHero(hero))));\n  }\n\n  getById(id: string | number): Observable<Hero> {\n    return super.getById(id).pipe(map(hero => this.mapHero(hero)));\n  }\n\n  getWithQuery(params: string | QueryParams): Observable<Hero[]> {\n    return super.getWithQuery(params).pipe(map(heroes => heroes.map(hero => this.mapHero(hero))));\n  }\n\n  private mapHero(hero: Hero): Hero {\n    return { ...hero, dateLoaded: new Date() };\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing NgRx ComponentStore with OnStateInit Lifecycle Hook in TypeScript (Lazy Initialization)\nDESCRIPTION: This code shows a BooksStore class implementing OnStateInit without initializing the state in the constructor. Instead, the state is set explicitly in the component's ngOnInit method, demonstrating lazy initialization where state setup occurs after component creation. The method ngrxOnStateInit runs once after the state is first set.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/component-store/lifecycle.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface BooksState {\n  collection: Book[];\n}\n\n@Injectable()\nexport class BooksStore extends ComponentStore<BooksState> implements OnStateInit {\n  constructor() {\n    super();\n  }\n\n  ngrxOnStateInit() {\n    // called once after state has been first initialized\n  }\n}\n\nexport const initialState: BooksState = {\n  collection: []\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring Runtime Checks in NgRx\nDESCRIPTION: This snippet demonstrates how to configure the runtime checks within the `StoreModule.forRoot` configuration in an Angular application. It shows how to enable or disable specific checks using a `runtimeChecks` property and its nested boolean configurations for each check. These settings override default behavior.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/configuration/runtime-checks.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\n@NgModule({\n  imports: [\n    StoreModule.forRoot(reducers, {\n      runtimeChecks: {\n        strictStateImmutability: true,\n        strictActionImmutability: true,\n        strictStateSerializability: true,\n        strictActionSerializability: true,\n        strictActionWithinNgZone: true,\n        strictActionTypeUniqueness: true,\n      },\n    }),\n  ],\n})\nexport class AppModule {}\n```\n```\n\n----------------------------------------\n\nTITLE: Comparing signalMethod with effect in Angular TypeScript\nDESCRIPTION: Provides an example comparing signalMethod and Angular's effect function. The example illustrates that while effect tracks reactive signal changes implicitly, signalMethod allows explicit input handling with flexible input types (static or Signal) and decouples processor invocation from injection context. This snippet highlights signalMethod's advantages including multi-source invocation and selective tracking.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-method.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\n@Component({ /* ... */ })\nexport class NumbersComponent {\n  readonly num = signal(2);\n  readonly logDoubledNumberEffect = effect(() => {\n    console.log(this.num() * 2);\n  });\n  readonly logDoubledNumber = signalMethod<number>((num) => {\n    console.log(num * 2);\n  });\n\n  constructor() {\n    this.logDoubledNumber(this.num);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating custom state updaters in TypeScript\nDESCRIPTION: Shows how to create reusable custom state updaters that can be tested and shared across the application, enhancing code maintainability and reusability.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-state.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { PartialStateUpdater } from '@ngrx/signals';\n\nfunction setFirstName(firstName: string): PartialStateUpdater<{ user: User }> {\n  return (state) => ({ user: { ...state.user, firstName } });\n}\n\nconst setAdmin = () => ({ isAdmin: true });\n```\n\n----------------------------------------\n\nTITLE: Configuring NgRx Router Store with Minimal Router State Serializer in TypeScript\nDESCRIPTION: Shows how to configure the NgRx Router Store to use the MinimalRouterStateSerializer by setting the routerState property to RouterState.Minimal. This serializer produces fully serializable router state by omitting non-serializable properties like paramMap and component, which is compatible with serializability runtime checks.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/router-store/configuration.md#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nprovideRouterStore({\n  routerState: RouterState.Minimal,\n});\n```\n\n----------------------------------------\n\nTITLE: Native Mocking of MoviesStore\nDESCRIPTION: This test demonstrates native mocking of the `MoviesStore` to verify the behavior of the `MoviesComponent`. It mocks the `movies`, `loading`, and `load` methods. The test sets up the testing module, creates the component, simulates user input, and asserts that the component displays movies correctly. Requires imports for component and related dependencies from @angular/core/testing and @angular/core.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/testing.md#_snippet_12\n\nLANGUAGE: TypeScript\nCODE:\n```\nit('should show movies (native Jest)', () => {\n  const load = jest.fn<void, [Signal<string>]>();\n\n  const moviesStore = {\n    movies: signal(new Array<Movie>()),\n    loading: signal(false),\n    load,\n  };\n\n  TestBed.configureTestingModule({\n    imports: [MoviesComponent],\n    providers: [\n      {\n        provide: MoviesStore,\n        useValue: moviesStore,\n      },\n    ],\n  });\n\n  const fixture = TestBed.createComponent(MoviesComponent);\n  fixture.autoDetectChanges(true);\n\n  const studio = load.mock.calls[0][0];\n  const input: HTMLInputElement = fixture.debugElement.query(By.css('input')).nativeElement;\n\n  expect(studio()).toBe('');\n\n  input.value = 'Warner Bros';\n  input.dispatchEvent(new Event('input'));\n  expect(studio()).toBe('Warner Bros');\n\n  moviesStore.movies.set([\n    { id: 1, name: 'Harry Potter' },\n    { id: 2, name: 'The Dark Knight' },\n  ]);\n  fixture.detectChanges();\n\n  const movieNames = fixture.debugElement.queryAll(By.css('p')).map((el) =>\n    el.nativeElement.textContent\n  );\n  expect(movieNames).toEqual(['1: Harry Potter', '2: The Dark Knight']);\n});\n```\n\n----------------------------------------\n\nTITLE: Calling signalMethod Processor with Static Values and Signals in Angular TypeScript\nDESCRIPTION: Demonstrates invoking a signalMethod processor with both static values and reactive Signals. Highlights how signalMethod processes dynamic values, logging doubled numbers synchronously and reacting to Signal updates asynchronously. Inputs include static number values and Signals of type number, with side effects logged to the console.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-method.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\n@Component({ /* ... */ })\nexport class NumbersComponent {\n  readonly logDoubledNumber = signalMethod<number>((num) => {\n    const double = num * 2;\n    console.log(double);\n  });\n\n  constructor() {\n    this.logDoubledNumber(1);\n    // console output: 2\n\n    const num = signal(2);\n    this.logDoubledNumber(num);\n    // console output: 4\n    \n    setTimeout(() => num.set(3), 3_000);\n    // console output after 3 seconds: 6\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Specific NgRx Package Configuration with ESLint v8\nDESCRIPTION: Configures ESLint to use only the rules relevant to NgRx Signals by extending the signals-specific configuration.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/index.md#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"extends\": [\"@ngrx/signals\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating Angular CLI Spec Option to SkipTest in Shell\nDESCRIPTION: This snippet illustrates the schematic option change from '--spec' to '--skipTest' for Angular CLI commands generating actions. It highlights a breaking change aligning NgRx schematics with Angular CLI defaults, where skipTest defaults to false, ensuring spec files are created by default. The before and after code blocks show the command invocation difference, which impacts the generation of unit test files for NgRx actions.\nSOURCE: https://github.com/ngrx/platform/blob/main/CHANGELOG.md#_snippet_38\n\nLANGUAGE: Shell\nCODE:\n```\nng generate action User --spec\n```\n\nLANGUAGE: Shell\nCODE:\n```\nng generate action User\n```\n\n----------------------------------------\n\nTITLE: Generating a Container Component with Updated skipTests Option Using Bash\nDESCRIPTION: This Bash snippet shows the updated Angular CLI command for generating a UsersPage container component with the new --skipTests option. This option replaces the removed --skipTest flag in NgRx version 10 schematics to control skipping the generation of test files.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v10.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nng generate container UsersPage --skipTests\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of store.dispatch in NgRx Effects\nDESCRIPTION: An example of an incorrect implementation where an effect directly dispatches an action inside a tap operator. This approach can lead to difficult-to-debug issues and is considered a bad practice in NgRx.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/no-dispatch-in-effects.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport class Effects {\n  loadData$ = createEffect(() =>\n    this.actions$.pipe(\n      ofType(loadData),\n      exhaustMap(() =>\n        this.dataService.getData().pipe(\n          tap((response) => {\n            // ⚠ dispatching another action from an effect\n            if (response.condition) {\n              this.store.dispatch(anotherAction());\n            }\n          }),\n          map((response) => loadDataSuccess(response)),\n          catchError((error) => of(loadDataError(error)))\n        )\n      )\n    )\n  );\n\n  constructor(\n    private readonly actions$: Actions,\n    private readonly store: Store\n  ) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Typing with Null/Undefined in LetDirective Before Update\nDESCRIPTION: Before the update, when `null` or `undefined` were passed to `LetDirective`, the type of the context variable (`n` or `u`) was `any`. This lacked specific type information for null and undefined values.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v14.md#_snippet_3\n\nLANGUAGE: html\nCODE:\n```\n<p *ngrxLet=\"null as n\">{{ n }}</p>\n<p *ngrxLet=\"undefined as u\">{{ u }}</p>\n```\n\n----------------------------------------\n\nTITLE: Replacing ReactiveComponentModule with LetModule\nDESCRIPTION: This code shows how to replace ReactiveComponentModule with LetModule, if the component uses the `ngrxLet` directive.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v14.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { LetModule } from '@ngrx/component';\n\n@NgModule({\n  imports: [\n    // ... other imports\n    LetModule,\n  ],\n})\nexport class MyFeatureModule {}\n```\n\n----------------------------------------\n\nTITLE: Defining NgRx Actions with Stricter Props (v11+)\nDESCRIPTION: Shows the required method for defining NgRx actions in v11 using `createAction` with `props<Record<string, unknown>>()`. This enforces stricter type checking by disallowing primitive types when an object structure is expected, improving type safety.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v11.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst customerPageLoaded = createAction(\n  '[Customer Page] Loaded',\n  props<Record<string, unknown>>(),\n);\n```\n\n----------------------------------------\n\nTITLE: Incorrect Store Subscription - TypeScript\nDESCRIPTION: This code snippet demonstrates an incorrect usage pattern where a store subscription is created within the `ngOnInit` lifecycle hook. This approach can lead to memory leaks and makes the component less testable. The subscription is directly assigning the result of `this.store.select(selectedItems)` to `this.items`.  This pattern is discouraged.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/no-store-subscription.md#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nngOnInit() {\n  this.store.select(selectedItems).subscribe(items => {\n    this.items = items;\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Using LetDirective with Null/Undefined Input - HTML\nDESCRIPTION: Illustrates the usage of the NgRx `LetDirective` when providing `null` or `undefined` as input. In version 14.0.0-beta.0, the directive's context variable now correctly infers the `null` or `undefined` type, instead of defaulting to `any`. Requires `@ngrx/component` module.\nSOURCE: https://github.com/ngrx/platform/blob/main/CHANGELOG.md#_snippet_28\n\nLANGUAGE: html\nCODE:\n```\n<p *ngrxLet=\"null as n\">{{ n }}</p>\n<p *ngrxLet=\"undefined as u\">{{ u }}</p>\n```\n\n----------------------------------------\n\nTITLE: Updating NgRx Store Reducer Registration in TypeScript\nDESCRIPTION: Shows the updated method for registering reducers and initial state. Instead of passing a single combined reducer function and initial state object to `provideStore`, a map of reducers is passed to `forRoot`, with initial state in a configuration object.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v4.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst reducers = {\n  auth: fromAuth.reducer,\n  layout: fromLayout.reducer,\n};\n\nconst rootReducer = combineReducers(reducers);\n\nexport function reducer(state: any, action: any) {\n  return rootReducer(state, action);\n}\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { StoreModule } from '@ngrx/store';\nimport { reducer } from './reducers';\n\n@NgModule({\n  imports: [\n    StoreModule.provideStore(reducer, {\n      auth: {\n        loggedIn: true,\n      },\n    }),\n  ],\n})\nexport class AppModule {}\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { ActionReducerMap } from '@ngrx/store';\n\nexport interface State {\n  auth: fromAuth.State;\n  layout: fromLayout.State;\n}\n\nexport const reducers: ActionReducerMap<State> = {\n  auth: fromAuth.reducer,\n  layout: fromLayout.reducer,\n};\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { StoreModule } from '@ngrx/store';\nimport { reducers } from './reducers';\n\n@NgModule({\n  imports: [\n    StoreModule.forRoot(reducers, {\n      initialState: {\n        auth: {\n          loggedIn: true,\n        },\n      },\n    }),\n  ],\n})\nexport class AppModule {}\n```\n\n----------------------------------------\n\nTITLE: Installing NgRx Schematics Nightly Build Shell\nDESCRIPTION: These commands install the latest nightly build of the NgRx Schematics package from the official NgRx GitHub builds repository. Use either npm or yarn with the appropriate flag (--save-dev or --dev) to add the unreleased schematics to your development dependencies.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/nightlies.md#_snippet_8\n\nLANGUAGE: Shell\nCODE:\n```\nnpm install github:ngrx/schematics-builds --save-dev\n```\n\nLANGUAGE: Shell\nCODE:\n```\nyarn add github:ngrx/schematics-builds --dev\n```\n\n----------------------------------------\n\nTITLE: Defining ComponentStore Selectors with Improper External Mapping - NgRx ComponentStore - TypeScript\nDESCRIPTION: This snippet demonstrates a misuse of the NgRx ComponentStore by applying additional mapping logic (using RxJS 'map') outside the selector level. The 'name$' observable is created by selecting 'loggedInUser' from the state, then further mapping to extract 'user.name' in a subsequent pipe. This violates best practices by separating transformation logic from the selector definition. The code requires NgRx ComponentStore and RxJS as dependencies, expects a type argument 'UserState', and will be flagged by the rule.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/avoid-mapping-component-store-selectors.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport class UserStore extends ComponentStore<UserState> {\n  loggedInUser$ = this.select((state) => state.loggedInUser);\n  //                                           ⚠ Avoid mapping logic outside the selector level.\n  name$ = this.select((state) => state.loggedInUser).pipe(\n    map((user) => user.name)\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Fix for Immutability Violation in Action\nDESCRIPTION: This snippet shows the corrected implementation to fix the action immutability violation. The `todo.id` is set in the action creator or in an immutable way. Then the `todo` object is appended to the current `todos` using the spread operator and array concatenation.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/configuration/runtime-checks.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nexport const addTodo = createAction(\n  '[Todo List] Add Todo',\n  (description: string) => ({ id: generateUniqueId(), description })\n);\nexport const reducer = createReducer(\n  initialState,\n  on(addTodo, (state, { todo }) => ({\n    ...state,\n    todos: [...state.todos, todo],\n  }))\n);\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Selector (After v13 Variadic Tuples) - TypeScript\nDESCRIPTION: Example of the updated syntax for `createSelector` in v13. Input selectors are now represented by a variadic tuple type (e.g., `[Customer, Order[]]`), removing the previous limit on the number of input selectors. A migration schematic is provided.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v13.md#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\n//                  needs to be a tuple 👇\nconst selector =  createSelector<State, [Customer, Order[]], CustomerWithOrder>\n```\n\n----------------------------------------\n\nTITLE: Defining NgRx Feature with createFeature in TypeScript\nDESCRIPTION: Illustrates the basic usage of `createFeature` to define an NgRx feature named 'books'. It combines the feature name with a reducer created using `createReducer` and `on` handlers for specific actions. The resulting `booksFeature` object contains the name, reducer, feature selector, and selectors for state properties, which are then destructured.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/feature-creators.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createFeature, createReducer, on } from '@ngrx/store';\nimport { Book } from './book.model';\n\nimport * as BookListPageActions from './book-list-page.actions';\nimport * as BooksApiActions from './books-api.actions';\n\ninterface State {\n  books: Book[];\n  loading: boolean;\n}\n\nconst initialState: State = {\n  books: [],\n  loading: false,\n};\n\nexport const booksFeature = createFeature({\n  name: 'books',\n  reducer: createReducer(\n    initialState,\n    on(BookListPageActions.enter, (state) => ({\n      ...state,\n      loading: true,\n    })),\n    on(BooksApiActions.loadBooksSuccess, (state, { books }) => ({\n      ...state,\n      books,\n      loading: false,\n    }))\n  ),\n});\n\nexport const {\n  name, // feature name\n  reducer, // feature reducer\n  selectBooksState, // feature selector\n  selectBooks, // selector for `books` property\n  selectLoading, // selector for `loading` property\n} = booksFeature;\n```\n\n----------------------------------------\n\nTITLE: Installing NgRx Data with npm in Shell\nDESCRIPTION: Uses npm to add the @ngrx/data package directly to your project dependencies. After running this command, you must manually import and configure the package in your Angular modules if not using ng add. Requires Node.js and npm to be installed in your environment. No project configuration is automated using this method.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/install.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nnpm install @ngrx/data --save\n```\n\n----------------------------------------\n\nTITLE: Configuring the Preferred Global Store Name in NgRx Lint Rules (JSON)\nDESCRIPTION: This JSON snippet demonstrates how to configure the lint rule to change the preferred global store variable name from the default (store) to store$. This configuration should be added to your project's linting configuration file. The rule flag can be set to 'warn' or another supported level, and the second array element specifies the variable name.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/use-consistent-global-store-name.md#_snippet_2\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"rules\": {\n    \"@ngrx/use-consistent-global-store-name\": [\"warn\", \"store$\"]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Actions with Props for NgRx Effects (TypeScript)\nDESCRIPTION: Example of creating an action with additional metadata using the props method to pass data to an effect.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/effects/index.md#_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { createAction, props } from '@ngrx/store';\nimport { Credentials } from '../models/user';\n\nexport const login = createAction(\n  '[Login Page] Login',\n  props<{ credentials: Credentials }>()\n);\n```\n\n----------------------------------------\n\nTITLE: Combining multiple observables using ngrxPush\nDESCRIPTION: This code snippet illustrates the use of the `ngrxPush` pipe with a dictionary of observables in a HTML template. This allows for accessing and rendering values from multiple observables within a single binding. This is useful for handling data from several sources in an optimized manner.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/component/push.md#_snippet_3\n\nLANGUAGE: html\nCODE:\n```\n<code>\n  {{ { users: users$, query: query$ } | ngrxPush | json }}\n</code>\n```\n\n----------------------------------------\n\nTITLE: Finalizing AppModule Configuration (TypeScript)\nDESCRIPTION: Presents the final version of `app.module.ts`, including imports for `HttpClientModule`, declarations for `AppComponent`, `BookListComponent`, and `BookCollectionComponent`, and the previously configured `StoreModule.forRoot` setup.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/walkthrough.md#_snippet_13\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Code from src/app/app.module.ts (Final)\n// Complete AppModule setup including component declarations and StoreModule.\n```\n\n----------------------------------------\n\nTITLE: Updating Component Style Option from styleext to style in TypeScript Configuration\nDESCRIPTION: This example details the schematic configuration change replacing the deprecated 'styleext' option with 'style' to specify stylesheet format for Angular components. It's a breaking change designed to align NgRx schematics with Angular CLI standards. The before and after JSON configuration demonstrates updating the property name without changing its function, which influences the CSS preprocessor used during component generation.\nSOURCE: https://github.com/ngrx/platform/blob/main/CHANGELOG.md#_snippet_40\n\nLANGUAGE: TypeScript\nCODE:\n```\n\"@schematics/angular:component\": {\n      \"inlineStyle\": true,\n      \"prefix\": \"aio\",\n      \"styleext\": \"scss\"\n    }\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\n\"@schematics/angular:component\": {\n      \"inlineStyle\": true,\n      \"prefix\": \"aio\",\n      \"style\": \"scss\"\n    }\n```\n\n----------------------------------------\n\nTITLE: Destroying rxMethod Subscriptions (After Rename)\nDESCRIPTION: Shows the updated method `destroy` for cleaning up individual (`num1Ref.destroy()`) or all (`logNumber.destroy()`) subscriptions managed by `rxMethod`. This was introduced as a breaking change in NgRx Signals 19.0.0-beta.0, replacing the former `unsubscribe` method.\nSOURCE: https://github.com/ngrx/platform/blob/main/CHANGELOG.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst logNumber = rxMethod<number>(tap(console.log));\n\nconst num1Ref = logNumber(interval(1_000));\nconst num2Ref = logNumber(interval(2_000));\n\n// destroy `num1Ref` after 2 seconds\nsetTimeout(() => num1Ref.destroy(), 2_000);\n\n// destroy all reactive method refs after 5 seconds\nsetTimeout(() => logNumber.destroy(), 5_000);\n```\n\n----------------------------------------\n\nTITLE: Installing NgRx ComponentStore Nightly Build Shell\nDESCRIPTION: These commands install the latest nightly build of the NgRx ComponentStore package directly from the official NgRx GitHub builds repository. Use either npm or yarn to add the unreleased version of the package to your project dependencies.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/nightlies.md#_snippet_7\n\nLANGUAGE: Shell\nCODE:\n```\nnpm install github:ngrx/component-store-builds\n```\n\nLANGUAGE: Shell\nCODE:\n```\nyarn add github:ngrx/component-store-builds\n```\n\n----------------------------------------\n\nTITLE: Incorrect NgRx Effect Callback without Block Statement - TypeScript\nDESCRIPTION: This code snippet shows an incorrect implementation where the callback function provided to `createEffect` does not utilize a block statement.  This makes it harder to troubleshoot potential issues, like missing RxJS imports.  The `ofType` and `concatMap` operators are used here. This snippet serves as an example of code that the rule is designed to flag.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/prefer-effect-callback-in-block-statement.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nclass Effect {\n  effectNOK = createEffect(() =>\n    this.actions.pipe(\n      ofType(detailsLoaded),\n      concatMap(() => ...),\n    )\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Using NgRx `select` Operator with RxJS `filter` (TypeScript)\nDESCRIPTION: Shows an alternative approach using the NgRx `select` pipeable operator combined with the RxJS `filter` operator. This achieves the same outcome as using `map` and `filter`: selecting a state slice (`selectValues`) and filtering out `undefined` values.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/selectors.md#_snippet_14\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { select } from '@ngrx/store';\nimport { map, filter } from 'rxjs/operators';\n\nstore\n  .pipe(\n    select(selectValues),\n    filter(val => val !== undefined)\n  )\n  .subscribe(/* .. */);\n```\n\n----------------------------------------\n\nTITLE: Defining Selector (Before v13 Variadic Tuples) - TypeScript\nDESCRIPTION: Example of the previous syntax for `createSelector` where generic type arguments directly mapped to individual input selectors. This syntax was limited to a maximum of 8 input selectors before the v13 update.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v13.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nconst selector = createSelector<State, Customer, Order[], CustomerWithOrder>\n```\n\n----------------------------------------\n\nTITLE: EntityChangeTracker - ChangeState Interface\nDESCRIPTION: Defines the `ChangeState` interface, which is used by the NgRx Data change tracking to record changes to entities.  It indicates the type of change, and holds the original value prior to the change. This is essential for the `undo` functionality.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/entity-change-tracker.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface ChangeState&lt;T&gt; {\n  changeType: ChangeType;\n  originalValue: T | undefined;\n}\n\nexport enum ChangeType {\n  Unchanged, // the entity has not been changed.\n  Added,     // the entity was added to the collection\n  Updated,   // the entity in the collection was updated\n  Deleted,   // the entity is scheduled for delete and was removed from collection.\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring NgRx Select-Style Lint Rule in JSON\nDESCRIPTION: Provides JSON configuration examples for the `@ngrx/select-style` lint rule, allowing developers to enforce either the method or operator style of selector usage. It includes the default setting (method) and how to override it to prefer operator syntax instead.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/select-style.md#_snippet_2\n\nLANGUAGE: JSON\nCODE:\n```\n\"rules\": {\n  \"@ngrx/select-style\": [\"warn\", \"method\"]\n}\n```\n\nLANGUAGE: JSON\nCODE:\n```\n\"rules\": {\n  \"@ngrx/select-style\": [\"warn\", \"operator\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Example of creating and releasing memoized selectors for sum calculations\nDESCRIPTION: Defines selectors for summing even and odd numbers, combined into a total, with the ability to release memoized values to free memory. Demonstrates memoization lifecycle management.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/selectors.md#_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface State {\n  evenNums: number[];\n  oddNums: number[];\n}\n\nexport const selectSumEvenNums = createSelector(\n  (state: State) => state.evenNums,\n  evenNums => evenNums.reduce((prev, curr) => prev + curr)\n);\nexport const selectSumOddNums = createSelector(\n  (state: State) => state.oddNums,\n  oddNums => oddNums.reduce((prev, curr) => prev + curr)\n);\nexport const selectTotal = createSelector(\n  selectSumEvenNums,\n  selectSumOddNums,\n  (evenSum, oddSum) => evenSum + oddSum\n);\n\nselectTotal({\n  evenNums: [2, 4],\n  oddNums: [1, 3],\n});\n\n// Memoized values before release:\n// selectSumEvenNums  6\n// selectSumOddNums   4\n// selectTotal        10\n\nselectTotal.release();\n\n// Memoized values after release:\n// selectSumEvenNums  null\n// selectSumOddNums   null\n// selectTotal        null\n```\n\n----------------------------------------\n\nTITLE: Installing @ngrx/entity with Angular CLI using ng add\nDESCRIPTION: Automates the process of adding @ngrx/entity as a dependency in an Angular project via the Angular CLI. It updates package.json and installs dependencies automatically, streamlining setup. Dependencies include @ngrx/entity.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/entity/install.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nng add @ngrx/entity@latest\n```\n\n----------------------------------------\n\nTITLE: Dispatching Custom Ngrx Router Navigation Actions\nDESCRIPTION: Shows how to dispatch the newly defined custom router navigation actions (`Go`, `Back`, `Forward`) using the Ngrx store. The `Go` action includes a payload specifying the target path, query parameters, and navigation extras.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v4.md#_snippet_11\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as RouterActions from './actions/router';\n\nstore.dispatch(new RouterActions.Go({\n  path: ['/path', { routeParam: 1 }],\n  query: { page: 1 },\n  extras: { replaceUrl: false }\n});\n\nstore.dispatch(new RouterActions.Back());\n\nstore.dispatch(new RouterActions.Forward());\n```\n\n----------------------------------------\n\nTITLE: *ngrxLet Suspense Behavior Before V15 (TypeScript)\nDESCRIPTION: Provides an Angular component example demonstrating the behavior of `*ngrxLet` before v15 when handling observable replacement leading to a suspense state. When the button is clicked and `obs$` is replaced with a delayed observable, the existing view (`<p>`) is not immediately removed; instead, the template variable `o` becomes `undefined` until the new observable emits.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v15.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n@Component({\n  template: `\n    <!-- When button is clicked, the 'LetDirective' view won't be cleared. -->\n    <!-- Instead, the value of 'o' will be 'undefined' until the replaced --> \n    <!-- observable emits the first value (after 1 second). -->\n    <p *ngrxLet=\"obs$ as o\">{{ o }}</p>\n    <button (click)=\"replaceObs()\">Replace Observable</button>\n  `\n})\nexport class TestComponent {\n  obs$ = of(1);\n  \n  replaceObs(): void {\n    this.obs$ = of(2).pipe(delay(1000));\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing NgRx Effects Nightly Build Shell\nDESCRIPTION: These commands install the latest nightly build of the NgRx Effects package directly from the official NgRx GitHub builds repository. Use either npm or yarn to add the unreleased version of the package to your project dependencies.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/nightlies.md#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\nnpm install github:ngrx/effects-builds\n```\n\nLANGUAGE: Shell\nCODE:\n```\nyarn add github:ngrx/effects-builds\n```\n\n----------------------------------------\n\nTITLE: Incorrect ofType Usage with String Literals - TypeScript\nDESCRIPTION: This code snippet demonstrates incorrect usage of the `ofType` operator in NgRx effects. It uses string literals ('PING', 'PONG', BookActions.load) directly within the `ofType` call, which makes the code less type-safe and can lead to errors if the string literals are misspelled. No dependencies other than NgRx (installed as part of the project). The input is the action stream, and the output is filtered based on the string literals. No limitations.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/prefer-action-creator-in-of-type.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\neffectNOK = createEffect(() => this.actions$.pipe(ofType('PING')));\n\neffectNOK1 = createEffect(() =>\n  this.actions$.pipe(ofType(BookActions.load, 'PONG'))\n);\n```\n\n----------------------------------------\n\nTITLE: Resetting memoized selectors to release cached data\nDESCRIPTION: Shows how to explicitly reset a selector's memoized value to null using 'release', allowing memory cleanup and avoiding stale cached data; applies recursively to ancestor selectors.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/selectors.md#_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nselectTotal.release();\n```\n\n----------------------------------------\n\nTITLE: Updating NgRx Packages via Angular CLI - Shell\nDESCRIPTION: Use this command with the Angular CLI's `ng update` tool to upgrade NgRx packages to version 13. This process includes running migration schematics to automate common breaking changes. Requires Angular CLI version 13.x.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v13.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nng update @ngrx/store@13\n```\n\n----------------------------------------\n\nTITLE: Selecting Data from NgRx Store Using Method Syntax in TypeScript\nDESCRIPTION: Shows the preferred method syntax for selecting data from the NgRx store as recommended by the lint rule, promoting less code and no need to import the selector operator. It ensures consistent usage by applying `store.select` for all selections within the component.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/select-style.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport class Component {\n  someData$ = this.store.select(someData);\n  otherData$ = this.store.select(otherData);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining NgRx Actions for Entity Operations in TypeScript\nDESCRIPTION: Defines a set of NgRx actions using `createAction` and `props` from `@ngrx/store` for various entity manipulation operations (Load, Set, Add, Update, Delete, etc.). These actions are typically dispatched from components or effects to signal intents to modify the entity state. Imports necessary types like `Update`, `EntityMap`, `Predicate` from `@ngrx/entity` and the `User` model.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/entity/adapter.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { createAction, props } from '@ngrx/store';\nimport { Update, EntityMap, EntityMapOne, Predicate } from '@ngrx/entity';\n\nimport { User } from '../models/user.model';\n\nexport const loadUsers = createAction('[User/API] Load Users', props<{ users: User[] }>());\nexport const setUsers = createAction('[User/API] Set Users', props<{ users: User[] }>());\nexport const addUser = createAction('[User/API] Add User', props<{ user: User }>());\nexport const setUser = createAction('[User/API] Set User', props<{ user: User }>());\nexport const upsertUser = createAction('[User/API] Upsert User', props<{ user: User }>());\nexport const addUsers = createAction('[User/API] Add Users', props<{ users: User[] }>());\nexport const upsertUsers = createAction('[User/API] Upsert Users', props<{ users: User[] }>());\nexport const updateUser = createAction('[User/API] Update User', props<{ update: Update<User> }>());\nexport const updateUsers = createAction('[User/API] Update Users', props<{ updates: Update<User>[] }>());\nexport const mapUser = createAction('[User/API] Map User', props<{ entityMap: EntityMapOne<User> }>());\nexport const mapUsers = createAction('[User/API] Map Users', props<{ entityMap: EntityMap<User> }>());\nexport const deleteUser = createAction('[User/API] Delete User', props<{ id: string }>());\nexport const deleteUsers = createAction('[User/API] Delete Users', props<{ ids: string[] }>());\nexport const deleteUsersByPredicate = createAction('[User/API] Delete Users By Predicate', props<{ predicate: Predicate<User> }>());\nexport const clearUsers = createAction('[User/API] Clear Users');\n```\n\n----------------------------------------\n\nTITLE: Correct: Dispatching a Different Action in NgRx Effect\nDESCRIPTION: This TypeScript snippet demonstrates a correct NgRx Effect. It listens for the `fromCustomers.pageLoaded` action but dispatches a different action, `fromCustomers.pageLoadedSuccess()`, using `map`. This avoids the cyclic dependency and potential infinite loop.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/avoid-cyclic-effects.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nclass Effect {\n  details$ = createEffect(() =>\n    this.actions$.pipe(\n      ofType(fromCustomers.pageLoaded),\n      map(() => fromCustomers.pageLoadedSuccess()) // Correct: Dispatching a different action\n    )\n  );\n\n  constructor(private actions$: Actions) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Updating NgRx Dependencies using Angular CLI (sh)\nDESCRIPTION: Provides the shell command to update NgRx packages to version 17 using the Angular CLI's `ng update` command. This command automatically runs migration schematics to handle some breaking changes.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v17.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nng update @ngrx/store@17\n```\n\n----------------------------------------\n\nTITLE: Updating NgRx Store using Angular CLI\nDESCRIPTION: Updates the @ngrx/store package to version 11 using the Angular CLI `ng update` command. This command automatically handles dependency updates and runs migration schematics to help address breaking changes.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v11.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nng update @ngrx/store@11\n```\n\n----------------------------------------\n\nTITLE: Uniqueness Violation: Duplicate Action Types\nDESCRIPTION: This snippet illustrates a violation of the `strictActionTypeUniqueness` rule. It shows the declaration of two actions with the same type string which is not allowed. It is causing ambiguity.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/configuration/runtime-checks.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nexport const customerPageLoaded = createAction('[Customers Page] Loaded');\nexport const customerPageRefreshed = createAction('[Customers Page] Loaded');\n```\n```\n\n----------------------------------------\n\nTITLE: Handling Arrays with ngrxLet Before Update\nDESCRIPTION: Before the update, `ngrxLet` and `ngrxPush` could directly handle arrays.  This was implicitly treating arrays as observable-like. This could lead to unexpected behavior in certain cases.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v14.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n@Component({\n  template: `\n    <p *ngrxLet=\"numbers as n\">{{ n }}</p>\n    <p>{{ numbers | ngrxPush }}</p>\n  `,\n})\nexport class NumbersComponent {\n  numbers = [1, 2, 3];\n}\n```\n\n----------------------------------------\n\nTITLE: Testing ServiceWorker Locally for NgRx Docs\nDESCRIPTION: Explains how to test the ServiceWorker functionality locally, as the standard `yarn start` command does not enable it. This involves creating a production build using `yarn build` and then serving the generated `dist/` directory using a simple HTTP server on port 4200.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/README.md#_snippet_2\n\nLANGUAGE: Bash\nCODE:\n```\nyarn build\n```\n\nLANGUAGE: Bash\nCODE:\n```\nyarn http-server dist -p 4200\n```\n\n----------------------------------------\n\nTITLE: Example of Incorrect NgRx Action Props Definition using Interface\nDESCRIPTION: This snippet shows an incorrect way to define action properties using a named interface, which obscures their usage and complicates understanding for developers. It declares an interface 'User' and uses it with the 'props' function, which is discouraged in this context. Dependencies include NgRx createAction and props functions, and a TypeScript interface named 'User'. The snippet emphasizes that using interfaces for props may not be optimal and may hinder clear understanding of expected data.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/prefer-inline-action-props.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface User {\n  id: number;\n  fullName: string;\n}\nexport const addUser = createAction('[Users] Add User', props<User>());\n```\n\n----------------------------------------\n\nTITLE: Defining NgRx Feature Selectors Without Explicit Store Type (TypeScript)\nDESCRIPTION: Shows the definition of NgRx feature selectors using `createFeatureSelector` with only the feature state type generic (`FeatureState`). This results in selectors (`selectFeature`, `selectFeatureCount`) whose base type is `object`, suitable for use with a `Store` injected without a generic type, especially in strict mode.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/selectors.md#_snippet_11\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { createSelector, createFeatureSelector } from '@ngrx/store';\n\nexport const featureKey = 'feature';\n\nexport interface FeatureState {\n  counter: number;\n}\n\n// selectFeature will have the type MemoizedSelector<object, FeatureState>\nexport const selectFeature = createFeatureSelector<FeatureState>(featureKey);\n\n// selectFeatureCount will have the type MemoizedSelector<object, number>\nexport const selectFeatureCount = createSelector(\n  selectFeature,\n  state => state.counter\n);\n```\n\n----------------------------------------\n\nTITLE: Configuring NgRx Router Store with Full Router State Serializer in TypeScript\nDESCRIPTION: Demonstrates configuring the NgRx Router Store to use the FullRouterStateSerializer by setting routerState to RouterState.Full. This serializer captures complete router event metadata such as NavigationStart and RoutesRecognized, but cannot be used if serializability runtime checks are enabled due to non-serializable properties.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/router-store/configuration.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nprovideRouterStore({\n  routerState: RouterState.Full,\n});\n```\n\n----------------------------------------\n\nTITLE: EntityChangeTracker - Clearing ChangeState\nDESCRIPTION: Identifies the `EntityOps` that clear the entire `changeState` map, resetting all entities to an unchanged state. This includes operations that replace the entire collection. Dependencies: NgRx Data library, entity actions.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/entity-change-tracker.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nADD_ALL\nQUERY_LOAD_SUCCESS\nREMOVE_ALL\nCOMMIT_ALL\nUNDO_ALL\n```\n\n----------------------------------------\n\nTITLE: Handling Arrays with ngrxLet After Update\nDESCRIPTION: After the update, arrays (and other iterable types) must be explicitly converted to observables using `from(array)` before being passed to `ngrxLet` or `ngrxPush`. Import from `rxjs`. This ensures that only true observables are handled, making the behavior more predictable.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v14.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n@Component({\n  template: `\n    <p *ngrxLet=\"numbers$ as n\">{{ n }}</p>\n    <p>{{ numbers$ | ngrxPush }}</p>\n  `,\n})\nexport class NumbersComponent {\n  numbers$ = from([1, 2, 3]);\n}\n```\n\n----------------------------------------\n\nTITLE: Generating a Basic Effect File with Root Module Registration\nDESCRIPTION: This command generates a UserEffects file configured for the root Angular module, registering the effect at the root level within 'app.module.ts'. It includes the effect's API success and failure actions, and creates a spec file unless skipped.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/schematics/effect.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nng generate effect User --root -m app.module.ts\n```\n\n----------------------------------------\n\nTITLE: Setting up and running the Angular NgRx book collection app with Bash commands\nDESCRIPTION: This snippet provides a step-by-step guide to clone the repository, install dependencies using pnpm, and start the development server for the application. It details prerequisites such as ensuring local npm bin folders are added to the PATH or installing Angular CLI globally. The instructions culminate with a URL to access the running app and login credentials.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/example-app/README.md#_snippet_0\n\nLANGUAGE: Bash\nCODE:\n```\n# Clone the repository\ngit clone https://github.com/ngrx/platform.git\n\n# Go to the example directory\ncd platform\n\n# Install the dependencies\npnpm install\n\n# Start the server\npnpm exec nx serve example-app\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Stricter Effects Typing in NgRx with TypeScript\nDESCRIPTION: This TypeScript snippet illustrates an NgRx effect before the version 10 update, which returns an EMPTY observable without specifying { dispatch: false }. This usage now results in a type error in version 10 due to stricter typing requirements on effects to explicitly declare when they do not dispatch actions.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v10.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nsomeEffect$ = createEffect(() => EMPTY)\n```\n\n----------------------------------------\n\nTITLE: Creating a Named Entity Collection with withEntities in NgRx (TypeScript)\nDESCRIPTION: This snippet demonstrates customizing the property name prefix for entity collections via the withEntities feature. It shows how to specify a collection name ('todo'), resulting in store properties like todoIds, todoEntityMap, and todoEntities. It requires the type function from @ngrx/signals and withEntities from @ngrx/signals/entities. The entity type Todo must be defined. No conditional logic is involved; inputs are the entity type and collection name, producing a store with appropriately named entity properties.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/entity-management.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { signalStore, type } from '@ngrx/signals';\nimport { withEntities } from '@ngrx/signals/entities';\n\ntype Todo = {\n  id: number;\n  text: string;\n  completed: boolean;\n};\n\nexport const TodosStore = signalStore(\n  // 💡 Entity type is specified using the `type` function.\n  withEntities({ entity: type<Todo>(), collection: 'todo' }),\n);\n\n```\n\n----------------------------------------\n\nTITLE: Feature Loaded Action Changes - TypeScript\nDESCRIPTION: This TypeScript code snippet illustrates the change in actions dispatched when adding or removing feature reducers in NgRx v7.  It shows the difference between dispatching individual actions per feature in the 'BEFORE' state and using a single action with an array of features in the 'AFTER' state. This involves changes in the action payload structure to accommodate multiple feature updates efficiently.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v7.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\n{type: '@ngrx/store/update-reducers', feature: 'feat1'}\n```\n\n----------------------------------------\n\nTITLE: Unit Testing Custom PluralHttpUrlGenerator in NgRx Data with Jasmine in TypeScript\nDESCRIPTION: This unit test suite verifies the behavior and correctness of the custom PluralHttpUrlGenerator class. It tests creation, pluralization of entity and collection resource URLs, and caching functionality to ensure consistent resource URL generation. The tests utilize Jasmine's expect and toBeTruthy assertions. Dependencies include the custom PluralHttpUrlGenerator implementation and NgRx Data's DefaultPluralizer to support pluralization logic during testing. This enables validation that the custom URL generator behaves as expected before deployment.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/extension-points.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { PluralHttpUrlGenerator } from './plural-http-url-generator';\nimport { DefaultPluralizer } from '@ngrx/data';\n\ndescribe('PluralHttpUrlGenerator', () => {\n  let generator: PluralHttpUrlGenerator;\n\n  beforeEach(() => {\n    generator = new PluralHttpUrlGenerator(new DefaultPluralizer([]));\n  });\n\n  it('should be created', () => {\n    expect(generator).toBeTruthy();\n  });\n\n  it('should pluralize entity resource URLs', () => {\n    let url = generator.entityResource('bar', 'https://foo.com/api');\n    expect(url).toBe('https://foo.com/api/bars/');\n  });\n\n  it('should pluralize collection resource URLs', () => {\n    const url = generator.collectionResource('bar', 'https://foo.com/api');\n    expect(url).toBe('https://foo.com/api/bars/');\n  });\n\n  it('should cache results (needed for 100% branch coverage)', () => {\n    const url = generator.entityResource('bar', 'https://foo.com/api');\n    const cachedUrl = generator.entityResource('bar', 'https://foo.com/api');\n    expect(cachedUrl).toBe(url);\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Effects with EffectsModule.run in Angular (TypeScript)\nDESCRIPTION: Demonstrates the previous method for registering effects in an Angular NgModule using the EffectsModule.run() API. This pattern requires listing each effect class individually in the imports array. Dependencies include @ngrx/effects and @angular/core. The key input is an array of run() calls for each source, and each effect is registered separately. Output is the configuration of an Angular module with effects enabled; this approach is now deprecated and incompatible with the updated Effects API.\nSOURCE: https://github.com/ngrx/platform/blob/main/CHANGELOG.md#_snippet_49\n\nLANGUAGE: TypeScript\nCODE:\n```\n@NgModule({\n  imports: [EffectsModule.run(SourceA), EffectsModule.run(SourceB)],\n})\nexport class AppModule {}\n```\n\n----------------------------------------\n\nTITLE: Using NgRx `selectSignal` in Angular Components (TypeScript)\nDESCRIPTION: Illustrates using `store.selectSignal` within a standalone Angular component to obtain a `Signal` representing a slice of the NgRx state. The example injects the `Store`, selects an array of users using `selectUsers`, and iterates over the signal's value (`users()`) in the template with `*ngFor`. Requires `@angular/core`, `@angular/common`, and `@ngrx/store`.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/selectors.md#_snippet_12\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Component, inject } from '@angular/core';\nimport { NgFor } from '@angular/common';\nimport { Store } from '@ngrx/store';\n\nimport { selectUsers } from './users.selectors';\n\n@Component({\n  standalone: true,\n  imports: [NgFor],\n  template: `\n    <h1>Users</h1>\n    <ul>\n      <li *ngFor=\"let user of users()\">\n        {{ user.name }}\n      </li>\n    </ul>\n  `\n})\nexport class UsersComponent {\n  private readonly store = inject(Store);\n\n  // type: Signal<User[]>\n  readonly users = this.store.selectSignal(selectUsers);\n}\n```\n\n----------------------------------------\n\nTITLE: Example: Generate User Entity and Register Reducer\nDESCRIPTION: Creates a set of entity files for 'User' and adds the reducer to the specified reducers file, facilitating integration into an existing reducer map.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/schematics/entity.md#_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\nng generate entity User --reducers reducers/index.ts\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of Mapping Logic in Component with RxJS\nDESCRIPTION: This example shows the incorrect approach of using RxJS map operator directly in a component to transform selector results, which the rule discourages.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/avoid-mapping-selectors.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport class Component {\n  name$ = this.store\n    .select(selectLoggedInUser)\n    .pipe(map((user) => ({ name: user.name })));\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Counter Actions Using NgRx Store in TypeScript\nDESCRIPTION: Defines a set of unique action creators representing events to increment, decrement, and reset the counter state within an Angular app using @ngrx/store. These actions are dispatched from components or services to signal state changes. This snippet requires @ngrx/store installed and properly configured, serving as the input events for reducers to process and update state accordingly.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\n\n```\n\n----------------------------------------\n\nTITLE: Installing NgRx Store Devtools Using Angular CLI ng add Command Shell\nDESCRIPTION: This shell snippet demonstrates the Angular CLI ng add command to add the @ngrx/store-devtools package to an Angular project with the latest version. Using ng add automates updating package.json dependencies, installs the package, and configures the StoreDevtoolsModule with default or customized options. It supports optional flags such as --path, --project, --module, and --maxAge to control import locations and maximum action history size.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store-devtools/install.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nng add @ngrx/store-devtools@latest\n```\n\n----------------------------------------\n\nTITLE: Example of EntityName inference (TypeScript)\nDESCRIPTION: This code illustrates that when `entityName` is omitted from the `EntityMetadataMap`, the key of the map becomes the `entityName`.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/entity-metadata.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst map = {\n  Hero: {} // \"Hero\" becomes the entityName\n};\n```\n\n----------------------------------------\n\nTITLE: Updating NgRx Store Using Angular CLI in Shell\nDESCRIPTION: This shell command updates the NgRx store package to version 10 using the Angular CLI ng update command. It assumes Angular CLI and related dependencies are properly installed and configured. Running this command triggers migration schematics to help automate breaking change fixes during upgrade.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v10.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nng update @ngrx/store@10\n```\n\n----------------------------------------\n\nTITLE: Setting up Library Module Dependencies with Yarn (sh)\nDESCRIPTION: This command installs all project dependencies for the core NgRx library modules. It should be run from the root project folder before submitting a pull request to ensure that all necessary libraries and tools for building, testing, and developing the core modules are installed. Requires `yarn`.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/marketing/contributing.md#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\nyarn\n```\n\n----------------------------------------\n\nTITLE: Serializability Violation: Using Unserializable Data in State\nDESCRIPTION: This code shows a violation of `strictStateSerializability` by including a `Date` object in the state, which is not serializable. This prevents the state from being persisted or rehydrated correctly.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/configuration/runtime-checks.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nexport const reducer = createReducer(\n  initialState,\n  on(completeTodo, (state, { id }) => ({\n    ...state,\n    todos: {\n      ...state.todos,\n      [id]: {\n        ...state.todos[id],\n        // Violation, Date is not serializable\n        completedOn: new Date(),\n      },\n    },\n  }))\n);\n```\n```\n\n----------------------------------------\n\nTITLE: Manually Creating and Dispatching an EntityAction Object in TypeScript\nDESCRIPTION: This example shows how to construct an EntityAction object manually without using the EntityActionFactory. The action object includes mandatory properties 'entityName' and 'entityOp' and a generic 'type' string. Manually created actions trigger NgRx Data effects like factory-created actions but might not have a descriptive 'type' tag in logs.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/entity-actions.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst action = {\n  type: 'some/arbitrary/action/type',\n  entityName: 'Hero',\n  entityOp: EntityOp.QUERY_ALL\n};\n\nstore.dispatch(action);\n```\n\n----------------------------------------\n\nTITLE: Creating Effects with Parameters\nDESCRIPTION: This demonstrates how to define an effect that takes parameters, including default values. The parameters allow customization of behavior during tests, for example overriding debounceTime or scheduler for time-dependent effects.  This approach promotes testability by enabling control over effect execution and hiding internal implementation details. The `createEffect` function is used to define the effect.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/effects/testing.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nsearch$ = createEffect(() => ({\n  // assign default values\n  debounce = 300,\n  scheduler = asyncScheduler\n} = {}) =>\n  this.actions$.pipe(\n    ofType(BookActions.search),\n    debounceTime(debounce, scheduler),\n    ...\n  )\n);\n```\n\n----------------------------------------\n\nTITLE: Installing NgRx Data with yarn in Shell\nDESCRIPTION: Uses yarn to add @ngrx/data as a dependency for your Angular project. This command installs the package but does not automate imports or configuration, leaving those steps for manual implementation. Prerequisites include a working Yarn installation and an initialized project.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/install.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nyarn add @ngrx/data\n```\n\n----------------------------------------\n\nTITLE: Configuring Plural Names - Replacing Pluralizer\nDESCRIPTION: This snippet shows how to replace the default `Pluralizer` class with a custom one.  It demonstrates how to provide `Pluralizer` using the `useClass` option. This is used when default pluralization logic is insufficient for your application's requirements, requiring a custom implementation of pluralization.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/entity-metadata.md#_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\n{ provide: Pluralizer, useClass: MyPluralizer }\n\n```\n\n----------------------------------------\n\nTITLE: Overwriting Entities with setAll (@ngrx/entity v11+)\nDESCRIPTION: Shows the replacement for `addAll` in `@ngrx/entity` version 11, the `adapter.setAll` method. This method serves the same purpose of replacing all entities in the state collection but uses a more descriptive name.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v11.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nadapter.setAll(action.entities, state);\n```\n\n----------------------------------------\n\nTITLE: Using EntityServices to retrieve EntityCollectionService for 'Hero'\nDESCRIPTION: Demonstrates how to inject EntityServices into a component and retrieve the singleton EntityCollectionService for 'Hero' entities using getEntityCollectionService(). This pattern simplifies access to entity data with automatic creation if not previously registered.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/entity-services.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { EntityCollectionService, EntityServices } from '@ngrx/data';\nimport { Hero } from '../../model';\n\n@Component({/* component metadata */})\nexport class HeroesComponent implements OnInit {\n  heroesService: EntityCollectionService<Hero>;\n\n  constructor(entityServices: EntityServices) {\n    this.heroesService = entityServices.getEntityCollectionService('Hero');\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Router Store Configuration - TypeScript (AFTER)\nDESCRIPTION: This TypeScript code snippet shows the updated router store configuration where the `stateKey` parameter is removed, and the default value is used. The `StoreRouterConnectingModule.forRoot()` method is used without specifying a custom state key.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v7.md#_snippet_8\n\nLANGUAGE: ts\nCODE:\n```\nStoreRouterConnectingModule.forRoot(),\n\n```\n\n----------------------------------------\n\nTITLE: Registering NgRx Feature Using provideState in Standalone Angular Application\nDESCRIPTION: Shows how to register an NgRx feature in a standalone Angular application using the `provideState` function. `provideState` is added to the `providers` array when bootstrapping the application with `bootstrapApplication`, alongside `provideStore`.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/feature-creators.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { bootstrapApplication } from '@angular/platform-browser';\nimport { provideStore, provideState } from '@ngrx/store';\n\nimport { AppComponent } from './app.component';\nimport { booksFeature } from './books.reducer';\n\nbootstrapApplication(AppComponent, {\n  providers: [\n    provideStore(),\n    provideState(booksFeature)\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Default EntityAction Instance Using the EntityActionFactory in TypeScript\nDESCRIPTION: This code example shows how to create an EntityAction for querying all entities of the 'Hero' type using the injectable EntityActionFactory. It demonstrates calling the 'create()' method with entity name and operation parameters, resulting in an action instance ready to be dispatched to the NgRx store to initiate data retrieval effects.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/entity-actions.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst action = this.entityActionFactory.create<Hero>(\n  'Hero',\n  EntityOp.QUERY_ALL\n);\n\nstore.dispatch(action);\n```\n\n----------------------------------------\n\nTITLE: Connecting Custom Feature with Store using withFeature TypeScript\nDESCRIPTION: This code showcases how to connect a custom feature with a SignalStore using the `withFeature` function in ngrx/signals. The `withBooksFilter` function defines the custom feature, using `signalStoreFeature` to add state, computed values, and methods related to filtering books based on a query. The BooksStore is created using `signalStore`, `withEntities`, and `withFeature` to integrate the custom filter.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/custom-store-features.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { computed, Signal } from '@angular/core';\nimport { patchState, signalStore, signalStoreFeature, withComputed, withFeature, withMethods, withState } from '@ngrx/signals';\nimport { withEntities } from '@ngrx/signals/entities';\n\nexport function withBooksFilter(books: Signal<Book[]>) {\n  return signalStoreFeature(\n    withState({ query: '' }),\n    withComputed(({ query }) => ({\n      filteredBooks: computed(() =>\n        books().filter((b) => b.name.includes(query()))\n      ),\n    })),\n    withMethods((store) => ({\n      setQuery(query: string): void {\n        patchState(store, { query });\n      },\n    })),\n)};\n\nexport const BooksStore = signalStore(\n  withEntities<Book>(),\n  withFeature(({ entities }) =>\n    withBooksFilter(entities)\n  ),\n);\n```\n\n----------------------------------------\n\nTITLE: Installing NgRx Store with Angular CLI using ng add (Shell)\nDESCRIPTION: This command installs the latest version of the @ngrx/store package into an Angular project using the Angular CLI. It automatically updates package.json, installs dependencies, and configures the StoreModule import within the project module. Optional flags can be used to further customize the module and project configuration. Dependencies: Angular CLI, an existing Angular project. Input: None. Output: Installs and configures @ngrx/store in the target application. Limitations: Requires Angular CLI and proper project setup.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/install.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nng add @ngrx/store@latest\n```\n\n----------------------------------------\n\nTITLE: Generating and Integrating a Reducer into an Index File (sh)\nDESCRIPTION: Example command to generate a 'User' reducer and automatically import and add its interface and reducer definition to an existing state interface and `ActionReducerMap` located in `reducers/index.ts`. This is achieved using the `--reducers` option.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/schematics/reducer.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nng generate reducer User --reducers reducers/index.ts\n```\n\n----------------------------------------\n\nTITLE: Configuring Feature Store (Before v13 Config Removal) - TypeScript\nDESCRIPTION: Examples showing the previous syntax for `StoreModule.forFeature` which accepted an optional second configuration object containing `initialState` and `metaReducers`. This configuration object parameter has been removed in v13.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v13.md#_snippet_5\n\nLANGUAGE: ts\nCODE:\n```\nStoreModule.forFeature(\n  featureSlice,\n  { initialState: 100, metaReducers: [metaReducer] }\n);\n```\n\nLANGUAGE: ts\nCODE:\n```\nStoreModule.forFeature(\n  { name: 'feature', reducer: featureReducer },\n  { initialState: 100, metaReducers: [metaReducer] }\n);\n```\n\n----------------------------------------\n\nTITLE: Installing @ngrx/effects with yarn\nDESCRIPTION: This command installs @ngrx/effects using yarn. Yarn is an alternative package manager to npm. This command will also update the `yarn.lock` file.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/effects/install.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nyarn add @ngrx/effects\n```\n\n----------------------------------------\n\nTITLE: Installing @ngrx/effects with npm\nDESCRIPTION: This command installs @ngrx/effects using npm and saves it as a dependency in the `package.json` file. This ensures that the package is included when others install your project's dependencies.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/effects/install.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nnpm install @ngrx/effects --save\n```\n\n----------------------------------------\n\nTITLE: Dispatching a ChangeSet with EntityCacheDispatcher in TypeScript\nDESCRIPTION: Illustrates how to create a ChangeSet object using the defined changes and then dispatch it to the server using the saveEntities method of the EntityCacheDispatcher. It also shows subscribing to the returned observable.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/save-entities.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst changeSet: ChangeSet = { changes, tag: 'Hello World'}\n\ncacheEntityDispatcher.saveEntities(changeSet, saveUrl).subscribe(\n  result => log('Saved ChangeSet')\n);\n```\n\n----------------------------------------\n\nTITLE: Default Minimal Router State in NgRx Router Store\nDESCRIPTION: This code sets the NgRx router store to use the minimal router state serializer by default, which includes only serializable, essential route information. It also illustrates how the dispatched actions' payloads are simplified.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v9.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\n// No explicit code snippet; configuration automatically uses MinimalRouterStateSerializer\n// Placeholder for configuration code if needed\n\n```\n\n----------------------------------------\n\nTITLE: Testing Play Tracking Extension Isolation Using Angular TestBed and fakeAsync in TypeScript\nDESCRIPTION: This test suite verifies the functionality of the `withPlayTracking` extension in isolation by creating a custom `TrackedPlayStore` injected via Angular TestBed. It employs the `fakeAsync` utility and `tick` function to simulate asynchronous time intervals, triggering `play` and `stop` methods to imitate movie playback durations. The test asserts that the tracked playback times correspond accurately to the simulated durations for each movie ID in the store's tracked data. Key dependencies include Angular testing utilities and the custom extension being tested.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/testing.md#_snippet_16\n\nLANGUAGE: TypeScript\nCODE:\n```\ndescribe('withTrackedPlay', () => {\n  const TrackedPlayStore = signalStore({ providedIn: 'root' }, withPlayTracking());\n\n  it('should track movies', fakeAsync(() => {\n    const store = TestBed.inject(TrackedPlayStore);\n\n    store.play(1);\n    tick(1000);\n\n    store.stop();\n    store.play(2);\n    tick(1000);\n\n    store.play(3);\n    tick(1000);\n\n    store.play(1);\n    tick(1000);\n    store.stop();\n\n    expect(store.trackedData()).toEqual({ 1: 2000, 2: 1000, 3: 1000 });\n  }))\n});\n```\n\n----------------------------------------\n\nTITLE: Updating Minimum Required Angular Version for NgRx\nDESCRIPTION: Breaking change introduced around NgRx v18.0.0-beta.0: The minimum required version of Angular has been updated from v17.x to v18.x. Ensure your project's Angular dependency meets this new requirement when upgrading NgRx to version 18 or later.\nSOURCE: https://github.com/ngrx/platform/blob/main/CHANGELOG.md#_snippet_8\n\nLANGUAGE: Text\nCODE:\n```\nBEFORE:\n\nThe minimum required version of Angular is 17.x\n```\n\nLANGUAGE: Text\nCODE:\n```\nAFTER:\n\nThe minimum required version of Angular is 18.x\n```\n\n----------------------------------------\n\nTITLE: Error Handling in LetDirective Before Update\nDESCRIPTION: This snippet demonstrates how the `$error` property in `LetDirective` was used before the update. The `e` variable would be `true` if the `obs$` emitted an error event, and `false` otherwise.  This relied on boolean error representation.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v14.md#_snippet_1\n\nLANGUAGE: html\nCODE:\n```\n<p *ngrxLet=\"obs$; $error as e\">{{ e }}</p>\n```\n\n----------------------------------------\n\nTITLE: Defining Nested Routes in Angular (TypeScript)\nDESCRIPTION: Example configuration array demonstrating how to define nested routes in Angular. It uses the `path` property for route segments and the `children` property to define child routes. This structure is relevant when discussing parameter extraction from different levels of the route tree.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/router-store/selectors.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n[\n  {\n    path: 'my/:urlPath',\n    component: /* ... */,\n    children: [\n      {\n        path: 'is/:matched',\n        component: /* ... */,\n      },\n    ],\n  },\n]\n```\n\n----------------------------------------\n\nTITLE: Defining rxMethod Without Input Arguments - NgRx Signals - TypeScript\nDESCRIPTION: Demonstrates how to define a reactive method that does not accept any input arguments by specifying the `void` type generic. It shows fetching a list of books using `exhaustMap` to prevent multiple simultaneous calls.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/rxjs-integration.md#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Component, inject, OnInit, signal } from '@angular/core';\nimport { exhaustMap } from 'rxjs';\nimport { rxMethod } from '@ngrx/signals/rxjs-interop';\nimport { tapResponse } from '@ngrx/operators';\nimport { Book } from './book.model';\nimport { BooksService } from './books.service';\n\n@Component({ /* ... */ })\nexport class BooksComponent implements OnInit {\n  readonly #booksService = inject(BooksService);\n  readonly books = signal<Book[]>([]);\n\n  // 👇 Creating a reactive method without arguments.\n  readonly loadAllBooks = rxMethod<void>(\n    exhaustMap(() => {\n      return this.#booksService.getAll().pipe(\n        tapResponse({\n          next: (books) => this.books.set(books),\n          error: console.error,\n        })\n      );\n    })\n  );\n\n  ngOnInit(): void {\n    this.loadAllBooks();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Correct usage of descriptive key names in nGRX store configuration\nDESCRIPTION: These snippets illustrate proper naming conventions by replacing 'reducer' with descriptive state slice names, enhancing code clarity. It demonstrates how to assign reducers to keys named after the data they manage.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/no-reducer-in-key-names.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nStoreModule.forRoot({\n  customers: customersReducer,\n});\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nStoreModule.forFeature({\n  customers: customersReducer,\n});\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport const reducers: ActionReducerMap<AppState> = {\n  customers: fromCustomers.reducer,\n};\n```\n\n----------------------------------------\n\nTITLE: Disabling Resubscription on Error in NgRx Effects (TypeScript)\nDESCRIPTION: Shows how to disable automatic resubscription to effects when an error occurs by setting the useEffectsErrorHandler option to false in the effect metadata.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/effects/lifecycle.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Injectable, inject } from '@angular/core';\nimport { Actions, ofType, createEffect } from '@ngrx/effects';\nimport { of } from 'rxjs';\nimport { catchError, exhaustMap, map } from 'rxjs/operators';\nimport {\n  LoginPageActions,\n  AuthApiActions,\n} from '../actions';\nimport { AuthService } from '../services/auth.service';\n\n@Injectable()\nexport class AuthEffects {\n  private actions$ = inject(Actions);\n  private authService = inject(AuthService);\n\n  logins$ = createEffect(\n    () => {\n      return this.actions$.pipe(\n        ofType(LoginPageActions.login),\n        exhaustMap(action =>\n          this.authService.login(action.credentials).pipe(\n            map(user => AuthApiActions.loginSuccess({ user })),\n            catchError(error => of(AuthApiActions.loginFailure({ error })))\n          )\n        )\n        // Errors are handled and it is safe to disable resubscription\n      );\n    },\n    { useEffectsErrorHandler: false }\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Logger Feature with ngrx/signals (TypeScript)\nDESCRIPTION: This code creates a custom `withLogger` feature that logs SignalStore state changes to the console using Angular's `effect`. It utilizes `signalStoreFeature` and `withHooks` to execute the logging logic on store initialization (`onInit`).  The `getState` function retrieves the current state of the store for logging.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/custom-store-features.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { effect } from '@angular/core';\nimport { getState, signalStoreFeature, withHooks } from '@ngrx/signals';\n\nexport function withLogger(name: string) {\n  return signalStoreFeature(\n    withHooks({\n      onInit(store) {\n        effect(() => {\n          const state = getState(store);\n          console.log(`${name} state changed`, state);\n        });\n      },\n    })\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring @ngrx/router-store in Angular (app.config.ts)\nDESCRIPTION: This code snippet demonstrates how to set up @ngrx/router-store in an Angular application using the `app.config.ts` file. It imports necessary modules such as `provideRouter`, `provideStore`, and `provideRouterStore`. It then configures the application to use the router and routerReducer, so that the router state can be managed by ngrx store.  This requires the `@ngrx/store` and `@ngrx/router-store` packages as dependencies.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/router-store/index.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ApplicationConfig } from '@angular/core';\nimport { provideRouter } from '@angular/router';\nimport { provideStore } from '@ngrx/store';\nimport { provideRouterStore, routerReducer } from '@ngrx/router-store';\n\nexport const appConfig: ApplicationConfig = {\n  providers: [\n    provideRouter([\n      // routes\n    ]),\n    provideStore({\n      router: routerReducer,\n    }),\n    provideRouterStore()\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Installing NgRx Store with yarn (Shell)\nDESCRIPTION: This shell command uses yarn to add the @ngrx/store package to the project dependencies. It downloads and installs @ngrx/store and updates the project's yarn.lock and package.json accordingly. Dependencies: yarn, existing Node.js/Angular project. Input: None. Output: Installs @ngrx/store and updates package dependency files. Limitations: Does not perform automatic configuration or integration steps.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/install.md#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\nyarn add @ngrx/store\n```\n\n----------------------------------------\n\nTITLE: Identifying Effects Uniquely with OnIdentifyEffects in NgRx (TypeScript)\nDESCRIPTION: Shows how to implement the OnIdentifyEffects interface to provide a unique identifier for an Effects class, allowing multiple instances of the same class to be registered.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/effects/lifecycle.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nclass EffectWithIdentifier implements OnIdentifyEffects {\n  constructor(private effectIdentifier: string) {}\n\n  ngrxOnIdentifyEffects() {\n    return this.effectIdentifier;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Typing with Null/Undefined in LetDirective After Update\nDESCRIPTION: After the update, when `null` or `undefined` are passed to `LetDirective`, the type of the context variable (`n` or `u`) is now correctly inferred as `null` or `undefined`, respectively. This provides stronger type safety.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v14.md#_snippet_4\n\nLANGUAGE: html\nCODE:\n```\n<p *ngrxLet=\"null as n\">{{ n }}</p>\n<p *ngrxLet=\"undefined as u\">{{ u }}</p>\n```\n\n----------------------------------------\n\nTITLE: Defining Parameterized Selectors (After v13 Props Deprecation) - TypeScript\nDESCRIPTION: Example demonstrating the recommended pattern in v13 for creating parameterized selectors (factory selectors). The outer function accepts parameters (e.g., `customerId`) and returns the result of `createSelector`, which operates on the selected state without a direct `props` argument.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v13.md#_snippet_12\n\nLANGUAGE: ts\nCODE:\n```\nconst selectCustomer = (customerId: number) =>\n  createSelector(\n    selectCustomers,\n    (customers) => {\n      return customers[customerId];\n    }\n  );\n```\n\n----------------------------------------\n\nTITLE: Configuring Plural Names - Providing Plural Names Incrementally\nDESCRIPTION: This snippet presents an approach to defining plural names in a modular fashion, especially useful when defining entity models across multiple Angular modules. It uses the multi-provider with the `PLURAL_NAMES_TOKEN`, allowing for incremental addition of the `pluralNames` map. This provides flexibility in organizing and maintaining entity definitions.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/entity-metadata.md#_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\n{ provide: PLURAL_NAMES_TOKEN, multi: true, useValue: morePluralNames }\n\n```\n\n----------------------------------------\n\nTITLE: Example: Generate Nested Entity Files\nDESCRIPTION: Generates entity files for 'User' in a nested folder structure by setting --flat to false, which organizes files into a dedicated directory.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/schematics/entity.md#_snippet_7\n\nLANGUAGE: sh\nCODE:\n```\nng generate entity User --flat false\n```\n\n----------------------------------------\n\nTITLE: Injecting NgRx Store Without Generic Type in AppComponent (TypeScript)\nDESCRIPTION: Demonstrates injecting the NgRx `Store` service into an Angular component without providing a generic type argument. It selects state using `store.select` with a selector function (`fromCounter.selectCounter`) created via `createSelector`, relying on TypeScript's type inference.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/selectors.md#_snippet_10\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport class AppComponent {\n  counter$ = this.store.select(fromCounter.selectCounter);\n\n  constructor(private readonly store: Store) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Option: Generate Test Files\nDESCRIPTION: Determines whether to create corresponding spec test files for the generated entity files. Defaults to false, generating tests unless explicitly skipped.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/schematics/entity.md#_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\n--skip-tests\n```\n\n----------------------------------------\n\nTITLE: Replacing ReactiveComponentModule with LetModule and PushModule\nDESCRIPTION: This code shows how to replace ReactiveComponentModule with both LetModule and PushModule, if the component uses both the `ngrxLet` directive and `ngrxPush` pipe.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v14.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { LetModule, PushModule } from '@ngrx/component';\n\n@NgModule({\n  imports: [\n    // ... other imports\n    LetModule,\n    PushModule,\n  ],\n})\nexport class MyFeatureModule {}\n```\n\n----------------------------------------\n\nTITLE: Defining the ChangeSetAdd Interface in TypeScript\nDESCRIPTION: Provides the TypeScript interface definition for a ChangeSetItem specifically for 'Add' operations. It specifies the operation type (Add), the entity name, and an array of entities to be added.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/save-entities.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface ChangeSetAdd<T = any> {\n  op: ChangeSetOperation.Add;\n  entityName: string;\n  entities: T[];\n}\n```\n\n----------------------------------------\n\nTITLE: Object Literal Return Type (Before)\nDESCRIPTION: This code snippet demonstrates the return of object literals from a selector, before version 8, which could lead to type mismatch issues. This will cause errors in version 8 as the type definitions become stricter.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v8.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Reaction {\n  happy: boolean;\n  tweet: string;\n}\n export const getNews: MemoizedSelector<State, Reaction> = createSelector(\n  newsState,\n  (news) => {\n    if (news.isFake) {\n      return {\n        happy: false,\n        tweet: 'blah blah blah',\n      }\n    }\n    return {\n      happy: true,\n      tweet: 'anyway',\n    }\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: Deprecation: LetModule in favor of standalone LetDirective\nDESCRIPTION: Example showing the migration from deprecated LetModule to the standalone LetDirective in both NgModule and standalone component contexts.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v16.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { LetModule } from '@ngrx/component';\n\n@NgModule({\n  imports: [\n    // ... other imports\n    LetModule,\n  ],\n})\nexport class MyFeatureModule {}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { LetDirective } from '@ngrx/component';\n\n@NgModule({\n  imports: [\n    // ... other imports\n    LetDirective,\n  ],\n})\nexport class MyFeatureModule {}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Component } from '@angular/core';\nimport { LetModule } from '@ngrx/component';\n\n@Component({\n  // ... other metadata\n  standalone: true,\n  imports: [\n    // ... other imports\n    LetModule,\n  ],\n})\nexport class MyStandaloneComponent {}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Component } from '@angular/core';\nimport { LetDirective } from '@ngrx/component';\n\n@Component({\n  // ... other metadata\n  standalone: true,\n  imports: [\n    // ... other imports\n    LetDirective,\n  ],\n})\nexport class MyStandaloneComponent {}\n```\n\n----------------------------------------\n\nTITLE: Testing Class-based NgRx Effects with Mocked Actions - TypeScript\nDESCRIPTION: This unit test demonstrates how to instantiate a NgRx effect class directly for testing, bypassing Angular TestBed. It creates a mock Actions observable stream using marble testing syntax, injects a mocked CustomersService, and verifies that the effect emits the expected success action when triggered. Dependencies include the Actions class, the hot helper for stream creation, and a mocked CustomersEffects class with a Get Customers effect. Expected inputs are action objects, and the test asserts observable output actions. Marble testing requires the jasmine-marbles or similar library.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/effects/testing.md#_snippet_11\n\nLANGUAGE: TypeScript\nCODE:\n```\nit('should get customers', () => {\n  // instead of using `provideMockActions`,\n  // define the actions stream by creating a new `Actions` instance\n  const actions = new Actions(\n    hot('-a--', {\n      a: { type: '[Customers Page] Get Customers' },\n    })\n  );\n\n  // create the effect\n  const effects = new CustomersEffects(actions, customersServiceSpy);\n\n  const expected = hot('-a--', {\n    a: {\n      type: '[Customers API] Get Customers Success',\n      customers: [...],\n    }\n  });\n\n  // expect remains the same\n  expect(effects.getAll$).toBeObservable(expected);\n})\n```\n\n----------------------------------------\n\nTITLE: Error Handling in LetDirective After Update\nDESCRIPTION: This snippet demonstrates how the `$error` property in `LetDirective` is used after the update.  The `e` variable now contains the actual error that was thrown, or `undefined` if no error occurred.  This offers better error context.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v14.md#_snippet_2\n\nLANGUAGE: html\nCODE:\n```\n<p *ngrxLet=\"obs$; $error as e\">{{ e }}</p>\n```\n\n----------------------------------------\n\nTITLE: Combining Multiple Observables with *ngrxLet in Angular\nDESCRIPTION: Demonstrates the capability of `*ngrxLet` to subscribe to multiple observables simultaneously by passing a dictionary object (e.g., `{ users: users$, query: query$ }`). The emitted values from each observable are then accessible as properties on a single view model object (`vm`) within the template scope.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/component/let.md#_snippet_4\n\nLANGUAGE: html\nCODE:\n```\n<ng-container *ngrxLet=\"{ users: users$, query: query$ } as vm\">\n  <app-search-bar [query]=\"vm.query\"></app-search-bar>\n  <app-user-list [users]=\"vm.users\"></app-user-list>\n</ng-container>\n```\n\n----------------------------------------\n\nTITLE: Setting up Docs/Website Dependencies with Yarn (sh)\nDESCRIPTION: This command is used to install the correct project dependencies specifically for the NgRx documentation and website (`ngrx.io`). It must be run from the `projects/ngrx.io` folder before submitting a pull request to ensure all required development dependencies are up-to-date. Requires `yarn`.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/marketing/contributing.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nyarn setup\n```\n\n----------------------------------------\n\nTITLE: Defining NgRx Action Group with Camel Case Events (TypeScript)\nDESCRIPTION: This snippet illustrates an alternative approach where event names within the `createActionGroup` function are defined using camel case. This results in the generated action creator names matching the event names, potentially simplifying codebase searching. It shows defining actions for API success and failure responses with typed object payloads (`props`). The generated action creators are also shown being destructured.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/action-groups.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createActionGroup, props } from '@ngrx/store';\n\nimport { Product } from './product.model';\n\nexport const ProductsApiActions = createActionGroup({\n  source: 'Products API',\n  events: {\n    productsLoadedSuccess: props<{ products: Product[] }>(),\n    productsLoadedFailure: props<{ errorMsg: string }>(),\n  },\n});\n\n// generated action creators:\nconst {\n  productsLoadedSuccess, // type: \"[Products API] productsLoadedSuccess\"\n  productsLoadedFailure, // type: \"[Products API] productsLoadedFailure\"\n} = ProductsApiActions;\n```\n\n----------------------------------------\n\nTITLE: Destroying rxMethod References Using unsubscribe (Pre-Version 19) - NgRx TypeScript\nDESCRIPTION: This code example illustrates rxMethod lifecycle management prior to NgRx v19, highlighting the use of 'unsubscribe' to clean up active subscriptions. The snippet depends on rxMethod from NgRx, tap from rxjs, and interval. It demonstrates destroying individual and collective rxMethod refs using setTimeout. Note: This pattern is deprecated and will break in version 19, where 'destroy' should be used instead.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v19.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst logNumber = rxMethod<number>(tap(console.log));\n\nconst num1Ref = logNumber(interval(1_000));\nconst num2Ref = logNumber(interval(2_000));\n\n// destroy `num1Ref` after 2 seconds\nsetTimeout(() => num1Ref.unsubscribe(), 2_000);\n\n// destroy all reactive method refs after 5 seconds\nsetTimeout(() => logNumber.unsubscribe(), 5_000);\n```\n\n----------------------------------------\n\nTITLE: Creating a SignalState instance in TypeScript\nDESCRIPTION: Demonstrates how to instantiate a SignalState using the signalState function, which accepts an initial state object as an input argument. The example creates a state with user data and an isAdmin flag.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-state.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { signalState } from '@ngrx/signals';\nimport { User } from './user.model';\n\ntype UserState = { user: User; isAdmin: boolean };\n\nconst userState = signalState<UserState>({\n  user: { firstName: 'Eric', lastName: 'Clapton' },\n  isAdmin: false,\n});\n```\n\n----------------------------------------\n\nTITLE: EntityChangeTracker - Recording Entity Changes\nDESCRIPTION: Lists the `EntityOps` reducer methods that record entity change states within the `changeState` map. These operations mark entities as added, updated, or deleted. Dependencies include the NgRx Data library and entity actions.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/entity-change-tracker.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Save operations when isOptimistic flag is true\nSAVE_ADD_ONE\nSAVE_ADD_MANY\nSAVE_DELETE_ONE\nSAVE_DELETE_MANY\nSAVE_UPDATE_ONE\nSAVE_UPDATE_MANY\nSAVE_UPSERT_ONE\nSAVE_UPSERT_MANY\n\n// Cache operations\nADD_ONE\nADD_MANY\nREMOVE_ONE\nREMOVE_MANY\nUPDATE_ONE\nUPDATE_MANY\nUPSERT_ONE\nUPSERT_MANY\n```\n\n----------------------------------------\n\nTITLE: ofType Operator Usage - TypeScript (AFTER)\nDESCRIPTION: This TypeScript code snippet shows the updated approach in NgRx v7, replacing the deprecated `ofType` function with the `ofType` operator. It imports the operator and utilizes it within the pipe to filter actions in the effects.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v7.md#_snippet_6\n\nLANGUAGE: ts\nCODE:\n```\nimport { Effect, Actions, ofType } from '@ngrx/effects'; // import ofType operator\n\n@Injectable()\nexport class MyEffects {\n  @Effect()\n  someEffect$: Observable<Action> = this.actions$.pipe(\n    ofType(UserActions.LOGIN), // use the pipeable ofType operator\n    map(() => new AnotherAction())\n  );\n\n  constructor(private actions$: Actions) {}\n}\n```\n\n----------------------------------------\n\nTITLE: MemoizedSelector Typing (Before)\nDESCRIPTION: This code snippet demonstrates the usage of MemoizedSelector prior to version 8, where the return type's widening was implicitly allowed.  This will cause errors in version 8 because the typing is now more strict.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v8.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport const getLoginPagePending: MemoizedSelector<State, boolean | null> = createSelector(\n  selectLoginPageState,\n  loginState => loginState.pending // boolean\n);\n```\n\n----------------------------------------\n\nTITLE: Migrating NgRx Effects using Angular CLI Schematic\nDESCRIPTION: Provides the Angular CLI command to run the NgRx schematic for automatically migrating effects defined with the deprecated `@Effect()` decorator to the new `createEffect` function syntax. This migration schematic was available in NgRx versions 11 and 12.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v11.md#_snippet_9\n\nLANGUAGE: sh\nCODE:\n```\nng generate @ngrx/schematics:create-effect-migration\n```\n\n----------------------------------------\n\nTITLE: Replacing ReactiveComponentModule with PushModule\nDESCRIPTION: This code shows how to replace ReactiveComponentModule with PushModule, if the component uses the `ngrxPush` pipe.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v14.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { PushModule } from '@ngrx/component';\n\n@NgModule({\n  imports: [\n    // ... other imports\n    PushModule,\n  ],\n})\nexport class MyFeatureModule {}\n```\n\n----------------------------------------\n\nTITLE: Defining NgRx Feature Key (Scoreboard Example) - TypeScript\nDESCRIPTION: Defines a constant string to represent the unique key under which the scoreboard feature state will be registered in the NgRx store. Using a constant prevents typos and improves maintainability.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/reducers.md#_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport const scoreboardFeatureKey = 'game';\n```\n\n----------------------------------------\n\nTITLE: Fixing Compilation Error with Generic Parameters TypeScript\nDESCRIPTION: This code snippet demonstrates the solution to the compilation error by specifying an unused generic parameter for the custom features `withZ` and `withW`. This approach resolves the TypeScript issue when combining these features in the SignalStore. It changes the function definition by adding `<_>` after the function name.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/custom-store-features.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n//            👇\nfunction withZ<_>() {\n  return signalStoreFeature(\n    { state: type<{ x: number }>() },\n    withState({ z: 10 })\n  );\n}\n\n//            👇\nfunction withW<_>() {\n  return signalStoreFeature(\n    { state: type<{ y: number }>() },\n    withState({ w: 100 })\n  );\n}\n\nconst Store = signalStore(\n  withState({ x: 10, y: 100 }),\n  withZ(),\n  withW()\n); // ✅ works as expected\n```\n\n----------------------------------------\n\nTITLE: Combining Multiple Selectors in Angular Component - TypeScript\nDESCRIPTION: Demonstrates an anti-pattern where multiple selectors from NgRx store are combined within the Angular component using combineLatest and multiple store.select calls. This approach handles enriching customer data with related orders and filtering customers in the component class, which complicates testing and breaks selector purity. Requires RxJS operators such as combineLatest, map, withLatestFrom. Inputs are raw selector observable streams, outputs are derived observables with combined state. This example is discouraged due to mixing state derivation logic with component code.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/avoid-combining-selectors.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport class Component {\n  vm$ = combineLatest(\n    this.store.select(selectCustomers),\n    this.store.select(selectOrders)\n  ).pipe(\n    map(([customers, orders]) => {\n      return customers.map((c) => {\n        return {\n          customerId: c.id,\n          name: c.name,\n          orders: orders.filter((o) => o.customerId === c.id),\n        };\n      });\n    })\n  );\n}\n\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport class Component {\n  customer$ = this.store\n    .select(selectCustomers)\n    .pipe(withLatestFrom(this.store.select(selectActiveCustomerId)))\n    .pipe(\n      map(([customers, customerId]) => {\n        return customers[customerId];\n      })\n    );\n}\n\n```\n\n----------------------------------------\n\nTITLE: Returning a Single Action per Effect in NgRx (TypeScript - Correct Example)\nDESCRIPTION: This snippet illustrates the recommended approach where each effect dispatches only a single action, using the map operator to translate a response into an action. It relies on @ngrx/effects for effect creation and RxJS for stream processing. When a response is received or an error occurs, only a single action is dispatched, while downstream effects listen for those actions as triggers. This ensures clarity, testability, and predictability within NgRx-managed state flows.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/no-multiple-actions-in-effects.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\n// in effect:\nexport class Effects {\n  loadEmployeeList$ = createEffect(() => {\n    return this.actions$.pipe(\n      ofType(componentLoaded),\n      exhaustMap(() =>\n        this.dataService.loadEmployeeList().pipe(\n          map((response) => loadEmployeeListSuccess(response)),\n          catchError((error) => loadEmployeeListError(error))\n        )\n      )\n    );\n  });\n\n  // use the one dispatched action\n\n  loadCompanyList$ = createEffect(() => {\n    return this.actions$.pipe(\n      ofType(loadEmployeeListSuccess)\n      // handle loadCompanyList\n    );\n  });\n\n  //use the one dispatched action\n\n  cleanData$ = createEffect(() => {\n    return this.actions$.pipe(\n      ofType(loadEmployeeListSuccess)\n      // handle cleanData\n    );\n  });\n\n  constructor(private readonly actions$: Actions) {}\n\n```\n\n----------------------------------------\n\nTITLE: Correct Usage: Explicitly Enabling Protected State in NgRx Signal Store (TypeScript)\nDESCRIPTION: This example demonstrates another correct way to define an NgRx Signal Store. It explicitly sets `protectedState` to `true` within the `signalStore` configuration, reinforcing that state modifications should be managed solely within the store.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/prefer-protected-state.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst Store = signalStore(\n  { protectedState: true },\n  withState({}),\n);\n```\n\n----------------------------------------\n\nTITLE: Installing NgRx Component Package with yarn add - shell\nDESCRIPTION: Uses the `yarn add @ngrx/component` command to add the NgRx Component package to the project dependencies via yarn package manager. Requires yarn to be installed and configured for the project environment.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/component/install.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nyarn add @ngrx/component\n```\n\n----------------------------------------\n\nTITLE: Using Standalone PushPipe (After Deprecation) in TypeScript\nDESCRIPTION: Shows the recommended way to use the `PushPipe` after `PushModule` deprecation in NgRx v17, by importing `PushPipe` directly into a standalone Angular component's imports array. This eliminates the need for `PushModule`.\nSOURCE: https://github.com/ngrx/platform/blob/main/CHANGELOG.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Component } from '@angular/core';\nimport { PushPipe } from '@ngrx/component';\n\n@Component({\n  // ... other metadata\n  standalone: true,\n  imports: [\n    // ... other imports\n    PushPipe,\n  ],\n})\nexport class MyStandaloneComponent {}\n```\n\n----------------------------------------\n\nTITLE: Managing NgRx ComponentStore Lifecycle with OnDestroy Interface in TypeScript\nDESCRIPTION: This snippet illustrates a MoviesStore class implementing OnDestroy to handle cleanup. The ngOnDestroy method calls super.ngOnDestroy() to ensure internal observables are unsubscribed, preventing memory leaks. An example usage shows a component subscribing to an observable until the store is destroyed, using the destroy$ property.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/component-store/lifecycle.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\n@Injectable()\nexport class MoviesStore extends ComponentStore<MoviesState> implements OnDestroy {\n  \n  constructor() {\n    super({movies: []});\n  }\n\n  override ngOnDestroy(): void {\n    // 👇 add this line\n    super.ngOnDestroy();\n  }\n}\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\n@Component({\n  // ... other metadata\n  providers: [ComponentStore]\n})\nexport class BooksPageComponent implements OnInit {\n  constructor(private cs: ComponentStore) {}\n\n  ngOnInit() {\n    const timer = interval(1000)\n      .pipe(takeUntil(this.cs.destroy$))\n      .subscribe(() => {\n        // listen until ComponentStore is destroyed\n      });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing NgRx Entity State in TypeScript\nDESCRIPTION: Shows how to use the `getInitialState` method from a previously created `EntityAdapter` to define the initial state for an entity slice. It merges the default entity state structure (`ids`, `entities`) provided by the adapter with additional custom state properties like `selectedUserId`. Imports `Action`, `createReducer` from `@ngrx/store` and entity types from `@ngrx/entity`.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/entity/adapter.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Action, createReducer } from '@ngrx/store';\nimport { EntityState, EntityAdapter, createEntityAdapter } from '@ngrx/entity';\n\nexport interface User {\n  id: string;\n  name: string;\n}\n\nexport interface State extends EntityState<User> {\n  // additional entities state properties\n  selectedUserId: string | null;\n}\n\n// Assuming 'adapter' is defined as shown in the previous snippet\ndeclare const adapter: EntityAdapter<User>; \n\nexport const initialState: State = adapter.getInitialState({\n  // additional entity state properties\n  selectedUserId: null,\n});\n\nexport const userReducer = createReducer(initialState);\n```\n\n----------------------------------------\n\nTITLE: Using selectors with props to parameterize state selection (deprecated approach)\nDESCRIPTION: Illustrates passing custom 'props' to selectors for dynamic computations, such as multiplying a counter by a factor. Note: 'selectors with props' are deprecated in favor of creating factory functions.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/selectors.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport const selectCount = createSelector(\n  selectCounterValue,\n  (counter, props) => counter * props.multiply\n);\n```\n\n----------------------------------------\n\nTITLE: Installing NgRx Store with npm (Shell)\nDESCRIPTION: This shell command installs the @ngrx/store package using npm and saves it as a project dependency. It modifies package.json to reflect the new dependency. Dependencies: npm, an existing Node.js/Angular project. Input: None. Output: Installs @ngrx/store to node_modules and updates package.json. Limitations: No automatic configuration or module import changes are performed.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/install.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nnpm install @ngrx/store --save\n```\n\n----------------------------------------\n\nTITLE: Updating NgRx Package with Angular CLI - Shell\nDESCRIPTION: This shell snippet demonstrates how to update the @ngrx/store package to version 12 using the Angular CLI. The command leverages Angular's built-in update mechanism, which also executes schematics to automatically address some breaking changes. Running this command requires the Angular CLI to be installed and properly configured in your project; it updates the package and its dependencies to the specified version if the minimum version requirements (Angular 12.x, TypeScript 4.2.x, RxJS 6.5.x) are met.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v12.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nng update @ngrx/store@12\n```\n\n----------------------------------------\n\nTITLE: Using setState Method in ComponentStore with TypeScript\nDESCRIPTION: Shows how to use the setState method in two ways: providing a complete state object for resetting state, and using a callback for partial updates. Includes initialization in ngOnInit.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/component-store/write.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n@Component({\n  template: `...`,\n  providers: [ComponentStore],\n})\nexport class MoviesPageComponent implements OnInit {\n  constructor(\n    private readonly componentStore: ComponentStore<MoviesState>\n  ) {}\n\n  ngOnInit() {\n    this.componentStore.setState({movies: []});\n  }\n\n  resetMovies() {\n    //    resets the State to empty array 👇\n    this.componentStore.setState({movies: []});\n  }\n\n  addMovie(movie: Movie) {\n    this.componentStore.setState((state) => {\n      return {\n        ...state,\n        movies: [...state.movies, movie],\n      };\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating a Container Component with Deprecated skipTest Option Using Bash\nDESCRIPTION: This Bash snippet demonstrates the previous usage of the Angular CLI generate command for a container named UsersPage employing the --skipTest option to omit test file creation. The skipTest option is deprecated and removed in NgRx v10 schematics, requiring updates to commands using this flag.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v10.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nng generate container UsersPage --skipTest\n```\n\n----------------------------------------\n\nTITLE: Injecting Feature Store Configuration into NgRx Feature Module Using InjectionToken (TypeScript)\nDESCRIPTION: Describes a pattern to provide the feature store configuration object (StoreConfig) into an NgRx feature module via dependency injection. An InjectionToken is created for the feature config, and a factory function uses an injected service to synchronously return the configuration including initial state and meta-reducers. The token is then passed to StoreModule.forFeature alongside reducers, enabling dynamic and service-driven feature store configuration.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/recipes/injecting.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { NgModule, InjectionToken } from '@angular/core';\nimport { StoreModule, StoreConfig } from '@ngrx/store';\nimport { SomeService } from './some.service';\n\nimport * as fromFeature from './reducers';\n\nexport const FEATURE_CONFIG_TOKEN = new InjectionToken<StoreConfig<fromFeature.State>>('Feature Config');\n\nexport function getConfig(someService: SomeService): StoreConfig<fromFeature.State> {\n  // return the config synchronously.\n  return {\n    initialState: someService.getInitialState(),\n\n    metaReducers: [\n      fromFeature.loggerFactory(someService.loggerConfig())\n    ]\n  };\n}\n\n@NgModule({\n  imports: [StoreModule.forFeature(fromFeature.featureKey, fromFeature.reducers, FEATURE_CONFIG_TOKEN)],\n  providers: [\n    {\n      provide: FEATURE_CONFIG_TOKEN,\n      deps: [SomeService],\n      useFactory: getConfig,\n    },\n  ],\n})\nexport class FeatureModule {}\n\n```\n\n----------------------------------------\n\nTITLE: Generating a Feature Set with Shorthand Command in NgRx - Shell\nDESCRIPTION: Similar to the standard generate command, this executes a shorthand alias ('f') for creating NgRx feature scaffolding in an Angular project. Dependencies and parameters are the same, with feature and option placeholders for customizing the generated output.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/schematics/feature.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nng generate f FeatureName [options]\n```\n\n----------------------------------------\n\nTITLE: Renaming StoreDevTools Configuration Options in NgRx (TypeScript)\nDESCRIPTION: Shows the updated configuration options for StoreDevtoolsModule.instrument in NgRx where the properties actionsWhitelist and actionsBlacklist are renamed to actionsSafelist and actionsBlocklist, respectively. This change reflects terminology updates for clarity and inclusivity. The code snippet compares the previous and current usage, essential when configuring StoreDevTools in Angular applications using NgRx. The snippet assumes import and setup of StoreDevtoolsModule from '@ngrx/store-devtools'.\nSOURCE: https://github.com/ngrx/platform/blob/main/CHANGELOG.md#_snippet_46\n\nLANGUAGE: typescript\nCODE:\n```\nStoreDevtoolsModule.instrument({\n  actionsWhitelist: ['...'],\n  actionsBlacklist: ['...'],\n});\n\n```\n\nLANGUAGE: typescript\nCODE:\n```\nStoreDevtoolsModule.instrument({\n  actionsSafelist: ['...'],\n  actionsBlocklist: ['...'],\n});\n\n```\n\n----------------------------------------\n\nTITLE: Breaking Change: getMockStore After\nDESCRIPTION: Illustrates the replacement of `getMockStore` with `createMockStore`.  Developers should migrate to use `createMockStore` for mocking the store in tests.\nSOURCE: https://github.com/ngrx/platform/blob/main/CHANGELOG.md#_snippet_21\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { createMockStore } from '@ngrx/store/testing';\nconst mockStore = createMockStore();\n```\n\n----------------------------------------\n\nTITLE: Updating NgRx Packages with Angular CLI\nDESCRIPTION: This command updates the @ngrx/store package to version 14 using the Angular CLI.  This triggers migration schematics to handle breaking changes and streamline the upgrade process. Make sure Angular CLI is installed.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v14.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nng update @ngrx/store@14\n```\n\n----------------------------------------\n\nTITLE: Configuring NgRx ESLint Plugin with Type Information for ESLint v8\nDESCRIPTION: Sets up the NgRx ESLint Plugin with type checking capabilities by providing the tsconfig.json path in the parserOptions for rules requiring type information.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/index.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"plugins\": [\"@ngrx\"],\n  \"parserOptions\": {\n    \"project\": \"tsconfig.json\"\n  },\n  \"rules\": {\n    \"@ngrx/avoid-cyclic-effects\": \"error\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Selector with a Custom Equality Function in NgRx ComponentStore Using TypeScript\nDESCRIPTION: Illustrates how to override the default strict equality check in a selector by providing a custom equality function that compares lengths of movie arrays instead of reference equality. This controls when the observable emits new values, optimizing performance by limiting emissions.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/component-store/read.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface MoviesState {\n  movies: Movie[];\n}\n\n@Injectable()\nexport class MoviesStore extends ComponentStore<MoviesState> {\n  \n  constructor() {\n    super({movies:[]});\n  }\n\n  readonly movies$: Observable<Movie[]> = this.select(\n    state => state.movies,\n    {equal: (prev, curr) => prev.length === curr.length} // 👈 custom equality function\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Injecting Root Reducers into NgRx Store using Angular Dependency Injection (TypeScript)\nDESCRIPTION: Illustrates how to inject root reducers into an NgRx store by creating an InjectionToken with a factory that synchronously returns reducers obtained via an injected service. The snippet demonstrates usage of Angular's inject function inside the token's factory to access a service that provides the reducers map, then passes the token to StoreModule.forRoot to register the reducers. This approach supports dynamic or runtime reducer resolution.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/recipes/injecting.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { NgModule, inject, InjectionToken } from '@angular/core';\nimport { StoreModule, ActionReducerMap } from '@ngrx/store';\n\nimport { SomeService } from './some.service';\nimport * as fromRoot from './reducers';\n\nexport const REDUCER_TOKEN = new InjectionToken<ActionReducerMap<fromRoot.State>>('Registered Reducers', {\n  factory: () => {\n    const serv = inject(SomeService);\n    // return reducers synchronously\n    return serv.getReducers();\n  }\n});\n\n@NgModule({\n  imports: [StoreModule.forRoot(REDUCER_TOKEN)]\n})\nexport class AppModule {}\n\n```\n\n----------------------------------------\n\nTITLE: Updating state with patchState function\nDESCRIPTION: Demonstrates using the patchState function to perform type-safe updates on pieces of state. Shows various approaches including partial state objects and state updaters.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-state.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { patchState } from '@ngrx/signals';\n\n// 👇 Providing a partial state object.\npatchState(userState, { isAdmin: true });\n\n// 👇 Providing a partial state updater.\npatchState(userState, (state) => ({\n  user: { ...state.user, firstName: 'Jimi' },\n}));\n\n// 👇 Providing a sequence of partial state objects and/or updaters.\npatchState(\n  userState,\n  { isAdmin: false },\n  (state) => ({ user: { ...state.user, lastName: 'Hendrix' } })\n);\n```\n\n----------------------------------------\n\nTITLE: Example: Generate Entity and Register in App Module\nDESCRIPTION: Creates 'User' entity files and automatically adds the reducer as a feature state in the specified Angular module ('app.module.ts').\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/schematics/entity.md#_snippet_8\n\nLANGUAGE: sh\nCODE:\n```\nng generate entity User -m app.module.ts\n```\n\n----------------------------------------\n\nTITLE: Updating NgRx Dependencies Using CLI\nDESCRIPTION: This command updates the NgRx store package to version 8 using the Angular CLI. It leverages migration schematics to automate the upgrade process and handle breaking changes.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v8.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nng update @ngrx/store@8\n```\n\n----------------------------------------\n\nTITLE: Executing rxMethod with Static Values - NgRx Signals - TypeScript\nDESCRIPTION: Illustrates how invoking a reactive method defined with `rxMethod` using static number values triggers the RxJS operator chain for each individual call. The output is logged to the console.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/rxjs-integration.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Component, OnInit } from '@angular/core';\nimport { map, pipe, tap } from 'rxjs';\nimport { rxMethod } from '@ngrx/signals/rxjs-interop';\n\n@Component({ /* ... */ })\nexport class NumbersComponent implements OnInit {\n  readonly logDoubledNumber = rxMethod<number>(\n    pipe(\n      map((num) => num * 2),\n      tap(console.log)\n    )\n  );\n\n  ngOnInit(): void {\n    this.logDoubledNumber(1);\n    // console output: 2\n\n    this.logDoubledNumber(2);\n    // console output: 4\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing ngrx/router-store with npm\nDESCRIPTION: This command installs the @ngrx/router-store package using npm, adding it as a project dependency.  The `--save` flag adds the package to the `dependencies` section in the `package.json` file. This is a straightforward method to install the required package.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/router-store/install.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nnpm install @ngrx/router-store --save\n```\n\n----------------------------------------\n\nTITLE: Installing @ngrx/entity with npm\nDESCRIPTION: Instructs to install @ngrx/entity using npm, a popular Node.js package manager. It adds the dependency to package.json and saves it to dependencies, requiring npm to be pre-installed.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/entity/install.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\nnpm install @ngrx/entity --save\n```\n\n----------------------------------------\n\nTITLE: Correct Usage: Default Protected State in NgRx Signal Store (TypeScript)\nDESCRIPTION: This code snippet shows the preferred way to define an NgRx Signal Store using `signalStore` and `withState`. By omitting the configuration object or providing an empty one, it relies on the default behavior where `protectedState` is implicitly `true`, ensuring state integrity.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/prefer-protected-state.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst Store = signalStore(\n  withState({}),\n);\n```\n\n----------------------------------------\n\nTITLE: Using patchState Method in ComponentStore with TypeScript\nDESCRIPTION: Demonstrates how to use patchState to update partial state in a ComponentStore. Shows both direct object patching and using a callback function for more complex updates.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/component-store/write.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ninterface MoviesState {\n  movies: Movie[];\n  selectedMovieId: string | null;\n}\n\n@Component({\n  template: `...`,\n  providers: [ComponentStore],\n})\nexport class MoviesPageComponent implements OnInit {\n  constructor(\n    private readonly componentStore: ComponentStore<MoviesState>\n  ) {}\n\n  ngOnInit() {\n    this.componentStore.setState({movies: [], selectedMovieId: null});\n  }\n\n  updateSelectedMovie(selectedMovieId: string) {\n    this.componentStore.patchState({selectedMovieId});\n  }\n\n  addMovie(movie: Movie) {\n    this.componentStore.patchState((state) => ({\n      movies: [...state.movies, movie]\n    }));\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Injecting Meta-Reducers into NgRx Store using META_REDUCERS InjectionToken (TypeScript)\nDESCRIPTION: Shows how to inject middleware-like meta-reducers into the NgRx store by providing them via the META_REDUCERS injection token with multi-provider enabled. A factory function returns a meta-reducer that logs state and actions before delegating to the original reducer. Using multi: true ensures that multiple meta-reducers from different libraries or sources are correctly composed and applied.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/recipes/injecting.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ActionReducer, MetaReducer, META_REDUCERS } from '@ngrx/store';\nimport { SomeService } from './some.service';\nimport * as fromRoot from './reducers';\n\nexport function metaReducerFactory(): MetaReducer<fromRoot.State> {\n  return (reducer: ActionReducer<any>) => (state, action) => {\n    console.log('state', state);\n    console.log('action', action);\n    return reducer(state, action);\n  };\n}\n\n@NgModule({\n  providers: [\n    {\n      provide: META_REDUCERS,\n      deps: [SomeService],\n      useFactory: metaReducerFactory,\n      multi: true,\n    },\n  ],\n})\nexport class AppModule {}\n\n```\n\n----------------------------------------\n\nTITLE: Option: Specify Target Project\nDESCRIPTION: This option allows specifying the name of the Angular project where the entity files will be created, ensuring correct placement within multiple projects or libraries in a monorepo.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/schematics/entity.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n--project\n-p\n```\n\n----------------------------------------\n\nTITLE: Setting Merge Strategy in NgRx Data - TypeScript\nDESCRIPTION: This code snippet demonstrates how to use the `mergeStrategy` property to configure how NgRx Data merges entities after a query or save operation, specifically using `IgnoreChanges`.  It shows how to apply this strategy when using `EntityDispatcher` and `EntityCollectionService` and creating the `EntityAction` directly with an `EntityActionFactory`.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/entity-change-tracker.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst hero: Hero = { id: 42, name: 'Francis' };\n\ndispatcher.addOneToCache(hero, {\n  mergeStrategy: MergeStrategy.IgnoreChanges,\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst hero: Hero = { id: 42, name: 'Francis' };\n\nheroService.addOneToCache(hero, {\n  mergeStrategy: MergeStrategy.IgnoreChanges,\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst hero: Hero = { id: 42, name: 'Francis' };\n\nconst payload: EntityActionPayload = {\n  entityName: 'Hero',\n  entityOp: EntityOp.ADD_ONE,\n  data: hero,\n  mergeStrategy: MergeStrategy.IgnoreChanges,\n  // .. other options ..\n};\n\nconst action = factory.create(payload);\n```\n\n----------------------------------------\n\nTITLE: Using ngrxPush pipe in HTML template\nDESCRIPTION: This HTML snippet showcases the usage of the `ngrxPush` pipe as a drop-in replacement for the `async` pipe. It displays how to bind an observable to the view and obtain its values directly in the template. The use cases include simple display, conditional rendering, and component input binding. This approach enables simplified component updates in both zone-full and zone-less environments.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/component/push.md#_snippet_2\n\nLANGUAGE: html\nCODE:\n```\n<p>{{ number$ | ngrxPush }}</p>\n\n<ng-container *ngIf=\"number$ | ngrxPush as n\">{{ n }}</ng-container>\n\n<app-number [number]=\"number$ | ngrxPush\"></app-number>\n```\n\n----------------------------------------\n\nTITLE: Breaking Change: Removing createFeature signature with root state\nDESCRIPTION: Example showing the removal of createFeature signature with root state in favor of a simpler signature without root state.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v16.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ninterface AppState {\n  users: State;\n}\n\nexport const usersFeature = createFeature<AppState>({\n  name: 'users',\n  reducer: createReducer(initialState, /* case reducers */),\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport const usersFeature = createFeature({\n  name: 'users',\n  reducer: createReducer(initialState, /* case reducers */),\n});\n```\n\n----------------------------------------\n\nTITLE: Displaying Selected State in Angular Component Template with TypeScript and HTML\nDESCRIPTION: Shows how to consume the observable movies$ from MoviesStore in an Angular component template using the async pipe and *ngFor directive. The component injects MoviesStore and exposes movies$ to the template, rendering a list of movie names. Requires Angular framework and ComponentStore provider.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/component-store/read.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n@Component({\n  template: `\n    <li *ngFor=\"let movie of (movies$ | async)\">\n      {{ movie.name }}\n    </li>\n  `,\n  providers: [MoviesStore],\n})\nexport class MoviesPageComponent {\n  movies$ = this.moviesStore.movies$;\n\n  constructor(private readonly moviesStore: MoviesStore) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Installing ngrx/router-store with Yarn\nDESCRIPTION: This command installs the @ngrx/router-store package using Yarn.  It adds the package as a project dependency. This is a straightforward method to install the required package using Yarn.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/router-store/install.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nyarn add @ngrx/router-store\n```\n\n----------------------------------------\n\nTITLE: Allowing All Crawlers and Specifying Sitemap (robots.txt)\nDESCRIPTION: This configuration uses the `robots.txt` standard to grant unrestricted access to all web crawlers (`User-agent: *`) by leaving the `Disallow` directive empty. It also informs crawlers about the location of the site's XML sitemap via the `Sitemap` directive.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/src/extra-files/stable/robots.txt#_snippet_0\n\nLANGUAGE: robots.txt\nCODE:\n```\n# Allow all URLs (see http://www.robotstxt.org/robotstxt.html)\nUser-agent: *\nDisallow:\nSitemap: https://ngrx.io/generated/sitemap.xml\n```\n\n----------------------------------------\n\nTITLE: Installing NgRx ComponentStore with npm Shell Command\nDESCRIPTION: This shell command installs the @ngrx/component-store package using npm, adding it as a dependency to the project's package.json. It requires npm to be installed and configured. This method is manual compared to ng add and suitable for npm-based projects.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/component-store/install.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nnpm install @ngrx/component-store --save\n```\n\n----------------------------------------\n\nTITLE: Correct Usage of Async Pipe in Template - HTML\nDESCRIPTION: This snippet shows how the `async` pipe is used in a template, assuming the correct TypeScript code is present. The `async` pipe unwraps the observable `selectedItems$` and makes the data available for use within the template. This approach simplifies the template logic by handling the subscription and unsubscription lifecycle automatically. The key is the use of `{{ selectedItems$ | async }}` to subscribe to the data.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/no-store-subscription.md#_snippet_2\n\nLANGUAGE: html\nCODE:\n```\n// in template\n{{ selectedItems$ | async }}\n```\n\n----------------------------------------\n\nTITLE: Testing NgRx Reducers for Action Handling and State Updates in TypeScript\nDESCRIPTION: This snippet shows reducer unit tests asserting correct behavior when handling actions. It verifies that state reference is unchanged when unknown actions occur and that specific actions like retrievedBookList correctly update and return new state instances. These tests ensure reducer functions maintain immutability and expected state transition logic.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/testing.md#_snippet_5\n\n\n\n----------------------------------------\n\nTITLE: Implementing Ngrx Effects for Custom Router Navigation\nDESCRIPTION: Defines an Ngrx effect class (`RouterEffects`) responsible for listening to the custom router navigation actions (`GO`, `BACK`, `FORWARD`) and executing the corresponding navigation logic using the Angular `Router` and `Location` services. Effects are marked `dispatch: false` as they handle side effects (navigation) rather than dispatching new actions.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v4.md#_snippet_12\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Injectable } from '@angular/core';\nimport { Router } from '@angular/router';\nimport { Location } from '@angular/common';\nimport { Effect, Actions } from '@ngrx/effects';\nimport { map, tap } from 'rxjs/operators';\nimport * as RouterActions from './actions/router';\n\n@Injectable()\nexport class RouterEffects {\n  @Effect({ dispatch: false })\n  navigate$ = this.actions$.ofType(RouterActions.GO).pipe(\n    map((action: RouterActions.Go) => action.payload),\n    tap(({ path, query: queryParams, extras }) =>\n      this.router.navigate(path, { queryParams, ...extras })\n    )\n  );\n\n  @Effect({ dispatch: false })\n  navigateBack$ = this.actions$\n    .ofType(RouterActions.BACK)\n    .do(() => this.location.back());\n\n  @Effect({ dispatch: false })\n  navigateForward$ = this.actions$\n    .ofType(RouterActions.FORWARD)\n    .do(() => this.location.forward());\n\n  constructor(\n    private actions$: Actions,\n    private router: Router,\n    private location: Location\n  ) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Using watchState Outside of Injection Context in Angular Component\nDESCRIPTION: Demonstrates how to use watchState outside an injection context by providing an injector as a configuration option. This pattern is useful when working with SignalStore in component classes or other non-injection contexts.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/state-tracking.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Component, inject, Injector, OnInit } from '@angular/core';\nimport { watchState } from '@ngrx/signals';\nimport { CounterStore } from './counter.store';\n\n@Component({\n  /* ... */\n  providers: [CounterStore],\n})\nexport class CounterComponent implements OnInit {\n  readonly #injector = inject(Injector);\n  readonly store = inject(CounterStore);\n\n  ngOnInit(): void {\n    watchState(this.store, console.log, {\n      injector: this.#injector,\n    });\n\n    setInterval(() => this.store.increment(), 2_000);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Breaking Change: createActionGroup Before\nDESCRIPTION: Illustrates the previous implementation of `createActionGroup` where the event name's case was modified during action name generation. All letters of the event name would be lowercase, except for the initial letters of words starting from the second word, which would be uppercase.\nSOURCE: https://github.com/ngrx/platform/blob/main/CHANGELOG.md#_snippet_16\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst authApiActions = createActionGroup({\n  source: 'Auth API',\n  events: {\n    'LogIn Success': emptyProps(),\n    'login failure': emptyProps(),\n    'Logout Success': emptyProps(),\n    logoutFailure: emptyProps(),\n  },\n});\n\n// generated actions:\nconst { loginSuccess, loginFailure, logoutSuccess, logoutfailure } = authApiActions;\n```\n\n----------------------------------------\n\nTITLE: Configuring NgRx ESLint Plugin with ESLint v9\nDESCRIPTION: Sets up the NgRx ESLint Plugin in an ESLint v9 configuration file using the new flat config format with TypeScript ESLint integration and various NgRx rule configurations.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/index.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst tseslint = require('typescript-eslint');\nconst ngrx = require('@ngrx/eslint-plugin/v9');\n\nmodule.exports = tseslint.config({\n  files: ['**/*.ts'],\n  extends: [\n    // 👇 Use all rules at once\n    ...ngrx.configs.all,\n    // 👇 Or only import the rules for a specific package\n    ...ngrx.configs.store,\n    ...ngrx.configs.effects,\n    ...ngrx.configs.componentStore,\n    ...ngrx.configs.operators,\n    ...ngrx.configs.signals,\n  ],\n  rules: {\n    // 👇 Configure specific rules\n    '@ngrx/with-state-no-arrays-at-root-level': 'warn',\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Installing NgRx Operators with npm\nDESCRIPTION: This command uses `npm` to install the `@ngrx/operators` package. The `--save` flag ensures that the package is added to the `dependencies` section of the `package.json` file.  This installation method requires npm to be installed and configured correctly.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/operators/install.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nnpm install @ngrx/operators --save\n```\n\n----------------------------------------\n\nTITLE: Installing NgRx Store Devtools Using npm Shell\nDESCRIPTION: This shell snippet installs the @ngrx/store-devtools package using npm. The --save flag ensures that the dependency is added to the package.json file. This method requires manual setup for integration and configuration of the Store Devtools in the Angular application.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store-devtools/install.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nnpm install @ngrx/store-devtools --save\n```\n\n----------------------------------------\n\nTITLE: Selecting Data from NgRx Store Using Method and Operator Syntax in TypeScript\nDESCRIPTION: Demonstrates how to select data from the NgRx store using both the `store.select` method and the `store.pipe(select())` operator. The snippet illustrates an incorrect mixture of both syntaxes within the same component, which the lint rule aims to disallow for consistency and simplicity.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/select-style.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport class Component {\n  someData$ = this.store.select(someData);\n  otherData$ = this.store.pipe(select(otherData));\n}\n```\n\n----------------------------------------\n\nTITLE: Updating NgRx Effects Testing Setup in TypeScript\nDESCRIPTION: Details the changes in testing effects. The legacy `EffectsTestingModule` and `EffectsRunner` are replaced by `provideMockActions` and leveraging RxJS testing with `jasmine-marbles` (`hot`, `cold`) or a `ReplaySubject` to provide the action stream.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v4.md#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { EffectsTestingModule, EffectsRunner } from '@ngrx/effects/testing';\nimport { MyEffects } from './my-effects';\n\ndescribe('My Effects', () => {\n  let effects: MyEffects;\n  let runner: EffectsRunner;\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      imports: [EffectsTestingModule],\n      providers: [\n        MyEffects,\n        // other providers\n      ],\n    });\n\n    effects = TestBed.inject(MyEffects);\n    runner = TestBed.inject(EffectsRunner);\n  });\n\n  it('should work', () => {\n    runner.queue(SomeAction);\n\n    effects.someSource$.subscribe(result => {\n      expect(result).toBe(AnotherAction);\n    });\n  });\n});\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { TestBed } from '@angular/core/testing';\nimport { provideMockActions } from '@ngrx/effects/testing';\nimport { hot, cold } from 'jasmine-marbles';\nimport { MyEffects } from './my-effects';\nimport { ReplaySubject } from 'rxjs/ReplaySubject';\n\ndescribe('My Effects', () => {\n  let effects: MyEffects;\n  let actions: Observable<any>;\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      providers: [\n        MyEffects,\n        provideMockActions(() => actions),\n        // other providers\n      ],\n    });\n\n    effects = TestBed.inject(MyEffects);\n  });\n\n  it('should work', () => {\n    actions = hot('--a-', { a: SomeAction, ... });\n\n    const expected = cold('--b', { b: AnotherAction });\n\n    expect(effects.someSource$).toBeObservable(expected);\n  });\n\n  it('should work also', () => {\n    actions = new ReplaySubject(1);\n\n    actions.next(SomeAction);\n\n    effects.someSource$.subscribe(result => {\n      expect(result).toBe(AnotherAction);\n    });\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Registering custom EntityCollectionServices within an Angular module\nDESCRIPTION: Shows how to register custom EntityCollectionService instances during module initialization, ensuring they are available via EntityServices for injection elsewhere. Typically done in the root module to maintain singleton services.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/entity-services.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\n@NgModule({\n  imports: [...],\n  declarations: [...],\n  providers: [HeroesService]\n})\nexport class AppModule {\n  constructor(\n    entityServices: EntityServices,\n    hs: HeroesService\n  ) {\n    entityServices.registerEntityCollectionServices([hs]);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using concatLatestFrom in NgRx Effects\nDESCRIPTION: This snippet demonstrates the usage of the `concatLatestFrom` operator within an NgRx effect. It retrieves route data from the store and uses it to update the page title. The `concatLatestFrom` operator combines the result of the `routerNavigatedAction` with the latest value emitted from the `selectRouteData` selector. Dependencies include `@ngrx/effects`, `@ngrx/store`, `@ngrx/router-store`, and the Angular core library.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/operators/operators.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Injectable } from '@angular/core';\nimport { Title } from '@angular/platform-browser';\n\nimport { map, tap } from 'rxjs/operators';\n\nimport { Actions, concatLatestFrom, createEffect, ofType } from '@ngrx/effects';\nimport { Store } from '@ngrx/store';\nimport { routerNavigatedAction } from '@ngrx/router-store';\n\nimport { selectRouteData } from './router.selectors';\n\n@Injectable()\nexport class RouterEffects {\n  updateTitle$ = createEffect(() =>\n    this.actions$.pipe(\n      ofType(routerNavigatedAction),\n      concatLatestFrom(() => this.store.select(selectRouteData)),\n      map(([, data]) => `Book Collection - ${data['title']}`),\n      tap((title) => this.titleService.setTitle(title))\n    ),\n    {\n      dispatch: false,\n    }\n  );\n\n  constructor(\n    private actions$: Actions,\n    private store: Store,\n    private titleService: Title\n  ) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Creating EntityCollectionService Selector Observable from Selector Function in TypeScript\nDESCRIPTION: This TypeScript snippet illustrates how to create a selector observable named loading$ by piping the NgRx store select operator with a selector function 'selectLoading'. This pattern binds a slice of the entity collection state to an observable stream which emits new values upon state changes, facilitating reactive UI updates in Angular applications using NgRx Data.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/entity-collection-service.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nloading$ = this.store.select(selectLoading);\n```\n\n----------------------------------------\n\nTITLE: Resetting Mock Selectors Using MockStore.resetSelectors in NgRx Tests with TypeScript\nDESCRIPTION: This snippet describes resetting all overridden selectors to default behavior after each test using MockStore.resetSelectors(). This is important to ensure isolation between tests and prevent selector overrides from leaking. This practice maintains test reliability when multiple selector mocks are applied across different tests.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/testing.md#_snippet_2\n\n\n\n----------------------------------------\n\nTITLE: Building and Running NgRx Docs with Docker\nDESCRIPTION: Provides Docker commands to containerize and run the NgRx documentation application. First, build the Docker image tagged `ngrx-docs:7.4.0` from the project root. Then, run the container, mapping a chosen host port to the container's port 4200. Also includes commands for saving the built image to a tar file for offline use and loading it back.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/README.md#_snippet_3\n\nLANGUAGE: Docker\nCODE:\n```\ndocker build -t ngrx-docs:7.4.0 .\n```\n\nLANGUAGE: Docker\nCODE:\n```\ndocker run -p <host-port>:4200 ngrx-docs:7.4.0\n```\n\nLANGUAGE: Docker\nCODE:\n```\nsudo docker save ngrx-docs:7.4.0 > <tar-name>.tar\n```\n\nLANGUAGE: Docker\nCODE:\n```\nsudo docker load < <tar-name>.tar\n```\n\n----------------------------------------\n\nTITLE: Registering a Completely Custom Data Service with NgRx EntityDataService (TypeScript)\nDESCRIPTION: This concise TypeScript snippet demonstrates how to register any full custom data service for a given entity (here, 'Hero') via the entityDataService.registerService method. The custom service should conform to the EntityCollectionDataService interface, but may implement data access via any desired mechanism, such as alternate APIs or storage. This enables complete override of default CRUD operations in NgRx Data for the specified entity. No specific dependencies are required beyond adhering to the interface and having a reference to the service instance.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/entity-dataservice.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// Register custom data service\nentityDataService.registerService('Hero', peculiarHeroDataService); \n```\n\n----------------------------------------\n\nTITLE: Installing NgRx Data Nightly Build Shell\nDESCRIPTION: These commands install the latest nightly build of the NgRx Data package directly from the official NgRx GitHub builds repository. Use either npm or yarn to add the unreleased version of the package to your project dependencies.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/nightlies.md#_snippet_5\n\nLANGUAGE: Shell\nCODE:\n```\nnpm install github:ngrx/data-builds\n```\n\nLANGUAGE: Shell\nCODE:\n```\nyarn add github:ngrx/data-builds\n```\n\n----------------------------------------\n\nTITLE: Fix Commit Message Example\nDESCRIPTION: This code shows an example of a fix commit message with scope (release), subject (need to depend on latest rxjs and zone.js) and a body that provides context and motivation for the change.\nSOURCE: https://github.com/ngrx/platform/blob/main/CONTRIBUTING.md#_snippet_5\n\nLANGUAGE: text\nCODE:\n```\nfix(release): need to depend on latest rxjs and zone.js\n\nThe version in our package.json gets copied to the one we publish, and users need the latest of these.\n```\n\n----------------------------------------\n\nTITLE: Resubscribe on Errors (Before)\nDESCRIPTION: This code snippet shows an effect before the introduction of `resubscribeOnError: false`. If an error occurred within the effect's pipe, it would resubscribe by default.  This behavior is now configurable.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v8.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nlogin$ = createEffect(() =>\n  this.actions$.pipe(\n    ofType(LoginPageActions.login),\n    exhaustMap(action =>\n      this.authService.login(action.credentials).pipe(\n        map(user => AuthApiActions.loginSuccess({ user })),\n        catchError(error => of(AuthApiActions.loginFailure({ error })))\n      )\n    )\n  )\n);\n```\n\n----------------------------------------\n\nTITLE: Alternative Correct NgRx Action Props Definition with Object Structure\nDESCRIPTION: This snippet illustrates another correct pattern where inline props are used to define the expected data structure, here encapsulating user data within a 'user' property. This structure facilitates clear, type-safe action payloads without relying on separate type or interface definitions, aligning with best practices for inline type usage. Dependencies are similar: NgRx createAction and props functions. This approach enhances readability and aligns with the guidance advocating for inline types over interfaces.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/prefer-inline-action-props.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport const addUser = createAction(\n  '[Users] Add User',\n  props<{ user: User }>()\n);\n```\n\n----------------------------------------\n\nTITLE: Setting Up Live Development Environment for NgRx Docs\nDESCRIPTION: Outlines the sequence of commands to establish a live development environment with automatic rebuilding and browser reloading. Run `yarn setup` first for initial installation and doc generation. Then, in one terminal, start the development server with `yarn start`. In a second terminal, start the documentation file watcher with `yarn docs-watch`.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/README.md#_snippet_4\n\nLANGUAGE: Bash\nCODE:\n```\nyarn setup\nyarn start\n```\n\nLANGUAGE: Bash\nCODE:\n```\nyarn docs-watch\n```\n\n----------------------------------------\n\nTITLE: Defining Stackblitz Generation Options Using JSON Configuration\nDESCRIPTION: This JSON snippet defines configuration for Stackblitz example generation by specifying a description, tags, and a files array to control included and excluded files. It supports file glob patterns with negations to filter which files are part of the Stackblitz project. This config file (stackblitz.json) resides in example folders to identify them as Stackblitz examples and customize their generated projects.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/tools/stackblitz-builder/README.md#_snippet_0\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"description\": \"Tour of Heroes: Part 6\",\n  \"files\": [\"!**/*.d.ts\", \"!**/*.js\", \"!**/*.[1,2].*\"],\n  \"tags\": [\"tutorial\", \"tour\", \"heroes\", \"http\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Combining Multiple Selectors at Selector Level with NgRx - TypeScript\nDESCRIPTION: Exemplifies the recommended approach of combining multiple selectors into a single selector function using NgRx's createSelector utility. This method centralizes state derivation logic, maintaining selectors' purity and synchronicity, simplifying component code, and enhancing testability. It enriches customer data with orders or filters customers using composed selectors. Depends on NgRx store and createSelector. Inputs are base selectors for customers and orders or customer ID; output is a derived selector emitting enriched or filtered state for component consumption.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/avoid-combining-selectors.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport selectCustomersAndOrders = createSelector(\n  selectCustomers,\n  selectOrders,\n  (customers, orders) => {\n    return customers.map((c) => ({\n      customerId: c.id,\n      name: c.name,\n      orders: orders.filter((o) => o.customerId === c.id),\n    }));\n  }\n)\n\nexport class Component {\n  vm$ = this.store.select(selectCustomersAndOrders);\n}\n\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport selectActiveCustomer = createSelector(\n  selectCustomers,\n  selectActiveCustomerId,\n  (customers, customerId) => {\n    return customers[customerId];\n  }\n)\n\nexport class Component {\n  customer$ = this.store.select(selectActiveCustomer);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Testing Effects Using TestScheduler\nDESCRIPTION: This snippet showcases how to test effects using `TestScheduler`.  It sets up an actions stream with `hot`, mocks a service response with `cold`, and uses `expectObservable` to assert the effect's output matches an expected marble diagram.  This approach is particularly effective for testing the timing and sequence of actions in effects. It includes providing a stream of actions and service responses, and checking output against an expected sequence.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/effects/testing.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n// more info about the API can be found at https://rxjs.dev/guide/testing/marble-testing#api\ntestScheduler.run(({ cold, hot, expectObservable }) => {\n  // use the `hot` and `cold` helper methods to create the action and service streams\n  actions$ = hot('-a', { a : { type: '[Customers Page] Get Customers' }});\n  customersServiceSpy.getAllCustomers.and.returnValue(cold('--a|', { a: [...] }));\n\n  // use the `expectObservable` helper method to assert if the output matches the expected output\n  expectObservable(effects.getAll$).toBe('---c', {\n    c: {\n      type: '[Customers API] Get Customers Success',\n      customers: [...],\n    }\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Working with DeepSignals for nested object properties\nDESCRIPTION: Shows how SignalState generates DeepSignals for object properties, which provide signals for each property of the nested object.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-state.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst firstName = user.firstName; // type: Signal<string>\nconst lastName = user.lastName; // type: Signal<string>\n\nconsole.log(firstName()); // logs: 'Eric'\nconsole.log(lastName()); // logs: 'Clapton'\n```\n\n----------------------------------------\n\nTITLE: Registering NgRx Data Module in AppModule (TypeScript)\nDESCRIPTION: This snippet demonstrates how to integrate the `EntityDataModule` into a traditional Angular `AppModule`. It imports the module and the entity configuration, then registers `EntityDataModule.forRoot(entityConfig)` within the `imports` array, alongside standard NgRx Store and Effects modules. This sets up NgRx Data for use throughout the application.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/index.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { NgModule } from '@angular/core';\nimport { HttpClientModule } from '@angular/common/http';\nimport { EffectsModule } from '@ngrx/effects';\nimport { StoreModule } from '@ngrx/store';\nimport { DefaultDataServiceConfig, EntityDataModule } from '@ngrx/data';\nimport { entityConfig } from './entity-metadata';\n\n@NgModule({\n  imports: [\n    HttpClientModule,\n    StoreModule.forRoot({}),\n    EffectsModule.forRoot([]),\n    EntityDataModule.forRoot(entityConfig)\n  ]\n})\nexport class AppModule {}\n\n```\n\n----------------------------------------\n\nTITLE: Importing ReactiveComponentModule (Before V15) (TypeScript)\nDESCRIPTION: Shows how the `ReactiveComponentModule` from `@ngrx/component` was imported into an Angular module's `imports` array before NgRx v15. This module provided the `*ngrxLet` directive and `push` pipe. It has been removed and replaced in v15.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v15.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ReactiveComponentModule } from '@ngrx/component';\n\n@NgModule({\n  imports: [\n    // ... other imports\n    ReactiveComponentModule,\n  ],\n})\nexport class MyFeatureModule {}\n```\n\n----------------------------------------\n\nTITLE: Incorrect: Non-Dispatching Effect Triggering Side Effect on Filtered Action\nDESCRIPTION: This TypeScript snippet shows another incorrect NgRx Effect implementation according to the rule's default configuration. Although it uses `tap` for a side effect and doesn't explicitly map to an action, it implicitly dispatches the result of `tap` (which is the original action) because `dispatch: false` is not specified. This would also lead to an infinite loop.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/avoid-cyclic-effects.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nclass Effect {\n  details$ = createEffect(() => // Implicitly dispatches the source action\n    this.actions$.pipe(\n      ofType(fromCustomers.pageLoaded),\n      tap(() => alert('Customers loaded'))\n    )\n  );\n\n  constructor(private actions$: Actions) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Updating NgRx Effects Registration in Angular Module\nDESCRIPTION: Illustrates the new API for registering effects modules. `EffectsModule.run` is replaced by `EffectsModule.forRoot` for the root application module and `EffectsModule.forFeature` for feature modules, both accepting an array of effect classes.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v4.md#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\n@NgModule({\n  imports: [EffectsModule.run(SourceA), EffectsModule.run(SourceB)],\n})\nexport class AppModule {}\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\n@NgModule({\n  imports: [EffectsModule.forRoot([SourceA, SourceB, SourceC])],\n})\nexport class AppModule {}\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\n@NgModule({\n  imports: [\n    EffectsModule.forFeature([FeatureSourceA, FeatureSourceB, FeatureSourceC]),\n  ],\n})\nexport class FeatureModule {}\n```\n\n----------------------------------------\n\nTITLE: Injecting Feature Reducers into NgRx Store with Angular Dependency Injection (TypeScript)\nDESCRIPTION: Demonstrates registering feature reducers in a feature module by defining an InjectionToken with a factory function that returns a map of reducers. The token is provided via a factory provider, enabling reducer composition through dependency injection. The feature module imports StoreModule.forFeature with the provided InjectionToken to register feature reducers, supporting modular and dynamic state management.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/recipes/injecting.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { NgModule, InjectionToken } from '@angular/core';\nimport { StoreModule, ActionReducerMap } from '@ngrx/store';\n\nimport * as fromFeature from './reducers';\n\nexport const FEATURE_REDUCER_TOKEN = new InjectionToken<\n  ActionReducerMap<fromFeature.State>\n>('Feature Reducers');\n\nexport function getReducers(): ActionReducerMap<fromFeature.State> {\n  // map of reducers\n  return {};\n}\n\n@NgModule({\n  imports: [StoreModule.forFeature(fromFeature.featureKey, FEATURE_REDUCER_TOKEN)],\n  providers: [\n    {\n      provide: FEATURE_REDUCER_TOKEN,\n      useFactory: getReducers,\n    },\n  ],\n})\nexport class FeatureModule {}\n\n```\n\n----------------------------------------\n\nTITLE: Handling API Calls with rxMethod and Signals - NgRx Signals - TypeScript\nDESCRIPTION: Illustrates using `rxMethod` to fetch data based on a Signal's value. It incorporates RxJS operators like `filter` and `concatMap` and utilizes `@ngrx/operators/tapResponse` for structured API response handling.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/rxjs-integration.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Component, inject, OnInit, signal } from '@angular/core';\nimport { concatMap, filter, pipe } from 'rxjs';\nimport { rxMethod } from '@ngrx/signals/rxjs-interop';\nimport { tapResponse } from '@ngrx/operators';\nimport { Book } from './book.model';\nimport { BooksService } from './books.service';\n\n@Component({ /* ... */ })\nexport class BooksComponent implements OnInit {\n  readonly #booksService = inject(BooksService);\n\n  readonly bookMap = signal<Record<string, Book>>({});\n  readonly selectedBookId = signal<string | null>(null);\n\n  readonly loadBookById = rxMethod<string | null>(\n    pipe(\n      filter((id) => !!id && !this.bookMap()[id]),\n      concatMap((id) => {\n        return this.#booksService.getById(id).pipe(\n          tapResponse({\n            next: (book) => this.addBook(book),\n            error: console.error,\n          })\n        );\n      })\n    )\n  );\n\n  ngOnInit(): void {\n    // 👇 Load book by id whenever the `selectedBookId` value changes.\n    this.loadBookById(this.selectedBookId);\n  }\n\n  addBook(book: Book): void {\n    this.bookMap.update((bookMap) => ({ ...bookMap, [book.id]: book }));\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using SignalStore in Angular Component with Access Restrictions\nDESCRIPTION: This snippet demonstrates the usage of the previously defined CounterStore within an Angular component. It showcases how attempts to access private members (prefixed with an underscore) from outside the store result in errors, reinforcing encapsulation principles. Public members like 'count1' and 'doubleCount2' are accessible, whereas private members are intentionally restricted.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/private-store-members.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Component, inject, OnInit } from '@angular/core';\nimport { CounterStore } from './counter.store';\n\n@Component({\n  /* ... */\n  providers: [CounterStore],\n})\nexport class CounterComponent implements OnInit {\n  readonly store = inject(CounterStore);\n\n  ngOnInit(): void {\n    console.log(this.store.count1()); // ✅\n    console.log(this.store._count2()); // ❌\n\n    console.log(this.store._doubleCount1()); // ❌\n    console.log(this.store.doubleCount2()); // ✅\n\n    this.store._count2$.subscribe(console.log); // ❌\n    this.store.doubleCount1$.subscribe(console.log); // ✅\n\n    this.store.increment1(); // ✅\n    this.store._increment2(); // ❌\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Breaking Change: createActionGroup event name case preservation\nDESCRIPTION: Example showing how createActionGroup now preserves the event name case when converting to action names, with the first word starting with lowercase and maintaining case for other letters.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v16.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst authApiActions = createActionGroup({\n  source: 'Auth API',\n  events: {\n    'LogIn Success': emptyProps(),\n    'login failure': emptyProps(),\n    'Logout Success': emptyProps(),\n    logoutFailure: emptyProps(),\n  },\n});\n\n// generated actions:\nconst {\n  loginSuccess,\n  loginFailure,\n  logoutSuccess,\n  logoutfailure,\n} = authApiActions;\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst authApiActions = createActionGroup({\n  source: 'Auth API',\n  events: {\n    'LogIn Success': emptyProps(),\n    'login failure': emptyProps(),\n    'Logout Success': emptyProps(),\n    logoutFailure: emptyProps(),\n  },\n});\n\n// generated actions:\nconst {\n  logInSuccess,\n  loginFailure,\n  logoutSuccess,\n  logoutFailure,\n} = authApiActions;\n```\n\n----------------------------------------\n\nTITLE: Defining Unsafe NgRx Action Interface with Optional Any Payload in TypeScript\nDESCRIPTION: Offers an interface that extends the base NgRx `Action` with an optional `payload` property of type `any`. This can assist during transition but sacrifices type safety.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v4.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface UnsafeAction extends Action {\n  payload?: any;\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect implementation with EffectsModule.forRoot() and duplicate provider\nDESCRIPTION: This example shows incorrect code where an effect class is both added to EffectsModule.forRoot() and declared in the providers array, creating a duplicate registration.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/no-effects-in-providers.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n@NgModule({\n  imports: [EffectsModule.forRoot([CustomersEffect])],\n  providers: [CustomersEffect],\n})\nexport class AppModule {}\n```\n\n----------------------------------------\n\nTITLE: Defining Feature Selector (Incorrect) - NgRx TypeScript\nDESCRIPTION: This snippet demonstrates the incorrect usage of NgRx's `createFeatureSelector` by providing two generic type arguments. The first generic `GlobalStore` represents the entire application state, which the rule suggests is unnecessary and undesirable for a feature selector focused on a specific part of the state (`CustomersFeatureState`). This violates the rule promoting modularity.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/prefer-one-generic-in-create-for-feature-selector.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst customersFeatureState = createFeatureSelector<\n  GlobalStore,\n  CustomersFeatureState\n>('customers');\n```\n\n----------------------------------------\n\nTITLE: Installing NgRx ComponentStore with ng add Shell Command\nDESCRIPTION: This shell command uses Angular CLI's ng add to automatically add the @ngrx/component-store package into the project. It updates the project's package.json dependencies and triggers the package manager to install the new dependency. It requires Angular CLI and network access to npm registries.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/component-store/install.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nng add @ngrx/component-store@latest\n```\n\n----------------------------------------\n\nTITLE: Resubscribe on Errors (After)\nDESCRIPTION: This code snippet demonstrates how to disable the automatic resubscription behavior using the  `resubscribeOnError: false` option within the effect's metadata. This provides fine-grained control over error handling and effect lifecycle.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v8.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nlogins$ = createEffect(\n  () =>\n    this.actions$.pipe(\n      ofType(LoginPageActions.login),\n      exhaustMap(action =>\n        this.authService.login(action.credentials).pipe(\n          map(user => AuthApiActions.loginSuccess({ user })),\n          catchError(error => of(AuthApiActions.loginFailure({ error })))\n        )\n      )\n    ),\n  { resubscribeOnError: false }\n);\n```\n\n----------------------------------------\n\nTITLE: Incorrect Selector Naming Patterns for NgRx in TypeScript\nDESCRIPTION: This snippet shows examples of incorrect naming patterns for selector functions in NgRx. It highlights selectors missing the 'select' prefix, using generic names, improper casing, or alternative prefixes like 'get'. It also demonstrates improper use of createSelectorFactory without the 'select' prefix. These examples illustrate what naming conventions to avoid in order to maintain clear and consistent selector naming.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/prefix-selectors-with-select.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\n// ⚠ Usage of a selector without any prefix\nexport const feature = createSelector((state: AppState) => state.feature);\n\n// ⚠ Usage of a selector without any description\nexport const select = (id: string) =>\n  createSelector((state: AppState) => state.feature);\n\n// ⚠ Usage of a selector with a `get` prefix\nexport const getFeature: MemoizedSelector<any, any> = (state: AppState) =>\n  state.feature;\n\n// ⚠ Usage of a selector with improper casing\nconst selectfeature = createFeatureSelector<AppState, FeatureState>(featureKey);\n\n// ⚠ Usage of a `createSelectorFactory` without `select` prefix\nconst createSelector = createSelectorFactory((projectionFun) =>\n  defaultMemoize(\n    projectionFun,\n    orderDoesNotMatterComparer,\n    orderDoesNotMatterComparer\n  )\n);\n```\n\n----------------------------------------\n\nTITLE: Using tapResponse with observer in NgRx Component Store\nDESCRIPTION: This example demonstrates a second signature of the `tapResponse` operator which accepts an observer object. This provides `next`, `error`, and `finalize` callbacks. This effect retrieves movies by a query string, and then uses `tapResponse` to update the state with the movies, handle errors, and set a loading state. Dependencies include a service to fetch movies, and `@ngrx/component-store`.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/operators/operators.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\n  readonly getMoviesByQuery = this.effect<string>((query$) => {\n    return query$.pipe(\n      tap(() => this.patchState({ loading: true }),\n      switchMap((query) =>\n        this.moviesService.fetchMoviesByQuery(query).pipe(\n          tapResponse({\n            next: (movies) => this.patchState({ movies }),\n            error: (error: HttpErrorResponse) => this.logError(error),\n            finalize: () => this.patchState({ loading: false }),\n          })\n        )\n      )\n    );\n  });\n```\n\n----------------------------------------\n\nTITLE: Migrating from NgRx Component LetModule to LetDirective (ts)\nDESCRIPTION: Illustrates the migration from importing the `LetModule` in traditional Angular modules before v17 to importing the standalone `LetDirective` directly in the `imports` array of standalone components or modules after v17. This change favors Angular's move towards standalone components.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v17.md#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nimport { LetModule } from '@ngrx/component';\n\n@NgModule({\n  imports: [\n    // ... other imports\n    LetModule,\n  ],\n})\nexport class MyFeatureModule {}\n```\n\nLANGUAGE: ts\nCODE:\n```\nimport { Component } from '@angular/core';\nimport { LetDirective } from '@ngrx/component';\n \n@Component({\n  // ... other metadata\n  standalone: true,\n  imports: [\n    // ... other imports\n    LetDirective,\n  ],\n})\nexport class MyStandaloneComponent {}\n```\n\n----------------------------------------\n\nTITLE: Defining NgRx Action Group with createActionGroup (TypeScript)\nDESCRIPTION: This snippet demonstrates how to define a group of NgRx actions for a feature ('Products Page') using the `createActionGroup` function. It shows defining actions with no payload (`emptyProps`), with a typed object payload (`props`), and with a payload generated by a factory function. The `source` property defines the shared prefix for action types, and the `events` object maps event names to payload definitions.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/action-groups.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createActionGroup, emptyProps, props } from '@ngrx/store';\n\nexport const ProductsPageActions = createActionGroup({\n  source: 'Products Page',\n  events: {\n    // defining an event without payload using the `emptyProps` function\n    'Opened': emptyProps(),\n\n    // defining an event with payload using the `props` function\n    'Pagination Changed': props<{ page: number; offset: number }>(),\n\n    // defining an event with payload using the props factory\n    'Query Changed': (query: string) => ({ query }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Grouping Dependencies in SignalStore with withProps\nDESCRIPTION: This example shows how to use withProps to group dependencies required across multiple store features, including service injections that can be accessed throughout the store. It demonstrates integrating these dependencies in methods and lifecycle hooks.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/custom-store-properties.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { inject } from '@angular/core';\nimport { signalStore, withProps, withState } from '@ngrx/signals';\nimport { Logger } from './logger';\nimport { Book } from './book.model';\nimport { BooksService } from './books.service';\n\ntype BooksState = {\n  books: Book[];\n  isLoading: boolean;\n};\n\nexport const BooksStore = signalStore(\n  withState<BooksState>({ books: [], isLoading: false }),\n  withProps(() => ({\n    booksService: inject(BooksService),\n    logger: inject(Logger),\n  })),\n  withMethods(({ booksService, logger, ...store }) => ({\n    async loadBooks(): Promise<void> {\n      logger.debug('Loading books...');\n      patchState(store, { isLoading: true });\n      \n      const books = await booksService.getAll();\n      logger.debug('Books loaded successfully', books);\n      \n      patchState(store, { books, isLoading: false });\n    },\n  })),\n  withHooks({\n    onInit({ logger }) {\n      logger.debug('BooksStore initialized');\n    },\n  }),\n);\n```\n\n----------------------------------------\n\nTITLE: Defining the EntityActionPayload Interface in TypeScript for NgRx Data\nDESCRIPTION: This snippet details the EntityActionPayload interface which extends EntityActionOptions to include mandatory properties for NgRx Data actions such as the entity name, operation type, and optionally data. It specifies fields that control action correlation, optimistic updates, merging strategies, tagging, error reporting, and skipping downstream processing, supporting robust management of entity-related actions.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/entity-actions.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface EntityActionPayload<P = any> extends EntityActionOptions {\n  readonly entityName: string;\n  readonly entityOp: EntityOp;\n  readonly data?: P;\n\n  // EntityActionOptions (also an interface)\n  readonly correlationId?: any;\n  readonly isOptimistic?: boolean;\n  readonly mergeStrategy?: MergeStrategy;\n  readonly tag?: string;\n  error?: Error;\n  skip?: boolean\n}\n```\n\n----------------------------------------\n\nTITLE: Installing NgRx Schematics with npm\nDESCRIPTION: Install @ngrx/schematics as a development dependency using npm. This adds the package to your project's devDependencies in package.json.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/schematics/install.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nnpm install @ngrx/schematics --save-dev\n```\n\n----------------------------------------\n\nTITLE: Unsubscribing from rxMethod (Before Rename)\nDESCRIPTION: Demonstrates the previous way of cleaning up subscriptions created by `rxMethod` using the `unsubscribe` method. This applied both to individual subscription references (e.g., `num1Ref.unsubscribe()`) and the `rxMethod` itself (`logNumber.unsubscribe()`) before the API change in NgRx Signals 19.0.0-beta.0.\nSOURCE: https://github.com/ngrx/platform/blob/main/CHANGELOG.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst logNumber = rxMethod<number>(tap(console.log));\n\nconst num1Ref = logNumber(interval(1_000));\nconst num2Ref = logNumber(interval(2_000));\n\n// destroy `num1Ref` after 2 seconds\nsetTimeout(() => num1Ref.unsubscribe(), 2_000);\n\n// destroy all reactive method refs after 5 seconds\nsetTimeout(() => logNumber.unsubscribe(), 5_000);\n```\n\n----------------------------------------\n\nTITLE: Manual Cleanup of watchState in NgRx SignalStore\nDESCRIPTION: Shows how to manually clean up a state watcher created with watchState before the injector is destroyed. This example creates a counter that increments every second but stops watching after 5 seconds by calling the destroy method returned by watchState.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/state-tracking.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport {\n  patchState,\n  signalStore,\n  watchState,\n  withHooks,\n  witMethods,\n  withState,\n} from '@ngrx/signals';\n\nexport const CounterStore = signalStore(\n  withState({ count: 0 }),\n  withMethods((store) => ({\n    increment(): void {\n      patchState(store, { count: store.count() + 1 });\n    },\n  })),\n  withHooks({\n    onInit(store) {\n      const { destroy } = watchState(store, console.log);\n\n      setInterval(() => store.increment(), 1_000);\n\n      // 👇 Stop watching after 5 seconds.\n      setTimeout(() => destroy(), 5_000);\n    },\n  })\n);\n```\n\n----------------------------------------\n\nTITLE: Registering EntityMetadataMap with ENTITY_METADATA_TOKEN (TypeScript)\nDESCRIPTION: This code shows how to register metadata for eagerly-loaded modules using the `ENTITY_METADATA_TOKEN` multi-provider. This allows adding metadata for each module separately.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/entity-metadata.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n{ provide: ENTITY_METADATA_TOKEN, multi: true, useValue: someEntityMetadata }\n```\n\n----------------------------------------\n\nTITLE: *ngrxLet Suspense Behavior in V15 (TypeScript)\nDESCRIPTION: Provides an Angular component example showing the updated behavior of `*ngrxLet` in v15 regarding suspense states. When the button is clicked and `obs$` is replaced by a delayed observable, the view managed by `*ngrxLet` (`<p>`) is cleared immediately. It is only re-rendered once the new observable emits its first value after the delay.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v15.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n@Component({\n  template: `\n    <!-- When button is clicked, the 'LetDirective' view will be cleared. -->\n    <!-- The view will be created again when the replaced observable -->\n    <!-- emits the first value (after 1 second). -->\n    <p *ngrxLet=\"obs$ as o\">{{ o }}</p>\n    <button (click)=\"replaceObs()\">Replace Observable</button>\n  `\n})\nexport class TestComponent {\n  obs$ = of(1);\n  \n  replaceObs(): void {\n    this.obs$ = of(2).pipe(delay(1000));\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Destroying rxMethod References Using destroy (Post-Version 19) - NgRx TypeScript\nDESCRIPTION: This TypeScript snippet shows NgRx v19-compliant rxMethod cleanup, using the new 'destroy' method to terminate individual and grouped references. Required dependencies include rxMethod (from NgRx), tap (rxjs), and interval (rxjs). The sample uses setTimeout to call 'destroy' after specific intervals. This approach is necessary after upgrading to ensure compatibility and prevent memory leaks.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v19.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst logNumber = rxMethod<number>(tap(console.log));\n\nconst num1Ref = logNumber(interval(1_000));\nconst num2Ref = logNumber(interval(2_000));\n\n// destroy `num1Ref` after 2 seconds\nsetTimeout(() => num1Ref.destroy(), 2_000);\n\n// destroy all reactive method refs after 5 seconds\nsetTimeout(() => logNumber.destroy(), 5_000);\n```\n\n----------------------------------------\n\nTITLE: Installing NgRx Schematics with Angular CLI\nDESCRIPTION: Use the Angular CLI's 'ng add' command to install @ngrx/schematics and make it the default schematic collection for your application. This automatically adds @ngrx/schematics to the schematicCollections in angular.json.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/schematics/install.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nng add @ngrx/schematics@latest\n```\n\n----------------------------------------\n\nTITLE: Installing NgRx Router Store Nightly Build Shell\nDESCRIPTION: These commands install the latest nightly build of the NgRx Router Store package directly from the official NgRx GitHub builds repository. Use either npm or yarn to add the unreleased version of the package to your project dependencies.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/nightlies.md#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\nnpm install github:ngrx/router-store-builds\n```\n\nLANGUAGE: Shell\nCODE:\n```\nyarn add github:ngrx/router-store-builds\n```\n\n----------------------------------------\n\nTITLE: Installing NgRx Entity Nightly Build Shell\nDESCRIPTION: These commands install the latest nightly build of the NgRx Entity package directly from the official NgRx GitHub builds repository. Use either npm or yarn to add the unreleased version of the package to your project dependencies.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/nightlies.md#_snippet_4\n\nLANGUAGE: Shell\nCODE:\n```\nnpm install github:ngrx/entity-builds\n```\n\nLANGUAGE: Shell\nCODE:\n```\nyarn add github:ngrx/entity-builds\n```\n\n----------------------------------------\n\nTITLE: Example Usage of Data Entity Generation Command in Angular CLI using shell\nDESCRIPTION: This snippet demonstrates example commands to generate a 'User' data entity with various folder structuring and test spec generation options. The first command generates standard data entity files with test specs. The second command generates a User entity inside a nested folder by setting '--flat false'. The third command groups the entity files inside a 'data' folder with '--group' option. These examples help developers tailor the scaffolding output according to project organization needs.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/schematics/data.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nng generate data User\n```\n\nLANGUAGE: shell\nCODE:\n```\nng generate data User --flat false\n```\n\nLANGUAGE: shell\nCODE:\n```\nng generate data User --group\n```\n\n----------------------------------------\n\nTITLE: Defining NgRx State Interface (Scoreboard Example) - TypeScript\nDESCRIPTION: Defines the TypeScript interface for the state managed by the scoreboard reducer. This interface specifies the structure and types of the data held in this part of the application state.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/reducers.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Action, createReducer, on } from '@ngrx/store';\nimport * as ScoreboardPageActions from '../actions/scoreboard-page.actions';\n\nexport interface State {\n  home: number;\n  away: number;\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating tapResponse Import in NgRx Component Store\nDESCRIPTION: Breaking change in NgRx v18.0.0-rc.0: The `tapResponse` operator is removed from `@ngrx/component-store`. Update imports to use the `@ngrx/operators` package instead. This aligns operator sourcing with other NgRx packages like effects.\nSOURCE: https://github.com/ngrx/platform/blob/main/CHANGELOG.md#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { tapResponse } from '@ngrx/component-store';\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { tapResponse } from '@ngrx/operators';\n```\n\n----------------------------------------\n\nTITLE: Generating a Grouped User Feature with Reducers Registration - Shell\nDESCRIPTION: Creates a 'User' NgRx feature and places its actions, effects, reducer, and selectors within grouped folders, registering it in a specified reducers file. The '--group' option nests the files, while '--reducers reducers/index.ts' tells the CLI to update the reducers mapping, requiring that reducers/index.ts define the state interface and action reducer map. This setup supports better organization for larger projects.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/schematics/feature.md#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\nng generate feature User --group --reducers reducers/index.ts\n```\n\n----------------------------------------\n\nTITLE: MemoizedSelector Typing (After)\nDESCRIPTION: This code snippet illustrates the correct typing for MemoizedSelector in version 8. It explicitly specifies the return type to match the actual type of the value returned by the selector function.  This is a direct fix for the breaking change.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v8.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport const getLoginPagePending: MemoizedSelector<State, boolean> = createSelector(\n  selectLoginPageState,\n  loginState => loginState.pending // boolean\n);\n```\n\n----------------------------------------\n\nTITLE: Example angular.json with Angular and @ngrx/schematics Collections\nDESCRIPTION: Shows the `cli.schematicCollections` property in `angular.json` when both the default Angular schematics (`@schematics/angular`) and NgRx schematics (`@ngrx/schematics`) are registered. This allows using generators from both collections without prefixes, typically with Angular's taking precedence.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/schematics/index.md#_snippet_6\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"cli\": {\n     \"schematicCollections\": [\"@schematics/angular\", \"@ngrx/schematics\"],\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: EntityAdapter upsertOne After Change (TypeScript)\nDESCRIPTION: Demonstrates the usage of `entityAdapter.upsertOne` *after* a breaking change in the NgRx EntityAdapter API. It shows how to pass the complete entity object directly, simplifying the update process.\nSOURCE: https://github.com/ngrx/platform/blob/main/CHANGELOG.md#_snippet_48\n\nLANGUAGE: typescript\nCODE:\n```\nentityAdapter.upsertOne(\n    {\n      id: 'Entity ID',\n      name: 'Entity Name',\n    },\n    state\n  );\n```\n\n----------------------------------------\n\nTITLE: Import tapResponse operator from @ngrx/operators\nDESCRIPTION: This code snippet shows the updated import statement for the `tapResponse` operator, which has been moved to the `@ngrx/operators` package. The component store no longer exports `tapResponse`.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v18.md#_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\nimport { tapResponse  } from '@ngrx/operators';\n```\n\n----------------------------------------\n\nTITLE: Creating Book Service for API Calls in TypeScript\nDESCRIPTION: Defines an Angular service (`BooksService`) responsible for fetching book data. It uses Angular's `HttpClient` to make a GET request to the Google Books API and returns an `Observable` of `Book[]`.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/walkthrough.md#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Code from src/app/book-list/books.service.ts\n// Service to fetch book data from the Google Books API.\n```\n\n----------------------------------------\n\nTITLE: Declaring a Login Success Action as POJO in JSON\nDESCRIPTION: This snippet represents a plain JavaScript object action—a POJO—to indicate a successful login event. The 'type' field uses the '[Auth API] Login Success' convention, clarifying the event source and its description. No additional properties are included, making this suitable for signaling simple success without extra payload. No dependencies or constraints; this follows the action structure expected by NgRx reducers and effects.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/actions.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"type\": \"[Auth API] Login Success\"\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating StoreRouterConnectingModule.forRoot() Usage in Angular NgRx (TypeScript)\nDESCRIPTION: Demonstrates the required migration for enabling the use of the StoreRouterConnectingModule with the forRoot() method in Angular NgRx. The code shows the before and after configurations within the @NgModule decorator's imports array, indicating that usage of forRoot() has become mandatory. This change improves module setup consistency and aligns with the updated router-store module specification. The snippet depends on Angular NgModules and NgRx router-store package.\nSOURCE: https://github.com/ngrx/platform/blob/main/CHANGELOG.md#_snippet_44\n\nLANGUAGE: typescript\nCODE:\n```\n@NgModule({\n  imports: [StoreRouterConnectingModule],\n})\nexport class AppModule {}\n\n```\n\nLANGUAGE: typescript\nCODE:\n```\n@NgModule({\n  imports: [StoreRouterConnectingModule.forRoot()],\n})\nexport class AppModule {}\n\n```\n\n----------------------------------------\n\nTITLE: Alternative Registration of NgRx Effects (TypeScript)\nDESCRIPTION: Example showing an alternative way to register effects using the USER_PROVIDED_EFFECTS provider token with multi property set to true.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/effects/index.md#_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nproviders: [\n  MoviesEffects,\n  {\n    provide: USER_PROVIDED_EFFECTS,\n    multi: true,\n    useValue: [MoviesEffects],\n  },\n]\n```\n\n----------------------------------------\n\nTITLE: Fixing Stricter Effects Typing in NgRx Version 10 using TypeScript\nDESCRIPTION: This TypeScript snippet shows the corrected pattern for defining an NgRx effect that returns an EMPTY observable. By passing the config object { dispatch: false } to createEffect, it explicitly informs the system that the effect does not dispatch any actions, thus satisfying the stricter typing requirements introduced in NgRx version 10.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v10.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nsomeEffect$ = createEffect(() => EMPTY, { dispatch: false })\n```\n\n----------------------------------------\n\nTITLE: Defining the NgRx Action Interface in TypeScript\nDESCRIPTION: This snippet shows the base Action interface used in NgRx for TypeScript applications. Every action must have a 'type' property, represented as a string, which describes the event being dispatched. All other metadata can be added as extra properties, but 'type' is required; this pattern provides consistent structure for all actions, enabling type-checking and tooling integration. No dependencies are required beyond TypeScript.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/actions.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Action {\n  type: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Refactoring Effects Error Handling Metadata in TypeScript\nDESCRIPTION: This snippet demonstrates the renaming of the effects error handler configuration key in createEffect metadata from 'resubscribeOnError' to 'useEffectsErrorHandler'. It is part of a breaking change to improve error handling configuration in NgRx Effects. The TypeScript class MyEffects shows usage of createEffect with the updated metadata key, which affects how effects resubscription on error is managed. This change requires updating existing effect classes to use the new property to maintain functionality.\nSOURCE: https://github.com/ngrx/platform/blob/main/CHANGELOG.md#_snippet_37\n\nLANGUAGE: TypeScript\nCODE:\n```\nclass MyEffects {\n  effect$ = createEffect(() => stream$, {\n    resubscribeOnError: true, // default\n  });\n}\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nclass MyEffects {\n  effect$ = createEffect(() => stream$, {\n    useEffectsErrorHandler: true, // default\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Example angular.json with @ngrx/schematics Collection\nDESCRIPTION: Illustrates the relevant section of the `angular.json` file after configuring `@ngrx/schematics` as the sole default schematic collection using the `ng config` command. This setup simplifies invoking NgRx generators.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/schematics/index.md#_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"cli\": {\n     \"schematicCollections\": [\"@ngrx/schematics\"]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Selector with Props in NgRx Store - TypeScript (Deprecated)\nDESCRIPTION: This TypeScript snippet shows the older method of creating a selector with additional props as an argument using NgRx's createSelector function. The selector fetches a customer by customerId from the customers object, where props is an object containing the parameter. This pattern has been deprecated in favor of factory selectors and may not be compatible with future NgRx versions.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v12.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nconst selectCustomer = createSelector(\n    selectCustomers,\n    (customers, props: { customerId: number }) => {\n      return customers[props.customerId];\n    }\n);\n\n// Or if the selector is already defined as a factory selector\n\nconst selectCustomer = () =>\n  createSelector(\n    selectCustomers,\n    (customers, props: { customerId: number }) => {\n      return customers[props.customerId];\n    }\n  );\n```\n\n----------------------------------------\n\nTITLE: Initial Game State Example - JSON\nDESCRIPTION: This JSON snippet represents the initial state of a game, containing the scores for home and away teams. The `game` object is initialized within the store. It is a simple state object that is managed within the application's store.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/reducers.md#_snippet_13\n\nLANGUAGE: json\nCODE:\n```\n{\n  game: { home: 0, away: 0 }\n}\n```\n\n----------------------------------------\n\nTITLE: Running NgRx Library Module Tests with Yarn (sh)\nDESCRIPTION: This command executes the test suite for the NgRx library modules. It's a critical step before pushing new commits to ensure that code changes haven't introduced regressions or broken existing functionality. This command should be run from the root project folder. Requires `yarn`.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/marketing/contributing.md#_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\nyarn test\n```\n\n----------------------------------------\n\nTITLE: Example Commit Message Structure\nDESCRIPTION: Illustrates the standard format for a commit message, including the header `type(scope): subject`, and the footer section demonstrating how to document `BREAKING CHANGES` along with optional `BEFORE` and `AFTER` code examples to clarify the impact.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/marketing/contributing.md#_snippet_6\n\nLANGUAGE: text\nCODE:\n```\nfeat(scope): commit message\n\nBREAKING CHANGES:\n\nDescribe breaking changes here\n\nBEFORE:\n\nPrevious code example here\n\nAFTER:\n\nNew code example here\n```\n\n----------------------------------------\n\nTITLE: Breaking Change: Strongly typed createFeature selectors\nDESCRIPTION: Example showing how projector function arguments of selectors generated by createFeature are now strongly typed, providing better type safety.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v16.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst counterFeature = createFeature({\n  name: 'counter',\n  reducer: createReducer({ count: 0 }),\n});\n\ncounterFeature.selectCount.projector\n// ^ type: (...args: any[]) => number\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst counterFeature = createFeature({\n  name: 'counter',\n  reducer: createReducer({ count: 0 }),\n});\n\ncounterFeature.selectCount.projector\n// ^ type: (featureState: { count: number; }) => number\n```\n\n----------------------------------------\n\nTITLE: Defining Entity Type and State Interface Extending NgRx EntityState - TypeScript\nDESCRIPTION: This example shows how to define a domain entity interface (`User`) and a specific state interface (`State`) that extends the generic `EntityState<User>`. Extending `EntityState` allows adding custom properties like `selectedUserId` while inheriting the standard `ids` and `entities` properties managed by the EntityAdapter. This demonstrates how to structure your application state for entities using NgRx Entity.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/entity/interfaces.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface User {\n  id: string;\n  name: string;\n}\n\nexport interface State extends EntityState<User> {\n  // additional entity state properties\n  selectedUserId: string | null;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Feature Module Effects with EffectsModule.forFeature (TypeScript)\nDESCRIPTION: Illustrates the registration of several feature-scoped effects using EffectsModule.forFeature() in an Angular feature module. Requires @ngrx/effects, @angular/core, and the specific feature effect classes. The input is an array of feature effect classes to be run within the feature's scope. Output is an Angular module with feature state effects configured. This method supports modularizing effect logic and is required post-migration to the new Effects API.\nSOURCE: https://github.com/ngrx/platform/blob/main/CHANGELOG.md#_snippet_51\n\nLANGUAGE: TypeScript\nCODE:\n```\n@NgModule({\n  imports: [EffectsModule.forFeature([FeatureSourceA, FeatureSourceB, FeatureSourceC])],\n})\nexport class SomeFeatureModule {}\n```\n\n----------------------------------------\n\nTITLE: Generate NgRx Selector - Command Syntax - sh\nDESCRIPTION: This snippet shows the general command syntax for generating an NgRx selector using the Angular CLI. It requires a selector name and accepts various options to control the generation process and file location.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/schematics/selector.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nng generate selector selectorName [options]\n```\n\nLANGUAGE: sh\nCODE:\n```\nng generate se selectorName [options]\n```\n\n----------------------------------------\n\nTITLE: Generating a Reducer in a Nested Folder (sh)\nDESCRIPTION: Example command demonstrating how to generate a 'User' reducer within a dedicated subfolder named 'user'. This overrides the default behavior of creating the file directly in the current path by setting the `--flat` option to `false`.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/schematics/reducer.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nng generate reducer User --flat false\n```\n\n----------------------------------------\n\nTITLE: Installing @ngrx/signals with ng add (Angular CLI)\nDESCRIPTION: This snippet demonstrates installing the @ngrx/signals package using the Angular CLI's `ng add` command.  The command automatically updates `package.json` dependencies and runs the package manager to install the required packages. Requires the Angular CLI to be installed and a valid Angular project.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/install.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nng add @ngrx/signals@latest\n```\n\n----------------------------------------\n\nTITLE: Providing and Injecting an NgRx SignalStore Locally in an Angular Component\nDESCRIPTION: Shows how to provide the `BooksStore` within the `providers` array of an Angular component (`BooksComponent`). The store is then injected into the component using the `inject` function, making it available for managing component-level state.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/index.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Component, inject } from '@angular/core';\nimport { BooksStore } from './books.store';\n\n@Component({\n  /* ... */\n  // 👇 Providing `BooksStore` at the component level.\n  providers: [BooksStore],\n})\nexport class BooksComponent {\n  readonly store = inject(BooksStore);\n}\n```\n\n----------------------------------------\n\nTITLE: Effects: Resubscribe on Error Example After\nDESCRIPTION: This snippet is the 'after' code demonstrating how to disable automatic resubscription for an effect in ngrx.  It shows the effect is configured with `{ resubscribeOnError: false }` to prevent automatic resubscription on errors. This is the recommended approach if you handle errors and do not want automatic resubscriptions.\nSOURCE: https://github.com/ngrx/platform/blob/main/CHANGELOG.md#_snippet_43\n\nLANGUAGE: TypeScript\nCODE:\n```\nlogin$ = createEffect(\n  () =>\n    this.actions$.pipe(\n      ofType(LoginPageActions.login),\n      mapToAction(\n        // Happy path callback\n        (action) => this.authService.login(action.credentials).pipe(map((user) => AuthApiActions.loginSuccess({ user }))),\n        // error callback\n        (error) => AuthApiActions.loginFailure({ error })\n      )\n      // Errors are handled and it is safe to disable resubscription\n    ),\n  { resubscribeOnError: false }\n);\n\n```\n\n----------------------------------------\n\nTITLE: Registering NgRx Data Providers with Standalone API (TypeScript)\nDESCRIPTION: This snippet shows how to configure NgRx Data using Angular's standalone application API. It uses `provideEntityData` with the `entityConfig` and `withEffects()` within the `providers` array passed to `bootstrapApplication`. This method achieves the same registration as the module approach but without an `NgModule`.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/index.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { bootstrapApplication } from '@angular/platform-browser';\nimport { provideHttpClient } from '@angular/common/http';\nimport { provideStore } from '@ngrx/store';\nimport { provideEffects } from '@ngrx/effects';\nimport { provideEntityData, withEffects } from '@ngrx/data';\n\nimport { AppComponent } from './app.component';\nimport { entityConfig } from './entity-metadata';\n\nbootstrapApplication(AppComponent, {\n  providers: [\n    provideHttpClient(),\n    provideStore(),\n    provideEffects(),\n    provideEntityData(entityConfig, withEffects())\n  ],\n});\n\n```\n\n----------------------------------------\n\nTITLE: Defining Hero Entity Model in TypeScript\nDESCRIPTION: This TypeScript snippet defines the Hero class, which serves as an entity model for NgRx Data operations. It specifies required properties including id (number), name (string), saying (string), and an additional dateLoaded (Date) property used to track when the entity was loaded. This class is foundational for typed data interactions in the application, and is intended to be extended or instantiated as part of data service operations.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/entity-dataservice.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport class Hero {\n  readonly id: number;\n  readonly name: string;\n  readonly saying: string;\n  readonly dateLoaded: Date;\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling State Protection in NgRx SignalStore in TypeScript\nDESCRIPTION: Demonstrates how to configure a SignalStore with `protectedState: false` to allow external modifications directly via `patchState`. It shows an example within a component method where `patchState` is called on the injected store instance, bypassing the store's own methods. This approach is generally discouraged.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/index.md#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport const BooksStore = signalStore(\n  { protectedState: false }, // 👈\n  withState(initialState)\n);\n\n@Component({ /* ... */ })\nexport class BooksComponent {\n  readonly store = inject(BooksStore);\n\n  addBook(book: Book): void {\n    // ⚠️ The state of the `BooksStore` is unprotected from external modifications.\n    patchState(this.store, ({ books }) => ({ books: [...books, book] }));\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Managing rxMethod Lifecycle with Injector - NgRx Signals - TypeScript\nDESCRIPTION: Explains the automatic cleanup of reactive methods within their creation injector context. It shows how to provide an explicit `injector` option when calling a reactive method from a different injection context to ensure proper cleanup.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/rxjs-integration.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Component, inject, Injectable, Injector, OnInit } from '@angular/core';\nimport { tap } from 'rxjs';\nimport { rxMethod } from '@ngrx/signals/rxjs-interop';\n\n@Injectable({ providedIn: 'root' })\nexport class NumbersService {\n  readonly log = rxMethod<number>(tap(console.log));\n}\n\n@Component({ /* ... */ })\nexport class NumbersComponent implements OnInit {\n  readonly #injector = inject(Injector);\n  readonly #numbersService = inject(NumbersService);\n\n  constructor() {\n    const num1$ = interval(1_000);\n    // 👇 Automatic cleanup when component is destroyed.\n    this.#numbersService.log(num1$);\n  }\n\n  ngOnInit(): void {\n    const num2$ = interval(2_000);\n    // 👇 Requires injector for cleanup when component is destroyed.\n    this.#numbersService.log(num2$, { injector: this.#injector });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a BooksStore with RxJS-based loadByQuery method in Angular\nDESCRIPTION: This snippet defines a SignalStore for managing books data, incorporating RxJS operators via rxMethod to implement the loadByQuery method. It sets up state, computed signals for derived data, and methods to handle query updates and book loading asynchronously. Dependencies include @ngrx/signals and rxjs libraries, with BooksService for API calls.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/index.md#_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { computed, inject } from '@angular/core';\nimport { debounceTime, distinctUntilChanged, pipe, switchMap, tap } from 'rxjs';\nimport { patchState, signalStore, /* ... */ } from '@ngrx/signals';\nimport { rxMethod } from '@ngrx/signals/rxjs-interop';\nimport { tapResponse } from '@ngrx/operators';\nimport { Book } from './book.model';\nimport { BooksService } from './books.service';\n\ntype BooksState = { /* ... */ };\n\nconst initialState: BooksState = { /* ... */ };\n\nexport const BooksStore = signalStore(\n  withState(initialState),\n  withComputed(/* ... */),\n  withMethods((store, booksService = inject(BooksService)) => ({\n    /* ... */\n    // 👇 Defining a method to load books by query.\n    loadByQuery: rxMethod<string>(\n      pipe(\n        debounceTime(300),\n        distinctUntilChanged(),\n        tap(() => patchState(store, { isLoading: true })),\n        switchMap((query) => {\n          return booksService.getByQuery(query).pipe(\n            tapResponse({\n              next: (books) => patchState(store, { books, isLoading: false }),\n              error: (err) => {\n                patchState(store, { isLoading: false });\n                console.error(err);\n              },\n            })\n          );\n        })\n      )\n    ),\n  }))\n);\n```\n\n----------------------------------------\n\nTITLE: Changing Default Router State Serializer in TypeScript\nDESCRIPTION: This snippet conveys a breaking change where the default router state serializer switches from DefaultRouterStateSerializer to MinimalRouterStateSerializer if none is configured. The change affects how router state is serialized within NgRx Router Store, optimizing performance or payload size. No direct code snippet for the serializer class is shown here, but the context indicates that modules using router-store must expect different default behavior post-upgrade.\nSOURCE: https://github.com/ngrx/platform/blob/main/CHANGELOG.md#_snippet_39\n\n\n\n----------------------------------------\n\nTITLE: Defining Entity State with Entity Adapter in NgRx - TypeScript\nDESCRIPTION: This snippet defines the user-related entity state using NgRx Entity Adapter, creating a typed State interface that extends EntityState for User entities. It sets up the initial state structure, with an adapter for User and an additional selectedUserId property. Dependencies include @ngrx/entity and a User model, and the initial state is configured to support both entity management and selection tracking.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/entity/recipes/entity-adapter-with-feature-creator.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { EntityState, createEntityAdapter } from '@ngrx/entity';\nimport { User } from './user.model';\n\nexport interface State extends EntityState<User> {\n  selectedUserId: string | null;\n}\n\nconst adapter = createEntityAdapter<User>();\n\nexport const initialState: State = adapter.getInitialState({\n  selectedUserId: null,\n});\n\n```\n\n----------------------------------------\n\nTITLE: Registering Multiple Effects with EffectsModule.forRoot (TypeScript)\nDESCRIPTION: Shows the updated method for registering multiple effects at the application root using EffectsModule.forRoot() with an array of effect classes in Angular NgRx. Requires @ngrx/effects and Angular module setup. Inputs are an array of effect classes; output is an Angular module configured for global effects handling. The method enhances scalability and reduces boilerplate, and is the mandatory approach after the breaking changes.\nSOURCE: https://github.com/ngrx/platform/blob/main/CHANGELOG.md#_snippet_50\n\nLANGUAGE: TypeScript\nCODE:\n```\n@NgModule({\n  imports: [EffectsModule.forRoot([SourceA, SourceB, SourceC])],\n})\nexport class AppModule {}\n```\n\n----------------------------------------\n\nTITLE: Refactoring SignalStoreFeature with Props (After)\nDESCRIPTION: Demonstrates the updated implementation of a signal store feature using `withComputed` and `EntityProps` after the breaking change in NgRx 19.0.0-rc.0. The `computed` property key is replaced with `props`, and the `EntityComputed` type is renamed to `EntityProps`.\nSOURCE: https://github.com/ngrx/platform/blob/main/CHANGELOG.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { computed, Signal } from '@angular/core';\nimport { signalStoreFeature, SignalStoreFeature, type, withComputed } from '@ngrx/signals';\nimport { EntityProps } from '@ngrx/signals/entities';\n\nexport function withTotalEntities<Entity>(): SignalStoreFeature<{ state: {}; props: EntityProps<Entity>; methods: {} }, { state: {}; props: { total: Signal<number> }; methods: {} }> {\n  return signalStoreFeature(\n    { props: type<EntityProps<Entity>>() },\n    withComputed(({ entities }) => ({\n      total: computed(() => entities().length),\n    }))\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Updating NgRx Packages Using Angular CLI\nDESCRIPTION: This snippet demonstrates how to update NgRx store dependencies to version 9 using the Angular CLI command `ng update`, which ensures the project uses the latest compatible versions with minimal manual intervention.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v9.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nng update @ngrx/store@9\n```\n\n----------------------------------------\n\nTITLE: Extending NgRx Data - Registering EntityCollectionReducerMethodsFactory\nDESCRIPTION: This snippet provides an example of how to register the `AdditionalEntityCollectionReducerMethodsFactory` within an NgModule. This allows the customized reducer methods to be used instead of the default ones, enabling the code to handle extra properties in the entity collection. It utilizes the `provide` and `useClass` configuration within an NgModule's providers array.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/entity-metadata.md#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\n@NgModule({\n  {\n    provide: EntityCollectionReducerMethodsFactory,\n    useClass: AdditionalEntityCollectionReducerMethodsFactory\n  },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Book List Component Template (HTML)\nDESCRIPTION: HTML template for the `BookListComponent`. It iterates over a list of books (`*ngFor=\"let book of books | async\"`) and displays book information. Includes a button for each book to trigger the `(add)` output event.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/walkthrough.md#_snippet_8\n\nLANGUAGE: HTML\nCODE:\n```\n<!-- Code from src/app/book-list/book-list.component.html -->\n<!-- Displays the list of books with an 'Add to Collection' button. -->\n```\n\n----------------------------------------\n\nTITLE: Configuring Example Type with JSON\nDESCRIPTION: This JSON snippet represents the configuration file `example-config.json` that specifies the type of boilerplate required by an example application. The `projectType` field determines which boilerplate files are copied into the example folder.  Dependencies are managed separately using symlinks, and a shared `node_modules` directory is utilized.  The script handles copying boilerplate based on the configured project type.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/tools/examples/README.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"projectType\": \"universal\"\n}\n```\n\n----------------------------------------\n\nTITLE: Using *ngrxLet Directive for Observable Binding in Angular\nDESCRIPTION: Illustrates using the `*ngrxLet` directive as a more robust alternative to `*ngIf` with the `async` pipe for binding observables (`number$`). It correctly handles falsy values and simplifies the template syntax. Both the `as n` and `let n` syntax variations for assigning the emitted value to a template variable are shown.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/component/let.md#_snippet_2\n\nLANGUAGE: html\nCODE:\n```\n<ng-container *ngrxLet=\"number$ as n\">\n  <app-number [number]=\"n\"></app-number>\n</ng-container>\n\n<ng-container *ngrxLet=\"number$; let n\">\n  <app-number [number]=\"n\"></app-number>\n</ng-container>\n```\n\n----------------------------------------\n\nTITLE: Migrating NgRx Effects Using Action Payload in TypeScript\nDESCRIPTION: Demonstrates how to handle effects that access the `payload` property after it was removed from the base `Action` interface. The recommended approach is to use the `ofType<ActionType>` operator to provide type information and allow access to type-safe properties like `payload`.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v4.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Action } from '@ngrx/store';\nimport { Observable } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport { Effect, Actions } from '@ngrx/effects';\n\n@Injectable()\nexport class MyEffects {\n  @Effect()\n  someEffect$: Observable<Action> = this.actions$\n    .ofType(UserActions.LOGIN)\n    .pipe(\n      map(action => action.payload),\n      map(() => new AnotherAction())\n    );\n\n  constructor(private actions$: Actions) {}\n}\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Action } from '@ngrx/store';\nimport { Observable } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport { Effect, Actions } from '@ngrx/effects';\nimport { Login } from '../actions/auth';\n\n@Injectable()\nexport class MyEffects {\n  @Effect()\n  someEffect$: Observable<Action> = this.actions$\n    .ofType<Login>(UserActions.LOGIN)\n    .pipe(\n      map(action => action.payload),\n      map(() => new AnotherAction())\n    );\n\n  constructor(private actions$: Actions) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Implementation: Using a Single Action with Multiple Effects in NgRx\nDESCRIPTION: This example demonstrates the recommended pattern where a single action is dispatched from the component, and multiple effects respond to that action to perform the required operations.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/avoid-dispatching-multiple-actions-sequentially.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\n// in component code:\nexport class Component implement OnInit {\n  constructor(\n    private readonly store: Store,\n  ) {}\n\n  ngOnInit() {\n    this.store.dispatch(componentLoaded());\n  }\n}\n\n// in effect:\nexport class Effects {\n\n  loadEmployeeList$ = createEffect(() => this.actions.pipe(\n    ofType(componentLoaded),\n    exhaustMap(() => this.dataService.loadEmployeeList().pipe(\n      map(response => loadEmployeeListSuccess(response)),\n      catchError(error => loadEmployeeListError(error)),\n    )),\n  ));\n\n  loadCompanyList$ = createEffect(() => this.actions.pipe(\n    ofType(componentLoaded),\n    // handle loadCompanyList\n  ));\n\n  cleanData$ = createEffect(() => this.actions.pipe(\n    ofType(componentLoaded),\n    // handle cleanData\n  ));\n\n  constructor(\n    private readonly actions$: Actions,\n  ) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Type Safety Enforcement for Selector Projector Functions in NgRx\nDESCRIPTION: This snippet shows the enforcement of strict type safety for the projector function within NgRx selectors. It highlights how, after the update, passing arguments with incorrect types causes a compile-time error, thereby enhancing robustness of selector logic. It also demonstrates how to bypass strict typing using 'any' if needed.\nSOURCE: https://github.com/ngrx/platform/blob/main/CHANGELOG.md#_snippet_25\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst mySelector = createSelector(\n  () => 'one',\n  () => 2,\n  (one, two) => 3\n);\n\nmySelector.projector(); // <- type is projector(...args: any[]): number\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst mySelector = createSelector(\n  () => 'one',\n  () => 2,\n  (one, two) => 3\n);\n\nmySelector.projector(); // <- Results in type error. Type is projector(s1: string, s2: number): number\n\n// To retain previous behavior\nconst result = mySelector.projector as any;\nresult(1, 'a', true); // no compile-time error due to 'any'\n\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of Selected Entity Feature in BooksStore with ngrx/signals (TypeScript)\nDESCRIPTION: This code demonstrates an incorrect usage of the `withSelectedEntity` feature. It highlights that if the store does not have the `EntityState` properties (e.g., because it doesn't use `withEntities`), a compilation error will occur.  This showcases the type safety provided by NgRx Signals.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/custom-store-features.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { signalStore } from '@ngrx/signals';\nimport { withSelectedEntity } from './selected-entity.feature';\nimport { Book } from './book.model';\n\nexport const BooksStore = signalStore(\n  withState({ books: [] as Book[], isLoading: false }),\n  // Error: `EntityState` properties (`entityMap` and `ids`) are missing in the `BooksStore`.\n  withSelectedEntity()\n);\n```\n\n----------------------------------------\n\nTITLE: Selecting Router State (@ngrx/router-store v11+ Optimization)\nDESCRIPTION: Shows the optimized behavior of `selectQueryParams` and `selectFragment` selectors in `@ngrx/router-store` version 11 and later. They now select query parameters and the fragment directly from the root node of the router state tree, providing more predictable behavior.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v11.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst queryParams$ = this.store.select(selectQueryParams);\nconst fragment$ = this.store.select(selectFragment);\n\n/*\nrouter state:\n{\n  root: {\n    queryParams: {\n      search: 'foo', 👈 query parameters are selected from here\n    },\n    fragment: 'bar', 👈 fragment is selected from here\n    firstChild: {\n      queryParams: {\n        search: 'foo',\n      },\n      fragment: 'bar',\n      firstChild: undefined,\n    },\n  },\n  url: '/books?search=foo#bar',\n}\n*/\n```\n\n----------------------------------------\n\nTITLE: Correct updater method with explicit return type in TypeScript\nDESCRIPTION: This snippet presents an updater method that correctly declares its return type as 'MoviesState', ensuring type safety. The method explicitly specifies the return type in its arrow function, which enforces that the function output matches the state interface and helps catch type mismatches during development.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/updater-explicit-return-type.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\ninterface MoviesState {\n  movies: Movie[];\n}\n\nclass MoviesStore extends ComponentStore<MoviesState> {\n  readonly addMovie = this.updater(\n    (state, movie: Movie): MoviesState => ({\n      movies: [...state.movies, movie],\n      // ⚠ this does throw\n      extra: 'property',\n    })\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using Entity Service in Angular Component (TypeScript)\nDESCRIPTION: This snippet demonstrates how an Angular component consumes an NgRx Data entity service (`HeroService`). It injects the service, accesses its observables (`entities$` and `loading$`), and calls its methods (`getAll`, `add`, `delete`, `update`) to perform data operations. This pattern abstracts away the underlying NgRx state management details from the component.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/index.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Component, OnInit } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { Hero } from '../../core';\nimport { HeroService } from '../hero.service';\n\n@Component({\n  selector: 'app-heroes',\n  templateUrl: './heroes.component.html',\n  styleUrls: ['./heroes.component.scss']\n})\nexport class HeroesComponent implements OnInit {\n  loading$: Observable<boolean>;\n  heroes$: Observable<Hero[]>;\n\n  constructor(private heroService: HeroService) {\n    this.heroes$ = heroService.entities$;\n    this.loading$ = heroService.loading$;\n  }\n\n  ngOnInit() {\n    this.getHeroes();\n  }\n\n  add(hero: Hero) {\n    this.heroService.add(hero);\n  }\n\n  delete(hero: Hero) {\n    this.heroService.delete(hero.id);\n  }\n\n  getHeroes() {\n    this.heroService.getAll();\n  }\n\n  update(hero: Hero) {\n    this.heroService.update(hero);\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Operator to Select State Transition History (TypeScript)\nDESCRIPTION: Defines a function `selectLastStateTransitions` that accepts a count and returns a custom RxJS pipeable operator. This operator uses NgRx `select` with the memoized `selectProjectedValues` selector and the RxJS `scan` operator to accumulate the last `count` non-undefined state values into an array, effectively tracking state history. Requires an explicit type hint for the accumulator in `scan`.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/selectors.md#_snippet_17\n\nLANGUAGE: TypeScript\nCODE:\n```\n// The number of state transitions is given by the user (subscriber)\nexport const selectLastStateTransitions = (count: number) => {\n\n  return pipe(\n   // Thanks to `createSelector` the operator will have memoization \"for free\"\n   select(selectProjectedValues),\n   // Combines the last `count` state values in array\n   scan((acc, curr) => {\n      return [ curr, ...acc ].filter((val, index) => index < count && val !== undefined)\n    }, [] as {foo: number; bar: string}[]) // XX: Explicit type hint for the array.\n                                          // Equivalent to what is emitted by the selector\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: SignalStore with Static Input Compilation Error TypeScript\nDESCRIPTION: This code demonstrates a common TypeScript compilation error when combining multiple custom features with static input in an ngrx/signals SignalStore. The error occurs when custom features accept input but don't define generic parameters. The code shows a failing example where withZ and withW are combined.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/custom-store-features.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nfunction withZ() {\n  return signalStoreFeature(\n    { state: type<{ x: number }>() },\n    withState({ z: 10 })\n  );\n}\n\nfunction withW() {\n  return signalStoreFeature(\n    { state: type<{ y: number }>() },\n    withState({ w: 100 })\n  );\n}\n\nconst Store = signalStore(\n  withState({ x: 10, y: 100 }),\n  withZ(),\n  withW()\n); // ❌ compilation error\n```\n\n----------------------------------------\n\nTITLE: Defining Entities with NgRx Data Metadata (TypeScript)\nDESCRIPTION: This snippet defines the metadata for entities ('Hero', 'Villain') that NgRx Data will manage using `EntityMetadataMap`. It specifies the entity types and can include configurations like custom plural names. This configuration is the foundation for NgRx Data to generate the necessary NgRx artifacts for these entities.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { EntityMetadataMap } from '@ngrx/data';\n\nconst entityMetadata: EntityMetadataMap = {\n  Hero: {},\n  Villain: {}\n};\n\n// because the plural of \"hero\" is not \"heros\"\nconst pluralNames = { Hero: 'Heroes' };\n\nexport const entityConfig = {\n  entityMetadata,\n  pluralNames\n};\n\n```\n\n----------------------------------------\n\nTITLE: Using Deprecated createFeature Signature with Root State (TypeScript)\nDESCRIPTION: Demonstrates the deprecated signature of `createFeature` from `@ngrx/store` (used before v15.2). This signature required explicitly passing the root application state interface (e.g., `AppState`) as a generic type parameter, coupling the feature definition to the global state structure.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v15.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\ninterface AppState {\n  users: State;\n}\n\nexport const usersFeature = createFeature<AppState>({\n  name: 'users',\n  reducer: createReducer(initialState, /* case reducers */),\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Actions Using createAction in NgRx - TypeScript\nDESCRIPTION: This snippet demonstrates the preferred way to define actions using NgRx's `createAction` function, which promotes a more concise and standardized method. It also shows examples of classes that do not implement Action and thus are acceptable within the coding guidelines, indicating focus on action creator usage for action definitions.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/prefer-action-creator.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport const loadUser = createAction('[User Page] Load User');\n\nclass Test {\n  type = '[Customer Page] Load Customer';\n}\n\nclass Test implements Action {\n  member = '[Customer Page] Load Customer';\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Signal Store Feature Definition (TypeScript)\nDESCRIPTION: This snippet shows correct examples of Signal Store features in TypeScript, using a generic type to define the feature state. This approach enables better type safety and allows for more flexible state management. The code employs `signalStoreFeature`, `withState`, and `type` to define and initialize the feature, correctly using generic types (Y or _) for state definitions.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/signal-store-feature-should-use-generic-type.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst withY = <Y>() => signalStoreFeature(\n  { state: type<{ y: Y }>() },\n  withState({})\n);\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst withY = <_>() => {\n  return signalStoreFeature(\n    type<{ state: { y: number } }>(),\n    withState({})\n  );\n};\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction withY<_>() {\n  return signalStoreFeature(\n    { state: type<{ y: Y }>() },\n    withState({})\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Features for NgRx Store DevTools in TypeScript\nDESCRIPTION: TypeScript configuration object for enabling or disabling specific features in the Redux DevTools browser extension. This controls capabilities like pausing recording, locking actions, state persistence, and time-traveling functionality.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store-devtools/config.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nfeatures: {\n  pause: true, // start/pause recording of dispatched actions\n  lock: true, // lock/unlock dispatching actions and side effects    \n  persist: true, // persist states on page reloading\n  export: true, // export history of actions in a file\n  import: 'custom', // import history of actions from a file\n  jump: true, // jump back and forth (time travelling)\n  skip: true, // skip (cancel) actions\n  reorder: true, // drag and drop actions in the history list \n  dispatch: true, // dispatch custom actions or action creators\n  test: true // generate tests for the selected actions\n},\n```\n\n----------------------------------------\n\nTITLE: Merging Action and TypedAction Interfaces in NgRx Store\nDESCRIPTION: Breaking change introduced around NgRx v18.0.0-beta.0: The `Action` and `TypedAction` interfaces in `@ngrx/store` have been merged. The `Action` interface now accepts an optional generic type parameter for the payload (defaulting to string), and the separate `TypedAction` interface has been removed. Refactor action definitions to use the updated `Action` interface.\nSOURCE: https://github.com/ngrx/platform/blob/main/CHANGELOG.md#_snippet_9\n\nLANGUAGE: Text\nCODE:\n```\nBEFORE:\n\nThere was a separation between the Action and TypedAction interfaces.\n```\n\nLANGUAGE: Text\nCODE:\n```\nAFTER:\n\nThe Action interface accepts a generic type parameter that represents the payload type (defaults to string).\nThe TypedAction interface is removed.\n```\n\n----------------------------------------\n\nTITLE: Correct Usage of Async Pipe - TypeScript\nDESCRIPTION: This code snippet demonstrates the preferred method of subscribing to store data using the `async` pipe in an Angular template.  The `selectedItems$` observable is declared within the component and the template is simplified using the `async` pipe. The template will automatically manage subscription and unsubscription, preventing memory leaks. This approach keeps the template clean and declarative.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/no-store-subscription.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\n// in code\nselectedItems$ = this.store.select(selectedItems)\n```\n\n----------------------------------------\n\nTITLE: Overwriting NgRx Entity State with setAll (Current) - NgRx Entity - TypeScript\nDESCRIPTION: Shows the recommended replacement for addAll when replacing all entities in NgRx Entity state using setAll. Requires @ngrx/entity and a correctly initialized adapter. The method expects an array of entities and the current state; it returns a new state where all previous entities are replaced. This reflects the improved, intention-revealing API.\nSOURCE: https://github.com/ngrx/platform/blob/main/CHANGELOG.md#_snippet_34\n\nLANGUAGE: TypeScript\nCODE:\n```\nadapter.setAll(action.entities, state);\n```\n\n----------------------------------------\n\nTITLE: Creating a Conditional NgRx Selector with `createSelector` (TypeScript)\nDESCRIPTION: Illustrates defining an NgRx selector `selectProjectedValues` using `createSelector`. This selector depends on two other selectors (`selectFoo`, `selectBar`) and projects a combined object `{ foo, bar }` only if both input slices (`foo` and `bar`) are truthy. Otherwise, it returns `undefined`.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/selectors.md#_snippet_16\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport const selectProjectedValues = createSelector(\n  selectFoo,\n  selectBar,\n  (foo, bar) => {\n    if (foo && bar) {\n      return { foo, bar };\n    }\n\n    return undefined;\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: Exposing Observables from SignalStore using withProps\nDESCRIPTION: This example demonstrates how to use withProps to expose RxJS observables from a SignalStore, creating integration points with RxJS-based APIs by converting a signal to an observable.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/custom-store-properties.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { toObservable } from '@angular/core/rxjs-interop';\nimport { signalStore, withProps, withState } from '@ngrx/signals';\nimport { Book } from './book.model';\n\ntype BooksState = {\n  books: Book[];\n  isLoading: boolean;\n};\n\nexport const BooksStore = signalStore(\n  withState<BooksState>({ books: [], isLoading: false }),\n  withProps(({ isLoading }) => ({\n    isLoading$: toObservable(isLoading),\n  })),\n);\n```\n\n----------------------------------------\n\nTITLE: Resetting MockStore in Jasmine Tests - TypeScript\nDESCRIPTION: Snippet demonstrating how to manually reset the `MockStore` using an `afterEach` hook in Jasmine test suites. This replaces the automatic reset behavior from previous versions and is applicable when `TestBed` is not automatically torn down.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v13.md#_snippet_7\n\nLANGUAGE: ts\nCODE:\n```\nimport { getTestBed } from '@angular/core/testing';\nimport { MockStore } from '@ngrx/store/testing';\n\nafterEach(() => {\n  getTestBed().inject(MockStore, null)?.resetSelectors();\n});\n```\n\n----------------------------------------\n\nTITLE: Using --skipTests Option for Angular Schematics - Angular CLI - Shell\nDESCRIPTION: Displays the updated method for omitting test file generation when using Angular's generate schematic for containers. Applicable with CLI after the skipTest to skipTests renaming and expects the user to run the command from a compatible project directory. Ensures no test spec files are included.\nSOURCE: https://github.com/ngrx/platform/blob/main/CHANGELOG.md#_snippet_36\n\nLANGUAGE: Shell\nCODE:\n```\nng generate container UsersPage --skipTests\n```\n\n----------------------------------------\n\nTITLE: Ngrx Entity Selector Types (After v17) in TypeScript\nDESCRIPTION: Shows the updated, strongly-typed return types from `adapter.getSelectors` (with a parent selector) in NgRx v17. Selectors are now correctly typed as `MemoizedSelector<object, T>`, providing better type safety and integration with NgRx Store.\nSOURCE: https://github.com/ngrx/platform/blob/main/CHANGELOG.md#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nconst {\n  selectIds, // type: MemoizedSelector<object, string[] | number[]>\n  selectEntities, // type: MemoizedSelector<object, Dictionary<Book>>\n  selectAll, // type: MemoizedSelector<object, Book[]>\n  selectTotal, // type: MemoizedSelector<object, number>\n} = adapter.getSelectors(selectBooksState);\n```\n\n----------------------------------------\n\nTITLE: Configuring Ngrx Store Devtools (Conditional/Current API)\nDESCRIPTION: Demonstrates the recommended approach for configuring `StoreDevtoolsModule` using the `instrument` method. It shows how to conditionally include the module in the application's `imports` array only when the environment is not production, preventing its inclusion in production builds.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v4.md#_snippet_14\n\nLANGUAGE: TypeScript\nCODE:\n```\n`app.module.ts`\n\nimport { StoreDevtoolsModule } from '@ngrx/store-devtools';\nimport { environment } from '../environments/environment'; // Angular CLI environment\n\n@NgModule({\n  imports: [\n    !environment.production\n      ? StoreDevtoolsModule.instrument({ maxAge: 50 })\n      : [],\n  ],\n})\nexport class AppModule {}\n```\n\n----------------------------------------\n\nTITLE: Updating NgRx Component Module Imports for Angular\nDESCRIPTION: This code snippet illustrates the migration from 'ReactiveComponentModule' to 'LetModule' and 'PushModule' in NgRx, reflecting a breaking change aimed at improving component module usage. It demonstrates the before-and-after imports within an Angular NgModule configuration, highlighting dependency management for reactive components.\nSOURCE: https://github.com/ngrx/platform/blob/main/CHANGELOG.md#_snippet_24\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { ReactiveComponentModule } from '@ngrx/component';\n\n@NgModule({\n  imports: [\n    // ... other imports\n    ReactiveComponentModule,\n  ],\n})\nexport class MyFeatureModule {}\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { LetModule, PushModule } from '@ngrx/component';\n\n@NgModule({\n  imports: [\n    // ... other imports\n    LetModule,\n    PushModule,\n  ],\n})\nexport class MyFeatureModule {}\n```\n\n----------------------------------------\n\nTITLE: Using Selected Entity Feature in BooksStore with ngrx/signals (TypeScript)\nDESCRIPTION: This code shows how to integrate the `withSelectedEntity` feature into a `BooksStore`.  It requires that the store also uses `withEntities` to provide the necessary `EntityState` properties.  This example shows a correct usage of the `withSelectedEntity` feature.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/custom-store-features.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { signalStore } from '@ngrx/signals';\nimport { withEntities } from '@ngrx/signals/entities';\nimport { withSelectedEntity } from './selected-entity.feature';\nimport { Book } from './book.model';\n\nexport const BooksStore = signalStore(\n  withEntities<Book>(),\n  withSelectedEntity()\n);\n```\n\n----------------------------------------\n\nTITLE: Generating Ngrx Container Component (Shell)\nDESCRIPTION: Provides the basic command syntax for generating a container component using the ngrx schematic. It includes the full command name and its shorthand alias. The `ComponentName` placeholder should be replaced with the desired name for the component, and `[options]` represents optional flags.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/schematics/container.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nng generate container ComponentName [options]\n```\n\nLANGUAGE: sh\nCODE:\n```\nng generate co ComponentName [options]\n```\n\n----------------------------------------\n\nTITLE: Executing Yarn Development Tasks for NgRx Docs\nDESCRIPTION: Provides a list of common Yarn commands used within the `projects/ngrx.io` directory to manage dependencies, build the application, run tests (unit, e2e), lint code, generate documentation, and manage code examples (boilerplate, StackBlitz, zips). These commands streamline the development workflow for the NgRx documentation project.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/README.md#_snippet_0\n\nLANGUAGE: Bash\nCODE:\n```\nyarn\n```\n\nLANGUAGE: Bash\nCODE:\n```\nyarn setup\n```\n\nLANGUAGE: Bash\nCODE:\n```\nyarn build\n```\n\nLANGUAGE: Bash\nCODE:\n```\nyarn start\n```\n\nLANGUAGE: Bash\nCODE:\n```\nyarn serve-and-sync\n```\n\nLANGUAGE: Bash\nCODE:\n```\nyarn lint\n```\n\nLANGUAGE: Bash\nCODE:\n```\nyarn test\n```\n\nLANGUAGE: Bash\nCODE:\n```\nyarn test --watch=false\n```\n\nLANGUAGE: Bash\nCODE:\n```\nyarn e2e\n```\n\nLANGUAGE: Bash\nCODE:\n```\nyarn docs\n```\n\nLANGUAGE: Bash\nCODE:\n```\nyarn docs-watch\n```\n\nLANGUAGE: Bash\nCODE:\n```\nyarn docs-lint\n```\n\nLANGUAGE: Bash\nCODE:\n```\nyarn docs-test\n```\n\nLANGUAGE: Bash\nCODE:\n```\nyarn boilerplate:add\n```\n\nLANGUAGE: Bash\nCODE:\n```\nyarn boilerplate:remove\n```\n\nLANGUAGE: Bash\nCODE:\n```\nyarn generate-stackblitz\n```\n\nLANGUAGE: Bash\nCODE:\n```\nyarn generate-zips\n```\n\nLANGUAGE: Bash\nCODE:\n```\nyarn example-e2e\n```\n\nLANGUAGE: Bash\nCODE:\n```\nyarn example-e2e --setup\n```\n\nLANGUAGE: Bash\nCODE:\n```\nyarn example-e2e --filter=foo\n```\n\nLANGUAGE: Bash\nCODE:\n```\nyarn example-e2e --setup --local\n```\n\n----------------------------------------\n\nTITLE: Renaming Angular Workspace Schematic Option --skipTest to --skipTests - Angular CLI - Shell\nDESCRIPTION: Illustrates the migration of the Angular schematic CLI option from --skipTest to --skipTests, which impacts code generation of containers with the Angular CLI. Requires Angular CLI v10.0.0-beta.1 or above. Inputs are the shell commands issued during generation; this affects whether the generated files include test specs.\nSOURCE: https://github.com/ngrx/platform/blob/main/CHANGELOG.md#_snippet_35\n\nLANGUAGE: Shell\nCODE:\n```\nng generate container UsersPage --skipTest\n```\n\n----------------------------------------\n\nTITLE: Remove concatLatestFrom operator from @ngrx/effects\nDESCRIPTION: This code snippet demonstrates the removal of the `concatLatestFrom` operator from `@ngrx/effects` and its replacement with the version from `@ngrx/operators`. This change requires updating the import statement.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v18.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport { concatLatestFrom } from '@ngrx/effects';\n```\n\n----------------------------------------\n\nTITLE: Generating a New Angular Project (Bash)\nDESCRIPTION: Uses the globally installed Angular CLI (`ng` command) to create a new, standard Angular application named 'dummy'. This newly generated project serves as the source for the updated boilerplate files needed for the ngrx examples.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/tools/examples/shared/boilerplate/UPDATING_CLI.md#_snippet_1\n\nLANGUAGE: Bash\nCODE:\n```\nng new dummy\n```\n\n----------------------------------------\n\nTITLE: Overwriting NgRx Entity State with addAll (Deprecated) - NgRx Entity - TypeScript\nDESCRIPTION: Demonstrates the previous approach for overwriting the entire NgRx Entity state using the addAll method. Requires the @ngrx/entity package and existing entity state structure. Inputs are the list of entities and the current state; output is the updated state object. The addAll method is now considered deprecated due to naming confusion.\nSOURCE: https://github.com/ngrx/platform/blob/main/CHANGELOG.md#_snippet_33\n\nLANGUAGE: TypeScript\nCODE:\n```\nadapter.addAll(action.entities, state);\n```\n\n----------------------------------------\n\nTITLE: Enrich state with other state in component (incorrect approach)\nDESCRIPTION: Demonstrates an incorrect pattern where multiple state slices are combined directly within a component using combineLatest, which can lead to potential performance issues and less maintainable code.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/avoid-combining-component-store-selectors.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport class Component extends ComponentStore<MoviesState> {\n  all$ = combineLatest(\n    this.select((state) => state.movies),\n    this.select((state) => state.books)\n  );\n\n  constructor() {\n    super({ movies: [], books: [] });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Attempting to Mutate Frozen Signal State (After Freezing)\nDESCRIPTION: Shows the behavior after the breaking change in NgRx Signals 19.0.0-beta.0, where attempting to mutate the state object directly within `patchState` (e.g., `state.user.firstName = 'mutable change'`) now throws an error in development mode due to state freezing.\nSOURCE: https://github.com/ngrx/platform/blob/main/CHANGELOG.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst userState = signalState(initialState);\npatchState(userState, (state) => {\n  state.user.firstName = 'mutable change'; // throws in dev mode\n  return state;\n});\n```\n\n----------------------------------------\n\nTITLE: Installing NgRx Dependencies using yarn\nDESCRIPTION: Command to install core NgRx libraries (store, effects, entity, store-devtools) as project dependencies using the yarn package manager. This adds the specified packages to the project's dependencies.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/schematics/index.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nyarn add @ngrx/{store,effects,entity,store-devtools}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Effect implementation without OnRunEffects interface - TypeScript\nDESCRIPTION: This example showcases an incorrect implementation of `ngrxOnRunEffects` without implementing the `OnRunEffects` interface. This can cause issues and is flagged by the rule. It showcases the use of `actions$` and `resolvedEffects$` observables within the function.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/use-effects-lifecycle-interface.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nclass Effect {\n  constructor(private actions$: Actions) {}\n\n  ngrxOnRunEffects(resolvedEffects$: Observable<EffectNotification>) {\n    return this.actions$.pipe(\n      ofType('LOGGED_IN'),\n      exhaustMap(() =>\n        resolvedEffects$.pipe(\n          takeUntil(this.actions$.pipe(ofType('LOGGED_OUT')))\n        )\n      )\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating from NgRx Component PushModule to PushPipe (ts)\nDESCRIPTION: Shows the change from importing the `PushModule` in traditional Angular modules before v17 to importing the standalone `PushPipe` directly in the `imports` array of Angular modules after v17. This aligns with Angular's preference for standalone pipes.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v17.md#_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nimport { PushModule } from '@ngrx/component';\n\n@NgModule({\n  imports: [\n    // ... other imports\n    PushModule,\n  ],\n})\nexport class MyFeatureModule {}\n```\n\nLANGUAGE: ts\nCODE:\n```\nimport { PushPipe } from '@ngrx/component';\n\n@NgModule({\n  imports: [\n    // ... other imports\n    PushPipe,\n  ],\n})\nexport class MyFeatureModule {}\n```\n\n----------------------------------------\n\nTITLE: Using Built-in Ngrx Router Navigation Actions (Deprecated)\nDESCRIPTION: Demonstrates the older approach (before Ngrx v4+) where built-in actions like `go`, `back`, and `forward` from `@ngrx/router-store` were used directly to trigger navigation. These actions are no longer provided in newer versions.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v4.md#_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { go, back, forward } from '@ngrx/router-store';\n\nstore.dispatch(\n  go(['/path', { routeParam: 1 }], { page: 1 }, { replaceUrl: false })\n);\n\nstore.dispatch(back());\n\nstore.dispatch(forward());\n```\n\n----------------------------------------\n\nTITLE: Running Consolidated Live Development for NgRx Docs\nDESCRIPTION: Presents the `yarn serve-and-sync` command as a convenient alternative for setting up the live development environment. This single command handles building the application, watching source files for changes, and serving the documentation viewer, consolidating the actions of `yarn start` and `yarn docs-watch` into one terminal process.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/README.md#_snippet_5\n\nLANGUAGE: Bash\nCODE:\n```\nyarn serve-and-sync\n```\n\n----------------------------------------\n\nTITLE: Setting Navigation Action Timing in NgRx Router Store Configuration in TypeScript\nDESCRIPTION: Illustrates configuring the router store feature to dispatch ROUTER_NAVIGATION actions after route activation, instead of the default pre-activation timing. Changing navigationActionTiming in provideRouterStore affects when navigation-related actions are dispatched relative to Angular guards and resolvers.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/router-store/configuration.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nprovideRouterStore({\n  navigationActionTiming: NavigationActionTiming.PostActivation,\n});\n```\n\n----------------------------------------\n\nTITLE: Deprecation: PushModule in favor of standalone PushPipe\nDESCRIPTION: Example showing the migration from deprecated PushModule to the standalone PushPipe in both NgModule and standalone component contexts.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v16.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { PushModule } from '@ngrx/component';\n\n@NgModule({\n  imports: [\n    // ... other imports\n    PushModule,\n  ],\n})\nexport class MyFeatureModule {}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { PushPipe } from '@ngrx/component';\n\n@NgModule({\n  imports: [\n    // ... other imports\n    PushPipe,\n  ],\n})\nexport class MyFeatureModule {}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Component } from '@angular/core';\nimport { PushModule } from '@ngrx/component';\n\n@Component({\n  // ... other metadata\n  standalone: true,\n  imports: [\n    // ... other imports\n    PushModule,\n  ],\n})\nexport class MyStandaloneComponent {}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Component } from '@angular/core';\nimport { PushPipe } from '@ngrx/component';\n\n@Component({\n  // ... other metadata\n  standalone: true,\n  imports: [\n    // ... other imports\n    PushPipe,\n  ],\n})\nexport class MyStandaloneComponent {}\n```\n\n----------------------------------------\n\nTITLE: Injecting a SignalStore into an Angular component via constructor\nDESCRIPTION: This code demonstrates how to declare and export a SignalStore type and how to inject the store into an Angular component using constructor injection. This pattern facilitates dependency injection of store instances for state management within Angular components.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/faq.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\n```ts\n// counter.store.ts\nexport const CounterStore = signalStore(withState({ count: 0 }));\n\nexport type CounterStore = InstanceType<typeof CounterStore>;\n\n// counter.component.ts\nimport { CounterStore } from './counter.store';\n\n@Component({ /* ... */ })\nexport class CounterComponent {\n  constructor(readonly store: CounterStore) {}\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Serializability Violation: Functions in Actions\nDESCRIPTION: This shows a `strictActionSerializability` violation, where a function (`logTodo`) is included as a property on an action. Functions cannot be serialized, which is required if you're using features like the Redux DevTools or persisting actions.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/configuration/runtime-checks.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst createTodo = createAction('[Todo List] Add new todo', todo => ({\n  todo,\n  // Violation, a function is not serializable\n  logTodo: () => {\n    console.log(todo);\n  },\n}));\n```\n```\n\n----------------------------------------\n\nTITLE: Example of Duplicate Action Handlers in NgRx Reducer (Incorrect)\nDESCRIPTION: This code snippet shows an incorrect implementation where the same action (customerLoaded) is handled twice within a createReducer function, which can lead to bugs or unintended behavior. It emphasizes the importance of only handling an action once unless justified by specific use cases like higher-order reducers.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/avoid-duplicate-actions-in-reducer.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport const reducer = createReducer(\n  initialState,\n  on(customerLoaded, (state) => ({ ...state, status: 'loaded' })),\n  on(customerLoaded, (state) => ({ ...state, status: 'loaded' }))\n);\n```\n\n----------------------------------------\n\nTITLE: Router Store Usage (Before)\nDESCRIPTION: This code snippet illustrates the usage of `StoreRouterConnectingModule` before the `forRoot` method was made mandatory. This would produce an error if the `forRoot` method was not used in version 8.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v8.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n@NgModule({\n  imports: [\n    StoreRouterConnectingModule\n  ]\n})\nexport class AppModule {}\n```\n\n----------------------------------------\n\nTITLE: Downgrading and Using NgRx Store in AngularJS Controller\nDESCRIPTION: Demonstrates how to make the Angular NgRx Store service available in AngularJS using `downgradeInjectable`. It shows importing necessary modules (`Store`, `downgradeInjectable`, AngularJS `module`), creating an AngularJS factory ('ngrxStoreService') for the downgraded service, and then injecting and using this service within an AngularJS controller to dispatch actions (`ngrxStoreService.dispatch`) and select state slices (`ngrxStoreService.select`). Requires `@ngrx/store` and `@angular/upgrade/static` dependencies.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/recipes/downgrade.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { Store } from '@ngrx/store';\nimport { downgradeInjectable } from '@angular/upgrade/static';\nimport { module as ngModule } from 'angular';\n// app\nimport { MyActionClass } from 'path/to.my/file.action';\nimport { mySelectorFunction } from 'path/to.my/file.selector';\n\n// Using the `downgradeInjectable` to create the `ngrxStoreService` factory in AngularJS\nngModule('appName').factory('ngrxStoreService', downgradeInjectable(Store));\n\n// AngularJS controller\nexport default ngModule('appName').controller('AngularJSController', [\n  '$scope',\n  '$controller',\n  'ngrxStoreService',\n  function($scope, $controller, ngrxStoreService) {\n    // ...\n    ngrxStoreService.dispatch(new MyActionClass(myPayload));\n    ngrxStoreService.select(mySelectorFunction).subscribe(/*...*/);\n    // ...\n  },\n]);\n```\n\n----------------------------------------\n\nTITLE: Dispatching an Action Outside Injection Context with Manual Injector in Angular (TypeScript)\nDESCRIPTION: This Angular TypeScript code demonstrates providing a manual injector when dispatching an NgRx action outside of the component injection context. The BookComponent uses input.required<number>() for reactivity, injects both the application Injector and Store, and calls store.dispatch with an options object specifying the injector for proper lifecycle management. Dependencies: Angular dependency injection, NgRx Store. Inputs: none directly; signal change triggers updates.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/actions.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nclass BookComponent {\n  bookId = input.required<number>();\n  injector = inject(Injector);\n  store = inject(Store);\n\n  ngOnInit() {\n    // runs outside the injection context\n    this.store.dispatch(() => loadBook({ id: this.bookId() }), { injector: this.injector });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Serving NgRx Docs/Website Locally with Yarn (sh)\nDESCRIPTION: This command builds and serves the NgRx documentation and website locally. It also watches for changes in files and automatically reloads the application, making local development efficient. The site will be accessible at `http://localhost:4200` after running this command. Requires `yarn`.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/marketing/contributing.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nyarn serve-and-sync\n```\n\n----------------------------------------\n\nTITLE: Breaking Change: createActionGroup After\nDESCRIPTION: Demonstrates the updated `createActionGroup` behavior where the event name's case is preserved during action name generation. The initial letter of the first word of the event name is lowercase, and the initial letters of the other words are uppercase. The case of other letters in the event name remains the same.\nSOURCE: https://github.com/ngrx/platform/blob/main/CHANGELOG.md#_snippet_17\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst { logInSuccess, loginFailure, logoutSuccess, logoutFailure } = authApiActions;\n```\n\n----------------------------------------\n\nTITLE: ofType Operator Usage - TypeScript (BEFORE)\nDESCRIPTION: This TypeScript code snippet demonstrates the deprecated use of the `ofType` function in NgRx 6.  It shows the import and usage within an effects class. The `ofType` function is used to filter actions of a specific type within an effect.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v7.md#_snippet_5\n\nLANGUAGE: ts\nCODE:\n```\nimport { Effect, Actions } from '@ngrx/effects';\n\n@Injectable()\nexport class MyEffects {\n  @Effect()\n  someEffect$: Observable<Action> = this.actions$\n    .ofType(UserActions.LOGIN)\n    .pipe(map(() => new AnotherAction()));\n\n  constructor(private actions$: Actions) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Using *ngrxLet with Prefixed Context Variables (Before V15) (HTML)\nDESCRIPTION: Shows the usage of the `*ngrxLet` structural directive from `@ngrx/component` in versions before v15. Template context variables for states like error (`$error`) and complete (`$complete`) required a `$` prefix.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v15.md#_snippet_8\n\nLANGUAGE: html\nCODE:\n```\n<ng-container *ngrxLet=\"obs$; $error as e; $complete as c\">\n  ...\n</ng-container>\n```\n\n----------------------------------------\n\nTITLE: Accessing LetDirective Error Context - HTML\nDESCRIPTION: Shows how to access error information within the `LetDirective`'s context using the `$error` property. As of version 14.0.0-beta.0, this property provides the actual thrown error object (or `undefined`) instead of a boolean (`true`/`false`). Requires `@ngrx/component` module.\nSOURCE: https://github.com/ngrx/platform/blob/main/CHANGELOG.md#_snippet_29\n\nLANGUAGE: html\nCODE:\n```\n<p *ngrxLet=\"obs$; $error as e\">{{ e }}</p>\n```\n\n----------------------------------------\n\nTITLE: Using async pipe in HTML template\nDESCRIPTION: This HTML snippet shows the typical usage of the built-in Angular `async` pipe. It demonstrates binding an observable to the view and accessing its emitted values within the template using various approaches. This involves the `async` pipe syntax and highlights the rendering of data received from the observable.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/component/push.md#_snippet_1\n\nLANGUAGE: html\nCODE:\n```\n<p>{{ number$ | async }}</p>\n\n<ng-container *ngIf=\"number$ | async as n\">{{ n }}</ng-container>\n\n<app-number [number]=\"number$ | async\"></app-number>\n```\n\n----------------------------------------\n\nTITLE: Defining NgRx Effect with @Effect Decorator (Before V15) (TypeScript)\nDESCRIPTION: Shows the deprecated method of defining an NgRx effect using the `@Effect` decorator in versions prior to v15. This decorator was applied to a class property assigned an observable stream (typically derived from `actions$`). This pattern is no longer supported in v15.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v15.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n@Effect()\ndata$ = this.actions$.pipe();\n```\n\n----------------------------------------\n\nTITLE: Enrich state with other state in selector (correct approach)\nDESCRIPTION: Illustrates proper pattern by defining individual selectors and combining them at the selector level, which improves reusability and clarity in state management.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/avoid-combining-component-store-selectors.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport class Component extends ComponentStore<StoreState> {\n  movies$ = this.select((state) => state.movies);\n  books$ = this.select((state) => state.books);\n  all$ = this.select(this.movies$, this.books$, ([movies, books]) => {\n    return {\n      movies,\n      books,\n    };\n  });\n\n  constructor() {\n    super({ movies: [], books: [] });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Renamed Router State Serializer - TypeScript Names\nDESCRIPTION: Highlights the renaming of the default router state serializer class in `@ngrx/router-store` as a breaking change in version 14.0.0-rc.0. The class name changed from `DefaultRouterStateSerializer` to `FullRouterStateSerializer`. Applications using this serializer directly will need to update their imports and references.\nSOURCE: https://github.com/ngrx/platform/blob/main/CHANGELOG.md#_snippet_30\n\nLANGUAGE: typescript\nCODE:\n```\nDefaultRouterStateSerializer\n```\n\nLANGUAGE: typescript\nCODE:\n```\nFullRouterStateSerializer\n```\n\n----------------------------------------\n\nTITLE: Running Setup Commands on Windows for NgRx Docs\nDESCRIPTION: Instructs Windows developers to run specific Yarn commands (`yarn setup`, `yarn boilerplate:add`) with Administrator privileges. This is necessary because the project utilizes Linux-specific symbolic links during the setup and example boilerplate generation process.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/README.md#_snippet_1\n\nLANGUAGE: Bash\nCODE:\n```\nyarn setup\n```\n\nLANGUAGE: Bash\nCODE:\n```\nyarn boilerplate:add\n```\n\n----------------------------------------\n\nTITLE: Creating NgRx Reducer for Book Collection State in TypeScript\nDESCRIPTION: Defines an NgRx reducer function (`collectionReducer`) to manage the state of the user's book collection. It handles the `'[Book List] Add Book'` action by adding a book ID (avoiding duplicates) and the `'[Book Collection] Remove Book'` action by filtering the collection.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/walkthrough.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Code from src/app/state/collection.reducer.ts\n// Defines the reducer managing the user's book collection.\n```\n\n----------------------------------------\n\nTITLE: Installing NgRx Store Devtools Using Yarn Shell\nDESCRIPTION: This shell snippet uses Yarn to add the @ngrx/store-devtools package to the project dependencies. Unlike npm, Yarn does not require the --save flag as it automatically adds the dependency to package.json. Manual configuration of the Store Devtools is required after installation.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store-devtools/install.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nyarn add @ngrx/store-devtools\n```\n\n----------------------------------------\n\nTITLE: Manual Cleanup of Dispatched EffectRef in Angular Component (TypeScript)\nDESCRIPTION: This code shows how to manually destroy an EffectRef returned by NgRx store.dispatch, ensuring proper resource cleanup. The BookComponent creates the effect in ngOnInit by dispatching a signal-derived action, then destroys it in ngOnDestroy to prevent memory leaks. Dependencies: EffectRef type (from NgRx or Angular CDK), injected Store. Inputs: signal (bookId); Output: effect teardown.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/actions.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nclass BookComponent {\n  bookId = input.required<number>();\n  loadBookEffectRef: EffectRef | undefined;\n  store = inject(Store);\n\n  ngOnInit() {\n    // uses the injection context of Store, i.e. root injector\n    this.loadBookEffectRef = this.store.dispatch(() => loadBook({ id: this.bookId() }));\n  }\n\n  ngOnDestroy() {\n    if (this.loadBookEffectRef) {\n      // destroys the effect\n      this.loadBookEffectRef.destroy();\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Effect in a Specific Folder and Registering with a Module\nDESCRIPTION: This sequence of commands creates a 'User' module without a flat structure, then generates a UserEffects file within the same folder, registering it in the 'user.module.ts' Angular module. It demonstrates modular effect organization.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/schematics/effect.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\nng generate module User --flat false\nng generate effect user/User -m user.module.ts\n```\n\n----------------------------------------\n\nTITLE: Creating a selector for a view model with multiple inputs using object syntax\nDESCRIPTION: Demonstrates usage of 'createSelector' with an object of input selectors to generate a structured output, facilitating cleaner selection logic for complex view models.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/selectors.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst selectBooksPageViewModel = createSelector({\n  books: selectBooks, // result type - Book[]\n  query: selectQuery, // result type - string\n});\n```\n\n----------------------------------------\n\nTITLE: Breaking Change Commit Message Example\nDESCRIPTION: This code snippet illustrates how to format a commit message that introduces breaking changes.  The footer includes \"BREAKING CHANGES:\" followed by a description of the changes, along with \"BEFORE:\" and \"AFTER:\" code examples.\nSOURCE: https://github.com/ngrx/platform/blob/main/CONTRIBUTING.md#_snippet_6\n\nLANGUAGE: text\nCODE:\n```\nfeat(scope): commit message\n\nBREAKING CHANGES:\n\nDescribe breaking changes here\n\nBEFORE:\n\nPrevious code example here\n\nAFTER:\n\nNew code example here\n```\n\n----------------------------------------\n\nTITLE: Example of nameAndSayingFilter function (TypeScript)\nDESCRIPTION: This function demonstrates how to create a filter for Villain entities using PropsFilterFnFactory helper to filter by name and saying. The input parameters are the list of villains and pattern.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/entity-metadata.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * Filter for entities whose name or saying\n * matches the case-insensitive pattern.\n */\nexport function nameAndSayingFilter(entities: Villain[], pattern: string) {\n  return PropsFilterFnFactory<Villain> ['name', 'saying'](entities, pattern);\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect usage of 'reducer' in key names in TypeScript code\nDESCRIPTION: This snippet shows examples of improper naming conventions where the key names include the word 'reducer' in the context of nGRX store configuration. Such naming can hinder clarity and maintainability.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/no-reducer-in-key-names.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nStoreModule.forRoot({\n  customersReducer: customersReducer,\n});\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nStoreModule.forFeature({\n  customersReducer,\n});\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport const reducers: ActionReducerMap<AppState> = {\n  customersReducer: fromCustomers.reducer,\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring Default Effect Retry Limit in NgRx Effects\nDESCRIPTION: This snippet discusses setting a maximum of 10 retries for effects on errors, replacing the previous unlimited retry behavior. Developers can implement a custom error handler to override this default.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v9.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Implement a custom effect error handler or set retry limit\n// Example placeholder code or configuration can be added here depending on the implementation.\n```\n\n----------------------------------------\n\nTITLE: Generating a User Module and Grouped Feature in Subfolder - Shell\nDESCRIPTION: First, a new Angular module 'User' is created within a folder using '--flat false', then a 'user' feature is generated inside that folder, registering it with the corresponding user.module.ts and grouping its files. Prerequisites include an existing or newly created user module and the Angular CLI environment. The resulting structure organizes feature and module code within component-specific directories.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/schematics/feature.md#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\nng generate module User --flat false\nng generate feature user/User -m user.module.ts --group\n```\n\n----------------------------------------\n\nTITLE: Migrating from @Effect decorator to createEffect in NgRx Effects\nDESCRIPTION: This code snippet demonstrates the transition from using the deprecated @Effect decorator to the new createEffect function for defining effects. It enhances code clarity by adopting a modern, function-based approach aligned with NgRx best practices.\nSOURCE: https://github.com/ngrx/platform/blob/main/CHANGELOG.md#_snippet_26\n\nLANGUAGE: TypeScript\nCODE:\n```\n@Effect()\ndata$ = this.actions$.pipe();\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\ndata$ = createEffect(() => this.actions$.pipe());\n```\n\n----------------------------------------\n\nTITLE: Formatting NgRx Live Examples with Yarn (sh)\nDESCRIPTION: This command runs Prettier to ensure consistent code formatting within the live examples provided in the documentation. It should be executed after adding or modifying any live code examples to maintain formatting consistency. Requires `yarn` and the project's Prettier configuration.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/marketing/contributing.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nyarn prettier\n```\n\n----------------------------------------\n\nTITLE: Generating a Reducer within a Grouped 'reducers' Folder (sh)\nDESCRIPTION: Example command illustrating the use of the `--group` option. This generates a 'User' reducer file and places it inside a standard 'reducers' subfolder within the feature's directory, facilitating organizational structure.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/schematics/reducer.md#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\nng generate reducer User --group\n```\n\n----------------------------------------\n\nTITLE: Migrating to LetDirective (After) in TypeScript\nDESCRIPTION: Shows the updated approach after `LetModule` removal in NgRx v17, importing the standalone `LetDirective` directly into an `NgModule` or a standalone component's imports. This replaces the need for `LetModule`.\nSOURCE: https://github.com/ngrx/platform/blob/main/CHANGELOG.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { LetDirective } from '@ngrx/component';\n\n@NgModule({\nimports: [\n// ... other imports\nLetDirective,\n],\n})\nexport class MyFeatureModule {}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage: Disabling Protected State in NgRx Signal Store (TypeScript)\nDESCRIPTION: This example demonstrates an incorrect pattern according to the 'prefer-protected-state' rule. It explicitly sets `protectedState` to `false` in the `signalStore` configuration, which allows state modifications from outside the store and is discouraged.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/prefer-protected-state.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Store = signalStore(\n  { protectedState: false },\n  withState({}),\n);\n```\n\n----------------------------------------\n\nTITLE: Example zipper configuration\nDESCRIPTION: This JSON snippet shows the configuration used by the example zipper tool. It specifies a description for the example, a list of files to include (or exclude using negation), and tags for categorization.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/tools/example-zipper/README.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"description\": \"Tour of Heroes: Part 6\",\n  \"files\": [\"!**/*.d.ts\", \"!**/*.js\", \"!**/*.[1,2].*\"],\n  \"tags\": [\"tutorial\", \"tour\", \"heroes\", \"http\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating from LetModule (Before) in TypeScript\nDESCRIPTION: Demonstrates the previous usage of `LetModule` within an Angular `NgModule`'s imports array before its removal in NgRx v17. This module provided the `*ngrxLet` structural directive.\nSOURCE: https://github.com/ngrx/platform/blob/main/CHANGELOG.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { LetModule } from '@ngrx/component';\n\n@NgModule({\nimports: [\n// ... other imports\nLetModule,\n],\n})\nexport class MyFeatureModule {}\n```\n\n----------------------------------------\n\nTITLE: Selector Definition (Before)\nDESCRIPTION: This code snippet demonstrates the definition of a selector using `createSelector` before the changes in version 8. The selector extracts a todo item based on its ID from the state.  This approach will cause errors in version 8.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v8.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst getTodosById = createSelector(\n  (state: TodoAppSchema, id: number) => state.todos.find(p => p.id === id)\n);\n```\n\n----------------------------------------\n\nTITLE: Extending NgRx Data - Registering Handlers and Reducer Methods\nDESCRIPTION: This snippet provides an example of how to register the custom implementations created in the previous steps.  It shows how to provide the `AdditionalPersistenceResultHandler` within an NgModule and how to register the `AdditionalEntityCollectionReducerMethodsFactory`.  This setup involves dependency injection and replacing the default NgRx Data services with the custom ones.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/entity-metadata.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n@NgModule({\n  {\n    provide: PersistenceResultHandler,\n    useClass: AdditionalPersistenceResultHandler\n  },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Zip Type Configuration\nDESCRIPTION: This JSON snippet demonstrates optional properties for zipper configuration within stackblitz.json or zipper.json. 'removeSystemJsConfig' controls removal of SystemJS-related configurations, and 'type' specifies the application type (e.g., 'testing').\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/tools/example-zipper/README.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  ...\n  \"removeSystemJsConfig\": true,\n  \"type\": \"testing\"\n}\n```\n\n----------------------------------------\n\nTITLE: ActivatedRouteSnapshot.RouteConfig - JSON (AFTER)\nDESCRIPTION: This JSON snippet shows the updated structure of the `routeConfig` property within the `ActivatedRouteSnapshot` in NgRx v7. When the `routeConfig` does not exist, the value is now `null` instead of an empty object.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v7.md#_snippet_10\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"routeConfig\": null\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Tagged EntityAction Instance Using EntityActionFactory in TypeScript\nDESCRIPTION: This snippet illustrates customizing the action 'type' tag property to provide a descriptive context for the action, improving debuggability and traceability in logs. The 'create()' method is called with an additional options parameter containing a 'tag' string, which appears between brackets in the formatted action type string seen in the NgRx store logs.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/entity-actions.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst action = this.entityActionFactory.create<Hero>(\n  'Hero',\n  EntityOp.QUERY_ALL,\n  null,\n  { tag: 'Load Heroes On Start' }\n);\n\nstore.dispatch(action);\n```\n\n----------------------------------------\n\nTITLE: Installing NgRx Store Devtools Nightly Build Shell\nDESCRIPTION: These commands install the latest nightly build of the NgRx Store Devtools package directly from the official NgRx GitHub builds repository. Use either npm or yarn to add the unreleased version of the package to your project dependencies.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/nightlies.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\nnpm install github:ngrx/store-devtools-builds\n```\n\nLANGUAGE: Shell\nCODE:\n```\nyarn add github:ngrx/store-devtools-builds\n```\n\n----------------------------------------\n\nTITLE: Breaking Change: createFeature Selectors After\nDESCRIPTION: Illustrates how the `createFeature` selector projector function arguments are now strongly typed after the change. They are specific to the feature state.\nSOURCE: https://github.com/ngrx/platform/blob/main/CHANGELOG.md#_snippet_23\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst counterFeature = createFeature({\n  name: 'counter',\n  reducer: createReducer({ count: 0 }),\n});\n\ncounterFeature.selectCount.projector;\n// type: (featureState: { count: number; }) => number\n```\n\n----------------------------------------\n\nTITLE: Alias for NgRx Action Generation Command (Shell)\nDESCRIPTION: Shows the shorthand alias `ng generate a` for the NgRx action generation command. Functionally equivalent to `ng generate action`. Replace `ActionName` with the desired name and optionally include command options.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/schematics/action.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nng generate a ActionName [options]\n```\n\n----------------------------------------\n\nTITLE: Run Tests for a Specific Library with PNPM\nDESCRIPTION: These shell commands use PNPM and Nx to run tests specifically for the 'effects' library or a specified module. The `--watchAll` flag enables continuous testing, automatically re-running tests on file changes.\nSOURCE: https://github.com/ngrx/platform/blob/main/CONTRIBUTING.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\npnpm exec nx test effects --watchAll\n```\n\nLANGUAGE: shell\nCODE:\n```\npnpm exec nx test <module-name> --watchAll\n```\n\n----------------------------------------\n\nTITLE: Option: Flat Structure for Effects Files\nDESCRIPTION: Controls whether the generated effects file is nested within a folder named after the entity or placed directly alongside other files. Defaults to true for a flat structure.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/schematics/entity.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\n--flat\n```\n\n----------------------------------------\n\nTITLE: Breaking Change: createFeature Selectors Before\nDESCRIPTION: Illustrates how the `createFeature` selector projector function arguments are *not* strongly typed before the change. They are of type `any[]`.\nSOURCE: https://github.com/ngrx/platform/blob/main/CHANGELOG.md#_snippet_22\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst counterFeature = createFeature({\n  name: 'counter',\n  reducer: createReducer({ count: 0 }),\n});\n\ncounterFeature.selectCount.projector;\n// type: (...args: any[]) => number\n```\n\n----------------------------------------\n\nTITLE: Reading State from an NgRx SignalStore in an Angular Component Template\nDESCRIPTION: Demonstrates accessing state values from an injected `BooksStore` within an Angular component's template. It shows how to read top-level signals (`store.books()`, `store.isLoading()`) and nested `DeepSignal` properties (`store.filter()`, `store.filter.query()`, `store.filter.order()`) using signal invocation syntax. The `JsonPipe` is used for displaying object/array values.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/index.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { ChangeDetectionStrategy, Component, inject } from '@angular/core';\nimport { JsonPipe } from '@angular/common';\nimport { BooksStore } from './books.store';\n\n@Component({\n  imports: [JsonPipe],\n  template: `\n    <p>Books: {{ store.books() | json }}</p>\n    <p>Loading: {{ store.isLoading() }}</p>\n\n    <!-- 👇 The `DeepSignal` value can be read in the same way as `Signal`. -->\n    <p>Pagination: {{ store.filter() | json }}</p>\n\n    <!-- 👇 Nested signals are created as `DeepSignal` properties. -->\n    <p>Query: {{ store.filter.query() }}</p>\n    <p>Order: {{ store.filter.order() }}</p>\n  `,\n  providers: [BooksStore],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class BooksComponent {\n  readonly store = inject(BooksStore);\n}\n```\n\n----------------------------------------\n\nTITLE: Breaking Change: createFeature After\nDESCRIPTION: Illustrates the updated `createFeature` implementation without root state.  The feature is defined directly without referencing a root `AppState` interface. An automatic migration is provided.\nSOURCE: https://github.com/ngrx/platform/blob/main/CHANGELOG.md#_snippet_19\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport const usersFeature = createFeature({\n  name: 'users',\n  reducer: createReducer(initialState /* case reducers */),\n});\n```\n\n----------------------------------------\n\nTITLE: Commit Message Example\nDESCRIPTION: This code snippet provides an example of a commit message adhering to the specified format. The header includes the type (docs), scope (changelog), and subject (update changelog to beta.5).\nSOURCE: https://github.com/ngrx/platform/blob/main/CONTRIBUTING.md#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\ndocs(changelog): update changelog to beta.5\n```\n\n----------------------------------------\n\nTITLE: Defining Custom NgRx Action Interface with Payload in TypeScript\nDESCRIPTION: Provides a type-safe interface that extends the base NgRx `Action` to include a generic `payload` property, useful if you prefer to explicitly type payloads.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v4.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface ActionWithPayload<T> extends Action {\n  payload: T;\n}\n```\n\n----------------------------------------\n\nTITLE: Generating a Grouped Effects File in Effects Folder\nDESCRIPTION: This command creates a UserEffects effect file placed inside an 'effects' folder, grouped accordingly, which helps organize multiple effects collaboratively within the project.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/schematics/effect.md#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\nng generate effect User --group\n```\n\n----------------------------------------\n\nTITLE: Installing ESLint plugin with Angular CLI\nDESCRIPTION: Installs the NgRx ESLint plugin using the Angular CLI's `ng add` command.  The command prompts the user to select a preconfigured ESLint configuration. Requires the Angular CLI to be installed globally or locally.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/install.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nng add @ngrx/eslint-plugin\n```\n\n----------------------------------------\n\nTITLE: Incorrect global Store injection with explicit typing in Angular component\nDESCRIPTION: This code snippet demonstrates improper usage where the Store is explicitly typed with a state interface, which is discouraged. It showcases how defining the store with a generic type can lead to unnecessary complexity and potential mismatches, contrary to ngrx best practices.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/no-typed-global-store.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport class Component {\n  data$ = this.store.select(data);\n\n  constructor(private readonly store: Store<{ data: Data }>) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Action with Primitive Props (Before v13 Restriction) - TypeScript\nDESCRIPTION: Example showing how `createAction` previously allowed using primitive types (like `string`, `number`, `boolean`) directly as the generic type for `props`. This is no longer permitted in v13.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v13.md#_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nconst action = createAction('[Source] Event', props<string>());\n```\n\n----------------------------------------\n\nTITLE: Installing @ngrx/signals with yarn\nDESCRIPTION: This snippet shows how to install the @ngrx/signals package using yarn.  It adds the package as a dependency to the project. This requires yarn to be installed and a valid project setup.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/install.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nyarn add @ngrx/signals\n```\n\n----------------------------------------\n\nTITLE: Breaking Change: Replacing getMockStore with createMockStore\nDESCRIPTION: Example showing the replacement of getMockStore function with createMockStore in the store testing module.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v16.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getMockStore } from '@ngrx/store/testing';\nconst mockStore = getMockStore();\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createMockStore } from '@ngrx/store/testing';\nconst mockStore = createMockStore();\n```\n\n----------------------------------------\n\nTITLE: Run Tests with PNPM\nDESCRIPTION: This shell command utilizes PNPM to execute the project's test suite. Running the tests ensures that the code adheres to the expected behavior and quality standards.\nSOURCE: https://github.com/ngrx/platform/blob/main/CONTRIBUTING.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\npnpm exec test\n```\n\n----------------------------------------\n\nTITLE: SignalStore with rxMethod for Reactive Loading\nDESCRIPTION: This example shows how to use rxMethod in a SignalStore to create a reactive load method. The method handles loading state, processes the studio parameter reactively, and updates the store with movies returned from the service.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/testing.md#_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport const MoviesStore = signalStore(\n  // ... code omitted\n  withMethods((store, moviesService = inject(MoviesService)) => ({\n    load: rxMethod<string>(\n      pipe(\n        tap(() => patchState(store, { loading: true })),\n        switchMap((studio) =>\n          moviesService.load(studio).pipe(\n            tapResponse({\n              next: (movies) =>\n                patchState(store, { movies, loading: false }),\n              error: console.error,\n            })\n          )\n        )\n      )\n    ),\n  }))\n);\n```\n\n----------------------------------------\n\nTITLE: Option: Register Entity in Angular Module\nDESCRIPTION: Specifies the path to an Angular module file where the entity reducer will be added to the module's imports via StoreModule.forFeature, facilitating feature state registration.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/schematics/entity.md#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\n--module\n-m\n```\n\n----------------------------------------\n\nTITLE: Configuring Plural Names - Defining Plural Names\nDESCRIPTION: This snippet demonstrates how to define a map of singular to plural entity names, which is used by the `HttpUrlGenerator` to create the correct URLs for HTTP requests. The example shows how to define `pluralNames` with `Hero: 'Heroes'`, which overrides the default pluralization of 'Hero' to be 'Heroes'.  This can be used when the default `Pluralizer` logic doesn't work for custom entity names.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/entity-metadata.md#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nexport const pluralNames = {\n  // Case matters. Match the case of the entity name.\n  Hero: 'Heroes'\n};\n\n```\n\n----------------------------------------\n\nTITLE: Correct implementation with EffectsModule.forRoot()\nDESCRIPTION: This example shows correct code where an effect class is only added to EffectsModule.forRoot() and not declared in the providers array.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/no-effects-in-providers.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n@NgModule({\n  imports: [EffectsModule.forRoot([CustomersEffect])],\n})\nexport class AppModule {}\n```\n\n----------------------------------------\n\nTITLE: Installing @ngrx/entity with yarn\nDESCRIPTION: Provides the command to add @ngrx/entity via yarn, another package manager, ensuring the dependency is added to the project for managing packages effectively.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/entity/install.md#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\nyarn add @ngrx/entity\n```\n\n----------------------------------------\n\nTITLE: Generating Feature State Setup for Admin Module with NgRx Store - Shell\nDESCRIPTION: This sequence of commands first creates an Angular feature module named 'admin' in its own directory, and then sets up NgRx store management for the 'Admin' feature. The store setup is registered with 'admin.module.ts' and creates state files under the 'admin' folder. Dependencies are an Angular CLI project, @ngrx/store, and the admin.module.ts file. The -m flag is used to associate the new feature state with the specified module.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/schematics/store.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nng generate module admin --flat false\nng generate store admin/Admin -m admin.module.ts\n```\n\n----------------------------------------\n\nTITLE: NgZone violation: Dispatching action outside zone\nDESCRIPTION: This code shows how actions can be dispatched outside of `NgZone`. This could result in a stale view. The example defines a callback `callbackOutsideNgZone()` that's running outside of the zone and dispatches a store action.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/configuration/runtime-checks.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\n// Callback running outside of NgZone\nfunction callbackOutsideNgZone() {\n  this.store.dispatch(clearTodos());\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Using Predefined NgRx ESLint Configurations with ESLint v8\nDESCRIPTION: Extends the predefined NgRx ESLint configurations to include all rules with a specific rule overridden to change its severity level.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/index.md#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"extends\": [\"plugin:@ngrx/all\"],\n  \"rules\": {\n    \"@ngrx/good-action-hygiene\": \"warn\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Basic NgRx ESLint Plugin with ESLint v8\nDESCRIPTION: Sets up the NgRx ESLint Plugin in an ESLint v8 configuration file by adding the plugin and specifying a rule to enforce good action hygiene.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/index.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"plugins\": [\"@ngrx\"],\n  \"rules\": {\n    \"@ngrx/good-action-hygiene\": \"error\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing ESLint plugin with yarn\nDESCRIPTION: Installs the NgRx ESLint plugin as a dev dependency using yarn. This command adds the plugin to the project's package.json file. Requires yarn to be installed.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/install.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nyarn add @ngrx/eslint-plugin -D\n```\n\n----------------------------------------\n\nTITLE: Install Dependencies with PNPM\nDESCRIPTION: This shell command uses the PNPM package manager to install the necessary dependencies for the project. This is a crucial first step in setting up the development environment.\nSOURCE: https://github.com/ngrx/platform/blob/main/CONTRIBUTING.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npnpm install\n```\n\n----------------------------------------\n\nTITLE: Installing NgRx Schematics with yarn\nDESCRIPTION: Install @ngrx/schematics as a development dependency using yarn. This adds the package to your project's devDependencies in package.json.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/schematics/install.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nyarn add @ngrx/schematics --dev\n```\n\n----------------------------------------\n\nTITLE: Breaking Change: getMockStore Before\nDESCRIPTION: Demonstrates how to use `getMockStore` function. This function is now deprecated in favor of `createMockStore`.\nSOURCE: https://github.com/ngrx/platform/blob/main/CHANGELOG.md#_snippet_20\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { getMockStore } from '@ngrx/store/testing';\nconst mockStore = getMockStore();\n```\n\n----------------------------------------\n\nTITLE: Fix for Serializability Violation: Actions without functions\nDESCRIPTION: This shows how to fix the `strictActionSerializability` violation by removing the function from the action. Instead, the function is defined separately (as `logTodo`) and doesn't become a property of the action, making the action serializable.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/configuration/runtime-checks.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst createTodo = createAction(\n  '[Todo List] Add new todo',\n  props<{ todo: Todo }>()\n);\n\nfunction logTodo(todo: Todo) {\n  console.log(todo);\n}\n```\n```\n\n----------------------------------------\n\nTITLE: NgRx State Interface with Optional Property (Unsupported for createFeature) in TypeScript\nDESCRIPTION: This snippet shows a state interface that includes an optional property defined using the `?` syntax. The accompanying text explains that `createFeature` does not support state interfaces defined this way and requires properties to be explicitly present in the initial state.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/feature-creators.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\ninterface State {\n  books: Book[];\n  activeBookId?: string;\n}\n\nconst initialState: State = {\n  books: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Feature Loaded Action Changes - TypeScript (Multiple Features, AFTER)\nDESCRIPTION: This TypeScript code snippet illustrates the change in actions dispatched when adding or removing feature reducers in NgRx v7.  It shows the difference between dispatching individual actions per feature in the 'BEFORE' state and using a single action with an array of features in the 'AFTER' state. This involves changes in the action payload structure to accommodate multiple feature updates efficiently.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v7.md#_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\n{type: '@ngrx/store/update-reducers', features: ['feat1', 'feat2']}\n```\n\n----------------------------------------\n\nTITLE: Tracking Observable Events with *ngrxLet in Angular\nDESCRIPTION: Shows how the `*ngrxLet` directive provides access to the different states or events of an observable stream (`number$`). It allows binding the emitted `next` value (aliased as `n`), potential `error` (aliased as `e`), and `complete` status (aliased as `c`) to template variables, enabling conditional rendering based on the observable's lifecycle.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/component/let.md#_snippet_3\n\nLANGUAGE: html\nCODE:\n```\n<ng-container *ngrxLet=\"number$ as n; error as e; complete as c\">\n  <app-number [number]=\"n\" *ngIf=\"!e && !c\">\n  </app-number>\n\n  <p *ngIf=\"e\">There is an error: {{ e }}</p>\n  <p *ngIf=\"c\">Observable is completed.</p>\n</ng-container>\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage: Initializing NgRx Signal State with Root Arrays (TypeScript)\nDESCRIPTION: Illustrates invalid ways to initialize NgRx Signal State by passing an array directly as the root state argument to `withState`. This includes literal arrays, typed arrays, or variables holding arrays. These patterns violate the 'signal-state-no-arrays-at-root-level' rule.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/signal-state-no-arrays-at-root-level.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst store = withState([1, 2, 3]);\n\nconst store = withState([{ foo: 'bar' }]);\n\nconst store = withState<string[]>([]);\n\nconst initialState = [];\nconst store = withState(initialState);\n```\n\n----------------------------------------\n\nTITLE: Generating NgRx Entity Files Using Angular CLI\nDESCRIPTION: This shell command demonstrates how to generate a new entity setup in an Angular project utilizing the Angular CLI, with the ability to specify options for project location, module registration, and test file creation. It streamlines creating actions, models, reducers, and selectors for entity management.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/schematics/entity.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nng generate entity EntityName [options]\n\n##### OR\n\nng generate en EntityName [options]\n```\n\n----------------------------------------\n\nTITLE: Incorrect updater method lacking explicit return type in TypeScript\nDESCRIPTION: This code snippet demonstrates an updater method within a class extending ComponentStore that does not specify a return type. The method updates the movies array but omits the return type annotation, which is discouraged as it bypasses compile-time type safety and linters flag it as an issue.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/updater-explicit-return-type.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ninterface MoviesState {\n  movies: Movie[];\n}\n\nclass MoviesStore extends ComponentStore<MoviesState> {\n  readonly addMovie = this.updater((state, movie: Movie) => ({\n    movies: [...state.movies, movie],\n    // ⚠ this doesn't throw, but is caught by the linter\n    extra: 'property',\n  }));\n}\n```\n\n----------------------------------------\n\nTITLE: Selecting Router State (Before @ngrx/router-store v11 Optimization)\nDESCRIPTION: Demonstrates how `selectQueryParams` and `selectFragment` selectors worked before the v11 optimization in `@ngrx/router-store`. They previously selected values from the last activated route's node in the router state tree.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v11.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst queryParams$ = this.store.select(selectQueryParams);\nconst fragment$ = this.store.select(selectFragment);\n\n/*\nrouter state:\n{\n  root: {\n    queryParams: {\n      search: 'foo',\n    },\n    fragment: 'bar',\n    firstChild: {\n      queryParams: {\n        search: 'foo', 👈 query parameters are selected from here\n      },\n      fragment: 'bar', 👈 fragment is selected from here\n      firstChild: undefined,\n    },\n  },\n  url: '/books?search=foo#bar',\n}\n*/\n```\n\n----------------------------------------\n\nTITLE: Obtaining the type of a SignalStore using TypeScript utility\nDESCRIPTION: This snippet illustrates how to derive the runtime type of a SignalStore instance using TypeScript's `InstanceType` utility. It helps in typing store variables and functions that operate on specific store instances, improving type safety and IntelliSense support.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/faq.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\n```ts\nconst CounterStore = signalStore(withState({ count: 0 }));\n\ntype CounterStore = InstanceType<typeof CounterStore>;\n\nfunction logCount(store: CounterStore): void {\n  console.log(store.count());\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Installing NgRx Store Nightly Build Shell\nDESCRIPTION: These commands install the latest nightly build of the NgRx Store package directly from the official NgRx GitHub builds repository. Use either npm or yarn to add the unreleased version of the package to your project dependencies.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/nightlies.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nnpm install github:ngrx/store-builds\n```\n\nLANGUAGE: Shell\nCODE:\n```\nyarn add github:ngrx/store-builds\n```\n\n----------------------------------------\n\nTITLE: Incorrect implementation with EffectsModule.forFeature() and duplicate provider\nDESCRIPTION: This example shows incorrect code where an effect class is both added to EffectsModule.forFeature() and declared in the providers array, creating a duplicate registration.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/no-effects-in-providers.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n@NgModule({\n  imports: [EffectsModule.forFeature([CustomersEffect])],\n  providers: [CustomersEffect],\n})\nexport class CustomersModule {}\n```\n\n----------------------------------------\n\nTITLE: Updating Angular Dependencies with Yarn for Documentation Examples\nDESCRIPTION: Command to interactively upgrade dependencies in the shared package.json file for documentation examples. This uses the yarn upgrade-interactive command with the --tilde flag to select which packages to update after a new Angular release.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/tools/RELEASE.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ yarn upgrade-interactive --tilde\n```\n\n----------------------------------------\n\nTITLE: Configuring Angular Application with NgRx Store and Custom Router Serializer in TypeScript\nDESCRIPTION: Demonstrates how to configure the Angular application using ApplicationConfig to provide the router, NgRx store with router reducer, and the router-store module with a custom serializer. This example wires all components together to enable customized router state management within the store.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/router-store/configuration.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { ApplicationConfig } from '@angular/core';\nimport { provideRouter } from '@angular/router';\nimport { provideStore } from '@ngrx/store';\nimport { provideRouterStore, routerReducer } from '@ngrx/router-store';\n\nimport { AppComponent } from './app.component';\nimport { CustomSerializer } from './custom-serializer';\n\nexport const appConfig: ApplicationConfig = {\n  providers: [\n    provideRouter([\n      // routes\n    ]),\n    provideStore({\n      router: routerReducer,\n    }),\n    provideRouterStore({\n      serializer: CustomSerializer\n    })\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Feature Selector (Correct) - NgRx TypeScript\nDESCRIPTION: This snippet demonstrates the recommended usage of NgRx's `createFeatureSelector` according to the rule. It uses only one generic type argument, `CustomersFeatureState`, which represents the shape of the specific feature state being selected. This adheres to the principle that feature selectors should only be aware of their own state shape, promoting better modularity and supporting lazy loading scenarios.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/prefer-one-generic-in-create-for-feature-selector.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst customersFeatureState =\n  createFeatureSelector<CustomersFeatureState>('customers');\n```\n\n----------------------------------------\n\nTITLE: Updating NgRx Effect for Initial Action in TypeScript\nDESCRIPTION: Shows how to adjust an effect that previously relied on the `Dispatcher.INIT` action. Since this action now fires earlier, using `rxjs/defer` ensures the effect logic executes after effects are fully initialized, providing similar timing to the old behavior.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v4.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Dispatcher, Action } from '@ngrx/store';\nimport { Actions, Effect } from '@ngrx/effects';\n\nimport * as auth from '../actions/auth.actions';\n\n@Injectable()\nexport class AppEffects {\n  @Effect()\n  init$: Observable<Action> = this.actions$\n    .ofType(Dispatcher.INIT)\n    .switchMap(action => {\n      return of(new auth.LoginAction());\n    });\n\n  constructor(private actions$: Actions) {}\n}\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Action } from '@ngrx/store';\nimport { Actions, Effect } from '@ngrx/effects';\nimport { defer } from 'rxjs';\n\nimport * as auth from '../actions/auth.actions';\n\n@Injectable()\nexport class AppEffects {\n  @Effect()\n  init$: Observable<Action> = defer(() => {\n    return of(new auth.LoginAction());\n  });\n\n  constructor(private actions$: Actions) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Example of incorrect multiple store injections in TypeScript\nDESCRIPTION: This code snippet shows an incorrect implementation where multiple distinct store instances are injected into a class, violating the rule of having only one global store. It highlights the need to avoid multiple store dependencies to maintain singleton store architecture.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/rules/no-multiple-global-stores.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport class Component {\n  constructor(\n    private readonly customersStore: Store<Customers>,\n    private readonly catalogStore: Store<Catalog>\n  ) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Feature Loaded Action Changes - TypeScript (Multiple Features)\nDESCRIPTION: This TypeScript code snippet illustrates the change in actions dispatched when adding or removing feature reducers in NgRx v7.  It shows the difference between dispatching individual actions per feature in the 'BEFORE' state and using a single action with an array of features in the 'AFTER' state. This involves changes in the action payload structure to accommodate multiple feature updates efficiently.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v7.md#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\n{type: '@ngrx/store/update-reducers', feature: 'feat1'}\n{type: '@ngrx/store/update-reducers', feature: 'feat2'}\n```\n\n----------------------------------------\n\nTITLE: Selector Definition (After)\nDESCRIPTION: This code snippet shows the corrected selector definition that is compatible with version 8.  It now correctly uses the state as the first argument to createSelector, and the id as the second argument.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v8.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst getTodosById = createSelector(\n  (state: TodoAppSchema) => state.todos,\n  (todos: Todo[], id: number) => todos.find(p => p.id === id)\n);\n```\n\n----------------------------------------\n\nTITLE: Migrating concatLatestFrom Import in NgRx Effects\nDESCRIPTION: Breaking change in NgRx v18.0.0-rc.0: The `concatLatestFrom` operator is removed from `@ngrx/effects`. Update imports to use the `@ngrx/operators` package instead. This change centralizes NgRx operators into a dedicated package for better modularity.\nSOURCE: https://github.com/ngrx/platform/blob/main/CHANGELOG.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { concatLatestFrom } from '@ngrx/effects';\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { concatLatestFrom } from '@ngrx/operators';\n```\n\n----------------------------------------\n\nTITLE: Implementing Book List Component Logic (TypeScript)\nDESCRIPTION: TypeScript class for the `BookListComponent`. It defines an `@Input()` for the book list (`books`) and an `@Output()` event emitter (`add`) that emits the book ID when the add button is clicked.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/walkthrough.md#_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Code from src/app/book-list/book-list.component.ts\n// Component logic for displaying books and emitting an add event.\n```\n\n----------------------------------------\n\nTITLE: Store DevtoolsModule Configuration (Before - actionsBlacklist)\nDESCRIPTION: This code snippet shows the configuration of `StoreDevtoolsModule` before the renaming of `actionsBlacklist` to `actionsBlocklist`. This will produce an error when using version 8.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v8.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nStoreDevtoolsModule.instrument({\n  actionsBlacklist: ['...']\n})\n```\n\n----------------------------------------\n\nTITLE: Renaming Effect Error Handler Option in NgRx Effects\nDESCRIPTION: This code illustrates the renaming of the `resubscribeOnError` option to `useEffectsErrorHandler` in NgRx Effects decorators and `createEffect` functions. It updates how to specify custom error handling behavior within effect configurations.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v9.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Before\n@Effect({ resubscribeOnError: false })\neffect$ = ...\n\n// After\n@Effect({ useEffectsErrorHandler: false })\neffect$ = ...\n\n// with createEffect\nconst effect$ = createEffect(() => ..., { useEffectsErrorHandler: false })\n```\n\n----------------------------------------\n\nTITLE: Ngrx Entity Selector Types (Before v17) in TypeScript\nDESCRIPTION: Displays the types returned by `adapter.getSelectors` when used with a parent selector prior to NgRx v17. The selectors returned plain function types without `MemoizedSelector` wrappers, potentially leading to less specific type inference.\nSOURCE: https://github.com/ngrx/platform/blob/main/CHANGELOG.md#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nconst {\n  selectIds, // type: (state: object) => string[] | number[]\n  selectEntities, // type: (state: object) => Dictionary<Book>\n  selectAll, // type: (state: object) => Book[]\n  selectTotal, // type: (state: object) => number\n} = adapter.getSelectors(selectBooksState);\n```\n\n----------------------------------------\n\nTITLE: Router Store Configuration - TypeScript (BEFORE)\nDESCRIPTION: This TypeScript code snippet illustrates the deprecated use of `stateKey` to customize the router state key. The `StoreRouterConnectingModule.forRoot` configuration sets the state key to 'router' in this example.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v7.md#_snippet_7\n\nLANGUAGE: ts\nCODE:\n```\nStoreRouterConnectingModule.forRoot({\n  stateKey: 'router',\n}),\n```\n\n----------------------------------------\n\nTITLE: Generating Root State Setup with Custom State Path in NgRx Store - Shell\nDESCRIPTION: This command initializes root state management files in a custom 'store' folder and registers NgRx root state providers in the given Angular module app.module.ts. It uses the --root flag for global provider registration, --state-path to define the folder for generated files, and --module to register in a specific module. Dependencies include @ngrx/store and @ngrx/store-devtools, and the command supports advanced folder structuring.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/schematics/store.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nng generate store State --root --state-path store --module app.module.ts\n```\n\n----------------------------------------\n\nTITLE: Configuring NgRx Store DevTools Zone Connection (ts)\nDESCRIPTION: Illustrates the change in configuration property for connecting NgRx Store DevTools relative to the Angular zone in v17. Before v17, `connectOutsideZone: true` was used to connect outside the zone; after v17, the default is outside the zone, and `connectInZone: true` is used to revert to connecting inside the zone.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v17.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nprovideStoreDevtools({\n    connectOutsideZone: true\n}),\n```\n\nLANGUAGE: ts\nCODE:\n```\nprovideStoreDevtools({\n    connectInZone: true\n}),\n```\n\n----------------------------------------\n\nTITLE: Refactoring SignalStoreFeature with Props (Before)\nDESCRIPTION: Shows the previous implementation of a signal store feature using `withComputed` and `EntityComputed` before the breaking change in NgRx 19.0.0-rc.0. This example defines a feature `withTotalEntities` relying on the `computed` property within the feature definition and the `EntityComputed` type.\nSOURCE: https://github.com/ngrx/platform/blob/main/CHANGELOG.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { computed, Signal } from '@angular/core';\nimport { signalStoreFeature, SignalStoreFeature, type, withComputed } from '@ngrx/signals';\nimport { EntityComputed } from '@ngrx/signals/entities';\n\nexport function withTotalEntities<Entity>(): SignalStoreFeature<{ state: {}; computed: EntityComputed<Entity>; methods: {} }, { state: {}; computed: { total: Signal<number> }; methods: {} }> {\n  return signalStoreFeature(\n    { computed: type<EntityComputed<Entity>>() },\n    withComputed(({ entities }) => ({\n      total: computed(() => entities().length),\n    }))\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Remove tapResponse operator from @ngrx/component-store\nDESCRIPTION: This code snippet shows the original import statement when `tapResponse` was part of `@ngrx/component-store`. After the update, this import statement is no longer valid.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v18.md#_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nimport { tapResponse  } from '@ngrx/component-store';\n```\n\n----------------------------------------\n\nTITLE: Installing @ngrx/effects with Angular CLI\nDESCRIPTION: This command installs @ngrx/effects using the Angular CLI's `ng add` command. It updates the `package.json` file, installs dependencies, and updates the application module with `EffectsModule.forRoot([AppEffects])` or `provideEffects()` for standalone components. Optional flags can customize the installation process.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/effects/install.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nng add @ngrx/effects@latest\n```\n\n----------------------------------------\n\nTITLE: Generating a Grouped User Feature Set - Shell\nDESCRIPTION: Generates a new 'User' feature with feature files (actions, effects, reducer, selectors) nested within their respective folders via the '--group' option. Requires Angular CLI and NgRx setup in the project. This command is suitable for organizing state feature code by type, which improves maintainability in large applications.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/schematics/feature.md#_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\nng generate feature User --group\n```\n\n----------------------------------------\n\nTITLE: Generate NgRx Selector - Grouped Example - sh\nDESCRIPTION: This snippet shows how to generate an NgRx selector named 'User' and place it within a nested 'selectors' folder. The `--group` option ensures the generated files are organized into a dedicated subdirectory.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/schematics/selector.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nng generate selector User --group\n```\n\n----------------------------------------\n\nTITLE: Installing ESLint plugin with npm\nDESCRIPTION: Installs the NgRx ESLint plugin as a dev dependency using npm.  This command adds the plugin to the project's package.json file. Requires npm to be installed.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/eslint-plugin/install.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nnpm install @ngrx/eslint-plugin --save-dev\n```\n\n----------------------------------------\n\nTITLE: Mutating Signal State Directly (Before Freezing)\nDESCRIPTION: Illustrates how direct state mutation within `patchState` was previously possible in NgRx Signals before development mode state freezing was introduced in version 19.0.0-beta.0. This mutable change to `state.user.firstName` would execute without error.\nSOURCE: https://github.com/ngrx/platform/blob/main/CHANGELOG.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst userState = signalState(initialState);\npatchState(userState, (state) => {\n  state.user.firstName = 'mutable change'; // mutable change which went through\n  return state;\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Ngrx Container Schematic Defaults (JSON)\nDESCRIPTION: Shows how to configure default options for the `@ngrx/schematics:container` in the `angular.json` file. This specific example sets the default style preprocessor for generated components to `scss`. Other schematic options can also be configured here.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/schematics/container.md#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n\"schematics\": {\n  \"@ngrx/schematics:container\": {\n    \"style\": \"scss\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Selectors With Props (Before v13 Deprecation) - TypeScript\nDESCRIPTION: Examples demonstrating the deprecated pattern of defining selectors that directly receive a `props` argument in the `createSelector` callback function or within a factory function. In v13, use 'normal' factory selectors instead.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v13.md#_snippet_11\n\nLANGUAGE: ts\nCODE:\n```\nconst selectCustomer = createSelector(\n    selectCustomers,\n    (customers, props: { customerId: number }) => {\n      return customers[props.customerId];\n    }\n);\n```\n\nLANGUAGE: ts\nCODE:\n```\nconst selectCustomer = () =>\n  createSelector(\n    selectCustomers,\n    (customers, props: { customerId: number }) => {\n      return customers[props.customerId];\n    }\n  );\n```\n\n----------------------------------------\n\nTITLE: ReactiveComponentModule deprecation: Before\nDESCRIPTION: This code snippet shows how to import the ReactiveComponentModule.  It is now deprecated and should be replaced with LetModule and PushModule.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v14.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ReactiveComponentModule } from '@ngrx/component';\n\n@NgModule({\n  imports: [\n    // ... other imports\n    ReactiveComponentModule,\n  ],\n})\nexport class MyFeatureModule {}\n```\n\n----------------------------------------\n\nTITLE: Using PushModule (Before Deprecation) in TypeScript\nDESCRIPTION: Illustrates the import and usage of `PushModule` within an Angular `NgModule` before it was deprecated in favor of the standalone `PushPipe` in NgRx v17. `PushModule` provided the `ngrxPush` pipe.\nSOURCE: https://github.com/ngrx/platform/blob/main/CHANGELOG.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { PushModule } from '@ngrx/component';\n\n@NgModule({\n  imports: [\n    // ... other imports\n    PushModule,\n  ],\n})\nexport class MyFeatureModule {}\n```\n\n----------------------------------------\n\nTITLE: Installing NgRx Component Nightly Build Shell\nDESCRIPTION: These commands install the latest nightly build of the NgRx Component package directly from the official NgRx GitHub builds repository. Use either npm or yarn to add the unreleased version of the package to your project dependencies.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/nightlies.md#_snippet_6\n\nLANGUAGE: Shell\nCODE:\n```\nnpm install github:ngrx/component-builds\n```\n\nLANGUAGE: Shell\nCODE:\n```\nyarn add github:ngrx/component-builds\n```\n\n----------------------------------------\n\nTITLE: Updating Angular CLI Globally (Bash)\nDESCRIPTION: Installs or updates the Angular CLI globally using npm. This command ensures the latest version of the Angular CLI is available on the system to generate the new boilerplate project.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/tools/examples/shared/boilerplate/UPDATING_CLI.md#_snippet_0\n\nLANGUAGE: Bash\nCODE:\n```\nnpm i -g @angular/cli\n```\n\n----------------------------------------\n\nTITLE: Run a Specific Schematic Unit Test with PNPM and Jest\nDESCRIPTION: These shell commands use PNPM and Jest to execute specific unit tests for schematics. The `--watch` flag enables continuous testing for the specified test file, re-running tests upon changes.\nSOURCE: https://github.com/ngrx/platform/blob/main/CONTRIBUTING.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\npnpm exec jest modules/schematics/src/effect/index.spec.ts --watch\n```\n\nLANGUAGE: shell\nCODE:\n```\npnpm exec jest <relative path> --watch\n```\n\n----------------------------------------\n\nTITLE: Building NgRx Library Modules with Bazel and Yarn (sh)\nDESCRIPTION: This command triggers the build process for the NgRx library modules using Bazel, the project's build tool. Running this command locally verifies that code changes compile correctly and helps catch build errors early. Requires `yarn` and a correctly configured Bazel environment.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/marketing/contributing.md#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\nyarn build\n```\n\n----------------------------------------\n\nTITLE: ActivatedRouteSnapshot.RouteConfig - JSON (BEFORE)\nDESCRIPTION: This JSON snippet shows the structure of the `routeConfig` property within the `ActivatedRouteSnapshot` before the change in NgRx v7. When the `routeConfig` did not exist, an empty object was returned.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v7.md#_snippet_9\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"routeConfig\": {}\n}\n```\n\n----------------------------------------\n\nTITLE: Updating NgRx Core Compose Import in TypeScript\nDESCRIPTION: Shows the change in import path for the `compose` function. In NgRx v4, `@ngrx/core` is removed and the `compose` function is available directly from `@ngrx/store`.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v4.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { compose } from '@ngrx/core/compose';\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { compose } from '@ngrx/store';\n```\n\n----------------------------------------\n\nTITLE: Testing Computed Properties in SignalStore with withComputed\nDESCRIPTION: This example shows how to test computed properties defined with withComputed in a SignalStore. The test verifies that the moviesCount computed property correctly reflects the number of movies in the store.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/signals/signal-store/testing.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport const MoviesStore = signalStore(\n  withState({\n    movies: [\n      // ... entries\n    ],\n  }),\n  withComputed((state) => ({\n    moviesCount: computed(() => state.movies().length),\n  }))\n);\n```\n\n----------------------------------------\n\nTITLE: Installing NgRx Dependencies using npm\nDESCRIPTION: Command to install core NgRx libraries (store, effects, entity, store-devtools) as project dependencies using the npm package manager. The `--save` flag ensures these dependencies are added to the `dependencies` section of your `package.json`.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/schematics/index.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm install @ngrx/{store,effects,entity,store-devtools} --save\n```\n\n----------------------------------------\n\nTITLE: Creating ChangeSetItems Manually in TypeScript\nDESCRIPTION: Demonstrates how to create an array of ChangeSetItem objects manually to define changes (add, delete, update, upsert) for multiple entities of different types within a single transaction.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/data/save-entities.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ChangeSetOperation } from '@ngrx/data';\n...\nconst changes: ChangeSetItem[] = [\n  {\n    op: ChangeSetOperation.Add,\n    entityName: 'Hero',\n    entities: [hero]\n  },\n  {\n    op: ChangeSetOperation.Delete,\n    entityName: 'Villain',\n    entities: [2, 3] // delete by their ids\n  }\n];\n```\n\n----------------------------------------\n\nTITLE: Import concatLatestFrom operator from @ngrx/operators\nDESCRIPTION: This code snippet shows the correct import statement for the `concatLatestFrom` operator after it has been moved to the `@ngrx/operators` package.  The old import from `@ngrx/effects` will no longer work.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/migration/v18.md#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nimport { concatLatestFrom } from '@ngrx/operators';\n```\n\n----------------------------------------\n\nTITLE: Immutability Violation: Modifying Action Property\nDESCRIPTION: This demonstrates a violation of the `strictActionImmutability` rule, where a developer attempts to modify an action property directly within a reducer. This is forbidden in NgRx as it can cause unpredictable state changes. This is shown with `todo.id = generateUniqueId()`.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/store/configuration/runtime-checks.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nexport const reducer = createReducer(initialState,\n  on(addTodo, (state, { todo }) => {\n    // Violation, it's not allowed to modify an action\n    todo.id = generateUniqueId();\n    return {\n      ...state,\n      todos: [...state.todos, todo]\n    }\n  })\n);\n```\n```\n\n----------------------------------------\n\nTITLE: Generate NgRx Selector - Basic Example - sh\nDESCRIPTION: This snippet demonstrates the basic usage of the `ng generate selector` command to create a selector named 'User'. By default, it generates the file without grouping it in a 'selectors' folder and includes a spec file.\nSOURCE: https://github.com/ngrx/platform/blob/main/projects/ngrx.io/content/guide/schematics/selector.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nng generate selector User\n```"
  }
]