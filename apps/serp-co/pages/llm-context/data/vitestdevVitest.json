[
  {
    "owner": "vitest-dev",
    "repo": "vitest",
    "content": "TITLE: Running Vitest Tests via CLI with Bash\nDESCRIPTION: This Bash snippet shows the command to run Vitest tests using npx. It assumes Node.js and Vitest are installed in the environment. Running `$ npx vitest` starts the Vitest test runner, executing test suites defined in the project and displaying the results in the terminal. This basic command serves as an entry point for developers to run their automated tests without any additional configuration flags.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/README.md#_snippet_1\n\nLANGUAGE: Bash\nCODE:\n```\n$ npx vitest\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Mock Functions with vi.fn\nDESCRIPTION: This snippet demonstrates how to create a mock function using `vi.fn` and track its execution. It shows how to invoke the mock function and access the arguments it was called with via the `mock.calls` property. This provides basic mocking functionality for tests.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/mock.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { vi } from 'vitest'\n\nconst fn = vi.fn()\nfn('hello world')\nfn.mock.calls[0] === ['hello world']\n```\n\n----------------------------------------\n\nTITLE: Using toMatchSnapshot() in Vitest (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to use `toMatchSnapshot()` in Vitest to create a snapshot of a function's output. The test will fail if the current output doesn't match the stored snapshot. Dependencies: vitest. Input: none. Output: A snapshot file is created or updated.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/snapshot.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { expect, it } from 'vitest'\n\nit('toUpperCase', () => {\n  const result = toUpperCase('foobar')\n  expect(result).toMatchSnapshot()\n})\n```\n\n----------------------------------------\n\nTITLE: Assert Value is Not String with Vitest\nDESCRIPTION: This demonstrates `assert.isNotString`, which asserts that a value is not a string.  It utilizes the `vitest` framework.  The input is a value, and the assertion passes if the value is not a string.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_32\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\nconst color = ['red', 'green', 'yellow']\n\ntest('assert.isNotString', () => {\n  assert.isNotString(color, 'color is not string but array')\n})\n```\n\n----------------------------------------\n\nTITLE: or Method - Combine Multiple Locators with OR Logic\nDESCRIPTION: Creates a locator that matches elements satisfying either of the provided locators. Useful when elements may match different criteria; caution advised if multiple elements are matched to avoid errors.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_24\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction or(locator: Locator): Locator\n```\n\n----------------------------------------\n\nTITLE: Defining Test Suites and Assertions with Vitest in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates how to create a test suite using Vitest's testing API. It imports key testing functions such as describe, it, expect, and assert from Vitest. The example defines three test cases using it blocks, showcasing various assertion styles including Jest-compatible expect matchers, Chai syntax, and snapshot testing. The snippet requires Vitest to be installed and configured in the project. Inputs are standard JavaScript operations and objects; outputs are assertions validating the expected behavior or data structure. This example illustrates basic usage patterns for writing tests in Vitest.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/README.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, describe, expect, it } from 'vitest'\n\ndescribe('suite name', () => {\n  it('foo', () => {\n    expect(1 + 1).toEqual(2)\n    expect(true).to.be.true\n  })\n\n  it('bar', () => {\n    assert.equal(Math.sqrt(4), 2)\n  })\n\n  it('snapshot', () => {\n    expect({ foo: 'bar' }).toMatchSnapshot()\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Installing Vitest using Package Managers\nDESCRIPTION: Commands to install Vitest as a development dependency using npm, yarn, pnpm, and bun. Vitest requires Vite >=v5.0.0 and Node >=v18.0.0.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/index.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install -D vitest\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn add -D vitest\n```\n\nLANGUAGE: bash\nCODE:\n```\npnpm add -D vitest\n```\n\nLANGUAGE: bash\nCODE:\n```\nbun add -D vitest\n```\n\n----------------------------------------\n\nTITLE: Testing Preact Components using Testing Library in Vitest (TSX)\nDESCRIPTION: Illustrates testing a Preact component (`HiddenMessage`) using `@testing-library/preact` within Vitest's browser mode. It renders the component, uses `page.elementLocator(baseElement)` to scope queries to the rendered output, queries elements using `screen.getByText().query()`, simulates a click via `screen.getByLabelText().click()`, and asserts the visibility change using `expect.element().toBeInTheDocument()`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/index.md#_snippet_19\n\nLANGUAGE: tsx\nCODE:\n```\n// based on @testing-library/preact example\n// https://testing-library.com/docs/preact-testing-library/example\n\nimport { h } from 'preact'\nimport { page } from '@vitest/browser/context'\nimport { render } from '@testing-library/preact'\n\nimport HiddenMessage from '../hidden-message'\n\ntest('shows the children when the checkbox is checked', async () => {\n  const testMessage = 'Test Message'\n\n  const { baseElement } = render(\n    <HiddenMessage>{testMessage}</HiddenMessage>,\n  )\n\n  const screen = page.elementLocator(baseElement)\n\n  // .query() will return the element or null if it cannot be found.\n  // .element() will return the element or throw an error if it cannot be found.\n  expect(screen.getByText(testMessage).query()).not.toBeInTheDocument()\n\n  // The queries can accept a regex to make your selectors more\n  // resilient to content tweaks and changes.\n  await screen.getByLabelText(/show/i).click()\n\n  await expect.element(screen.getByText(testMessage)).toBeInTheDocument()\n})\n```\n\n----------------------------------------\n\nTITLE: Mocking Modules with vi.mock\nDESCRIPTION: This code demonstrates how to mock a module using `vi.mock` in Vitest. It imports a module and mocks its `add` function to return a specific value. The `vi.mocked` helper is used to provide type safety when working with mocked modules.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport function add(x: number, y: number): number {\n  return x + y\n}\n\nexport function fetchSomething(): Promise<Response> {\n  return fetch('https://vitest.dev/')\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as example from './example'\n\nvi.mock('./example')\n\ntest('1 + 1 equals 10', async () => {\n  vi.mocked(example.add).mockReturnValue(10)\n  expect(example.add(1, 1)).toBe(10)\n})\n\ntest('mock return value with only partially correct typing', async () => {\n  vi.mocked(example.fetchSomething).mockResolvedValue(new Response('hello'))\n  vi.mocked(example.fetchSomething, { partial: true }).mockResolvedValue({ ok: false })\n  // vi.mocked(example.someFn).mockResolvedValue({ ok: false }) // this is a type error\n})\n```\n\n----------------------------------------\n\nTITLE: Declaring unhover Function in Vitest (TypeScript)\nDESCRIPTION: Defines the unhover function signature for triggering mouse leave events, moving cursor focus to document.body. Inherits same parameters as hover (UserEventHoverOptions), returns a Promise when unhover is executed. Ensures clearing hover state from elements for accurate state transitions in tests. Outputs a void Promise on completion.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_36\n\nLANGUAGE: typescript\nCODE:\n```\nfunction unhover(options?: UserEventHoverOptions): Promise<void>\n```\n\n----------------------------------------\n\nTITLE: Filtering Tests with Vitest CLI - Bash\nDESCRIPTION: Demonstrates how to run Vitest in the current directory and filter test files by name inclusion. This command expects Vitest to be installed globally or available via package scripts and accepts an argument that filters test file paths for matches containing the given string. The filter is a simple substring match, not a glob or regex. Input: \"foobar\" as the file filter. Output: Runs only test files whose path includes \"foobar\". No external dependencies besides Vitest itself.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/cli.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nvitest foobar\n\n```\n\n----------------------------------------\n\nTITLE: Spying on Object Methods with vi.spyOn\nDESCRIPTION: This snippet demonstrates the use of `vi.spyOn` to track calls to a method on an existing object. It shows how to spy on a method, call the method, and then assert that the method was called using the `mock.calls.length` property. This is useful for verifying that a method was called during a test.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/mock.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst market = {\n  getApples: () => 100\n}\n\nconst getApplesSpy = vi.spyOn(market, 'getApples')\nmarket.getApples()\ngetApplesSpy.mock.calls.length === 1\n```\n\n----------------------------------------\n\nTITLE: Setting One-Time Return Value with mockReturnValueOnce\nDESCRIPTION: This example showcases how to use `mockReturnValueOnce` to set different return values for consecutive calls to a mock function. After the `mockReturnValueOnce` values are exhausted, the default return value (if any) is used. TypeScript ensures that the provided value matches the return type of the original function.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/mock.md#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nconst myMockFn = vi\n  .fn()\n  .mockReturnValue('default')\n  .mockReturnValueOnce('first call')\n  .mockReturnValueOnce('second call')\n\n// 'first call', 'second call', 'default', 'default'\nconsole.log(myMockFn(), myMockFn(), myMockFn(), myMockFn())\n```\n\n----------------------------------------\n\nTITLE: Creating Mock Functions with vi.fn\nDESCRIPTION: This snippet showcases the creation of a mock function using `vi.fn`. It demonstrates how to track calls, return values, and manipulate the mock's behavior using methods like `mockReturnValueOnce`. It returns a Mock object that can be used to track calls and set return values.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nconst getApples = vi.fn(() => 0)\n\ngetApples()\n\nexpect(getApples).toHaveBeenCalled()\nexpect(getApples).toHaveReturnedWith(0)\n\ngetApples.mockReturnValueOnce(5)\n\nconst res = getApples()\nexpect(res).toBe(5)\nexpect(getApples).toHaveNthReturnedWith(2, 5)\n```\n\n----------------------------------------\n\nTITLE: Initializing Vitest Test Runner with startVitest Function (TypeScript/JavaScript)\nDESCRIPTION: This snippet demonstrates how to start Vitest tests programmatically using the startVitest API in Node.js, configuring mode, filters, and options. It provides an example of managing test execution lifecycle, including automatic closure in non-watch mode, and accessing test module results through the returned Vitest instance.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { startVitest } from 'vitest/node'\n\nconst vitest = await startVitest('test')\n\nawait vitest.close()\n```\n\n----------------------------------------\n\nTITLE: Concurrent Suite Execution with Vitest in TypeScript\nDESCRIPTION: This snippet demonstrates how to execute an entire test suite concurrently using the 'describe.concurrent' modifier in Vitest with TypeScript. The 'vitest' library must be present in the environment. The example defines a suite where all contained tests are automatically run in parallel, increasing test throughput. Inputs are test suite and test definitions; outputs are concurrent execution results. For proper snapshot and assertion behavior, testers should use the 'expect' from the current test context.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/features.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { describe, it } from 'vitest'\n\n// All tests within this suite will be started in parallel\ndescribe.concurrent('suite', () => {\n  it('concurrent test 1', async ({ expect }) => { /* ... */ })\n  it('concurrent test 2', async ({ expect }) => { /* ... */ })\n  it.concurrent('concurrent test 3', async ({ expect }) => { /* ... */ })\n})\n\n```\n\n----------------------------------------\n\nTITLE: Using assert.notProperty in Vitest (TypeScript)\nDESCRIPTION: Illustrates `assert.notProperty`, used to assert that an object does not have a specific property, either directly or inherited. The snippet imports from `vitest` and checks for the absence of the 'coffee' property within a test function.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_57\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.notProperty', () => {\n  assert.notProperty({ tea: { green: 'matcha' } }, 'coffee')\n})\n```\n\n----------------------------------------\n\nTITLE: Asserting Async Function Throws Error with rejects and toThrowError in Vitest\nDESCRIPTION: Demonstrates the recommended way to test asynchronous functions that reject with an error by combining `await expect()` with `.rejects.toThrowError()`. The example shows checking if a promise rejects with an error containing a specific substring.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_14\n\nLANGUAGE: js\nCODE:\n```\nfunction getAsyncFruitStock() {\n  return Promise.reject(new Error('empty'))\n}\n\ntest('throws on pineapples', async () => {\n  await expect(() => getAsyncFruitStock()).rejects.toThrowError('empty')\n})\n```\n\n----------------------------------------\n\nTITLE: Defining a Test Case with Vitest test Function in TypeScript\nDESCRIPTION: This example shows how to define a basic Vitest test case using the test() function, passing a descriptive string name and a callback as parameters. The snippet requires Vitest as a dependency and expects a test environment configured accordingly. The input is no argument (other than the name and test function), and there is no explicit output; the test will appear in Vitest's results. Useful for simple validation and demonstration purposes.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/test-case.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { test } from 'vitest'\n\ntest('the validation works correctly', () => {\n  // ...\n})\n```\n\n----------------------------------------\n\nTITLE: Asserting Value Types with Vitest assertType in TypeScript\nDESCRIPTION: This snippet demonstrates use of the assertType function from Vitest to perform compile-time type assertions in TypeScript. It shows how to use assertType generically to ensure the value matches the expected type and how TypeScript will throw errors on type mismatches. The example includes multiple function overloads and explicit demonstration of correct and incorrect type assertions. Requires the Vitest framework and a TypeScript environment; passing the --typecheck flag enables active type checking. Inputs are values and generic types, while outputs occur only at type checking (no runtime effect). Limitations include lack of runtime checking; errors are only surfaced at build/type-check time.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert-type.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assertType } from 'vitest'\n\nfunction concat(a: string, b: string): string\nfunction concat(a: number, b: number): number\nfunction concat(a: string | number, b: string | number): string | number\n\nassertType<string>(concat('a', 'b'))\nassertType<number>(concat(1, 2))\n// @ts-expect-error wrong types\nassertType(concat('a', 2))\n\n```\n\n----------------------------------------\n\nTITLE: Vitest Test Sharding GitHub Actions Workflow (YAML)\nDESCRIPTION: Provides a complete GitHub Actions workflow example demonstrating how to run sharded Vitest tests in parallel across multiple jobs using a matrix strategy. It includes steps for checkout, node setup, dependency installation, running sharded tests, uploading reports, downloading reports, and merging them.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/improving-performance.md#_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\n# Inspired from https://playwright.dev/docs/test-sharding\nname: Tests\non:\n  push:\n    branches:\n      - main\njobs:\n  tests:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        shardIndex: [1, 2, 3, 4]\n        shardTotal: [4]\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: 20\n\n      - name: Install pnpm\n        uses: pnpm/action-setup@a7487c7e89a18df4991f7f222e4898a00d66ddda # v4.1.0\n\n      - name: Install dependencies\n        run: pnpm i\n\n      - name: Run tests\n        run: pnpm run test --reporter=blob --shard=${{ matrix.shardIndex }}/${{ matrix.shardTotal }}\n\n      - name: Upload blob report to GitHub Actions Artifacts\n        if: ${{ !cancelled() }}\n        uses: actions/upload-artifact@v4\n        with:\n          name: blob-report-${{ matrix.shardIndex }}\n          path: .vitest-reports/*\n          include-hidden-files: true\n          retention-days: 1\n\n  merge-reports:\n    if: ${{ !cancelled() }}\n    needs: [tests]\n\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: 20\n\n      - name: Install pnpm\n        uses: pnpm/action-setup@a7487c7e89a18df4991f7f222e4898a00d66ddda # v4.1.0\n\n      - name: Install dependencies\n        run: pnpm i\n\n      - name: Download blob reports from GitHub Actions Artifacts\n        uses: actions/download-artifact@v4\n        with:\n          path: .vitest-reports\n          pattern: blob-report-*\n          merge-multiple: true\n\n      - name: Merge reports\n        run: npx vitest --merge-reports\n```\n\n----------------------------------------\n\nTITLE: Snapshot Testing with Vitest in TypeScript\nDESCRIPTION: This snippet shows how to implement snapshot testing with Vitest using its Jest-compatible API. It requires vitest to be installed and proper configuration for snapshot storage. The function 'render' is called, and its output is asserted to match an existing or new snapshot. Expected input is a result from the 'render' function; expected output is a comparison against a stored reference. Testers should ensure their environment supports file I/O for saving and comparing snapshots.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/features.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { expect, it } from 'vitest'\n\nit('renders correctly', () => {\n  const result = render()\n  expect(result).toMatchSnapshot()\n})\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Vitest Workspaces (vitest.config.ts)\nDESCRIPTION: Demonstrates configuring Vitest Workspaces within `vitest.config.ts`. The `test.workspace` property accepts an array of glob patterns pointing to config files or directories containing them, or specific configuration objects to run tests under different settings (e.g., different environments like 'happy-dom' and 'node').\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/index.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    workspace: [\n      // you can use a list of glob patterns to define your workspaces\n      // Vitest expects a list of config files\n      // or directories where there is a config file\n      'packages/*',\n      'tests/*/vitest.config.{e2e,unit}.ts',\n      // you can even run the same tests,\n      // but with different configs in the same \"vitest\" process\n      {\n        test: {\n          name: 'happy-dom',\n          root: './shared_tests',\n          environment: 'happy-dom',\n          setupFiles: ['./setup.happy-dom.ts'],\n        },\n      },\n      {\n        test: {\n          name: 'node',\n          root: './shared_tests',\n          environment: 'node',\n          setupFiles: ['./setup.node.ts'],\n        },\n      },\n    ],\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: getByText Function - Find Elements by Text Content\nDESCRIPTION: Creates a locator to find elements containing specific text, matching against nodeValue or input's value. Supports exact and regex matching with whitespace normalization. Useful for non-interactive element selection.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_17\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction getByText(\n  text: string | RegExp,\n  options?: LocatorOptions,\n): Locator\n```\n\n----------------------------------------\n\nTITLE: Asserting Synchronous Function Throws Error with Vitest\nDESCRIPTION: Illustrates various ways to use `.toThrowError()` with a synchronous function call. It shows how to assert that a function throws an error and how to check the error message using regular expressions, substrings, exact string matches, Error objects, or object containing matchers like `expect.objectContaining`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_13\n\nLANGUAGE: ts\nCODE:\n```\nimport { expect, test } from 'vitest'\n\nfunction getFruitStock(type: string) {\n  if (type === 'pineapples') {\n    throw new Error('Pineapples are not in stock')\n  }\n\n  // Do some other stuff\n}\n\ntest('throws on pineapples', () => {\n  // Test that the error message says \"stock\" somewhere: these are equivalent\n  expect(() => getFruitStock('pineapples')).toThrowError(/stock/)\n  expect(() => getFruitStock('pineapples')).toThrowError('stock')\n\n  // Test the exact error message\n  expect(() => getFruitStock('pineapples')).toThrowError(\n    /^Pineapples are not in stock$/,\n  )\n\n  expect(() => getFruitStock('pineapples')).toThrowError(\n    new Error('Pineapples are not in stock'),\n  )\n  expect(() => getFruitStock('pineapples')).toThrowError(expect.objectContaining({\n    message: 'Pineapples are not in stock',\n  }))\n})\n```\n\n----------------------------------------\n\nTITLE: Setting Return Value with mockReturnValue\nDESCRIPTION: This snippet demonstrates how to configure a mock function to return a specific value using `mockReturnValue`.  TypeScript checks that the return value type matches that of the original function.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/mock.md#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nconst mock = vi.fn()\nmock.mockReturnValue(42)\nmock() // 42\nmock.mockReturnValue(43)\nmock() // 43\n```\n\n----------------------------------------\n\nTITLE: Configuration Structure in Vitest Config File\nDESCRIPTION: Demonstrates the proper structure of the configuration object in Vitest config file, showing that browser options should be nested within the test property.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/config.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport default defineConfig({\n  test: {\n    browser: {},\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Saving Test Results with Blob Reporter in Vitest CLI\nDESCRIPTION: Stores test results on the local machine as JSON files to allow merging reports from multiple test runs or machines. The output folder defaults to '.vitest-reports' but can be overridden via '--outputFile' or '--outputFile.blob' CLI flags. Recommended for use with the '--shard' option in distributed testing setups. Blob reports cannot be used in watch mode. Provides an example CLI command to save blob reports and a follow-up command to merge them into a JSON and default reporter output.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/reporters.md#_snippet_22\n\nLANGUAGE: bash\nCODE:\n```\nnpx vitest --reporter=blob --outputFile=reports/blob-1.json\n```\n\nLANGUAGE: bash\nCODE:\n```\nnpx vitest --merge-reports=reports --reporter=json --reporter=default\n```\n\n----------------------------------------\n\nTITLE: Asserting an Object is Not an Instance of a Constructor using Vitest (TypeScript)\nDESCRIPTION: Illustrates using `assert.notInstanceOf` in a Vitest test to check that an object is *not* an instance of a given constructor or class. Requires `assert` and `test`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_41\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\nfunction Person(name) { this.name = name }\nconst foo = new Person('foo')\n\nclass Tea {\n  constructor(name) {\n    this.name = name\n  }\n}\nconst coffee = new Tea('coffee')\n\ntest('assert.instanceOf', () => {\n  assert.instanceOf(foo, Tea, 'foo is not an instance of Tea')\n})\n```\n\n----------------------------------------\n\nTITLE: In-Source Testing with Vitest TypeScript API (Inspired by Rust)\nDESCRIPTION: This snippet shows how to co-locate implementation and test code within the same TypeScript source file, leveraging the 'import.meta.vitest' property. Dependencies include TypeScript, Vitest, and a setup that recognizes 'import.meta.vitest'. The test context is conditionally imported, and tests are defined in the same closure as the implementation, facilitating direct access to private states. Inputs are typical function arguments; outputs are assertions on function behavior. This setup reduces the need for exports solely for testing purposes.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/features.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n// the implementation\nexport function add(...args: number[]): number {\n  return args.reduce((a, b) => a + b, 0)\n}\n\n// in-source test suites\nif (import.meta.vitest) {\n  const { it, expect } = import.meta.vitest\n  it('add', () => {\n    expect(add()).toBe(0)\n    expect(add(1)).toBe(1)\n    expect(add(1, 2, 3)).toBe(6)\n  })\n}\n\n```\n\n----------------------------------------\n\nTITLE: TSX example using `getByAltText` with a regular expression\nDESCRIPTION: This TSX snippet demonstrates locating an image element using `getByAltText` with a regular expression to match the `alt` attribute.  It includes a positive and negative example. Requires a TSX environment that supports JSX syntax. No external dependencies needed other than a rendering context for the TSX.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_12\n\nLANGUAGE: tsx\nCODE:\n```\n<img alt=\"Incredibles 2 Poster\" src=\"/incredibles-2.png\" />\n\npage.getByAltText(/incredibles.*? poster/i) // ✅\npage.getByAltText('non existing alt text') // ❌\n```\n\n----------------------------------------\n\nTITLE: Showing query Behavior with Sample DOM and Locators (TypeScript and HTML)\nDESCRIPTION: Demonstrates the behavior of .query() with different locators on a sample DOM structure. Shows both successful and error-throwing calls. Requires page object and the correct HTML structure matching test selectors. Input consists of DOM nodes, output is Element or null; ambiguous selectors throw exceptions.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_47\n\nLANGUAGE: html\nCODE:\n```\n<div>Hello <span>World</span></div>\n<div>Hello</div>\n```\n\nLANGUAGE: typescript\nCODE:\n```\npage.getByText('Hello World').query() // ✅ HTMLDivElement\npage.getByText('Hello Germany').query() // ✅ null\npage.getByText('World').query() // ✅ HTMLSpanElement\npage.getByText('Hello', { exact: true }).query() // ✅ HTMLSpanElement\n```\n\nLANGUAGE: typescript\nCODE:\n```\n// returns multiple elements\npage.getByText('Hello').query() // ❌\npage.getByText(/^Hello/).query() // ❌\n```\n\n----------------------------------------\n\nTITLE: vi.doMock usage to mock modules dynamically after imports (TypeScript)\nDESCRIPTION: Shows how to use vi.doMock to mock modules without hoisting, allowing factory functions reference to variables defined in outer scopes. Demonstrates that existing static imports are not mocked retroactively but subsequent dynamic imports are mocked, useful for conditional mocking scenarios. The snippet includes a module exporting increment and a test file showing beforeEach vi.doMock and dynamic import usage.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport function increment(number) {\n  return number + 1\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { beforeEach, test } from 'vitest'\nimport { increment } from './increment.js'\n\n// the module is not mocked, because vi.doMock is not called yet\nincrement(1) === 2\n\nlet mockedIncrement = 100\n\nbeforeEach(() => {\n  // you can access variables inside a factory\n  vi.doMock('./increment.js', () => ({ increment: () => ++mockedIncrement }))\n})\n\ntest('importing the next module imports mocked one', async () => {\n  // original import WAS NOT MOCKED, because vi.doMock is evaluated AFTER imports\n  expect(increment(1)).toBe(2)\n  const { increment: mockedIncrement } = await import('./increment.js')\n  // new dynamic import returns mocked module\n  expect(mockedIncrement(1)).toBe(101)\n  expect(mockedIncrement(1)).toBe(102)\n  expect(mockedIncrement(1)).toBe(103)\n})\n```\n\n----------------------------------------\n\nTITLE: VS Code Launch Configuration for Debugging\nDESCRIPTION: This JSON configuration allows debugging the current test file in VS Code. It uses the 'node' debugger, specifies the Vitest entry point, and passes the 'run' command with the relative file path as arguments.  It skips internal node and node_modules files. Requires VS Code and Vitest to be installed.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/debugging.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"type\": \"node\",\n      \"request\": \"launch\",\n      \"name\": \"Debug Current Test File\",\n      \"autoAttachChildProcesses\": true,\n      \"skipFiles\": [\"<node_internals>/**\", \"**/node_modules/**\"],\n      \"program\": \"${workspaceRoot}/node_modules/vitest/vitest.mjs\",\n      \"args\": [\"run\", \"${relativeFile}\"],\n      \"smartStep\": true,\n      \"console\": \"integratedTerminal\"\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Function Mocking with Vitest, Tinyspy, and Jest APIs in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates mocking functions using Vitest’s built-in 'vi' object, which provides Jest-compatible mock and assertion APIs via Tinyspy. It shows creating a mock function, tracking its calls and results, and implementing custom behavior dynamically. Dependencies include Vitest and TypeScript. Expected input is function invocations; expected output includes assertions on call arguments and mock results. Some matchers may require enabling global test variables for third-party integrations.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/features.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { expect, vi } from 'vitest'\n\nconst fn = vi.fn()\n\nfn('hello', 1)\n\nexpect(vi.isMockFunction(fn)).toBe(true)\nexpect(fn.mock.calls[0]).toEqual(['hello', 1])\n\nfn.mockImplementation((arg: string) => arg)\n\nfn('world', 2)\n\nexpect(fn.mock.results[1].value).toBe('world')\n\n```\n\n----------------------------------------\n\nTITLE: Asserting Spy Function Was Called With Specific Arguments in Vitest\nDESCRIPTION: Explains how to use `.toHaveBeenCalledWith()` to check if a spy function was called at least once with the specified arguments. This is useful for verifying interaction details with mock functions.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_22\n\nLANGUAGE: ts\nCODE:\n```\nimport { expect, test, vi } from 'vitest'\n\nconst market = {\n  buy(subject: string, amount: number) {\n    // ...\n  },\n}\n\ntest('spy function', () => {\n  const buySpy = vi.spyOn(market, 'buy')\n\n  market.buy('apples', 10)\n  market.buy('apples', 20)\n\n  expect(buySpy).toHaveBeenCalledWith('apples', 10)\n  expect(buySpy).toHaveBeenCalledWith('apples', 20)\n})\n```\n\n----------------------------------------\n\nTITLE: last Method - Target Last Element in Multiple Matches\nDESCRIPTION: Returns a locator for the last element in a set of matched elements, equivalent to `nth(-1)`. Facilitates selection of the final element in a collection.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_22\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction last(): Locator\n```\n\n----------------------------------------\n\nTITLE: Using vi.waitUntil to Wait for Element Existence in Vitest (TypeScript)\nDESCRIPTION: Shows how to use `vi.waitUntil` to wait until a callback returns a truthy value (e.g., a DOM element exists via `document.querySelector`) without throwing errors. If the callback throws, `waitUntil` fails immediately, unlike `waitFor`. This example waits for '.element' to appear before performing assertions. Configurable `timeout` and `interval` options are shown. Dependencies include `vitest` (`expect`, `test`, `vi`).\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\nimport { expect, test, vi } from 'vitest'\n\ntest('Element render correctly', async () => {\n  const element = await vi.waitUntil(\n    () => document.querySelector('.element'),\n    {\n      timeout: 500, // default is 1000\n      interval: 20, // default is 50\n    }\n  )\n\n  // do something with the element\n  expect(element.querySelector('.element-child')).toBeTruthy()\n})\n```\n\n----------------------------------------\n\nTITLE: Asserting Object Lacks Specific Keys with Vitest (TypeScript)\nDESCRIPTION: Demonstrates using `assert.doesNotHaveAnyKeys` in Vitest to verify that an object (or Map/Set) does not contain any of the specified keys. Keys can be provided as an array of strings/objects or as the keys of another object.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_72\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.doesNotHaveAnyKeys', () => {\n  assert.doesNotHaveAnyKeys({ foo: 1, bar: 2, baz: 3 }, ['one', 'two', 'example'])\n  assert.doesNotHaveAnyKeys({ foo: 1, bar: 2, baz: 3 }, { one: 1, two: 2, example: 'foo' })\n  assert.doesNotHaveAnyKeys(new Map([[{ foo: 1 }, 'bar'], ['key', 'value']]), [{ one: 'two' }, 'example'])\n  assert.doesNotHaveAnyKeys(new Set([{ foo: 'bar' }, 'anotherKey'], [{ one: 'two' }, 'example']))\n})\n```\n\n----------------------------------------\n\nTITLE: Locating elements by alt text with `getByAltText` in Vitest (TS)\nDESCRIPTION: This snippet demonstrates how to locate elements by their `alt` attribute using the `getByAltText` method in Vitest.  It showcases the usage with a regular expression to match the alt text. Requires the Vitest environment to be configured for browser mode testing. Returns a Locator object.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nfunction getByAltText(\n  text: string | RegExp,\n  options?: LocatorOptions,\n): Locator\n```\n\n----------------------------------------\n\nTITLE: Using expect.any Matcher with Constructor in Vitest (TypeScript)\nDESCRIPTION: Demonstrates the `expect.any(constructor)` asymmetric matcher used with `toEqual`. It checks if the actual value is an instance of the provided constructor (e.g., `Number`), useful when the exact value is dynamic but the type is known.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_45\n\nLANGUAGE: typescript\nCODE:\n```\nimport { expect, test } from 'vitest'\nimport { generateId } from './generators.js'\n\ntest('\"id\" is a number', () => {\n  expect({ id: generateId() }).toEqual({ id: expect.any(Number) })\n})\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Test Fixtures in Vitest\nDESCRIPTION: Example of using test.extend to create custom test fixtures with setup and teardown logic for todos and archive arrays.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/test-context.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { test } from 'vitest'\n\nconst todos = []\nconst archive = []\n\nexport const myTest = test.extend({\n  todos: async ({}, use) => {\n    // setup the fixture before each test function\n    todos.push(1, 2, 3)\n\n    // use the fixture value\n    await use(todos)\n\n    // cleanup the fixture after each test function\n    todos.length = 0\n  },\n  archive\n})\n```\n\n----------------------------------------\n\nTITLE: Asserting Strict Deep Equality with Vitest in TypeScript\nDESCRIPTION: `toStrictEqual` extends `toEqual` by checking types, sparseness, and undefined keys strictly between two values, detecting semantic differences such as class instances vs object literals. Requires Vitest. Inputs are received values; output is strict equality assertion result.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { expect, test } from 'vitest'\n\nclass Stock {\n  constructor(type) {\n    this.type = type\n  }\n}\n\ntest('structurally the same, but semantically different', () => {\n  expect(new Stock('apples')).toEqual({ type: 'apples' })\n  expect(new Stock('apples')).not.toStrictEqual({ type: 'apples' })\n})\n```\n\n----------------------------------------\n\nTITLE: Verifying Assertion Calls with expect.hasAssertions in Vitest (TypeScript)\nDESCRIPTION: Demonstrates using `expect.hasAssertions()` within a Vitest test to ensure that at least one assertion is executed, which is particularly useful for verifying asynchronous code like callbacks. The example shows a test that would incorrectly pass without `expect.hasAssertions()` if the asynchronous `select` function wasn't awaited or didn't trigger the callback.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_42\n\nLANGUAGE: typescript\nCODE:\n```\nimport { expect, test } from 'vitest'\nimport { db } from './db.js'\n\nconst cbs = []\n\nfunction onSelect(cb) {\n  cbs.push(cb)\n}\n\n// after selecting from db, we call all callbacks\nfunction select(id) {\n  return db.select({ id }).then((data) => {\n    return Promise.all(\n      cbs.map(cb => cb(data)),\n    )\n  })\n}\n\ntest('callback was called', async () => {\n  expect.hasAssertions()\n  onSelect((data) => {\n    // should be called on select\n    expect(data).toBeTruthy()\n  })\n  // if not awaited, test will fail\n  // if you don't have expect.hasAssertions(), test will pass\n  await select(3)\n})\n```\n\n----------------------------------------\n\nTITLE: Framework-Specific Vitest Browser Mode Configuration Examples - TypeScript\nDESCRIPTION: Multiple example configurations for enabling Vitest browser mode with Playwright provider integrated with specific frameworks such as React, Vue, Svelte, Solid, and Marko. Each snippet shows importing the framework-specific Vite plugin, registering it, and enabling browser mode with chromium instance. These examples assist framework users in setting up Vitest browser tests.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/index.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\nimport react from '@vitejs/plugin-react'\n\nexport default defineConfig({\n  plugins: [react()],\n  test: {\n    browser: {\n      enabled: true,\n      provider: 'playwright',\n      instances: [\n        { browser: 'chromium' },\n      ],\n    }\n  }\n})\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\nimport vue from '@vitejs/plugin-vue'\n\nexport default defineConfig({\n  plugins: [vue()],\n  test: {\n    browser: {\n      enabled: true,\n      provider: 'playwright',\n      instances: [\n        { browser: 'chromium' },\n      ],\n    }\n  }\n})\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\nimport { svelte } from '@sveltejs/vite-plugin-svelte'\n\nexport default defineConfig({\n  plugins: [svelte()],\n  test: {\n    browser: {\n      enabled: true,\n      provider: 'playwright',\n      instances: [\n        { browser: 'chromium' },\n      ],\n    }\n  }\n})\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\nimport solidPlugin from 'vite-plugin-solid'\n\nexport default defineConfig({\n  plugins: [solidPlugin()],\n  test: {\n    browser: {\n      enabled: true,\n      provider: 'playwright',\n      instances: [\n        { browser: 'chromium' },\n      ],\n    }\n  }\n})\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\nimport marko from '@marko/vite'\n\nexport default defineConfig({\n  plugins: [marko()],\n  test: {\n    browser: {\n      enabled: true,\n      provider: 'playwright',\n      instances: [\n        { browser: 'chromium' },\n      ],\n    }\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Asserting Containment in Arrays or Strings with Vitest in TypeScript\nDESCRIPTION: `toContain` asserts that a string is a substring or an array contains a specific element. In browser environments, it supports checking DOM class lists or element containment. Inputs are arrays, strings, or iterable objects; outputs are assertion results. Requires Vitest and optionally browser DOM.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { expect, test } from 'vitest'\nimport { getAllFruits } from './stocks.js'\n\ntest('the fruit list contains orange', () => {\n  expect(getAllFruits()).toContain('orange')\n\n  const element = document.querySelector('#el')\n  // element has a class\n  expect(element.classList).toContain('flex')\n  // element is inside another one\n  expect(document.querySelector('#wrapper')).toContain(element)\n})\n```\n\n----------------------------------------\n\nTITLE: Assert Value is Not Array with Vitest\nDESCRIPTION: This snippet shows `assert.isNotArray`, which asserts that a value is not an array.  It utilizes the `vitest` testing framework.  The input is a value, and the assertion passes if the value is not an array.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_30\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\nconst color = 'red'\n\ntest('assert.isNotArray', () => {\n  assert.isNotArray(color, 'color is not array but string')\n})\n```\n\n----------------------------------------\n\nTITLE: Setting the Global Test Name Filter Pattern in Vitest (TypeScript)\nDESCRIPTION: Overrides the global test name pattern filter (`config.testNamePattern`) with the provided string or RegExp. This change takes effect on subsequent test runs triggered via methods like `runTestSpecifications`; it doesn't initiate a run itself.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/vitest.md#_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nfunction setGlobalTestNamePattern(pattern: string | RegExp): void\n```\n\n----------------------------------------\n\nTITLE: Type Checking with Vitest and TypeScript\nDESCRIPTION: This snippet demonstrates how to perform type checking with Vitest using `expectTypeOf` and `assertType`. It imports necessary functions from 'vitest' and a local module 'mount.js'. It then defines a test case that asserts the type of the `mount` function and its parameters, including expecting a type error.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/testing-types.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assertType, expectTypeOf } from 'vitest'\nimport { mount } from './mount.js'\n\ntest('my types work properly', () => {\n  expectTypeOf(mount).toBeFunction()\n  expectTypeOf(mount).parameter(0).toMatchTypeOf<{ name: string }>()\n\n  // @ts-expect-error name is a string\n  assertType(mount({ name: 42 }))\n})\n```\n\n----------------------------------------\n\nTITLE: Workspace Configuration for Mixed Node and Browser Testing in Vitest - TypeScript\nDESCRIPTION: Example of a Vitest workspace configuration splitting tests into separate environments: Node for unit tests and browser mode for browser tests. Supports file pattern conventions to organize tests by environment and enables the browser mode with a Chromium instance separately. Useful for projects requiring both test types.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/index.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineWorkspace } from 'vitest/config'\n\nexport default defineWorkspace([\n  {\n    test: {\n      // an example of file based convention,\n      // you don't have to follow it\n      include: [\n        'tests/unit/**/*.{test,spec}.ts',\n        'tests/**/*.unit.{test,spec}.ts',\n      ],\n      name: 'unit',\n      environment: 'node',\n    },\n  },\n  {\n    test: {\n      // an example of file based convention,\n      // you don't have to follow it\n      include: [\n        'tests/browser/**/*.{test,spec}.ts',\n        'tests/**/*.browser.{test,spec}.ts',\n      ],\n      name: 'browser',\n      browser: {\n        enabled: true,\n        instances: [\n          { browser: 'chromium' },\n        ],\n      },\n    },\n  },\n])\n```\n\n----------------------------------------\n\nTITLE: Running Benchmark Tests with Vitest and Tinybench in TypeScript\nDESCRIPTION: This TypeScript snippet uses the 'bench' function from Vitest, which integrates with Tinybench to compare the performance of two sorting operations. Requires Vitest and optionally Tinybench. The code defines two benchmarks: normal sort and reverse sort, each working with the same array. The inputs are arrays; outputs are benchmark results for performance comparison. The feature is experimental and should be used in compatible environments.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/features.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { bench, describe } from 'vitest'\n\ndescribe('sort', () => {\n  bench('normal', () => {\n    const x = [1, 5, 4, 2, 3]\n    x.sort((a, b) => {\n      return a - b\n    })\n  })\n\n  bench('reverse', () => {\n    const x = [1, 5, 4, 2, 3]\n    x.reverse().sort((a, b) => {\n      return a - b\n    })\n  })\n})\n\n```\n\n----------------------------------------\n\nTITLE: TSX example demonstrating `exact` option for `getByRole`\nDESCRIPTION: This TSX snippet illustrates the usage of the `exact` option with `getByRole`. It highlights the difference between case-insensitive substring matching (default) and case-sensitive whole-string matching when locating elements by ARIA role. Requires a TSX environment that supports JSX syntax. No external dependencies needed other than a rendering context for the TSX.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\n<button>Hello World</button>\n\npage.getByRole('button', { name: 'hello world' }) // ✅\npage.getByRole('button', { name: 'hello world', exact: true }) // ❌\npage.getByRole('button', { name: 'Hello World', exact: true }) // ✅\n```\n\n----------------------------------------\n\nTITLE: Asserting Element Attributes in Vitest Tests (JavaScript)\nDESCRIPTION: Checks for the existence of a specific attribute on a DOM element, and optionally verifies its value. Useful for testing element state or configuration defined by attributes. Supports exact value match or partial matches using `expect.stringContaining`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_15\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction toHaveAttribute(attribute: string, value?: unknown): Promise<void>\n```\n\nLANGUAGE: HTML\nCODE:\n```\n<button data-testid=\"ok-button\" type=\"submit\" disabled>ok</button>\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst button = getByTestId('ok-button')\n\nawait expect.element(button).toHaveAttribute('disabled')\nawait expect.element(button).toHaveAttribute('type', 'submit')\nawait expect.element(button).not.toHaveAttribute('type', 'button')\n\nawait expect.element(button).toHaveAttribute(\n  'type',\n  expect.stringContaining('sub')\n)\nawait expect.element(button).toHaveAttribute(\n  'type',\n  expect.not.stringContaining('but')\n)\n```\n\n----------------------------------------\n\nTITLE: Using resolves to Handle Asynchronous Assertions\nDESCRIPTION: This code illustrates the use of `resolves` to unwrap promises for assertions, ensuring that the promise resolves successfully before performing further matchers. It emphasizes awaiting the assertion to avoid false positives.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_39\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { expect, test } from 'vitest'\n\nasync function buyApples() {\n  return fetch('/buy/apples').then(r => r.json())\n}\n\ntest('buyApples returns new stock id', async () => {\n  // toEqual returns a promise now, so you HAVE to await it\n  await expect(buyApples()).resolves.toEqual({ id: 1 }) // jest API\n  await expect(buyApples()).resolves.to.equal({ id: 1 }) // chai API\n})\n```\n\n----------------------------------------\n\nTITLE: Assert Truthiness with Vitest\nDESCRIPTION: This snippet demonstrates the basic `assert` method.  It checks if the given expression is truthy, and fails the test if not.  It requires the `vitest` module for the testing framework.  The input is a boolean expression, and the output is either a pass or fail based on its truthiness.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert', () => {\n  assert('foo' !== 'bar', 'foo should not be equal to bar')\n})\n```\n\n----------------------------------------\n\nTITLE: Mocking a module with spy option using vi.mock (TypeScript)\nDESCRIPTION: Shows how to use vi.mock with the spy option set to true. This mocks the module but preserves original export implementations, allowing verification of calls without overriding behavior. Useful to track calls on functions while using their real code. Requires vi imported from Vitest. The example mocks a calculator module.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { calculator } from './src/calculator.ts'\n\nvi.mock('./src/calculator.ts', { spy: true })\n\n// calls the original implementation,\n// but allows asserting the behaviour later\nconst result = calculator(1, 2)\n\nexpect(result).toBe(3)\nexpect(calculator).toHaveBeenCalledWith(1, 2)\nexpect(calculator).toHaveReturned(3)\n```\n\n----------------------------------------\n\nTITLE: Locating elements by ARIA role with `getByRole` in Vitest (TS)\nDESCRIPTION: This snippet demonstrates how to locate elements by their ARIA role using the `getByRole` method in Vitest. It shows how to find elements by role, accessible name, and other ARIA attributes. The example also uses `expect.element` to assert the visibility of an element and `fill` to populate textboxes. Requires the Vitest environment to be configured for browser mode testing. Returns a Locator object.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nfunction getByRole(\n  role: ARIARole | string,\n  options?: LocatorByRoleOptions,\n): Locator\n```\n\nLANGUAGE: typescript\nCODE:\n```\nawait expect.element(\n  page.getByRole('heading', { name: 'Sign up' })\n).toBeVisible()\n\nawait page.getByRole('textbox', { name: 'Login' }).fill('admin')\nawait page.getByRole('textbox', { name: 'Password' }).fill('admin')\n\nawait page.getByRole('button', { name: /submit/i }).click()\n```\n\n----------------------------------------\n\nTITLE: Asserting Type Equality with Vitest TypeScript Matcher\nDESCRIPTION: Uses `expectTypeOf` to check if the runtime value type matches the expected TypeScript type using `.toEqualTypeOf`. Requires the `vitest` testing framework and enabling type-checking with the `--typecheck` flag. Accepts any value or object as input and performs compile-time type equality assertions, ignoring runtime values.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect-typeof.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf({ a: 1 }).toEqualTypeOf<{ a: number }>()\nexpectTypeOf({ a: 1 }).toEqualTypeOf({ a: 1 })\nexpectTypeOf({ a: 1 }).toEqualTypeOf({ a: 2 })\nexpectTypeOf({ a: 1, b: 1 }).not.toEqualTypeOf<{ a: number }>()\n```\n\n----------------------------------------\n\nTITLE: Importing vi helper from Vitest (JavaScript)\nDESCRIPTION: Demonstrates how to import the vi mocking utility from Vitest. This import is necessary to use the vi.mock and vi.doMock APIs for module mocking in test files. No dependencies apart from Vitest are required.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { vi } from 'vitest'\n```\n\n----------------------------------------\n\nTITLE: User Event Handler in Vitest Browser Mode (TypeScript)\nDESCRIPTION: Defines the `userEvent` handler for simulating user interactions in Vitest browser tests. It leverages the browser provider (Playwright or WebdriverIO) for implementation, falling back to simulated events via `@testing-library/user-event` with the `preview` provider. Provides methods for common user actions like click, double-click, typing, and drag-and-drop.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/context.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * Handler for user interactions. The support is implemented by the browser provider (`playwright` or `webdriverio`).\n * If used with `preview` provider, fallbacks to simulated events via `@testing-library/user-event`.\n * @experimental\n */\nexport const userEvent: {\n  setup: () => UserEvent\n  cleanup: () => Promise<void>\n  click: (element: Element, options?: UserEventClickOptions) => Promise<void>\n  dblClick: (element: Element, options?: UserEventDoubleClickOptions) => Promise<void>\n  tripleClick: (element: Element, options?: UserEventTripleClickOptions) => Promise<void>\n  selectOptions: (\n    element: Element,\n    values: HTMLElement | HTMLElement[] | string | string[],\n    options?: UserEventSelectOptions,\n  ) => Promise<void>\n  keyboard: (text: string) => Promise<void>\n  type: (element: Element, text: string, options?: UserEventTypeOptions) => Promise<void>\n  clear: (element: Element) => Promise<void>\n  tab: (options?: UserEventTabOptions) => Promise<void>\n  hover: (element: Element, options?: UserEventHoverOptions) => Promise<void>\n  unhover: (element: Element, options?: UserEventHoverOptions) => Promise<void>\n  fill: (element: Element, text: string, options?: UserEventFillOptions) => Promise<void>\n  dragAndDrop: (source: Element, target: Element, options?: UserEventDragAndDropOptions) => Promise<void>\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting Element Presence with Vitest Browser API (TypeScript)\nDESCRIPTION: Shows how to use Vitest's `expect.element` API to assert that a specific DOM element, located using `page.getByText`, is present in the document. This leverages the forked `@testing-library/jest-dom` matchers available within Vitest's browser environment.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/index.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport { expect } from 'vitest'\nimport { page } from '@vitest/browser/context'\n// element is rendered correctly\nawait expect.element(page.getByText('Hello World')).toBeInTheDocument()\n```\n\n----------------------------------------\n\nTITLE: Basic Browser Configuration Setup in Vitest\nDESCRIPTION: A minimal configuration example showing how to enable browser testing with Playwright as the provider and setting up a single Chromium instance with a custom setup file.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/config.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    browser: {\n      enabled: true,\n      provider: 'playwright',\n      instances: [\n        {\n          browser: 'chromium',\n          setupFile: './chromium-setup.js',\n        },\n      ],\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Equality Testers with expect.addEqualityTesters in Vitest (TypeScript)\nDESCRIPTION: Illustrates how to define and register custom equality logic using `expect.addEqualityTesters`. The example creates an `AnagramComparator` class and a tester function `areAnagramsEqual` that checks if two `AnagramComparator` instances represent anagrams. This custom tester is then used by `toEqual` when comparing instances of the class.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_53\n\nLANGUAGE: typescript\nCODE:\n```\nimport { expect, test } from 'vitest'\n\nclass AnagramComparator {\n  public word: string\n\n  constructor(word: string) {\n    this.word = word\n  }\n\n  equals(other: AnagramComparator): boolean {\n    const cleanStr1 = this.word.replace(/ /g, '').toLowerCase()\n    const cleanStr2 = other.word.replace(/ /g, '').toLowerCase()\n\n    const sortedStr1 = cleanStr1.split('').sort().join('')\n    const sortedStr2 = cleanStr2.split('').sort().join('')\n\n    return sortedStr1 === sortedStr2\n  }\n}\n\nfunction isAnagramComparator(a: unknown): a is AnagramComparator {\n  return a instanceof AnagramComparator\n}\n\nfunction areAnagramsEqual(a: unknown, b: unknown): boolean | undefined {\n  const isAAnagramComparator = isAnagramComparator(a)\n  const isBAnagramComparator = isAnagramComparator(b)\n\n  if (isAAnagramComparator && isBAnagramComparator) {\n    return a.equals(b)\n  }\n  else if (isAAnagramComparator === isBAnagramComparator) {\n    return undefined\n  }\n  else {\n    return false\n  }\n}\n\nexpect.addEqualityTesters([areAnagramsEqual])\n\ntest('custom equality tester', () => {\n  expect(new AnagramComparator('listen')).toEqual(new AnagramComparator('silent'))\n})\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Environment for Vitest | TypeScript\nDESCRIPTION: This snippet illustrates how to create a custom Vitest environment by exporting an object of type 'Environment'. The environment must specify properties like 'name' and required 'transformMode' ('ssr' or 'web') for code transformation. Optional asynchronous 'setupVM' and synchronous 'setup' methods enable environment initialization and teardown lifecycle management. This allows extending Vitest beyond built-in environments like 'node' or 'jsdom'. It requires understanding Vitest environment shapes and possibly Node's vm module.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/environment.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { Environment } from 'vitest/environments'\n\nexport default <Environment>{\n  name: 'custom',\n  transformMode: 'ssr',\n  // optional - only if you support \"experimental-vm\" pool\n  async setupVM() {\n    const vm = await import('node:vm')\n    const context = vm.createContext()\n    return {\n      getVmContext() {\n        return context\n      },\n      teardown() {\n        // called after all tests with this env have been run\n      }\n    }\n  },\n  setup() {\n    // custom setup\n    return {\n      teardown() {\n        // called after all tests with this env have been run\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using hover via Locator API in Vitest (TypeScript)\nDESCRIPTION: Demonstrates applying the hover method to an element found using page.getByRole in Vitest's browser context, simulating mouse entry events. Depends on @vitest/browser/context for page object and locator utilities. Accepts role arguments for finding the element, and supports async execution; completes when hover is done. Useful for testing UI states or trigger hover-specific behaviors.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_35\n\nLANGUAGE: typescript\nCODE:\n```\nimport { page } from '@vitest/browser/context'\n\nawait page.getByRole('img', { name: 'Rose' }).hover()\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Coverage Provider (TypeScript)\nDESCRIPTION: Shows how to instruct Vitest to use a custom coverage provider by setting `test.coverage.provider` to `'custom'` and specifying the module name or path using the `customProviderModule` option in `vitest.config.ts`. The specified module must export a `CoverageProviderModule` implementation.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/coverage.md#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    coverage: {\n      provider: 'custom',\n      customProviderModule: 'my-custom-coverage-provider'\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Rewriting beforeEach Hooks with TypeScript for Proper Vitest Teardown\nDESCRIPTION: Demonstrates recommended patterns for using beforeEach hooks in Vitest, especially when initializing library state like Pinia. To ensure Vitest teardown compatibility, use a block body even for single statements. Requires Pinia and Vitest, with createTestingPinia and setActivePinia functions. Input: none; Output: Pinia state setup for each test.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/migration.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nbeforeEach(() => setActivePinia(createTestingPinia())) // [!code --]\nbeforeEach(() => { setActivePinia(createTestingPinia()) }) // [!code ++]\n```\n\n----------------------------------------\n\nTITLE: Asserting Instance of Class with Vitest in TypeScript\nDESCRIPTION: `toBeInstanceOf` asserts whether an object is an instance of a given class. Requires Vitest, and a class definition to test against. Input is the actual object and the class constructor; output is a test assertion.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { expect, test } from 'vitest'\nimport { Stocks } from './stocks.js'\n\nconst stocks = new Stocks()\n\ntest('stocks are instance of Stocks', () => {\n  expect(stocks).toBeInstanceOf(Stocks)\n})\n```\n\n----------------------------------------\n\nTITLE: Using fill via Locator API in Vitest (TypeScript)\nDESCRIPTION: Shows an example of filling an input element by locating it with page.getByRole and invoking fill, entering specified user text. Depends on @vitest/browser/context; assumes the located element supports value assignment. The function is async and resolves when the entered value and all events (change, input) are dispatched.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_39\n\nLANGUAGE: typescript\nCODE:\n```\nimport { page } from '@vitest/browser/context'\n\nawait page.getByRole('input', { name: 'Full Name' }).fill('Mr. Bean')\n```\n\n----------------------------------------\n\nTITLE: Setting a Mock to Reject with mockRejectedValue\nDESCRIPTION: This snippet demonstrates how to configure a mock function to reject with a specific error using `mockRejectedValue`. This is useful for testing asynchronous code that handles rejections.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/mock.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst asyncMock = vi.fn().mockRejectedValue(new Error('Async error'))\n\nawait asyncMock() // throws Error<'Async error'>\n```\n\n----------------------------------------\n\nTITLE: Checking Object Properties with Vitest\nDESCRIPTION: The `toHaveProperty()` matcher checks if a specific property exists on an object. It imports `expectTypeOf` from 'vitest'. If the property exists, it allows further type assertions on the property's type by chaining other matchers like `toBeNumber()` and `toBeString()`. It demonstrates asserting existence of a property and chaining matchers.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect-typeof.md#_snippet_28\n\nLANGUAGE: ts\nCODE:\n```\nimport { expectTypeOf } from 'vitest'\n\nconst obj = { a: 1, b: '' }\n\nexpectTypeOf(obj).toHaveProperty('a')\nexpectTypeOf(obj).not.toHaveProperty('c')\n\nexpectTypeOf(obj).toHaveProperty('a').toBeNumber()\nexpectTypeOf(obj).toHaveProperty('b').toBeString()\nexpectTypeOf(obj).toHaveProperty('a').not.toBeString()\n```\n\n----------------------------------------\n\nTITLE: Initializing Vitest Configuration with defineConfig from vitest/config\nDESCRIPTION: This snippet demonstrates how to initialize a Vitest configuration using `defineConfig` from the `vitest/config` package.  It defines the `test` property within the Vitest configuration. This approach allows for a dedicated configuration file for Vitest, independent of the main Vite configuration.  This is the recommended way to define the vitest config.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    // ... Specify options here.\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Basic Browser Test Example using Vitest APIs (JavaScript)\nDESCRIPTION: Illustrates a simple browser test using Vitest's built-in browser context (`page`) and assertion utilities (`expect`). It shows how to render components (using a hypothetical `my-render-function.js`), query DOM elements by label text, interact with them (fill input), and assert the expected state changes in the document.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/index.md#_snippet_12\n\nLANGUAGE: javascript\nCODE:\n```\nimport { expect, test } from 'vitest'\nimport { page } from '@vitest/browser/context'\nimport { render } from './my-render-function.js'\n\ntest('properly handles form inputs', async () => {\n  render() // mount DOM elements\n\n  // Asserts initial state.\n  await expect.element(page.getByText('Hi, my name is Alice')).toBeInTheDocument()\n\n  // Get the input DOM node by querying the associated label.\n  const usernameInput = page.getByLabelText(/username/i)\n\n  // Type the name into the input. This already validates that the input\n  // is filled correctly, no need to check the value manually.\n  await usernameInput.fill('Bob')\n\n  await expect.element(page.getByText('Hi, my name is Bob')).toBeInTheDocument()\n})\n```\n\n----------------------------------------\n\nTITLE: Assert Strict Equality with Vitest\nDESCRIPTION: This demonstrates `assert.strictEqual`, which tests for strict equality (===).  It requires the `vitest` testing framework. The input consists of two values, and the assertion passes only if both value and type are the same.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.strictEqual', () => {\n  assert.strictEqual(Math.sqrt(4), 2)\n})\n```\n\n----------------------------------------\n\nTITLE: Page Utilities in Vitest Browser Mode (TypeScript)\nDESCRIPTION: Defines the `page` export, which offers utilities to interact with the current page within the Vitest browser environment. Includes functions for viewport manipulation, taking screenshots, extending the default `page` object with custom methods, creating element locators, and using locator APIs like `getByRole`, `getByLabelText`, and `getByTestId`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/context.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport const page: {\n  /**\n   * Change the size of iframe's viewport.\n   */\n  viewport(width: number, height: number): Promise<void>\n  /**\n   * Make a screenshot of the test iframe or a specific element.\n   * @returns Path to the screenshot file or path and base64.\n   */\n  screenshot(options: Omit<ScreenshotOptions, 'base64'> & { base64: true }): Promise<{\n    path: string\n    base64: string\n  }>\n  screenshot(options?: ScreenshotOptions): Promise<string>\n  /**\n   * Extend default `page` object with custom methods.\n   */\n  extend(methods: Partial<BrowserPage>): BrowserPage\n  /**\n   * Wrap an HTML element in a `Locator`. When querying for elements, the search will always return this element.\n   */\n  elementLocator(element: Element): Locator\n\n  /**\n   * Locator APIs. See its documentation for more details.\n   */\n  getByRole(role: ARIARole | string, options?: LocatorByRoleOptions): Locator\n  getByLabelText(text: string | RegExp, options?: LocatorOptions): Locator\n  getByTestId(text: string | RegExp): Locator\n  getByAltText(text: string | RegExp, options?: LocatorOptions): Locator\n  getByPlaceholder(text: string | RegExp, options?: LocatorOptions): Locator\n  getByText(text: string | RegExp, options?: LocatorOptions): Locator\n  getByTitle(text: string | RegExp, options?: LocatorOptions): Locator\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring hover Function in Vitest (TypeScript)\nDESCRIPTION: Defines the hover function signature, simulating mouse hover actions on target elements. Requires a UserEventHoverOptions parameter (optional), returns a Promise resolved when the hover action is completed. Intended for use in testing scenarios to trigger pointer events on specified elements; outputs a void Promise, and is invoked via locator instances.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_34\n\nLANGUAGE: typescript\nCODE:\n```\nfunction hover(options?: UserEventHoverOptions): Promise<void>\n```\n\n----------------------------------------\n\nTITLE: Configuring Workspace for Custom Test Pools\nDESCRIPTION: This code snippet demonstrates how to use the `workspace` feature to run tests in different pools. This is useful when you need to execute tests in different environments or using different configurations.  It extends the base configuration to define specific test pools, such as 'threads', providing flexibility in managing test execution across multiple projects within the Vitest workspace.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/pool.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts [vitest.config.ts]\nexport default defineConfig({\n  test: {\n    workspace: [\n      {\n        extends: true,\n        test: {\n          pool: 'threads',\n        },\n      },\n    ],\n  },\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Using toHaveDisplayValue Assertion with Form Elements - TypeScript\nDESCRIPTION: Demonstrates usage of `toHaveDisplayValue` in test code. Elements are queried by labels and assertions are made to check their displayed values using strings, regex, or arrays of strings/regex in the case of multiple selections. It confirms that the UI elements display expected user-facing values.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_30\n\nLANGUAGE: ts\nCODE:\n```\nconst input = page.getByLabelText('First name')\nconst textarea = page.getByLabelText('Description')\nconst selectSingle = page.getByLabelText('Fruit')\nconst selectMultiple = page.getByLabelText('Fruits')\n\nawait expect.element(input).toHaveDisplayValue('Luca')\nawait expect.element(input).toHaveDisplayValue(/Luc/)\nawait expect.element(textarea).toHaveDisplayValue('An example description here.')\nawait expect.element(textarea).toHaveDisplayValue(/example/)\nawait expect.element(selectSingle).toHaveDisplayValue('Select a fruit...')\nawait expect.element(selectSingle).toHaveDisplayValue(/Select/)\nawait expect.element(selectMultiple).toHaveDisplayValue([/Avocado/, 'Banana'])\n```\n\n----------------------------------------\n\nTITLE: filter.hasText - Filter Elements Containing Specific Text\nDESCRIPTION: Narrows elements to those containing given text or regex inside, case-insensitive for strings. Useful for selecting elements based on visible or inner text content.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_28\n\nLANGUAGE: TypeScript\nCODE:\n```\nhasText: string | RegExp\n```\n\n----------------------------------------\n\nTITLE: Passing custom timeout to tests in Vitest\nDESCRIPTION: This snippet demonstrates how to set a custom timeout in milliseconds for individual tests and hooks, overriding the default 5-second timeout to accommodate longer or shorter test executions.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/filtering.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { test } from 'vitest'\n\ntest('name', async () => { /* ... */ }, 1000)\n```\n\n----------------------------------------\n\nTITLE: Using toBeChecked Assertion on Checkbox, Radio, and ARIA Elements - TypeScript\nDESCRIPTION: This snippet shows how to select elements by test ID for checked and unchecked states and use the `toBeChecked` assertion to verify the checked states synchronously. It covers native input elements and ARIA roles with corresponding aria-checked attributes.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_33\n\nLANGUAGE: ts\nCODE:\n```\nconst inputCheckboxChecked = getByTestId('input-checkbox-checked')\nconst inputCheckboxUnchecked = getByTestId('input-checkbox-unchecked')\nconst ariaCheckboxChecked = getByTestId('aria-checkbox-checked')\nconst ariaCheckboxUnchecked = getByTestId('aria-checkbox-unchecked')\nawait expect.element(inputCheckboxChecked).toBeChecked()\nawait expect.element(inputCheckboxUnchecked).not.toBeChecked()\nawait expect.element(ariaCheckboxChecked).toBeChecked()\nawait expect.element(ariaCheckboxUnchecked).not.toBeChecked()\n\nconst inputRadioChecked = getByTestId('input-radio-checked')\nconst inputRadioUnchecked = getByTestId('input-radio-unchecked')\nconst ariaRadioChecked = getByTestId('aria-radio-checked')\nconst ariaRadioUnchecked = getByTestId('aria-radio-unchecked')\nawait expect.element(inputRadioChecked).toBeChecked()\nawait expect.element(inputRadioUnchecked).not.toBeChecked()\nawait expect.element(ariaRadioChecked).toBeChecked()\nawait expect.element(ariaRadioUnchecked).not.toBeChecked()\n\nconst ariaSwitchChecked = getByTestId('aria-switch-checked')\nconst ariaSwitchUnchecked = getByTestId('aria-switch-unchecked')\nawait expect.element(ariaSwitchChecked).toBeChecked()\nawait expect.element(ariaSwitchUnchecked).not.toBeChecked()\n```\n\n----------------------------------------\n\nTITLE: Accessing Last Mock Call Arguments with mock.lastCall (TypeScript)\nDESCRIPTION: The `mock.lastCall` property provides convenient access to the arguments of the most recent call made to the mock function. It returns an array of arguments similar to an element in `mock.calls`, or `undefined` if the mock function has not been called yet.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/mock.md#_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nconst lastCall: Parameters<T> | undefined\n```\n\n----------------------------------------\n\nTITLE: Using expect.anything Matcher in Vitest (TypeScript)\nDESCRIPTION: Shows how the `expect.anything()` asymmetric matcher works with equality checks (`toEqual`). It always returns true, making it useful for verifying the existence of a property without checking its specific value.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_44\n\nLANGUAGE: typescript\nCODE:\n```\nimport { expect, test } from 'vitest'\n\ntest('object has \"apples\" key', () => {\n  expect({ apples: 22 }).toEqual({ apples: expect.anything() })\n})\n```\n\n----------------------------------------\n\nTITLE: Setting Mock Implementation with mockImplementation\nDESCRIPTION: This example demonstrates how to set a custom implementation for a mock function using `mockImplementation`. This allows you to define the behavior of the mock function when it is called.  TypeScript expects the arguments and return type to match those of the original function.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/mock.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst mockFn = vi.fn().mockImplementation((apples: number) => apples + 1)\n// or: vi.fn(apples => apples + 1);\n\nconst NelliesBucket = mockFn(0)\nconst BobsBucket = mockFn(1)\n\nNelliesBucket === 1 // true\nBobsBucket === 2 // true\n\nmockFn.mock.calls[0][0] === 0 // true\nmockFn.mock.calls[1][0] === 1 // true\n```\n\n----------------------------------------\n\nTITLE: Asserting Partial Object Matching with Vitest in TypeScript\nDESCRIPTION: `toMatchObject` asserts that an object contains at least the properties in the given subset, including nested objects or arrays. When passed an array of objects, it requires exact matching of length and elements. Inputs are the actual object or array and the expected subset. Outputs are assertion results. Requires Vitest.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_11\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { expect, test } from 'vitest'\n\nconst johnInvoice = {\n  isActive: true,\n  customer: {\n    first_name: 'John',\n    last_name: 'Doe',\n    location: 'China',\n  },\n  total_amount: 5000,\n  items: [\n    {\n      type: 'apples',\n      quantity: 10,\n    },\n    {\n      type: 'oranges',\n      quantity: 5,\n    },\n  ],\n}\n\nconst johnDetails = {\n  customer: {\n    first_name: 'John',\n    last_name: 'Doe',\n    location: 'China',\n  },\n}\n\ntest('invoice has john personal details', () => {\n  expect(johnInvoice).toMatchObject(johnDetails)\n})\n\ntest('the number of elements must match exactly', () => {\n  // Assert that an array of object matches\n  expect([{ foo: 'bar' }, { baz: 1 }]).toMatchObject([\n    { foo: 'bar' },\n    { baz: 1 },\n  ])\n})\n```\n\n----------------------------------------\n\nTITLE: CLI Commands for Debugging Vitest Without IDEs\nDESCRIPTION: These bash commands launch Vitest with debugging enabled, forcing single-threaded or single-process execution to avoid parallelism. They use `--inspect-brk` to pause execution for debugging. Requires Vitest to be installed.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/debugging.md#_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\n# To run in a single worker\nvitest --inspect-brk --pool threads --poolOptions.threads.singleThread\n\n# To run in a single child process\nvitest --inspect-brk --pool forks --poolOptions.forks.singleFork\n\n# To run in browser mode\nvitest --inspect-brk --browser --no-file-parallelism\n```\n\n----------------------------------------\n\nTITLE: Hoisted vi.mock with default export mocking caveat (TypeScript)\nDESCRIPTION: Explains the requirement to provide a default export when mocking ES modules with a default export using vi.mock. This addresses the ES module default export specific pattern, differing from CommonJS Jest mocks. The factory must return an object with a default key representing the default export alongside other named exports.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nvi.mock('./path/to/module.js', () => {\n  return {\n    default: { myDefaultKey: vi.fn() },\n    namedExport: vi.fn(),\n    // etc...\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: HTML examples demonstrating various label associations with `getByLabelText`\nDESCRIPTION: This HTML snippet provides examples of different ways labels can be associated with form elements, including using `for`/`id`, `aria-labelledby`, wrapper labels, and `aria-label` attributes.  These examples serve as context for demonstrating how `getByLabelText` can locate the associated input elements.  No external dependencies required.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_14\n\nLANGUAGE: html\nCODE:\n```\n// for/htmlFor relationship between label and form element id\n<label for=\"username-input\">Username</label>\n<input id=\"username-input\" />\n\n// The aria-labelledby attribute with form elements\n<label id=\"username-label\">Username</label>\n<input aria-labelledby=\"username-label\" />\n\n// Wrapper labels\n<label>Username <input /></label>\n\n// Wrapper labels where the label text is in another child element\n<label>\n  <span>Username</span>\n  <input />\n</label>\n\n// aria-label attributes\n// Take care because this is not a label that users can see on the page,\n// so the purpose of your input must be obvious to visual users.\n<input aria-label=\"Username\" />\n```\n\n----------------------------------------\n\nTITLE: Using CDP Command Vitest TypeScript\nDESCRIPTION: Shows how to access and utilize the raw Chrome DevTools Protocol (CDP) session from a browser test using the `cdp()` command. This allows direct interaction with the browser's internal mechanisms, useful for advanced scenarios like simulating low-level events. Note that this requires the Playwright provider and Chromium browser.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/commands.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { cdp } from '@vitest/browser/context'\n\nconst input = document.createElement('input')\ndocument.body.appendChild(input)\ninput.focus()\n\nawait cdp().send('Input.dispatchKeyEvent', {\n  type: 'keyDown',\n  text: 'a',\n})\n\nexpect(input).toHaveValue('a')\n```\n\n----------------------------------------\n\nTITLE: Ordered Subset Not Present in Array (TypeScript)\nDESCRIPTION: Defines `assert.notIncludeOrderedMembers` to check that `subset` does not appear in `superset` in the same order. Demonstrates both positive and negative assertions.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_96\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\n test('assert.notIncludeOrderedMembers', () => {\n  assert.notIncludeOrderedMembers([1, 2, 3], [2, 1], 'not include ordered members')\n  assert.notIncludeOrderedMembers([1, 2, 3], [2, 3], 'not include ordered members')\n})\n```\n\n----------------------------------------\n\nTITLE: Assert Value is Object with Vitest\nDESCRIPTION: This demonstrates `assert.isObject`, which asserts that a value is an object (of type Object).  It uses the `vitest` testing framework. The input is a value and the assertion passes if the value is an object. Does not match subclassed objects.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_27\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\nconst someThing = { color: 'red', shape: 'circle' }\n\ntest('assert.isObject', () => {\n  assert.isObject(someThing, 'someThing is object')\n})\n```\n\n----------------------------------------\n\nTITLE: getByTitle Function - Find Elements by Title Attribute\nDESCRIPTION: Creates a locator to find elements with a specified title attribute, with optional exact matching. Unlike testing-library, cannot locate SVG titles. Useful for identifying elements by tooltip text.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_18\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction getByTitle(\n  text: string | RegExp,\n  options?: LocatorOptions,\n): Locator\n```\n\n----------------------------------------\n\nTITLE: Configuring Reporters with Options\nDESCRIPTION: This example shows how to configure reporters with specific options within the `vitest.config.ts` file. It configures the 'junit' reporter with a custom suite name. This allows for more detailed control over the output, tailoring the reports to fit specific project needs. The options are passed as an array where the first element is the reporter name and the second element is an object containing the reporter's options.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/reporters.md#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nexport default defineConfig({\n  test: {\n    reporters: [\n      'default',\n      ['junit', { suiteName: 'UI tests' }]\n    ],\n  },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Checking the Nth Returned Value of a Spy Function Using toHaveNthReturnedWith\nDESCRIPTION: This snippet illustrates how to verify that a spy function returned a particular value on the nth call. It counts the calls and checks the return value of the specific invocation index.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_32\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { expect, test, vi } from 'vitest'\n\ntest('spy function returns bananas on second call', () => {\n  const sell = vi.fn((product: string) => ({ product }))\n\n  sell('apples')\n  sell('bananas')\n\n  expect(sell).toHaveNthReturnedWith(2, { product: 'bananas' })\n})\n```\n\n----------------------------------------\n\nTITLE: TSX example demonstrating `name` option for `getByRole`\nDESCRIPTION: This TSX snippet demonstrates how to use the `name` option with `getByRole` to filter elements based on their accessible name.  It showcases the default case-insensitive substring matching. Requires a TSX environment that supports JSX syntax. No external dependencies needed other than a rendering context for the TSX.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\n<button>Click Me!</button>\n\npage.getByRole('button', { name: 'Click Me!' }) // ✅\npage.getByRole('button', { name: 'click me!' }) // ✅\npage.getByRole('button', { name: 'Click Me?' }) // ❌\n```\n\n----------------------------------------\n\nTITLE: filter.has - Find Elements Containing Specific Child Elements\nDESCRIPTION: Filters parent elements to include only those that contain child elements matching a provided locator, useful for narrowing down elements based on nested structure or content.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_26\n\nLANGUAGE: TypeScript\nCODE:\n```\nhas: Locator\n```\n\n----------------------------------------\n\nTITLE: Skipping tests and suites with .skip in Vitest\nDESCRIPTION: This snippet shows how to exclude specific suites or tests from execution using `.skip`, useful for temporarily disabling tests or suites without deleting code.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/filtering.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assert, describe, it } from 'vitest'\n\ndescribe.skip('skipped suite', () => {\n  it('test', () => {\n    // Suite skipped, no error\n    assert.equal(Math.sqrt(4), 3)\n  })\n})\n\n// Skip individual test\n\ndescribe('suite', () => {\n  it.skip('skipped test', () => {\n    // Test skipped, no error\n    assert.equal(Math.sqrt(4), 3)\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Mocking System Time with Vitest vi.setSystemTime in TypeScript\nDESCRIPTION: Explains how to use `vi.setSystemTime` to mock the system clock when fake timers are enabled via `vi.useFakeTimers`. This affects date-related APIs like `Date.now()`, `new Date()`, `performance.now`, etc., allowing tests dependent on specific dates or times. The original time can be restored using `vi.useRealTimers()`. Requires `vi` from `vitest`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_28\n\nLANGUAGE: ts\nCODE:\n```\nconst date = new Date(1998, 11, 19)\n\nvi.useFakeTimers()\nvi.setSystemTime(date)\n\nexpect(Date.now()).toBe(date.valueOf())\n\nvi.useRealTimers()\n```\n\n----------------------------------------\n\nTITLE: Testing Svelte Components in Vitest Browser Mode (TypeScript)\nDESCRIPTION: Demonstrates testing a Svelte component (`Greeter.svelte`) using `vitest-browser-svelte`. The test renders the component with props, finds a button by role, simulates a click interaction, locates the resulting text using `screen.getByText`, and asserts its presence in the document.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/index.md#_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nimport { render } from 'vitest-browser-svelte'\nimport { expect, test } from 'vitest'\n\nimport Greeter from './greeter.svelte'\n\ntest('greeting appears on click', async () => {\n  const screen = render(Greeter, { name: 'World' })\n\n  const button = screen.getByRole('button')\n  await button.click()\n  const greeting = screen.getByText(/hello world/iu)\n\n  await expect.element(greeting).toBeInTheDocument()\n})\n```\n\n----------------------------------------\n\nTITLE: Unmocking Modules with vi.doUnmock\nDESCRIPTION: This example demonstrates how to unmock a module using `vi.doUnmock`. Unlike `vi.unmock`, `vi.doUnmock` is not hoisted and only affects subsequent imports. It removes the module from the mocked registry for future imports.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nexport function increment(number) {\n  return number + 1\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { increment } from './increment.js'\n\n// increment is already mocked, because vi.mock is hoisted\nincrement(1) === 100\n\n// this is hoisted, and factory is called before the import on line 1\nvi.mock('./increment.js', () => ({ increment: () => 100 }))\n\n// all calls are mocked, and `increment` always returns 100\nincrement(1) === 100\nincrement(30) === 100\n\n// this is not hoisted, so other import will return unmocked module\nvi.doUnmock('./increment.js')\n\n// this STILL returns 100, because `vi.doUnmock` doesn't reevaluate a module\nincrement(1) === 100\nincrement(30) === 100\n\n// the next import is unmocked, now `increment` is the original function that returns count + 1\nconst { increment: unmockedIncrement } = await import('./increment.js')\n\nunmockedIncrement(1) === 2\nunmockedIncrement(30) === 31\n```\n\n----------------------------------------\n\nTITLE: Configuring Vitest to Include Source Files (TypeScript)\nDESCRIPTION: This snippet demonstrates how to configure Vitest using `defineConfig` to include source files (JavaScript and TypeScript) for in-source testing. By setting `includeSource` in `test` options, it instructs Vitest to search and execute tests embedded within files in the `src/` directory. The configuration is required to enable in-source testing support.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/in-source.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    includeSource: ['src/**/*.{js,ts}'] // [!code ++]\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Running Vitest Tests with multiple projects via npm\nDESCRIPTION: This code snippet describes how to run tests for multiple specific projects within a Vitest workspace using the `--project` CLI option in conjunction with npm. In this example projects `e2e` and `unit` are specified.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/workspace.md#_snippet_8\n\nLANGUAGE: Bash\nCODE:\n```\nnpm run test --project e2e --project unit\n```\n\n----------------------------------------\n\nTITLE: Validating the Last Return Value of a Spy Function Using toHaveLastReturnedWith\nDESCRIPTION: This code demonstrates verifying that the last invocation of a spy function returned a specified value. It involves calling the spy multiple times with different arguments and checking the last returned result matches expectations.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_31\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { expect, test, vi } from 'vitest'\n\ntest('spy function returns bananas on a last call', () => {\n  const sell = vi.fn((product: string) => ({ product }))\n\n  sell('apples')\n  sell('bananas')\n\n  expect(sell).toHaveLastReturnedWith({ product: 'bananas' })\n})\n```\n\n----------------------------------------\n\nTITLE: Creating a TestSpecification in Vitest (TypeScript)\nDESCRIPTION: Demonstrates how to instantiate a TestSpecification using the `createSpecification` method on a TestProject instance. It requires a resolved module ID and optionally accepts an array of specific line numbers to run tests from.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/test-specification.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst specification = project.createSpecification(\n  resolve('./example.test.ts'),\n  [20, 40], // optional test lines\n)\n```\n\n----------------------------------------\n\nTITLE: Extending TaskMeta Type Definition for Custom Fields in Vitest (TypeScript)\nDESCRIPTION: This snippet demonstrates how to extend the built-in TypeScript interface TaskMeta in the \"vitest\" module declaration. By adding optional properties such as \"done\" (boolean) and \"custom\" (string), downstream code gets full type safety and autocompletion when using meta fields. There are no direct runtime dependencies, but make sure your project uses TypeScript and includes Vitest type definitions. This extension is modular and does not impact existing usage unless custom fields are referenced.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/metadata.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare module 'vitest' {\n  interface TaskMeta {\n    done?: boolean\n    custom?: string\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: File structure based auto-mocking using __mocks__ folders (TypeScript)\nDESCRIPTION: Describes how Vitest auto-mocks modules when no factory is provided in vi.mock by looking up corresponding files in __mocks__ folders at various levels. The example explains folder placement of __mocks__ and how Vitest uses them to replace modules automatically without factory functions.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n- __mocks__\n  - axios.js\n- src\n  __mocks__\n    - increment.js\n  - increment.js\n- tests\n  - increment.test.js\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { vi } from 'vitest'\n\n// axios is a default export from `__mocks__/axios.js`\nimport axios from 'axios'\n\n// increment is a named export from `src/__mocks__/increment.js`\nimport { increment } from '../increment.js'\n\nvi.mock('axios')\nvi.mock('../increment.js')\n\naxios.get(`/apples/${increment(1)}`)\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Coverage Reporters (TypeScript)\nDESCRIPTION: Illustrates how to include custom coverage reporters in the Vitest configuration. Custom reporters can be specified by their npm package name (optionally with configuration options) or by an absolute path to a local file. Custom reporters must adhere to the Istanbul reporter interface.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/coverage.md#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    coverage: {\n      reporter: [\n        // Specify reporter using name of the NPM package\n        ['@vitest/custom-coverage-reporter', { someOption: true }],\n\n        // Specify reporter using local path\n        '/absolute/path/to/custom-reporter.cjs',\n      ],\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Asserting Spy Function Was Called in Vitest\nDESCRIPTION: Demonstrates using `.toHaveBeenCalled()` and `.not.toHaveBeenCalled()` to assert whether a spy function (created with `vi.spyOn`) was called at least once during the test execution.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_20\n\nLANGUAGE: ts\nCODE:\n```\nimport { expect, test, vi } from 'vitest'\n\nconst market = {\n  buy(subject: string, amount: number) {\n    // ...\n  },\n}\n\ntest('spy function', () => {\n  const buySpy = vi.spyOn(market, 'buy')\n\n  expect(buySpy).not.toHaveBeenCalled()\n\n  market.buy('apples', 10)\n\n  expect(buySpy).toHaveBeenCalled()\n})\n```\n\n----------------------------------------\n\nTITLE: Browser Commands in Vitest Browser Mode (TypeScript)\nDESCRIPTION: Defines the `commands` export, which provides access to available browser commands within the Vitest environment. This is a direct shortcut to `server.commands` and allows tests to execute browser-specific actions.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/context.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * Available commands for the browser.\n * A shortcut to `server.commands`.\n */\nexport const commands: BrowserCommands\n```\n\n----------------------------------------\n\nTITLE: Asserting Containment by Structure in Arrays with Vitest in TypeScript\nDESCRIPTION: `toContainEqual` asserts an array includes an element with a structure equal to the received item, comparing deeply without strict identity. Useful for checking arrays containing objects. Requires Vitest. Inputs are arrays and object to find; output is assertion result.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { expect, test } from 'vitest'\nimport { getFruitStock } from './stocks.js'\n\ntest('apple available', () => {\n  expect(getFruitStock()).toContainEqual({ fruit: 'apple', count: 5 })\n})\n```\n\n----------------------------------------\n\nTITLE: Asserting the Type of a Value using Vitest (TypeScript)\nDESCRIPTION: Examples of using `assert.typeOf` in Vitest tests to check the specific type of various values (object, array, string, regexp, null, undefined) using `Object.prototype.toString`. Imports `assert` and `test`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_38\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.typeOf', () => {\n  assert.typeOf({ color: 'red' }, 'object', 'we have an object')\n  assert.typeOf(['red', 'green'], 'array', 'we have an array')\n  assert.typeOf('red', 'string', 'we have a string')\n  assert.typeOf(/red/, 'regexp', 'we have a regular expression')\n  assert.typeOf(null, 'null', 'we have a null')\n  assert.typeOf(undefined, 'undefined', 'we have an undefined')\n})\n```\n\n----------------------------------------\n\nTITLE: Asserting Nth Call of Spy Function Had Specific Arguments in Vitest\nDESCRIPTION: Shows how to use `.toHaveBeenNthCalledWith()` to assert the arguments used in a specific invocation of a spy function, identified by its call index (starting from 1). Requires a spy function.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_27\n\nLANGUAGE: ts\nCODE:\n```\nimport { expect, test, vi } from 'vitest'\n\nconst market = {\n  buy(subject: string, amount: number) {\n    // ...\n  },\n}\n\ntest('first call of spy function called with right params', () => {\n  const buySpy = vi.spyOn(market, 'buy')\n\n  market.buy('apples', 10)\n  market.buy('apples', 20)\n\n  expect(buySpy).toHaveBeenNthCalledWith(1, 'apples', 10)\n})\n```\n\n----------------------------------------\n\nTITLE: Using toMatchInlineSnapshot() in Vitest (TypeScript)\nDESCRIPTION: This code snippet shows how to use `toMatchInlineSnapshot()` to store the snapshot directly within the test file. Vitest will automatically update the test file with the snapshot. Dependencies: vitest. Input: none. Output: A snapshot string within the test file.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/snapshot.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { expect, it } from 'vitest'\n\nit('toUpperCase', () => {\n  const result = toUpperCase('foobar')\n  expect(result).toMatchInlineSnapshot()\n})\n```\n\n----------------------------------------\n\nTITLE: Checking Object Shape with expect.objectContaining in Vitest (TypeScript)\nDESCRIPTION: Demonstrates the `expect.objectContaining(expected)` asymmetric matcher within `toEqual`. It verifies that the actual object contains key-value pairs matching those in the `expected` object. The actual object can have additional properties.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_48\n\nLANGUAGE: typescript\nCODE:\n```\nimport { expect, test } from 'vitest'\n\ntest('basket has empire apples', () => {\n  const basket = {\n    varieties: [\n      {\n        name: 'Empire',\n        count: 1,\n      }\n    ],\n  }\n  expect(basket).toEqual({\n    varieties: [\n      expect.objectContaining({ name: 'Empire' }),\n    ]\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Accessing Mock Call Arguments with mock.calls (TypeScript/JavaScript)\nDESCRIPTION: The `mock.calls` property is an array where each element represents the arguments passed during a single call to the mock function. The type `Parameters<T>` infers the argument types from the mocked function's signature `T`. This allows inspection of all arguments for every invocation.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/mock.md#_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nconst calls: Parameters<T>[]\n```\n\nLANGUAGE: javascript\nCODE:\n```\nconst fn = vi.fn()\n\nfn('arg1', 'arg2')\nfn('arg3')\n\nfn.mock.calls === [\n  ['arg1', 'arg2'], // first call\n  ['arg3'], // second call\n]\n```\n\n----------------------------------------\n\nTITLE: Installing Istanbul Coverage Provider (Bash)\nDESCRIPTION: Bash command to manually install the `@vitest/coverage-istanbul` package as a development dependency using npm. This package is required to enable the istanbul code coverage provider in Vitest.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/coverage.md#_snippet_2\n\nLANGUAGE: Bash\nCODE:\n```\nnpm i -D @vitest/coverage-istanbul\n```\n\n----------------------------------------\n\nTITLE: Stubbing Global Variables with Vitest vi.stubGlobal in TypeScript\nDESCRIPTION: Shows how to modify a global variable (e.g., `innerWidth`) using `vi.stubGlobal`. This allows testing code that relies on global properties, making the stubbed value accessible via `globalThis` or `window` (in jsdom/happy-dom). The original value can be restored later with `vi.unstubAllGlobals`. Requires `vi` from `vitest`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_16\n\nLANGUAGE: ts\nCODE:\n```\nimport { vi } from 'vitest'\n\n// `innerWidth` is \"0\" before calling stubGlobal\n\nvi.stubGlobal('innerWidth', 100)\n\ninnerWidth === 100\nglobalThis.innerWidth === 100\n// if you are using jsdom or happy-dom\nwindow.innerWidth === 100\n```\n\n----------------------------------------\n\nTITLE: Adding a Custom Snapshot Serializer (TypeScript)\nDESCRIPTION: This code demonstrates how to add a custom snapshot serializer using `expect.addSnapshotSerializer`. This allows you to alter how values are serialized before being stored as a snapshot. Dependencies: vitest. Input: Value to serialize. Output: Serialized string representation of the value.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/snapshot.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexpect.addSnapshotSerializer({\n  serialize(val, config, indentation, depth, refs, printer) {\n    // `printer` is a function that serializes a value using existing plugins.\n    return `Pretty foo: ${printer(\n      val.foo,\n      config,\n      indentation,\n      depth,\n      refs,\n    )}`\n  },\n  test(val) {\n    return val && Object.prototype.hasOwnProperty.call(val, 'foo')\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Advancing Fake Timers by Time with Vitest vi.advanceTimersByTime in TypeScript\nDESCRIPTION: Demonstrates using `vi.advanceTimersByTime` to fast-forward fake timers by a specified duration in milliseconds. This synchronously executes any timer callbacks (like those from `setInterval`) scheduled within that timeframe. Requires `vi` from `vitest` and enabling fake timers via `vi.useFakeTimers()`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_19\n\nLANGUAGE: ts\nCODE:\n```\nlet i = 0\nsetInterval(() => console.log(++i), 50)\n\nvi.advanceTimersByTime(150)\n\n// log: 1\n// log: 2\n// log: 3\n```\n\n----------------------------------------\n\nTITLE: Restoring Stubbed Global Variables with Vitest vi.unstubAllGlobals in TypeScript\nDESCRIPTION: Explains how to use `vi.unstubAllGlobals` to revert changes made to global variables via `vi.stubGlobal`. The example stubs `IntersectionObserver` with a mock function and then restores it, demonstrating that the global variable is removed or reset to its original state. Requires `vi` from `vitest`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_18\n\nLANGUAGE: ts\nCODE:\n```\nimport { vi } from 'vitest'\n\nconst Mock = vi.fn()\n\n// IntersectionObserver is \"undefined\" before calling \"stubGlobal\"\n\nvi.stubGlobal('IntersectionObserver', Mock)\n\nIntersectionObserver === Mock\nglobal.IntersectionObserver === Mock\nglobalThis.IntersectionObserver === Mock\n// if you are using jsdom or happy-dom\nwindow.IntersectionObserver === Mock\n\nvi.unstubAllGlobals()\n\nglobalThis.IntersectionObserver === undefined\n'IntersectionObserver' in globalThis === false\n// throws ReferenceError, because it's not defined\nIntersectionObserver === undefined\n```\n\n----------------------------------------\n\nTITLE: Setting Debugging Port in Vitest\nDESCRIPTION: This bash command runs Vitest with a specified debugging port.  It overrides the default port `9229` with `3000`. `--inspect-brk=127.0.0.1:3000` sets the debugging port, `--browser` enables browser mode, and `--no-file-parallelism` disables parallel execution.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/debugging.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nvitest --inspect-brk=127.0.0.1:3000 --browser --no-file-parallelism\n```\n\n----------------------------------------\n\nTITLE: Running Vitest Tests in specific project via pnpm\nDESCRIPTION: This snippet demonstrates how to run tests in a specific project within a Vitest workspace using the `--project` CLI option with pnpm.  The example targets a project named `e2e`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/workspace.md#_snippet_13\n\nLANGUAGE: Bash\nCODE:\n```\npnpm run test --project e2e\n```\n\n----------------------------------------\n\nTITLE: Using Asynchronous vi.hoisted in Vitest (TypeScript)\nDESCRIPTION: Demonstrates that `vi.hoisted` supports asynchronous factory functions using `async/await`. This allows performing async operations, like fetching data from an API, before module imports are evaluated, even in environments that don't support top-level await.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_37\n\nLANGUAGE: typescript\nCODE:\n```\nconst json = await vi.hoisted(async () => {\n  const response = await fetch('https://jsonplaceholder.typicode.com/posts')\n  return response.json()\n})\n```\n\n----------------------------------------\n\nTITLE: Extending Root Config for Workspace Projects - workspace.ts\nDESCRIPTION: This snippet shows how to define the workspace via `vitest.workspace.ts`.  By setting `extends` to the path of the main configuration file, the workspace project can inherit the root configuration and plugins and control which options are inherited.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/workspace.md#_snippet_20\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { defineWorkspace } from 'vitest/config'\n\nexport default defineWorkspace([\n  {\n    extends: './vitest.config.ts',\n    test: {\n      name: 'unit',\n      include: ['**/*.unit.test.ts'],\n    },\n  },\n  {\n    extends: './vitest.config.ts',\n    test: {\n      name: 'integration',\n      include: ['**/*.integration.test.ts'],\n    },\n  },\n])\n\n```\n\n----------------------------------------\n\nTITLE: Testing Marko Components using Testing Library in Vitest (TypeScript)\nDESCRIPTION: Shows testing a Marko component (`Greeting.marko`) using `@marko/testing-library` within Vitest's browser mode. It renders the component with props, uses `page.elementLocator(baseElement)` for assertions, checks for text presence using `expect.element(screen.getByText()).toBeInTheDocument()`, and includes a snapshot assertion.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/index.md#_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\n// baed on @testing-library/marko API\n// https://testing-library.com/docs/marko-testing-library/api\n\nimport { render, screen } from '@marko/testing-library'\nimport Greeting from './greeting.marko'\n\ntest('renders a message', async () => {\n  const { baseElement } = await render(Greeting, { name: 'Marko' })\n  const screen = page.elementLocator(baseElement)\n  await expect.element(screen.getByText(/Marko/)).toBeInTheDocument()\n  expect(container.firstChild).toMatchInlineSnapshot(`\n    <h1>Hello, Marko!</h1>\n  `)\n})\n```\n\n----------------------------------------\n\nTITLE: Stubbing Environment Variables with vi.stubEnv\nDESCRIPTION: This code demonstrates how to stub environment variables using `vi.stubEnv`. It shows how to change the value of variables on `process.env` and `import.meta.env` for testing purposes and restore their values using `vi.unstubAllEnvs`.  It returns the Vitest object.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport { vi } from 'vitest'\n\n// `process.env.NODE_ENV` and `import.meta.env.NODE_ENV`\n// are \"development\" before calling \"vi.stubEnv\"\n\nvi.stubEnv('NODE_ENV', 'production')\n\nprocess.env.NODE_ENV === 'production'\nimport.meta.env.NODE_ENV === 'production'\n\nvi.stubEnv('NODE_ENV', undefined)\n\nprocess.env.NODE_ENV === undefined\nimport.meta.env.NODE_ENV === undefined\n\n// doesn't change other envs\nimport.meta.env.MODE === 'development'\n```\n\n----------------------------------------\n\nTITLE: Asserting Numeric Property Increases But Not By Specific Value with Vitest - TypeScript\nDESCRIPTION: Ensures the modifier function increases an object's numeric property (or return value) but not by a specific value. Requires Vitest and takes a function, object, property, forbidden change amount, and optional message. Use for cases where an increase is allowed except for a particular amount.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_107\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.increasesButNotBy', () => {\n  const obj = { val: 10 }\n  function fn() { obj.val += 15 };\n  assert.increasesButNotBy(fn, obj, 'val', 10)\n})\n```\n\n----------------------------------------\n\nTITLE: Asserting Length Property with Vitest in TypeScript\nDESCRIPTION: `toHaveLength` asserts that an object has a `.length` property equal to a given numeric value. Inputs are strings, arrays, or objects with `length`. Outputs are assertion results. Requires Vitest.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { expect, test } from 'vitest'\n\ntest('toHaveLength', () => {\n  expect('abc').toHaveLength(3)\n  expect([1, 2, 3]).toHaveLength(3)\n\n  expect('').not.toHaveLength(3) // doesn't have .length of 3\n  expect({ length: 3 }).toHaveLength(3)\n})\n```\n\n----------------------------------------\n\nTITLE: Extracting Function Parameter Types with Vitest in TypeScript\nDESCRIPTION: Uses `.parameters` to extract and assert the argument types of a function, returning them as an array. Requires Vitest and works with function types, supporting detailed assertions about expected function signatures in unit tests.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect-typeof.md#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { expectTypeOf } from 'vitest'\n\ntype NoParam = () => void\ntype HasParam = (s: string) => void\n\nexpectTypeOf<NoParam>().parameters.toEqualTypeOf<[]>()\nexpectTypeOf<HasParam>().parameters.toEqualTypeOf<[string]>()\n```\n\n----------------------------------------\n\nTITLE: Asserting One Mock Function Was Called After Another in Vitest\nDESCRIPTION: Shows how to use `.toHaveBeenCalledAfter()` to assert the call order, verifying that the first mock function was invoked at least once after the second mock function's first invocation.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_24\n\nLANGUAGE: ts\nCODE:\n```\ntest('calls mock1 after mock2', () => {\n  const mock1 = vi.fn()\n  const mock2 = vi.fn()\n\n  mock2()\n  mock1()\n  mock2()\n\n  expect(mock1).toHaveBeenCalledAfter(mock2)\n})\n```\n\n----------------------------------------\n\nTITLE: Importing Modules Dynamically Using TypeScript Generic Function\nDESCRIPTION: Defines a generic function import<T> that takes a module identifier string and returns a Promise of type T, representing the module's exports. This utility function is intended for environments supporting ES module dynamic imports, such as Node.js or modern browsers. The input parameter moduleId specifies the ID or path of the module to import, and the function returns a Promise that resolves to the typed module object. Requires TypeScript as a prerequisite and is constrained to valid module identifiers.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/import-example.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction import<T>(moduleId: string): Promise<T>\n```\n\n----------------------------------------\n\nTITLE: Verifying the Number of Resolved Calls Using toHaveResolvedTimes\nDESCRIPTION: This shows how to assert that a Promise-returning function has resolved exactly a specified number of times. It involves creating an async spy function, calling it multiple times with `await`, and checking the resolved count.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_34\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { expect, test, vi } from 'vitest'\n\ntest('spy function resolved a value two times', async () => {\n  const sell = vi.fn((product: string) => Promise.resolve({ product }))\n\n  await sell('apples')\n  await sell('bananas')\n\n  expect(sell).toHaveResolvedTimes(2)\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Coverage Thresholds with Glob Patterns (TS)\nDESCRIPTION: This snippet shows how to configure coverage thresholds for specific files matching a glob pattern in Vitest. It demonstrates setting thresholds for statements, functions, branches, and lines. Ensure glob patterns are correctly specified to target the desired files.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_28\n\nLANGUAGE: ts\nCODE:\n```\n{\n  coverage: {\n    thresholds: {\n      // Thresholds for all files\n      functions: 95,\n      branches: 70,\n\n      // Thresholds for matching glob pattern\n      'src/utils/**.ts': {\n        statements: 95,\n        functions: 90,\n        branches: 85,\n        lines: 80,\n      },\n\n      // Files matching this pattern will only have lines thresholds set.\n      // Global thresholds are not inherited.\n      '**/math.ts': {\n        lines: 100,\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: TSX example demonstrating `disabled` option for `getByRole`\nDESCRIPTION: This TSX snippet demonstrates how to use the `disabled` option with `getByRole` to filter elements based on their disabled state. It includes examples using input elements with the `disabled` attribute. Requires a TSX environment that supports JSX syntax. No external dependencies needed other than a rendering context for the TSX.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\n<input type=\"text\" disabled />\n\npage.getByRole('textbox', { disabled: true }) // ✅\npage.getByRole('textbox', { disabled: false }) // ❌\n```\n\n----------------------------------------\n\nTITLE: Integrating Github Actions Annotations with Vitest Reporter in TypeScript\nDESCRIPTION: Automatically emits Github Actions workflow commands to create annotated test failure messages visible in the GitHub UI when the 'github-actions' reporter is enabled. It is auto-enabled when 'process.env.GITHUB_ACTIONS' is 'true' alongside the default reporter; otherwise, it must be explicitly added. The snippet demonstrates conditional reporter array selection based on environment variables.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/reporters.md#_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nexport default defineConfig({\n  test: {\n    reporters: process.env.GITHUB_ACTIONS ? [\"dot\", \"github-actions\"] : [\"dot\"],\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Restoring Stubbed Environment Variables with Vitest vi.unstubAllEnvs in TypeScript\nDESCRIPTION: Demonstrates how to use `vi.unstubAllEnvs` to restore environment variables (`process.env` and `import.meta.env`) previously modified using `vi.stubEnv`. The example shows stubbing `NODE_ENV` multiple times and then restoring it to its original value recorded before the first `stubEnv` call. Requires `vi` from `vitest`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_15\n\nLANGUAGE: ts\nCODE:\n```\nimport { vi } from 'vitest'\n\n// `process.env.NODE_ENV` and `import.meta.env.NODE_ENV`\n// are \"development\" before calling stubEnv\n\nvi.stubEnv('NODE_ENV', 'production')\n\nprocess.env.NODE_ENV === 'production'\nimport.meta.env.NODE_ENV === 'production'\n\nvi.stubEnv('NODE_ENV', 'staging')\n\nprocess.env.NODE_ENV === 'staging'\nimport.meta.env.NODE_ENV === 'staging'\n\nvi.unstubAllEnvs()\n\n// restores to the value that were stored before the first \"stubEnv\" call\nprocess.env.NODE_ENV === 'development'\nimport.meta.env.NODE_ENV === 'development'\n```\n\n----------------------------------------\n\nTITLE: Changing Vitest Coverage Reports Directory (JavaScript)\nDESCRIPTION: Demonstrates how to change the default output directory for coverage reports from `./coverage` to a custom path using the `test.coverage.reportsDirectory` option in the `vitest.config.js` file.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/coverage.md#_snippet_9\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  test: {\n    coverage: {\n      reportsDirectory: './tests/unit/coverage'\n    }\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Sharding Test Runs with Vitest CLI - SH\nDESCRIPTION: Demonstrates how to use the --shard option to divide test execution into multiple shards, enabling distributed or parallel test runs. The format is <index>/<count>, and each command runs the part of the suite corresponding to its index. Input: --shard parameter with values like 1/3, 2/3, etc. Output: Only the subset of tests for each shard is executed. Limitation: Cannot be combined with --watch mode; --reporter=blob output defaults to separate files per shard unless overridden.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/cli.md#_snippet_9\n\nLANGUAGE: sh\nCODE:\n```\nvitest run --shard=1/3\nvitest run --shard=2/3\nvitest run --shard=3/3\n\n```\n\n----------------------------------------\n\nTITLE: Asserting Function Throws Errors with Vitest (TypeScript)\nDESCRIPTION: Illustrates using `assert.throws` (aliased as `throw`, `Throw`) in Vitest to check if a function throws an error. It can assert the error type (constructor or instance) and optionally match the error message against a string or RegExp. Requires the function (`fn`) to be tested and optional error/message matchers.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_79\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.throws', () => {\n  // Assume 'fn' and 'errorInstance' are defined elsewhere for these examples\n  assert.throws(fn, 'Error thrown must have this msg')\n  assert.throws(fn, /Error thrown must have a msg that matches this/)\n  assert.throws(fn, ReferenceError)\n  assert.throws(fn, errorInstance)\n  assert.throws(fn, ReferenceError, 'Error thrown must be a ReferenceError and have this msg')\n  assert.throws(fn, errorInstance, 'Error thrown must be the same errorInstance and have this msg')\n  assert.throws(fn, ReferenceError, /Error thrown must be a ReferenceError and match this/)\n  assert.throws(fn, errorInstance, /Error thrown must be the same errorInstance and match this/)\n})\n```\n\n----------------------------------------\n\nTITLE: Using meta Method to Access Custom Metadata in Vitest TestCase (TypeScript)\nDESCRIPTION: This entry outlines the meta method, which returns TestMeta (custom runtime metadata) for a given test. The provided example shows how to attach a custom field to the test's meta during execution. Inputs include the context object in the test callback, and developers can assign or retrieve arbitrary metadata here. Useful for advanced test context tracking; meta is empty if the test hasn't run.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/test-case.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nfunction meta(): TaskMeta\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { test } from 'vitest'\n\ntest('the validation works correctly', ({ task }) => {\n  // ...\n\n  task.meta.decorated = false\n})\n```\n\n----------------------------------------\n\nTITLE: Enabling Headless Browser Testing via Vitest CLI (Shell)\nDESCRIPTION: Demonstrates how to enable headless browser testing mode directly from the command line using the `--browser.headless` flag when running Vitest via npx. This command implicitly uses Chrome as the default browser if not otherwise specified. Requires either `playwright` or `webdriverio` provider.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/index.md#_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\nnpx vitest --browser.headless\n```\n\n----------------------------------------\n\nTITLE: Enabling Headless Browser Testing in Vitest Configuration (TypeScript)\nDESCRIPTION: Configures Vitest to run browser tests in headless mode using Playwright as the provider. This is done within the `vitest.config.ts` file by setting `browser.enabled` and `browser.headless` to `true`. Requires either `playwright` or `webdriverio` provider.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/index.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\nexport default defineConfig({\n  test: {\n    browser: {\n      provider: 'playwright',\n      enabled: true,\n      headless: true,\n    },\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Writing a Basic Vitest Test (sum.test.js)\nDESCRIPTION: Demonstrates writing a simple test file (`sum.test.js`) using Vitest. It imports `expect` and `test` from 'vitest' and the `sum` function from './sum.js'. The test checks if `sum(1, 2)` equals 3 using `expect().toBe()`. By default, test files must include `.test.` or `.spec.` in their names.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/index.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { expect, test } from 'vitest'\nimport { sum } from './sum.js'\n\ntest('adds 1 + 2 to equal 3', () => {\n  expect(sum(1, 2)).toBe(3)\n})\n```\n\n----------------------------------------\n\nTITLE: Verifying the Number of Times a Spy Function Has Returned Using toHaveReturnedTimes\nDESCRIPTION: This snippet shows how to confirm that a spy function has returned successfully a specific number of times. It involves creating a spy with `vi.fn()`, invoking it multiple times, and asserting the exact return count. Useful for tracking function call counts in tests.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_29\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { expect, test, vi } from 'vitest'\n\ntest('spy function returns a value two times', () => {\n  const sell = vi.fn((product: string) => ({ product }))\n\n  sell('apples')\n  sell('bananas')\n\n  expect(sell).toHaveReturnedTimes(2)\n})\n```\n\n----------------------------------------\n\nTITLE: Asserting Inclusion in Strings, Arrays, or Objects using Vitest (TypeScript)\nDESCRIPTION: Demonstrates using `assert.include` in Vitest tests to check if an array contains a value, a string contains a substring, or an object contains specific properties (shallow check). Imports `assert` and `test`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_42\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.include', () => {\n  assert.include([1, 2, 3], 2, 'array contains value')\n  assert.include('foobar', 'foo', 'string contains substring')\n  assert.include({ foo: 'bar', hello: 'universe' }, { foo: 'bar' }, 'object contains property')\n})\n```\n\n----------------------------------------\n\nTITLE: Asserting Object Property Existence and Value with Vitest in TypeScript\nDESCRIPTION: `toHaveProperty` asserts an object contains a property at a given key path, optionally matching the property's value using deep equality. Supports nested properties using dot notation, array indices, or arrays for key paths. Inputs are target object, key(s), and optional expected value. Outputs are assertion results. Requires Vitest.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { expect, test } from 'vitest'\n\nconst invoice = {\n  'isActive': true,\n  'P.O': '12345',\n  'customer': {\n    first_name: 'John',\n    last_name: 'Doe',\n    location: 'China',\n  },\n  'total_amount': 5000,\n  'items': [\n    {\n      type: 'apples',\n      quantity: 10,\n    },\n    {\n      type: 'oranges',\n      quantity: 5,\n    },\n  ],\n}\n\ntest('John Doe Invoice', () => {\n  expect(invoice).toHaveProperty('isActive') // assert that the key exists\n  expect(invoice).toHaveProperty('total_amount', 5000) // assert that the key exists and the value is equal\n\n  expect(invoice).not.toHaveProperty('account') // assert that this key does not exist\n\n  // Deep referencing using dot notation\n  expect(invoice).toHaveProperty('customer.first_name')\n  expect(invoice).toHaveProperty('customer.last_name', 'Doe')\n  expect(invoice).not.toHaveProperty('customer.location', 'India')\n\n  // Deep referencing using an array containing the key\n  expect(invoice).toHaveProperty('items[0].type', 'apples')\n  expect(invoice).toHaveProperty('items.0.type', 'apples') // dot notation also works\n\n  // Deep referencing using an array containing the keyPath\n  expect(invoice).toHaveProperty(['items', 0, 'type'], 'apples')\n  expect(invoice).toHaveProperty(['items', '0', 'type'], 'apples') // string notation also works\n\n  // Wrap your key in an array to avoid the key from being parsed as a deep reference\n  expect(invoice).toHaveProperty(['P.O'], '12345')\n})\n```\n\n----------------------------------------\n\nTITLE: nth Method - Select Element at Specific Index in Query Results\nDESCRIPTION: Returns a locator matching the element at a specified zero-based index within multiple elements found by a query. Retries until the element is available, helping target specific elements when multiple match. Useful for distinguishing elements by position.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_20\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction nth(index: number): Locator\n```\n\n----------------------------------------\n\nTITLE: Skipping Tests with Context in Vitest\nDESCRIPTION: Example of using the skip function from the test context to skip test execution and mark the test as skipped.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/test-context.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { expect, it } from 'vitest'\n\nit('math is hard', ({ skip }) => {\n  skip()\n  expect(2 + 2).toBe(5)\n})\n```\n\n----------------------------------------\n\nTITLE: Fail Assertion with Vitest\nDESCRIPTION: This code showcases how to intentionally force an assertion failure. It can be used to verify failure scenarios or to signal that a code path should not be reached. Requires the `vitest` testing framework. It takes an optional message as input and always results in test failure. The second usage takes actual, expected, message, and operator.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.fail', () => {\n  assert.fail('error message on failure')\n  assert.fail('foo', 'bar', 'foo is not bar', '===')\n})\n```\n\n----------------------------------------\n\nTITLE: TSX example demonstrating `checked` option for `getByRole`\nDESCRIPTION: This TSX snippet demonstrates how to use the `checked` option with `getByRole` to filter elements based on their checked state (aria-checked or <input type=\"checkbox\"/>). It includes examples of elements with and without the checked attribute set. Requires a TSX environment that supports JSX syntax.  No external dependencies needed other than a rendering context for the TSX.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\n<>\n  <button role=\"checkbox\" aria-checked=\"true\" />\n  <input type=\"checkbox\" checked />\n</>\n\npage.getByRole('checkbox', { checked: true }) // ✅\npage.getByRole('checkbox', { checked: false }) // ❌\n```\n\n----------------------------------------\n\nTITLE: Verifying If a Function Has Resolved at Least Once Using toHaveResolved\nDESCRIPTION: This example demonstrates asserting that an asynchronous function (returning a Promise) has resolved successfully at least once. It involves wrapping the function with a spy, invoking it, and asserting resolution with `toHaveResolved`. Suitable for testing Promise-based functions that may perform asynchronous operations.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_33\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { expect, test, vi } from 'vitest'\nimport db from './db/apples.js'\n\nasync function getApplesPrice(amount: number) {\n  return amount * await db.get('price')\n}\n\ntest('spy function resolved a value', async () => {\n  const getPriceSpy = vi.fn(getApplesPrice)\n\n  const price = await getPriceSpy(10)\n\n  expect(price).toBe(100)\n  expect(getPriceSpy).toHaveResolved()\n})\n```\n\n----------------------------------------\n\nTITLE: Asserting Deep Equality with Vitest in TypeScript\nDESCRIPTION: `toEqual` asserts that two values are deeply equal recursively, useful for comparing objects' structural equality but not strict identity. Differences from `toBe` are documented with examples. Requires Vitest. Inputs are compared objects; output is assertion pass/fail.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { expect, test } from 'vitest'\n\nconst stockBill = {\n  type: 'apples',\n  count: 13,\n}\n\nconst stockMary = {\n  type: 'apples',\n  count: 13,\n}\n\ntest('stocks have the same properties', () => {\n  expect(stockBill).toEqual(stockMary)\n})\n\ntest('stocks are not the same', () => {\n  expect(stockBill).not.toBe(stockMary)\n})\n```\n\n----------------------------------------\n\nTITLE: Running Vitest with a Specific Browser via CLI - Shell\nDESCRIPTION: Shell commands to run Vitest tests in browser mode by specifying a target browser name or options via CLI flags. The `--browser` flag enables selecting browsers like `chrome` or setting browser options such as `headless` mode. This allows flexible test invocation without changing config files.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/index.md#_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\nnpx vitest --browser=chrome\n```\n\nLANGUAGE: shell\nCODE:\n```\nnpx vitest --browser.headless\n```\n\n----------------------------------------\n\nTITLE: Declaring all Function in Vitest (TypeScript)\nDESCRIPTION: Defines the all() function, which retrieves all matching locators as an array. Internally calls .elements and wraps each DOM element with page.elementLocator for chainable automated tests. Never throws errors, returns an array of Locator objects.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_53\n\nLANGUAGE: typescript\nCODE:\n```\nfunction all(): Locator[]\n```\n\n----------------------------------------\n\nTITLE: Running Vitest Tests via bun\nDESCRIPTION: This code snippet outlines how to run tests within a Vitest workspace using the bun package manager.  It includes options for running all tests and only tests inside of a single project.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/workspace.md#_snippet_15\n\nLANGUAGE: Bash\nCODE:\n```\nbun run test\n```\n\n----------------------------------------\n\nTITLE: Defining the Diagnostic Method for TestModule (TypeScript)\nDESCRIPTION: Presents the method signature for the diagnostic function, which is used to extract diagnostic information (like timing and memory usage) from a TestModule. Returns a ModuleDiagnostic object, defined elsewhere. If the module was not executed, all diagnostic values will be zero. The function is to be called after or during test run completion for accurate results.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/test-module.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nfunction diagnostic(): ModuleDiagnostic\n```\n\n----------------------------------------\n\nTITLE: Testing Formatter Module Import with Vitest in TypeScript\nDESCRIPTION: This TypeScript snippet shows a Vitest test case for verifying the 'formatter' function does not throw errors when called. It demonstrates two import styles: one using a barrel file and one directly importing the formatter module, highlighting the impact on file transforms in profiling. Dependencies include Vitest and the relevant source files. Input is the formatter module, and output is a passing test confirming formatter stability. This snippet assists in understanding barrel file implications on test transformations and performance.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/profiling-test-performance.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { expect, test } from 'vitest'\nimport { formatter } from '../src/utils' // [!code --]\nimport { formatter } from '../src/utils/formatters' // [!code ++]\n\ntest('formatter works', () => {\n  expect(formatter).not.toThrow()\n})\n```\n\n----------------------------------------\n\nTITLE: Using screenshot with Locator in Vitest (TypeScript)\nDESCRIPTION: Illustrates capturing screenshots using a button locator: saving to file path only, or retrieving both file path and base64 content. Requires @vitest/browser/context for page object; accepts LocatorScreenshotOptions for output customization, including output directory and encoding choice. Useful for visual regression or image comparisons; resolves asynchronously, outputs screenshot file and/or base64 string.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_45\n\nLANGUAGE: typescript\nCODE:\n```\nimport { page } from '@vitest/browser/context'\n\nconst button = page.getByRole('button', { name: 'Click Me!' })\n\nconst path = await button.screenshot()\n\nconst { path, base64 } = await button.screenshot({\n  path: './button-click-me.png',\n  base64: true, // also return base64 string\n})\n// path - fullpath to the screenshot\n// bas64 - base64 encoded string of the screenshot\n```\n\n----------------------------------------\n\nTITLE: Checking Resolved Value Using toHaveResolvedWith\nDESCRIPTION: This snippet verifies that an async function has resolved to a specific value at least once by awaiting the call and asserting the result matches expectations, suitable for Promise-based functions.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_35\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { expect, test, vi } from 'vitest'\n\ntest('spy function resolved a product', async () => {\n  const sell = vi.fn((product: string) => Promise.resolve({ product }))\n\n  await sell('apples')\n\n  expect(sell).toHaveResolvedWith({ product: 'apples' })\n})\n```\n\n----------------------------------------\n\nTITLE: Defining and Using toHaveFormValues Matcher in Vitest - TypeScript\nDESCRIPTION: Defines the toHaveFormValues matcher, used to assert a form or fieldset's form control values against an expected object. Requires a form or fieldset element; other elements are not supported. Key parameter is expectedValues, an object mapping input names to their expected values (string, number, boolean, or array as appropriate). Handles normalization for various input and select types as described. Output is a pass/fail assertion based on value matching. Limitations: only valid for form/fieldset; cannot be applied to non-form containers.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_20\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction toHaveFormValues(expectedValues: Record<string, unknown>): Promise<void>\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nawait expect.element(getByTestId('login-form')).toHaveFormValues({\n  username: 'jane.doe',\n  rememberMe: true,\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring TypeScript `compilerOptions.types` for Vitest Browser Providers - JSON\nDESCRIPTION: Configuration snippets for adding Vitest browser matchers or providers to the `types` array inside the `compilerOptions` field of `tsconfig.json`. Ensures that TypeScript loads the correct type declarations for the used browser mode features, though specifying this field disables auto-loading of other `@types/*` packages.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/index.md#_snippet_8\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"compilerOptions\": {\n    \"types\": [\"@vitest/browser/matchers\"]\n  }\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"compilerOptions\": {\n    \"types\": [\"@vitest/browser/providers/playwright\"]\n  }\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"compilerOptions\": {\n    \"types\": [\"@vitest/browser/providers/webdriverio\"]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting One-Time Mock Implementation with mockImplementationOnce\nDESCRIPTION: This snippet illustrates the use of `mockImplementationOnce` to provide different implementations for consecutive calls to a mock function. It allows chaining multiple `mockImplementationOnce` calls. After all `mockImplementationOnce` implementations are exhausted, the default implementation (if any) is used.  TypeScript expects the arguments and return type to match those of the original function.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/mock.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst myMockFn = vi\n  .fn()\n  .mockImplementationOnce(() => true) // 1st call\n  .mockImplementationOnce(() => false) // 2nd call\n\nmyMockFn() // 1st call: true\nmyMockFn() // 2nd call: false\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst myMockFn = vi\n  .fn(() => 'default')\n  .mockImplementationOnce(() => 'first call')\n  .mockImplementationOnce(() => 'second call')\n\n// 'first call', 'second call', 'default', 'default'\nconsole.log(myMockFn(), myMockFn(), myMockFn(), myMockFn())\n```\n\n----------------------------------------\n\nTITLE: Configuring Module Directories with defineConfig - Vitest - TypeScript\nDESCRIPTION: This code snippet demonstrates how to use the defineConfig function from vitest/config to customize the list of module directories. By specifying the moduleDirectories array, you control where Vitest searches for modules and mocks. Requires the vitest/config module and, if using non-default directories, Node.js path resolution. Takes an object with a test.deps.moduleDirectories key (array of directories), returning a configuration object. The main output is a properly structured Vitest configuration for dependency resolution. Ensure all specified paths exist to avoid resolution errors.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    deps: {\n      moduleDirectories: ['node_modules', path.resolve('../../packages')],\n    }\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Adding Coverage Script (JSON)\nDESCRIPTION: Example `package.json` demonstrating how to add a script named `coverage` that runs Vitest with coverage enabled by passing the `--coverage` command-line flag. This provides a convenient way to generate coverage reports.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/coverage.md#_snippet_3\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"scripts\": {\n    \"test\": \"vitest\",\n    \"coverage\": \"vitest run --coverage\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting Spy Function Was Called a Specific Number of Times in Vitest\nDESCRIPTION: Shows how to use `.toHaveBeenCalledTimes()` to verify that a spy function was invoked exactly a certain number of times during the test run. Requires a spy function.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_21\n\nLANGUAGE: ts\nCODE:\n```\nimport { expect, test, vi } from 'vitest'\n\nconst market = {\n  buy(subject: string, amount: number) {\n    // ...\n  },\n}\n\ntest('spy function called two times', () => {\n  const buySpy = vi.spyOn(market, 'buy')\n\n  market.buy('apples', 10)\n  market.buy('apples', 20)\n\n  expect(buySpy).toHaveBeenCalledTimes(2)\n})\n```\n\n----------------------------------------\n\nTITLE: filter Method - Narrow Down Locator with Various Options\nDESCRIPTION: Refines a locator based on provided filtering options such as has, hasNot, hasText, and hasNotText. Allows chaining to create highly specific element queries, including filtering by nested elements or text content.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_25\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction filter(options: LocatorOptions): Locator\n```\n\n----------------------------------------\n\nTITLE: Sharding Tests in Parallel Environments using Bash\nDESCRIPTION: This set of bash commands demonstrates running and merging Vitest tests in parallel shards, then merging results for reporting. The 'vitest --shard=1/2' and 'vitest --shard=2/2' commands split the test suite across two processes, reporting with the 'blob' reporter and generating coverage data. The final command uses 'vitest --merge-reports' to aggregate results and output them in the 'junit' format with final coverage stats. This is commonly used in CI pipelines for large projects.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/features.md#_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nvitest --shard=1/2 --reporter=blob --coverage\nvitest --shard=2/2 --reporter=blob --coverage\nvitest --merge-reports --reporter=junit --coverage\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Vitest Workspace with Glob\nDESCRIPTION: This snippet defines a Vitest workspace using a glob pattern to include all folders within the `packages` directory as separate projects. It leverages the `defineConfig` function from the `vitest/config` module.  The workspace configuration is specified within the `test` object, which is part of the main configuration.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/workspace.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    workspace: ['packages/*'],\n  },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Asynchronously Executing All Pending Fake Timers with Vitest vi.runAllTimersAsync in TypeScript\nDESCRIPTION: Shows how `vi.runAllTimersAsync` executes all scheduled timers, including asynchronous ones (e.g., `setTimeout` with async callback), until the queue is empty. It returns a Promise that resolves after all timers, including async operations within them, have completed. Requires `vi` from `vitest`, enabling fake timers, and using `await`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_25\n\nLANGUAGE: ts\nCODE:\n```\nsetTimeout(async () => {\n  console.log(await Promise.resolve('result'))\n}, 100)\n\nawait vi.runAllTimersAsync()\n\n// log: result\n```\n\n----------------------------------------\n\nTITLE: Resetting Modules with vi.resetModules\nDESCRIPTION: This example shows how to use `vi.resetModules` to clear the module cache, forcing modules to be re-evaluated on subsequent imports. This is useful for isolating modules with local state between tests. Top-level imports will not be re-evaluated.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { vi } from 'vitest'\n\nimport { data } from './data.js' // Will not get reevaluated beforeEach test\n\nbeforeEach(() => {\n  vi.resetModules()\n})\n\ntest('change state', async () => {\n  const mod = await import('./some/path.js') // Will get reevaluated\n  mod.changeLocalState('new value')\n  expect(mod.getLocalState()).toBe('new value')\n})\n\ntest('module has old state', async () => {\n  const mod = await import('./some/path.js') // Will get reevaluated\n  expect(mod.getLocalState()).toBe('old value')\n})\n```\n\n----------------------------------------\n\nTITLE: Asynchronously Advancing to the Next Fake Timer with Vitest vi.advanceTimersToNextTimerAsync in TypeScript\nDESCRIPTION: Demonstrates `vi.advanceTimersToNextTimerAsync`, which advances to the next scheduled timer and waits for its resolution if it's asynchronous (e.g., involves Promises). This allows precise control and assertions for async timer callbacks. Requires `vi` from `vitest`, enabling fake timers, and using `await`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_22\n\nLANGUAGE: ts\nCODE:\n```\nlet i = 0\nsetInterval(() => Promise.resolve().then(() => console.log(++i)), 50)\n\nawait vi.advanceTimersToNextTimerAsync() // log: 1\nexpect(console.log).toHaveBeenCalledWith(1)\n\nawait vi.advanceTimersToNextTimerAsync() // log: 2\nawait vi.advanceTimersToNextTimerAsync() // log: 3\n```\n\n----------------------------------------\n\nTITLE: Configuring Multiple Browser Instances - Advanced\nDESCRIPTION: This code configures Vitest to run tests in Chromium with two different setups using `browser.instances`. It configures custom options such as `name`, `setupFiles`, and `provide` for each Chromium instance. The `setupFiles` option specifies a file to execute before the tests in the first instance. The `provide` option allows injecting different values during the test.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/multiple-setups.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\nexport default defineConfig({\n  test: {\n    browser: {\n      enabled: true,\n      provider: 'playwright',\n      headless: true,\n      instances: [\n        {\n          browser: 'chromium',\n          name: 'chromium-1',\n          setupFiles: ['./ratio-setup.ts'],\n          provide: {\n            ratio: 1,\n          }\n        },\n        {\n          browser: 'chromium',\n          name: 'chromium-2',\n          provide: {\n            ratio: 2,\n          }\n        },\n      ],\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Using assert.property in Vitest (TypeScript)\nDESCRIPTION: Demonstrates the `assert.property` method, which asserts that an object possesses a specified property, either directly or inherited. The example imports from `vitest` and shows checks for both a direct property ('tea') and an inherited property ('toString') within a test.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_56\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.property', () => {\n  assert.property({ tea: { green: 'matcha' } }, 'tea')\n  assert.property({ tea: { green: 'matcha' } }, 'toString')\n})\n```\n\n----------------------------------------\n\nTITLE: Starting Vitest in Watch Mode using Bash\nDESCRIPTION: This snippet demonstrates starting the Vitest test runner in watch mode using the CLI command in a shell environment. Dependencies include Node.js with Vitest installed either globally or as a local project dependency. The expected usage is to execute the command from a terminal to launch Vitest, which will reactively re-run tests as files change. It is typically used in development environments and does not require additional options except for specific configuration files if needed.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/features.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ vitest\n\n```\n\n----------------------------------------\n\nTITLE: Replacing import.meta.vitest for Dead Code Elimination with Unbuild (TypeScript)\nDESCRIPTION: Demonstrates how to use Unbuild's configuration to replace references to `import.meta.vitest` with `undefined` during the build process. This configuration, within `replace`, ensures in-source tests are not included in the final build output. It is specific to projects using Unbuild as their build tool.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/in-source.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { defineBuildConfig } from 'unbuild'\n\nexport default defineBuildConfig({\n  replace: { // [!code ++]\n    'import.meta.vitest': 'undefined' // [!code ++]\n  } // [!code ++]\n  // other options\n})\n```\n\n----------------------------------------\n\nTITLE: Running Vite Node via CLI (Bash)\nDESCRIPTION: Executes a TypeScript or JavaScript file (`index.ts` in this example) using the Vite Node runtime via the `npx` command. This leverages Vite's resolvers and transformers.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/vite-node/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx vite-node index.ts\n```\n\n----------------------------------------\n\nTITLE: Configuring Stack Trace Filtering in Vitest (TypeScript)\nDESCRIPTION: Shows how to apply a filtering function to each frame of each stack trace when handling errors in Vitest. Demonstrates filtering out stack trace frames from third-party libraries based on the file path.  Requires `vitest` types for ParsedStack and `vitest/config` dependency.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_38\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { ParsedStack } from 'vitest'\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    onStackTrace(error: Error, { file }: ParsedStack): boolean | void {\n      // If we've encountered a ReferenceError, show the whole stack.\n      if (error.name === 'ReferenceError') {\n        return\n      }\n\n      // Reject all frames from third party libraries.\n      if (file.includes('node_modules')) {\n        return false\n      }\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Workspace using Inline Configuration\nDESCRIPTION: This snippet demonstrates how to define projects within a Vitest workspace using inline configurations.  It shows how to add 'extends' property to merge with root configurations. Different projects can have specific configurations (e.g., including tests or setting environment). The configuration allows the combination of glob patterns and inline configs.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/workspace.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    workspace: [\n      // matches every folder and file inside the `packages` folder\n      'packages/*',\n      {\n        // add \"extends: true\" to inherit the options from the root config\n        extends: true,\n        test: {\n          include: ['tests/**/*.{browser}.test.{ts,js}'],\n          // it is recommended to define a name when using inline configs\n          name: 'happy-dom',\n          environment: 'happy-dom',\n        }\n      },\n      {\n        test: {\n          include: ['tests/**/*.{node}.test.{ts,js}'],\n          name: 'node',\n          environment: 'node',\n        }\n      }\n    ]\n  }\n})\n\n```\n\n----------------------------------------\n\nTITLE: Concurrent Test Execution with Vitest in TypeScript\nDESCRIPTION: This TypeScript snippet illustrates how to run tests concurrently using the 'concurrent' modifier provided by Vitest. It requires the 'vitest' package installed and set up in a TypeScript environment. The snippet defines a test suite with individual and concurrent tests, showing how tests can run in parallel for improved performance. Inputs are test definitions with optional parameters like the test context ('{ expect }'). Outputs are parallel test execution results. It is important to use 'expect' from the local test context to avoid test collisions.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/features.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { describe, it } from 'vitest'\n\n// The two tests marked with concurrent will be started in parallel\ndescribe('suite', () => {\n  it('serial test', async () => { /* ... */ })\n  it.concurrent('concurrent test 1', async ({ expect }) => { /* ... */ })\n  it.concurrent('concurrent test 2', async ({ expect }) => { /* ... */ })\n})\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Browser Instances in Vitest\nDESCRIPTION: This code snippet shows how to configure browser instances, including browser type, launch options, and context options within the `vitest.config.ts` file.  It configures a firefox browser instance.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/playwright.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    browser: {\n      instances: [\n        {\n          browser: 'firefox',\n          launch: {},\n          context: {},\n        },\n      ],\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Asserting Last Call of Spy Function Had Specific Arguments in Vitest\nDESCRIPTION: Demonstrates using `.toHaveBeenLastCalledWith()` and `.not.toHaveBeenLastCalledWith()` to check the arguments that were used in the most recent invocation of a spy function. Requires a spy function.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_26\n\nLANGUAGE: ts\nCODE:\n```\nimport { expect, test, vi } from 'vitest'\n\nconst market = {\n  buy(subject: string, amount: number) {\n    // ...\n  },\n}\n\ntest('spy function', () => {\n  const buySpy = vi.spyOn(market, 'buy')\n\n  market.buy('apples', 10)\n  market.buy('apples', 20)\n\n  expect(buySpy).not.toHaveBeenLastCalledWith('apples', 10)\n  expect(buySpy).toHaveBeenLastCalledWith('apples', 20)\n})\n```\n\n----------------------------------------\n\nTITLE: and Method - Combine Multiple Locators with AND Logic\nDESCRIPTION: Creates a new locator that matches elements satisfying both parent locators. Enables combining multiple criteria to refine element selection, such as role and title simultaneously.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_23\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction and(locator: Locator): Locator\n```\n\n----------------------------------------\n\nTITLE: Checking Substrings with expect.stringContaining in Vitest (TypeScript)\nDESCRIPTION: Illustrates using the `expect.stringContaining(expected)` asymmetric matcher within `toEqual`. It checks if the actual string value contains the specified `expected` substring.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_49\n\nLANGUAGE: typescript\nCODE:\n```\nimport { expect, test } from 'vitest'\n\ntest('variety has \"Emp\" in its name', () => {\n  const variety = {\n    name: 'Empire',\n    count: 1,\n  }\n  expect(variety).toEqual({\n    name: expect.stringContaining('Emp'),\n    count: 1,\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Workspace using Inline Configuration and defineWorkspace\nDESCRIPTION: This snippet demonstrates the use of `defineWorkspace` function to define multiple projects inline, providing a type hinting DX. It shows how to add 'extends' property to merge with a root level configurations and set up specific environments for projects.  The configuration allows the combination of glob patterns and inline configs.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/workspace.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { defineWorkspace } from 'vitest/config'\n\n// defineWorkspace provides a nice type hinting DX\nexport default defineWorkspace([\n  // matches every folder and file inside the `packages` folder\n  'packages/*',\n  {\n    // add \"extends\" to merge two configs together\n    extends: './vite.config.js',\n    test: {\n      include: ['tests/**/*.{browser}.test.{ts,js}'],\n      // it is recommended to define a name when using inline configs\n      name: 'happy-dom',\n      environment: 'happy-dom',\n    }\n  },\n  {\n    test: {\n      include: ['tests/**/*.{node}.test.{ts,js}'],\n      name: 'node',\n      environment: 'node',\n    }\n  }\n])\n\n```\n\n----------------------------------------\n\nTITLE: Configuring ESBuild for Coverage in Vitest (TS)\nDESCRIPTION: This snippet demonstrates configuring ESBuild options within a Vitest configuration file to transpile files for accurate code coverage. It includes specifying files to transpile, ensuring comments and Typescript types are removed. Requires installing `vitest/config`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_30\n\nLANGUAGE: ts\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  esbuild: {\n    // Transpile all files with ESBuild to remove comments from code coverage.\n    // Required for `test.coverage.ignoreEmptyLines` to work:\n    include: ['**/*.js', '**/*.jsx', '**/*.mjs', '**/*.ts', '**/*.tsx'],\n  },\n  test: {\n    coverage: {\n      provider: 'v8',\n      ignoreEmptyLines: true,\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Using mockClear to Reset Call History\nDESCRIPTION: This example showcases the `mockClear` method, which clears all information about previous calls to a mock function. The implementation is retained. This is useful for isolating assertions in different test cases where the mock implementation should persist between them.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/mock.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst person = {\n  greet: (name: string) => `Hello ${name}`,\n}\nconst spy = vi.spyOn(person, 'greet').mockImplementation(() => 'mocked')\nexpect(person.greet('Alice')).toBe('mocked')\nexpect(spy.mock.calls).toEqual([['Alice']])\n\n// clear call history but keep mock implementation\nspy.mockClear()\nexpect(spy.mock.calls).toEqual([])\nexpect(person.greet('Bob')).toBe('mocked')\nexpect(spy.mock.calls).toEqual([['Bob']])\n```\n\n----------------------------------------\n\nTITLE: Spying on Object Methods with vi.spyOn\nDESCRIPTION: This example demonstrates how to spy on a method of an object using `vi.spyOn`. It shows how to track calls to the method and override its implementation using `mockImplementation`. It returns a MockInstance object that allows observing and manipulating the method's behavior.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nlet apples = 0\nconst cart = {\n  getApples: () => 42,\n}\n\nconst spy = vi.spyOn(cart, 'getApples').mockImplementation(() => apples)\napples = 1\n\nexpect(cart.getApples()).toBe(1)\n\nexpect(spy).toHaveBeenCalled()\nexpect(spy).toHaveReturnedWith(1)\n```\n\n----------------------------------------\n\nTITLE: Running Browser Tests during Development (Bash)\nDESCRIPTION: This snippet provides Bash commands to navigate to the browser test directory within the project and execute specific test suites. It shows commands for running relevant tests (`pnpm test`) to verify functionality and running tests directly in browser mode (`pnpm test-fixtures`) for active development. It assumes `pnpm` is used as the package manager.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/browser/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncd test/browser\n# runs relevant tests for the browser mode\n# useful to confirm everything works fine\npnpm test\n# runs tests as the browser mode\n# useful during development\npnpm test-fixtures\n```\n\n----------------------------------------\n\nTITLE: Matching Value Against External Snapshot in Vitest\nDESCRIPTION: Shows how to use `.toMatchSnapshot()` to compare a value against a stored external snapshot file (`.snap`). Vitest creates or updates the snapshot file on the first run or when explicitly requested.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_15\n\nLANGUAGE: ts\nCODE:\n```\nimport { expect, test } from 'vitest'\n\ntest('matches snapshot', () => {\n  const data = { foo: new Set(['bar', 'snapshot']) }\n  expect(data).toMatchSnapshot()\n})\n```\n\n----------------------------------------\n\nTITLE: Asynchronously Advancing Fake Timers by Time with Vitest vi.advanceTimersByTimeAsync in TypeScript\nDESCRIPTION: Shows how `vi.advanceTimersByTimeAsync` advances fake timers by a given duration, including timers set asynchronously (e.g., within a `Promise.resolve().then`). This function returns a Promise that resolves after the specified time has passed and relevant async callbacks have executed. Requires `vi` from `vitest`, enabling fake timers, and using `await`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_20\n\nLANGUAGE: ts\nCODE:\n```\nlet i = 0\nsetInterval(() => Promise.resolve().then(() => console.log(++i)), 50)\n\nawait vi.advanceTimersByTimeAsync(150)\n\n// log: 1\n// log: 2\n// log: 3\n```\n\n----------------------------------------\n\nTITLE: Configuring Inline Workspace in Vitest 3\nDESCRIPTION: Demonstrates how to set up a workspace configuration directly in the Vitest config file using the new 'workspace' field, eliminating the need for separate workspace files.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/blog/vitest-3.md#_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    workspace: ['packages/*'],\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Using assert.notMatch in Vitest (TypeScript)\nDESCRIPTION: Provides an example of `assert.notMatch` in Vitest. This assertion verifies that a string value does not match the provided regular expression. The code imports from `vitest` and demonstrates the assertion within a test function, including an optional message.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_55\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.notMatch', () => {\n  assert.notMatch('foobar', /^foo/, 'regexp does not match')\n})\n```\n\n----------------------------------------\n\nTITLE: Assertion for Numerical Proximity in Vitest (TypeScript)\nDESCRIPTION: Defines `assert.closeTo` (alias `approximately`) to check if a number `actual` is within `delta` of `expected`. Useful for floating-point comparisons. The snippet demonstrates its usage in a test.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_82\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\n test('assert.closeTo', () => {\n  assert.closeTo(1.5, 1, 0.5, 'numbers are close')\n})\n```\n\n----------------------------------------\n\nTITLE: Running Vitest Tests in specific project via npm\nDESCRIPTION: This snippet demonstrates how to run tests in a specific project within a Vitest workspace using the `--project` CLI option with npm.  The example targets a project named `e2e`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/workspace.md#_snippet_7\n\nLANGUAGE: Bash\nCODE:\n```\nnpm run test --project e2e\n```\n\n----------------------------------------\n\nTITLE: Configuring Vitest Threads Pool Test Runner for CPU and Heap Profiling in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates configuring Vitest's test runner with 'threads' pool for CPU and heap profiling. It sets execArgv flags similar to the forks configuration, directing profiling outputs to 'test-runner-profile' and enables a single thread profile generation via 'singleThread: true'. Required dependencies include Node.js and Vitest basics. Tests are executed with these profiling flags producing profiling files for analysis. It is important to note that some profiling options may be limited or incompatible with worker threads in Node.js.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/profiling-test-performance.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    pool: 'threads',\n    poolOptions: {\n      threads: {\n        execArgv: [\n          '--cpu-prof',\n          '--cpu-prof-dir=test-runner-profile',\n          '--heap-prof',\n          '--heap-prof-dir=test-runner-profile'\n        ],\n\n        // To generate a single profile\n        singleThread: true,\n      },\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Asserting String Pattern Matching with Vitest in TypeScript\nDESCRIPTION: `toMatch` asserts that a string matches a regular expression or contains a substring. Inputs are the string under test and a pattern string or regular expression. Outputs are assertion pass/fail. Requires Vitest.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_10\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { expect, test } from 'vitest'\n\ntest('top fruits', () => {\n  expect('top fruits include apple, orange and grape').toMatch(/apple/)\n  expect('applefruits').toMatch('fruit') // toMatch also accepts a string\n})\n```\n\n----------------------------------------\n\nTITLE: Asserting a Value is a Number using Vitest (TypeScript)\nDESCRIPTION: Demonstrates using `assert.isNumber` within a Vitest test to check if a variable holds a numeric value. Imports `assert` and `test` from 'vitest'.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_33\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\nconst colors = 3\n\ntest('assert.isNumber', () => {\n  assert.isNumber(colors, 'colors is number')\n})\n```\n\n----------------------------------------\n\nTITLE: Asserting Object Is Not Frozen with Vitest - TypeScript\nDESCRIPTION: Verifies that an object is not frozen and remains mutable with Vitest's isNotFrozen assertion. Requires the object and optional message. This check enforces the ability to modify object properties as needed.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_119\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.isNotFrozen', () => {\n  assert.isNotFrozen({})\n})\n```\n\n----------------------------------------\n\nTITLE: Assert Value is At Least with Vitest\nDESCRIPTION: This demonstrates `assert.isAtLeast`, which checks if a value is greater than or equal to another. It uses the `vitest` testing framework.  It takes two numbers and asserts that the first is greater than or equal to the second.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_10\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.isAtLeast', () => {\n  assert.isAtLeast(5, 2, '5 is greater or equal to 2')\n  assert.isAtLeast(3, 3, '3 is greater or equal to 3')\n})\n```\n\n----------------------------------------\n\nTITLE: Tracking Mock Execution Order with mock.invocationCallOrder (TypeScript/JavaScript)\nDESCRIPTION: The `mock.invocationCallOrder` property is an array of numbers indicating the global order in which this specific mock function was invoked relative to all other Vitest mocks defined in the test suite. Each number represents a unique invocation across all mocks.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/mock.md#_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nconst invocationCallOrder: number[]\n```\n\nLANGUAGE: javascript\nCODE:\n```\nconst fn1 = vi.fn()\nconst fn2 = vi.fn()\n\nfn1()\nfn2()\nfn1()\n\nfn1.mock.invocationCallOrder === [1, 3]\nfn2.mock.invocationCallOrder === [2]\n```\n\n----------------------------------------\n\nTITLE: CLI Command for Browser Debugging\nDESCRIPTION: This bash command runs Vitest in browser mode with debugging enabled. It uses `--inspect-brk` to pause execution on the first line, `--browser` to enable browser mode, and `--no-file-parallelism` to disable parallel test execution. Requires Vitest to be installed.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/debugging.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nvitest --inspect-brk --browser --no-file-parallelism\n```\n\n----------------------------------------\n\nTITLE: Configuring Vitest Environment for happy-dom or jsdom in TypeScript\nDESCRIPTION: This TypeScript configuration snippet demonstrates how to set the environment for Vitest to 'happy-dom', 'jsdom', or 'node' by editing the 'vitest.config.ts' file. It uses 'defineConfig' from 'vitest/config'. Prerequisites include installing the selected environment package ('happy-dom' or 'jsdom'). The 'test.environment' field should match the intended environment. The config determines how Vitest interprets APIs during testing.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/features.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    environment: 'happy-dom', // or 'jsdom', 'node'\n  },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Checking for `never` Type using Vitest in TypeScript\nDESCRIPTION: Utilizes `.toBeNever` matcher to verify if a given type is `never`. Requires Vitest. Useful for contracts that must produce impossible (uninhabited) types or when confirming unreachable code paths with TypeScript.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect-typeof.md#_snippet_15\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf<never>().toBeNever()\nexpectTypeOf((): never => {}).returns.toBeNever()\n```\n\n----------------------------------------\n\nTITLE: Using JSON Reporter - Configuration\nDESCRIPTION: This snippet demonstrates configuring the `json` reporter within the `vitest.config.ts` file.  It sets the `reporters` array to `['json']`. The JSON reporter generates a report of the test results in a JSON format compatible with Jest's `--json` option.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/reporters.md#_snippet_16\n\nLANGUAGE: ts\nCODE:\n```\nexport default defineConfig({\n  test: {\n    reporters: ['json']\n  },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Matching Partial Object Shape Against External Snapshot in Vitest\nDESCRIPTION: Demonstrates using `.toMatchSnapshot()` with a shape argument to test only a subset or specific structure of an object rather than an exact match. The example uses `expect.any(Set)` to check if the 'foo' property is any instance of a Set.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_16\n\nLANGUAGE: ts\nCODE:\n```\nimport { expect, test } from 'vitest'\n\ntest('matches snapshot', () => {\n  const data = { foo: new Set(['bar', 'snapshot']) }\n  expect(data).toMatchSnapshot({ foo: expect.any(Set) })\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Vitest Workspace using Config Files\nDESCRIPTION: This code snippet shows how to define a Vitest workspace by specifying a glob pattern that includes specific configuration files within projects, targeting files ending with `.config.{e2e,unit}.ts`. This allows targeting only selected configurations.  The workspace is configured in the root Vitest configuration file and uses `defineConfig` from `vitest/config`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/workspace.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    workspace: ['packages/*/vitest.config.{e2e,unit}.ts'],\n  },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Getting Project by Name\nDESCRIPTION: This method allows you to retrieve a test project by its name. It is equivalent to calling `vitest.projects.find`. If the project isn't found, it will return the root project; you should check the names again when the project you're looking for is the one returned.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/vitest.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction getProjectByName(name: string): TestProject\n```\n\n----------------------------------------\n\nTITLE: Assert Value is Below with Vitest\nDESCRIPTION: This code demonstrates `assert.isBelow` used for asserting that a value is strictly less than another value. It uses the `vitest` testing framework. The input is two numbers, where the assertion passes if the first number is strictly less than the second.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_11\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.isBelow', () => {\n  assert.isBelow(3, 6, '3 is strictly less than 6')\n})\n```\n\n----------------------------------------\n\nTITLE: Checking Checked State of Checkbox and Radio Inputs with Vitest - TypeScript\nDESCRIPTION: The `toBeChecked` function asynchronously asserts whether an element is checked. It supports input elements of type checkbox and radio, and elements with roles 'checkbox', 'radio', or 'switch' having a valid `aria-checked` attribute. This snippet also demonstrates HTML examples of such elements in checked and unchecked states and how to assert using test IDs in Vitest.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_31\n\nLANGUAGE: ts\nCODE:\n```\nfunction toBeChecked(): Promise<void>\n```\n\n----------------------------------------\n\nTITLE: Using Hashbang for Vite Node Scripts (TypeScript)\nDESCRIPTION: Example TypeScript file (`file.ts`) showing how to use a hashbang (`#!/usr/bin/env vite-node --script`) to allow the script to be executed directly using `vite-node` without explicitly invoking it via `npx`. The script logs command-line arguments passed to it.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/vite-node/README.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n#!/usr/bin/env vite-node --script\n\nconsole.log('argv:', process.argv.slice(2))\n```\n\n----------------------------------------\n\nTITLE: Using assert.notDeepNestedPropertyVal in Vitest (TypeScript)\nDESCRIPTION: Shows the usage of `assert.notDeepNestedPropertyVal`. This method asserts that an object either doesn't have a nested property or has it with a value that is not deeply equal to the specified value. The example imports from `vitest` and demonstrates various failing conditions for deep equality within a test.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_67\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.notDeepNestedPropertyVal', () => {\n  assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { oolong: 'yum' })\n  assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { matcha: 'yuck' })\n  assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.black', { matcha: 'yum' })\n})\n```\n\n----------------------------------------\n\nTITLE: Referencing Vitest Config Types for Plugin Augmentation - TypeScript\nDESCRIPTION: A TypeScript reference directive that includes type definitions from `vitest/config`. This is necessary when defining a plugin that works with both Vite and Vitest to ensure that the `configureVitest` hook is recognized and correctly typed within the plugin object derived from `vite`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/plugin.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n/// <reference types=\"vitest/config\" />\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies and Building Wasm Project\nDESCRIPTION: This shell script installs project dependencies using npm and then runs the build command.  The built output from wasm-bindgen generates JavaScript and WebAssembly files.  After building, the user needs to copy the generated files to the current directory and add a module type.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/test/core/src/wasm/wasm-bindgen-no-cyclic/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm i\nnpm run build\n# then\n# 1. copy `examples/hello_world/pkg` to this directory\n# 2. add { \"type\": \"module\" } to `package.json`\n#    (this will be automatically included after https://github.com/rustwasm/wasm-pack/pull/1061)\n```\n\n----------------------------------------\n\nTITLE: Initializing Vitest Configuration with defineConfig from Vite\nDESCRIPTION: This snippet demonstrates how to initialize a Vitest configuration using `defineConfig` from the `vite` package. It shows how to include the necessary type references and define the `test` property within the Vite configuration. This approach integrates Vitest configuration within the existing Vite setup, allowing for a unified configuration strategy.  The example uses a triple-slash directive to reference vitest types.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n/// <reference types=\"vitest\" />\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  test: {\n    // ... Specify options here.\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Using assert.deepOwnInclude in Vitest (TypeScript)\nDESCRIPTION: Demonstrates how to use the `assert.deepOwnInclude` method in a Vitest test. This assertion checks if an object (`haystack`) deeply includes the own properties of another object (`needle`), ignoring inherited properties. The example imports `assert` and `test` from `vitest` and calls `assert.deepOwnInclude` within a test case.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_52\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.deepOwnInclude', () => {\n  assert.deepOwnInclude({ a: { b: 2 } }, { a: { b: 2 } })\n})\n```\n\n----------------------------------------\n\nTITLE: Waiting for Dynamic Imports with vi.dynamicImportSettled\nDESCRIPTION: This code demonstrates how to use `vi.dynamicImportSettled` to wait for all dynamic imports to complete. This is useful when dealing with asynchronous imports that need to be resolved before assertions can be made.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { expect, test } from 'vitest'\n\n// cannot track import because Promise is not returned\nfunction renderComponent() {\n  import('./component.js').then(({ render }) => {\n    render()\n  })\n}\n\ntest('operations are resolved', async () => {\n  renderComponent()\n  await vi.dynamicImportSettled()\n  expect(document.querySelector('.component')).not.toBeNull()\n})\n```\n\n----------------------------------------\n\nTITLE: Accessing Mock Instances Created with `new` using mock.instances (TypeScript/JavaScript)\nDESCRIPTION: The `mock.instances` property is an array containing all object instances created when the mock function was invoked using the `new` keyword. It captures the `this` context of the constructor call. Note that if the constructor explicitly returns an object, that returned object will be in `mock.results`, not `mock.instances`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/mock.md#_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nconst instances: ReturnType<T>[]\n```\n\nLANGUAGE: javascript\nCODE:\n```\nconst MyClass = vi.fn()\nconst a = new MyClass()\n\nMyClass.mock.instances[0] === a\n```\n\nLANGUAGE: javascript\nCODE:\n```\nconst Spy = vi.fn(() => ({ method: vi.fn() }))\nconst a = new Spy()\n\nSpy.mock.instances[0] !== a\nSpy.mock.results[0] === a\n```\n\n----------------------------------------\n\nTITLE: toBeEnabled Assertion Example\nDESCRIPTION: Shows how to use the toBeEnabled assertion to check if an element is not disabled from the user's perspective.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_3\n\nLANGUAGE: html\nCODE:\n```\n<button\n  data-testid=\"button\"\n  type=\"submit\"\n  disabled\n>\n  submit\n</button>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nawait expect.element(getByTestId('button')).toBeEnabled() // ✅\nawait expect.element(getByTestId('button')).not.toBeEnabled() // ❌\n```\n\n----------------------------------------\n\nTITLE: Checking Array Contents with expect.arrayContaining in Vitest (TypeScript)\nDESCRIPTION: Shows how to use the `expect.arrayContaining(expected)` asymmetric matcher within `toEqual`. It verifies that the actual array value contains all the elements specified in the `expected` array, regardless of order or other elements present.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_47\n\nLANGUAGE: typescript\nCODE:\n```\nimport { expect, test } from 'vitest'\n\ntest('basket includes fuji', () => {\n  const basket = {\n    varieties: [\n      'Empire',\n      'Fuji',\n      'Gala',\n    ],\n    count: 3\n  }\n  expect(basket).toEqual({\n    count: 3,\n    varieties: expect.arrayContaining(['Fuji'])\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Matching Strings with Regex using expect.stringMatching in Vitest (TypeScript)\nDESCRIPTION: Shows how the `expect.stringMatching(expected)` asymmetric matcher works within `toEqual`. It verifies that the actual string value matches the provided regular expression or contains the provided string.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_50\n\nLANGUAGE: typescript\nCODE:\n```\nimport { expect, test } from 'vitest'\n\ntest('variety ends with \"re\"', () => {\n  const variety = {\n    name: 'Empire',\n    count: 1,\n  }\n  expect(variety).toEqual({\n    name: expect.stringMatching(/re$/),\n    count: 1,\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Alias with URL in Vitest\nDESCRIPTION: This code snippet shows how to configure aliases in the Vitest configuration file using `URL` constructor to resolve the path correctly. Using `URL` ensures that the alias resolves to an absolute path, preventing issues where aliases are treated as relative to the importing file. This configuration maps the `@/` alias to the `./src/` directory.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/common-errors.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    alias: {\n      '@/': new URL('./src/', import.meta.url).pathname, // [!code ++]\n    }\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Enabling Global APIs in Vitest Configuration - TypeScript\nDESCRIPTION: This example shows how to enable global Vitest APIs by setting the globals property to true within the defineConfig call. This allows test APIs like describe and it to be available globally, mimicking Jest-like behavior. Requires vitest/config. Accepts a configuration object with test.globals set to true. Outputs a configuration enabling global APIs for all tests. Note that enabling globals may risk polluting the global namespace in some large projects.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    globals: true,\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Running Vitest Test Suite (Bash)\nDESCRIPTION: This command line instruction executes the Vitest test suite located at `./garden/tasks.test.js`. It utilizes the `vitest` command to run the specified test file. The output will indicate the results of the test execution, including passed, failed, or skipped tests.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/runner.md#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nvitest ./garden/tasks.test.js\n```\n\n----------------------------------------\n\nTITLE: Running Vitest Tests in specific project via yarn\nDESCRIPTION: This snippet demonstrates how to run tests in a specific project within a Vitest workspace using the `--project` CLI option with yarn.  The example targets a project named `e2e`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/workspace.md#_snippet_10\n\nLANGUAGE: Bash\nCODE:\n```\nyarn test --project e2e\n```\n\n----------------------------------------\n\nTITLE: Using assert.nestedProperty in Vitest (TypeScript)\nDESCRIPTION: Demonstrates `assert.nestedProperty`, which asserts that an object has a nested property specified using dot or bracket notation. The example imports from `vitest` and checks for the existence of 'tea.green' within a test.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_62\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.deepPropertyVal', () => { // Note: Test name seems incorrect in original text, likely should be assert.nestedProperty\n  assert.nestedProperty({ tea: { green: 'matcha' } }, 'tea.green')\n})\n```\n\n----------------------------------------\n\nTITLE: Setting Vitest Pool via CLI\nDESCRIPTION: This command line argument shows how to set the test pool option to 'forks' when running Vitest from the command line.  This is an alternative to configuring the pool in the `vitest.config.js` file.  Specifying `--pool=forks` overrides the configuration in the config file, and can be useful for temporary configuration changes.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/common-errors.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nvitest --pool=forks\n```\n\n----------------------------------------\n\nTITLE: Vitest Configuration for Browser Debugging\nDESCRIPTION: This TypeScript configuration sets up Vitest to run in browser mode with debugging enabled. It sets `inspectBrk` to true, disables file parallelism, and configures browser options using Playwright with Chromium.  Requires Vitest and Playwright to be installed.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/debugging.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    inspectBrk: true,\n    fileParallelism: false,\n    browser: {\n      provider: 'playwright',\n      instances: [{ browser: 'chromium' }]\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Using toMatchFileSnapshot() in Vitest (TypeScript)\nDESCRIPTION: This example demonstrates how to use `toMatchFileSnapshot()` to compare a value against the content of a specific file. This is useful for snapshots of formatted content. Dependencies: vitest. Input: none. Output: Comparison against the content of the specified file.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/snapshot.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { expect, it } from 'vitest'\n\nit('render basic', async () => {\n  const result = renderHTML(h('div', { class: 'foo' }))\n  await expect(result).toMatchFileSnapshot('./test/basic.output.html')\n})\n```\n\n----------------------------------------\n\nTITLE: Using assert.notDeepOwnInclude in Vitest (TypeScript)\nDESCRIPTION: Illustrates the usage of `assert.notDeepOwnInclude` in a Vitest test. This method asserts that an object (`haystack`) does not deeply include the own properties of another object (`needle`), ignoring inherited properties. The snippet imports necessary functions from `vitest` and demonstrates the assertion within a test.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_53\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.notDeepOwnInclude', () => {\n  assert.notDeepOwnInclude({ a: { b: 2 } }, { a: { c: 3 } })\n})\n```\n\n----------------------------------------\n\nTITLE: Asserting a Value is a Boolean using Vitest (TypeScript)\nDESCRIPTION: Demonstrates the use of `assert.isBoolean` within a Vitest test to check if a variable holds a boolean value. Imports `assert` and `test` from 'vitest'.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_36\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\nconst isReady = true\n\ntest('assert.isBoolean', () => {\n  assert.isBoolean(isReady, 'isReady is a boolean')\n})\n```\n\n----------------------------------------\n\nTITLE: Checking Constructible Types with Vitest\nDESCRIPTION: This snippet utilizes `toBeConstructibleWith()` to ensure a type can be constructed with given parameters. It imports `expectTypeOf` from 'vitest'. It demonstrates constructing a `Date` object with different arguments.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect-typeof.md#_snippet_27\n\nLANGUAGE: ts\nCODE:\n```\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf(Date).toBeConstructibleWith(new Date())\nexpectTypeOf(Date).toBeConstructibleWith('01-01-2000')\n```\n\n----------------------------------------\n\nTITLE: Configuring Vitest to Use Custom Reporter (TypeScript)\nDESCRIPTION: Provides an example of how to configure the `vitest.config.ts` file to use a custom reporter class. The custom reporter is imported and added to the `reporters` array within the test configuration.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/reporters.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\nimport CustomReporter from './custom-reporter.js'\n\nexport default defineConfig({\n  test: {\n    reporters: [new CustomReporter()],\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Global Type Definitions for Test Context in Vitest\nDESCRIPTION: Example of providing type definitions for custom context properties by extending the TestContext interface globally.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/test-context.md#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare module 'vitest' {\n  export interface TestContext {\n    foo?: string\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing Floating Point Numbers with expect.closeTo in Vitest (JavaScript)\nDESCRIPTION: Illustrates using `expect.closeTo(expected, precision?)` within `toEqual` to compare floating-point numbers inside object properties. It checks if the received number is close to the expected number within a specified decimal precision (defaulting to 2).\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_46\n\nLANGUAGE: javascript\nCODE:\n```\ntest('compare float in object properties', () => {\n  expect({\n    title: '0.1 + 0.2',\n    sum: 0.1 + 0.2,\n  }).toEqual({\n    title: '0.1 + 0.2',\n    sum: expect.closeTo(0.3, 5),\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Example Using injectTestProjects to Add a New Test Project - TypeScript\nDESCRIPTION: Provides an example of using the `injectTestProjects` function to add a single new test project configuration. It demonstrates how to inherit settings from the current project's config file and define custom settings like a unique `name` and `alias` within the `test` property. The function is awaited as it returns a Promise.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/plugin.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// inject a single project with a custom alias\nconst newProjects = await injectTestProjects({\n  // you can inherit the current project config by referencing `configFile`\n  // note that you cannot have a project with the name that already exists,\n  // so it's a good practice to define a custom name\n  configFile: project.vite.config.configFile,\n  test: {\n    name: 'my-custom-alias',\n    alias: {\n      customAlias: resolve('./custom-path.js'),\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Using rejects to Handle Promise Rejection Assertions\nDESCRIPTION: This snippet demonstrates asserting that a promise is rejected with a specific error message or type. It involves calling an async function that throws and awaiting the `rejects` matcher with the expected error details.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_40\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { expect, test } from 'vitest'\n\nasync function buyApples(id) {\n  if (!id) {\n    throw new Error('no id')\n  }\n}\n\ntest('buyApples throws an error when no id provided', async () => {\n  // toThrow returns a promise now, so you HAVE to await it\n  await expect(buyApples()).rejects.toThrow('no id')\n})\n```\n\n----------------------------------------\n\nTITLE: Asserting a Value is Not a Boolean using Vitest (TypeScript)\nDESCRIPTION: Shows how to use `assert.isNotBoolean` in a Vitest test to verify that a variable is not a boolean. Requires `assert` and `test` from 'vitest'.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_37\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\nconst isReady = 'sure'\n\ntest('assert.isBoolean', () => {\n  assert.isBoolean(isReady, 'isReady is not a boolean but string')\n})\n```\n\n----------------------------------------\n\nTITLE: CLI Command for Debugging Vitest (Version >= 1.1)\nDESCRIPTION: This bash command launches Vitest with debugging enabled, disabling file parallelism using `--no-file-parallelism`. Requires Vitest version 1.1 or higher to be installed.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/debugging.md#_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\n# If pool is unknown\nvitest --inspect-brk --no-file-parallelism\n```\n\n----------------------------------------\n\nTITLE: Assert Value is True with Vitest\nDESCRIPTION: This demonstrates `assert.isTrue`, which asserts that a given value is true. It utilizes the `vitest` testing framework. The input is a boolean value and the assertion passes if the value is strictly true.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_13\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\nconst testPassed = true\n\ntest('assert.isTrue', () => {\n  assert.isTrue(testPassed)\n})\n```\n\n----------------------------------------\n\nTITLE: Importing Actual Module with vi.importActual\nDESCRIPTION: This snippet illustrates how to import the actual module using `vi.importActual` within a `vi.mock` factory. This is useful when you want to mock only specific parts of a module while retaining the original implementation of others.  It returns a promise that resolves to the imported module.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nvi.mock('./example.js', async () => {\n  const originalModule = await vi.importActual('./example.js')\n\n  return { ...originalModule, get: vi.fn() }\n})\n```\n\n----------------------------------------\n\nTITLE: Using assert.match in Vitest (TypeScript)\nDESCRIPTION: Shows how to use `assert.match` to assert that a string value matches a given regular expression. The example imports `assert` and `test` from `vitest` and checks if 'foobar' starts with 'foo' using a regex within a test case, providing an optional message.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_54\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.match', () => {\n  assert.match('foobar', /^foo/, 'regexp matches')\n})\n```\n\n----------------------------------------\n\nTITLE: Using assert.notNestedProperty in Vitest (TypeScript)\nDESCRIPTION: Illustrates `assert.notNestedProperty`, used to assert that an object does not have a specific nested property (using dot/bracket notation). The snippet imports from `vitest` and checks for the absence of 'tea.oolong' within a test function.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_63\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.deepPropertyVal', () => { // Note: Test name seems incorrect in original text, likely should be assert.notNestedProperty\n  assert.notNestedProperty({ tea: { green: 'matcha' } }, 'tea.oolong')\n})\n```\n\n----------------------------------------\n\nTITLE: Reusing Mocked Methods with vi.spyOn in Vitest (TypeScript)\nDESCRIPTION: Demonstrates the updated behavior where vi.spyOn reuses an existing mock if the method is already mocked, preventing duplicate spies. Illustrates sequence of spy, mock, restore, and verification steps. Vi.isMockFunction is used to assert the true/false state before and after restoreAllMocks. Dependencies: 'vi.spyOn', 'vi.restoreAllMocks', 'vi.isMockFunction'.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/migration.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nvi.spyOn(fooService, 'foo').mockImplementation(() => 'bar')\nvi.spyOn(fooService, 'foo').mockImplementation(() => 'bar')\nvi.restoreAllMocks()\nvi.isMockFunction(fooService.foo) // true\nvi.isMockFunction(fooService.foo) // false\n```\n\n----------------------------------------\n\nTITLE: Using vi.hoisted for Pre-Import Execution in Vitest (Diff)\nDESCRIPTION: Shows a diff demonstrating the use of `vi.hoisted` in Vitest. Wrapping side-effect code (`callFunctionWithSideEffect()`) in `vi.hoisted` allows it to run before static imports are evaluated, automatically achieving the effect of pre-import execution without manual conversion to dynamic imports.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_33\n\nLANGUAGE: diff\nCODE:\n```\n- callFunctionWithSideEffect()\nimport { value } from './some/module.js'\n+ vi.hoisted(() => callFunctionWithSideEffect())\n```\n\n----------------------------------------\n\nTITLE: Local Type Definitions for Test Context in Vitest\nDESCRIPTION: Example of providing type definitions for custom context properties only for specific test hooks using generics.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/test-context.md#_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\ninterface LocalTestContext {\n  foo: string\n}\n\nbeforeEach<LocalTestContext>(async (context) => {\n  // typeof context is 'TestContext & LocalTestContext'\n  context.foo = 'bar'\n})\n\nit<LocalTestContext>('should work', ({ foo }) => {\n  // typeof foo is 'string'\n  console.log(foo) // 'bar'\n})\n```\n\n----------------------------------------\n\nTITLE: Asserting Element Accessible Description in Vitest Tests (JavaScript)\nDESCRIPTION: Verifies that a DOM element has a specific accessible description, derived from attributes like `title`, `aria-label`, `alt`, `aria-describedby`, or `aria-description`. Useful for accessibility testing to ensure elements are properly described for assistive technologies. Supports exact string match or regular expressions.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_12\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction toHaveAccessibleDescription(description?: string | RegExp): Promise<void>\n```\n\nLANGUAGE: HTML\nCODE:\n```\n<a\n  data-testid=\"link\"\n  href=\"/\"\n  aria-label=\"Home page\"\n  title=\"A link to start over\"\n  >Start</a\n>\n<a data-testid=\"extra-link\" href=\"/about\" aria-label=\"About page\">About</a>\n<img src=\"avatar.jpg\" data-testid=\"avatar\" alt=\"User profile pic\" />\n<img\n  src=\"logo.jpg\"\n  data-testid=\"logo\"\n  alt=\"Company logo\"\n  aria-describedby=\"t1\"\n/>\n<span id=\"t1\" role=\"presentation\">The logo of Our Company</span>\n<img\n  src=\"logo.jpg\"\n  data-testid=\"logo2\"\n  alt=\"Company logo\"\n  aria-description=\"The logo of Our Company\"\n/>\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\nawait expect.element(getByTestId('link')).toHaveAccessibleDescription()\nawait expect.element(getByTestId('link')).toHaveAccessibleDescription('A link to start over')\nawait expect.element(getByTestId('link')).not.toHaveAccessibleDescription('Home page')\nawait expect.element(getByTestId('extra-link')).not.toHaveAccessibleDescription()\nawait expect.element(getByTestId('avatar')).not.toHaveAccessibleDescription()\nawait expect.element(getByTestId('logo')).not.toHaveAccessibleDescription('Company logo')\nawait expect.element(getByTestId('logo')).toHaveAccessibleDescription(\n  'The logo of Our Company',\n)\nawait expect.element(getByTestId('logo2')).toHaveAccessibleDescription(\n  'The logo of Our Company',\n)\n```\n\n----------------------------------------\n\nTITLE: Injecting provided values in tests (test.spec.js)\nDESCRIPTION: This snippet shows how to inject values that have been provided to a test using the `inject` function from Vitest. This allows for dynamic configuration and value injection into test cases.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/test-project.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { inject } from 'vitest'\nconst value = inject('key')\n```\n\n----------------------------------------\n\nTITLE: Setting a Mock to Resolve with mockResolvedValue\nDESCRIPTION: This snippet demonstrates how to configure a mock function to resolve with a specific value using `mockResolvedValue`. TypeScript ensures that the provided value matches the return type of the original function. This is particularly useful for testing asynchronous functions that return promises.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/mock.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nconst asyncMock = vi.fn().mockResolvedValue(42)\n\nawait asyncMock() // 42\n```\n\n----------------------------------------\n\nTITLE: Inspecting Mock Return Values and Errors with mock.results (TypeScript/JavaScript)\nDESCRIPTION: The `mock.results` property is an array containing objects that describe the outcome of each call to the mock function. Each result object has a `type` ('return' or 'throw') and a `value` (the returned value or the thrown error). For functions returning promises, the `type` is always 'return', regardless of promise resolution.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/mock.md#_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\ninterface MockResultReturn<T> {\n  type: 'return'\n  /**\n   * The value that was returned from the function.\n   * If function returned a Promise, then this will be a resolved value.\n   */\n  value: T\n}\n\ninterface MockResultIncomplete {\n  type: 'incomplete'\n  value: undefined\n}\n\ninterface MockResultThrow {\n  type: 'throw'\n  /**\n   * An error that was thrown during function execution.\n   */\n  value: any\n}\n\ntype MockResult<T> =\n  | MockResultReturn<T>\n  | MockResultThrow\n  | MockResultIncomplete\n\nconst results: MockResult<ReturnType<T>>[]\n```\n\nLANGUAGE: javascript\nCODE:\n```\nconst fn = vi.fn()\n  .mockReturnValueOnce('result')\n  .mockImplementationOnce(() => { throw new Error('thrown error') })\n\nconst result = fn() // returned 'result'\n\ntry {\n  fn() // threw Error\n}\ncatch {}\n\nfn.mock.results === [\n  // first result\n  {\n    type: 'return',\n    value: 'result',\n  },\n  // last result\n  {\n    type: 'throw',\n    value: Error,\n  },\n]\n```\n\n----------------------------------------\n\nTITLE: Resetting Spies with mockReset in Vitest using TypeScript\nDESCRIPTION: Shows how the 'mockReset' function on a spy resets the implementation to the original function rather than to a noop, as of Vitest 3.0. Demonstrates spying on a method, replacing its implementation, and restoring it via mockReset. Dependencies: 'vi.spyOn'. Input: object with function property. Output: function returns original result after reset.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/migration.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst foo = {\n  bar: () => 'Hello, world!'\n}\n\nvi.spyOn(foo, 'bar').mockImplementation(() => 'Hello, mock!')\n\nfoo.bar() // 'Hello, mock!'\n\nfoo.bar.mockReset()\n\nfoo.bar() // undefined\nfoo.bar() // 'Hello, world!'\n```\n\n----------------------------------------\n\nTITLE: Asserting Async Promise Rejection Throws Error with Vitest\nDESCRIPTION: Demonstrates how to use `.rejects.toThrowError()` to assert that an asynchronous operation (a promise) rejects with an error when awaited. This is the correct way to test async error throwing in Vitest.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_12\n\nLANGUAGE: ts\nCODE:\n```\ntest('expect rejects toThrow', async ({ expect }) => {\n  const promise = Promise.reject(new Error('Test'))\n  await expect(promise).rejects.toThrowError()\n})\n```\n\n----------------------------------------\n\nTITLE: Testing React Components in Vitest Browser Mode (TSX)\nDESCRIPTION: Shows how to test a React component (`Fetch`) using `vitest-browser-react`. It renders the component, simulates a button click using `screen.getByText().click()`, waits for an element (heading) to appear using `screen.getByRole()`, and then asserts its text content and the button's disabled state.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/index.md#_snippet_17\n\nLANGUAGE: tsx\nCODE:\n```\nimport { render } from 'vitest-browser-react'\nimport Fetch from './fetch'\n\ntest('loads and displays greeting', async () => {\n  // Render a React element into the DOM\n  const screen = render(<Fetch url=\"/greeting\" />)\n\n  await screen.getByText('Load Greeting').click()\n  // wait before throwing an error if it cannot find an element\n  const heading = screen.getByRole('heading')\n\n  // assert that the alert message is correct\n  await expect.element(heading).toHaveTextContent('hello there')\n  await expect.element(screen.getByRole('button')).toBeDisabled()\n})\n```\n\n----------------------------------------\n\nTITLE: Testing Vue Components in Vitest Browser Mode (TypeScript)\nDESCRIPTION: Example of testing a Vue component using `vitest-browser-vue`. It renders the component, finds elements using `screen.getByLabelText` and `screen.getByText`, simulates user input with `fill`, and asserts the component's reactive updates using `expect.element`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/index.md#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport { render } from 'vitest-browser-vue'\nimport Component from './Component.vue'\n\ntest('properly handles v-model', async () => {\n  const screen = render(Component)\n\n  // Asserts initial state.\n  await expect.element(screen.getByText('Hi, my name is Alice')).toBeInTheDocument()\n\n  // Get the input DOM node by querying the associated label.\n  const usernameInput = screen.getByLabelText(/username/i)\n\n  // Type the name into the input. This already validates that the input\n  // is filled correctly, no need to check the value manually.\n  await usernameInput.fill('Bob')\n\n  await expect.element(screen.getByText('Hi, my name is Bob')).toBeInTheDocument()\n})\n```\n\n----------------------------------------\n\nTITLE: Restoring Original Descriptors with mockRestore\nDESCRIPTION: This example showcases `mockRestore`, which resets call history, resets the implementation to its original state, and restores the original descriptors of spied-on objects. This effectively removes the spy. Mocks created with `vi.fn()` will have their implementation set to an empty function.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/mock.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nconst person = {\n  greet: (name: string) => `Hello ${name}`,\n}\nconst spy = vi.spyOn(person, 'greet').mockImplementation(() => 'mocked')\nexpect(person.greet('Alice')).toBe('mocked')\nexpect(spy.mock.calls).toEqual([['Alice']])\n\n// clear call history and restore spied object method\nspy.mockRestore()\nexpect(spy.mock.calls).toEqual([])\nexpect(person.greet).not.toBe(spy)\nexpect(person.greet('Bob')).toBe('Hello Bob')\nexpect(spy.mock.calls).toEqual([])\n```\n\n----------------------------------------\n\nTITLE: Configuring Reporters via vitest.config.ts\nDESCRIPTION: This code snippet shows how to configure the reporters in the `vitest.config.ts` file. It demonstrates how to use an array of reporter names in the `reporters` property within the `test` configuration. This allows for persistent and project-specific reporter settings. This snippet uses the `verbose` reporter.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/reporters.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    reporters: ['verbose']\n  },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Running Vitest Tests with multiple projects via yarn\nDESCRIPTION: This code snippet describes how to run tests for multiple specific projects within a Vitest workspace using the `--project` CLI option in conjunction with yarn. In this example projects `e2e` and `unit` are specified.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/workspace.md#_snippet_11\n\nLANGUAGE: Bash\nCODE:\n```\nyarn test --project e2e --project unit\n```\n\n----------------------------------------\n\nTITLE: Installing jsdom for Browser Mocking using Bash\nDESCRIPTION: This bash snippet shows installation of 'jsdom' as a development dependency. 'jsdom' enables Vitest to mock DOM and browser APIs in a Node.js environment. This should be run before configuring the test environment with 'jsdom' as the target. It must be executed in the project directory.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/features.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ npm i -D jsdom\n\n```\n\n----------------------------------------\n\nTITLE: Disabling Default Reporter Summary\nDESCRIPTION: This snippet demonstrates configuring the `default` reporter with the `summary` option set to `false`. This removes the summary output from the end of the tests in the terminal output. This allows the developer to tailor the output and remove redundant information.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/reporters.md#_snippet_7\n\nLANGUAGE: ts\nCODE:\n```\nexport default defineConfig({\n  test: {\n    reporters: [\n      ['default', { summary: false }]\n    ]\n  },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Enabling TypeScript Definitions for import.meta.vitest\nDESCRIPTION: Configures TypeScript's `tsconfig.json` to include type declarations for `import.meta.vitest` by adding `vitest/importMeta` under `types`. This provides proper typing within source files so that Vitest's testing API is accessible and type-safe. Required for full TypeScript support when writing in-source Vitest tests.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/in-source.md#_snippet_6\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"compilerOptions\": {\n    \"types\": [\n      \"vitest/importMeta\" // [!code ++]\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Vitest Globals to TypeScript Configuration - JSON\nDESCRIPTION: This JSON snippet configures TypeScript to recognize Vitest global APIs by adding 'vitest/globals' to the types list in tsconfig.json. This ensures proper code completion and type checking for global APIs in test files. Add this to the compilerOptions of your project's tsconfig.json. Outputs a correctly typed global test environment. This change affects the TypeScript compilation process, so ensure no typing conflicts with other global declarations.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_9\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"compilerOptions\": {\n    \"types\": [\"vitest/globals\"]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Using toHaveTextContent Matcher in Vitest - TypeScript\nDESCRIPTION: Defines the toHaveTextContent matcher for asserting the text content of elements, text nodes, or fragments. Accepts a string (for partial, case-sensitive match) or RegExp (for flexible, possibly case-insensitive match) as parameters, as well as an options object (normalizeWhitespace). Outputs assertion pass/fail based on text content match. Requires the element to be available in the DOM. Limitation: partial matching for strings, all other custom logic via RegExp.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_24\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction toHaveTextContent(\n  text: string | RegExp,\n  options?: { normalizeWhitespace: boolean }\n): Promise<void>\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst element = getByTestId('text-content')\n\nawait expect.element(element).toHaveTextContent('Content')\n// to match the whole content\nawait expect.element(element).toHaveTextContent(/^Text Content$/)\n// to use case-insensitive match\nawait expect.element(element).toHaveTextContent(/content$/i)\nawait expect.element(element).not.toHaveTextContent('content')\n```\n\n----------------------------------------\n\nTITLE: Configure environmentMatchGlobs - TypeScript\nDESCRIPTION: This snippet demonstrates how to automatically assign environments based on globs using the deprecated `environmentMatchGlobs` option. Tests matching the specified globs will run in the corresponding environment. It shows a config where files under `tests/dom` run in the `jsdom` environment and files ending with `.edge.test.ts` run in `edge-runtime`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_18\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    environmentMatchGlobs: [\n      // all tests in tests/dom will run in jsdom\n      ['tests/dom/**', 'jsdom'],\n      // all tests in tests/ with .edge.test.ts will run in edge-runtime\n      ['**/*.edge.test.ts', 'edge-runtime'],\n      // ...\n    ]\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Image Snapshot with jest-image-snapshot (TypeScript)\nDESCRIPTION: This snippet demonstrates how to use `jest-image-snapshot` with Vitest to create image snapshots. It reads an image file and compares it to a stored snapshot. Dependencies: jest-image-snapshot. Input: Image file path. Output: Comparison against the content of the specified file.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/snapshot.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\ntest('image snapshot', () => {\n  expect(readFileSync('./test/stubs/input-image.png'))\n    .toMatchImageSnapshot()\n})\n```\n\n----------------------------------------\n\nTITLE: Running Vitest from the Command Line (Bash)\nDESCRIPTION: This snippet shows the command for running all tests (including in-source tests) using npx and the Vitest CLI. It assumes that Vitest is installed as a development dependency. No additional arguments are needed for basic operation. All matching files based on configuration will be discovered and executed.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/in-source.md#_snippet_2\n\nLANGUAGE: Bash\nCODE:\n```\n$ npx vitest\n```\n\n----------------------------------------\n\nTITLE: Starting Vitest Tests with UI via Command Line\nDESCRIPTION: This command starts the Vitest tests and enables the UI.  The `--ui` flag instructs Vitest to launch the UI along with the test execution, utilizing the Vite server under the hood.  The tests run in watch mode by default. The output is the test results displayed in the terminal and the UI running in the browser.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/ui.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nvitest --ui\n```\n\n----------------------------------------\n\nTITLE: Defining and Using toHaveFocus Matcher in Vitest - TypeScript\nDESCRIPTION: Defines and uses the toHaveFocus matcher to assert whether an element currently has keyboard focus. Requires a compatible Vitest environment and a DOM API supporting focus/blur. No parameters; acts on the selected element. Used here to simulate focusing and unfocusing an input, and asserting focus state. Output is a pass/fail assertion.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_18\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction toHaveFocus(): Promise<void>\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst input = page.getByTestId('element-to-focus')\ninput.element().focus()\nawait expect.element(input).toHaveFocus()\ninput.element().blur()\nawait expect.element(input).not.toHaveFocus()\n```\n\n----------------------------------------\n\nTITLE: Resetting the Global Test Name Filter Pattern in Vitest (TypeScript)\nDESCRIPTION: Resets the global test name pattern filter, removing any previously set pattern via `setGlobalTestNamePattern`. This allows all tests to run (unless filtered by other means) in subsequent test runs; it doesn't initiate a run itself.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/vitest.md#_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nfunction resetGlobalTestNamePattern(): void\n```\n\n----------------------------------------\n\nTITLE: Returning 'this' Context with mockReturnThis\nDESCRIPTION: This snippet showcases `mockReturnThis`, which sets the mock implementation to return the `this` context. This is a shorthand for `spy.mockImplementation(function () { return this })` and is useful for testing method chaining.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/mock.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nspy.mockImplementation(function () {\n  return this\n})\n```\n\n----------------------------------------\n\nTITLE: Using Custom Vitest Reporters via CLI and TypeScript Configuration\nDESCRIPTION: Demonstrates how to use third-party or user-defined custom reporters in Vitest by specifying the NPM package name or the file path to the reporter implementation. Custom reporters must implement the Reporter interface as defined in Vitest. The snippet shows enabling a published reporter by name and using a local reporter file path through the CLI and config options.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/reporters.md#_snippet_23\n\nLANGUAGE: bash\nCODE:\n```\nnpx vitest --reporter=some-published-vitest-reporter\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport default defineConfig({\n  test: {\n    reporters: [\"some-published-vitest-reporter\"]\n  },\n})\n```\n\nLANGUAGE: bash\nCODE:\n```\nnpx vitest --reporter=./path/to/reporter.ts\n```\n\n----------------------------------------\n\nTITLE: Configuring Test Setup Files in Vite for Vitest and Vue Snapshots with JavaScript\nDESCRIPTION: Demonstrates how to specify test setup files in vite.config.js to support custom setup logic, such as snapshot serializers for Vue components. Requires Vite, Vitest, and the jest-serializer-vue package installed. Input: relative path to setup file; Output: test setup properly configured in Vite/Vitest.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/migration.md#_snippet_16\n\nLANGUAGE: javascript\nCODE:\n```\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  test: {\n    setupFiles: ['./tests/unit/setup.js']\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Asserting Element Contains Another in Vitest Tests (JavaScript)\nDESCRIPTION: Verifies if one DOM element is a descendant of another element. Useful for testing parent-child structural relationships in the rendered DOM. Requires `expect.element` and locator methods like `getByTestId`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_10\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction toContainElement(element: HTMLElement | SVGElement | null): Promise<void>\n```\n\nLANGUAGE: HTML\nCODE:\n```\n<span data-testid=\"ancestor\"><span data-testid=\"descendant\"></span></span>\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst ancestor = getByTestId('ancestor')\nconst descendant = getByTestId('descendant')\nconst nonExistantElement = getByTestId('does-not-exist')\n\nawait expect.element(ancestor).toContainElement(descendant)\nawait expect.element(descendant).not.toContainElement(ancestor)\nawait expect.element(ancestor).not.toContainElement(nonExistantElement)\n```\n\n----------------------------------------\n\nTITLE: Closing Vitest Project Resources\nDESCRIPTION: This TypeScript function closes the Vitest project and all its associated resources, ensuring that the Vite server, typechecker service, browser (if running), and temporary directory are properly shut down and cleaned up. The promise of this operation is cached to prevent repeated calls, and new projects should be created if resources are needed again.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/test-project.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nfunction close(): Promise<void>\n```\n\n----------------------------------------\n\nTITLE: Migrating Custom Types Import in Vitest (TypeScript)\nDESCRIPTION: Illustrates updated import paths for test case types as the 'Custom' type is deprecated in favor of direct imports. Shows the difference between importing RunnerCustomCase and the newer RunnerTestCase from 'vitest'. Requires Vitest 2.1+. Input: none. Output: named imports.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/migration.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport {\n  RunnerCustomCase,\n  RunnerTestCase,\n} from 'vitest'\n```\n\n----------------------------------------\n\nTITLE: Using startVitest to initiate and run Vitest tests in Node.js\nDESCRIPTION: This snippet demonstrates how to import the startVitest function from 'vitest/node', initialize Vitest with specific parameters, and iterate over the test modules to log their results. It requires the 'vitest/node' package and uses async/await for asynchronous execution. The script runs all tests matching the provided filters and configurations.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/guide/tests.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { startVitest } from 'vitest/node'\n\nconst vitest = await startVitest(\n  'test',\n  [], // CLI filters\n  {}, // override test config\n  {}, // override Vite config\n  {}, // custom Vitest options\n)\nconst testModules = vitest.state.getTestModules()\nfor (const testModule of testModules) {\n  console.log(testModule.moduleId, testModule.ok() ? 'passed' : 'failed')\n}\n```\n\n----------------------------------------\n\nTITLE: toBeDisabled Assertion Example\nDESCRIPTION: Demonstrates how to use the toBeDisabled assertion to check if an element is disabled from the user's perspective.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_2\n\nLANGUAGE: html\nCODE:\n```\n<button\n  data-testid=\"button\"\n  type=\"submit\"\n  disabled\n>\n  submit\n</button>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nawait expect.element(getByTestId('button')).toBeDisabled() // ✅\nawait expect.element(getByTestId('button')).not.toBeDisabled() // ❌\n```\n\n----------------------------------------\n\nTITLE: Implementing a Basic Web Worker (TypeScript)\nDESCRIPTION: Provides an example of a simple Web Worker implementation in a TypeScript file (`worker.ts`). It uses `self.onmessage` to define a handler that listens for incoming messages and `self.postMessage` to send a modified message back to the main thread.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/web-worker/README.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// worker.ts\nself.onmessage = (e) => {\n  self.postMessage(`${e.data} world`)\n}\n```\n\n----------------------------------------\n\nTITLE: Running UI in Development Mode (Vitest)\nDESCRIPTION: This command starts the Vitest UI in development mode, allowing developers to work on the UI and see changes in real-time.  It relies on the `nr` command, which is likely a shorthand for a Node.js package manager script (e.g., npm run or yarn).\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/ui/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnr ui:dev\n```\n\n----------------------------------------\n\nTITLE: Type Definitions for Custom Fixtures in Vitest\nDESCRIPTION: Example of providing type definitions for custom fixtures by using generics with test.extend.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/test-context.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\ninterface MyFixtures {\n  todos: number[]\n  archive: number[]\n}\n\nconst myTest = test.extend<MyFixtures>({\n  todos: [],\n  archive: []\n})\n\nmyTest('types are defined correctly', ({ todos, archive }) => {\n  expectTypeOf(todos).toEqualTypeOf<number[]>()\n  expectTypeOf(archive).toEqualTypeOf<number[]>()\n})\n```\n\n----------------------------------------\n\nTITLE: Running Vitest Tests with multiple projects via pnpm\nDESCRIPTION: This code snippet describes how to run tests for multiple specific projects within a Vitest workspace using the `--project` CLI option in conjunction with pnpm. In this example projects `e2e` and `unit` are specified.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/workspace.md#_snippet_14\n\nLANGUAGE: Bash\nCODE:\n```\npnpm run test --project e2e --project unit\n```\n\n----------------------------------------\n\nTITLE: Asserting Array Types with Vitest in TypeScript\nDESCRIPTION: Applies `.toBeArray` matcher to check if the provided type is an array. Requires Vitest and works with array literals or initializers. Prevents type errors where array structures are expected.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect-typeof.md#_snippet_18\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf(42).not.toBeArray()\nexpectTypeOf([]).toBeArray()\nexpectTypeOf([1, 2]).toBeArray()\nexpectTypeOf([{}, 42]).toBeArray()\n```\n\n----------------------------------------\n\nTITLE: Asserting Element Contains HTML String in Vitest Tests (JavaScript)\nDESCRIPTION: Checks if a DOM element's inner HTML contains a specific, valid HTML string. This matcher is often discouraged for testing internal DOM structure you control, preferring `toContainElement`. Dependencies include `expect.element` and locator methods like `getByTestId`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_11\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction toContainHTML(htmlText: string): Promise<void>\n```\n\nLANGUAGE: HTML\nCODE:\n```\n<span data-testid=\"parent\"><span data-testid=\"child\"></span></span>\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\n// These are valid usages\nawait expect.element(getByTestId('parent')).toContainHTML('<span data-testid=\"child\"></span>')\nawait expect.element(getByTestId('parent')).toContainHTML('<span data-testid=\"child\" />')\nawait expect.element(getByTestId('parent')).not.toContainHTML('<br />')\n\n// These won't work\nawait expect.element(getByTestId('parent')).toContainHTML('data-testid=\"child\"')\nawait expect.element(getByTestId('parent')).toContainHTML('data-testid')\nawait expect.element(getByTestId('parent')).toContainHTML('</span>')\n```\n\n----------------------------------------\n\nTITLE: Implementing onTestRunEnd Lifecycle Hook in Vitest Reporter with TypeScript\nDESCRIPTION: Provides an example of implementing the onTestRunEnd method to handle various test run end scenarios including passed, failed, and interrupted states. Demonstrates iterating over testModules and unhandled errors to log results and errors from failed tests. Requires importing Vitest node types for Reporter, SerializedError, TestModule, TestRunEndReason, and TestSpecification. Enables detailed reporting and error inspection post test execution.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/reporters.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type {\n  Reporter,\n  SerializedError,\n  TestModule,\n  TestRunEndReason,\n  TestSpecification\n} from 'vitest/node'\n\nclass MyReporter implements Reporter {\n  onTestRunEnd(\n    testModules: ReadonlyArray<TestModule>,\n    unhandledErrors: ReadonlyArray<SerializedError>,\n    reason: TestRunEndReason,\n  ) {\n    if (reason === 'passed') {\n      testModules.forEach(module => console.log(module.moduleId, 'succeeded'))\n    }\n    else if (reason === 'failed') {\n      // note that this will skip possible errors in suites\n      // you can get them from testSuite.errors()\n      for (const testCase of testModules.children.allTests()) {\n        if (testCase.result().state === 'failed') {\n          console.log(testCase.fullName, 'in', testCase.module.moduleId, 'failed')\n          console.log(testCase.result().errors)\n        }\n      }\n    }\n    else {\n      console.log('test run was interrupted, skipping report')\n    }\n  }\n}\n\nexport default new MyReporter()\n```\n\n----------------------------------------\n\nTITLE: Configuring Vitest Coverage Reporters (TypeScript)\nDESCRIPTION: Shows how to configure the output formats for the coverage report by specifying an array of reporter names in the `test.coverage.reporter` option within `vitest.config.ts`. Common reporters include 'text', 'json', 'html'.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/coverage.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    coverage: {\n      reporter: ['text', 'json', 'html'],\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Asserting ARIA Role Presence on Elements with Vitest - TypeScript\nDESCRIPTION: The `toHaveRole` function asserts asynchronously that an element has a specific ARIA role, either explicit via `role` attribute or implicit through HTML semantics. It is useful for accessibility validation. The role must match exactly as a string without inheritance, and only the first valid custom role is considered. The snippet includes sample HTML with various role usages and test examples asserting roles of elements.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_37\n\nLANGUAGE: ts\nCODE:\n```\nfunction toHaveRole(role: ARIARole): Promise<void>\n```\n\n----------------------------------------\n\nTITLE: Setting Coverage Thresholds in Vitest (TS)\nDESCRIPTION: This snippet demonstrates how to configure coverage thresholds in Vitest using TypeScript syntax. It shows how to set thresholds for functions and lines, using both percentage and uncovered item limits. These thresholds are used to determine if the test suite passes or fails based on coverage metrics.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_27\n\nLANGUAGE: ts\nCODE:\n```\n{\n  coverage: {\n    thresholds: {\n      // Requires 90% function coverage\n      functions: 90,\n\n      // Require that no more than 10 lines are uncovered\n      lines: -10,\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Assert Non-Deep Equality with Vitest\nDESCRIPTION: This snippet shows `assert.notDeepEqual`, which asserts that two objects are not deeply equal. It uses the `vitest` testing framework. It takes two objects as input, and asserts that they are not deeply equal. The test passes if their properties and values (recursively) differ.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.notDeepEqual', () => {\n  assert.notDeepEqual({ color: 'green' }, { color: 'red' })\n})\n```\n\n----------------------------------------\n\nTITLE: Extending Root Config for Workspace Projects\nDESCRIPTION: This snippet demonstrates how to inherit options from the root-level configuration in a Vitest workspace. It utilizes the `extends` option within the workspace configuration and shows examples of inheriting plugins like react and how to control options inheritance.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/workspace.md#_snippet_19\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\nimport react from '@vitejs/plugin-react'\n\nexport default defineConfig({\n  plugins: [react()],\n  test: {\n    pool: 'threads',\n    workspace: [\n      {\n        // will inherit options from this config like plugins and pool\n        extends: true,\n        test: {\n          name: 'unit',\n          include: ['**/*.unit.test.ts'],\n        },\n      },\n      {\n        // won't inherit any options from this config\n        // this is the default behaviour\n        extends: false,\n        test: {\n          name: 'integration',\n          include: ['**/*.integration.test.ts'],\n        },\n      },\n    ],\n  },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Running Vitest Tests in specific project via bun\nDESCRIPTION: This snippet demonstrates how to run tests in a specific project within a Vitest workspace using the `--project` CLI option with bun.  The example targets a project named `e2e`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/workspace.md#_snippet_16\n\nLANGUAGE: Bash\nCODE:\n```\nbun run test --project e2e\n```\n\n----------------------------------------\n\nTITLE: Asserting Spy Function Was Called Exactly Once With Specific Arguments in Vitest\nDESCRIPTION: Explains the use of `.toHaveBeenCalledExactlyOnceWith()` to verify that a spy function was called only one time throughout the test and with precisely the specified arguments. Requires a spy function.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_25\n\nLANGUAGE: ts\nCODE:\n```\nimport { expect, test, vi } from 'vitest'\n\nconst market = {\n  buy(subject: string, amount: number) {\n    // ...\n  },\n}\n\ntest('spy function', () => {\n  const buySpy = vi.spyOn(market, 'buy')\n\n  market.buy('apples', 10)\n\n  expect(buySpy).toHaveBeenCalledExactlyOnceWith('apples', 10)\n})\n```\n\n----------------------------------------\n\nTITLE: Saving and Comparing Benchmark Results with Vitest Bench - Shell\nDESCRIPTION: This shell script demonstrates how to use Vitest's bench command to save benchmark results to a JSON file and later compare them. It saves current benchmark results in one branch and compares them after checking out a different branch. Requires Vitest CLI, git, and a working test suite with benchmarks. Inputs are shell commands executed in sequence; outputs are JSON result files for comparison. Keep in mind that output file paths should be valid and you must run these commands from the project's root directory.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_11\n\nLANGUAGE: sh\nCODE:\n```\n# save main branch's result\ngit checkout main\nvitest bench --outputJson main.json\n\n# change a branch and compare against main\ngit checkout feature\nvitest bench --compare main.json\n```\n\n----------------------------------------\n\nTITLE: Configuring Vite Node Execution Debugging Programmatically (JavaScript)\nDESCRIPTION: Shows how to enable execution debugging programmatically when creating a `ViteNodeRunner` instance by setting the `debug` option to `true`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/vite-node/README.md#_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\nimport { ViteNodeRunner } from 'vite-node/client'\n\nconst runner = new ViteNodeRunner({\n  debug: true,\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Global Web Worker Support in Vitest (TypeScript)\nDESCRIPTION: Shows how to configure global Web Worker support in Vitest by adding '@vitest/web-worker' to the `setupFiles` array within the `vitest.config.ts` file using `defineConfig`. This ensures the worker simulation environment is available in all test suites.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/web-worker/README.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig } from 'vitest/node'\n\nexport default defineConfig({\n  test: {\n    setupFiles: ['@vitest/web-worker'],\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Regular Snapshot Assertion\nDESCRIPTION: Performs a regular snapshot assertion by calling `client.assert` with `isInline: false`. The `received` value is compared to the existing snapshot, and a new snapshot is created if one doesn't exist. The snapshot is saved to a file determined by the `snapshotEnvironment.resolvePath` function.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/snapshot/README.md#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n// this will save snapshot to a file which is returned by \"snapshotEnvironment.resolvePath\"\nclient.assert({\n  received: 'some text',\n  isInline: false,\n})\n```\n\n----------------------------------------\n\nTITLE: Migrating Jest Mock Type Imports to Vitest with TypeScript\nDESCRIPTION: Illustrates replacing Jest's global namespace mock typing with explicit type imports from Vitest. This aids type safety and avoids namespace conflicts. Requires Vitest installed and TypeScript. Input: function type signatures; Output: properly imported and typed mock variables.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/migration.md#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nlet fn: jest.Mock<(name: string) => number> // [!code --]\nimport type { Mock } from 'vitest' // [!code ++]\nlet fn: Mock<(name: string) => number> // [!code ++]\n```\n\n----------------------------------------\n\nTITLE: Configuring actionTimeout\nDESCRIPTION: Shows an example of how to set the action timeout and override it per action.  The default timeout is no timeout, while previously it was 1 second.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/playwright.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { page, userEvent } from '@vitest/browser/context'\n\nawait userEvent.click(page.getByRole('button'), {\n  timeout: 1_000,\n})\n```\n\n----------------------------------------\n\nTITLE: Merging Vitest Config with Vite Config (Function)\nDESCRIPTION: This snippet demonstrates how to merge a Vitest configuration with a Vite configuration that is defined as a function. It uses `mergeConfig` and `defineConfig` from `vitest/config` and passes the `configEnv` to the Vite config function. This allows conditional configuration of Vite, ensuring it's correctly merged with the Vitest config. This approach enables reusing existing Vite configurations while adding specific settings for testing, when the vite config is defined as a function.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig, mergeConfig } from 'vitest/config'\nimport viteConfig from './vite.config'\n\nexport default defineConfig(configEnv => mergeConfig(\n  viteConfig(configEnv),\n  defineConfig({\n    test: {\n      exclude: ['packages/template/*'],\n    },\n  })\n))\n```\n\n----------------------------------------\n\nTITLE: Defining Vite and Vitest Plugin with configureVitest Hook - TypeScript\nDESCRIPTION: Defines a plugin compatible with both Vite and Vitest by importing the `Plugin` type from `vite`. It includes a `/// <reference types=\"vitest/config\" />` comment to ensure the `configureVitest` property is correctly augmented. The plugin object contains standard Vite hooks like `transform` and the Vitest-specific `configureVitest` hook.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/plugin.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n/// <reference types=\"vitest/config\" />\n\nimport type { Plugin } from 'vite'\n\nexport function plugin(): Plugin {\n  return {\n    name: 'vitest:my-plugin',\n    transform() {\n      // ...\n    },\n    configureVitest(context) {\n      // ...\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Set test environment using docblock (JSDOM) - JavaScript\nDESCRIPTION: This snippet demonstrates how to specify the test environment for a single file using a JSDoc-style docblock.  It sets the environment to jsdom, allowing tests to interact with a DOM-like environment. The test then creates a div element to verify that the jsdom environment is working correctly. Requires the vitest test framework.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_12\n\nLANGUAGE: JavaScript\nCODE:\n```\n/**\n * @vitest-environment jsdom\n */\n\ntest('use jsdom in this test file', () => {\n  const element = document.createElement('div')\n  expect(element).not.toBeNull()\n})\n```\n\n----------------------------------------\n\nTITLE: Object Property Change Assertion (TypeScript)\nDESCRIPTION: Defines `assert.changes` to verify that executing a modifier function alters a specified property of an object.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_100\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\n test('assert.changes', () => {\n  const obj = { val: 10 }\n  function fn() { obj.val = 22 };\n  assert.changes(fn, obj, 'val')\n})\n```\n\n----------------------------------------\n\nTITLE: toBeInTheDocument Assertion Example\nDESCRIPTION: Demonstrates how to use the toBeInTheDocument assertion to check if an element is present in the document.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_5\n\nLANGUAGE: html\nCODE:\n```\n<svg data-testid=\"svg-element\"></svg>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nawait expect.element(getByTestId('svg-element')).toBeInTheDocument()\nawait expect.element(getByTestId('does-not-exist')).not.toBeInTheDocument()\n```\n\n----------------------------------------\n\nTITLE: Asserting Numeric Property Increases By Specific Value with Vitest - TypeScript\nDESCRIPTION: This snippet checks that a modifier function increases a numeric property or its return value by exactly a given amount. It uses the Vitest assert utility with parameters for the modifier, target object, property, change amount, and optional message. Ideal when the precise value of the change is important for program correctness.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_105\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.increasesBy', () => {\n  const obj = { val: 10 }\n  function fn() { obj.val += 10 };\n  assert.increasesBy(fn, obj, 'val', 10)\n})\n```\n\n----------------------------------------\n\nTITLE: Setting One-Time Rejection with mockRejectedValueOnce\nDESCRIPTION: This example shows how to use `mockRejectedValueOnce` to make a mock function reject only on its next call. Subsequent calls will resolve or reject according to other configurations. If chained, each consecutive call will reject the specified value.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/mock.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst asyncMock = vi\n  .fn()\n  .mockResolvedValueOnce('first call')\n  .mockRejectedValueOnce(new Error('Async error'))\n\nawait asyncMock() // 'first call'\nawait asyncMock() // throws Error<'Async error'>\n```\n\n----------------------------------------\n\nTITLE: Extending Matchers with expect.extend (TypeScript)\nDESCRIPTION: Extends Vitest's default matchers with a custom matcher `toBeFoo`. It checks if the received value is equal to 'foo' and returns a message indicating whether the received value is or is not 'foo'. The `isNot` property is used to determine if the matcher was called with `.not`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/extending-matchers.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexpect.extend({\n  toBeFoo(received, expected) {\n    const { isNot } = this\n    return {\n      // do not alter your \"pass\" based on isNot. Vitest does it for you\n      pass: received === 'foo',\n      message: () => `${received} is${isNot ? ' not' : ''} foo`\n    }\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Defining unimplemented suites and tests with .todo in Vitest\nDESCRIPTION: This snippet shows how to create placeholders for suites and tests not yet implemented using `.todo`, which appear in reports and remind developers of pending work.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/filtering.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { describe, it } from 'vitest'\n\ndescribe.todo('unimplemented suite')\n\n// Placeholder for an unimplemented test\n\ndescribe('suite', () => {\n  it.todo('unimplemented test')\n})\n```\n\n----------------------------------------\n\nTITLE: Asserting Numeric Property Decreases By Specific Value with Vitest - TypeScript\nDESCRIPTION: Checks that a modifier decreases a numeric object's property (or its return value) by a specific amount using Vitest assertions. Input parameters are the modifier, object, property, expected decrease, and optional message. Use for guaranteeing decrement by a defined value.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_109\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.decreasesBy', () => {\n  const obj = { val: 10 }\n  function fn() { obj.val -= 5 };\n  assert.decreasesBy(fn, obj, 'val', 5)\n})\n```\n\n----------------------------------------\n\nTITLE: Passing Options to Vite Node CLI (Bash)\nDESCRIPTION: Demonstrates passing configuration options to `vite-node` via the command line using dot syntax. This example shows how to configure dependency inlining and externalization, including specifying regular expressions (enclosed in slashes).\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/vite-node/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpx vite-node --options.deps.inline=\"module-name\" --options.deps.external=\"/module-regexp/\" index.ts\n```\n\n----------------------------------------\n\nTITLE: Using Basic Reporter - CLI\nDESCRIPTION: This snippet shows how to use the 'basic' reporter using the command line. It utilizes the `--reporter=basic` option when running vitest.  The basic reporter offers the same functionality as the default reporter without displaying the test summary.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/reporters.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nnpx vitest --reporter=basic\n```\n\n----------------------------------------\n\nTITLE: Extending BaseReporter for Custom Logic (TypeScript)\nDESCRIPTION: Shows how to create a custom reporter class by extending the `BaseReporter`. This provides a base class with common utilities and lifecycle methods that can be overridden to implement specific reporting behavior.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/reporters.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { BaseReporter } from 'vitest/reporters'\n\nexport default class CustomReporter extends BaseReporter {\n  onCollected() {\n    const files = this.ctx.state.getFiles(this.watchFilters)\n    this.reportTestSummary(files)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Executing All Pending Fake Timers with Vitest vi.runAllTimers in TypeScript\nDESCRIPTION: Demonstrates `vi.runAllTimers`, which synchronously executes all currently scheduled timers (like `setTimeout` and `setInterval`) until the timer queue is empty. This includes timers scheduled by other timers during the execution. Requires `vi` from `vitest` and enabling fake timers. Be cautious with infinite intervals.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_24\n\nLANGUAGE: ts\nCODE:\n```\nlet i = 0\nsetTimeout(() => console.log(++i))\nconst interval = setInterval(() => {\n  console.log(++i)\n  if (i === 3) {\n    clearInterval(interval)\n  }\n}, 50)\n\nvi.runAllTimers()\n\n// log: 1\n// log: 2\n// log: 3\n```\n\n----------------------------------------\n\nTITLE: Modifying Vitest Global Configuration within Plugin - TypeScript\nDESCRIPTION: Demonstrates how to access and mutate the global Vitest configuration object via the `vitest.config` property available in the `configureVitest` context. This allows plugins to dynamically enable/disable features like coverage or add custom reporters before Vitest fully initializes.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/plugin.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nvitest.config.coverage.enabled = false\nvitest.config.reporters.push([['my-reporter', {}]])\n```\n\n----------------------------------------\n\nTITLE: Set test environment using comment (Happy DOM) - JavaScript\nDESCRIPTION: This snippet demonstrates specifying the test environment using a comment.  It sets the environment to happy-dom, another browser-like environment. The test creates a div element to verify the environment is set up correctly.  Requires the vitest testing framework.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_13\n\nLANGUAGE: JavaScript\nCODE:\n```\n// @vitest-environment happy-dom\n\ntest('use happy-dom in this test file', () => {\n  const element = document.createElement('div')\n  expect(element).not.toBeNull()\n})\n```\n\n----------------------------------------\n\nTITLE: Locating elements by label text with `getByLabelText` in Vitest (TS)\nDESCRIPTION: This snippet demonstrates how to locate elements associated with a label using the `getByLabelText` method in Vitest. Requires the Vitest environment to be configured for browser mode testing. Returns a Locator object.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nfunction getByLabelText(\n  text: string | RegExp,\n  options?: LocatorOptions,\n): Locator\n```\n\n----------------------------------------\n\nTITLE: Providing custom values to tests (Node.js)\nDESCRIPTION: This code demonstrates how to provide custom values to tests using the `provide` method. These values are accessible within the tests using the `inject` function. The provided values are validated with `structuredClone`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/test-project.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createVitest } from 'vitest/node'\n\nconst vitest = await createVitest('test')\nconst project = vitest.projects.find(p => p.name === 'custom')\nproject.provide('key', 'value')\nawait vitest.start()\n```\n\n----------------------------------------\n\nTITLE: Wrapping Dynamic Imports with dynamicImportPlugin - TypeScript\nDESCRIPTION: Integrates dynamicImportPlugin into the Vite server, wrapping all dynamic imports using the specified global accessor. Requires @vitest/mocker/node and explicit configuration of globalThisAccessor if custom injection is needed. Intended to coordinate mock resolution before code modules are loaded via dynamic import.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/mocker/EXPORTS.md#_snippet_14\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { dynamicImportPlugin } from '@vitest/mocker/node'\nimport { createServer } from 'vite'\n\nawait createServer({\n  plugins: [\n    dynamicImportPlugin({\n      globalThisAccessor: 'Symbol.for(\"my-mocker\")'\n    }),\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Using expect.element with Locators\nDESCRIPTION: Demonstrates how to use expect.element with Playwright locators to create retry-able assertions in browser tests.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { expect, test } from 'vitest'\nimport { page } from '@vitest/browser/context'\n\ntest('error banner is rendered', async () => {\n  triggerError()\n\n  // This creates a locator that will try to find the element\n  // when any of its methods are called.\n  // This call by itself doesn't check the existence of the element.\n  const banner = page.getByRole('alert', {\n    name: /error/i,\n  })\n\n  // Vitest provides `expect.element` with built-in retry-ability\n  // It will repeatedly check that the element exists in the DOM and that\n  // the content of `element.textContent` is equal to \"Error!\"\n  // until all the conditions are met\n  await expect.element(banner).toHaveTextContent('Error!')\n})\n```\n\n----------------------------------------\n\nTITLE: Resetting Modules in Vitest Setup File\nDESCRIPTION: This code demonstrates how to reset modules in a Vitest setup file to avoid conflicts when mocking modules with `vi.mock`.  `vi.resetModules()` clears the module cache, ensuring that subsequent `vi.mock` calls are effective. It prevents the \"Cannot mock because it is already loaded\" error. It's important to note that setup file and test files will reference different modules in this case.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/common-errors.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { vi } from 'vitest'\nimport { sideEffect } from './mocked-file.js'\n\nsideEffect()\n\nvi.resetModules()\n```\n\n----------------------------------------\n\nTITLE: Extending Context in beforeEach and afterEach Hooks in Vitest\nDESCRIPTION: Example of accessing and extending the test context within beforeEach and afterEach hooks to add custom properties.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/test-context.md#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport { beforeEach, it } from 'vitest'\n\nbeforeEach(async (context) => {\n  // extend context\n  context.foo = 'bar'\n})\n\nit('should work', ({ foo }) => {\n  console.log(foo) // 'bar'\n})\n```\n\n----------------------------------------\n\nTITLE: Ignoring Code with V8 Comments (TypeScript)\nDESCRIPTION: Example demonstrating the use of V8 ignore comments like `/* v8 ignore next 3 */` in TypeScript code. These comments are correctly preserved by `esbuild` and tell the V8 provider to exclude the specified number of lines from coverage analysis.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/coverage.md#_snippet_11\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* v8 ignore next 3 */\nif (condition) {\n```\n\n----------------------------------------\n\nTITLE: Defining the Meta Method for TestModule (TypeScript)\nDESCRIPTION: Shows the method signature for meta, which returns custom TaskMeta information attached to a module during execution or collection. No dependencies are required, but TaskMeta is a presumed type defined elsewhere in Vitest. Used to extract metadata assigned at runtime or during test collection, and can be leveraged in custom reporters or hooks.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/test-module.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nfunction meta(): TaskMeta\n```\n\n----------------------------------------\n\nTITLE: Asserting Boolean Types with Vitest in TypeScript\nDESCRIPTION: Applies `.toBeBoolean` matcher to enforce that a type is boolean. Requires Vitest and is suitable for boolean literals, variables, or generic type assertions. Ensures logic expecting boolean types receives correct typings.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect-typeof.md#_snippet_20\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf(42).not.toBeBoolean()\nexpectTypeOf(true).toBeBoolean()\nexpectTypeOf<boolean>().toBeBoolean()\n```\n\n----------------------------------------\n\nTITLE: Matching Value Against Inline Snapshot in Vitest\nDESCRIPTION: Illustrates using `.toMatchInlineSnapshot()` to compare a value against a snapshot string embedded directly within the test file. Vitest adds or updates this string when snapshots are created or updated.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_17\n\nLANGUAGE: ts\nCODE:\n```\nimport { expect, test } from 'vitest'\n\ntest('matches inline snapshot', () => {\n  const data = { foo: new Set(['bar', 'snapshot']) }\n  // Vitest will update following content when updating the snapshot\n  expect(data).toMatchInlineSnapshot(`\n    {\n      \"foo\": Set {\n        \"bar\",\n        \"snapshot\",\n      },\n    }\n  `)\n})\n```\n\n----------------------------------------\n\nTITLE: Asserting Element Visibility in Vitest Tests (JavaScript)\nDESCRIPTION: Checks if a DOM element is considered visible to the user based on its bounding box, display style, and visibility style. Useful for verifying that UI elements are rendered and interactable. Requires `expect.element` and locator methods like `page.getByText` or `page.getByTestId`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction toBeVisible(): Promise<void>\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\n// A specific element is visible.\nawait expect.element(page.getByText('Welcome')).toBeVisible()\n\n// At least one item in the list is visible.\nawait expect.element(page.getByTestId('todo-item').first()).toBeVisible()\n\n// At least one of the two elements is visible, possibly both.\nawait expect.element(\n  page.getByRole('button', { name: 'Sign in' })\n    .or(page.getByRole('button', { name: 'Sign up' }))\n    .first()\n).toBeVisible()\n```\n\n----------------------------------------\n\nTITLE: Customizing JUnit Reporter\nDESCRIPTION: This snippet demonstrates configuring the `junit` reporter with custom options, `suiteName` and `classnameTemplate`, within the `vitest.config.ts` file.  This allows for more detailed control over the output, allowing customization of the report to better integrate with other tools. The `suiteName` option sets a custom name for the test suite, and `classnameTemplate` customizes the name of the classes in the report.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/reporters.md#_snippet_14\n\nLANGUAGE: ts\nCODE:\n```\nexport default defineConfig({\n  test: {\n    reporters: [\n      ['junit', { suiteName: 'custom suite name', classnameTemplate: 'filename:{filename} - filepath:{filepath}' }]\n    ]\n  },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Vitest Coverage Provider (TypeScript)\nDESCRIPTION: Demonstrates how to specify the desired code coverage provider (v8 or istanbul) in the Vitest configuration file using the `test.coverage.provider` option. Requires the corresponding provider package to be installed.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/coverage.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    coverage: {\n      provider: 'istanbul' // or 'v8'\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Browser Mode in Vitest with Playwright Provider - TypeScript\nDESCRIPTION: Configuration example to enable browser mode in Vitest using Playwright as the browser provider. It specifies the browser instance to be launched (like chromium) and enables the feature via the `test.browser` field in the Vitest config. This setup supports running tests inside real browsers during development or CI.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/index.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\nexport default defineConfig({\n  test: {\n    browser: {\n      provider: 'playwright', // or 'webdriverio'\n      enabled: true,\n      // at least one instance is required\n      instances: [\n        { browser: 'chromium' },\n      ],\n    },\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Running Vitest Tests via npm\nDESCRIPTION: This code snippet outlines how to run tests within a Vitest workspace using the npm package manager.  It includes options for running all tests and only tests inside of a single project.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/workspace.md#_snippet_6\n\nLANGUAGE: Bash\nCODE:\n```\nnpm run test\n```\n\n----------------------------------------\n\nTITLE: Configuring Sequential Hooks in Vitest with TypeScript\nDESCRIPTION: Shows how to configure Vitest to run hooks sequentially, matching Jest's default behavior. This requires exporting a configuration object with the test.sequence.hooks property set to 'list'. Requires Vitest project setup. Input: none; Output: updated Vitest configuration file.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/migration.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nexport default defineConfig({\n  test: {\n    sequence: { // [!code ++]\n      hooks: 'list', // [!code ++]\n    } // [!code ++]\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Cancelling the Current Test Run in Vitest (TypeScript)\nDESCRIPTION: Gracefully cancels the currently executing test run. It waits for already started tests to finish but prevents tests that haven't started yet from running. Takes a `CancelReason` parameter and returns a Promise that resolves when cancellation is complete.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/vitest.md#_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nfunction cancelCurrentRun(reason: CancelReason): Promise<void>\n```\n\n----------------------------------------\n\nTITLE: click Method - Simulate User Click on Element\nDESCRIPTION: Performs a click action on the targeted element, with optional configuration for event parameters such as cursor position. Useful for simulating user interactions during tests.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_30\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction click(options?: UserEventClickOptions): Promise<void>\n```\n\n----------------------------------------\n\nTITLE: Configuring WebdriverIO Types in tsconfig.json\nDESCRIPTION: Updates the `compilerOptions.types` array in the `tsconfig.json` file to explicitly include the type definitions for Vitest's WebdriverIO provider. Adding specific types here disables the default auto-loading of `@types/*` packages.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/webdriverio.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"compilerOptions\": {\n    \"types\": [\"@vitest/browser/providers/webdriverio\"]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring TypeScript Types in tsconfig.json\nDESCRIPTION: This snippet demonstrates how to configure the `compilerOptions.types` field in your `tsconfig.json` file to include the Playwright provider types. Specifying anything in this field disables auto-loading of `@types/*` packages.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/playwright.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"compilerOptions\": {\n    \"types\": [\"@vitest/browser/providers/playwright\"]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Collecting Tests without Execution in Vitest (TypeScript)\nDESCRIPTION: Executes test files based on optional filters to discover tests without running their callback functions. Returns a Promise resolving to a `TestRunResult` containing unhandled errors and an array of test modules. This method can be slow as it runs each test file in isolation unless isolation is disabled.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/vitest.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nfunction collect(filters?: string[]): Promise<TestRunResult>\n```\n\n----------------------------------------\n\nTITLE: Asserting Numeric Comparison with Vitest in TypeScript\nDESCRIPTION: Matchers such as `toBeGreaterThan`, `toBeGreaterThanOrEqual`, `toBeLessThan`, and `toBeLessThanOrEqual` test numeric comparisons between actual and expected values. Inputs are numbers or bigints, outputs are assertion results. Requires Vitest's `expect` and `test`. Equal values fail `toBeGreaterThan` and `toBeLessThan` tests but pass or not fail inclusive tests.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { expect, test } from 'vitest'\nimport { getApples } from './stocks.js'\n\ntest('have more then 10 apples', () => {\n  expect(getApples()).toBeGreaterThan(10)\n})\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { expect, test } from 'vitest'\nimport { getApples } from './stocks.js'\n\ntest('have 11 apples or more', () => {\n  expect(getApples()).toBeGreaterThanOrEqual(11)\n})\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { expect, test } from 'vitest'\nimport { getApples } from './stocks.js'\n\ntest('have less then 20 apples', () => {\n  expect(getApples()).toBeLessThan(20)\n})\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { expect, test } from 'vitest'\nimport { getApples } from './stocks.js'\n\ntest('have 11 apples or less', () => {\n  expect(getApples()).toBeLessThanOrEqual(11)\n})\n```\n\n----------------------------------------\n\nTITLE: Defining the State Method for TestModule (TypeScript)\nDESCRIPTION: Presents the function signature for the state method, allowing retrieval of a TestModule's execution state. The function returns a TestModuleState (type alias/interface), similar to testSuite.state(), but can additionally return 'queued' for unexecuted modules. Used to monitor or branch logic based on module execution progress. Requires context: must be called on a TestModule instance.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/test-module.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nfunction state(): TestModuleState\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Coverage Reporters in Vitest (TS)\nDESCRIPTION: This snippet illustrates how to use custom coverage reporters in Vitest. It demonstrates specifying reporters using NPM package names and local paths, including options for each. Ensure the custom reporter is correctly implemented and accessible in the project.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_26\n\nLANGUAGE: ts\nCODE:\n```\n{\n  reporter: [\n    // Specify reporter using name of the NPM package\n    '@vitest/custom-coverage-reporter',\n    ['@vitest/custom-coverage-reporter', { someOption: true }],\n\n    // Specify reporter using local path\n    '/absolute/path/to/custom-reporter.cjs',\n    ['/absolute/path/to/custom-reporter.cjs', { someOption: true }],\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Asynchronous Code with Vitest Using Done Callback in JavaScript\nDESCRIPTION: This snippet demonstrates how to write an asynchronous test case using Vitest by providing a done callback parameter to the test function. The done callback is called manually when the asynchronous operations complete, signaling the framework to end the test. Dependencies include Vitest configured in a JavaScript environment. The test case expects no arguments and uses the done callback to handle async completion.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/examples/promise-done.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nit('should work', (done) => {  // [!code --]\n```\n\n----------------------------------------\n\nTITLE: Asserting Object Is Sealed with Vitest - TypeScript\nDESCRIPTION: Ensures that an object is sealed (cannot add or remove properties) using Vitest's assert.isSealed method. Accepts the object to be checked (e.g., Object.seal or Object.freeze results) and optionally a message. Use to check for prevention of property addition/removal, leveraging JavaScript object sealing features.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_116\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.isSealed', () => {\n  const sealedObject = Object.seal({})\n  const frozenObject = Object.seal({})\n\n  assert.isSealed(sealedObject)\n  assert.isSealed(frozenObject)\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Vitest Test Pool (CLI & Config)\nDESCRIPTION: Demonstrates switching the test execution pool, typically from the default `forks` to `threads`, which might be faster for large projects. This can be done via the `--pool` CLI option or the `test.pool` config property.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/improving-performance.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nvitest --pool=threads\n```\n\nLANGUAGE: ts\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    pool: 'threads',\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Combining Reporters with Multiple Output Files\nDESCRIPTION: This snippet shows how to direct the output of multiple reporters to distinct files.  It demonstrates configuring the `reporters` array to include 'junit', 'json', and 'verbose' reporters, and using the `outputFile` option with an object that maps reporter names to file paths. This allows for generating reports in different formats and saving them in separate files.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/reporters.md#_snippet_6\n\nLANGUAGE: ts\nCODE:\n```\nexport default defineConfig({\n  test: {\n    reporters: ['junit', 'json', 'verbose'],\n    outputFile: {\n      junit: './junit-report.xml',\n      json: './json-report.json',\n    },\n  },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Enabling Debug Logging for Vite-Node File Transformations in Bash\nDESCRIPTION: This bash snippet enables debug-level logging for Vite Node's file transformation and execution processes by setting 'DEBUG=vite-node:*' before running Vitest with the '--run' flag. It provides detailed logs about which files are requested and executed, helping identify unnecessary transforms or barrel file related overheads. Inputs are test files in the project, outputs are console logs describing file transformation flow. Requires environment with 'DEBUG' utility and Vitest installed.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/profiling-test-performance.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ DEBUG=vite-node:* vitest --run\n\n RUN  v2.1.1 /x/vitest/examples/profiling\n\n  vite-node:server:request /x/vitest/examples/profiling/global-setup.ts +0ms\n  vite-node:client:execute /x/vitest/examples/profiling/global-setup.ts +0ms\n  vite-node:server:request /x/vitest/examples/profiling/test/prime-number.test.ts +45ms\n  vite-node:client:execute /x/vitest/examples/profiling/test/prime-number.test.ts +26ms\n  vite-node:server:request /src/prime-number.ts +9ms\n  vite-node:client:execute /x/vitest/examples/profiling/src/prime-number.ts +9ms\n  vite-node:server:request /src/unnecessary-file.ts +6ms\n  vite-node:client:execute /x/vitest/examples/profiling/src/unnecessary-file.ts +4ms\n...\n```\n\n----------------------------------------\n\nTITLE: Testing Vitest Options: Deprecated Third Argument Syntax in TypeScript\nDESCRIPTION: This snippet illustrates the deprecated and new recommended signature for the test function in Vitest 3.0. The old pattern of using an options object as a third argument to test is shown alongside the updated syntax that places the options as the second argument. Requires Vitest 3.0+. The function accepts the test name, callback, and retry options. Deprecated: object as third argument will cause errors in future versions.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/migration.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ntest('validation works', () => {\n  // ...\n}, { retry: 3 })\n\ntest('validation works', { retry: 3 }, () => {\n  // ...\n})\n```\n\n----------------------------------------\n\nTITLE: Defining onFilterWatchedSpecification Function Signature (TypeScript)\nDESCRIPTION: This snippet shows the function signature for `onFilterWatchedSpecification`. It registers a handler function that accepts a `TestSpecification` object as input and returns a boolean indicating whether the test file should be rerun. This allows for custom filtering logic based on the specification.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/vitest.md#_snippet_30\n\nLANGUAGE: typescript\nCODE:\n```\nfunction onFilterWatchedSpecification(\n  fn: (specification: TestSpecification) => boolean\n): void\n```\n\n----------------------------------------\n\nTITLE: Setting One-Time Resolution with mockResolvedValueOnce\nDESCRIPTION: This example shows how to use `mockResolvedValueOnce` to make a mock function resolve with a value only on its next call. Subsequent calls will resolve or reject according to other configurations. Chaining allows setting different return values for consecutive calls. TypeScript ensures that the provided value matches the return type of the original function.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/mock.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nconst asyncMock = vi\n  .fn()\n  .mockResolvedValue('default')\n  .mockResolvedValueOnce('first call')\n  .mockResolvedValueOnce('second call')\n\nawait asyncMock() // first call\nawait asyncMock() // second call\nawait asyncMock() // default\nawait asyncMock() // default\n```\n\n----------------------------------------\n\nTITLE: Using Test Context in Vitest\nDESCRIPTION: Basic example showing how to access the test context in Vitest, which provides metadata about the current test.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/test-context.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { it } from 'vitest'\n\nit('should work', (ctx) => {\n  // prints name of the test\n  console.log(ctx.task.name)\n})\n```\n\n----------------------------------------\n\nTITLE: Globbing Test Specifications\nDESCRIPTION: This method constructs new test specifications by collecting tests in all projects using `project.globTestFiles`. It accepts string filters to match test files, utilizing the same filters supported by the CLI. Test specifications are automatically cached.  Multiple specs with the same module ID are possible.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/vitest.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction globTestSpecifications(\n  filters?: string[],\n): Promise<TestSpecification[]>\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst specifications = await vitest.globTestSpecifications(['my-filter'])\n// [TestSpecification{ moduleId: '/tests/my-filter.test.ts' }]\nconsole.log(specifications)\n```\n\n----------------------------------------\n\nTITLE: Customizing Environment Variables Loading in Vitest Configuration (TypeScript)\nDESCRIPTION: This TypeScript configuration snippet demonstrates how to use Vite's 'loadEnv' function inside a Vitest config to load all environment variables (not just those prefixed with 'VITE_') from .env files. Requires 'vite' and 'vitest/config' as dependencies. The code provides access to custom '.env.{mode}' files determined by the current test mode. The 'env' property under 'test' enables Vitest to utilize tailored environment setups during testing. Proper directory context should be ensured when executing.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/features.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport { loadEnv } from 'vite'\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig(({ mode }) => ({\n  test: {\n    // mode defines what \".env.{mode}\" file to choose if exists\n    env: loadEnv(mode, process.cwd(), ''),\n  },\n}))\n\n```\n\n----------------------------------------\n\nTITLE: Verifying Number of Assertions Called Using expect.assertions\nDESCRIPTION: This example shows how to ensure that a specific number of assertions were called during a test, particularly useful for testing asynchronous code to confirm that all expected assertions were executed.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_41\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { expect, test } from 'vitest'\n\nasync function doAsync(...cbs) {\n  await Promise.all(\n    cbs.map((cb, index) => cb({ index })),\n  )\n}\n\ntest('all assertions are called', async () => {\n  expect.assertions(2)\n  function callback1(data) {\n    expect(data).toBeTruthy()\n  }\n  function callback2(data) {\n    expect(data).toBeTruthy()\n  }\n\n  await doAsync(callback1, callback2)\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring tsconfig-paths Plugin in Vitest\nDESCRIPTION: This code snippet demonstrates how to configure the `vite-tsconfig-paths` plugin in a Vitest configuration file.  The plugin resolves module paths based on the `baseUrl` setting in the `tsconfig.json` file, which is not automatically handled by Vite.  This allows for importing modules using paths defined in `tsconfig.json`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/common-errors.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\nimport tsconfigPaths from 'vite-tsconfig-paths'\n\nexport default defineConfig({\n  plugins: [tsconfigPaths()]\n})\n```\n\n----------------------------------------\n\nTITLE: Accessing Built-in Vitest Environments and Globals Population | TypeScript\nDESCRIPTION: This snippet shows how to import the built-in Vitest environments and use the 'populateGlobal' utility. It retrieves the default environment objects ('jsdom', 'happy-dom', 'node', 'edge-runtime') from 'vitest/environments' and demonstrates logging them. The 'populateGlobal' function helps transfer properties from an environment object into the global namespace with configurable binding of functions, supporting environment setup and teardown. This aids in environment integration and global context setup during tests.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/environment.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { builtinEnvironments, populateGlobal } from 'vitest/environments'\n\nconsole.log(builtinEnvironments) // { jsdom, happy-dom, node, edge-runtime }\n\ninterface PopulateOptions {\n  // should non-class functions be bind to the global namespace\n  bindFunctions?: boolean\n}\n\ninterface PopulateResult {\n  // a list of all keys that were copied, even if value doesn't exist on original object\n  keys: Set<string>\n  // a map of original object that might have been overridden with keys\n  // you can return these values inside `teardown` function\n  originals: Map<string | symbol, any>\n}\n\nexport function populateGlobal(global: any, original: any, options: PopulateOptions): PopulateResult\n```\n\n----------------------------------------\n\nTITLE: Merging Configs in Workspace\nDESCRIPTION: This code snippet shows how to merge a shared configuration with project-specific configurations to avoid repeating config. It utilizes the `mergeConfig` function from `vitest/config` and leverages `defineProject` to specify the project’s configurations.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/workspace.md#_snippet_18\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { defineProject, mergeConfig } from 'vitest/config'\nimport configShared from '../vitest.shared.js'\n\nexport default mergeConfig(\n  configShared,\n  defineProject({\n    test: {\n      environment: 'jsdom',\n    }\n  })\n)\n\n```\n\n----------------------------------------\n\nTITLE: Printing Test Files Only With Vitest CLI - Bash\nDESCRIPTION: Explains how to use the --filesOnly flag with Vitest's list command to print only the matching test file paths rather than individual tests. Input: --filesOnly flag. Output: File paths of all matching test files are printed to standard output.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/cli.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nvitest list --filesOnly\n\n```\n\n----------------------------------------\n\nTITLE: Integrating Vitest Related Command in Lint-Staged - JavaScript\nDESCRIPTION: Example lint-staged configuration that runs Vitest with the related command and --run flag on changed JavaScript or TypeScript files. Shows how to set up lint-staged to use Vitest as a test runner. Input: JS/TS filenames from staged changes. Output: Vitest is invoked for related tests in non-watch mode. Dependency: lint-staged package must be installed.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/cli.md#_snippet_4\n\nLANGUAGE: js\nCODE:\n```\nexport default {\n  '*.{js,ts}': 'vitest related --run',\n}\n\n```\n\n----------------------------------------\n\nTITLE: Type Checking TestCase Instance in Vitest with TypeScript\nDESCRIPTION: This snippet demonstrates how to distinguish a TestCase by checking if a task's type is 'test'. It uses standard TypeScript type narrowing to safely assume subsequent property access is for a TestCase object. This is useful when working with multiple task types in Vitest's runner API. Inputs are any task-like object; outputs are narrowed types for conditional logic. No dependencies beyond TypeScript and Vitest context.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/test-case.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nif (task.type === 'test') {\n  task // TestCase\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Callable Functions with Vitest\nDESCRIPTION: This snippet uses the `toBeCallableWith()` matcher to verify that a function can be called with a specified set of parameters. It imports `expectTypeOf` from 'vitest'. It defines two function types, `NoParam` and `HasParam`, and then checks the behavior of `toBeCallableWith()` with the correct arguments.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect-typeof.md#_snippet_26\n\nLANGUAGE: ts\nCODE:\n```\nimport { expectTypeOf } from 'vitest'\n\ntype NoParam = () => void\ntype HasParam = (s: string) => void\n\nexpectTypeOf<NoParam>().toBeCallableWith()\nexpectTypeOf<HasParam>().toBeCallableWith('some string')\n```\n\n----------------------------------------\n\nTITLE: Resolving Vitest and Vite Configuration Programmatically with resolveConfig (TypeScript)\nDESCRIPTION: This snippet illustrates how to resolve Vitest and Vite configurations with custom options, such as mode and test setup files. The function provides a promise returning resolved configuration objects, useful for pre-processing or dynamic configuration scenarios before test execution.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/index.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { resolveConfig } from 'vitest/node'\n\nconst { vitestConfig, viteConfig } = await resolveConfig({\n  mode: 'custom',\n  configFile: false,\n  resolve: {\n    conditions: ['custom']\n  },\n  test: {\n    setupFiles: ['/my-setup-file.js'],\n    pool: 'threads',\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Adding automockPlugin to Vite Server Plugins - TypeScript\nDESCRIPTION: Shows how to integrate automockPlugin into the Vite server, enabling automatic mocking of modules during development. Requires @vitest/mocker/node and uses createServer from Vite. With the plugin active, modules flagged with mock query parameters are automatically subject to mocking behavior.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/mocker/EXPORTS.md#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { automockPlugin } from '@vitest/mocker/node'\nimport { createServer } from 'vite'\n\nawait createServer({\n  plugins: [\n    automockPlugin(),\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: filter.hasNotText - Exclude Elements Containing Specific Text\nDESCRIPTION: Filters out elements that contain the specified text or pattern, enabling exclusion based on visible or inner text matching.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_29\n\nLANGUAGE: TypeScript\nCODE:\n```\nhasNotText: string | RegExp\n```\n\n----------------------------------------\n\nTITLE: Running Related Tests With Vitest CLI - Bash\nDESCRIPTION: Runs tests that cover specific source files identified by their relative path, using Vitest's static import analysis. Useful for pre-commit hooks like lint-staged or automation in CI. Input: list of source file paths. Output: Runs tests related to the supplied files. Limitation: Only tests for files with static imports are detected, not dynamic ones.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/cli.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nvitest related /src/index.ts /src/hello-world.js\n\n```\n\n----------------------------------------\n\nTITLE: Initializing Vitest and accessing project names (Node.js)\nDESCRIPTION: This code snippet initializes Vitest using `createVitest` and retrieves the names of all projects. It demonstrates how Vitest automatically assigns names based on `package.json` or folder names if a `package.json` is missing.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/test-project.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createVitest } from 'vitest/node'\n\nconst vitest = await createVitest('test')\nvitest.projects.map(p => p.name) === [\n  '@pkg/server',\n  'utils',\n  '2',\n  'custom'\n]\n```\n\n----------------------------------------\n\nTITLE: Extending VitestTestRunner Class to Implement Custom Runner in TypeScript\nDESCRIPTION: This example demonstrates a practical implementation of a custom test runner by extending the VitestTestRunner class from 'vitest/runners.' It implements the VitestRunner interface by defining a constructor that accepts a VitestRunnerConfig and stores it as a public property. It overrides the onAfterRunFiles lifecycle method to log when test files have finished running. This pattern is useful for creating customized test runners that maintain compatibility with Vitest's core functionalities while enabling additional behaviors such as logging or augmenting test execution.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/runner.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { RunnerTestFile } from 'vitest'\nimport type { VitestRunner, VitestRunnerConfig } from 'vitest/suite'\nimport { VitestTestRunner } from 'vitest/runners'\n\nclass CustomRunner extends VitestTestRunner implements VitestRunner {\n  public config: VitestRunnerConfig\n\n  constructor(config: VitestRunnerConfig) {\n    this.config = config\n  }\n\n  onAfterRunFiles(files: RunnerTestFile[]) {\n    console.log('finished running', files)\n  }\n}\n\nexport default CustomRunner\n```\n\n----------------------------------------\n\nTITLE: Creating Vitest Instance without Starting Tests using createVitest Function (TypeScript/JavaScript)\nDESCRIPTION: This snippet shows how to instantiate a Vitest object without immediately starting tests, allowing customization of options such as watch mode and Vite overrides. It enables developers to prepare a Vitest environment for later execution or configuration manipulation.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/index.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { createVitest } from 'vitest/node'\n\nconst vitest = await createVitest('test', {\n  watch: false,\n})\n```\n\n----------------------------------------\n\nTITLE: Installing WebdriverIO for Vitest Browser Mode - Bash\nDESCRIPTION: Installation commands to add WebdriverIO alongside Vitest and the browser package. WebdriverIO enables running browser tests locally using the WebDriver protocol. Useful as an alternative to Playwright.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/index.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpm install -D vitest @vitest/browser webdriverio\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn add -D vitest @vitest/browser webdriverio\n```\n\nLANGUAGE: bash\nCODE:\n```\npnpm add -D vitest @vitest/browser webdriverio\n```\n\nLANGUAGE: bash\nCODE:\n```\nbun add -D vitest @vitest/browser webdriverio\n```\n\n----------------------------------------\n\nTITLE: Merging Vitest Sharded Reports (CLI)\nDESCRIPTION: Explains how to combine test reports generated by sharded runs (using the blob reporter) into a single result. This is done by running `vitest run --merge-reports` after collecting all blob reports from the `.vitest-reports` directory.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/improving-performance.md#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\nvitest run --merge-reports\n```\n\n----------------------------------------\n\nTITLE: Targeting Line Numbers in Test Files - Bash\nDESCRIPTION: Shows how to invoke Vitest to run only tests located at a specific line in a given file. This feature requires the full file path, either relative to the current working directory or absolute. Multiple valid forms are demonstrated; invalid cases include omitting the extension or using incomplete filenames. Input: a filename (with extension) and line number. Output: Test(s) at the specified line are executed. Limitations: range selection (e.g., 10-25) is not supported.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/cli.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ vitest basic/foo.test.ts:10\n$ vitest basic/foo.js:10 # ✅\n$ vitest ./basic/foo.js:10 # ✅\n$ vitest /users/project/basic/foo.js:10 # ✅\n$ vitest foo:10 # ❌\n$ vitest ./basic/foo:10 # ❌\n\n```\n\n----------------------------------------\n\nTITLE: Extracting Assert Signatures with Vitest in TypeScript\nDESCRIPTION: Uses `.asserts` to extract the value asserted by an 'asserts' function for further type checking. Requires Vitest and an assertion-style function accepting any value. Useful for developers maintaining custom assertion logic in TypeScript.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect-typeof.md#_snippet_12\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { expectTypeOf } from 'vitest'\n\nfunction assertNumber(v: any): asserts v is number {\n  if (typeof v !== 'number') {\n    throw new TypeError('Nope !')\n  }\n}\n\nexpectTypeOf(assertNumber).asserts.toBeNumber()\n```\n\n----------------------------------------\n\nTITLE: Configuring Verbose Reporter\nDESCRIPTION: This snippet demonstrates configuring the `verbose` reporter. It configures the reporter by setting the `reporters` array to `['verbose']`.  The verbose reporter displays each individual test after the suite has finished and also displays currently running tests that are taking longer than [`slowTestThreshold`](/config/#slowtestthreshold).\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/reporters.md#_snippet_10\n\nLANGUAGE: ts\nCODE:\n```\nexport default defineConfig({\n  test: {\n    reporters: [\n      ['verbose', { summary: false }]\n    ]\n  },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Asserting a Value Satisfies a Predicate Using toSatisfy\nDESCRIPTION: This snippet shows how to assert that a value passes a specific predicate function, useful for complex validation logic. It can be combined with negation to assert failure cases.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_38\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { describe, expect, it } from 'vitest'\n\nconst isOdd = (value: number) => value % 2 !== 0\n\ndescribe('toSatisfy()', () => {\n  it('pass with 0', () => {\n    expect(1).toSatisfy(isOdd)\n  })\n\n  it('pass with negation', () => {\n    expect(2).not.toSatisfy(isOdd)\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Disabling Vitest Test Isolation (CLI & Config)\nDESCRIPTION: Explains how to disable test isolation per file using the `--no-isolate` flag or the `test.isolate` config option. Disabling isolation can improve speed for projects without side effects, though it's not supported for the `vmThreads` pool. It also shows how to disable isolation specifically for the `forks` pool.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/improving-performance.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nvitest --no-isolate\n```\n\nLANGUAGE: ts\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    isolate: false,\n    // you can also disable isolation only for specific pools\n    poolOptions: {\n      forks: {\n        isolate: false,\n      },\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Resetting Mock Function State with mockReset\nDESCRIPTION: This snippet demonstrates the `mockReset` method, which clears call history and resets the implementation to its original state. For mocks created with `vi.fn()`, the implementation is set to an empty function. For mocks created with `vi.fn(impl)`, the implementation is restored to `impl`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/mock.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst person = {\n  greet: (name: string) => `Hello ${name}`,\n}\nconst spy = vi.spyOn(person, 'greet').mockImplementation(() => 'mocked')\nexpect(person.greet('Alice')).toBe('mocked')\nexpect(spy.mock.calls).toEqual([['Alice']])\n\n// clear call history and reset implementation, but method is still spied\nspy.mockReset()\nexpect(spy.mock.calls).toEqual([])\nexpect(person.greet).toBe(spy)\nexpect(person.greet('Bob')).toBe('Hello Bob')\nexpect(spy.mock.calls).toEqual([['Bob']])\n```\n\n----------------------------------------\n\nTITLE: Writing In-Source Tests with Vitest in TypeScript\nDESCRIPTION: This snippet shows how to organize implementation and test code within a single TypeScript module using Vitest. The main function is exported, followed by an `if (import.meta.vitest)` block containing suites using Vitest's `it` and `expect` primitives. Inputs tested include zero arguments and multiple numbers. Dependencies include Vitest's test runner, and the implementation is pure TypeScript. The file is structured so that private/internal logic can be tested directly, bypassing the need for exports.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/in-source.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport function add(...args: number[]) {\n  return args.reduce((a, b) => a + b, 0)\n}\n\nif (import.meta.vitest) {\n  const { it, expect } = import.meta.vitest\n  it('add', () => {\n    expect(add()).toBe(0)\n    expect(add(1)).toBe(1)\n    expect(add(1, 2, 3)).toBe(6)\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Setting a timeout for hooks in Vitest\nDESCRIPTION: This snippet shows how hooks like `beforeAll` can also receive a timeout parameter, allowing control over setup durations within the test lifecycle.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/filtering.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { beforeAll } from 'vitest'\n\nbeforeAll(async () => { /* ... */ }, 1000)\n```\n\n----------------------------------------\n\nTITLE: Jest Environment Compatibility - JavaScript\nDESCRIPTION: This snippet shows that Vitest is compatible with Jest's `@jest-environment` docblock to set the environment to jsdom. This facilitates migration from Jest to Vitest. It creates a div element as an assertion that the test is running in a jsdom environment.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_14\n\nLANGUAGE: JavaScript\nCODE:\n```\n/**\n * @jest-environment jsdom\n */\n\ntest('use jsdom in this test file', () => {\n  const element = document.createElement('div')\n  expect(element).not.toBeNull()\n})\n```\n\n----------------------------------------\n\nTITLE: Illustrating Valid moduleId Formats in Vitest\nDESCRIPTION: Shows examples of valid and invalid string formats for the `moduleId` property of a TestSpecification. The ID must be an absolute file path using the posix separator, regardless of the operating system.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/test-specification.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\n'C:/Users/Documents/project/example.test.ts' // ✅\n'/Users/mac/project/example.test.ts' // ✅\n'C:\\\\Users\\\\Documents\\\\project\\\\example.test.ts' // ❌\n```\n\n----------------------------------------\n\nTITLE: Assert Value is Above with Vitest\nDESCRIPTION: This snippet shows the `assert.isAbove` method for checking if a value is strictly greater than another value. The test requires the `vitest` testing framework. It takes two numbers and asserts that the first number is greater than the second.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.isAbove', () => {\n  assert.isAbove(5, 2, '5 is strictly greater than 2')\n})\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Task Collector in Vitest (JavaScript)\nDESCRIPTION: This snippet defines a custom task collector using `createTaskCollector` from the `vitest/suite` module. It aims to create a `myCustomTask` function that allows adding tasks with custom behavior during the collection phase. The custom task function takes a name, a handler function, and an optional timeout as parameters. It then uses `getCurrentSuite().task` to add the task to the current suite with a custom meta field, handler function, and timeout.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/runner.md#_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createTaskCollector, getCurrentSuite } from 'vitest/suite'\n\nexport { afterAll, beforeAll, describe } from 'vitest'\n\n// this function will be called during collection phase:\n// don't call function handler here, add it to suite tasks\n// with \"getCurrentSuite().task()\" method\n// note: createTaskCollector provides support for \"todo\"/\"each\"/...\nexport const myCustomTask = createTaskCollector(\n  function (name, fn, timeout) {\n    getCurrentSuite().task(name, {\n      ...this, // so \"todo\"/\"skip\"/... is tracked correctly\n      meta: {\n        customPropertyToDifferentiateTask: true\n      },\n      handler: fn,\n      timeout,\n    })\n  }\n)\n\n```\n\n----------------------------------------\n\nTITLE: Accessing GlobalConfig from a Vitest project\nDESCRIPTION: This snippet demonstrates how to access the global configuration of a Vitest project. `globalConfig` is the test config with which Vitest was initialized and is useful for values that cannot be set on the project level, like `coverage` or `reporters`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/test-project.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { ResolvedConfig } from 'vitest/node'\n\nvitest.config === vitest.projects[0].globalConfig\n```\n\n----------------------------------------\n\nTITLE: Ignoring Code with Istanbul Comments (TypeScript)\nDESCRIPTION: Shows how to use Istanbul ignore comments like `/* istanbul ignore if */` in TypeScript. The `@preserve` keyword is necessary to prevent `esbuild` from stripping the comment, allowing Istanbul to ignore the line, although this means the comment might remain in the final build.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/coverage.md#_snippet_10\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* istanbul ignore if -- @preserve */\nif (condition) {\n```\n\n----------------------------------------\n\nTITLE: Ordered Members Equality Assertion (TypeScript)\nDESCRIPTION: Defines `assert.sameOrderedMembers` to assert two arrays have identical elements in the same order, using strict equality. Demonstrates its usage in a test.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_87\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\n test('assert.sameOrderedMembers', () => {\n  assert.sameOrderedMembers([1, 2, 3], [1, 2, 3], 'same ordered members')\n})\n```\n\n----------------------------------------\n\nTITLE: getByTestId Function - Find Elements by Data Test ID\nDESCRIPTION: Creates a locator to find elements with a specific data-testid attribute, configurable for custom attribute names. Recommended to use primarily when other locators are insufficient. Suitable for testing attributes but less representative of user interactions.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_19\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction getByTestId(text: string | RegExp): Locator\n```\n\n----------------------------------------\n\nTITLE: Error Snapshotting (JavaScript)\nDESCRIPTION: This snippet demonstrates how Vitest snapshots Errors differently than Jest, providing the full error object with stack trace in both standard and inline snapshots, where Jest only snapshots the error message in inline snapshots.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/snapshot.md#_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\nimport { expect, test } from 'vitest'\n\ntest('snapshot', () => {\n  // in Jest and Vitest\n  expect(new Error('error')).toMatchInlineSnapshot(`[Error: error]`)\n\n  // Jest snapshots `Error.message` for `Error` instance\n  // Vitest prints the same value as toMatchInlineSnapshot\n  expect(() => {\n    throw new Error('error')\n  }).toThrowErrorMatchingInlineSnapshot(`\"error\"`)\n  }).toThrowErrorMatchingInlineSnapshot(`[Error: error]`)\n})\n```\n\n----------------------------------------\n\nTITLE: Accessing Vitest State and Extracting Module Metadata Programmatically (TypeScript)\nDESCRIPTION: This code shows how to programmatically run Vitest tests, then use the returned state to access stored metadata from the test run. The function createVitest is called to launch Vitest and testModules is accessed after completion to read meta properties. This technique is useful for automation or tooling around Vitest and requires the \"vitest\" package. No external configuration is needed; inputs are managed internally by createVitest. Output includes the meta fields set on suite and child tests.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/metadata.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst vitest = await createVitest('test')\nconst { testModules } = await vitest.start()\n\nconst testModule = testModules[0]\ntestModule.meta().done === true\ntestModule.children.at(0).meta().custom === 'some-custom-handler'\n```\n\n----------------------------------------\n\nTITLE: Snapshot Client Initialization\nDESCRIPTION: Initializes a SnapshotClient with a custom equality check function. This function is used when `.toMatchSnapshot({ property: 1 })` is called. It requires an equality check implementation (e.g., using libraries like 'equals' with iterable and subset equality checks).\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/snapshot/README.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { SnapshotClient } from '@vitest/snapshot'\nimport { NodeSnapshotEnvironment } from '@vitest/snapshot/environment'\nimport { SnapshotManager } from '@vitest/snapshot/manager'\n\nconst client = new SnapshotClient({\n  // you need to provide your own equality check implementation if you use it\n  // this function is called when `.toMatchSnapshot({ property: 1 })` is called\n  isEqual: (received, expected) =>\n    equals(received, expected, [iterableEquality, subsetEquality]),\n})\n```\n\n----------------------------------------\n\nTITLE: Writing Reporter Output to File - Configuration\nDESCRIPTION: This code snippet shows how to configure the reporter in the `vitest.config.ts` file to write the output to a file.  It configures the 'json' reporter and specifies the output file path using the `outputFile` configuration option. The output file will contain the test results in JSON format.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/reporters.md#_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\nexport default defineConfig({\n  test: {\n    reporters: ['json'],\n    outputFile: './test-output.json'\n  },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Vitest List Command Output Example - Plain Text\nDESCRIPTION: Shows sample output for the 'vitest list' command, including nested describe/test structure, as well as output when using --filesOnly (plain text). Inputs: combinations of CLI filters. Output: Human-readable listing of test suites or file paths. Dependency: Vitest CLI.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/cli.md#_snippet_8\n\nLANGUAGE: txt\nCODE:\n```\ndescribe > some-test\ndescribe > some-test > test 1\ndescribe > some-test > test 2\n\n```\n\nLANGUAGE: txt\nCODE:\n```\ntests/test1.test.ts\ntests/test2.test.ts\n\n```\n\n----------------------------------------\n\nTITLE: Assert Value Exists with Vitest\nDESCRIPTION: This demonstrates `assert.exists`, asserting that a value is neither null nor undefined. It utilizes the `vitest` testing framework. The assertion passes if the input value is neither null nor undefined.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_21\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\nconst name = 'foo'\n\ntest('assert.exists', () => {\n  assert.exists(name, 'foo is neither null nor undefined')\n})\n```\n\n----------------------------------------\n\nTITLE: Updating Snapshots using CLI (Bash)\nDESCRIPTION: This shows how to update snapshots using the `--update` or `-u` flag in the Vitest CLI. This will update all failing snapshots to match the current output. Dependencies: vitest CLI. Input: none. Output: Updated snapshot files.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/snapshot.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nvitest -u\n```\n\n----------------------------------------\n\nTITLE: Debugging Vite Node Transformation via Env Var (Bash)\nDESCRIPTION: Demonstrates enabling transformation debugging by setting the `VITE_NODE_DEBUG_DUMP=true` environment variable. When running `vite-node`, this causes the transformed code for each module to be saved ('dumped') into the `.vite-node/dump` directory.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/vite-node/README.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nVITE_NODE_DEBUG_DUMP=true vite-node example.ts\n```\n\n----------------------------------------\n\nTITLE: Iterating TestCollection\nDESCRIPTION: This code demonstrates how to iterate through the children of a module (which is an instance of TestCollection) to log the type and name of each child.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/test-collection.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nfor (const child of module.children) {\n  console.log(child.type, child.name)\n}\n```\n\n----------------------------------------\n\nTITLE: Assert Value Does Not Exist with Vitest\nDESCRIPTION: This demonstrates `assert.notExists`, which asserts that a value is either null or undefined.  It uses the `vitest` framework. The input is a value, and the assertion passes if the value is either null or undefined.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_22\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\nconst foo = null\nconst bar = undefined\n\ntest('assert.notExists', () => {\n  assert.notExists(foo, 'foo is null so not exist')\n  assert.notExists(bar, 'bar is undefined so not exist')\n})\n```\n\n----------------------------------------\n\nTITLE: TestCollection allTests method definition\nDESCRIPTION: Defines a function `allTests` that returns a Generator for iterating over all TestCase objects within the TestCollection and its children.  It accepts an optional TestState parameter to filter tests by state.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/test-collection.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nfunction allTests(state?: TestState): Generator<TestCase, undefined, void>\n```\n\n----------------------------------------\n\nTITLE: Using assert.deepPropertyVal in Vitest (TypeScript)\nDESCRIPTION: Illustrates `assert.deepPropertyVal`, which asserts that an object has a specific property (direct or inherited) with a value that is deeply equal to the provided value. The example imports from `vitest` and checks if the 'tea' property deeply equals an object within a test.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_60\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.deepPropertyVal', () => {\n  assert.deepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'matcha' })\n})\n```\n\n----------------------------------------\n\nTITLE: Using toHaveRole Assertion to Validate Element Roles - TypeScript\nDESCRIPTION: This snippet demonstrates how to assert roles on elements found by test IDs, including checking for explicit and implicit roles. It also covers negative assertions when an element does not have a given role, including fallback to 'generic' if no valid role applies.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_39\n\nLANGUAGE: ts\nCODE:\n```\nawait expect.element(getByTestId('button')).toHaveRole('button')\nawait expect.element(getByTestId('button-explicit')).toHaveRole('button')\nawait expect.element(getByTestId('button-explicit-multiple')).toHaveRole('button')\nawait expect.element(getByTestId('button-explicit-multiple')).toHaveRole('switch')\nawait expect.element(getByTestId('link')).toHaveRole('link')\nawait expect.element(getByTestId('link-invalid')).not.toHaveRole('link')\nawait expect.element(getByTestId('link-invalid')).toHaveRole('generic')\n```\n\n----------------------------------------\n\nTITLE: Defining Vitest-Only Plugin with configureVitest Hook - TypeScript\nDESCRIPTION: Defines a Vitest plugin using types imported from `vitest/node`. It returns a plugin object with a `name` and the `configureVitest` hook, which receives a `VitestPluginContext` object. This hook is executed early in the Vitest lifecycle and is suitable for modifying configuration before test execution.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/plugin.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { Vite, VitestPluginContext } from 'vitest/node'\n\nexport function plugin(): Vite.Plugin {\n  return {\n    name: 'vitest:my-plugin',\n    configureVitest(context: VitestPluginContext) {\n      // ...\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Fake Timers in Vitest with TypeScript\nDESCRIPTION: Illustrates new default behavior for fake timers and how to configure them explicitly in Vitest. The first snippet calls vi.useFakeTimers, showing performance.now() is now mocked. The second snippet exports a configuration object with fakeTimers.toFake set to a list of timer-related API names. Dependencies: 'vi.useFakeTimers', defineConfig. Input: none. Output: overridden/simulated timers during test runs.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/migration.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nvi.useFakeTimers()\n\nperformance.now() // original\nperformance.now() // fake\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport default defineConfig({\n  test: {\n    fakeTimers: {\n      toFake: [\n        'setTimeout',\n        'clearTimeout',\n        'setInterval',\n        'clearInterval',\n        'setImmediate',\n        'clearImmediate',\n        'Date',\n      ]\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Asserting Object Types with Vitest in TypeScript\nDESCRIPTION: Uses `.toBeObject` to check if the provided type is an object. Requires Vitest and can distinguish between objects and primitives, supporting robust API or data structure guards.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect-typeof.md#_snippet_17\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf(42).not.toBeObject()\nexpectTypeOf({}).toBeObject()\n```\n\n----------------------------------------\n\nTITLE: Writing Reporter Output to File - CLI\nDESCRIPTION: This snippet demonstrates how to direct reporter output to a file when using the command-line.  It uses the `--reporter=json` to specify the JSON reporter and `--outputFile` to specify the output file path.  The output file will contain the test results in JSON format.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/reporters.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpx vitest --reporter=json --outputFile=./test-output.json\n```\n\n----------------------------------------\n\nTITLE: Referencing Playwright Providers in TypeScript\nDESCRIPTION: This snippet shows how to reference the Playwright providers for Vitest in a TypeScript file to enable type definitions for custom options. This allows TypeScript to recognize the provider options and extra `expect` properties.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/playwright.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n/// <reference types=\"@vitest/browser/providers/playwright\" />\n```\n\n----------------------------------------\n\nTITLE: Assert Value is Not True with Vitest\nDESCRIPTION: This snippet shows `assert.isNotTrue`, which asserts that a value is not true. It uses `vitest` for testing. The input is a value, and the test passes if the value is not strictly true.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_14\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\nconst testPassed = 'ok'\n\ntest('assert.isNotTrue', () => {\n  assert.isNotTrue(testPassed)\n})\n```\n\n----------------------------------------\n\nTITLE: Assert Falsy Value with Vitest\nDESCRIPTION: This snippet demonstrates `assert.isNotOk`, which asserts that a given value is falsy. It requires `vitest` for the testing framework. It takes a value as input, and expects it to be falsy to pass. It fails the test if the input is truthy. Also demonstrates the alias `notOk`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.isNotOk', () => {\n  assert.isNotOk('foo', 'this will fail, every truthy is not ok')\n  assert.isNotOk(false, 'this will pass since false is falsy')\n})\n```\n\n----------------------------------------\n\nTITLE: TSX example using `getByPlaceholder`\nDESCRIPTION: This TSX snippet demonstrates locating an input element using `getByPlaceholder`.  It includes positive and negative examples. Requires a TSX environment that supports JSX syntax. No external dependencies needed other than a rendering context for the TSX.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_16\n\nLANGUAGE: tsx\nCODE:\n```\n<input placeholder=\"Username\" />\n\npage.getByPlaceholder('Username') // ✅\npage.getByPlaceholder('not found') // ❌\n```\n\n----------------------------------------\n\nTITLE: Manually Hoisting Mocks in Module Source with hoistMocks - TypeScript\nDESCRIPTION: Uses hoistMocks utility, with AST parsing, to transform a module source so mocks are resolved before imports. Expects a parseAst function (from Vite) and rewrites import statements for correct mock resolution. Returns rewritten code to be emitted or further processed.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/mocker/EXPORTS.md#_snippet_12\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { parseAst } from 'vite'\n\nhoistMocks(\n  `\nimport { mocked } from './some-module.js'\n\nvi.mock('./some-module.js', () => {\n  return { mocked: true }\n})\n\nmocked === true\n  `,\n  '/my-module.js',\n  parseAst\n)\n```\n\n----------------------------------------\n\nTITLE: Checking for `unknown` Type using Vitest in TypeScript\nDESCRIPTION: Applies `.toBeUnknown` matcher to check if a value is of type `unknown`. Requires Vitest and is used to enforce safe, unknown-only usage in type-sensitive contexts. Prevents reliance on concrete or overly specific types.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect-typeof.md#_snippet_14\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf().toBeUnknown()\nexpectTypeOf({} as unknown).toBeUnknown()\nexpectTypeOf('string').not.toBeUnknown()\n```\n\n----------------------------------------\n\nTITLE: Asserting Deep Inclusion in Arrays or Objects using Vitest (TypeScript)\nDESCRIPTION: Illustrates `assert.deepInclude` in Vitest tests for checking the presence of values in arrays or objects using deep equality comparison. Depends on `assert` and `test`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_44\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\nconst obj1 = { a: 1 }\nconst obj2 = { b: 2 }\n\ntest('assert.deepInclude', () => {\n  assert.deepInclude([obj1, obj2], { a: 1 })\n  assert.deepInclude({ foo: obj1, bar: obj2 }, { foo: { a: 1 } })\n})\n```\n\n----------------------------------------\n\nTITLE: Using ViteNodeRunner executeId Method for Runtime File Import in Custom Runner (TypeScript)\nDESCRIPTION: This snippet illustrates how a custom runner class can leverage the injected __vitest_executor, an instance of ViteNodeRunner provided by Vitest at runtime. It shows the usage of the executeId method to import test files dynamically in a Vite-compatible manner during the importFile lifecycle method. This approach ensures that imports and source transformations are resolved at runtime, allowing Node.js to understand modern ESM syntax and other Vite transformations during test execution. This technique is essential for running tests in complex Vite environments.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/runner.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport default class Runner {\n  async importFile(filepath: string) {\n    await this.__vitest_executor.executeId(filepath)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Running only specific suites or tests with .only in Vitest\nDESCRIPTION: This snippet illustrates how to execute only selected suites or tests marked with `.only`, enabling focused testing and debugging.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/filtering.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assert, describe, it } from 'vitest'\n\n// Only this suite will run\n\ndescribe.only('suite', () => {\n  it('test', () => {\n    assert.equal(Math.sqrt(4), 3)\n  })\n})\n\n// Other suites/tests are skipped unless marked with only\n\ndescribe('another suite', () => {\n  it('skipped test', () => {\n    assert.equal(Math.sqrt(4), 3)\n  })\n\n  it.only('test', () => {\n    assert.equal(Math.sqrt(4), 2)\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Filtering Tests by Line Number in Vitest 3\nDESCRIPTION: Examples of how to use the new feature that allows filtering tests by line number when running Vitest from the command line.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/blog/vitest-3.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ vitest basic/foo.js:10\n$ vitest ./basic/foo.js:10\n```\n\n----------------------------------------\n\nTITLE: Declaring element Function in Vitest (TypeScript)\nDESCRIPTION: Defines the element() function, retrieving a single DOM element for the locator's selector. Throws an error if zero or multiple matches are found. Used for strict element selection when presence and uniqueness are guaranteed; returns Element if found, otherwise throws.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_48\n\nLANGUAGE: typescript\nCODE:\n```\nfunction element(): Element\n```\n\n----------------------------------------\n\nTITLE: Asserting Unreachable Code with expect.unreachable in Vitest (TypeScript)\nDESCRIPTION: Illustrates how to use `expect.unreachable(message?)` to assert that a specific line of code should never be executed. This is demonstrated within a try-catch block to ensure an expected error is thrown and handled, and also within a switch statement's default case to guarantee all error conditions are explicitly tested.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_43\n\nLANGUAGE: typescript\nCODE:\n```\nimport { expect, test } from 'vitest'\n\nasync function build(dir) {\n  if (dir.includes('no-src')) {\n    throw new Error(`${dir}/src does not exist`)\n  }\n}\n\nconst errorDirs = [\n  'no-src-folder',\n  // ...\n]\n\ntest.each(errorDirs)('build fails with \"%s\"', async (dir) => {\n  try {\n    await build(dir)\n    expect.unreachable('Should not pass build')\n  }\n  catch (err: any) {\n    expect(err).toBeInstanceOf(Error)\n    expect(err.stack).toContain('build')\n\n    switch (dir) {\n      case 'no-src-folder':\n        expect(err.message).toBe(`${dir}/src does not exist`)\n        break\n      default:\n        // to exhaust all error tests\n        expect.unreachable('All error test must be handled')\n        break\n    }\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: TypeScript Reference Setup for Vitest Browser Matchers and Providers - TypeScript\nDESCRIPTION: TypeScript triple-slash directives to include typings for Vitest browser mode extra matchers and provider-specific options. Users need to add references to `@vitest/browser/matchers` or to `@vitest/browser/providers/playwright` or `@vitest/browser/providers/webdriverio` depending on their selected provider to get proper TypeScript type checking and intellisense.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/index.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n/// <reference types=\"@vitest/browser/matchers\" />\n```\n\nLANGUAGE: typescript\nCODE:\n```\n/// <reference types=\"@vitest/browser/providers/playwright\" />\n```\n\nLANGUAGE: typescript\nCODE:\n```\n/// <reference types=\"@vitest/browser/providers/webdriverio\" />\n```\n\n----------------------------------------\n\nTITLE: Defining Suite Interface for Grouping Test Tasks in Vitest (TypeScript)\nDESCRIPTION: This interface defines a Suite as a specialized TaskBase for grouping multiple test tasks in Vitest. It contains a type property fixed to 'suite', a file property linking to its root File task, and a tasks array holding child tasks (suites or tests). This structure supports hierarchical organization and traversal of test suites during collection and execution phases.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/runner.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\ninterface Suite extends TaskBase {\n  type: 'suite'\n  /**\n   * File task. It's the root task of the file.\n   */\n  file: File\n  /**\n   * An array of tasks that are part of the suite.\n   */\n  tasks: Task[]\n}\n```\n\n----------------------------------------\n\nTITLE: Running Vitest Sharded Tests (CLI)\nDESCRIPTION: Describes how to split Vitest test execution into smaller subsets (shards) across multiple machines or processes using the `--shard` option. Requires the `--reporter=blob` option to save results for later merging.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/improving-performance.md#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\nvitest run --reporter=blob --shard=1/3 # 1st machine\nvitest run --reporter=blob --shard=2/3 # 2nd machine\nvitest run --reporter=blob --shard=3/3 # 3rd machine\n```\n\n----------------------------------------\n\nTITLE: Handling Test Case Result Event in Vitest - TypeScript\nDESCRIPTION: Defines the `onTestCaseResult` function, called asynchronously when a test case has completed running or was skipped. It receives a `TestCase` parameter and runs after any `afterEach` hooks have finished. At this point, the test case's result is finalized with a non-pending state, allowing inspection of pass/fail status.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/reporters.md#_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction onTestCaseResult(testCase: TestCase): Awaitable<void>\n```\n\n----------------------------------------\n\nTITLE: Defining TypeScript Types for Custom Vitest Matchers\nDESCRIPTION: Provides the TypeScript code necessary to extend Vitest's built-in `Assertion` and `AsymmetricMatchersContaining` interfaces. This enables type checking and autocompletion for custom matchers defined using `expect.extend` when working in a TypeScript project. This declaration should be placed in an ambient declaration file (e.g., `vitest.d.ts`) included in `tsconfig.json`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_52\n\nLANGUAGE: typescript\nCODE:\n```\ninterface CustomMatchers<R = unknown> {\n  toBeFoo: () => R\n}\n\ndeclare module 'vitest' {\n  interface Assertion<T = any> extends CustomMatchers<T> {}\n  interface AsymmetricMatchersContaining extends CustomMatchers {}\n}\n```\n\n----------------------------------------\n\nTITLE: Generating HTML Report with Vitest Reporter in TypeScript and CLI\nDESCRIPTION: Configures Vitest to generate an interactive HTML report of test results served by a local development server. Requires the '@vitest/ui' package installed as a dependency. The output HTML file location can be set using the 'outputFile' configuration option; otherwise, a new file is created automatically. This snippet shows both the CLI command and the equivalent TypeScript config for enabling the 'html' reporter.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/reporters.md#_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\nnpx vitest --reporter=html\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport default defineConfig({\n  test: {\n    reporters: [\"html\"]\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Providing Context to Tests\nDESCRIPTION: This snippet shows how to use the `provide` method to pass values from the main thread to tests and how to receive them using the `inject` method. Values are checked with `structuredClone` before storage.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/vitest.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction provide<T extends keyof ProvidedContext & string>(\n  key: T,\n  value: ProvidedContext[T],\n): void\n```\n\n----------------------------------------\n\nTITLE: Configuring threads pool options in Vitest\nDESCRIPTION: This code snippet demonstrates how to configure the threads pool options within a Vitest configuration file. It showcases the structure for specifying thread-related settings.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    poolOptions: {\n      threads: {\n        // Threads related options here\n      }\n    }\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Declaring screenshot Function in Vitest (TypeScript)\nDESCRIPTION: Specifies overloaded screenshot function signatures to capture a screenshot of the element matching the locator. Accepts options for base64 encoding and custom file path; returns a Promise of either a path string or an object containing path and base64 fields. Requires locator context and valid output directory. Limitations include correct path permissions and optional base64 content retrieval.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_44\n\nLANGUAGE: typescript\nCODE:\n```\nfunction screenshot(options: LocatorScreenshotOptions & { base64: true }): Promise<{\n  path: string\n  base64: string\n}>\nfunction screenshot(options?: LocatorScreenshotOptions & { base64?: false }): Promise<string>\n```\n\n----------------------------------------\n\nTITLE: Asserting Own Property Inclusion using Vitest (TypeScript)\nDESCRIPTION: Illustrates `assert.ownInclude` in a Vitest test to check for the inclusion of properties directly defined on an object, ignoring any inherited properties. Imports `assert` and `test`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_50\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.ownInclude', () => {\n  assert.ownInclude({ a: 1 }, { a: 1 })\n})\n```\n\n----------------------------------------\n\nTITLE: Accessing SerializedConfig from a Vitest project\nDESCRIPTION: This snippet shows how to access the serialized configuration of a Vitest project. The `serializedConfig` property is a getter that serializes the config by removing functions and unserializable properties, and returns a new reference each time.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/test-project.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { SerializedConfig } from 'vitest'\n\nconst config: SerializedConfig = vitest.projects[0].serializedConfig\n```\n\n----------------------------------------\n\nTITLE: Filtering individual tests by full name using --testNamePattern\nDESCRIPTION: This snippet illustrates filtering tests by their full name using the `-t` or `--testNamePattern` option, useful for targeting specific tests within files.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/filtering.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ vitest -t \"test name pattern\"\n```\n\n----------------------------------------\n\nTITLE: Defining and Using toHaveClass Matcher in Vitest - TypeScript\nDESCRIPTION: This code defines the TypeScript signatures for the toHaveClass matcher and demonstrates usage in testing if elements have specific classes. It supports both string and RegExp inputs for class name matching, with an optional exact option to assert for an exact set of classes. Dependencies include a Vitest testing environment and DOM querying utilities like getByTestId. Key parameters are classNames (string or RegExp) and an optional options object with the exact property. The input consists of elements with class attributes, and the output is an assertion pass/fail about class presence. Limitation: exact: true cannot be set if only regular expressions are used.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_16\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction toHaveClass(...classNames: string[], options?: { exact: boolean }): Promise<void>\nfunction toHaveClass(...classNames: (string | RegExp)[]): Promise<void>\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst deleteButton = getByTestId('delete-button')\nconst noClasses = getByTestId('no-classes')\n\nawait expect.element(deleteButton).toHaveClass('extra')\nawait expect.element(deleteButton).toHaveClass('btn-danger btn')\nawait expect.element(deleteButton).toHaveClass(/danger/, 'btn')\nawait expect.element(deleteButton).toHaveClass('btn-danger', 'btn')\nawait expect.element(deleteButton).not.toHaveClass('btn-link')\nawait expect.element(deleteButton).not.toHaveClass(/link/)\n\n// ⚠️ regexp matches against individual classes, not the whole classList\nawait expect.element(deleteButton).not.toHaveClass(/btn extra/)\n\n// the element has EXACTLY a set of classes (in any order)\nawait expect.element(deleteButton).toHaveClass('btn-danger extra btn', {\n  exact: true\n})\n// if it has more than expected it is going to fail\nawait expect.element(deleteButton).not.toHaveClass('btn-danger extra', {\n  exact: true\n})\n\nawait expect.element(noClasses).not.toHaveClass()\n```\n\n----------------------------------------\n\nTITLE: Creating Automatic Fixtures in Vitest\nDESCRIPTION: Example of using tuple syntax for fixtures to create an automatic fixture that runs even if not used in tests.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/test-context.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { test as base } from 'vitest'\n\nconst test = base.extend({\n  fixture: [\n    async ({}, use) => {\n      // this function will run\n      setup()\n      await use()\n      teardown()\n    },\n    { auto: true } // Mark as an automatic fixture\n  ],\n})\n\ntest('works correctly')\n```\n\n----------------------------------------\n\nTITLE: Registering a Handler for Vitest Test Run Cancellation (TypeScript)\nDESCRIPTION: Registers a callback function that will be invoked when a test run is cancelled using `vitest.cancelCurrentRun`. The handler receives the `CancelReason` as an argument.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/vitest.md#_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\nfunction onCancel(fn: (reason: CancelReason) => Awaitable<void>): void\n```\n\n----------------------------------------\n\nTITLE: Defining and Using toHaveValue Matcher in Vitest - TypeScript\nDESCRIPTION: Defines the toHaveValue matcher for verifying the value of form elements, including input, select, textarea, and elements with certain ARIA roles. Supports string, string array, number, or null as the value parameter and outputs assertion pass/fail. Requires a compatible DOM element and a Vitest testing environment. Does not support input type=\"checkbox\" or type=\"radio\" (use toBeChecked or toHaveFormValues instead). For other elements, follows the normalization rules of toHaveFormValues.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_26\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction toHaveValue(value: string | string[] | number | null): Promise<void>\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst textInput = getByTestId('input-text')\nconst numberInput = getByTestId('input-number')\nconst emptyInput = getByTestId('input-empty')\nconst selectInput = getByTestId('select-number')\n\nawait expect.element(textInput).toHaveValue('text')\nawait expect.element(numberInput).toHaveValue(5)\nawait expect.element(emptyInput).not.toHaveValue()\nawait expect.element(selectInput).toHaveValue(['second', 'third'])\n```\n\n----------------------------------------\n\nTITLE: Testing a Web Worker with Vitest (TypeScript)\nDESCRIPTION: Demonstrates how to test a Web Worker in a Vitest test file (`worker.test.ts`). It imports `@vitest/web-worker` for setup, instantiates the worker using either the `?worker` import syntax or the standard `new Worker(URL)` constructor, sends data using `worker.postMessage`, and receives the response via the `worker.onmessage` event handler.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/web-worker/README.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// worker.test.ts\nimport '@vitest/web-worker'\nimport MyWorker from '../worker?worker'\n\nlet worker = new MyWorker()\n// new Worker is also supported\nworker = new Worker(new URL('../src/worker.ts', import.meta.url))\n\nworker.postMessage('hello')\nworker.onmessage = (e) => {\n  // e.data equals to 'hello world'\n}\n```\n\n----------------------------------------\n\nTITLE: Extracting Guard Types from Predicates with Vitest in TypeScript\nDESCRIPTION: Applies `.guards` matcher to extract the asserted type from type predicate functions (`v is Type`). Requires Vitest and a predicate function. Supports assertions for user-defined or built-in type guard functions.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect-typeof.md#_snippet_11\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { expectTypeOf } from 'vitest'\n\nfunction isString(v: any): v is string {\n  return typeof v === 'string'\n}\nexpectTypeOf(isString).guards.toBeString()\n```\n\n----------------------------------------\n\nTITLE: Initializing Vitest Project Configuration for Browser - Bash\nDESCRIPTION: Showcases how to use the Vitest CLI to initialize project configuration targeted for browser environments. The <name> argument should be 'browser' as currently supported. Input: browser as a value. Output: Sets up necessary config files in the project. Limitation: At present, only the browser mode is available.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/cli.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nvitest init browser\n\n```\n\n----------------------------------------\n\nTITLE: Asserting No Property Change with Vitest - TypeScript\nDESCRIPTION: This snippet verifies that a modifier function does not change a specified property of an object when executed. It requires the Vitest library, and the key parameters are the modifier function, object, property name, and an optional message. The input is an object and a modifier, and it asserts that the object's property remains unchanged after applying the modifier. Use when ensuring immutability or expected non-mutation.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_102\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.doesNotChange', () => {\n  const obj = { val: 10 }\n  function fn() { obj.val += 2 };\n  assert.doesNotChange(fn, obj, 'val', 2)\n})\n```\n\n----------------------------------------\n\nTITLE: Asserting Non-Inclusion in Strings, Arrays, or Objects using Vitest (TypeScript)\nDESCRIPTION: Shows how to use `assert.notInclude` in Vitest tests to verify the absence of a value in an array, a substring in a string, or properties in an object (shallow check). Requires `assert` and `test`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_43\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.notInclude', () => {\n  assert.notInclude([1, 2, 3], 4, 'array doesn\\'t contain 4')\n  assert.notInclude('foobar', 'baz', 'foobar doesn\\'t contain baz')\n  assert.notInclude({ foo: 'bar', hello: 'universe' }, { foo: 'baz' }, 'object doesn\\'t contain property')\n})\n```\n\n----------------------------------------\n\nTITLE: Handling test reruns in a Vitest project (TypeScript)\nDESCRIPTION: This code demonstrates how to use `onTestsRerun` to execute a callback when tests are scheduled to rerun, typically due to file changes. The callback receives an array of test specifications.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/test-project.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nproject.onTestsRerun((specs) => {\n  console.log(specs)\n})\n```\n\n----------------------------------------\n\nTITLE: Using Vite Node Programmatically (TypeScript)\nDESCRIPTION: Illustrates the programmatic integration of `vite-node`. It involves creating a Vite development server, initializing a `ViteNodeServer` instance, setting up source map support with `installSourcemapsSupport`, creating a `ViteNodeRunner` to handle module fetching and resolution via the server, and finally executing a target file (`./example.ts`). Requires `vite` and `vite-node` packages.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/vite-node/README.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createServer, version as viteVersion } from 'vite'\nimport { ViteNodeRunner } from 'vite-node/client'\nimport { ViteNodeServer } from 'vite-node/server'\nimport { installSourcemapsSupport } from 'vite-node/source-map'\n\n// create vite server\nconst server = await createServer({\n  optimizeDeps: {\n    // It's recommended to disable deps optimization\n    disabled: true,\n  },\n})\n// For old Vite, this is need to initialize the plugins.\nif (Number(viteVersion.split('.')[0]) < 6) {\n  await server.pluginContainer.buildStart({})\n}\n\n// create vite-node server\nconst node = new ViteNodeServer(server)\n\n// fixes stacktraces in Errors\ninstallSourcemapsSupport({\n  getSourceMap: source => node.getSourceMap(source),\n})\n\n// create vite-node runner\nconst runner = new ViteNodeRunner({\n  root: server.config.root,\n  base: server.config.base,\n  // when having the server and runner in a different context,\n  // you will need to handle the communication between them\n  // and pass to this function\n  fetchModule(id) {\n    return node.fetchModule(id)\n  },\n  resolveId(id, importer) {\n    return node.resolveId(id, importer)\n  },\n})\n\n// execute the file\nawait runner.executeFile('./example.ts')\n\n// close the vite server\nawait server.close()\n```\n\n----------------------------------------\n\nTITLE: Locating elements by placeholder text with `getByPlaceholder` in Vitest (TS)\nDESCRIPTION: This snippet demonstrates how to locate elements by their `placeholder` attribute using the `getByPlaceholder` method in Vitest. Requires the Vitest environment to be configured for browser mode testing. Returns a Locator object.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nfunction getByPlaceholder(\n  text: string | RegExp,\n  options?: LocatorOptions,\n): Locator\n```\n\n----------------------------------------\n\nTITLE: Asserting Element Accessible Error Message in Vitest Tests (JavaScript)\nDESCRIPTION: Verifies that a DOM element has a specific accessible error message, typically linked via `aria-errormessage` and used in conjunction with `aria-invalid`. Important for testing the accessibility of form validation feedback. Supports exact string match or regular expressions.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_13\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction toHaveAccessibleErrorMessage(message?: string | RegExp): Promise<void>\n```\n\nLANGUAGE: HTML\nCODE:\n```\n<input\n  aria-label=\"Has Error\"\n  aria-invalid=\"true\"\n  aria-errormessage=\"error-message\"\n/>\n<div id=\"error-message\" role=\"alert\">This field is invalid</div>\n\n<input aria-label=\"No Error Attributes\" />\n<input\n  aria-label=\"Not Invalid\"\n  aria-invalid=\"false\"\n  aria-errormessage=\"error-message\"\n/>\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Inputs with Valid Error Messages\nawait expect.element(getByRole('textbox', { name: 'Has Error' })).toHaveAccessibleErrorMessage()\nawait expect.element(getByRole('textbox', { name: 'Has Error' })).toHaveAccessibleErrorMessage(\n  'This field is invalid',\n)\nawait expect.element(getByRole('textbox', { name: 'Has Error' })).toHaveAccessibleErrorMessage(\n  /invalid/i,\n)\nawait expect.element(\n  getByRole('textbox', { name: 'Has Error' }),\n).not.toHaveAccessibleErrorMessage('This field is absolutely correct!')\n\n// Inputs without Valid Error Messages\nawait expect.element(\n  getByRole('textbox', { name: 'No Error Attributes' }),\n).not.toHaveAccessibleErrorMessage()\n\nawait expect.element(\n  getByRole('textbox', { name: 'Not Invalid' }),\n).not.toHaveAccessibleErrorMessage()\n```\n\n----------------------------------------\n\nTITLE: Asserting Object Contains Specific Keys with Vitest (TypeScript)\nDESCRIPTION: Demonstrates using `assert.containsAllKeys` in Vitest to verify that an object (or Map/Set) includes all specified keys, potentially having additional keys. Keys can be provided as an array of strings/objects or as the keys of another object. Includes examples with plain objects, Maps, and Sets.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_71\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.containsAllKeys', () => {\n  assert.containsAllKeys({ foo: 1, bar: 2, baz: 3 }, ['foo', 'baz'])\n  assert.containsAllKeys({ foo: 1, bar: 2, baz: 3 }, ['foo', 'bar', 'baz'])\n  assert.containsAllKeys({ foo: 1, bar: 2, baz: 3 }, { foo: 30, baz: 1337 })\n  assert.containsAllKeys({ foo: 1, bar: 2, baz: 3 }, { foo: 30, bar: 99, baz: 1337 })\n  assert.containsAllKeys(new Map([[{ foo: 1 }, 'bar'], ['key', 'value']]), [{ foo: 1 }])\n  assert.containsAllKeys(new Map([[{ foo: 1 }, 'bar'], ['key', 'value']]), [{ foo: 1 }, 'key'])\n  assert.containsAllKeys(new Set([{ foo: 'bar' }, 'anotherKey'], [{ foo: 'bar' }]))\n  assert.containsAllKeys(new Set([{ foo: 'bar' }, 'anotherKey'], [{ foo: 'bar' }, 'anotherKey']))\n})\n```\n\n----------------------------------------\n\nTITLE: Asserting Decreases But Not By Specific Value with Vitest - TypeScript\nDESCRIPTION: Asserts that a property of an object, or the modifier's return value, decreases when the modifier runs, but not by a forbidden value. Uses Vitest; parameters include the modifier function, target object, property, the forbidden change, and an optional message. Useful for fine-grained negative decrement assertions.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_112\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.decreasesButNotBy', () => {\n  const obj = { val: 10 }\n  function fn() { obj.val = 5 };\n  assert.decreasesButNotBy(fn, obj, 'val', 1)\n})\n```\n\n----------------------------------------\n\nTITLE: Using selectOptions for Select Elements in Vitest (TypeScript)\nDESCRIPTION: Demonstrates selection of one or more options from a <select> element using a locator. Shows usage with single string, multiple strings, and option locators. Requires page instance and access to locator hierarchy; ensures options are valid within the select. Handles UserEventSelectOptions for extra behaviors and executes asynchronously.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_43\n\nLANGUAGE: typescript\nCODE:\n```\nimport { page } from '@vitest/browser/context'\n\nconst languages = page.getByRole('select', { name: 'Languages' })\n\nawait languages.selectOptions('EN')\nawait languages.selectOptions(['ES', 'FR'])\nawait languages.selectOptions([\n  languages.getByRole('option', { name: 'Spanish' }),\n  languages.getByRole('option', { name: 'French' }),\n])\n```\n\n----------------------------------------\n\nTITLE: Assert Value is At Most with Vitest\nDESCRIPTION: This demonstrates the `assert.isAtMost` method to assert that a value is less than or equal to another. It uses the `vitest` testing framework. The input consists of two numbers, where the assertion passes if the first is less than or equal to the second.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_12\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.isAtMost', () => {\n  assert.isAtMost(3, 6, '3 is less than or equal to 6')\n  assert.isAtMost(4, 4, '4 is less than or equal to 4')\n})\n```\n\n----------------------------------------\n\nTITLE: Defining and Using toHaveStyle Matcher in Vitest - TypeScript\nDESCRIPTION: Defines the toHaveStyle matcher used to assert the presence of inline or stylesheet-applied CSS styles on DOM elements. The input parameter can be a CSS string or an object matching CSSStyleDeclaration, supporting flexibility. Outputs assertion pass/fail for strict matching of all expected property values. Requires HTML element with applicable style. Limitations: only verifies that all specified styles are applied; ignores extraneous styles.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_22\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction toHaveStyle(css: string | Partial<CSSStyleDeclaration>): Promise<void>\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst button = getByTestId('delete-button')\n\nawait expect.element(button).toHaveStyle('display: none')\nawait expect.element(button).toHaveStyle({ display: 'none' })\nawait expect.element(button).toHaveStyle(`\n  background-color: red;\n  display: none;\n`)\nawait expect.element(button).toHaveStyle({\n  backgroundColor: 'red',\n  display: 'none',\n})\nawait expect.element(button).not.toHaveStyle(`\n  background-color: blue;\n  display: none;\n`)\nawait expect.element(button).not.toHaveStyle({\n  backgroundColor: 'blue',\n  display: 'none',\n})\n```\n\n----------------------------------------\n\nTITLE: Getting Relevant Test Specifications\nDESCRIPTION: This method resolves test specifications by calling `project.globTestFiles`, including only changed files if the `--changed` flag is specified. It uses string filters. This method can be slow because it filters `--changed` flags. It should not be used if just a list of test files is needed.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/vitest.md#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction getRelevantTestSpecifications(\n  filters?: string[]\n): Promise<TestSpecification[]>\n```\n\n----------------------------------------\n\nTITLE: Deprecated WebdriverIO Provider Options in Vitest\nDESCRIPTION: Shows the previous method of configuring provider-specific options using `test.browser.providerOptions` in the Vitest config. This property is deprecated in Vitest 3+ and has been replaced by the `instances` configuration for defining browser capabilities.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/webdriverio.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport default defineConfig({\n  test: {\n    browser: {\n      providerOptions: {\n        capabilities: {},\n      },\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Defining toHaveSelection Assertion Function in TypeScript\nDESCRIPTION: Defines the toHaveSelection function that returns a Promise resolving to void and accepts an optional string parameter representing the expected selected text. This assertion is designed to check if the supplied text or part of it is currently selected within a DOM element. It supports elements like inputs of type text, textareas, and other text containing elements such as paragraphs and spans. The expected selection parameter must be a string, and checking for selection ranges by numeric indices is not supported.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_40\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction toHaveSelection(selection?: string): Promise<void>\n```\n\n----------------------------------------\n\nTITLE: Using vi.hoisted to reference variables in vi.mock factory (TypeScript)\nDESCRIPTION: Illustrates how to declare variables with vi.hoisted to enable their reference inside a hoisted vi.mock factory. Since vi.mock is hoisted and cannot directly access variables outside its scope, vi.hoisted allows pre-declaring mocks that can be reused. This example shows mocking a named export with vi.fn() and how to mock return values and verify calls.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { namedExport } from './path/to/module.js'\n\nconst mocks = vi.hoisted(() => {\n  return {\n    namedExport: vi.fn(),\n  }\n})\n\nvi.mock('./path/to/module.js', () => {\n  return {\n    namedExport: mocks.namedExport,\n  }\n})\n\nvi.mocked(namedExport).mockReturnValue(100)\n\nexpect(namedExport()).toBe(100)\nexpect(namedExport).toBe(mocks.namedExport)\n```\n\n----------------------------------------\n\nTITLE: TSX example demonstrating `level` option for `getByRole`\nDESCRIPTION: This TSX snippet demonstrates how to use the `level` option with `getByRole` to filter heading elements based on their level (aria-level). It includes examples using h1 elements and a div with role heading and aria-level. Requires a TSX environment that supports JSX syntax. No external dependencies needed other than a rendering context for the TSX.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\n<>\n  <h1>Heading Level One</h1>\n  <div role=\"heading\" aria-level=\"1\">Second Heading Level One</div>\n</>\n\npage.getByRole('heading', { level: 1 }) // ✅\npage.getByRole('heading', { level: 2 }) // ❌\n```\n\n----------------------------------------\n\nTITLE: Example HTML Elements Demonstrating ARIA Roles and Attributes - HTML\nDESCRIPTION: HTML snippet featuring buttons, links, and divs with explicit and implicit roles. Some elements demonstrate multiple roles and invalid roles for testing the role assertion behavior of Vitest.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_38\n\nLANGUAGE: html\nCODE:\n```\n<button data-testid=\"button\">Continue</button>\n<div role=\"button\" data-testid=\"button-explicit\">Continue</button>\n<button role=\"switch button\" data-testid=\"button-explicit-multiple\">Continue</button>\n<a href=\"/about\" data-testid=\"link\">About</a>\n<a data-testid=\"link-invalid\">Invalid link<a/>\n```\n\n----------------------------------------\n\nTITLE: Configuring vmThreads pool options in Vitest\nDESCRIPTION: This code snippet demonstrates how to configure the vmThreads pool options within a Vitest configuration file. It showcases the structure for specifying vmThreads-related settings.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    poolOptions: {\n      vmThreads: {\n        // VM threads related options here\n      }\n    }\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: VS Code Compound Configuration for Vitest Browser Debugging\nDESCRIPTION: This JSON configuration defines a compound launch configuration for debugging Vitest in browser mode within VS Code. It includes configurations to run Vitest with `--inspect-brk` and attach the Chrome debugger to the specified port. Requires VS Code, Vitest, and Chrome to be installed.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/debugging.md#_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"type\": \"node\",\n      \"request\": \"launch\",\n      \"name\": \"Run Vitest Browser\",\n      \"program\": \"${workspaceRoot}/node_modules/vitest/vitest.mjs\",\n      \"console\": \"integratedTerminal\",\n      \"args\": [\"--inspect-brk\", \"--browser\", \"--no-file-parallelism\"]\n    },\n    {\n      \"type\": \"chrome\",\n      \"request\": \"attach\",\n      \"name\": \"Attach to Vitest Browser\",\n      \"port\": 9229\n    }\n  ],\n  \"compounds\": [\n    {\n      \"name\": \"Debug Vitest Browser\",\n      \"configurations\": [\"Attach to Vitest Browser\", \"Run Vitest Browser\"],\n      \"stopAll\": true\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Using dropTo for Drag-and-Drop Operations in Vitest (TypeScript)\nDESCRIPTION: Provides an example where two elements are selected using page.getByText, and one is dropped onto the other using dropTo. Requires @vitest/browser/context and properly chained locator calls. Demonstrates how to structure source and destination locators for UI drag-and-drop automation; resolves the action as a Promise.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_41\n\nLANGUAGE: typescript\nCODE:\n```\nimport { page } from '@vitest/browser/context'\n\nconst paris = page.getByText('Paris')\nconst france = page.getByText('France')\n\nawait paris.dropTo(france)\n```\n\n----------------------------------------\n\nTITLE: Assert Value is False with Vitest\nDESCRIPTION: This snippet uses `assert.isFalse`, which asserts that a value is false. It uses the `vitest` framework. The input is a boolean, and the assertion passes only when the value is strictly false.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_15\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\nconst testPassed = false\n\ntest('assert.isFalse', () => {\n  assert.isFalse(testPassed)\n})\n```\n\n----------------------------------------\n\nTITLE: Asserting Own Property Non-Inclusion using Vitest (TypeScript)\nDESCRIPTION: Demonstrates `assert.notOwnInclude` in a Vitest test to verify the absence of a specific property directly on an object, ignoring properties inherited from its prototype chain. Requires `assert` and `test`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_51\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\nconst obj1 = {\n  b: 2\n}\n\n// Assuming 'object' refers to Object in a real scenario\n// const obj2 = Object.create(obj1); \n// The provided snippet has 'object.create' which might be a typo or custom implementation\n// Assuming standard Object.create for the example's intent:\nconst obj2 = Object.create(obj1)\nobj2.a = 1\n\ntest('assert.notOwnInclude', () => {\n  assert.notOwnInclude(obj2, { b: 2 }) // b is inherited, not owned\n})\n```\n\n----------------------------------------\n\nTITLE: Collecting Tests from Provided Specifications in Vitest (TypeScript)\nDESCRIPTION: Executes test files based on provided `TestSpecification` objects without running test callbacks, similar to `collect`. Returns unhandled errors and an array of test modules. This method can be slow due to running files in isolation.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/vitest.md#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nfunction collectTests(\n  specifications: TestSpecification[]\n): Promise<TestRunResult>\n```\n\n----------------------------------------\n\nTITLE: TypeScript Reference for Browser Context\nDESCRIPTION: Shows how to add a TypeScript reference for Vitest browser context to get correct type hints in your tests.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n/// <reference types=\"@vitest/browser/context\" />\n```\n\n----------------------------------------\n\nTITLE: HTML Context for toHaveTextContent Usage - HTML\nDESCRIPTION: HTML span with text content and test ID, serving as the node under test for toHaveTextContent matcher. Designed for use in the TypeScript test examples above.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_25\n\nLANGUAGE: HTML\nCODE:\n```\n<span data-testid=\"text-content\">Text Content</span>\n```\n\n----------------------------------------\n\nTITLE: Closing All Vitest Projects and Resources (TypeScript)\nDESCRIPTION: Closes all Vitest projects and releases their associated resources (like watchers or servers). Returns a Promise that resolves when closing is complete. This function can only be called once, and the result is cached.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/vitest.md#_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nfunction close(): Promise<void>\n```\n\n----------------------------------------\n\nTITLE: Referencing WebdriverIO Types in TypeScript Shims\nDESCRIPTION: Adds a reference directive to a TypeScript declaration file (`.d.ts`) to include type definitions specific to Vitest's WebdriverIO provider. This enables proper type checking for WebdriverIO-related options used in Vitest configuration without modifying the main tsconfig.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/webdriverio.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n/// <reference types=\"@vitest/browser/providers/webdriverio\" />\n```\n\n----------------------------------------\n\nTITLE: Extracting Types from Unions with Vitest in TypeScript\nDESCRIPTION: Demonstrates use of `.extract` to narrow union types for further assertions. Requires Vitest and TypeScript types including generics and interfaces. Extracts a specified type from a union for targeted type comparisons, supporting advanced typing scenarios in complex generic structures.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect-typeof.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { expectTypeOf } from 'vitest'\n\ntype ResponsiveProp<T> = T | T[] | { xs?: T; sm?: T; md?: T }\n\ninterface CSSProperties { margin?: string; padding?: string }\n\nfunction getResponsiveProp<T>(_props: T): ResponsiveProp<T> {\n  return {}\n}\n\nconst cssProperties: CSSProperties = { margin: '1px', padding: '2px' }\n\nexpectTypeOf(getResponsiveProp(cssProperties))\n  .extract<{ xs?: any }>() // extracts the last type from a union\n  .toEqualTypeOf<{ xs?: CSSProperties; sm?: CSSProperties; md?: CSSProperties }>()\n\nexpectTypeOf(getResponsiveProp(cssProperties))\n  .extract<unknown[]>() // extracts an array from a union\n  .toEqualTypeOf<CSSProperties[]>()\n```\n\n----------------------------------------\n\nTITLE: Inline Snapshot Usage\nDESCRIPTION: Demonstrates the usage of inline snapshots via the `wrapper` function. The example calls `toMatchInlineSnapshot` to assert the received value against an inline snapshot. The code shows how to use both automatically inferred and explicitly provided inline snapshots. `pretty-format` is required and the naming is hard-coded when parsing test files.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/snapshot/README.md#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\n// uses \"pretty-format\", so it requires quotes\n// also naming is hard-coded when parsing test files\nwrapper('text 1').toMatchInlineSnapshot()\nwrapper('text 2').toMatchInlineSnapshot('\"text 2\"')\n```\n\n----------------------------------------\n\nTITLE: Assert Value is Function with Vitest\nDESCRIPTION: This snippet uses `assert.isFunction` (and its alias `isCallable`) to verify if a value is a function.  It requires the `vitest` framework.  The input is a value and the assertion passes if the value is a function.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_25\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\nfunction name() { return 'foo' };\n\ntest('assert.isFunction', () => {\n  assert.isFunction(name, 'name is function')\n})\n```\n\n----------------------------------------\n\nTITLE: Assert Value is Not False with Vitest\nDESCRIPTION: This snippet demonstrates `assert.isNotFalse`, which asserts that a value is not false. It uses the `vitest` framework. The input is a value, and the test passes if it is not strictly false.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_16\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\nconst testPassed = 'no'\n\ntest('assert.isNotFalse', () => {\n  assert.isNotFalse(testPassed)\n})\n```\n\n----------------------------------------\n\nTITLE: Eliminating In-Source Test Code in Production Builds (TypeScript)\nDESCRIPTION: Shows how to configure Vitest and the underlying bundler using `define` options so the code in `if (import.meta.vitest)` blocks is removed in production. By setting `'import.meta.vitest': 'undefined'`, it allows dead code elimination to occur. This prevents in-source tests from being included in production bundles. Applies to Vite and other build tools supporting similar defines.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/in-source.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    includeSource: ['src/**/*.{js,ts}']\n  },\n  define: { // [!code ++]\n    'import.meta.vitest': 'undefined' // [!code ++]\n  } // [!code ++]\n})\n```\n\n----------------------------------------\n\nTITLE: Registering a Handler for Vitest Server Close (TypeScript)\nDESCRIPTION: Registers a callback function that will be invoked when the Vitest server is closed, typically via the `vitest.close` or `vitest.exit` methods.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/vitest.md#_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\nfunction onClose(fn: () => Awaitable<void>): void\n```\n\n----------------------------------------\n\nTITLE: tripleClick Method - Trigger Triple Click Event\nDESCRIPTION: Simulates three rapid click events in succession, as browsers do not natively support triple clicks. Used for testing triple-click interactions or custom behaviors.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_32\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction tripleClick(options?: UserEventTripleClickOptions): Promise<void>\n```\n\n----------------------------------------\n\nTITLE: Asserting Element Accessible Name in Vitest Tests (JavaScript)\nDESCRIPTION: Verifies that a DOM element has a specific accessible name, which is the primary way assistive technologies identify interactive elements. Derived from various sources like `alt`, `title`, or content. Supports exact string match or regular expressions.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_14\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction toHaveAccessibleName(name?: string | RegExp): Promise<void>\n```\n\nLANGUAGE: HTML\nCODE:\n```\n<img data-testid=\"img-alt\" src=\"\" alt=\"Test alt\" />\n<img data-testid=\"img-empty-alt\" src=\"\" alt=\"\" />\n<svg data-testid=\"svg-title\"><title>Test title</title></svg>\n<button data-testid=\"button-img-alt\"><img src=\"\" alt=\"Test\" /></button>\n<p><img data-testid=\"img-paragraph\" src=\"\" alt=\"\" /> Test content</p>\n<button data-testid=\"svg-button\"><svg><title>Test</title></svg></p>\n<div><svg data-testid=\"svg-without-title\"></svg></div>\n<input data-testid=\"input-title\" title=\"test\" />\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\nawait expect.element(getByTestId('img-alt')).toHaveAccessibleName('Test alt')\nawait expect.element(getByTestId('img-empty-alt')).not.toHaveAccessibleName()\nawait expect.element(getByTestId('svg-title')).toHaveAccessibleName('Test title')\nawait expect.element(getByTestId('button-img-alt')).toHaveAccessibleName()\nawait expect.element(getByTestId('img-paragraph')).not.toHaveAccessibleName()\nawait expect.element(getByTestId('svg-button')).toHaveAccessibleName()\nawait expect.element(getByTestId('svg-without-title')).not.toHaveAccessibleName()\nawait expect.element(getByTestId('input-title')).toHaveAccessibleName()\n```\n\n----------------------------------------\n\nTITLE: Accessing Playwright Context Custom Command Vitest TypeScript\nDESCRIPTION: Shows how to access provider-specific context properties, such as `ctx.iframe` (a Playwright `FrameLocator`), within the server-side implementation of a custom browser command. This allows the command logic to interact directly with the test iframe using Playwright's API. The example demonstrates finding an element and taking a screenshot.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/commands.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { BrowserCommand } from 'vitest/node'\n\nexport const myCommand: BrowserCommand<[string, number]> = async (\n  ctx,\n  arg1: string,\n  arg2: number\n) => {\n  if (ctx.provider.name === 'playwright') {\n    const element = await ctx.iframe.findByRole('alert')\n    const screenshot = await element.screenshot()\n    // do something with the screenshot\n    return difference\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Vitest Fork Pool Test Runner for CPU and Heap Profiling in TypeScript\nDESCRIPTION: This TypeScript snippet defines a Vitest configuration that enables CPU and heap profiling for test runners using the 'forks' pool. It sets Node.js execArgv flags '--cpu-prof' and '--heap-prof' along with directories to store profiling output. The 'singleFork' option creates a single profiling output to simplify analysis. Dependencies include Vitest and Node.js with administrative permissions to write profile data. Inputs are test files run through Vitest, and outputs are '.cpuprofile' and '.heapprofile' files in the specified directory. Limitations include Node.js version compatibility and must avoid 'pool: threads' to use '--prof'.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/profiling-test-performance.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    pool: 'forks',\n    poolOptions: {\n      forks: {\n        execArgv: [\n          '--cpu-prof',\n          '--cpu-prof-dir=test-runner-profile',\n          '--heap-prof',\n          '--heap-prof-dir=test-runner-profile'\n        ],\n\n        // To generate a single profile\n        singleFork: true,\n      },\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring WebdriverIO Instances in Vitest\nDESCRIPTION: Demonstrates how to define specific browser instances and their desired capabilities (like browser version and platform) within the `test.browser.instances` array in the Vitest configuration file (`vitest.config.ts`). This configures the browser environment for running tests via WebdriverIO.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/webdriverio.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    browser: {\n      instances: [\n        {\n          browser: 'chrome',\n          capabilities: {\n            browserVersion: 86,\n            platformName: 'Windows 10',\n          },\n        },\n      ],\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Excluding Types from Unions with Vitest in TypeScript\nDESCRIPTION: Utilizes `.exclude` to remove specific types from a union and assert the remainder. Depends on Vitest and TypeScript, utilizing generics and interface definitions. Ensures precise union manipulation and targeted type narrowing in typings-focused tests.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect-typeof.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { expectTypeOf } from 'vitest'\n\ntype ResponsiveProp<T> = T | T[] | { xs?: T; sm?: T; md?: T }\n\ninterface CSSProperties { margin?: string; padding?: string }\n\nfunction getResponsiveProp<T>(_props: T): ResponsiveProp<T> {\n  return {}\n}\n\nconst cssProperties: CSSProperties = { margin: '1px', padding: '2px' }\n\nexpectTypeOf(getResponsiveProp(cssProperties))\n  .exclude<unknown[]>()\n  .exclude<{ xs?: unknown }>() // or just .exclude<unknown[] | { xs?: unknown }>()\n  .toEqualTypeOf<CSSProperties>()\n```\n\n----------------------------------------\n\nTITLE: Merging Vitest Blob Reports - SH\nDESCRIPTION: Shows how to use Vitest's --merge-reports option to combine multiple blob reports in a given directory, typically after sharded runs. This command supports all reporters except the blob reporter itself. Input: --merge-reports flag and optional --reporter argument. Output: Combined and formatted test report using the specified format, e.g., junit.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/cli.md#_snippet_10\n\nLANGUAGE: sh\nCODE:\n```\nvitest --merge-reports --reporter=junit\n\n```\n\n----------------------------------------\n\nTITLE: Asserting Map/Set Has Exactly All Deep Keys with Vitest (TypeScript)\nDESCRIPTION: Demonstrates using `assert.hasAllDeepKeys` in Vitest to verify that a Map or Set contains exactly all of the specified keys and no others, performing a deep comparison for object keys. Keys can be provided as an array of objects/strings or as the keys of another object. *Note: The example code incorrectly uses the test name `assert.hasAnyDeepKeys`; it should be `assert.hasAllDeepKeys`.*\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_75\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.hasAnyDeepKeys', () => { // Test title should be assert.hasAllDeepKeys\n  assert.hasAllDeepKeys(new Map([[{ one: 'one' }, 'valueOne']]), { one: 'one' })\n  assert.hasAllDeepKeys(new Map([[{ one: 'one' }, 'valueOne'], [{ two: 'two' }, 'valueTwo']]), [{ one: 'one' }, { two: 'two' }])\n  assert.hasAllDeepKeys(new Set([{ one: 'one' }]), { one: 'one' })\n  assert.hasAllDeepKeys(new Set([{ one: 'one' }, { two: 'two' }]), [{ one: 'one' }, { two: 'two' }])\n})\n```\n\n----------------------------------------\n\nTITLE: Asserting Deep Nested Property Non-Inclusion using Vitest (TypeScript)\nDESCRIPTION: Shows how to use `assert.notDeepNestedInclude` in Vitest tests to verify the absence of nested properties using dot/bracket notation (with escaping) and deep equality comparison. Requires `assert` and `test`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_49\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.notDeepNestedInclude', () => {\n  assert.notDeepNestedInclude({ a: { b: [{ x: 1 }] } }, { 'a.b[0]': { y: 1 } })\n  assert.notDeepNestedInclude({ '.a': { '[b]': { x: 1 } } }, { '\\\\.a.\\\\[b\\\\]': { y: 2 } })\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring project names in vitest.workspace.js\nDESCRIPTION: This snippet shows how project names are configured within a `vitest.workspace.js` file. It demonstrates how names are derived from `package.json` files or custom configurations within the workspace file.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/test-project.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport default [\n  './packages/server', // has package.json with \"@pkg/server\"\n  './utils', // doesn't have a package.json file\n  {\n    // doesn't customize the name\n    test: {\n      pool: 'threads',\n    },\n  },\n  {\n    // customized the name\n    test: {\n      name: 'custom',\n    },\n  },\n]\n```\n\n----------------------------------------\n\nTITLE: Configuring Rollup to Remove In-Source Tests (JavaScript)\nDESCRIPTION: This snippet illustrates the use of the Rollup replace plugin to substitute `import.meta.vitest` with `undefined`, enabling the dead code elimination of in-source test blocks. It requires the `@rollup/plugin-replace` as a dependency, and the configuration is placed in `plugins`. Recommended for projects using Rollup as their bundler.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/in-source.md#_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport replace from '@rollup/plugin-replace' // [!code ++]\n\nexport default {\n  plugins: [\n    replace({ // [!code ++]\n      'import.meta.vitest': 'undefined' // [!code ++]\n    }) // [!code ++]\n  ],\n  // other options\n}\n```\n\n----------------------------------------\n\nTITLE: Example HTML Markup for Checked State Assertions - HTML\nDESCRIPTION: HTML snippet providing checkbox and radio inputs, along with ARIA role elements for checkbox, radio, and switch with aria-checked attribute. Both checked and unchecked states are demonstrated for comprehensive testing.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_32\n\nLANGUAGE: html\nCODE:\n```\n<input type=\"checkbox\" checked data-testid=\"input-checkbox-checked\" />\n<input type=\"checkbox\" data-testid=\"input-checkbox-unchecked\" />\n<div role=\"checkbox\" aria-checked=\"true\" data-testid=\"aria-checkbox-checked\" />\n<div\n  role=\"checkbox\"\n  aria-checked=\"false\"\n  data-testid=\"aria-checkbox-unchecked\"\n/>\n\n<input type=\"radio\" checked value=\"foo\" data-testid=\"input-radio-checked\" />\n<input type=\"radio\" value=\"foo\" data-testid=\"input-radio-unchecked\" />\n<div role=\"radio\" aria-checked=\"true\" data-testid=\"aria-radio-checked\" />\n<div role=\"radio\" aria-checked=\"false\" data-testid=\"aria-radio-unchecked\" />\n<div role=\"switch\" aria-checked=\"true\" data-testid=\"aria-switch-checked\" />\n<div role=\"switch\" aria-checked=\"false\" data-testid=\"aria-switch-unchecked\" />\n```\n\n----------------------------------------\n\nTITLE: Configuring npm Scripts for Vitest in package.json\nDESCRIPTION: Shows how to add a `test` script to the `scripts` section of `package.json`. This allows running Vitest tests using the command `npm run test`, `yarn test`, or `pnpm test`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/index.md#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"scripts\": {\n    \"test\": \"vitest\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an Example Function (sum.js)\nDESCRIPTION: Defines a simple JavaScript function `sum` that takes two arguments (`a`, `b`) and returns their sum. This function is intended to be tested using Vitest.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/index.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nexport function sum(a, b) {\n  return a + b\n}\n```\n\n----------------------------------------\n\nTITLE: Set Membership Assertion with Same Members (TypeScript)\nDESCRIPTION: Defines `assert.sameMembers` to verify two arrays contain the same elements, regardless of order, using strict equality. Demonstrates the assertion with a test case.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_83\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\n test('assert.sameMembers', () => {\n  assert.sameMembers([1, 2, 3], [2, 1, 3], 'same members')\n})\n```\n\n----------------------------------------\n\nTITLE: Handling Hook Completion Event in Vitest - TypeScript\nDESCRIPTION: Defines the `onHookEnd` function which is asynchronously invoked when any test hook (`beforeAll`, `afterAll`, `beforeEach`, or `afterEach`) finishes running. It receives a `ReportedHookContext` context object representing the hook execution. Depending on the hook type, the `entity` property in the context represents either a `TestSuite` or `TestModule` (for `beforeAll`/`afterAll`) or a `TestCase` (for `beforeEach`/`afterEach`). The function will not be called if the hook did not run during the test suite execution.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/reporters.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction onHookEnd(context: ReportedHookContext): Awaitable<void>\n```\n\n----------------------------------------\n\nTITLE: Asserting Map/Set Lacks Any Specific Deep Keys with Vitest (TypeScript)\nDESCRIPTION: Demonstrates using `assert.doesNotHaveAnyDeepKeys` in Vitest to verify that a Map or Set does not contain any of the specified keys, performing a deep comparison for object keys. Keys can be provided as an array of objects/strings or as the keys of another object.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_77\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.doesNotHaveAnyDeepKeys', () => {\n  assert.doesNotHaveAnyDeepKeys(new Map([[{ one: 'one' }, 'valueOne'], [1, 2]]), { thisDoesNot: 'exist' })\n  assert.doesNotHaveAnyDeepKeys(new Map([[{ one: 'one' }, 'valueOne'], [{ two: 'two' }, 'valueTwo']]), [{ twenty: 'twenty' }, { fifty: 'fifty' }])\n  assert.doesNotHaveAnyDeepKeys(new Set([{ one: 'one' }, { two: 'two' }]), { twenty: 'twenty' })\n  assert.doesNotHaveAnyDeepKeys(new Set([{ one: 'one' }, { two: 'two' }]), [{ twenty: 'twenty' }, { fifty: 'fifty' }])\n})\n```\n\n----------------------------------------\n\nTITLE: Using assert.propertyVal in Vitest (TypeScript)\nDESCRIPTION: Shows how to use `assert.propertyVal` to assert that an object has a specific property (direct or inherited) with a particular value, using strict equality (===). The example imports from `vitest` and checks if the 'tea' property equals 'is good' within a test.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_58\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.notPropertyVal', () => { // Note: Test name seems incorrect in original text, likely should be assert.propertyVal\n  assert.propertyVal({ tea: 'is good' }, 'tea', 'is good')\n})\n```\n\n----------------------------------------\n\nTITLE: Using defineProject in Project Config\nDESCRIPTION: This code snippet illustrates the correct usage of `defineProject` within a project configuration file. It highlights that some configuration options are not supported at the project level, like `reporters`. This is to ensure better type safety when configuring individual project.  It also demonstrates limitations.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/workspace.md#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\n// @errors: 2769\nimport { defineProject } from 'vitest/config'\n\nexport default defineProject({\n  test: {\n    environment: 'jsdom',\n    // \"reporters\" is not supported in a project config,\n    // so it will show an error\n    reporters: ['json']\n  }\n})\n\n```\n\n----------------------------------------\n\nTITLE: Configure JSDOM Typescript - JSON\nDESCRIPTION: This snippet shows how to configure TypeScript to recognize the `jsdom` global variable when using the jsdom environment in Vitest.  Adding `vitest/jsdom` to the `types` array in `tsconfig.json` enables TypeScript to provide type checking for jsdom APIs. This prevents compilation errors related to missing type definitions.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_16\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"compilerOptions\": {\n    \"types\": [\"vitest/jsdom\"]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: HTML Context for toHaveFocus Usage - HTML\nDESCRIPTION: Single input element inside a div, with a test ID for retrieval in TypeScript/JS tests. Serves as the node under test for focus assertions. No dependencies beyond standard HTML.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_19\n\nLANGUAGE: HTML\nCODE:\n```\n<div><input type=\"text\" data-testid=\"element-to-focus\" /></div>\n```\n\n----------------------------------------\n\nTITLE: Defining TestResultPassed Interface for Passed Tests in Vitest (TypeScript)\nDESCRIPTION: This interface describes the result object returned by result() for passed tests in Vitest. State is 'passed', and errors may be present if retries were used. Inputs are implicit. Used for managing reporting logic and post-processing results in test suites.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/test-case.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\ninterface TestResultPassed {\n  /**\n   * The test passed successfully.\n   */\n  readonly state: 'passed'\n  /**\n   * Errors that were thrown during the test execution.\n   */\n  readonly errors: ReadonlyArray<TestError> | undefined\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and managing a Vitest instance with createVitest in Node.js\nDESCRIPTION: This snippet illustrates how to import createVitest from 'vitest/node' and create a Vitest instance without automatically running tests. It sets up event handlers for cancel, close, and rerun events, and demonstrates error handling during the start process. Proper cleanup with vitest.close() is emphasized. Dependencies include the 'vitest/node' package, and the pattern is suitable for advanced test orchestration.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/guide/tests.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { createVitest } from 'vitest/node'\n\nconst vitest = await createVitest(\n  'test',\n  {}, // override test config\n  {}, // override Vite config\n  {}, // custom Vitest options\n)\n\n// called when `vitest.cancelCurrentRun()` is invoked\nvitest.onCancel(() => {})\n// called during `vitest.close()` call\nvitest.onClose(() => {})\n// called when Vitest reruns test files\nvitest.onTestsRerun((files) => {})\n\ntry {\n  // this will set process.exitCode to 1 if tests failed,\n  // and won't close the process automatically\n  await vitest.start(['my-filter'])\n}\ncatch (err) {\n  // handle errors like \"FilesNotFoundError\" or \"GitNotFoundError\"\n}\nfinally {\n  await vitest.close()\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting Function Types with Vitest in TypeScript\nDESCRIPTION: Checks if a tested value is a function using `.toBeFunction`. Requires Vitest and can be applied to values, functions, or function expressions to guarantee correct typing and API coverage.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect-typeof.md#_snippet_16\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf(42).not.toBeFunction()\nexpectTypeOf((): never => {}).toBeFunction()\n```\n\n----------------------------------------\n\nTITLE: Filtering test files by name using Vitest CLI\nDESCRIPTION: This snippet demonstrates how to filter test files by a substring within their filename using the Vitest CLI, enabling selective test execution based on filename patterns.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/filtering.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ vitest basic\n\nWill only execute test files that contain `basic`, e.g.\n\n```\nbasic.test.ts\nbasic-foo.test.ts\nbasic/foo.test.ts\n```\n```\n\n----------------------------------------\n\nTITLE: Assert Deep Equality with Vitest\nDESCRIPTION: This demonstrates `assert.deepEqual`, which tests for deep equality of objects. It requires the `vitest` testing framework. The input is two objects, and the assertion passes if they have the same properties and values (recursively).\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.deepEqual', () => {\n  assert.deepEqual({ color: 'green' }, { color: 'green' })\n})\n```\n\n----------------------------------------\n\nTITLE: Type Testing and Assertions using expect-type and Vitest in TypeScript (.d.ts files)\nDESCRIPTION: This TypeScript declaration file snippet shows how to test type correctness using Vitest's 'expectTypeOf', 'assertType', and 'test' APIs alongside user modules. It requires Vitest and the 'expect-type' package and should be placed in a '.test-d.ts' file for type checking in the editor and build processes. Inputs are types and expected types; outputs are compile-time errors or passes. It's useful for catching regressions in type definitions. Not all JavaScript environments support type assertion tests, which are primarily intended for TypeScript.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/features.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assertType, expectTypeOf, test } from 'vitest'\nimport { mount } from './mount.js'\n\ntest('my types work properly', () => {\n  expectTypeOf(mount).toBeFunction()\n  expectTypeOf(mount).parameter(0).toMatchTypeOf<{ name: string }>()\n\n  // @ts-expect-error name is a string\n  assertType(mount({ name: 42 }))\n})\n\n```\n\n----------------------------------------\n\nTITLE: HTML Context for toHaveStyle Usage - HTML\nDESCRIPTION: HTML snippet representing a button with inline CSS for display and background color. Used in toHaveStyle matcher demonstrations. Standard HTML element with a test ID for element selection.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_23\n\nLANGUAGE: HTML\nCODE:\n```\n<button\n  data-testid=\"delete-button\"\n  style=\"display: none; background-color: red\"\n>\n  Delete item\n</button>\n```\n\n----------------------------------------\n\nTITLE: Assertion for Operator Comparison in Vitest (TypeScript)\nDESCRIPTION: Defines `assert.operator` to compare two values using a specified operator (e.g., '<', '>', '=='). It verifies that the comparison holds true within a test case context.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_81\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\n test('assert.operator', () => {\n  assert.operator(1, '<', 2, 'everything is ok')\n})\n```\n\n----------------------------------------\n\nTITLE: Combining Reporters\nDESCRIPTION: This snippet demonstrates using multiple reporters simultaneously. It shows how to include multiple reporters in the `reporters` array within the `test` configuration.  This will output the test results in different formats.  In the example, it configures both JSON and the default reporter.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/reporters.md#_snippet_5\n\nLANGUAGE: ts\nCODE:\n```\nexport default defineConfig({\n  test: {\n    reporters: ['json', 'default'],\n    outputFile: './test-output.json'\n  },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Verifying the Last Resolved Value of an Async Function Using toHaveLastResolvedWith\nDESCRIPTION: This snippet demonstrates asserting the last resolved value of an async function after multiple calls, involving `await` on each call and matching the result to expected data.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_36\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { expect, test, vi } from 'vitest'\n\ntest('spy function resolves bananas on a last call', async () => {\n  const sell = vi.fn((product: string) => Promise.resolve({ product }))\n\n  await sell('apples')\n  await sell('bananas')\n\n  expect(sell).toHaveLastResolvedWith({ product: 'bananas' })\n})\n```\n\n----------------------------------------\n\nTITLE: Using assert.notNestedPropertyVal in Vitest (TypeScript)\nDESCRIPTION: Demonstrates `assert.notNestedPropertyVal`, asserting that an object either lacks a nested property or has it with a different value (using strict equality). The example imports from `vitest` and shows checks for incorrect values or non-existent paths within a test.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_65\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.notNestedPropertyVal', () => {\n  assert.notNestedPropertyVal({ tea: { green: 'matcha' } }, 'tea.green', 'konacha')\n  assert.notNestedPropertyVal({ tea: { green: 'matcha' } }, 'coffee.green', 'matcha')\n})\n```\n\n----------------------------------------\n\nTITLE: TestCollection Array Method\nDESCRIPTION: Defines a function `array` that returns the TestCollection as an array of TestCase or TestSuite objects.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/test-collection.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nfunction array(): (TestCase | TestSuite)[]\n```\n\n----------------------------------------\n\nTITLE: Asserting Nested Property Inclusion using Vitest (TypeScript)\nDESCRIPTION: Shows how to use `assert.nestedInclude` in Vitest tests to check for the inclusion of nested properties in objects using dot and bracket notation. Special characters '.' and '[]' in keys need double backslash escaping. Imports `assert` and `test`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_46\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.nestedInclude', () => {\n  assert.nestedInclude({ '.a': { b: 'x' } }, { '\\\\.a.[b]': 'x' })\n  assert.nestedInclude({ a: { '[b]': 'x' } }, { 'a.\\\\[b\\\\]': 'x' })\n})\n```\n\n----------------------------------------\n\nTITLE: Migrating Jest Timeout to Vitest Configuration with TypeScript\nDESCRIPTION: Demonstrates replacing jest.setTimeout with the Vitest configuration API vi.setConfig. Ensures test timeouts are properly set for async tests. Requires Vitest and TypeScript; vi must be available in scope. Input: timeout value in milliseconds; Output: updated test timeout configuration.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/migration.md#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\njest.setTimeout(5_000) // [!code --]\nvi.setConfig({ testTimeout: 5_000 }) // [!code ++]\n```\n\n----------------------------------------\n\nTITLE: Enabling Typechecking with Vitest\nDESCRIPTION: This snippet shows how to enable typechecking in a Vitest project by adding the `--typecheck` flag to the Vitest command in the `package.json` file.  This configures Vitest to run type checking during tests.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/testing-types.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"scripts\": {\n    \"test\": \"vitest --typecheck\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Example Vitest Test Output\nDESCRIPTION: Displays sample output generated by Vitest after successfully running tests. It shows the test file name, the individual test description, a summary of passed tests, and the execution duration.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/index.md#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\n✓ sum.test.js (1)\n  ✓ adds 1 + 2 to equal 3\n\nTest Files  1 passed (1)\n     Tests  1 passed (1)\n  Start at  02:15:44\n  Duration  311ms\n```\n\n----------------------------------------\n\nTITLE: Asserting Object Is Not Sealed with Vitest - TypeScript\nDESCRIPTION: Asserts that an object is not sealed, i.e., new properties can be added or existing ones removed. Accepts the target object and an optional message, using Vitest's isNotSealed method. Applies to mutable objects and ensures object structure remains flexible.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_117\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.isNotSealed', () => {\n  assert.isNotSealed({})\n})\n```\n\n----------------------------------------\n\nTITLE: Using Scoped Values with Database Connections in Vitest\nDESCRIPTION: Example of using test.scoped API to provide different database schema configurations to different test suites.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/test-context.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nconst test = baseTest.extend<{\n  db: Database\n  schema: string\n}>({\n  db: async ({ schema }, use) => {\n    const db = await createDb({ schema })\n    await use(db)\n    await cleanup(db)\n  },\n  schema: '',\n})\n\ndescribe('one type of schema', () => {\n  test.scoped({ schema: 'schema-1' })\n\n  // ... tests\n})\n\ndescribe('another type of schema', () => {\n  test.scoped({ schema: 'schema-2' })\n\n  // ... tests\n})\n```\n\n----------------------------------------\n\nTITLE: Running Vitest Tests with multiple projects via bun\nDESCRIPTION: This code snippet describes how to run tests for multiple specific projects within a Vitest workspace using the `--project` CLI option in conjunction with bun. In this example projects `e2e` and `unit` are specified.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/workspace.md#_snippet_17\n\nLANGUAGE: Bash\nCODE:\n```\nbun run test --project e2e --project unit\n```\n\n----------------------------------------\n\nTITLE: Deep Ordered Members Equality Check (TypeScript)\nDESCRIPTION: Defines `assert.sameDeepOrderedMembers` to compare arrays of objects for deep equality in the same order. Demonstrates with objects.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_89\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\n test('assert.sameDeepOrderedMembers', () => {\n  assert.sameDeepOrderedMembers([{ a: 1 }, { b: 2 }, { c: 3 }], [{ a: 1 }, { b: 2 }, { c: 3 }], 'same deep ordered members')\n})\n```\n\n----------------------------------------\n\nTITLE: HTML Context for toHaveClass Usage - HTML\nDESCRIPTION: Provides HTML markup for two buttons: one with multiple classes and one with no classes. These elements serve as test fixtures for toHaveClass assertions. No dependencies beyond basic HTML. Test IDs allow selection of elements in the TypeScript testing code.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_17\n\nLANGUAGE: HTML\nCODE:\n```\n<button data-testid=\"delete-button\" class=\"btn extra btn-danger\">\n  Delete item\n</button>\n<button data-testid=\"no-classes\">No Classes</button>\n```\n\n----------------------------------------\n\nTITLE: Asserting Deep Nested Property Inclusion using Vitest (TypeScript)\nDESCRIPTION: Demonstrates `assert.deepNestedInclude` in Vitest tests to check for nested properties using dot/bracket notation (with escaping) and deep equality comparison. Depends on `assert` and `test`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_48\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.deepNestedInclude', () => {\n  assert.deepNestedInclude({ a: { b: [{ x: 1 }] } }, { 'a.b[0]': { x: 1 } })\n  assert.deepNestedInclude({ '.a': { '[b]': { x: 1 } } }, { '\\\\.a.\\\\[b\\\\]': { x: 1 } })\n})\n```\n\n----------------------------------------\n\nTITLE: Using assert.notPropertyVal in Vitest (TypeScript)\nDESCRIPTION: Demonstrates `assert.notPropertyVal`, asserting that an object either doesn't have a property or has it with a different value than specified, using strict equality (===). The example imports from `vitest` and shows two cases within a test: checking for a different value and checking for a non-existent property.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_59\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.notPropertyVal', () => {\n  assert.notPropertyVal({ tea: 'is good' }, 'tea', 'is bad')\n  assert.notPropertyVal({ tea: 'is good' }, 'coffee', 'is good')\n})\n```\n\n----------------------------------------\n\nTITLE: Inspecting Mock Settled Promise Results with mock.settledResults (TypeScript/JavaScript)\nDESCRIPTION: The `mock.settledResults` property tracks the settled outcomes (fulfilled or rejected) of promises returned by the mock function. It's an array of objects, each with a `type` ('fulfilled' or 'rejected') and the corresponding resolved `value` or rejection reason. This array populates only after the promises have settled.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/mock.md#_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\ninterface MockSettledResultFulfilled<T> {\n  type: 'fulfilled'\n  value: T\n}\n\ninterface MockSettledResultRejected {\n  type: 'rejected'\n  value: any\n}\n\nexport type MockSettledResult<T> =\n  | MockSettledResultFulfilled<T>\n  | MockSettledResultRejected\n\nconst settledResults: MockSettledResult<Awaited<ReturnType<T>>>[]\n```\n\nLANGUAGE: javascript\nCODE:\n```\nconst fn = vi.fn().mockResolvedValueOnce('result')\n\nconst result = fn()\n\nfn.mock.settledResults === []\n\nawait result\n\nfn.mock.settledResults === [\n  {\n    type: 'fulfilled',\n    value: 'result',\n  },\n]\n```\n\n----------------------------------------\n\nTITLE: Matching Types with Vitest Matcher in TypeScript\nDESCRIPTION: Applies `.toMatchTypeOf` to verify if a value's type extends or is compatible with another type. Depends on `vitest` and requires TypeScript type analysis. Accepts values or union types and checks for structural compatibility rather than strict equality, facilitating flexible type match assertions in tests.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect-typeof.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf({ a: 1, b: 1 }).toMatchTypeOf({ a: 1 })\nexpectTypeOf<number>().toMatchTypeOf<string | number>()\nexpectTypeOf<string | number>().not.toMatchTypeOf<number>()\n```\n\n----------------------------------------\n\nTITLE: Configuring Workspace with Injected Fixtures in Vitest\nDESCRIPTION: Example of defining a workspace configuration that provides different values for injected fixtures across multiple test projects.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/test-context.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineWorkspace } from 'vitest/config'\n\nexport default defineWorkspace([\n  {\n    test: {\n      name: 'project-new',\n    },\n  },\n  {\n    test: {\n      name: 'project-full',\n      provide: {\n        url: '/full',\n      },\n    },\n  },\n  {\n    test: {\n      name: 'project-empty',\n      provide: {\n        url: '/empty',\n      },\n    },\n  },\n])\n```\n\n----------------------------------------\n\nTITLE: Deep Ordered Subset Not Present (TypeScript)\nDESCRIPTION: Defines `assert.notIncludeDeepOrderedMembers` to verify that `subset` does not appear in `superset` in order with deep comparison; includes multiple negative tests.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_98\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\n test('assert.includeDeepOrderedMembers', () => {\n  assert.notIncludeDeepOrderedMembers([{ a: 1 }, { b: 2 }, { c: 3 }], [{ a: 1 }, { f: 5 }], 'not include deep ordered members')\n  assert.notIncludeDeepOrderedMembers([{ a: 1 }, { b: 2 }, { c: 3 }], [{ b: 2 }, { a: 1 }], 'not include deep ordered members')\n  assert.notIncludeDeepOrderedMembers([{ a: 1 }, { b: 2 }, { c: 3 }], [{ b: 2 }, { c: 3 }], 'not include deep ordered members')\n})\n```\n\n----------------------------------------\n\nTITLE: Integrating Vitest Configuration into Vite (vite.config.ts)\nDESCRIPTION: Shows how to add Vitest configuration directly into an existing `vite.config.ts` file by adding a `test` property to the `defineConfig` object. It requires adding a triple-slash directive `/// <reference types=\"vitest\" />` for TypeScript type support.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/index.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n/// <reference types=\"vitest\" />\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  test: {\n    // ...\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Ordered Members Inequality Assertion (TypeScript)\nDESCRIPTION: Defines `assert.notSameOrderedMembers` to verify two arrays do not have the same elements in order. The test case demonstrates mismatch detection.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_88\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\n test('assert.notSameOrderedMembers', () => {\n  assert.notSameOrderedMembers([1, 2, 3], [2, 1, 3], 'not same ordered members')\n})\n```\n\n----------------------------------------\n\nTITLE: Using MockerRegistry and ManualMockedModule for Manual Mock Registration - TypeScript\nDESCRIPTION: Illustrates the manual registration and retrieval of mocked modules via MockerRegistry. Involves import of MockerRegistry and ManualMockedModule from @vitest/mocker and registering a module with associated meta-data and a factory. Supports improved error reporting through original ID association and custom cache management.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/mocker/EXPORTS.md#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { ManualMockedModule, MockerRegistry } from '@vitest/mocker'\nconst registry = new MockerRegistry()\n\n// Vitest requites the original ID for better error messages,\n// You can pass down anything related to the module there\nregistry.register('manual', './id.js', '/users/custom/id.js', factory)\nregistry.get('/users/custom/id.js') instanceof ManualMockedModule\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of vi.hoisted: Accessing Hoisted Variables (TypeScript)\nDESCRIPTION: Demonstrates an incorrect usage pattern for `vi.hoisted`. Accessing variables (like `value`) from static imports within the `vi.hoisted` factory function will throw an initialization error because the static imports haven't been evaluated and assigned yet when the hoisted code runs.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_34\n\nLANGUAGE: typescript\nCODE:\n```\nimport { value } from './some/module.js'\n\nvi.hoisted(() => { value }) // throws an error // [!code warning]\n```\n\n----------------------------------------\n\nTITLE: Deep Automocking of Objects with mockObject - TypeScript\nDESCRIPTION: Demonstrates deep mocking of a provided object, supporting custom spyOn implementations and explicit global constructor injection for use in custom virtual machine contexts. Requires @vitest/mocker and @vitest/spy, and supports configuration between automock and autospy modes. Suitable for advanced testing scenarios with nested mocks.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/mocker/EXPORTS.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { mockObject } from '@vitest/mocker'\nimport { spyOn } from '@vitest/spy'\n\nmockObject(\n  {\n    // this is needed because it can be used in vm context\n    globalConstructors: {\n      Object,\n      // ...\n    },\n    // you can provide your own spyOn implementation\n    spyOn,\n    mockType: 'automock' // or 'autospy'\n  },\n  {\n    myDeep: {\n      object() {\n        return {\n          willAlso: {\n            beMocked() {\n              return true\n            },\n          },\n        }\n      },\n    },\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Test Specifications by Module ID in Vitest (TypeScript)\nDESCRIPTION: Returns an array of `TestSpecification` objects for a given absolute module ID. It utilizes a cache, which requires `globTestSpecifications` to be called at least once (since Vitest 3) to populate. Returns an empty array if the ID doesn't match configured include patterns.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/vitest.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nfunction getModuleSpecifications(moduleId: string): TestSpecification[]\n```\n\n----------------------------------------\n\nTITLE: Assertion for Non-Throwing Functions in Vitest (TypeScript)\nDESCRIPTION: Defines `assert.doesNotThrow` to verify that a function does not throw an error of a specified type or message. It supports checking against error constructors, specific error instances, and message matchers. The snippet demonstrates its usage within a test case.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_80\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\n test('assert.doesNotThrow', () => {\n  assert.doesNotThrow(fn, 'Any Error thrown must not have this message')\n  assert.doesNotThrow(fn, /Any Error thrown must not match this/)\n  assert.doesNotThrow(fn, Error)\n  assert.doesNotThrow(fn, errorInstance)\n  assert.doesNotThrow(fn, Error, 'Error must not have this message')\n  assert.doesNotThrow(fn, errorInstance, 'Error must not have this message')\n  assert.doesNotThrow(fn, Error, /Error must not match this/)\n  assert.doesNotThrow(fn, errorInstance, /Error must not match this/)\n})\n```\n\n----------------------------------------\n\nTITLE: Assert Value is Not Null with Vitest\nDESCRIPTION: This snippet demonstrates `assert.isNotNull`, which asserts that a value is not null. It requires the `vitest` framework.  The input is a value, and the assertion passes when the value is not null.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_18\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\nconst error = { message: 'error was occurred' }\n\ntest('assert.isNotNull', () => {\n  assert.isNotNull(error, 'error is not null but object')\n})\n```\n\n----------------------------------------\n\nTITLE: Using vi.waitFor with Asynchronous Callback in Vitest (TypeScript)\nDESCRIPTION: Illustrates using `vi.waitFor` with an asynchronous callback function to wait for a DOM element to appear and meet specific criteria (checked via `expect`). It uses `async/await` within the callback and configures `timeout` and `interval`. This pattern is suitable for waiting on asynchronous DOM updates. Requires `@vitest-environment jsdom`. Dependencies include `vitest` (`expect`, `test`, `vi`) and hypothetical async DOM functions (`getDOMElementAsync`, `populateDOMAsync`) from './dom.js'.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_30\n\nLANGUAGE: typescript\nCODE:\n```\n// @vitest-environment jsdom\n\nimport { expect, test, vi } from 'vitest'\nimport { getDOMElementAsync, populateDOMAsync } from './dom.js'\n\ntest('Element exists in a DOM', async () => {\n  // start populating DOM\n  populateDOMAsync()\n\n  const element = await vi.waitFor(async () => {\n    // try to get the element until it exists\n    const element = await getDOMElementAsync() as HTMLElement | null\n    expect(element).toBeTruthy()\n    expect(element.dataset.initialized).toBeTruthy()\n    return element\n  }, {\n    timeout: 500, // default is 1000\n    interval: 20, // default is 50\n  })\n  expect(element).toBeInstanceOf(HTMLElement)\n})\n```\n\n----------------------------------------\n\nTITLE: Registering a Handler for Vitest Server Restarts (TypeScript)\nDESCRIPTION: Registers a callback function (`OnServerRestartHandler`) that will be invoked when the Vitest server restarts, usually triggered by changes in configuration files.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/vitest.md#_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\nfunction onServerRestart(fn: OnServerRestartHandler): void\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Test Pool in Vitest\nDESCRIPTION: This code snippet demonstrates how to configure a custom test pool in Vitest using the `vitest.config.ts` file. It sets the `pool` option to specify the path to the custom pool file and the `poolOptions` object to provide custom properties. This configuration allows Vitest to use the defined custom pool for running tests.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/pool.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts [vitest.config.ts]\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    // will run every file with a custom pool by default\n    pool: './my-custom-pool.ts',\n    // you can provide options using `poolOptions` object\n    poolOptions: {\n      myCustomPool: {\n        customProperty: true,\n      },\n    },\n  },\n})\n```\n```\n\n----------------------------------------\n\nTITLE: TSX example demonstrating `selected` option for `getByRole`\nDESCRIPTION: This TSX snippet demonstrates how to use the `selected` option with `getByRole` to filter elements based on their selected state (aria-selected). It includes an example using a button with role tab and the aria-selected attribute. Requires a TSX environment that supports JSX syntax. No external dependencies needed other than a rendering context for the TSX.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_10\n\nLANGUAGE: tsx\nCODE:\n```\n<button role=\"tab\" aria-selected=\"true\">Vue</button>\n\npage.getByRole('button', { selected: true }) // ✅\npage.getByRole('button', { selected: false }) // ❌\n```\n\n----------------------------------------\n\nTITLE: Using Dynamic Import Inside vi.hoisted in Vitest (TypeScript)\nDESCRIPTION: Shows the workaround for accessing module variables needed within `vi.hoisted`. It uses `await import()` *inside* the `vi.hoisted` async factory function. However, this pattern is generally discouraged because if access to imported values is needed, the setup logic might be better placed within the imported module itself.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_35\n\nLANGUAGE: typescript\nCODE:\n```\nawait vi.hoisted(async () => {\n  const { value } = await import('./some/module.js')\n})\n```\n\n----------------------------------------\n\nTITLE: Using assert.nestedPropertyVal in Vitest (TypeScript)\nDESCRIPTION: Shows how to use `assert.nestedPropertyVal` to assert that an object has a nested property (using dot/bracket notation) with a specific value, using strict equality (===). The example imports from `vitest` and verifies the value of 'tea.green' within a test.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_64\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.nestedPropertyVal', () => {\n  assert.nestedPropertyVal({ tea: { green: 'matcha' } }, 'tea.green', 'matcha')\n})\n```\n\n----------------------------------------\n\nTITLE: Set Non-Membership Assertion with Different Members (TypeScript)\nDESCRIPTION: Defines `assert.notSameMembers` to assert that two arrays have different members. Uses strict equality for member comparison.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_84\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\n test('assert.sameMembers', () => {\n  assert.notSameMembers([1, 2, 3], [5, 1, 3], 'not same members')\n})\n```\n\n----------------------------------------\n\nTITLE: Deprecated poolMatchGlobs - TypeScript\nDESCRIPTION: This snippet demonstrates the deprecated `poolMatchGlobs` option in Vitest, which is now replaced by the `workspace` configuration. It shows how to migrate from using `poolMatchGlobs` to defining pool configurations within a workspace.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_19\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport default defineConfig({\n  test: {\n    poolMatchGlobs: [ // [!code --]\n      ['./*.threads.test.ts', 'threads'], // [!code --]\n    ], // [!code --]\n    workspace: [ // [!code ++]\n      { // [!code ++]\n        test: { // [!code ++]\n          extends: true, // [!code ++]\n          pool: 'threads', // [!code ++]\n        }, // [!code ++]\n      }, // [!code ++]\n    ], // [!code ++]\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Assert Value is Null with Vitest\nDESCRIPTION: This snippet uses `assert.isNull`, which asserts that a value is null. It uses the `vitest` framework. The input is a value, and the assertion passes only when the value is null.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_17\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\nconst error = null\n\ntest('assert.isNull', () => {\n  assert.isNull(error, 'error is null')\n})\n```\n\n----------------------------------------\n\nTITLE: Running Concurrent Snapshot Tests in Vitest\nDESCRIPTION: Example showing how to run snapshot tests concurrently using the context-bound expect to ensure proper tracking.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/test-context.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { it } from 'vitest'\n\nit.concurrent('math is easy', ({ expect }) => {\n  expect(2 + 2).toMatchInlineSnapshot()\n})\n\nit.concurrent('math is hard', ({ expect }) => {\n  expect(2 * 2).toMatchInlineSnapshot()\n})\n```\n\n----------------------------------------\n\nTITLE: Accessing Custom Test Metadata in a Vitest Custom Reporter (TypeScript)\nDESCRIPTION: This example demonstrates how to implement a custom Vitest reporter to consume the meta field of test cases and modules after test execution completes. Importing types for Reporter, TestCase, and TestModule from \"vitest/node\", the reporter exposes onTestCaseResult and onTestRunEnd hooks, accessing custom metadata properties previously set during test execution. No external dependencies are required aside from Vitest. Parameters include testCase and testModule objects, both supplying a meta() method returning the metadata object. The expected output is the ability to access previously set metadata for further processing or reporting.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/metadata.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { Reporter, TestCase, TestModule } from 'vitest/node'\n\nexport default {\n  onTestCaseResult(testCase: TestCase) {\n    // custom === 'some-custom-handler' ✅\n    const { custom } = testCase.meta()\n  },\n  onTestRunEnd(testModule: TestModule) {\n    testModule.meta().done === true\n    testModule.children.at(0).meta().custom === 'some-custom-handler'\n  }\n} satisfies Reporter\n```\n\n----------------------------------------\n\nTITLE: Asserting One Mock Function Was Called Before Another in Vitest\nDESCRIPTION: Demonstrates using `.toHaveBeenCalledBefore()` to assert the call order of two different mock functions created with `vi.fn()`. It verifies that the first mock was invoked at least once before the second mock's first invocation.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_23\n\nLANGUAGE: ts\nCODE:\n```\ntest('calls mock1 before mock2', () => {\n  const mock1 = vi.fn()\n  const mock2 = vi.fn()\n\n  mock1()\n  mock2()\n  mock1()\n\n  expect(mock1).toHaveBeenCalledBefore(mock2)\n})\n```\n\n----------------------------------------\n\nTITLE: Asserting Array Item Types with Vitest in TypeScript\nDESCRIPTION: Applies `.items` to extract and assert the type of elements inside arrays. Requires Vitest and works with array literals or typed arrays, supporting positive and negative assertions about contained types.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect-typeof.md#_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf([1, 2, 3]).items.toEqualTypeOf<number>()\nexpectTypeOf([1, 2, 3]).items.not.toEqualTypeOf<string>()\n```\n\n----------------------------------------\n\nTITLE: TSX example demonstrating `expanded` option for `getByRole`\nDESCRIPTION: This TSX snippet demonstrates how to use the `expanded` option with `getByRole` to filter elements based on their expanded state (aria-expanded). It includes examples using an anchor element. Requires a TSX environment that supports JSX syntax. No external dependencies needed other than a rendering context for the TSX.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\n<a aria-expanded=\"true\" href=\"example.com\">Link</a>\n\npage.getByRole('link', { expanded: true }) // ✅\npage.getByRole('link', { expanded: false }) // ❌\n```\n\n----------------------------------------\n\nTITLE: Iterating allTests in TestCollection\nDESCRIPTION: This code snippet demonstrates iterating over all tests within a module's children (TestCollection) and checking if any tests have a 'pending' result state, logging their full name if they do.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/test-collection.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nfor (const test of module.children.allTests()) {\n  if (test.result().state === 'pending') {\n    console.log('test', test.fullName, 'did not finish')\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Specify default coverage.watermarks in TypeScript\nDESCRIPTION: Provides the default value for the `coverage.watermarks` configuration option. It sets the default low watermark to 50 and the high watermark to 80 for statements, functions, branches, and lines coverage metrics.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_32\n\nLANGUAGE: ts\nCODE:\n```\n{\n  statements: [50, 80],\n  functions: [50, 80],\n  branches: [50, 80],\n  lines: [50, 80]\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring console.log handler in Vitest (TypeScript)\nDESCRIPTION: Demonstrates how to configure a custom handler for `console.log` in Vitest to filter out specific messages.  It shows how to define a function that receives the log message and its type, and returns a boolean indicating whether Vitest should print the log to the console. Requires `vitest/config` dependency.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_37\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    onConsoleLog(log: string, type: 'stdout' | 'stderr'): boolean | void {\n      return !(log === 'message from third party library' && type === 'stdout')\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Using onTestRunStart Reporter Hook in Vitest with TypeScript\nDESCRIPTION: Illustrates a reporter implementing the onTestRunStart method to log the number of test files scheduled to run. Requires types from 'vitest/node' for Reporter and TestSpecification. The specifications array is readonly and informational. Useful for monitoring or logging at the start of a test run.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/reporters.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { Reporter, TestSpecification } from 'vitest/node'\n\nclass MyReporter implements Reporter {\n  onTestRunStart(specifications: TestSpecification[]) {\n    console.log(specifications.length, 'test files will run')\n  }\n}\n\nexport default new MyReporter()\n```\n\n----------------------------------------\n\nTITLE: Extending Custom Test Fixtures in Vitest\nDESCRIPTION: Example of adding more fixtures or overriding existing fixtures by extending a custom test object.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/test-context.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport const myTest2 = myTest.extend({\n  settings: {\n    // ...\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Array Inclusion of Members Not Present (TypeScript)\nDESCRIPTION: Defines `assert.notIncludeMembers` to assert that `subset` elements are not all contained within `superset`. Uses strict equality.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_92\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\n test('assert.notIncludeMembers', () => {\n  assert.notIncludeMembers([1, 2, 3], [5, 1], 'not include members')\n})\n```\n\n----------------------------------------\n\nTITLE: Deep Members Equality Assertion (TypeScript)\nDESCRIPTION: Defines `assert.sameDeepMembers` to compare arrays of objects for deep equality, regardless of order. The test case demonstrates deep comparison of object arrays.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_85\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\n test('assert.sameDeepMembers', () => {\n  assert.sameDeepMembers([{ a: 1 }, { b: 2 }, { c: 3 }], [{ b: 2 }, { a: 1 }, { c: 3 }], 'same deep members')\n})\n```\n\n----------------------------------------\n\nTITLE: Defining SnapshotEnvironment Interface in TypeScript\nDESCRIPTION: Defines the SnapshotEnvironment interface outlining methods required for custom snapshot environment implementations in Vitest. This interface includes methods to get version and header strings, resolve snapshot file paths asynchronously, and read, write, and delete snapshot files. This interface is essential for advanced use cases where Node.js APIs are unavailable, allowing extension or replacement of Vitest's default snapshot handling behavior.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_41\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface SnapshotEnvironment {\n  getVersion: () => string\n  getHeader: () => string\n  resolvePath: (filepath: string) => Promise<string>\n  resolveRawPath: (testPath: string, rawPath: string) => Promise<string>\n  saveSnapshotFile: (filepath: string, snapshot: string) => Promise<void>\n  readSnapshotFile: (filepath: string) => Promise<string | null>\n  removeSnapshotFile: (filepath: string) => Promise<void>\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Partially Checked State of Checkbox Elements - TypeScript\nDESCRIPTION: The `toBePartiallyChecked` function asynchronously asserts if a checkbox input or an element with role 'checkbox' is partially checked. It supports inputs with `indeterminate` property set to true or an ARIA attribute `aria-checked=\"mixed\"`. The snippet provides HTML with such mixed and indeterminate states and usage examples demonstrating how to assert partial checks.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_34\n\nLANGUAGE: typescript\nCODE:\n```\nfunction toBePartiallyChecked(): Promise<void>\n```\n\n----------------------------------------\n\nTITLE: Enabling Snapshot Update Mode in Vitest (TypeScript)\nDESCRIPTION: Enables a mode where snapshots will be automatically updated during subsequent test runs (e.g., via `runTestSpecifications`). This method does not trigger a test run itself. Use `resetSnapshotUpdate` to disable this mode.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/vitest.md#_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nfunction enableSnapshotUpdate(): void\n```\n\n----------------------------------------\n\nTITLE: Assert Value is Not Function with Vitest\nDESCRIPTION: This snippet demonstrates `assert.isNotFunction` (and its alias `isNotCallable`), which checks if a value is not a function. It uses the `vitest` framework. The input is a value, and the test passes if the value is not a function.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_26\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\nconst name = 'foo'\n\ntest('assert.isNotFunction', () => {\n  assert.isNotFunction(name, 'name is not function but string')\n})\n```\n\n----------------------------------------\n\nTITLE: Rerunning Test Specifications with Watcher Events in Vitest (TypeScript)\nDESCRIPTION: Reruns tests based on the provided `TestSpecification` array, emitting watcher events (`reporter.onWatcherRerun`, `onTestsRerun`, `reporter.onWatcherStart`) before executing the tests via `runTestSpecifications`. Suitable for scenarios like file changes in watch mode.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/vitest.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nfunction rerunTestSpecifications(\n  specifications: TestSpecification[],\n  allTestsRun = false\n): Promise<TestRunResult>\n```\n\n----------------------------------------\n\nTITLE: ModuleDiagnostic Interface Definition (TypeScript)\nDESCRIPTION: Defines the shape of the ModuleDiagnostic object returned by TestModule's diagnostic method. Contains read-only properties capturing environment setup time, prepare time, module collection time, setup time, total duration, and heap usage, some of which may only be available if executed with specific flags. Provides consumers with collectible performance statistics of the test module. No additional dependencies are required.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/test-module.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\ninterface ModuleDiagnostic {\n  /**\n   * The time it takes to import and initiate an environment.\n   */\n  readonly environmentSetupDuration: number\n  /**\n   * The time it takes Vitest to setup test harness (runner, mocks, etc.).\n   */\n  readonly prepareDuration: number\n  /**\n   * The time it takes to import the test module.\n   * This includes importing everything in the module and executing suite callbacks.\n   */\n  readonly collectDuration: number\n  /**\n   * The time it takes to import the setup module.\n   */\n  readonly setupDuration: number\n  /**\n   * Accumulated duration of all tests and hooks in the module.\n   */\n  readonly duration: number\n  /**\n   * The amount of memory used by the module in bytes.\n   * This value is only available if the test was executed with `logHeapUsage` flag.\n   */\n  readonly heap: number | undefined\n}\n```\n\n----------------------------------------\n\nTITLE: filter.hasNot - Exclude Elements Containing Certain Child Elements\nDESCRIPTION: Filters parent elements to exclude those containing child elements matching a specified locator, helping refine searches to elements lacking certain nested content.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_27\n\nLANGUAGE: TypeScript\nCODE:\n```\nhasNot: Locator\n```\n\n----------------------------------------\n\nTITLE: Object Property Change by Specific Amount (TypeScript)\nDESCRIPTION: Defines `assert.changesBy` to verify a change in an object property by a specific delta after executing a modifier function.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_101\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\n test('assert.changesBy', () => {\n  const obj = { val: 10 }\n  function fn() { obj.val += 2 };\n  assert.changesBy(fn, obj, 'val', 2)\n})\n```\n\n----------------------------------------\n\nTITLE: Fixture Initialization Based on Usage in Vitest\nDESCRIPTION: Example showing how Vitest runner smartly initializes fixtures and injects them into the test context based on usage.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/test-context.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { test } from 'vitest'\n\nasync function todosFn({ task }, use) {\n  await use([1, 2, 3])\n}\n\nconst myTest = test.extend({\n  todos: todosFn,\n  archive: []\n})\n\n// todosFn will not run\nmyTest('', () => {})\nmyTest('', ({ archive }) => {})\n\n// todosFn will run\nmyTest('', ({ todos }) => {})\n```\n\n----------------------------------------\n\nTITLE: Matching Partial Object Shape Against Inline Snapshot in Vitest\nDESCRIPTION: Shows how to combine `.toMatchInlineSnapshot()` with a shape argument and an inline snapshot string. This allows testing specific structural properties of an object against an embedded snapshot, useful when the full object content isn't relevant.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_18\n\nLANGUAGE: ts\nCODE:\n```\nimport { expect, test } from 'vitest'\n\ntest('matches snapshot', () => {\n  const data = { foo: new Set(['bar', 'snapshot']) }\n  expect(data).toMatchInlineSnapshot(\n    { foo: expect.any(Set) },\n    `\n    {\n      \"foo\": Any<Set>,\n    }\n  `\n  )\n})\n```\n\n----------------------------------------\n\nTITLE: TSX example demonstrating `includeHidden` option for `getByRole`\nDESCRIPTION: This TSX snippet demonstrates how to use the `includeHidden` option with `getByRole` to include or exclude hidden elements in the search. It includes examples using a button with `display: none`. Requires a TSX environment that supports JSX syntax. No external dependencies needed other than a rendering context for the TSX.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\n<button style=\"display: none\" />\n\npage.getByRole('button') // ❌\npage.getByRole('button', { includeHidden: false }) // ❌\npage.getByRole('button', { includeHidden: true }) // ✅\n```\n\n----------------------------------------\n\nTITLE: Using assert.notDeepPropertyVal in Vitest (TypeScript)\nDESCRIPTION: Shows the usage of `assert.notDeepPropertyVal`. This method asserts that an object either doesn't have a property or has it with a value that is not deeply equal to the specified value. The example imports from `vitest` and demonstrates various failing conditions within a test.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_61\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.deepPropertyVal', () => { // Note: Test name seems incorrect in original text, likely should be assert.notDeepPropertyVal\n  assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { black: 'matcha' })\n  assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'oolong' })\n  assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'coffee', { green: 'matcha' })\n})\n```\n\n----------------------------------------\n\nTITLE: Defining TestResultPending Interface for Awaiting Tests in Vitest (TypeScript)\nDESCRIPTION: This code defines the TestResultPending TypeScript interface, representing the shape of result() output before the test has executed in Vitest. It includes a 'pending' state and indicates there are no errors. Used internally by result(); no dynamic input required.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/test-case.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface TestResultPending {\n  /**\n   * The test was collected, but didn't finish running yet.\n   */\n  readonly state: 'pending'\n  /**\n   * Pending tests have no errors.\n   */\n  readonly errors: undefined\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring selectOptions Function in Vitest (TypeScript)\nDESCRIPTION: Defines the selectOptions function for interacting with <select> elements, allowing selection by string, HTMLElement(s), or Locator(s). Takes a flexible values argument and optional UserEventSelectOptions; returns a resolved Promise when selection is completed. Useful for automating dropdown and multi-select UI components; requires that corresponding option elements are present and unique.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_42\n\nLANGUAGE: typescript\nCODE:\n```\nfunction selectOptions(\n  values:\n    | HTMLElement\n    | HTMLElement[]\n    | Locator\n    | Locator[]\n    | string\n    | string[],\n  options?: UserEventSelectOptions,\n): Promise<void>\n```\n\n----------------------------------------\n\nTITLE: Handling Test Suite Readiness Event in Vitest - TypeScript\nDESCRIPTION: Defines the `onTestSuiteReady` function which is called asynchronously before a test suite starts running its tests, or if the suite was skipped. It receives a `TestSuite` instance as a parameter. This callback is only invoked if the suite exists in the file being tested; if no suites are present, it will not be called, and `onTestModuleStart` should be used instead to handle modules without suites.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/reporters.md#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction onTestSuiteReady(testSuite: TestSuite): Awaitable<void>\n```\n\n----------------------------------------\n\nTITLE: Asserting Object Is Frozen with Vitest - TypeScript\nDESCRIPTION: Checks whether an object is frozen (immutable: no property modification, addition, or deletion) with Vitest. Takes the object (e.g., from Object.freeze) and an optional message. Validates data immutability for critical object states.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_118\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.isFrozen', () => {\n  const frozenObject = Object.freeze({})\n  assert.frozen(frozenObject)\n})\n```\n\n----------------------------------------\n\nTITLE: Asserting Property Change But Not By Specific Value with Vitest - TypeScript\nDESCRIPTION: This snippet ensures that the modifier function does not change an object's property by a specific amount. It uses Vitest assertions, requiring the function to check, the target object, property key, change value, and an optional message. The function can change the property, but not by the forbidden value. Useful for negative testing of property modifications.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_103\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.changesButNotBy', () => {\n  const obj = { val: 10 }\n  function fn() { obj.val += 10 };\n  assert.changesButNotBy(fn, obj, 'val', 5)\n})\n```\n\n----------------------------------------\n\nTITLE: Asserting Null Types with Vitest in TypeScript\nDESCRIPTION: Asserts that a value or type is null using `.toBeNull`. Requires Vitest and works with null literals and assignments. Supports positive and negative assertions on possible nullable values.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect-typeof.md#_snippet_23\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf(null).toBeNull()\nexpectTypeOf<null>().toBeNull()\nexpectTypeOf(undefined).not.toBeNull()\n```\n\n----------------------------------------\n\nTITLE: Asserting Object Misses At Least One Key with Vitest (TypeScript)\nDESCRIPTION: Demonstrates using `assert.doesNotHaveAllKeys` in Vitest to verify that an object (or Map/Set) is missing at least one of the specified keys. Keys can be provided as an array of strings/objects or as the keys of another object. *Note: The example code incorrectly uses `assert.doesNotHaveAnyKeys`; it should use `assert.doesNotHaveAllKeys` as per the section title and description.*\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_73\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.hasAnyKeys', () => { // Test title might be a typo, context suggests doesNotHaveAllKeys\n  assert.doesNotHaveAnyKeys({ foo: 1, bar: 2, baz: 3 }, ['one', 'two', 'example']) // Should be assert.doesNotHaveAllKeys based on section title\n  assert.doesNotHaveAnyKeys({ foo: 1, bar: 2, baz: 3 }, { one: 1, two: 2, example: 'foo' }) // Should be assert.doesNotHaveAllKeys\n  assert.doesNotHaveAnyKeys(new Map([[{ foo: 1 }, 'bar'], ['key', 'value']]), [{ one: 'two' }, 'example']) // Should be assert.doesNotHaveAllKeys\n  assert.doesNotHaveAnyKeys(new Set([{ foo: 'bar' }, 'anotherKey']), [{ one: 'two' }, 'example']) // Should be assert.doesNotHaveAllKeys\n})\n```\n\n----------------------------------------\n\nTITLE: Updating Vitest Type Reference in Vite Config (Vitest 2.1+)\nDESCRIPTION: Demonstrates the updated method for referencing Vitest types in `vite.config.ts` using `/// <reference types=\"vitest/config\" />`. This replaces the older `<reference types=\"vitest\" />` and is recommended for future compatibility.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/index.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n/// <reference types=\"vitest/config\" />\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  test: {\n    // ... Specify options here.\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Working with Selector Property for Custom Browser Commands (TypeScript)\nDESCRIPTION: Shows the use of the selector property for advanced command execution, specifically when building custom browser commands. Requires integration with vitest/node and @vitest/browser/context, and accepts selector strings for various browser providers (playwright, webdriverio). Demonstrates programmatic element location via raw selectors and the importance of not using them in standard test code.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_54\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { BrowserCommand } from 'vitest/node'\n\nconst test: BrowserCommand<string> = function test(context, selector) {\n  // playwright\n  await context.iframe.locator(selector).click()\n  // webdriverio\n  await context.browser.$(selector).click()\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { test } from 'vitest'\nimport { commands, page } from '@vitest/browser/context'\n\ntest('works correctly', async () => {\n  await commands.test(page.getByText('Hello').selector) // ✅\n  // vitest will automatically unwrap it to a string\n  await commands.test(page.getByText('Hello')) // ✅\n})\n```\n\n----------------------------------------\n\nTITLE: Updating Test Snapshots in Vitest (TypeScript)\nDESCRIPTION: Updates test snapshots. If an array of file paths (`files`) is provided, only snapshots in those files are updated. Otherwise, it updates snapshots in files with failed tests or obsolete snapshots. Returns a Promise resolving to a `TestRunResult`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/vitest.md#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nfunction updateSnapshot(files?: string[]): Promise<TestRunResult>\n```\n\n----------------------------------------\n\nTITLE: Defining TestResultSkipped Interface for Skipped Tests in Vitest (TypeScript)\nDESCRIPTION: This snippet declares the TestResultSkipped interface, which models the output of result() for a test that was skipped in Vitest. It includes a 'skipped' state, no errors, and an optional note explaining the skip. The note typically comes from ctx.skip(). All fields are readonly. No dynamic input; used for static typing.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/test-case.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\ninterface TestResultSkipped {\n  /**\n   * The test was skipped with `skip` or `todo` flag.\n   * You can see which one was used in the `options.mode` option.\n   */\n  readonly state: 'skipped'\n  /**\n   * Skipped tests have no errors.\n   */\n  readonly errors: undefined\n  /**\n   * A custom note passed down to `ctx.skip(note)`.\n   */\n  readonly note: string | undefined\n}\n```\n\n----------------------------------------\n\nTITLE: TypeScript: Identifying Suite Type in Vitest\nDESCRIPTION: Example snippet demonstrating how to check if a task object represents a TestSuite by inspecting its 'type' property, which should be 'suite'.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/test-suite.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nif (task.type === 'suite') {\n  task // TestSuite\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting Error Thrown with ifError using Vitest - TypeScript\nDESCRIPTION: This snippet demonstrates the use of assert.ifError to rethrow any truthy error object, making it compatible with Node's assert API. It requires Vitest, and the main parameter is the error object. The test expects the assertion to throw the error if present. Used for ensuring error presence propagates correctly during tests.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_113\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.ifError', () => {\n  const err = new Error('I am a custom error')\n  assert.ifError(err) // Rethrows err!\n})\n```\n\n----------------------------------------\n\nTITLE: Asserting Numeric Property Increase with Vitest - TypeScript\nDESCRIPTION: This code tests whether a modifier function increases a numeric property of an object when executed. Dependencies include the Vitest library. Key parameters are the modifier function, the object to modify, the property name, and an optional message. The assertion passes only if the property's value increases after running the modifier.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_104\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.increases', () => {\n  const obj = { val: 10 }\n  function fn() { obj.val = 13 };\n  assert.increases(fn, obj, 'val')\n})\n```\n\n----------------------------------------\n\nTITLE: Debugging Using Dumped Transformation Files (Bash)\nDESCRIPTION: Shows how to instruct `vite-node` to load and execute code from previously dumped files instead of performing transformation on the fly. Setting `VITE_NODE_DEBUG_DUMP=load` enables this mode, useful for debugging by modifying the dumped files.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/vite-node/README.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nVITE_NODE_DEBUG_DUMP=load vite-node example.ts\n```\n\n----------------------------------------\n\nTITLE: Checking Nullable Types with Vitest\nDESCRIPTION: The `toBeNullable()` matcher checks if a type can be `null` or `undefined`. It imports `expectTypeOf` from 'vitest'. The code tests several union types including null and undefined.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect-typeof.md#_snippet_25\n\nLANGUAGE: ts\nCODE:\n```\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf<undefined | 1>().toBeNullable()\nexpectTypeOf<null | 1>().toBeNullable()\nexpectTypeOf<undefined | null | 1>().toBeNullable()\n```\n\n----------------------------------------\n\nTITLE: Configuring Multiple Browser Instances - Minimal\nDESCRIPTION: This code snippet demonstrates the minimal configuration required to run Vitest tests in multiple browsers (Chromium, Firefox, and Webkit) using Playwright.  It enables the browser environment, sets the provider to 'playwright', enables headless mode, and defines an array of browser instances. Each instance specifies a different browser to run the tests in.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/multiple-setups.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\nexport default defineConfig({\n  test: {\n    browser: {\n      enabled: true,\n      provider: 'playwright',\n      headless: true,\n      instances: [\n        { browser: 'chromium' },\n        { browser: 'firefox' },\n        { browser: 'webkit' },\n      ],\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Handling Test Case Readiness Event in Vitest - TypeScript\nDESCRIPTION: Defines the `onTestCaseReady` function which is triggered asynchronously before an individual test case starts running or is skipped. It receives a `TestCase` object representing the test. This callback includes the time during `beforeEach` and `afterEach` hooks because those influence the test result. Notably, the test case's result may already be in a `passed` or `failed` state when this callback is called, which can occur if the test execution was very fast and both readiness and result handlers run in the same microtask.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/reporters.md#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction onTestCaseReady(testCase: TestCase): Awaitable<void>\n```\n\n----------------------------------------\n\nTITLE: Registering a Handler for Vitest Test Reruns (TypeScript)\nDESCRIPTION: Registers a callback function (`OnTestsRerunHandler`) that is invoked when tests are about to be rerun. This happens either manually via `rerunTestSpecifications` or automatically due to file changes when using the built-in watcher.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/vitest.md#_snippet_28\n\nLANGUAGE: typescript\nCODE:\n```\nfunction onTestsRerun(fn: OnTestsRerunHandler): void\n```\n\n----------------------------------------\n\nTITLE: Registering a Filter for Watched Test Specifications in Vitest (TypeScript)\nDESCRIPTION: This snippet demonstrates how to register a filter for watched test specifications using `vitest.onFilterWatchedSpecification`. The provided function determines whether a test file needs to be rerun based on changes. The example uses a custom wrapper to track enabled test runs and filters specifications based on their `moduleId`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/vitest.md#_snippet_29\n\nLANGUAGE: typescript\nCODE:\n```\nconst continuesTests: string[] = []\n\nmyCustomWrapper.onContinuesRunEnabled(testItem =>\n  continuesTests.push(item.fsPath)\n)\n\nvitest.onFilterWatchedSpecification(specification =>\n  continuesTests.includes(specification.moduleId)\n)\n```\n\n----------------------------------------\n\nTITLE: Customizing Mocking Recognition with hoistMocks Option - TypeScript\nDESCRIPTION: Configures mockerPlugin to recognize custom mocking hints using the hoistMocks option. Accepts a regexpHoistable pattern and utilsObjectName array to match non-standard mocking APIs. Requires @vitest/mocker/node and may need additional configuration for harmonization. Enables compatibility with user-defined mocking utilities and expands mocking coverage.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/mocker/EXPORTS.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { mockerPlugin } from '@vitest/mocker/node'\n\nexport default defineConfig({\n  plugins: [\n    mockerPlugin({\n      hoistMocks: {\n        regexpHoistable: /myObj.mock/,\n        // you will also need to update other options accordingly\n        utilsObjectName: ['myObj'],\n      },\n    }),\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: first Method - Target First Element in Multiple Matches\nDESCRIPTION: Returns a locator for the first element in a set of matched elements, equivalent to `nth(0)`. Simplifies access when only the first match is needed.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_21\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction first(): Locator\n```\n\n----------------------------------------\n\nTITLE: Asserting No Numeric Property Decrease with Vitest - TypeScript\nDESCRIPTION: Verifies that a modifier function does not decrease the value of a numeric property in an object. Takes the modifier function, object, property name, and optional message as arguments. Ensures the property remains unchanged or increases after the modifier runs.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_110\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.doesNotDecrease', () => {\n  const obj = { val: 10 }\n  function fn() { obj.val = 15 }\n  assert.doesNotDecrease(fn, obj, 'val')\n})\n```\n\n----------------------------------------\n\nTITLE: Specifying test file and line number in Vitest CLI\nDESCRIPTION: This snippet shows how to run a specific test in a file by specifying the filename and line number, requiring the full filename for accuracy.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/filtering.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ vitest basic/foo.test.ts:10\n```\n\n----------------------------------------\n\nTITLE: Assigning Custom Metadata During Collection and Test Run (TypeScript)\nDESCRIPTION: Demonstrates how to attach custom metadata to a TestModule via the meta property during both the test collection phase and the execution phase inside a test. Requires importing the test object from Vitest. The example highlights how metadata attached outside a test is available in hooks like onTestModuleCollected, while metadata set during a test is only available in later lifecycle hooks. The task parameter is expected in describe and test functions, and meta is directly mutated for custom information.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/test-module.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { test } from 'vitest'\n\ndescribe('the validation works correctly', (task) => {\n  // assign \"decorated\" during collection\n  task.file.meta.decorated = false\n\n  test('some test', ({ task }) => {\n    // assign \"decorated\" during test run, it will be available\n    // only in onTestCaseReady hook\n    task.file.meta.decorated = false\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Test and Coverage Scripts with Vitest in package.json\nDESCRIPTION: This JSON snippet adds 'test' and 'coverage' scripts to package.json for project automation. The 'test' script runs all tests with Vitest, and the 'coverage' script collects code coverage using 'vitest run --coverage'. Vitest must be included in 'devDependencies'. These scripts standardize testing workflows and integrate with CI systems. No parameters are needed to run; triggering is done via 'npm run test' or 'npm run coverage'.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/features.md#_snippet_8\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"scripts\": {\n    \"test\": \"vitest\",\n    \"coverage\": \"vitest run --coverage\"\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Asserting a Value is Not of a Specific Type using Vitest (TypeScript)\nDESCRIPTION: Demonstrates `assert.notTypeOf` within a Vitest test to ensure a value is *not* of a specified type, determined by Object.prototype.toString. Requires `assert` and `test`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_39\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.notTypeOf', () => {\n  assert.notTypeOf('red', 'number', '\"red\" is not a number')\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring vmForks pool options in Vitest\nDESCRIPTION: This code snippet demonstrates how to configure the vmForks pool options within a Vitest configuration file. It showcases the structure for specifying vmForks-related settings.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    poolOptions: {\n      vmForks: {\n        // VM forks related options here\n      }\n    }\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: TestCollection suites method definition\nDESCRIPTION: Defines a function `suites` that returns a Generator for iterating over TestSuite objects directly within the TestCollection (not its children).\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/test-collection.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nfunction suites(): Generator<TestSuite, undefined, void>\n```\n\n----------------------------------------\n\nTITLE: Wrapping a Single Dynamic Import for Mocker Compliance - TypeScript\nDESCRIPTION: Demonstrates awaiting a standard dynamic import, and then shows how dynamicImportPlugin transforms it into a wrapped call that ensures all mocks are properly resolved before execution. Outputs code transformed to rely on the configured global wrapDynamicImport function.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/mocker/EXPORTS.md#_snippet_15\n\nLANGUAGE: TypeScript\nCODE:\n```\nawait import('./my-module.js')\n\n// produces this:\nawait globalThis[`Symbol.for('my-mocker')`].wrapDynamicImport(() => import('./my-module.js'))\n```\n\n----------------------------------------\n\nTITLE: Conditionally Configure Cache Directory for Vitest (TypeScript)\nDESCRIPTION: Illustrates how to set the `cacheDir` option conditionally based on the `process.env.VITEST` environment variable. This ensures the custom cache directory is used only when running Vitest, allowing Vite to use a different cache location otherwise. Requires `defineConfig` from 'vitest/config'.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_36\n\nLANGUAGE: ts\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  cacheDir: process.env.VITEST ? 'custom-folder/.vitest' : undefined\n})\n```\n\n----------------------------------------\n\nTITLE: Defining RPC methods for Custom Pool\nDESCRIPTION: This code snippet shows how to set up Remote Procedure Calls (RPC) for communication between processes within a custom test pool. It utilizes `birpc` for bi-directional RPC and `flatted` to serialize/deserialize objects for communication. It sets up a `createBirpc` instance using methods generated by `createMethodsRPC`, enabling complex communication and coordination between different parts of a custom test pool.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/pool.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { createBirpc } from 'birpc'\nimport { parse, stringify } from 'flatted'\nimport { createMethodsRPC, TestProject } from 'vitest/node'\n\nfunction createRpc(project: TestProject, wss: WebSocketServer) {\n  return createBirpc(\n    createMethodsRPC(project),\n    {\n      post: msg => wss.send(msg),\n      on: fn => wss.on('message', fn),\n      serialize: stringify,\n      deserialize: parse,\n    },\n  )\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Coverage Reporters with Options in Vitest (TS)\nDESCRIPTION: This snippet demonstrates how to configure coverage reporters in Vitest with specific options, using TypeScript syntax. It shows how to specify reporters with options such as projectRoot for lcov and file for json. Requires `@types/istanbul-reports` for type definitions.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_25\n\nLANGUAGE: ts\nCODE:\n```\n{\n  reporter: [\n    ['lcov', { 'projectRoot': './src' }],\n    ['json', { 'file': 'coverage.json' }],\n    ['text']\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Dot Reporter\nDESCRIPTION: This snippet demonstrates configuring the `dot` reporter within the `vitest.config.ts` file.  This sets the `reporters` array to `['dot']`. The dot reporter prints a single dot for each completed test.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/reporters.md#_snippet_11\n\nLANGUAGE: ts\nCODE:\n```\nexport default defineConfig({\n  test: {\n    reporters: ['dot']\n  },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Bypassing ES Module Hoisting with Dynamic Imports (Diff)\nDESCRIPTION: Shows a diff illustrating how to manually convert a static import to a dynamic `await import()` to execute code (like `callFunctionWithSideEffect()`) *before* the module is evaluated, thus bypassing the standard ES module import hoisting behavior where all imports are evaluated first.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_32\n\nLANGUAGE: diff\nCODE:\n```\ncallFunctionWithSideEffect()\n- import { value } from './some/module.js'\n+ const { value } = await import('./some/module.js')\n```\n\n----------------------------------------\n\nTITLE: Excluding Files from Watcher in Vitest via Vite Config (TypeScript)\nDESCRIPTION: Migrates usage of the deprecated 'watchExclude' to Vite's watcher options by specifying 'server.watch.ignored' in the exported config. Input: array of path patterns. Output: ignored files or directories during watch mode. Dependencies: defineConfig from Vite/Vitest.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/migration.md#_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport default defineConfig({\n  server: {\n    watch: {\n      ignored: ['!node_modules/examplejs']\n    }\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Checking the Nth Resolved Value of an Async Function Using toHaveNthResolvedWith\nDESCRIPTION: This example verifies that a Promise-returning function has resolved to a specific value on a particular call index, involving sequential `await` calls and assertions on the resolution.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_37\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { expect, test, vi } from 'vitest'\n\ntest('spy function returns bananas on second call', async () => {\n  const sell = vi.fn((product: string) => Promise.resolve({ product }))\n\n  await sell('apples')\n  await sell('bananas')\n\n  expect(sell).toHaveNthResolvedWith(2, { product: 'bananas' })\n})\n```\n\n----------------------------------------\n\nTITLE: Multiple Browser Configurations with Inherited Options\nDESCRIPTION: Shows how multiple browser configurations inherit options from the root config, including setup files and custom paths. Also demonstrates how to properly organize browser instances.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/config.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport default defineConfig({\n  test: {\n    setupFile: ['./root-setup-file.js'],\n    browser: {\n      enabled: true,\n      testerHtmlPath: './custom-path.html',\n      instances: [\n        {\n          // will have both setup files: \"root\" and \"browser\"\n          setupFile: ['./browser-setup-file.js'],\n          // implicitly has \"testerHtmlPath\" from the root config\n          // testerHtmlPath: './custom-path.html',\n        },\n      ],\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Testing Lit Components in Vitest Browser Mode (TypeScript)\nDESCRIPTION: Example of testing a Lit web component (`greeter-button`) using `vitest-browser-lit`. It renders the component using `html` tagged template literal, finds a button by role using `screen.getByRole()`, simulates a click, finds the resulting text using `screen.getByText()`, and asserts its presence.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/index.md#_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nimport { render } from 'vitest-browser-lit'\nimport { html } from 'lit'\nimport './greeter-button'\n\ntest('greeting appears on click', async () => {\n  const screen = render(html`<greeter-button name=\"World\"></greeter-button>`)\n\n  const button = screen.getByRole('button')\n  await button.click()\n  const greeting = screen.getByText(/hello world/iu)\n\n  await expect.element(greeting).toBeInTheDocument()\n})\n```\n\n----------------------------------------\n\nTITLE: Listing Tests With Name Filters and JSON Output - Shell\nDESCRIPTION: Demonstrates usage of the Vitest CLI to list all tests in a file matching a given test name filter, with support for outputting results as raw text or JSON. Takes an optional --json flag, which can redirect output to a file. Input: filename, name filter, --json flag. Output: List of test names and optionally their structure, either on stdout or in the specified file. Limitation: --json outputs to stdout unless a file is specified.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/cli.md#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\nvitest list filename.spec.ts -t=\"some-test\" --json=./file.json\n\n```\n\n----------------------------------------\n\nTITLE: Checking Displayed Value of Form Elements with Vitest - TypeScript\nDESCRIPTION: The `toHaveDisplayValue` function asynchronously asserts that a form element (input, select, or textarea) shows a specified displayed value to the end user. It supports single or multiple expected values, accepting string or regular expressions to match the visible value property. Elements like checkboxes and radios are excluded from this check and should use other assertions instead. The snippet demonstrates using page queries to get elements by label and asserting their displayed values with exact matches or regex.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_28\n\nLANGUAGE: typescript\nCODE:\n```\nfunction toHaveDisplayValue(\n  value: string | RegExp | (string | RegExp)[]\n): Promise<void>\n```\n\n----------------------------------------\n\nTITLE: ExpectationResult Interface (TypeScript)\nDESCRIPTION: Defines the structure of the return value of a matcher. It includes a boolean `pass` indicating whether the expectation passed, a `message` function that returns an error message, and optional `actual` and `expected` values for diffing.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/extending-matchers.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ninterface ExpectationResult {\n  pass: boolean\n  message: () => string\n  // If you pass these, they will automatically appear inside a diff when\n  // the matcher does not pass, so you don't need to print the diff yourself\n  actual?: unknown\n  expected?: unknown\n}\n```\n\n----------------------------------------\n\nTITLE: Conditionally Defining Web Workers with Options (JavaScript)\nDESCRIPTION: Illustrates how to conditionally enable and configure Web Worker simulation using the `defineWebWorkers` function imported from '@vitest/web-worker/pure'. This example enables workers based on an environment variable and specifies the cloning behavior (`clone: 'none'`). Options include 'native' (requires Node 17+), 'ponyfill', or 'none'.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/web-worker/README.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { defineWebWorkers } from '@vitest/web-worker/pure'\n\nif (process.env.SUPPORT_WORKERS) {\n  defineWebWorkers({ clone: 'none' })\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Vue Snapshot Serializer in Test Setup File with JavaScript\nDESCRIPTION: Shows how to add the jest-serializer-vue serializer in a Vitest test setup file to enable proper snapshot testing for Vue components. Requires Vitest and jest-serializer-vue package. Input: none; Output: snapshot serializer registered so Vue snapshots render correctly.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/migration.md#_snippet_17\n\nLANGUAGE: javascript\nCODE:\n```\nimport vueSnapshotSerializer from 'jest-serializer-vue'\n\nexpect.addSnapshotSerializer(vueSnapshotSerializer)\n```\n\n----------------------------------------\n\nTITLE: TestCollection at Method\nDESCRIPTION: Defines a function `at` that retrieves a TestCase or TestSuite at a specific index from the TestCollection. It supports negative indexing.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/test-collection.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nfunction at(index: number): TestCase | TestSuite | undefined\n```\n\n----------------------------------------\n\nTITLE: Assert Value is Array with Vitest\nDESCRIPTION: This snippet demonstrates `assert.isArray`, which asserts that a value is an array. It uses the `vitest` testing framework.  The input is a value, and the assertion passes if the value is an array.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_29\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\nconst color = ['red', 'green', 'yellow']\n\ntest('assert.isArray', () => {\n  assert.isArray(color, 'color is array')\n})\n```\n\n----------------------------------------\n\nTITLE: Declaring injectTestProjects Utility Function Signature - TypeScript\nDESCRIPTION: The function signature for the `injectTestProjects` utility, available in the `configureVitest` context. It accepts a single `TestProjectConfiguration` object or an array of them and returns a `Promise` that resolves to an array of resolved `TestProject` objects. This function is used to dynamically add new test projects during the Vitest configuration phase.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/plugin.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nfunction injectTestProjects(\n  config: TestProjectConfiguration | TestProjectConfiguration[]\n): Promise<TestProject[]>\n```\n\n----------------------------------------\n\nTITLE: Define a custom environment - TypeScript\nDESCRIPTION: This snippet illustrates how to define a custom environment for Vitest. The code exports an object conforming to the `Environment` interface from the `vitest` package. It defines the environment's name, transformMode, and setup/teardown functions. Requires the vitest testing framework.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_15\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { Environment } from 'vitest'\n\nexport default <Environment>{\n  name: 'custom',\n  transformMode: 'ssr',\n  setup() {\n    // custom setup\n    return {\n      teardown() {\n        // called after all tests with this env have been run\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using vi.waitFor with Synchronous Callback in Vitest (TypeScript)\nDESCRIPTION: Demonstrates using `vi.waitFor` to poll a synchronous condition (`server.isReady`) until it becomes true or times out. It shows configuring `timeout` (default 1000ms) and `interval` (default 50ms) options. This is useful for waiting on operations like server startup. Dependencies include `vitest` (`expect`, `test`, `vi`) and a hypothetical `createServer` function from './server.js'.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_29\n\nLANGUAGE: typescript\nCODE:\n```\nimport { expect, test, vi } from 'vitest'\nimport { createServer } from './server.js'\n\ntest('Server started successfully', async () => {\n  const server = createServer()\n\n  await vi.waitFor(\n    () => {\n      if (!server.isReady) {\n        throw new Error('Server not started')\n      }\n\n      console.log('Server started')\n    },\n    {\n      timeout: 500, // default is 1000\n      interval: 20, // default is 50\n    }\n  )\n  expect(server.isReady).toBe(true)\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Multi-Browser Testing in Vitest 3\nDESCRIPTION: Shows how to set up multiple browser instances for testing with different configurations using the new 'instances' array in browser configuration. This approach is more performant than using workspaces.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/blog/vitest-3.md#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    browser: {\n      provider: 'playwright',\n      instances: [\n        {\n          browser: 'chromium',\n          launch: { devtools: true },\n        },\n        {\n          browser: 'firefox',\n          setupFiles: ['./setup.firefox.ts'],\n          provide: {\n            secret: 'my-secret',\n          },\n        },\n      ],\n    }\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Assert Value is Undefined with Vitest\nDESCRIPTION: This snippet showcases `assert.isUndefined`, which asserts that a value is undefined. It utilizes the `vitest` testing framework. The assertion passes only when the input is undefined.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_23\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\nconst name = undefined\n\ntest('assert.isUndefined', () => {\n  assert.isUndefined(name, 'name is undefined')\n})\n```\n\n----------------------------------------\n\nTITLE: HTML Context for toHaveFormValues Usage - HTML\nDESCRIPTION: Sample form with username, password, and a checked rememberMe checkbox. Test ID allows the element to be located in the TypeScript test code. Used for demonstrating toHaveFormValues assertions.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_21\n\nLANGUAGE: HTML\nCODE:\n```\n<form data-testid=\"login-form\">\n  <input type=\"text\" name=\"username\" value=\"jane.doe\" />\n  <input type=\"password\" name=\"password\" value=\"12345678\" />\n  <input type=\"checkbox\" name=\"rememberMe\" checked />\n  <button type=\"submit\">Sign in</button>\n</form>\n```\n\n----------------------------------------\n\nTITLE: Checking Module Type and Accessing TestModule (TypeScript)\nDESCRIPTION: Demonstrates how to verify if a given task object is a TestModule instance by checking its type property. No special dependencies are required. This pattern helps differentiate between various task types within the runner API or test execution context. The code expects a task-like object with a type property and allows TypeScript to infer the object type when type is \\\"module\\\". Outputs: task object of type TestModule. Inputs: task object with a type property.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/test-module.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nif (task.type === 'module') {\n  task // TestModule\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Vite Node Transformation Debugging Programmatically (JavaScript)\nDESCRIPTION: Illustrates how to enable transformation debugging options programmatically when instantiating `ViteNodeServer`. The `debug.dumpModules` option enables dumping, and `debug.loadDumppedModules` enables loading from dumped files.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/vite-node/README.md#_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nimport { ViteNodeServer } from 'vite-node/server'\n\nconst server = new ViteNodeServer(viteServer, {\n  debug: {\n    dumpModules: true,\n    loadDumppedModules: true,\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Installing Vitest UI with npm\nDESCRIPTION: This command installs the Vitest UI package as a development dependency.  It uses npm to install the @vitest/ui package. This package provides the necessary components for the Vitest UI functionality.  No specific parameters are needed for installation. The output is the installed package and its dependencies.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/ui.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i -D @vitest/ui\n```\n\n----------------------------------------\n\nTITLE: Importing and Extending Chai with Jest Expect Matchers in JavaScript\nDESCRIPTION: This snippet demonstrates how to import Jest matching plugins from @vitest/expect and integrate them with the Chai assertion library by registering them as Chai plugins. It allows developers to use Jest's expect.extend and asymmetric matchers such as stringContaining and objectContaining inside Chai's expect framework. The snippet requires the @vitest/expect and chai packages and assumes a JavaScript environment. No additional parameters are required, and the integration enhances assertion capabilities for testing.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/expect/README.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport {\n  JestAsymmetricMatchers,\n  JestChaiExpect,\n  JestExtend,\n} from '@vitest/expect'\nimport * as chai from 'chai'\n\n// allows using expect.extend instead of chai.use to extend plugins\nchai.use(JestExtend)\n// adds all jest matchers to expect\nchai.use(JestChaiExpect)\n// adds asymmetric matchers like stringContaining, objectContaining\nchai.use(JestAsymmetricMatchers)\n```\n\n----------------------------------------\n\nTITLE: Deep Members Inequality Assertion (TypeScript)\nDESCRIPTION: Defines `assert.notSameDeepMembers` to assert two arrays of objects do not have the same deep members. The example demonstrates the check with different object arrays.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_86\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\n test('assert.sameDeepMembers', () => {\n  assert.sameDeepMembers([{ a: 1 }, { b: 2 }, { c: 3 }], [{ b: 2 }, { a: 1 }, { c: 3 }], 'same deep members')\n})\n```\n\n----------------------------------------\n\nTITLE: Adding Vitest CLI Commands to npm Scripts in package.json\nDESCRIPTION: Shows recommended npm scripts in `package.json` for running Vitest tests. The `test` script runs Vitest in watch mode, while the `coverage` script runs tests once (`vitest run`) and generates a coverage report (`--coverage`).\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/index.md#_snippet_10\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"scripts\": {\n    \"test\": \"vitest\",\n    \"coverage\": \"vitest run --coverage\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting Map/Set Has Any Deep Keys with Vitest (TypeScript)\nDESCRIPTION: Demonstrates using `assert.hasAnyDeepKeys` in Vitest to verify that a Map or Set contains at least one of the specified keys, performing a deep comparison for object keys. Keys can be provided as an array of objects/strings or as the keys of another object.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_74\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.hasAnyDeepKeys', () => {\n  assert.hasAnyDeepKeys(new Map([[{ one: 'one' }, 'valueOne'], [1, 2]]), { one: 'one' })\n  assert.hasAnyDeepKeys(new Map([[{ one: 'one' }, 'valueOne'], [1, 2]]), [{ one: 'one' }, { two: 'two' }])\n  assert.hasAnyDeepKeys(new Map([[{ one: 'one' }, 'valueOne'], [{ two: 'two' }, 'valueTwo']]), [{ one: 'one' }, { two: 'two' }])\n  assert.hasAnyDeepKeys(new Set([{ one: 'one' }, { two: 'two' }]), { one: 'one' })\n  assert.hasAnyDeepKeys(new Set([{ one: 'one' }, { two: 'two' }]), [{ one: 'one' }, { three: 'three' }])\n  assert.hasAnyDeepKeys(new Set([{ one: 'one' }, { two: 'two' }]), [{ one: 'one' }, { two: 'two' }])\n})\n```\n\n----------------------------------------\n\nTITLE: Auto-Importing Vitest APIs Using unplugin-auto-import - TypeScript\nDESCRIPTION: This snippet integrates the unplugin-auto-import plugin with a Vitest configuration to automatically import test APIs. It adds the 'vitest' module to the imports list, generating TypeScript declarations for auto-imported APIs. Requires vitest/config and unplugin-auto-import/vite. Takes a configuration object with plugins, each plugin being an auto-import instance for 'vitest' and other modules if needed. Output is a Vitest configuration setup supporting auto-imported test APIs with TypeScript declarations enabled. Best suited for projects already using Vite plugins; ensure unplugin-auto-import is installed.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_10\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\nimport AutoImport from 'unplugin-auto-import/vite'\n\nexport default defineConfig({\n  plugins: [\n    AutoImport({\n      imports: ['vitest'],\n      dts: true, // generate TypeScript declaration\n    }),\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Scoping Context Values to Suites in Vitest\nDESCRIPTION: Example of overriding context values for specific test suites and their children using test.scoped API, available since Vitest 3.1.0.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/test-context.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { test as baseTest, describe, expect } from 'vitest'\n\nconst test = baseTest.extend({\n  dependency: 'default',\n  dependant: ({ dependency }, use) => use({ dependency })\n})\n\ndescribe('use scoped values', () => {\n  test.scoped({ dependency: 'new' })\n\n  test('uses scoped value', ({ dependant }) => {\n    // `dependant` uses the new overriden value that is scoped\n    // to all tests in this suite\n    expect(dependant).toEqual({ dependency: 'new' })\n  })\n\n  describe('keeps using scoped value', () => {\n    test('uses scoped value', ({ dependant }) => {\n      // nested suite inherited the value\n      expect(dependant).toEqual({ dependency: 'new' })\n    })\n  })\n})\n\ntest('keep using the default values', ({ dependant }) => {\n  // the `dependency` is using the default\n  // value outside of the suite with .scoped\n  expect(dependant).toEqual({ dependency: 'default' })\n})\n```\n\n----------------------------------------\n\nTITLE: Strict Error Comparison with expect in Vitest (TypeScript)\nDESCRIPTION: Shows how Vitest 3.0 introduces stricter error object comparisons via toEqual and toThrowError. Demonstrates asymmetric and type-based error matching. Requires 'expect' and can be used when testing for thrown errors with additional properties (like cause) or specific error prototypes.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/migration.md#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nexpect(new Error('hi', { cause: 'x' })).toEqual(new Error('hi')) // ✅\nexpect(new Error('hi')).toEqual(new Error('hi', { cause: 'x' })) // ❌\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nexpect(() => {\n  throw new TypeError('type error')\n})\n  .toThrowError(new Error('type error'))\n  .toThrowError(new TypeError('type error'))\n```\n\n----------------------------------------\n\nTITLE: Configuring mockerPlugin with Vite Plugin System - TypeScript\nDESCRIPTION: Shows how to set up Vitest's mockerPlugin within Vite by importing it and adding to the plugins array in the exported config. Requires Vite, @vitest/mocker/node, and defines an initial plugin integration. The exported configuration ensures that Vitest's mocking capabilities are available during builds and development.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/mocker/EXPORTS.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { mockerPlugin } from '@vitest/mocker/node'\n\nexport default defineConfig({\n  plugins: [mockerPlugin()],\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring forks pool options in Vitest\nDESCRIPTION: This code snippet demonstrates how to configure the forks pool options within a Vitest configuration file. It showcases the structure for specifying fork-related settings.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    poolOptions: {\n      forks: {\n        // Forks related options here\n      }\n    }\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Previewing HTML Report with Vite Preview\nDESCRIPTION: This command uses Vite's preview functionality to serve the generated HTML report.  The `--outDir ./html` flag specifies that the report is located in the ./html directory. The command requires Vite to be installed and the HTML report to be present in the specified output directory. The output is a preview server serving the generated HTML report in the browser.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/ui.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nnpx vite preview --outDir ./html\n```\n\n----------------------------------------\n\nTITLE: Registering the Runtime Mocker with Server and MSW Interceptors - TypeScript\nDESCRIPTION: Demonstrates initializing the runtime module mocker using either Vite's websocket-driven server interceptor or a browser-based MSW interceptor. Requires @vitest/mocker/register and optionally msw for browser interception. registerModuleMocker returns compiler hints used by the Vite plugin. The vi variable must be configured consistently as it is referenced by the compiler.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/mocker/EXPORTS.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport {\n  ModuleMockerMSWInterceptor,\n  ModuleMockerServerInterceptor,\n  registerModuleMocker\n} from '@vitest/mocker/register'\n\n// you can use either a server interceptor (relies on Vite's websocket connection)\nconst vi = registerModuleMocker(() => new ModuleMockerServerInterceptor())\n// or you can use MSW to intercept requests directly in the browser\nconst vi = registerModuleMocker(globalThisAccessor => new ModuleMockerMSWInterceptor({ globalThisAccessor }))\n```\n\n----------------------------------------\n\nTITLE: Accessing Individual Function Parameters with Vitest in TypeScript\nDESCRIPTION: Demonstrates using `.parameter(n)` to access a specific argument's type for assertions. Requires Vitest and a valid function reference. Enables fine-grained assertions on individual parameter types to ensure function API correctness.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect-typeof.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { expectTypeOf } from 'vitest'\n\nfunction foo(a: number, b: string) {\n  return [a, b]\n}\n\nexpectTypeOf(foo).parameter(0).toBeNumber()\nexpectTypeOf(foo).parameter(1).toBeString()\n```\n\n----------------------------------------\n\nTITLE: Configuring Snapshot Serializers in Vitest (TypeScript)\nDESCRIPTION: This code shows how to configure the `snapshotSerializers` option in the `vitest.config.ts` file to implicitly add custom serializers to your tests. Dependencies: vitest. Input: none. Output: Configuration of snapshot serializers.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/snapshot.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    snapshotSerializers: ['path/to/custom-serializer.ts'],\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Serial and Parallel Hooks in Vitest (TypeScript)\nDESCRIPTION: Shows how to switch hook execution order (from serial to parallel) in Vitest 2.0+ by setting 'test.sequence.hooks' to 'parallel' within the config object. Appropriate for configuring afterAll/afterEach hook behavior. Dependencies: defineConfig. Input: none. Output: sequential or parallel test hook execution.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/migration.md#_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport default defineConfig({\n  test: {\n    sequence: {\n      hooks: 'parallel',\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: HTML example for `getByRole` usage in Vitest\nDESCRIPTION: This HTML snippet provides the DOM structure for demonstrating the use of `getByRole`. It includes elements with implicit roles (heading, textbox, button) and associated accessible names. Used as a reference in the `getByRole` examples to show how to target these elements using Vitest's locator API. No external dependencies required.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_1\n\nLANGUAGE: html\nCODE:\n```\n<h3>Sign up</h3>\n<label>\n  Login\n  <input type=\"text\" />\n</label>\n<label>\n  Password\n  <input type=\"password\" />\n</label>\n<br/>\n<button>Submit</button>\n```\n\n----------------------------------------\n\nTITLE: Importing BlogIndex Component in Vue\nDESCRIPTION: This snippet imports the BlogIndex Vue component from a relative path. This component is then used to display blog posts. It is crucial for displaying content from the blog.  The component relies on having a BlogIndex.vue file available in the specified path.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/blog.md#_snippet_0\n\nLANGUAGE: Vue\nCODE:\n```\nimport BlogIndex from './.vitepress/components/BlogIndex.vue'\n```\n\n----------------------------------------\n\nTITLE: Running Vitest Tests via yarn\nDESCRIPTION: This code snippet outlines how to run tests within a Vitest workspace using the yarn package manager.  It includes options for running all tests and only tests inside of a single project.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/workspace.md#_snippet_9\n\nLANGUAGE: Bash\nCODE:\n```\nyarn test\n```\n\n----------------------------------------\n\nTITLE: Getting Vite Node CLI Help (Bash)\nDESCRIPTION: Displays the help message for the `vite-node` command-line interface, listing available options and usage instructions.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/vite-node/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpx vite-node -h\n```\n\n----------------------------------------\n\nTITLE: TSX example demonstrating `pressed` option for `getByRole`\nDESCRIPTION: This TSX snippet demonstrates how to use the `pressed` option with `getByRole` to filter elements based on their pressed state (aria-pressed). It includes an example using a button with the aria-pressed attribute. Requires a TSX environment that supports JSX syntax. No external dependencies needed other than a rendering context for the TSX.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\n<button aria-pressed=\"true\">👍</button>\n\npage.getByRole('button', { pressed: true }) // ✅\npage.getByRole('button', { pressed: false }) // ❌\n```\n\n----------------------------------------\n\nTITLE: Asynchronous module mocking with vi.mock and dynamic import (TypeScript)\nDESCRIPTION: Demonstrates asynchronous factory usage with vi.mock providing a module promise directly. The factory receives importOriginal to access the original module asynchronously, enabling selective overrides while preserving type inference in TypeScript. This approach supports better IDE integration and strict factory return types. Requires Vitest and TypeScript configured with correct relative paths instead of path aliases.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// @filename: ./path/to/module.js\nexport declare function total(...numbers: number[]): number\n// @filename: test.js\nimport { vi } from 'vitest'\n// ---cut---\nvi.mock(import('./path/to/module.js'), async (importOriginal) => {\n  const mod = await importOriginal() // type is inferred\n  //    ^?\n  return {\n    ...mod,\n    // replace some exports\n    total: vi.fn(),\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring hoistMocksPlugin for Custom Modules - TypeScript\nDESCRIPTION: Demonstrates how to use hoistMocksPlugin within Vite to support hoisting and dynamic transforming of module imports and compiler hints for specific modules and methods. Accepts customization for hoistedModules, regex, and method name arrays. Disables dynamic import mocking if desired. Facilitates precise control over the mocking infrastructure for advanced users.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/mocker/EXPORTS.md#_snippet_11\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { hoistMocksPlugin } from '@vitest/mocker/node'\nimport { createServer } from 'vite'\n\nawait createServer({\n  plugins: [\n    hoistMocksPlugin({\n      hoistedModules: ['virtual:my-module'],\n      regexpHoistable: /myObj.(mock|hoist)/,\n      utilsObjectName: ['myObj'],\n      hoistableMockMethodNames: ['mock'],\n      // disable support for vi.mock(import('./path'))\n      dynamicImportMockMethodNames: [],\n      hoistedMethodNames: ['hoist'],\n    }),\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Using vi.hoisted to Create Mocks in Vitest (TypeScript)\nDESCRIPTION: Illustrates a pattern where `vi.hoisted` is used to create mock functions or objects (`mockedMethod`) before modules are imported. The value returned by the `vi.hoisted` factory is captured and then used within a `vi.mock` factory to replace the `originalMethod`. This ensures the mock is ready before the module is used. Dependencies include `vitest` (`expect`, `vi`) and a module ('./path/to/module.js') to be mocked.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_36\n\nLANGUAGE: typescript\nCODE:\n```\nimport { expect, vi } from 'vitest'\nimport { originalMethod } from './path/to/module.js'\n\nconst { mockedMethod } = vi.hoisted(() => {\n  return { mockedMethod: vi.fn() }\n})\n\nvi.mock('./path/to/module.js', () => {\n  return { originalMethod: mockedMethod }\n})\n\nmockedMethod.mockReturnValue(100)\nexpect(originalMethod()).toBe(100)\n```\n\n----------------------------------------\n\nTITLE: Asserting No Decrease By Specific Value with Vitest - TypeScript\nDESCRIPTION: Ensures that the modifier does not decrease a property (or its return value) by a specified amount. This is important for negative assertions about specific decrement values, and is implemented via the Vitest assertion library.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_111\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.doesNotDecreaseBy', () => {\n  const obj = { val: 10 }\n  function fn() { obj.val = 5 };\n  assert.doesNotDecreaseBy(fn, obj, 'val', 1)\n})\n```\n\n----------------------------------------\n\nTITLE: Example HTML Structure for Testing Text Selection\nDESCRIPTION: Provides a sample HTML markup with various elements (input, textarea, paragraphs with nested spans) annotated with data-testid attributes. This structure serves as the DOM setup for testing text selection behavior using the toHaveSelection assertion. It demonstrates different types of text-containing elements where text selection detection is applicable.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_41\n\nLANGUAGE: HTML\nCODE:\n```\n<div>\n  <input type=\"text\" value=\"text selected text\" data-testid=\"text\" />\n  <textarea data-testid=\"textarea\">text selected text</textarea>\n  <p data-testid=\"prev\">prev</p>\n  <p data-testid=\"parent\">\n    text <span data-testid=\"child\">selected</span> text\n  </p>\n  <p data-testid=\"next\">next</p>\n</div>\n```\n\n----------------------------------------\n\nTITLE: Define coverage.watermarks Type in TypeScript\nDESCRIPTION: Specifies the TypeScript interface for the `coverage.watermarks` configuration option. It defines an object shape with optional properties for different coverage metrics (statements, functions, branches, lines), where each property is a tuple of two numbers representing low and high watermark thresholds.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_31\n\nLANGUAGE: ts\nCODE:\n```\n{\n  statements?: [number, number],\n  functions?: [number, number],\n  branches?: [number, number],\n  lines?: [number, number]\n}\n```\n\n----------------------------------------\n\nTITLE: Debugging Vite Node Execution via Env Var (Bash)\nDESCRIPTION: Demonstrates enabling execution debugging by setting the `VITE_NODE_DEBUG_RUNNER=true` environment variable. This makes the `ViteNodeRunner` provide warnings, for instance, about potential unresolvable circular dependencies that might cause the process to hang.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/vite-node/README.md#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nVITE_NODE_DEBUG_RUNNER=true vite-node example.ts\n```\n\n----------------------------------------\n\nTITLE: Extracting Function Return Types with Vitest in TypeScript\nDESCRIPTION: Applies `.returns` to determine and assert the return value type of functions. Requires Vitest and is used with function types. Ensures the tested function provides the expected return type and supports chaining type assertions for advanced validation.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect-typeof.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf(() => {}).returns.toBeVoid()\nexpectTypeOf((a: number) => [a, a]).returns.toEqualTypeOf([1, 2])\n```\n\n----------------------------------------\n\nTITLE: Testing Solid Components using Testing Library in Vitest (TSX)\nDESCRIPTION: Demonstrates testing a Solid component with routing using `@testing-library/solid` in Vitest's browser mode. It renders the component with a specific initial route (`location`), uses `page.elementLocator(baseElement)` for querying within the rendered component, and asserts that the correct text based on route parameters is rendered using `expect.screen().toBeInTheDocument()`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/index.md#_snippet_20\n\nLANGUAGE: tsx\nCODE:\n```\n// baed on @testing-library/solid API\n// https://testing-library.com/docs/solid-testing-library/api\n\nimport { render } from '@testing-library/solid'\n\nit('uses params', async () => {\n  const App = () => (\n    <>\n      <Route\n        path=\"/ids/:id\"\n        component={() => (\n          <p>\n            Id:\n            {useParams()?.id}\n          </p>\n        )}\n      />\n      <Route path=\"/\" component={() => <p>Start</p>} />\n    </>\n  )\n  const { baseElement } = render(() => <App />, { location: 'ids/1234' })\n  const screen = page.elementLocator(baseElement)\n\n  await expect.screen(screen.getByText('Id: 1234')).toBeInTheDocument()\n})\n```\n\n----------------------------------------\n\nTITLE: Extending Vitest Matchers with expect.extend (TypeScript)\nDESCRIPTION: Demonstrates how to add custom matchers to Vitest using `expect.extend`. The example defines a `toBeFoo` matcher and shows its usage both directly (`expect('foo').toBeFoo()`) and as an asymmetric matcher within `toEqual` (`expect.toBeFoo()`). It requires defining a function that receives the value and returns an object with `message` and `pass` properties.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_51\n\nLANGUAGE: typescript\nCODE:\n```\nimport { expect, test } from 'vitest'\n\ntest('custom matchers', () => {\n  expect.extend({\n    toBeFoo: (received, expected) => {\n      if (received !== 'foo') {\n        return {\n          message: () => `expected ${received} to be foo`,\n          pass: false,\n        }\n      }\n    },\n  })\n\n  expect('foo').toBeFoo()\n  expect({ foo: 'foo' }).toEqual({ foo: expect.toBeFoo() })\n})\n```\n\n----------------------------------------\n\nTITLE: Creating a test specification (Node.js)\nDESCRIPTION: This code snippet demonstrates how to create a test specification using `createSpecification`. It shows how to scope a test file to a specific project and optionally specify test locations (lines) within the file.  The module ID must be resolved.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/test-project.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createVitest } from 'vitest/node'\nimport { resolve } from 'node:path/posix'\n\nconst vitest = await createVitest('test')\nconst project = vitest.projects[0]\nconst specification = project.createSpecification(\n  resolve('./example.test.ts'),\n  [20, 40], // optional test lines\n)\nawait vitest.runTestSpecifications([specification])\n```\n\n----------------------------------------\n\nTITLE: Rendering BlogIndex Component in Vue\nDESCRIPTION: This snippet renders the imported BlogIndex Vue component. This action takes the imported BlogIndex component and injects it directly into the template.  This relies on the BlogIndex component being properly imported beforehand.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/blog.md#_snippet_1\n\nLANGUAGE: Vue\nCODE:\n```\n<BlogIndex />\n```\n\n----------------------------------------\n\nTITLE: Declaring dropTo Function in Vitest (TypeScript)\nDESCRIPTION: Specifies a dropTo function for simulating drag-and-drop between elements. Accepts a Locator for the drop target, optional UserEventDragAndDropOptions, and returns a Promise resolving when the operation completes. Used for drag-and-drop UI tests where elements must be moved or reordered; relies on accurate Locator instances for source and target.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_40\n\nLANGUAGE: typescript\nCODE:\n```\nfunction dropTo(\n  target: Locator,\n  options?: UserEventDragAndDropOptions,\n): Promise<void>\n```\n\n----------------------------------------\n\nTITLE: Vitest Test Sharding for High CPU Machines (Shell)\nDESCRIPTION: Illustrates using test sharding on a single high-CPU machine to distribute the load from the Vite server bottleneck. It shows how to run multiple sharded processes in parallel using `&` and `wait`, limiting the threads per process with `VITEST_MAX_THREADS`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/improving-performance.md#_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\n# Example for splitting tests on 32 CPU to 4 shards.\n# As each process needs 1 main thread, there's 7 threads for test runners (1+7)*4 = 32\n# Use VITEST_MAX_THREADS or VITEST_MAX_FORKS depending on the pool:\nVITEST_MAX_THREADS=7 vitest run --reporter=blob --shard=1/4 & \\\nVITEST_MAX_THREADS=7 vitest run --reporter=blob --shard=2/4 & \\\nVITEST_MAX_THREADS=7 vitest run --reporter=blob --shard=3/4 & \\\nVITEST_MAX_THREADS=7 vitest run --reporter=blob --shard=4/4 & \\\nwait # https://man7.org/linux/man-pages/man2/waitpid.2.html\n\nvitest run --merge-reports\n```\n\n----------------------------------------\n\nTITLE: Outputting TAP Flat Format Reports with Vitest Reporter in TypeScript and CLI\nDESCRIPTION: Configures Vitest to output a TAP report in a flat format where test suites and tests are listed as a single-level list rather than a nested structure. This can simplify integration with tools expecting flat TAP outputs. Example CLI and TypeScript configurations set the reporter to 'tap-flat'. A sample TAP flat report output is included showing test results with full test path descriptions and error details.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/reporters.md#_snippet_19\n\nLANGUAGE: bash\nCODE:\n```\nnpx vitest --reporter=tap-flat\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport default defineConfig({\n  test: {\n    reporters: [\"tap-flat\"]\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Advancing Fake Timers to the Next Animation Frame with Vitest vi.advanceTimersToNextFrame in TypeScript\nDESCRIPTION: Shows how `vi.advanceTimersToNextFrame` advances fake timers specifically by the amount needed to execute callbacks currently scheduled via `requestAnimationFrame`. Useful for testing animation or rendering logic that depends on animation frames. Requires `vi` from `vitest` and enabling fake timers.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_23\n\nLANGUAGE: ts\nCODE:\n```\nlet frameRendered = false\n\nrequestAnimationFrame(() => {\n  frameRendered = true\n})\n\nvi.advanceTimersToNextFrame()\n\nexpect(frameRendered).toBe(true)\n```\n\n----------------------------------------\n\nTITLE: Installing happy-dom for Browser Mocking using Bash\nDESCRIPTION: This bash command snippet shows how to install 'happy-dom' as a development dependency for use with Vitest. The package is required when using browser or DOM APIs for mocking during testing, but must be installed separately as it is not bundled. Executing this command adds 'happy-dom' to the project's 'devDependencies'.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/features.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ npm i -D happy-dom\n\n```\n\n----------------------------------------\n\nTITLE: Checking if a Spy Function Has Returned at Least Once Using toHaveReturned\nDESCRIPTION: This snippet demonstrates verifying whether a spy function has successfully returned a value at least once without throwing an error. It requires a spy to wrap the target function and the use of expect assertions to validate behavior. It is useful for testing synchronous functions' return executions.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_28\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { expect, test, vi } from 'vitest'\n\nfunction getApplesPrice(amount: number) {\n  const PRICE = 10\n  return amount * PRICE\n}\n\ntest('spy function returned a value', () => {\n  const getPriceSpy = vi.fn(getApplesPrice)\n\n  const price = getPriceSpy(10)\n\n  expect(price).toBe(100)\n  expect(getPriceSpy).toHaveReturned()\n})\n```\n\n----------------------------------------\n\nTITLE: Declaring elements Function in Vitest (TypeScript)\nDESCRIPTION: Defines the elements() function, returning all matching DOM elements as an array. Never throws errors; returns an empty array if no matches found. Used for batch operations and flexible multi-element queries within tests. Each array item is an Element corresponding to a match.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_51\n\nLANGUAGE: typescript\nCODE:\n```\nfunction elements(): Element[]\n```\n\n----------------------------------------\n\nTITLE: Matching Output Against File Snapshot in Vitest\nDESCRIPTION: Explains how to use the asynchronous `.toMatchFileSnapshot()` matcher to compare test output with the content of a specific file on the filesystem. It requires `await` because it involves file system operations.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_19\n\nLANGUAGE: ts\nCODE:\n```\nimport { expect, it } from 'vitest'\n\nit('render basic', async () => {\n  const result = renderHTML(h('div', { class: 'foo' }))\n  await expect(result).toMatchFileSnapshot('./test/basic.output.html')\n})\n```\n\n----------------------------------------\n\nTITLE: Asserting Target is Empty with Vitest - TypeScript\nDESCRIPTION: Tests whether the provided target is empty, handling arrays, strings, Maps, Sets, and plain objects as appropriate. Uses Vitest; takes the target and optional message. Passes if the collection or object contains no items, using the correct property (length, size, or own keys) for each.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_120\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.isEmpty', () => {\n  assert.isEmpty([])\n  assert.isEmpty('')\n  assert.isEmpty(new Map())\n  assert.isEmpty({})\n})\n```\n\n----------------------------------------\n\nTITLE: Using Basic Reporter - Configuration\nDESCRIPTION: This snippet demonstrates configuring the `basic` reporter within the `vitest.config.ts` file.  It sets the `reporters` array to `['basic']`.  The basic reporter is equivalent to `default` reporter without `summary`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/reporters.md#_snippet_9\n\nLANGUAGE: ts\nCODE:\n```\nexport default defineConfig({\n  test: {\n    reporters: ['basic']\n  },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Running Vitest with Node.js CPU Profiling Flags in Bash\nDESCRIPTION: This bash snippet shows how to run the Vitest test runner with Node.js arguments to collect CPU profiling data for the main thread. It passes '--cpu-prof' and '--cpu-prof-dir=main-profile' to the node process before invoking Vitest's CLI to execute tests. The input consists of test files run by Vitest, and the output includes a '.cpuprofile' file generated in 'main-profile' directory. This approach aids in diagnosing performance issues related to Vite plugins and setup scripts. Usage requires Node.js installed and appropriate permissions to write profiling files.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/profiling-test-performance.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ node --cpu-prof --cpu-prof-dir=main-profile ./node_modules/vitest/vitest.mjs --run\n#      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^                                  ^^^^^\n#               NodeJS arguments                                           Vitest arguments\n```\n\n----------------------------------------\n\nTITLE: Globbing test files in a Vitest project (JavaScript)\nDESCRIPTION: This snippet illustrates how to use `globTestFiles` to find test files within a Vitest project. It returns an object with an array of regular test files and typecheck test files. Filters can be used to narrow down the results.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/test-project.md#_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nproject.globTestFiles(['foo']) // ✅\nproject.globTestFiles(['basic/foo.js:10']) // ❌\n```\n\n----------------------------------------\n\nTITLE: Using toBePartiallyChecked Assertion for Mixed and Indeterminate Checkboxes - TypeScript\nDESCRIPTION: This code snippet demonstrates retrieving checkbox elements in various states and asserting whether they are partially checked using `toBePartiallyChecked`. It includes setting the indeterminate property manually for relevant inputs to satisfy the partial check condition.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_36\n\nLANGUAGE: ts\nCODE:\n```\nconst ariaCheckboxMixed = getByTestId('aria-checkbox-mixed')\nconst inputCheckboxChecked = getByTestId('input-checkbox-checked')\nconst inputCheckboxUnchecked = getByTestId('input-checkbox-unchecked')\nconst ariaCheckboxChecked = getByTestId('aria-checkbox-checked')\nconst ariaCheckboxUnchecked = getByTestId('aria-checkbox-unchecked')\nconst inputCheckboxIndeterminate = getByTestId('input-checkbox-indeterminate')\n\nawait expect.element(ariaCheckboxMixed).toBePartiallyChecked()\nawait expect.element(inputCheckboxChecked).not.toBePartiallyChecked()\nawait expect.element(inputCheckboxUnchecked).not.toBePartiallyChecked()\nawait expect.element(ariaCheckboxChecked).not.toBePartiallyChecked()\nawait expect.element(ariaCheckboxUnchecked).not.toBePartiallyChecked()\n\ninputCheckboxIndeterminate.element().indeterminate = true\nawait expect.element(inputCheckboxIndeterminate).toBePartiallyChecked()\n```\n\n----------------------------------------\n\nTITLE: Using Reporters via Command Line\nDESCRIPTION: This snippet demonstrates how to specify the reporter using the command line interface (CLI) when running Vitest tests.  It uses the `--reporter` option followed by the reporter name (e.g., `verbose`). This is a quick way to change the reporting style without modifying the configuration file.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/reporters.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx vitest --reporter=verbose\n```\n\n----------------------------------------\n\nTITLE: Assert Truthy Value with Vitest\nDESCRIPTION: This snippet demonstrates `assert.isOk`, which asserts that a given value is truthy.  It uses the `vitest` module for testing.  It takes a value as input, and expects it to be truthy to pass. It fails the test if the input is falsy. Also demonstrates the alias `ok`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.isOk', () => {\n  assert.isOk('foo', 'every truthy is ok')\n  assert.isOk(false, 'this will fail since false is not truthy')\n})\n```\n\n----------------------------------------\n\nTITLE: Deep Ordered Members Inequality Check (TypeScript)\nDESCRIPTION: Defines `assert.notSameDeepOrderedMembers` to verify two object arrays do not match in deep equality in the same order; demonstrates checks with different objects.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_90\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\n test('assert.notSameDeepOrderedMembers', () => {\n  assert.notSameDeepOrderedMembers([{ a: 1 }, { b: 2 }, { c: 3 }], [{ a: 1 }, { b: 2 }, { z: 5 }], 'not same deep ordered members')\n  assert.notSameDeepOrderedMembers([{ a: 1 }, { b: 2 }, { c: 3 }], [{ b: 2 }, { a: 1 }, { c: 3 }], 'not same deep ordered members')\n})\n```\n\n----------------------------------------\n\nTITLE: Checking if a file matches a test glob (TypeScript)\nDESCRIPTION: This code shows how to use `matchesTestGlob` to check if a file is a regular test file within a Vitest project. It utilizes the same configuration properties as `globTestFiles` for validation and also allows for source code to validate in-source tests.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/test-project.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createVitest } from 'vitest/node'\nimport { resolve } from 'node:path/posix'\n\nconst vitest = await createVitest('test')\nconst project = vitest.projects[0]\n\nproject.matchesTestGlob(resolve('./basic.test.ts')) // true\nproject.matchesTestGlob(resolve('./basic.ts')) // false\nproject.matchesTestGlob(resolve('./basic.ts'), () => `\nif (import.meta.vitest) {\n  // ...\n}\n`) // true if `includeSource` is set\n```\n\n----------------------------------------\n\nTITLE: Using assert.hasAnyKeys in Vitest (TypeScript)\nDESCRIPTION: Illustrates `assert.hasAnyKeys`, used to assert that an object, Map, or Set contains at least one of the specified keys. Keys can be provided as an array or as the keys of a given object. The example imports from `vitest` and shows checks for objects, Maps, and Sets within a test.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_69\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.hasAnyKeys', () => {\n  assert.hasAnyKeys({ foo: 1, bar: 2, baz: 3 }, ['foo', 'iDontExist', 'baz'])\n  assert.hasAnyKeys({ foo: 1, bar: 2, baz: 3 }, { foo: 30, iDontExist: 99, baz: 1337 })\n  assert.hasAnyKeys(new Map([[{ foo: 1 }, 'bar'], ['key', 'value']]), [{ foo: 1 }, 'key'])\n  assert.hasAnyKeys(new Set([{ foo: 'bar' }, 'anotherKey']), [{ foo: 'bar' }, 'anotherKey'])\n})\n```\n\n----------------------------------------\n\nTITLE: Example Format of moduleId for TestModule (TypeScript)\nDESCRIPTION: Illustrates valid and invalid moduleId formats for TestModule, specifically showing accepted absolute UNIX and Windows file paths, and an invalid backslash-separated Windows path. This is intended to clarify proper path formatting for module identification in Vitest's ModuleGraph. It assumes the reader is familiar with file path conventions and does not require any dependencies or setup.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/test-module.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n'C:/Users/Documents/project/example.test.ts' // \\u2705\n'/Users/mac/project/example.test.ts' // \\u2705\n'C:\\\\Users\\\\Documents\\\\project\\\\example.test.ts' // \\u274C\n```\n\n----------------------------------------\n\nTITLE: Server Environment in Vitest Browser Mode (TypeScript)\nDESCRIPTION: Defines the `server` export, which represents the Node.js environment where the Vitest server is running. Provides access to platform, runtime version, browser provider, current browser, available browser commands, and serialized test configuration, and is particularly useful for debugging or limiting tests based on the environment.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/context.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport const server: {\n  /**\n   * Platform the Vitest server is running on.\n   * The same as calling `process.platform` on the server.\n   */\n  platform: Platform\n  /**\n   * Runtime version of the Vitest server.\n   * The same as calling `process.version` on the server.\n   */\n  version: string\n  /**\n   * Name of the browser provider.\n   */\n  provider: string\n  /**\n   * Name of the current browser.\n   */\n  browser: string\n  /**\n   * Available commands for the browser.\n   */\n  commands: BrowserCommands\n  /**\n   * Serialized test config.\n   */\n  config: SerializedConfig\n}\n```\n\n----------------------------------------\n\nTITLE: Running Development and Test Commands using pnpm (or ni)\nDESCRIPTION: Provides common commands for setting up the development environment, building the project, running tests, and formatting code within the Vitest monorepo using pnpm. It also shows equivalent commands using the optional 'ni' tool.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/CONTRIBUTING.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n# Using ni (optional)\nni # equivalent to pnpm install\nnr test # equivalent to pnpm run test\n\n# Standard pnpm commands\npnpm install # Install dependencies\npnpm run build # Build all monorepo packages\npnpm run dev # Rebuild packages on code modification\npnpm run test # Run core tests\npnpm run test:ci # Run the entire test suite\ncd test/(dir) && pnpm run test # Run a specific test suite\npnpm run lint:fix # Format files according to project guidelines\n```\n\n----------------------------------------\n\nTITLE: Deep Inclusion of Members in Any Order (TypeScript)\nDESCRIPTION: Defines `assert.includeDeepMembers` to check if all `subset` objects are included in `superset` with deep equality, ignoring duplicates.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_93\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\n test('assert.includeDeepMembers', () => {\n  assert.includeDeepMembers([{ a: 1 }, { b: 2 }, { c: 3 }], [{ b: 2 }, { a: 1 }, { b: 2 }], 'include deep members')\n})\n```\n\n----------------------------------------\n\nTITLE: Disabling Vitest File Parallelism (CLI & Config)\nDESCRIPTION: Shows how to prevent multiple test files from running in parallel to potentially improve startup time. This can be achieved using the `--no-file-parallelism` CLI flag or the `test.fileParallelism` config option.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/improving-performance.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nvitest --no-file-parallelism\n```\n\nLANGUAGE: ts\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    fileParallelism: false,\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Updating Vitest Configuration per File with vi.setConfig (TypeScript)\nDESCRIPTION: Shows how to use `vi.setConfig` within a test file to dynamically override specific Vitest configuration options for that file only. This example updates timeouts, mock behavior, fake timer settings, concurrency, and sequence options. Use `vi.resetConfig()` to revert these changes.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_38\n\nLANGUAGE: typescript\nCODE:\n```\nvi.setConfig({\n  allowOnly: true,\n  testTimeout: 10_000,\n  hookTimeout: 10_000,\n  clearMocks: true,\n  restoreMocks: true,\n  fakeTimers: {\n    now: new Date(2021, 11, 19),\n    // supports the whole object\n  },\n  maxConcurrency: 10,\n  sequence: {\n    hooks: 'stack'\n    // supports only \"sequence.hooks\"\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Extending Vitest Defaults\nDESCRIPTION: This snippet demonstrates how to extend Vitest's default options using `configDefaults` and `defineConfig` from `vitest/config`. It excludes specific files or directories from the test suite by modifying the `exclude` property.  This approach allows customization of default Vitest behavior.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { configDefaults, defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    exclude: [...configDefaults.exclude, 'packages/template/*'],\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: toBeValid Assertion Example\nDESCRIPTION: Shows how to use the toBeValid assertion to check if an element is currently valid based on aria-invalid attribute and form validation.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_8\n\nLANGUAGE: html\nCODE:\n```\n<input data-testid=\"no-aria-invalid\" />\n<input data-testid=\"aria-invalid\" aria-invalid />\n<input data-testid=\"aria-invalid-value\" aria-invalid=\"true\" />\n<input data-testid=\"aria-invalid-false\" aria-invalid=\"false\" />\n\n<form data-testid=\"valid-form\">\n  <input />\n</form>\n\n<form data-testid=\"invalid-form\">\n  <input required />\n</form>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nawait expect.element(getByTestId('no-aria-invalid')).toBeValid()\nawait expect.element(getByTestId('aria-invalid')).not.toBeValid()\nawait expect.element(getByTestId('aria-invalid-value')).not.toBeValid()\nawait expect.element(getByTestId('aria-invalid-false')).toBeValid()\n\nawait expect.element(getByTestId('valid-form')).toBeValid()\nawait expect.element(getByTestId('invalid-form')).not.toBeValid()\n```\n\n----------------------------------------\n\nTITLE: Deprecated environmentMatchGlobs - TypeScript\nDESCRIPTION: This snippet demonstrates the deprecated `environmentMatchGlobs` option in Vitest. It is replaced by the `workspace` configuration. The snippet shows how to migrate from `environmentMatchGlobs` to using a `workspace` to configure environments. The `extends: true` means it inherits base configuration.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_17\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport default defineConfig({\n  test: {\n    environmentMatchGlobs: [ // [!code --]\n      ['./*.jsdom.test.ts', 'jsdom'], // [!code --]\n    ], // [!code --]\n    workspace: [ // [!code ++]\n      { // [!code ++]\n        extends: true, // [!code ++]\n        test: { // [!code ++]\n          environment: 'jsdom', // [!code ++]\n        }, // [!code ++]\n      }, // [!code ++]\n    ], // [!code ++]\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Using assert.hasAllKeys in Vitest (TypeScript)\nDESCRIPTION: Demonstrates `assert.hasAllKeys`, which asserts that an object, Map, or Set contains all, and only all, of the specified keys. Keys can be provided as an array or implicitly via another object's keys. The example imports from `vitest` and shows checks for objects, Maps, and Sets within a test.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_70\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.hasAllKeys', () => {\n  assert.hasAllKeys({ foo: 1, bar: 2, baz: 3 }, ['foo', 'bar', 'baz'])\n  assert.hasAllKeys({ foo: 1, bar: 2, baz: 3 }, { foo: 30, bar: 99, baz: 1337 })\n  assert.hasAllKeys(new Map([[{ foo: 1 }, 'bar'], ['key', 'value']]), [{ foo: 1 }, 'key'])\n  assert.hasAllKeys(new Set([{ foo: 'bar' }, 'anotherKey'], [{ foo: 'bar' }, 'anotherKey']))\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Inline Dependencies in Vitest with TypeScript\nDESCRIPTION: Demonstrates how to configure Vite/Vitest to explicitly inline third-party dependencies for module mocking using the server.deps.inline property. This ensures that external libraries using the same module are mocked as well. Requires a Vite or Vitest project and knowledge of dependency names. Input is an array of dependency names; output is proper inline configuration. This setting may increase bundle size.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/migration.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nserver.deps.inline: [\"lib-name\"]\n```\n\n----------------------------------------\n\nTITLE: Calling Custom Command Vitest TypeScript\nDESCRIPTION: Demonstrates how to call a custom command, previously defined in the Vitest configuration, from within a browser test by importing it via `commands` from `@vitest/browser/context`. It also includes the necessary TypeScript module augmentation to provide type safety and autocompletion for the custom command. The command executes on the server and returns a promise resolving with the result.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/commands.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { commands } from '@vitest/browser/context'\nimport { expect, test } from 'vitest'\n\ntest('custom command works correctly', async () => {\n  const result = await commands.myCustomCommand('test1', 'test2')\n  expect(result).toEqual({ someValue: true })\n})\n\n// if you are using TypeScript, you can augment the module\ndeclare module '@vitest/browser/context' {\n  interface BrowserCommands {\n    myCustomCommand: (arg1: string, arg2: string) => Promise<{\n      someValue: true\n    }>\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using JUnit Reporter - CLI\nDESCRIPTION: This snippet shows how to use the 'junit' reporter using the command-line. It utilizes the `--reporter=junit` option when running vitest. This will output the results in JUnit XML format.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/reporters.md#_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nnpx vitest --reporter=junit\n```\n\n----------------------------------------\n\nTITLE: toBeInvalid Assertion Example\nDESCRIPTION: Shows how to use the toBeInvalid assertion to check if an element is currently invalid based on aria-invalid attribute or form validation.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_6\n\nLANGUAGE: html\nCODE:\n```\n<input data-testid=\"no-aria-invalid\" />\n<input data-testid=\"aria-invalid\" aria-invalid />\n<input data-testid=\"aria-invalid-value\" aria-invalid=\"true\" />\n<input data-testid=\"aria-invalid-false\" aria-invalid=\"false\" />\n\n<form data-testid=\"valid-form\">\n  <input />\n</form>\n\n<form data-testid=\"invalid-form\">\n  <input required />\n</form>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nawait expect.element(getByTestId('no-aria-invalid')).not.toBeInvalid()\nawait expect.element(getByTestId('aria-invalid')).toBeInvalid()\nawait expect.element(getByTestId('aria-invalid-value')).toBeInvalid()\nawait expect.element(getByTestId('aria-invalid-false')).not.toBeInvalid()\n\nawait expect.element(getByTestId('valid-form')).not.toBeInvalid()\nawait expect.element(getByTestId('invalid-form')).toBeInvalid()\n```\n\n----------------------------------------\n\nTITLE: Checking Undefined Types with Vitest\nDESCRIPTION: This snippet uses the `toBeUndefined()` matcher to assert if a type is undefined. It imports `expectTypeOf` from 'vitest'. The matcher checks if the provided type is undefined. It shows positive and negative tests.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect-typeof.md#_snippet_24\n\nLANGUAGE: ts\nCODE:\n```\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf(undefined).toBeUndefined()\nexpectTypeOf<undefined>().toBeUndefined()\nexpectTypeOf(null).not.toBeUndefined()\n```\n\n----------------------------------------\n\nTITLE: Asserting Inclusion in Array with Vitest in TypeScript\nDESCRIPTION: `toBeOneOf` matcher verifies if a value matches any value within a provided array, useful for flexible matching like optional properties being null or undefined. Dependencies include Vitest's `expect` and `test`. Inputs are test values and arrays of allowed values; outputs are test pass/fail results.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { expect, test } from 'vitest'\n\ntest('fruit is one of the allowed values', () => {\n  expect(fruit).toBeOneOf(['apple', 'banana', 'orange'])\n})\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\ntest('optional properties can be null or undefined', () => {\n  const user = {\n    firstName: 'John',\n    middleName: undefined,\n    lastName: 'Doe'\n  }\n\n  expect(user).toEqual({\n    firstName: expect.any(String),\n    middleName: expect.toBeOneOf([expect.any(String), undefined]),\n    lastName: expect.any(String),\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Asserting a Value is Not a Number using Vitest (TypeScript)\nDESCRIPTION: Shows how to use `assert.isNotNumber` in a Vitest test to verify that a variable does not contain a number. Requires `assert` and `test` from 'vitest'.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_34\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\nconst colors = '3 colors'\n\ntest('assert.isNotNumber', () => {\n  assert.isNotNumber(colors, 'colors is not number but strings')\n})\n```\n\n----------------------------------------\n\nTITLE: Asserting String Types with Vitest in TypeScript\nDESCRIPTION: Uses `.toBeString` to verify a value or type is a string. Requires Vitest and works with string literals and string type assertions. Important for APIs expecting string data or interfaces.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect-typeof.md#_snippet_19\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf(42).not.toBeString()\nexpectTypeOf('').toBeString()\nexpectTypeOf('a').toBeString()\n```\n\n----------------------------------------\n\nTITLE: Updating Test PoolOptions for Default Forks in Vitest (TypeScript)\nDESCRIPTION: Demonstrates how to migrate test runner 'poolOptions' from threads to forks as the default pool setting changes in Vitest 2.0. Requires defineConfig from Vitest. Key parameters: poolOptions. Outcome: more stable test environment.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/migration.md#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport default defineConfig({\n  test: {\n    poolOptions: {\n      threads: {\n        singleThread: true,\n      },\n      forks: {\n        singleFork: true,\n      },\n    }\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Testing Asynchronous Code with Vitest Using Promise Pattern in JavaScript\nDESCRIPTION: This snippet illustrates how to handle asynchronous tests by returning a Promise from the test function in Vitest. The Promise constructor receives a done callback, which is called inside the Promise to indicate completion. This approach replaces explicit done callback parameters and leverages promise resolution. Vitest and JavaScript promise support are required. The test function returns a Promise that resolves when the async process completes.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/examples/promise-done.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nit('should work', () => new Promise(done => { // [!code ++]\n  // ...\n  done()\n}) // [!code --]\n})) // [!code ++]\n```\n\n----------------------------------------\n\nTITLE: Merging Vitest Config with Vite Config\nDESCRIPTION: This snippet demonstrates how to merge a Vitest configuration with an existing Vite configuration using `mergeConfig` and `defineConfig` from `vitest/config`. It imports the Vite configuration and extends it with specific test settings, such as excluding certain files. This approach enables reusing existing Vite configurations while adding specific settings for testing. It assumes there is a `vite.config.js` file in the same directory.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig, mergeConfig } from 'vitest/config'\nimport viteConfig from './vite.config'\n\nexport default mergeConfig(viteConfig, defineConfig({\n  test: {\n    exclude: ['packages/template/*'],\n  },\n}))\n```\n\n----------------------------------------\n\nTITLE: Asserting Symbol Types with Vitest in TypeScript\nDESCRIPTION: Checks if a value or type is a symbol using `.toBeSymbol`. Requires Vitest and applies to symbol instances and symbol type assertions. Useful for APIs and feature flags building on symbols.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect-typeof.md#_snippet_22\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf(Symbol(1)).toBeSymbol()\nexpectTypeOf<symbol>().toBeSymbol()\n```\n\n----------------------------------------\n\nTITLE: Using testLines to Specify Test Execution Lines (TypeScript)\nDESCRIPTION: Provides an example of using the `testLines` option when creating a TestSpecification. The first snippet shows passing specific line numbers (3, 8, 9) to `createSpecification`. The second snippet shows the corresponding test file (`example.test.js`), highlighting the lines where tests are defined that match the provided `testLines`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/test-specification.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\n// script.js\nconst specification = project.createSpecification(\n  resolve('./example.test.ts'),\n  [3, 8, 9],\n)\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\n// example.test.js\nimport { test, describe } from 'vitest'\n\ntest('verification works') // line 3\n\ndescribe('a group of tests', () => { // [!code error]\n  // ...\n\n  test('nested test') // line 8\n  test.skip('skipped test') // line 9\n})\n```\n\n----------------------------------------\n\nTITLE: Snapshot Run Initialization\nDESCRIPTION: Starts a snapshot run by calling `client.startCurrentRun` with the current file path, test name, and snapshot options (e.g., `updateSnapshot: 'new'`).  This initializes the snapshot environment for the current test.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/snapshot/README.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst options = {\n  updateSnapshot: 'new',\n  snapshotEnvironment: environment,\n}\n\nawait client.startCurrentRun(\n  getCurrentFilepath(),\n  getCurrentTestName(),\n  options\n)\n```\n\n----------------------------------------\n\nTITLE: Array Inclusion of Members in Any Order (TypeScript)\nDESCRIPTION: Defines `assert.includeMembers` to verify that `subset` elements are included in `superset` regardless of order, using strict equality. Duplicates are ignored.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_91\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\n test('assert.includeMembers', () => {\n  assert.includeMembers([1, 2, 3], [2, 1, 2], 'include members')\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing onInit Reporter Method in Vitest with TypeScript\nDESCRIPTION: Shows a reporter implementation capturing the Vitest instance during the onInit lifecycle hook to store it for later use. Utilizes the 'vitest/node' types for strong typing. This allows access to the Vitest config root during later hooks, like onTestRunStart. Requires familiarity with Vitest's Reporter interface and lifecycle hooks.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/reporters.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { Reporter, TestSpecification, Vitest } from 'vitest/node'\n\nclass MyReporter implements Reporter {\n  private vitest!: Vitest\n\n  onInit(vitest: Vitest) {\n    this.vitest = vitest\n  }\n\n  onTestRunStart(specifications: TestSpecification[]) {\n    console.log(\n      specifications.length,\n      'test files will run in',\n      this.vitest.config.root,\n    )\n  }\n}\n\nexport default new MyReporter()\n```\n\n----------------------------------------\n\nTITLE: Configuring Vitest Pool to 'forks'\nDESCRIPTION: This code snippet illustrates how to configure the test pool option in `vitest.config.js` to use the 'forks' pool.  The 'forks' pool executes tests in separate `node:child_process` instances, which can be used as a workaround for issues like NodeJS's `fetch` failing to terminate or native code errors when using the default 'threads' pool. Using 'forks' provides process-level isolation for tests.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/common-errors.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    pool: 'forks',\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Running Vitest Tests via pnpm\nDESCRIPTION: This code snippet outlines how to run tests within a Vitest workspace using the pnpm package manager.  It includes options for running all tests and only tests inside of a single project.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/workspace.md#_snippet_12\n\nLANGUAGE: Bash\nCODE:\n```\npnpm run test\n```\n\n----------------------------------------\n\nTITLE: Demonstrate testNamePattern Filtering in JavaScript\nDESCRIPTION: Illustrates the usage of the `testNamePattern` option to filter tests. This example shows two tests: one matching the pattern 'OnlyRunThis' (which will run) and one that does not match (which will be skipped). Requires `expect` and `test` from 'vitest'.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_33\n\nLANGUAGE: js\nCODE:\n```\nimport { expect, test } from 'vitest'\n\n// run\ntest('OnlyRunThis', () => {\n  expect(true).toBe(true)\n})\n\n// skipped\ntest('doNotRun', () => {\n  expect(true).toBe(true)\n})\n```\n\n----------------------------------------\n\nTITLE: Defining the toJSON Method Signature for TestSpecification (TypeScript)\nDESCRIPTION: Shows the TypeScript function signature for the `toJSON` method of the TestSpecification class. This method serializes the specification into a JSON-friendly object, suitable for use in environments like Browser Mode or Vitest UI.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/test-specification.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction toJSON(): SerializedTestSpecification\n```\n\n----------------------------------------\n\nTITLE: Inline Snapshot Wrapper\nDESCRIPTION: Creates a wrapper function to handle inline snapshots. This wrapper includes a `toMatchInlineSnapshot` function, which in turn calls `client.assert` with `isInline: true`.  It finds the actual test file using call stack trace parsing.  A custom SnapshotState can be provided to the SnapshotClient constructor to override the default `_inferInlineSnapshotStack` behavior.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/snapshot/README.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n// example for inline snapshots, nothing is required to support regular snapshots,\n// just call `assert` with `isInline: false`\nfunction wrapper(received) {\n  function __INLINE_SNAPSHOT__(inlineSnapshot, message) {\n    client.assert({\n      received,\n      message,\n      isInline: true,\n      inlineSnapshot,\n      filepath: getCurrentFilepath(),\n      name: getCurrentTestName(),\n    })\n  }\n  return {\n    // the name is hard-coded, it should be inside another function, so Vitest can find the actual test file where it was called (parses call stack trace + 2)\n    // you can override this behaviour in SnapshotState's `_inferInlineSnapshotStack` method by providing your own SnapshotState to SnapshotClient constructor\n    toMatchInlineSnapshot: (...args) => __INLINE_SNAPSHOT__(...args),\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Ordered Subset Inclusion in Array (TypeScript)\nDESCRIPTION: Defines `assert.includeOrderedMembers` to verify that `subset` appears in `superset` in the same sequence, starting from the beginning, using strict equality.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_95\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\n test('assert.includeOrderedMembers', () => {\n  assert.includeOrderedMembers([1, 2, 3], [1, 2], 'include ordered members')\n})\n```\n\n----------------------------------------\n\nTITLE: Assert Value is NaN with Vitest\nDESCRIPTION: This demonstrates `assert.isNaN`, which asserts that a given value is NaN. It requires the `vitest` framework. The input is a value, and the assertion passes if the value is NaN.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_19\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\nconst calculation = 1 * 'vitest'\n\ntest('assert.isNaN', () => {\n  assert.isNaN(calculation, '1 * \"vitest\" is NaN')\n})\n```\n\n----------------------------------------\n\nTITLE: Handling Test Suite Completion Event in Vitest - TypeScript\nDESCRIPTION: Defines the `onTestSuiteResult` function which is called asynchronously after a test suite has finished running its tests or was skipped. It takes a `TestSuite` parameter to represent the suite that finished. Similar to `onTestSuiteReady`, this function will not be called if no test suites are present, and in that case, `onTestModuleEnd` may be used to handle the test module completion.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/reporters.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction onTestSuiteResult(testSuite: TestSuite): Awaitable<void>\n```\n\n----------------------------------------\n\nTITLE: TestCollection tests method definition\nDESCRIPTION: Defines a function `tests` that returns a Generator for iterating over TestCase objects directly within the TestCollection (not its children).  It accepts an optional TestState parameter to filter tests by state.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/test-collection.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nfunction tests(state?: TestState): Generator<TestCase, undefined, void>\n```\n\n----------------------------------------\n\nTITLE: Using elements for Multi-Match Selection in Vitest (TypeScript and HTML)\nDESCRIPTION: Presents a DOM structure and demonstrates .elements() returning arrays of matching HTMLElements for given selectors. Illustrates return values for different matching situations; empty array if none match. Requires correct DOM layout and locator methods for real use.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_52\n\nLANGUAGE: html\nCODE:\n```\n<div>Hello <span>World</span></div>\n<div>Hello</div>\n```\n\nLANGUAGE: typescript\nCODE:\n```\npage.getByText('Hello World').elements() // ✅ [HTMLElement]\npage.getByText('World').elements() // ✅ [HTMLElement]\npage.getByText('Hello', { exact: true }).elements() // ✅ [HTMLElement]\npage.getByText('Hello').element() // ✅ [HTMLElement, HTMLElement]\npage.getByText('Hello USA').elements() // ✅ []\n```\n\n----------------------------------------\n\nTITLE: Declaring fill Function in Vitest (TypeScript)\nDESCRIPTION: Defines the fill function signature, setting the value for input, textarea, or contenteditable elements. Takes a text string to input and optional UserEventFillOptions, returning a Promise resolved after the fill completes. Useful for form automation in tests; outputs a void Promise. Requires a writable element as target, and manages underlying change/input events.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_38\n\nLANGUAGE: typescript\nCODE:\n```\nfunction fill(text: string, options?: UserEventFillOptions): Promise<void>\n```\n\n----------------------------------------\n\nTITLE: Outputting TAP Format Reports with Vitest Reporter in TypeScript and CLI\nDESCRIPTION: Enables Vitest to output a test report formatted according to the Test Anything Protocol (TAP), suitable for integration with TAP-compliant tools. The example provides the CLI command and TypeScript configuration for selecting the 'tap' reporter. An example TAP report output shows the hierarchical structure with detailed error information including assertion failures, error type, message, and source location.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/reporters.md#_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\nnpx vitest --reporter=tap\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport default defineConfig({\n  test: {\n    reporters: [\"tap\"]\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Using JSON Reporter - CLI\nDESCRIPTION: This snippet shows how to use the 'json' reporter using the command-line.  It utilizes the `--reporter=json` option when running vitest. This will output the results in JSON format.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/reporters.md#_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\nnpx vitest --reporter=json\n```\n\n----------------------------------------\n\nTITLE: Finding __mocks__ Folder Redirection with findMockRedirect - TypeScript\nDESCRIPTION: Illustrates use of the findMockRedirect utility to resolve the file path corresponding to a mock for a given module, using synchronous filesystem queries. Requires @vitest/mocker/node and a root path variable. Supports both source files and library modules, returning the expected path for the corresponding mock file under __mocks__.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/mocker/EXPORTS.md#_snippet_16\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { findMockRedirect } from '@vitest/mocker/node'\n\n// uses sync fs APIs\nconst mockRedirect = findMockRedirect(\n  root,\n  'vscode',\n  'vscode', // if defined, will assume the file is a library name\n)\n// mockRedirect == ${root}/__mocks__/vscode.js\n```\n\n----------------------------------------\n\nTITLE: Installing and Building Vitest from Source\nDESCRIPTION: Instructions for cloning, installing dependencies, building, and linking Vitest locally to test modifications. This process requires pnpm as the package manager.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/index.md#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/vitest-dev/vitest.git\ncd vitest\npnpm install\ncd packages/vitest\npnpm run build\npnpm link --global # you can use your preferred package manager for this step\n```\n\n----------------------------------------\n\nTITLE: Asserting Value Type with Vitest in TypeScript\nDESCRIPTION: `toBeTypeOf` matcher tests whether a value is of a specific JavaScript type such as 'string' or 'number'. Requires Vitest's `expect` and `test`. Input is the actual value and expected type string; output is success if types match.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { expect, test } from 'vitest'\n\nconst actual = 'stock'\n\ntest('stock is type of string', () => {\n  expect(actual).toBeTypeOf('string')\n})\n```\n\n----------------------------------------\n\nTITLE: Example Usage of Custom Serializer (TypeScript)\nDESCRIPTION: This shows an example of how a custom serializer is used in a test. It defines a simple object and then uses `toMatchSnapshot` to create a snapshot using the defined custom serializer. Dependencies: custom serializer. Input: Object to serialize. Output: Snapshot of the serialized object.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/snapshot.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\ntest('foo snapshot test', () => {\n  const bar = {\n    foo: {\n      x: 1,\n      y: 2,\n    },\n  }\n\n  expect(bar).toMatchSnapshot()\n})\n```\n\n----------------------------------------\n\nTITLE: Using assert.lengthOf in Vitest (TypeScript)\nDESCRIPTION: Demonstrates `assert.lengthOf`, which asserts that an object (like an array, string, Set, or Map) has a specific `length` or `size`. The example imports from `vitest` and shows checks for arrays, strings, Sets, and Maps within a test, including optional messages.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_68\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.lengthOf', () => {\n  assert.lengthOf([1, 2, 3], 3, 'array has length of 3')\n  assert.lengthOf('foobar', 6, 'string has length of 6')\n  assert.lengthOf(new Set([1, 2, 3]), 3, 'set has size of 3')\n  assert.lengthOf(new Map([['a', 1], ['b', 2], ['c', 3]]), 3, 'map has size of 3')\n})\n```\n\n----------------------------------------\n\nTITLE: Accessing Class Instance Properties with Vitest in TypeScript\nDESCRIPTION: Uses `.instance` to perform type assertions on instances of classes, allowing checks for presence and typing of properties and methods. Depends on Vitest and a valid constructable class. Supports comprehensive instance shape validation in tests.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect-typeof.md#_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf(Date).instance.toHaveProperty('toISOString')\n```\n\n----------------------------------------\n\nTITLE: Using assert.deepNestedPropertyVal in Vitest (TypeScript)\nDESCRIPTION: Illustrates `assert.deepNestedPropertyVal`, which asserts that an object has a nested property (using dot/bracket notation) with a value that is deeply equal to the provided value. The example imports from `vitest` and uses `assert.notNestedPropertyVal` mistakenly; it should demonstrate `assert.deepNestedPropertyVal`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_66\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.notNestedPropertyVal', () => { // Note: Test name and assertion used seem incorrect based on section title\n  assert.notNestedPropertyVal({ tea: { green: 'matcha' } }, 'tea.green', 'konacha')\n  assert.notNestedPropertyVal({ tea: { green: 'matcha' } }, 'coffee.green', 'matcha')\n})\n```\n\n----------------------------------------\n\nTITLE: Asserting a Value is Finite using Vitest (TypeScript)\nDESCRIPTION: Illustrates using `assert.isFinite` in a Vitest test to confirm a variable is a finite number (not NaN or Infinity). Depends on `assert` and `test` from 'vitest'.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_35\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\nconst colors = 3\n\ntest('assert.isFinite', () => {\n  assert.isFinite(colors, 'colors is number not NaN or Infinity')\n})\n```\n\n----------------------------------------\n\nTITLE: Using Context-Bound Expect in Vitest\nDESCRIPTION: Example of using the expect API bound to the current test context, which is useful for running snapshot tests concurrently.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/test-context.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { it } from 'vitest'\n\nit('math is easy', ({ expect }) => {\n  expect(2 + 2).toBe(4)\n})\n```\n\n----------------------------------------\n\nTITLE: Checking for `any` Type using Vitest in TypeScript\nDESCRIPTION: Uses `.toBeAny` matcher to assert that a provided value is of type `any`. Requires Vitest and operates at the static type level. Enables detection and prevention of overly broad types in code bases.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect-typeof.md#_snippet_13\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf<any>().toBeAny()\nexpectTypeOf({} as any).toBeAny()\nexpectTypeOf('string').not.toBeAny()\n```\n\n----------------------------------------\n\nTITLE: Asserting Void Types with Vitest in TypeScript\nDESCRIPTION: Uses `.toBeVoid` to assert if the tested type is `void`, particularly for function returns. Requires Vitest and is used for verifying side-effect-only or non-returning functions.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect-typeof.md#_snippet_21\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf(() => {}).returns.toBeVoid()\nexpectTypeOf<void>().toBeVoid()\n```\n\n----------------------------------------\n\nTITLE: Handling Multiple Line Selections with Vitest CLI - Bash\nDESCRIPTION: Illustrates the attempt to run tests across multiple specified line numbers or ranges within a file using Vitest. Currently supported: running tests at distinct line numbers separated by commas. Not supported: specifying a range using dash notation. Input: line numbers (comma-separated or range) with filename. Output: Only tests at specifically listed lines are executed; ranges are ignored. Limitation: range syntax (e.g., 10-25) is not supported.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/cli.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ vitest basic/foo.test.ts:10, basic/foo.test.ts:25 # ✅\n$ vitest basic/foo.test.ts:10-25 # ❌\n\n```\n\n----------------------------------------\n\nTITLE: Test Name Formatting Differences: Jest vs Vitest in Diff\nDESCRIPTION: Shows the difference between how Jest and Vitest format joined test and suite names. This helps developers adjust their tooling and assertions when migrating. No dependencies. Accepts describeTitle and testTitle strings and joins them with either a space (Jest) or > (Vitest).\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/migration.md#_snippet_11\n\nLANGUAGE: diff\nCODE:\n```\n- `${describeTitle} ${testTitle}`\n+ `${describeTitle} > ${testTitle}`\n```\n\n----------------------------------------\n\nTITLE: Executing Only Initially Pending Fake Timers with Vitest vi.runOnlyPendingTimers in TypeScript\nDESCRIPTION: Illustrates `vi.runOnlyPendingTimers`, which synchronously executes only the timers that were scheduled *before* this function was called. It does not execute timers scheduled *during* its own execution. Requires `vi` from `vitest` and enabling fake timers.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_26\n\nLANGUAGE: ts\nCODE:\n```\nlet i = 0\nsetInterval(() => console.log(++i), 50)\n\nvi.runOnlyPendingTimers()\n\n// log: 1\n```\n\n----------------------------------------\n\nTITLE: Checking if Vitest Server Should Remain Active (TypeScript)\nDESCRIPTION: Returns a boolean indicating whether the Vitest server should be kept running after the tests finish. This is typically `true` when running in watch mode (`--watch`).\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/vitest.md#_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\nfunction shouldKeepServer(): boolean\n```\n\n----------------------------------------\n\nTITLE: Advancing to the Next Fake Timer with Vitest vi.advanceTimersToNextTimer in TypeScript\nDESCRIPTION: Illustrates using `vi.advanceTimersToNextTimer` to execute only the next scheduled timer callback synchronously. This method is chainable and useful for making assertions between individual timer executions. Requires `vi` from `vitest` and enabling fake timers.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_21\n\nLANGUAGE: ts\nCODE:\n```\nlet i = 0\nsetInterval(() => console.log(++i), 50)\n\nvi.advanceTimersToNextTimer() // log: 1\n  .advanceTimersToNextTimer() // log: 2\n  .advanceTimersToNextTimer() // log: 3\n```\n\n----------------------------------------\n\nTITLE: Assert Value is Not NaN with Vitest\nDESCRIPTION: This demonstrates `assert.isNotNaN`, which asserts that a value is not NaN.  It uses the `vitest` framework.  The input is a value, and the assertion passes if the value is not NaN.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_20\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\nconst calculation = 1 * 2\n\ntest('assert.isNotNaN', () => {\n  assert.isNotNaN(calculation, '1 * 2 is Not NaN but 2')\n})\n```\n\n----------------------------------------\n\nTITLE: Example HTML Structure for toHaveDisplayValue Usage - HTML\nDESCRIPTION: This HTML snippet provides example form elements including text input, textarea, single select, and multiple select with various option values. These serve as test targets for the `toHaveDisplayValue` function to verify visible values shown to users.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_29\n\nLANGUAGE: html\nCODE:\n```\n<label for=\"input-example\">First name</label>\n<input type=\"text\" id=\"input-example\" value=\"Luca\" />\n\n<label for=\"textarea-example\">Description</label>\n<textarea id=\"textarea-example\">An example description here.</textarea>\n\n<label for=\"single-select-example\">Fruit</label>\n<select id=\"single-select-example\">\n  <option value=\"\">Select a fruit...</option>\n  <option value=\"banana\">Banana</option>\n  <option value=\"ananas\">Ananas</option>\n  <option value=\"avocado\">Avocado</option>\n</select>\n\n<label for=\"multiple-select-example\">Fruits</label>\n<select id=\"multiple-select-example\" multiple>\n  <option value=\"\">Select a fruit...</option>\n  <option value=\"banana\" selected>Banana</option>\n  <option value=\"ananas\">Ananas</option>\n  <option value=\"avocado\" selected>Avocado</option>\n</select>\n```\n\n----------------------------------------\n\nTITLE: Displaying Hanging Processes with Vitest Hanging-Process Reporter in TypeScript and CLI\nDESCRIPTION: Uses the 'hanging-process' reporter in Vitest to detect and display any processes preventing Vitest from exiting properly. This reporter does not show test results and is intended mainly for debugging process lifecycle issues. Example CLI command and TypeScript configuration illustrate how to enable this reporter. It should be used carefully as it may be resource-intensive.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/reporters.md#_snippet_20\n\nLANGUAGE: bash\nCODE:\n```\nnpx vitest --reporter=hanging-process\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport default defineConfig({\n  test: {\n    reporters: [\"hanging-process\"]\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Calling vi.mock to Automock a Module at Runtime - TypeScript\nDESCRIPTION: Demonstrates the use of vi.mock within application code to mock external modules. Requires prior setup of mocking infrastructure with Vitest and import of the targeted module. The mocked object is validated via direct comparison. Suitable for runtime mocking and verification in tests.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/mocker/EXPORTS.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { mocked } from './some-module.js'\n\nvi.mock('./some-module.js', () => {\n  return { mocked: true }\n})\n\nmocked === true\n```\n\n----------------------------------------\n\nTITLE: Declaring query Function in Vitest (TypeScript)\nDESCRIPTION: Declares the query function, returning a single DOM element matching the locator, or null if none found. Throws an error if multiple elements match the selector. Useful for conditional logic based on element presence; intended for precise, unambiguous selections only. Does not throw if zero elements are found.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_46\n\nLANGUAGE: typescript\nCODE:\n```\nfunction query(): Element | null\n```\n\n----------------------------------------\n\nTITLE: HTML Example Markup for Partially Checked and Indeterminate Checkboxes - HTML\nDESCRIPTION: HTML snippet shows checkboxes with `aria-checked=\"mixed\"`, checked, unchecked, and indeterminate states. It also includes div elements with checkbox roles and various aria-checked states for testing partial selection scenarios.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_35\n\nLANGUAGE: html\nCODE:\n```\n<input type=\"checkbox\" aria-checked=\"mixed\" data-testid=\"aria-checkbox-mixed\" />\n<input type=\"checkbox\" checked data-testid=\"input-checkbox-checked\" />\n<input type=\"checkbox\" data-testid=\"input-checkbox-unchecked\" />\n<div role=\"checkbox\" aria-checked=\"true\" data-testid=\"aria-checkbox-checked\" />\n<div\n  role=\"checkbox\"\n  aria-checked=\"false\"\n  data-testid=\"aria-checkbox-unchecked\"\n/>\n<input type=\"checkbox\" data-testid=\"input-checkbox-indeterminate\" />\n```\n\n----------------------------------------\n\nTITLE: hoistMocks Transformed Output for Module with vi.mock - JavaScript\nDESCRIPTION: Displays the output code produced by hoistMocks, with the static import replaced by a dynamic import and references updated. Ensures the mocked module is fully resolved before consumption. Consumes the standard ES dynamic import and updates variable access for mocking compliance.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/mocker/EXPORTS.md#_snippet_13\n\nLANGUAGE: JavaScript\nCODE:\n```\nvi.mock('./some-module.js', () => {\n  return { mocked: true }\n})\n\nconst __vi_import_0__ = await import('./some-module.js')\n__vi_import_0__.mocked === true\n```\n\n----------------------------------------\n\nTITLE: Automocking a Module with Query Parameter - TypeScript\nDESCRIPTION: Demonstrates importing a module with ?mock=automock query, triggering automocking by the Vite plugin. Requires the automockPlugin integration in Vite and appropriate global mocks infrastructure. The imported calculator module will have all exports mocked and calls traced for assertion.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/mocker/EXPORTS.md#_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { calculator } from './src/calculator.js?mock=automock'\n\ncalculator(1, 2)\ncalculator.mock.calls[0] === [1, 2]\n```\n\n----------------------------------------\n\nTITLE: Configuring pnpm Overrides for Local Vitest Testing (JSON)\nDESCRIPTION: This JSON snippet demonstrates how to configure `pnpm.overrides` in the root `package.json` of an external project to link and test a locally modified version of Vitest. The `vitest` dependency must also be listed under `dependencies`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/CONTRIBUTING.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"dependencies\": {\n    \"vitest\": \"*\"\n  },\n  \"pnpm\": {\n    \"overrides\": {\n      \"vitest\": \"link:../path/to/vitest/packages/vitest\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: toBeEmptyDOMElement Assertion Example\nDESCRIPTION: Shows how to use the toBeEmptyDOMElement assertion to check if an element has no visible content for the user.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_4\n\nLANGUAGE: html\nCODE:\n```\n<span data-testid=\"not-empty\"><span data-testid=\"empty\"></span></span>\n<span data-testid=\"with-whitespace\"> </span>\n<span data-testid=\"with-comment\"><!-- comment --></span>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nawait expect.element(getByTestId('empty')).toBeEmptyDOMElement()\nawait expect.element(getByTestId('not-empty')).not.toBeEmptyDOMElement()\nawait expect.element(\n  getByTestId('with-whitespace')\n).not.toBeEmptyDOMElement()\n```\n\n----------------------------------------\n\nTITLE: Asserting Deep Non-Inclusion in Arrays or Objects using Vitest (TypeScript)\nDESCRIPTION: Demonstrates `assert.notDeepInclude` in Vitest tests to verify the absence of values in arrays or objects using deep equality comparison. Requires `assert` and `test`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_45\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\nconst obj1 = { a: 1 }\nconst obj2 = { b: 2 }\n\ntest('assert.notDeepInclude', () => {\n  assert.notDeepInclude([obj1, obj2], { a: 10 })\n  assert.notDeepInclude({ foo: obj1, bar: obj2 }, { foo: { a: 10 } })\n})\n```\n\n----------------------------------------\n\nTITLE: Asserting Target is Not Empty with Vitest - TypeScript\nDESCRIPTION: Asserts that the given target contains at least one value. Checks include arrays, strings, Sets, and objects with enumerable properties. Uses Vitest, and passes if the target's length, size, or key count is greater than zero.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_121\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.isNotEmpty', () => {\n  assert.isNotEmpty([1, 2])\n  assert.isNotEmpty('34')\n  assert.isNotEmpty(new Set([5, 6]))\n  assert.isNotEmpty({ key: 7 })\n})\n```\n\n----------------------------------------\n\nTITLE: Manually Modifying Global Variables (Alternative to vi.stubGlobal) in TypeScript\nDESCRIPTION: Illustrates an alternative way to modify global variables by directly assigning them to `globalThis` or `window` (in JSDOM/Happy-DOM environments). This method provides no built-in way to restore the original value using Vitest's `vi.unstubAllGlobals` function.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_17\n\nLANGUAGE: ts\nCODE:\n```\nglobalThis.innerWidth = 100\n// if you are using jsdom or happy-dom\nwindow.innerWidth = 100\n```\n\n----------------------------------------\n\nTITLE: Asserting Promise Resolution Types with Vitest in TypeScript\nDESCRIPTION: Uses `.resolves` to extract the type of the resolved value from a Promise, enabling further type assertions. Requires Vitest, works with function types that return a Promise or explicit Promise values, and allows chained type checks on asynchronous logic.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect-typeof.md#_snippet_10\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { expectTypeOf } from 'vitest'\n\nasync function asyncFunc() {\n  return 123\n}\n\nexpectTypeOf(asyncFunc).returns.resolves.toBeNumber()\nexpectTypeOf(Promise.resolve('string')).resolves.toBeString()\n```\n\n----------------------------------------\n\nTITLE: Configuring Diff Options via Module in Vitest (TypeScript)\nDESCRIPTION: Demonstrates how to configure Vitest's diff options by providing a path to a module that exports a `DiffOptions` object. Illustrates creating a separate file (`vitest.diff.ts`) containing the diff configuration.  Requires `vitest` types for `DiffOptions` and a color library like `picocolors`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_40\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    diff: './vitest.diff.ts',\n  },\n})\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { DiffOptions } from 'vitest'\nimport c from 'picocolors'\n\nexport default {\n  aIndicator: c.bold('--'),\n  bIndicator: c.bold('++'),\n  omitAnnotationLines: true,\n} satisfies DiffOptions\n```\n\n----------------------------------------\n\nTITLE: Using JUnit Reporter - Configuration\nDESCRIPTION: This snippet demonstrates configuring the `junit` reporter within the `vitest.config.ts` file.  It sets the `reporters` array to `['junit']`. The JUnit reporter outputs test results in JUnit XML format.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/reporters.md#_snippet_13\n\nLANGUAGE: ts\nCODE:\n```\nexport default defineConfig({\n  test: {\n    reporters: ['junit']\n  },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Asserting Nested Property Non-Inclusion using Vitest (TypeScript)\nDESCRIPTION: Illustrates using `assert.notNestedInclude` in Vitest tests to verify the absence of specific nested properties in objects using dot/bracket notation with necessary escaping. Requires `assert` and `test`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_47\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.nestedInclude', () => {\n  assert.notNestedInclude({ '.a': { b: 'x' } }, { '\\\\.a.b': 'y' })\n  assert.notNestedInclude({ a: { '[b]': 'x' } }, { 'a.\\\\[b\\\\]': 'y' })\n})\n```\n\n----------------------------------------\n\nTITLE: Using unhover via Locator API in Vitest (TypeScript)\nDESCRIPTION: Shows execution of the unhover method through a locator, moving the virtual mouse off the target element and onto the document body. Requires @vitest/browser/context with a locator for the target. Accepts the same role-and-name matching as hover, and executes asynchronously, useful for simulating user interactions leaving a component.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_37\n\nLANGUAGE: typescript\nCODE:\n```\nimport { page } from '@vitest/browser/context'\n\nawait page.getByRole('img', { name: 'Rose' }).unhover()\n```\n\n----------------------------------------\n\nTITLE: Custom Snapshot Serializer Module (TypeScript)\nDESCRIPTION: This code defines a custom snapshot serializer as a module that can be imported into the Vitest config. This allows you to reuse the serializer across multiple tests. Dependencies: vitest. Input: Value to serialize. Output: Serialized string representation of the value.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/snapshot.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { SnapshotSerializer } from 'vitest'\n\nexport default {\n  serialize(val, config, indentation, depth, refs, printer) {\n    // `printer` is a function that serializes a value using existing plugins.\n    return `Pretty foo: ${printer(\n      val.foo,\n      config,\n      indentation,\n      depth,\n      refs,\n    )}`\n  },\n  test(val) {\n    return val && Object.prototype.hasOwnProperty.call(val, 'foo')\n  },\n} satisfies SnapshotSerializer\n```\n\n----------------------------------------\n\nTITLE: Asserting Map/Set Contains All Deep Keys with Vitest (TypeScript)\nDESCRIPTION: Demonstrates using `assert.containsAllDeepKeys` in Vitest to verify that a Map or Set includes all specified keys, potentially having additional keys, performing a deep comparison for object keys. Keys can be provided as an array of objects/strings or as the keys of another object.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_76\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.containsAllDeepKeys', () => {\n  assert.containsAllDeepKeys(new Map([[{ one: 'one' }, 'valueOne'], [1, 2]]), { one: 'one' })\n  assert.containsAllDeepKeys(new Map([[{ one: 'one' }, 'valueOne'], [{ two: 'two' }, 'valueTwo']]), [{ one: 'one' }, { two: 'two' }])\n  assert.containsAllDeepKeys(new Set([{ one: 'one' }, { two: 'two' }]), { one: 'one' })\n  assert.containsAllDeepKeys(new Set([{ one: 'one' }, { two: 'two' }]), [{ one: 'one' }, { two: 'two' }])\n})\n```\n\n----------------------------------------\n\nTITLE: Configure Custom Cache Directory in Vitest Config (TypeScript)\nDESCRIPTION: Provides an example of setting a custom directory for the Vitest cache using the `cacheDir` option in `vitest.config.ts`. This option is inherited from Vite's configuration and controls where Vitest stores its cache files. Requires `defineConfig` from 'vitest/config'.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_35\n\nLANGUAGE: ts\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  cacheDir: 'custom-folder/.vitest'\n})\n```\n\n----------------------------------------\n\nTITLE: Closing Projects and Exiting Vitest Process (TypeScript)\nDESCRIPTION: Closes all Vitest projects (similar to `close`) and then exits the Node.js process. If `force` is true, it exits immediately after closing. It includes a timeout (`config.teardownTimeout`) to forcefully exit if the process hangs.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/vitest.md#_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nfunction exit(force = false): Promise<void>\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Command Vitest TypeScript\nDESCRIPTION: Illustrates how to define a custom browser command on the server-side within a Vitest plugin's configuration. The `BrowserCommand` type defines the function signature, accepting a context object and custom arguments. This command can then be invoked from browser tests.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/commands.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { Plugin } from 'vitest/config'\nimport type { BrowserCommand } from 'vitest/node'\n\nconst myCustomCommand: BrowserCommand<[arg1: string, arg2: string]> = ({\n  testPath,\n  provider\n}, arg1, arg2) => {\n  if (provider.name === 'playwright') {\n    console.log(testPath, arg1, arg2)\n    return { someValue: true }\n  }\n\n  throw new Error(`provider ${provider.name} is not supported`)\n}\n\nexport default function BrowserCommands(): Plugin {\n  return {\n    name: 'vitest:custom-commands',\n    config() {\n      return {\n        test: {\n          browser: {\n            commands: {\n              myCustomCommand,\n            }\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting 100% Coverage Thresholds with Glob Patterns in Vitest (TS)\nDESCRIPTION: This snippet demonstrates how to set coverage thresholds to 100% for files matching specified glob patterns in Vitest. This configuration ensures complete coverage for the targeted files. Verify that the specified glob patterns accurately identify the desired files.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_29\n\nLANGUAGE: ts\nCODE:\n```\n{\n  coverage: {\n    thresholds: {\n      // Thresholds for all files\n      functions: 95,\n      branches: 70,\n\n      // Thresholds for matching glob pattern\n      'src/utils/**.ts': { 100: true },\n      '**/math.ts': { 100: true }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Filtering Browser Instances - Default Names\nDESCRIPTION: This code snippet shows how Vitest automatically assigns browser names as project names if no `name` is specified in the browser instance config.  It illustrates the default naming convention when using the `--project` flag for filtering.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/multiple-setups.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport default defineConfig({\n  test: {\n    browser: {\n      instances: [\n        // name: chromium\n        { browser: 'chromium' },\n        // name: custom\n        { browser: 'firefox', name: 'custom' },\n      ]\n    }\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Populating Task Metadata in Vitest Lifecycle Hooks (TypeScript)\nDESCRIPTION: This snippet augments the meta property on Vitest test suite and individual test tasks from within test context and hooks. The afterAll hook sets a \"done\" flag, while the \"custom\" attribute is configured on an individual test. There are no external dependencies required aside from Vitest, and this code should be written within your test files. The key parameters are the suite and task objects, both exposing a mutable meta field. Values are typically JSON-serializable primitives or simple objects.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/metadata.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nafterAll((suite) => {\n  suite.meta.done = true\n})\n\ntest('custom', ({ task }) => {\n  task.meta.custom = 'some-custom-handler'\n})\n```\n\n----------------------------------------\n\nTITLE: Using withImplementation with Async Callback\nDESCRIPTION: This example showcases the usage of `withImplementation` with an asynchronous callback function. The key is to `await` the `withImplementation` call, ensuring the callback completes before reverting to the original mock implementation.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/mock.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\ntest('async callback', () => {\n  const myMockFn = vi.fn(() => 'original')\n\n  // We await this call since the callback is async\n  await myMockFn.withImplementation(\n    () => 'temp',\n    async () => {\n      myMockFn() // 'temp'\n    },\n  )\n\n  myMockFn() // 'original'\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Vitest without Vite (vitest.config.ts)\nDESCRIPTION: Illustrates creating a `vitest.config.ts` file to configure Vitest independently, especially when not using Vite as the primary build tool. It uses `defineConfig` from `vitest/config` and defines options within the `test` property.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/index.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    // ...\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Assert Non-Strict Inequality with Vitest\nDESCRIPTION: This snippet demonstrates `assert.notEqual`, which checks for non-strict inequality (!=). It requires the `vitest` testing framework. The input is two values, and the assertion passes if they are not equal (ignoring type).\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.equal', () => {\n  assert.notEqual(Math.sqrt(4), 3)\n})\n```\n\n----------------------------------------\n\nTITLE: Assert Value is Not Object with Vitest\nDESCRIPTION: This demonstrates `assert.isNotObject`, which asserts that a value is not an object.  It uses the `vitest` framework.  The input is a value and the test passes if the value is not an object.  The assertion does not match subclassed objects.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_28\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\nconst someThing = 'redCircle'\n\ntest('assert.isNotObject', () => {\n  assert.isNotObject(someThing, 'someThing is not object but string')\n})\n```\n\n----------------------------------------\n\nTITLE: Initializing Reporters and Coverage in Vitest (TypeScript)\nDESCRIPTION: Initializes reporters and the coverage provider without running any tests, returning a Promise that resolves when initialization is complete. This method is typically used with the `--standalone` flag and should not be called if `vitest.start()` is used.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/vitest.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nfunction init(): Promise<void>\n```\n\n----------------------------------------\n\nTITLE: Defining Test Property in Vitest Config\nDESCRIPTION: This snippet shows how to define the `test` property within a Vitest configuration file. This is where specific test-related options are configured. The example demonstrates setting an empty `exclude` array. This code snippet is included for completeness.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport default defineConfig({\n  test: {\n    exclude: [],\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Asserting an Object is an Instance of a Constructor using Vitest (TypeScript)\nDESCRIPTION: Shows how to use `assert.instanceOf` in Vitest tests to verify if an object is an instance of a specific constructor function or class. Uses `assert` and `test`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_40\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\nfunction Person(name) { this.name = name }\nconst foo = new Person('foo')\n\nclass Tea {\n  constructor(name) {\n    this.name = name\n  }\n}\nconst coffee = new Tea('coffee')\n\ntest('assert.instanceOf', () => {\n  assert.instanceOf(foo, Person, 'foo is an instance of Person')\n  assert.instanceOf(coffee, Tea, 'coffee is an instance of Tea')\n})\n```\n\n----------------------------------------\n\nTITLE: Using Built-in File Commands Vitest TypeScript\nDESCRIPTION: Demonstrates the usage of Vitest's built-in file handling commands (`writeFile`, `readFile`, `removeFile`) within a browser test. These commands allow tests running in the browser to interact with the server's file system, respecting `server.fs` restrictions. Paths are resolved relative to the test file.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/commands.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { server } from '@vitest/browser/context'\n\nconst { readFile, writeFile, removeFile } = server.commands\n\nit('handles files', async () => {\n  const file = './test.txt'\n\n  await writeFile(file, 'hello world')\n  const content = await readFile(file)\n\n  expect(content).toBe('hello world')\n\n  await removeFile(file)\n})\n```\n\n----------------------------------------\n\nTITLE: Extending Assertion Interface (TypeScript)\nDESCRIPTION: Extends the default `Assertion` interface in TypeScript to include the custom matcher `toBeFoo`. This allows TypeScript to recognize the new matcher when used in assertions. The interface `CustomMatchers` defines the return type of the custom matcher.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/extending-matchers.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport 'vitest'\n\ninterface CustomMatchers<R = unknown> {\n  toBeFoo: () => R\n}\n\ndeclare module 'vitest' {\n  interface Assertion<T = any> extends CustomMatchers<T> {}\n  interface AsymmetricMatchersContaining extends CustomMatchers {}\n}\n```\n\n----------------------------------------\n\nTITLE: Simulating User Interactions with Vitest Browser API (TypeScript)\nDESCRIPTION: Demonstrates using `userEvent.fill` from `@vitest/browser/context` to simulate typing text into an input field located by its label. It also shows the alternative shorthand `locator.fill` method for the same interaction, leveraging the underlying browser automation provider (CDP or Webdriver).\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/index.md#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport { page, userEvent } from '@vitest/browser/context'\nawait userEvent.fill(page.getByLabelText(/username/i), 'Alice')\n// or just locator.fill\nawait page.getByLabelText(/username/i).fill('Alice')\n```\n\n----------------------------------------\n\nTITLE: Example of Vitest Snapshot File (JavaScript)\nDESCRIPTION: This is an example of what a snapshot file created by Vitest looks like.  It stores the string representation of the value being snapshotted. This example represents the string \"FOOBAR\". Dependencies: None. Input: Value to snapshot. Output: String representation of value.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/snapshot.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html\n\nexports['toUpperCase 1'] = '\"FOOBAR\"'\n```\n\n----------------------------------------\n\nTITLE: Installing Playwright for Vitest Browser Mode - Bash\nDESCRIPTION: Installation commands to add Playwright along with Vitest and the browser package for running tests in CI or using Playwright as the browser provider. Playwright enables parallel test execution using Chrome DevTools Protocol, providing a faster testing experience.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/index.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm install -D vitest @vitest/browser playwright\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn add -D vitest @vitest/browser playwright\n```\n\nLANGUAGE: bash\nCODE:\n```\npnpm add -D vitest @vitest/browser playwright\n```\n\nLANGUAGE: bash\nCODE:\n```\nbun add -D vitest @vitest/browser playwright\n```\n\n----------------------------------------\n\nTITLE: Manual Installation of Vitest Browser Packages - Bash\nDESCRIPTION: Manual installation commands for Vitest and its browser extension package `@vitest/browser`. These commands install required development dependencies for enabling browser mode testing. Supported across npm, yarn, pnpm, and bun package managers.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/index.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm install -D vitest @vitest/browser\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn add -D vitest @vitest/browser\n```\n\nLANGUAGE: bash\nCODE:\n```\npnpm add -D vitest @vitest/browser\n```\n\nLANGUAGE: bash\nCODE:\n```\nbun add -D vitest @vitest/browser\n```\n\n----------------------------------------\n\nTITLE: Executing Shell Command - Shell\nDESCRIPTION: This snippet executes the standard shell command `echo` to print the string \"hello\" to the standard output. It requires a shell environment (like bash, sh, zsh) to run. The input is implicit (the string \"hello\"), and the output is the string printed to the console.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/test/core/test/snapshot-2.txt#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\necho \"hello\"\n```\n\n----------------------------------------\n\nTITLE: Merging Test Reports\nDESCRIPTION: This method merges reports from multiple test runs located in a specified directory, which defaults to `.vitest-reports`. The directory is resolved relative to the working directory. This is automatically called by `startVitest` if `config.mergeReports` is set.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/vitest.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction mergeReports(directory?: string): Promise<TestRunResult>\n```\n\n----------------------------------------\n\nTITLE: Accessing Mock Call Contexts (`this`) with mock.contexts (TypeScript/JavaScript)\nDESCRIPTION: The `mock.contexts` property stores an array of the `this` context values used during each invocation of the mock function. This is useful for verifying the context in which the mock was called, especially when using methods like `apply` or `call`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/mock.md#_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nconst contexts: ThisParameterType<T>[]\n```\n\nLANGUAGE: javascript\nCODE:\n```\nconst fn = vi.fn()\nconst context = {}\n\nfn.apply(context)\nfn.call(context)\n\nfn.mock.contexts[0] === context\nfn.mock.contexts[1] === context\n```\n\n----------------------------------------\n\nTITLE: Deep Inclusion of Members Not Present (TypeScript)\nDESCRIPTION: Defines `assert.notIncludeDeepMembers` to ensure that `subset` objects are not all included in `superset` with deep comparison. Duplicates are ignored.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_94\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\n test('assert.notIncludeDeepMembers', () => {\n  assert.notIncludeDeepMembers([{ a: 1 }, { b: 2 }, { c: 3 }], [{ b: 2 }, { f: 5 }], 'not include deep members')\n})\n```\n\n----------------------------------------\n\nTITLE: Assert Value is Defined with Vitest\nDESCRIPTION: This snippet demonstrates `assert.isDefined`, which asserts that a value is not undefined. It uses the `vitest` framework.  The input is a value, and the test passes if the value is not undefined.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_24\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\nconst name = 'foo'\n\ntest('assert.isDefined', () => {\n  assert.isDefined(name, 'name is not undefined')\n})\n```\n\n----------------------------------------\n\nTITLE: Executing a Vite Node Script with Hashbang (Shell)\nDESCRIPTION: Shows how to run a script (`./file.ts`) directly from the shell after making it executable. The hashbang invokes `vite-node`, and any arguments (like 'hello') are passed to the script.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/vite-node/README.md#_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\n$ ./file.ts hello\nargv: [ 'hello' ]\n```\n\n----------------------------------------\n\nTITLE: Starting Test API (Vitest)\nDESCRIPTION: This command starts the test API for Vitest.  This API is likely used by the UI to retrieve test results and other information. It utilizes the `nr` command, suggesting a script defined in the package.json file.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/ui/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnr test --api\n```\n\n----------------------------------------\n\nTITLE: Clearing Test Specification Cache in Vitest (TypeScript)\nDESCRIPTION: Clears the cached test specifications populated by `globTestSpecifications` or `runTestSpecifications`. If a `moduleId` is provided, only the cache for that specific file is cleared; otherwise, the entire cache is cleared.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/vitest.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nfunction clearSpecificationsCache(moduleId?: string): void\n```\n\n----------------------------------------\n\nTITLE: dblClick Method - Simulate Double Click on Element\nDESCRIPTION: Triggers a double click event on the element, suitable for testing double-click interactions. Options allow setting cursor position and click timing.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_31\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction dblClick(options?: UserEventDoubleClickOptions): Promise<void>\n```\n\n----------------------------------------\n\nTITLE: Snapshot Run Finalization\nDESCRIPTION: Finalizes the snapshot run by calling `client.finishCurrentRun`. This saves any new or updated snapshots to files and returns a `SnapshotResult` object containing information about the snapshot run.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/snapshot/README.md#_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nconst result = await client.finishCurrentRun() // this saves files and returns SnapshotResult\n```\n\n----------------------------------------\n\nTITLE: Example Test File\nDESCRIPTION: This is an example test file that uses the `inject` function from Vitest to access a provided value (`ratio`) and asserts its value after modification by `globalSetupModifier`. It demonstrates how to use the `provide` configuration to inject values into tests.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/multiple-setups.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { expect, inject, test } from 'vitest'\nimport { globalSetupModifier } from './example.js'\n\ntest('ratio works', () => {\n  expect(inject('ratio') * globalSetupModifier).toBe(14)\n})\n```\n\n----------------------------------------\n\nTITLE: Checking if a Spy Function Has Returned a Specific Value Using toHaveReturnedWith\nDESCRIPTION: This snippet illustrates how to assert that a spy function has returned a particular value with certain parameters at least once. It requires the spy to be invoked with specific arguments, and then verifies the return object matches expectations.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_30\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { expect, test, vi } from 'vitest'\n\ntest('spy function returns a product', () => {\n  const sell = vi.fn((product: string) => ({ product }))\n\n  sell('apples')\n\n  expect(sell).toHaveReturnedWith({ product: 'apples' })\n})\n```\n\n----------------------------------------\n\nTITLE: Filtering Browser Instances - Custom Names\nDESCRIPTION: This code snippet demonstrates how Vitest merges the root config name with the browser name if both are defined and no explicit name is given to an instance. It also shows how setting an instance `name` overrides the default naming strategy. Used with filtering using the `--project` flag.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/multiple-setups.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport default defineConfig({\n  test: {\n    name: 'custom',\n    browser: {\n      instances: [\n        // name: custom (chromium)\n        { browser: 'chromium' },\n        // name: manual\n        { browser: 'firefox', name: 'manual' },\n      ]\n    }\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Invalidating a File in Vite Cache for Vitest (TypeScript)\nDESCRIPTION: Removes the specified file and its importers from the Vite module cache used by Vitest projects. This is crucial when using a custom file watcher instead of Vitest's built-in watcher to ensure changes are picked up, as the cache persists in memory.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/vitest.md#_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nfunction invalidateFile(filepath: string): void\n```\n\n----------------------------------------\n\nTITLE: toBeRequired Assertion Example\nDESCRIPTION: Demonstrates how to use the toBeRequired assertion to check if a form element is currently required.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_7\n\nLANGUAGE: html\nCODE:\n```\n<input data-testid=\"required-input\" required />\n<input data-testid=\"aria-required-input\" aria-required=\"true\" />\n<input data-testid=\"conflicted-input\" required aria-required=\"false\" />\n<input data-testid=\"aria-not-required-input\" aria-required=\"false\" />\n<input data-testid=\"optional-input\" />\n<input data-testid=\"unsupported-type\" type=\"image\" required />\n<select data-testid=\"select\" required></select>\n<textarea data-testid=\"textarea\" required></textarea>\n<div data-testid=\"supported-role\" role=\"tree\" required></div>\n<div data-testid=\"supported-role-aria\" role=\"tree\" aria-required=\"true\"></div>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nawait expect.element(getByTestId('required-input')).toBeRequired()\nawait expect.element(getByTestId('aria-required-input')).toBeRequired()\nawait expect.element(getByTestId('conflicted-input')).toBeRequired()\nawait expect.element(getByTestId('aria-not-required-input')).not.toBeRequired()\nawait expect.element(getByTestId('optional-input')).not.toBeRequired()\nawait expect.element(getByTestId('unsupported-type')).not.toBeRequired()\nawait expect.element(getByTestId('select')).toBeRequired()\nawait expect.element(getByTestId('textarea')).toBeRequired()\nawait expect.element(getByTestId('supported-role')).not.toBeRequired()\nawait expect.element(getByTestId('supported-role-aria')).toBeRequired()\n```\n\n----------------------------------------\n\nTITLE: Assert Non-Strict Equality with Vitest\nDESCRIPTION: This demonstrates `assert.equal`, which checks for non-strict equality (==).  It requires the `vitest` testing framework. The input consists of two values, and the assertion passes if the values are equal (ignoring type).\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.equal', () => {\n  assert.equal(Math.sqrt(4), '2')\n})\n```\n\n----------------------------------------\n\nTITLE: Assert Value is String with Vitest\nDESCRIPTION: This snippet uses `assert.isString`, which asserts that a value is a string. It uses the `vitest` framework. The input is a value, and the assertion passes if the value is a string.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_31\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\nconst color = 'red'\n\ntest('assert.isString', () => {\n  assert.isString(color, 'color is string')\n})\n```\n\n----------------------------------------\n\nTITLE: HTML Context for toHaveValue Usage - HTML\nDESCRIPTION: Provides several form input and select elements as test fixtures for the toHaveValue matcher. Test IDs allow selection of individual elements for targeted assertions in TypeScript code. Standard, dependency-free HTML markup.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_27\n\nLANGUAGE: HTML\nCODE:\n```\n<input type=\"text\" value=\"text\" data-testid=\"input-text\" />\n<input type=\"number\" value=\"5\" data-testid=\"input-number\" />\n<input type=\"text\" data-testid=\"input-empty\" />\n<select multiple data-testid=\"select-number\">\n  <option value=\"first\">First Value</option>\n  <option value=\"second\" selected>Second Value</option>\n  <option value=\"third\" selected>Third Value</option>\n</select>\n```\n\n----------------------------------------\n\nTITLE: Referencing WebdriverIO Provider Types Vitest TypeScript\nDESCRIPTION: Provides the TypeScript reference directive required to enable autocompletion and type checking for the WebdriverIO-specific context properties available when using the Vitest browser provider with WebdriverIO. This directive should be included in a setup file or Vitest config file.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/commands.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\n/// <reference types=\"@vitest/browser/providers/webdriverio\" />\n```\n\n----------------------------------------\n\nTITLE: Configuring Diff Options in Vitest (TypeScript)\nDESCRIPTION: Illustrates how to customize the diff display in Vitest using a configuration object. Shows how to modify the indicators and omit annotation lines. Requires a dependency on a color library like `picocolors`.  This example is shown as a config object.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_39\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\nimport c from 'picocolors'\n\nexport default defineConfig({\n  test: {\n    diff: {\n      aIndicator: c.bold('--'),\n      bIndicator: c.bold('++'),\n      omitAnnotationLines: true,\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Making a Vite Node Script Executable (Shell)\nDESCRIPTION: Uses the `chmod +x` command in a Unix-like shell to grant execute permissions to a script file (`./file.ts`), enabling it to be run directly when using a hashbang.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/vite-node/README.md#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\nchmod +x ./file.ts\n```\n\n----------------------------------------\n\nTITLE: Value Inclusion in List (TypeScript)\nDESCRIPTION: Defines `assert.oneOf` to verify that a value appears in a list, checking for non-object, non-array primitive values.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_99\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\n test('assert.oneOf', () => {\n  assert.oneOf(1, [2, 1], 'Not found in list')\n})\n```\n\n----------------------------------------\n\nTITLE: Getting the provided context from a Vitest project\nDESCRIPTION: This code shows how to retrieve the entire context object, including global context and project-specific context, using `getProvidedContext`. Project context values override root project's context.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/test-project.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createVitest } from 'vitest/node'\n\nconst vitest = await createVitest('test')\nvitest.provide('global', true)\nconst project = vitest.projects.find(p => p.name === 'custom')\nproject.provide('key', 'value')\n\n// { global: true, key: 'value' }\nconst context = project.getProvidedContext()\n```\n\n----------------------------------------\n\nTITLE: Snapshot Configuration for printBasicPrototype (TypeScript)\nDESCRIPTION: This code demonstrates how to configure the `printBasicPrototype` option in `vitest.config.ts` to change the default snapshot formatting to match Jest's behavior. Dependencies: vitest. Input: none. Output: Configuration of snapshot format.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/snapshot.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    snapshotFormat: {\n      printBasicPrototype: true,\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Disabling Snapshot Update Mode in Vitest (TypeScript)\nDESCRIPTION: Disables the mode that allows automatic snapshot updates during test runs. Tests run after calling this will no longer update snapshots unless explicitly told to (e.g., via `updateSnapshot` or CLI flags). This method does not trigger a test run itself.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/vitest.md#_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nfunction resetSnapshotUpdate(): void\n```\n\n----------------------------------------\n\nTITLE: Getting Provided Context\nDESCRIPTION: This method returns the root context object. It serves as a shorthand for `vitest.getRootProject().getProvidedContext` and is used to access context values provided to the project.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/vitest.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction getProvidedContext(): ProvidedContext\n```\n\n----------------------------------------\n\nTITLE: Initializing Vitest Configuration with updated defineConfig from Vite\nDESCRIPTION: This snippet demonstrates how to initialize a Vitest configuration using `defineConfig` from the `vite` package, with an updated type reference to `vitest/config`. It shows how to include the necessary type references and define the `test` property within the Vite configuration. This approach integrates Vitest configuration within the existing Vite setup, allowing for a unified configuration strategy.  This example uses a triple-slash directive to reference the updated vitest config types.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n/// <reference types=\"vitest/config\" />\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  test: {\n    // ... Specify options here.\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Asserting Numeric Property Decrease with Vitest - TypeScript\nDESCRIPTION: Asserts with Vitest that a modifier function decreases a numeric property of an object. Requires the function, object, property, and an optional message as input. Use when checking that a value is diminished as a result of an operation.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_108\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.decreases', () => {\n  const obj = { val: 10 }\n  function fn() { obj.val = 5 };\n  assert.decreases(fn, obj, 'val')\n})\n```\n\n----------------------------------------\n\nTITLE: Asserting No Numeric Property Increase with Vitest - TypeScript\nDESCRIPTION: This test asserts that a modifier function does not increase a specified numeric property of an object. Using Vitest, it expects the property's value to not increase after executing the modifier. Required parameters include the modifier function, object, property key, and optional message. Useful for checking value stability.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_106\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.doesNotIncrease', () => {\n  const obj = { val: 10 }\n  function fn() { obj.val = 8 }\n  assert.doesNotIncrease(fn, obj, 'val')\n})\n```\n\n----------------------------------------\n\nTITLE: Getting Root Project\nDESCRIPTION: This snippet demonstrates how to get the root test project in Vitest. The root project is the starting point and usually doesn't run any tests itself, but can be useful for global configurations.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/vitest.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction getRootProject(): TestProject\n```\n\n----------------------------------------\n\nTITLE: Asserting Map/Set Misses At Least One Deep Key with Vitest (TypeScript)\nDESCRIPTION: Demonstrates using `assert.doesNotHaveAllDeepKeys` in Vitest to verify that a Map or Set is missing at least one of the specified keys, performing a deep comparison for object keys. Keys can be provided as an array of objects/strings or as the keys of another object.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_78\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.doesNotHaveAllDeepKeys', () => {\n  assert.doesNotHaveAllDeepKeys(new Map([[{ one: 'one' }, 'valueOne'], [1, 2]]), { thisDoesNot: 'exist' })\n  assert.doesNotHaveAllDeepKeys(new Map([[{ one: 'one' }, 'valueOne'], [{ two: 'two' }, 'valueTwo']]), [{ twenty: 'twenty' }, { one: 'one' }])\n  assert.doesNotHaveAllDeepKeys(new Set([{ one: 'one' }, { two: 'two' }]), { twenty: 'twenty' })\n  assert.doesNotHaveAllDeepKeys(new Set([{ one: 'one' }, { two: 'two' }]), [{ one: 'one' }, { fifty: 'fifty' }])\n})\n```\n\n----------------------------------------\n\nTITLE: Declaring diagnostic Function Signature and TestDiagnostic Interface in Vitest (TypeScript)\nDESCRIPTION: This set of snippets provides the function signature for diagnostic(), which returns a TestDiagnostic object or undefined in Vitest. The accompanying interface details returned diagnostic properties (duration, memory usage, retries, flakiness, etc.). No direct parameters; behavior depends on test runtime context and enabled flags (e.g., logHeapUsage). Used for reporting advanced statistics about individual tests.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/test-case.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nfunction diagnostic(): TestDiagnostic | undefined\n```\n\nLANGUAGE: typescript\nCODE:\n```\ninterface TestDiagnostic {\n  /**\n   * If the duration of the test is above `slowTestThreshold`.\n   */\n  readonly slow: boolean\n  /**\n   * The amount of memory used by the test in bytes.\n   * This value is only available if the test was executed with `logHeapUsage` flag.\n   */\n  readonly heap: number | undefined\n  /**\n   * The time it takes to execute the test in ms.\n   */\n  readonly duration: number\n  /**\n   * The time in ms when the test started.\n   */\n  readonly startTime: number\n  /**\n   * The amount of times the test was retried.\n   */\n  readonly retryCount: number\n  /**\n   * The amount of times the test was repeated as configured by `repeats` option.\n   * This value can be lower if the test failed during the repeat and no `retry` is configured.\n   */\n  readonly repeatCount: number\n  /**\n   * If test passed on a second retry.\n   */\n  readonly flaky: boolean\n}\n```\n\n----------------------------------------\n\nTITLE: Override Snapshot Path in Vitest Config (TypeScript)\nDESCRIPTION: Shows how to configure the `resolveSnapshotPath` option in `vitest.config.ts`. The provided example customizes the snapshot file path to store snapshots in the same directory as the test file, instead of the default `__snapshots__` directory. Requires `defineConfig` from 'vitest/config'.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_34\n\nLANGUAGE: ts\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    resolveSnapshotPath: (testPath, snapExtension) => testPath + snapExtension,\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Specifying Test Environment Per File in Vitest | TypeScript\nDESCRIPTION: This snippet demonstrates how to use a control comment '@vitest-environment' to specify the testing environment ('jsdom' here) for a particular test file in Vitest. It shows a simple test case verifying the 'window' object is defined in the chosen environment. No external dependencies are required beyond Vitest itself. This allows fine-grained control of environment per test file overriding the global config.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/environment.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\n// @vitest-environment jsdom\n\nimport { expect, test } from 'vitest'\n\ntest('test', () => {\n  expect(typeof window).not.toBe('undefined')\n})\n```\n\n----------------------------------------\n\nTITLE: Accessing Reported Tasks via Vitest State (TypeScript)\nDESCRIPTION: Shows how to access detailed information about reported test tasks using the `vitest.state.getReportedEntity` method. This allows custom reporters to retrieve structured data about test files, modules, and individual tasks.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/reporters.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { Reporter, RunnerTestFile, TestModule, Vitest } from 'vitest/node'\n\nclass MyReporter implements Reporter {\n  private vitest!: Vitest\n\n  onInit(vitest: Vitest) {\n    this.vitest = vitest\n  }\n\n  onFinished(files: RunnerTestFile[]) {\n    for (const file of files) {\n      // note that the old task implementation uses \"file\" instead of \"module\"\n      const testModule = this.vitest.state.getReportedEntity(file) as TestModule\n      for (const task of testModule.children) {\n        //                          ^?\n        console.log('finished', task.type, task.fullName)\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Extending BaseReporter in Vitest with TypeScript\nDESCRIPTION: Demonstrates creating a custom reporter by extending Vitest's BaseReporter class. Shows how to override the onTestRunEnd lifecycle method to log the number of finished tests, then calls the base implementation. Requires 'vitest/reporters' for BaseReporter. Intended for users creating custom reporters by subclassing.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/reporters.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { BaseReporter } from 'vitest/reporters'\n\nexport default class CustomReporter extends BaseReporter {\n  onTestRunEnd(testModules, errors) {\n    console.log(testModules.length, 'tests finished running')\n    super.onTestRunEnd(testModules, errors)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Calling element with Locator in Vitest (TypeScript and HTML)\nDESCRIPTION: Demonstrates element() usage with various locators, including valid and invalid cases. Covers scenarios where one, none, or multiple elements match. Requires accurate DOM structure; success returns Element, failure throws. Illustrates key differences with query() and elements() methods.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_49\n\nLANGUAGE: html\nCODE:\n```\n<div>Hello <span>World</span></div>\n<div>Hello Germany</div>\n<div>Hello</div>\n```\n\nLANGUAGE: typescript\nCODE:\n```\npage.getByText('Hello World').element() // ✅\npage.getByText('Hello Germany').element() // ✅\npage.getByText('World').element() // ✅\npage.getByText('Hello', { exact: true }).element() // ✅\n```\n\nLANGUAGE: typescript\nCODE:\n```\n// returns multiple elements\npage.getByText('Hello').element() // ❌\npage.getByText(/^Hello/).element() // ❌\n\n// returns no elements\npage.getByText('Hello USA').element() // ❌\n```\n\n----------------------------------------\n\nTITLE: Using element with expect for Assertions in Vitest (TypeScript)\nDESCRIPTION: Shows how to use locator.element() in combination with expect assertions to check element states. element() is automatically called by expect.element when used in retried assertions, simplifying test syntax. Requires @vitest/browser/context and assertion extensions.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_50\n\nLANGUAGE: typescript\nCODE:\n```\nawait expect.element(page.getByRole('button')).toBeDisabled()\n```\n\n----------------------------------------\n\nTITLE: Executing a Simple Shell Command (echo)\nDESCRIPTION: This shell script snippet, embedded within a YAML 'example' key using a block scalar style, executes the 'echo' command to print the string \"hello\" to standard output. It requires a standard shell environment (like Bash or sh) to run.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/test/snapshots/test/fixtures/file/snapshot-2.txt#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n{\n  echo \"hello\"\n}\n```\n\n----------------------------------------\n\nTITLE: Deep Ordered Subset Inclusion (TypeScript)\nDESCRIPTION: Defines `assert.includeDeepOrderedMembers` to check if `subset` appears in `superset` in sequence with deep object equality.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_97\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\n test('assert.includeDeepOrderedMembers', () => {\n  assert.includeDeepOrderedMembers([{ a: 1 }, { b: 2 }, { c: 3 }], [{ a: 1 }, { b: 2 }], 'include deep ordered members')\n})\n```\n\n----------------------------------------\n\nTITLE: Initializing and Running Tests in Vitest (TypeScript)\nDESCRIPTION: Initializes reporters, the coverage provider, and then runs tests matching the optional filters. Returns a Promise resolving to a `TestRunResult`. This method should not be called if `vitest.init()` is used; use `runTestSpecifications` or `rerunTestSpecifications` instead in that scenario.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/vitest.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nfunction start(filters?: string[]): Promise<TestRunResult>\n```\n\n----------------------------------------\n\nTITLE: Extending DefaultReporter in Vitest (TypeScript)\nDESCRIPTION: Demonstrates how to create a custom reporter by extending the `DefaultReporter` class provided by Vitest. This approach allows modifying or adding functionality to the standard default reporter.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/reporters.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DefaultReporter } from 'vitest/reporters'\n\nexport default class MyDefaultReporter extends DefaultReporter {\n  // do something\n}\n```\n\n----------------------------------------\n\nTITLE: clear Method - Clear Input Element Content\nDESCRIPTION: Clears the value of input or textarea elements, simulating user clearing input fields. Useful for testing form inputs and state resets.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_33\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction clear(options?: UserEventClearOptions): Promise<void>\n```\n\n----------------------------------------\n\nTITLE: Asserting Object Is Not Extensible with Vitest - TypeScript\nDESCRIPTION: Asserts that an object cannot be extended with new properties. The test demonstrates use with objects created via Object.preventExtensions, Object.seal, and Object.freeze. Accepts the object and optional message; depends on ECMAScript object extensibility behavior. Suitable for validating finalization of object structures.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_115\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.isNotExtensible', () => {\n  const nonExtensibleObject = Object.preventExtensions({})\n  const sealedObject = Object.seal({})\n  const frozenObject = Object.freeze({})\n\n  assert.isNotExtensible(nonExtensibleObject)\n  assert.isNotExtensible(sealedObject)\n  assert.isNotExtensible(frozenObject)\n})\n```\n\n----------------------------------------\n\nTITLE: Parsing CLI Arguments with parseCLI to Generate Filters and Options (TypeScript/JavaScript)\nDESCRIPTION: This snippet demonstrates parsing CLI argument strings into filter patterns and configuration options using Vitest's parseCLI function, enabling programmatic emulation of command-line input and integration with script-controlled test runs.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/index.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { parseCLI } from 'vitest/node'\n\nconst result = parseCLI('vitest ./files.ts --coverage --browser=chrome')\n\nresult.options\n// {\n//   coverage: { enabled: true },\n//   browser: { name: 'chrome', enabled: true }\n// }\n\nresult.filter\n// ['./files.ts']\n```\n\n----------------------------------------\n\nTITLE: Implementing Reporter Interface Directly (TypeScript)\nDESCRIPTION: Illustrates how to create a custom reporter by implementing the `Reporter` interface. This requires implementing all necessary methods defined by the interface to handle test lifecycle events.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/reporters.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { Reporter } from 'vitest/node'\n\nexport default class CustomReporter implements Reporter {\n  onCollected() {\n    // print something\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Vitest HTML Reporter\nDESCRIPTION: This TypeScript code configures Vitest to generate an HTML report of the test results. It leverages the defineConfig function from 'vitest/config'.  The `reporters` option in the configuration specifies that an 'html' reporter should be used.  The output is a generated HTML report based on the test results. No specific input is necessary as the test runs are configured elsewhere.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/ui.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    reporters: ['html'],\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Temporarily Overriding Implementation with withImplementation\nDESCRIPTION: This example demonstrates how to use `withImplementation` to temporarily override the implementation of a mock function within a callback. The original implementation is restored after the callback is executed.  Supports both synchronous and asynchronous callbacks.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/mock.md#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nconst myMockFn = vi.fn(() => 'original')\n\nmyMockFn.withImplementation(() => 'temp', () => {\n  myMockFn() // 'temp'\n})\n\nmyMockFn() // 'original'\n```\n\n----------------------------------------\n\nTITLE: Using Custom Tasks in Vitest Test Suite (JavaScript)\nDESCRIPTION: This code demonstrates the usage of the custom task collector, `myCustomTask`, defined in the previous snippet within a Vitest test suite. It imports `myCustomTask`, `afterAll`, `beforeAll` and `describe` from the `custom.js` file. It also imports a `gardener` object from the './gardener.js' file. The suite uses `beforeAll` and `afterAll` to set up and tear down the test environment. `myCustomTask` is used to define test cases like 'weed the grass', 'mow the lawn', and 'water flowers'. This showcases the integration of custom tasks within the regular test suite structure.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/runner.md#_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nimport {\n  afterAll,\n  beforeAll,\n  describe,\n  myCustomTask\n} from './custom.js'\nimport { gardener } from './gardener.js'\n\ndescribe('take care of the garden', () => {\n  beforeAll(() => {\n    gardener.putWorkingClothes()\n  })\n\n  myCustomTask('weed the grass', () => {\n    gardener.weedTheGrass()\n  })\n  myCustomTask.todo('mow the lawn', () => {\n    gardener.mowerTheLawn()\n  })\n  myCustomTask('water flowers', () => {\n    gardener.waterFlowers()\n  })\n\n  afterAll(() => {\n    gardener.goHome()\n  })\n})\n\n```\n\n----------------------------------------\n\nTITLE: Defining Nested Tests with describe and test in Vitest Using TypeScript\nDESCRIPTION: This snippet illustrates grouping related test cases within a describe block in Vitest using TypeScript. It helps organize large test suites and constructs a hierarchical full name for nested tests, aiding in better reporting. Requires importing both test() and describe() functions from Vitest. Inputs are test and suite names; outputs are properly nested test results. There are no external constraints, aside from the Vitest setup.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/test-case.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { describe, test } from 'vitest'\n\ndescribe('the validation logic', () => {\n  test('the validation works correctly', () => {\n    // ...\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Declaring ok Function Signature for Test Completion Status (TypeScript)\nDESCRIPTION: This code provides a TypeScript function signature for checking if a test did not fail its suite in Vitest. The ok() function returns a boolean reflecting completion and status. It has no parameters and is expected to be called on a TestCase instance. Not finished or skipped tests return true. Only the signature is shown; usage depends on test context.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/test-case.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nfunction ok(): boolean\n```\n\n----------------------------------------\n\nTITLE: Defining TaskOptions Interface for Vitest TestCase Configuration (TypeScript)\nDESCRIPTION: This snippet defines the TaskOptions TypeScript interface used to specify per-test configuration in Vitest. Properties control parallelism (concurrent), flakiness (fails), how many times a test runs (retry and repeats), and other behaviors. Each property is optional; developers use this type for strong typing of test and runner options. No direct input/output; used for static type checks.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/test-case.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ninterface TaskOptions {\n  readonly each: boolean | undefined\n  readonly fails: boolean | undefined\n  readonly concurrent: boolean | undefined\n  readonly shuffle: boolean | undefined\n  readonly retry: number | undefined\n  readonly repeats: number | undefined\n  readonly mode: 'run' | 'only' | 'skip' | 'todo'\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting Object Is Extensible with Vitest - TypeScript\nDESCRIPTION: Checks that a given object can have new properties added (is extensible) using Vitest assertions. Takes the object to be checked and an optional message. Useful for ensuring default mutability or before operations requiring property additions, relies on JavaScript's native extensible semantics.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_114\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { assert, test } from 'vitest'\n\ntest('assert.isExtensible', () => {\n  assert.isExtensible({})\n})\n```\n\n----------------------------------------\n\nTITLE: Defining VitestRunner Interface with Lifecycle Hooks in TypeScript\nDESCRIPTION: This snippet defines the TypeScript interface for a custom test runner in Vitest named VitestRunner. It specifies optional lifecycle hooks such as onBeforeCollect, onCollected, onCancel, onBeforeRunTask, onAfterRunTask, onBeforeRunSuite, onAfterRunSuite, and others that enable detailed control over test collection and execution phases. The interface requires a config property of type VitestRunnerConfig, and optionally a pool name. The methods handle test and suite lifecycle events, task updates, context extension, file imports, and injection of values, enabling custom logic and integration with the Vitest testing lifecycle.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/runner.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface VitestRunner {\n  /**\n   * First thing that's getting called before actually collecting and running tests.\n   */\n  onBeforeCollect?: (paths: string[]) => unknown\n  /**\n   * Called after collecting tests and before \"onBeforeRun\".\n   */\n  onCollected?: (files: File[]) => unknown\n\n  /**\n   * Called when test runner should cancel next test runs.\n   * Runner should listen for this method and mark tests and suites as skipped in\n   * \"onBeforeRunSuite\" and \"onBeforeRunTask\" when called.\n   */\n  onCancel?: (reason: CancelReason) => unknown\n\n  /**\n   * Called before running a single test. Doesn't have \"result\" yet.\n   */\n  onBeforeRunTask?: (test: TaskPopulated) => unknown\n  /**\n   * Called before actually running the test function. Already has \"result\" with \"state\" and \"startTime\".\n   */\n  onBeforeTryTask?: (test: TaskPopulated, options: { retry: number; repeats: number }) => unknown\n  /**\n   * Called after result and state are set.\n   */\n  onAfterRunTask?: (test: TaskPopulated) => unknown\n  /**\n   * Called right after running the test function. Doesn't have new state yet. Will not be called, if the test function throws.\n   */\n  onAfterTryTask?: (test: TaskPopulated, options: { retry: number; repeats: number }) => unknown\n\n  /**\n   * Called before running a single suite. Doesn't have \"result\" yet.\n   */\n  onBeforeRunSuite?: (suite: Suite) => unknown\n  /**\n   * Called after running a single suite. Has state and result.\n   */\n  onAfterRunSuite?: (suite: Suite) => unknown\n\n  /**\n   * If defined, will be called instead of usual Vitest suite partition and handling.\n   * \"before\" and \"after\" hooks will not be ignored.\n   */\n  runSuite?: (suite: Suite) => Promise<void>\n  /**\n   * If defined, will be called instead of usual Vitest handling. Useful, if you have your custom test function.\n   * \"before\" and \"after\" hooks will not be ignored.\n   */\n  runTask?: (test: TaskPopulated) => Promise<void>\n\n  /**\n   * Called, when a task is updated. The same as \"onTaskUpdate\" in a reporter, but this is running in the same thread as tests.\n   */\n  onTaskUpdate?: (task: [string, TaskResult | undefined, TaskMeta | undefined][]) => Promise<void>\n\n  /**\n   * Called before running all tests in collected paths.\n   */\n  onBeforeRunFiles?: (files: File[]) => unknown\n  /**\n   * Called right after running all tests in collected paths.\n   */\n  onAfterRunFiles?: (files: File[]) => unknown\n  /**\n   * Called when new context for a test is defined. Useful, if you want to add custom properties to the context.\n   * If you only want to define custom context with a runner, consider using \"beforeAll\" in \"setupFiles\" instead.\n   */\n  extendTaskContext?: (context: TestContext) => TestContext\n  /**\n   * Called when certain files are imported. Can be called in two situations: to collect tests and to import setup files.\n   */\n  importFile: (filepath: string, source: VitestRunnerImportSource) => unknown\n  /**\n   * Function that is called when the runner attempts to get the value when `test.extend` is used with `{ injected: true }`\n   */\n  injectValue?: (key: string) => unknown\n  /**\n   * Publicly available configuration.\n   */\n  config: VitestRunnerConfig\n  /**\n   * The name of the current pool. Can affect how stack trace is inferred on the server side.\n   */\n  pool?: string\n}\n```\n\n----------------------------------------\n\nTITLE: Defining TestResultFailed Interface for Failed Tests in Vitest (TypeScript)\nDESCRIPTION: This snippet defines the TestResultFailed TypeScript interface, representing result() output for a failed test in Vitest. Contains a 'failed' state and an array of TestErrors collected during test execution. Errors are readonly. Only for failed state; input is implicit.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/test-case.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\ninterface TestResultFailed {\n  /**\n   * The test failed to execute.\n   */\n  readonly state: 'failed'\n  /**\n   * Errors that were thrown during the test execution.\n   */\n  readonly errors: ReadonlyArray<TestError>\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Default Injected Fixtures in Vitest\nDESCRIPTION: Example of creating fixtures that can be injected with different values from project configuration, with fallback to default values when not specified.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/test-context.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { test as base } from 'vitest'\n\nconst test = base.extend({\n  url: [\n    // default value if \"url\" is not defined in the config\n    '/default',\n    // mark the fixture as \"injected\" to allow the override\n    { injected: true },\n  ],\n})\n\ntest('works correctly', ({ url }) => {\n  // url is \"/default\" in \"project-new\"\n  // url is \"/full\" in \"project-full\"\n  // url is \"/empty\" in \"project-empty\"\n})\n```\n\n----------------------------------------\n\nTITLE: Using Custom Test Fixtures in Vitest\nDESCRIPTION: Example of importing and using custom test fixtures created with test.extend to manage shared test state.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/test-context.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { expect } from 'vitest'\nimport { myTest } from './my-test.js'\n\nmyTest('add items to todos', ({ todos }) => {\n  expect(todos.length).toBe(3)\n\n  todos.push(4)\n  expect(todos.length).toBe(4)\n})\n\nmyTest('move items from todos to archive', ({ todos, archive }) => {\n  expect(todos.length).toBe(3)\n  expect(archive.length).toBe(0)\n\n  archive.push(todos.pop())\n  expect(todos.length).toBe(2)\n  expect(archive.length).toBe(1)\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Test Interface Representing Individual Test Task in Vitest (TypeScript)\nDESCRIPTION: This snippet describes the Test interface that extends TaskBase with generics to support an optional ExtraContext. It models individual test tasks, including properties like type set to 'test', context combining TestContext with ExtraContext, the root file task, and booleans pending (for skipped tests) and fails (for expected failures). It also supports storing asynchronous promises to handle test timing and completion. This interface captures detailed metadata and context for each test executed by Vitest runner.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/runner.md#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\ninterface Test<ExtraContext = object> extends TaskBase {\n  type: 'test'\n  /**\n   * Test context that will be passed to the test function.\n   */\n  context: TestContext & ExtraContext\n  /**\n   * File task. It's the root task of the file.\n   */\n  file: File\n  /**\n   * Whether the task was skipped by calling `t.skip()`.\n   */\n  pending?: boolean\n  /**\n   * Whether the task should succeed if it fails. If the task fails, it will be marked as passed.\n   */\n  fails?: boolean\n  /**\n   * Store promises (from async expects) to wait for them before finishing the test\n   */\n  promises?: Promise<any>[]\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Workspace using JSON config\nDESCRIPTION: This code snippet shows a simplified workspace configuration using a JSON file to define projects. The workspace configuration is stored in a `vitest.workspace.json` file and specifies a glob pattern to include projects.  It's an alternative to defining the workspace within the root config file or via the `vitest.workspace.ts` file.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/workspace.md#_snippet_4\n\nLANGUAGE: JSON\nCODE:\n```\n[\n  \"packages/*\"\n]\n\n```\n\n----------------------------------------\n\nTITLE: Defining TaskResult Interface Representing Outcome of Test/Suite Execution in Vitest (TypeScript)\nDESCRIPTION: This interface models the results returned by a test or suite task in Vitest after execution. It includes a state field indicating the task status such as 'pass' or 'fail', optional arrays of errors with diffs for multiple assertion failures, duration and startTime in milliseconds, optional heap memory usage statistics, hook states for related lifecycle hooks, and counters for retry and repeat attempts. This enables detailed reporting and diagnostics within the Vitest runner framework.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/runner.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface TaskResult {\n  /**\n   * State of the task. Inherits the `task.mode` during collection.\n   * When the task has finished, it will be changed to `pass` or `fail`.\n   * - **pass**: task ran successfully\n   * - **fail**: task failed\n   */\n  state: TaskState\n  /**\n   * Errors that occurred during the task execution. It is possible to have several errors\n   * if `expect.soft()` failed multiple times.\n   */\n  errors?: ErrorWithDiff[]\n  /**\n   * How long in milliseconds the task took to run.\n   */\n  duration?: number\n  /**\n   * Time in milliseconds when the task started running.\n   */\n  startTime?: number\n  /**\n   * Heap size in bytes after the task finished.\n   * Only available if `logHeapUsage` option is set and `process.memoryUsage` is defined.\n   */\n  heap?: number\n  /**\n   * State of related to this task hooks. Useful during reporting.\n   */\n  hooks?: Partial<Record<'afterAll' | 'beforeAll' | 'beforeEach' | 'afterEach', TaskState>>\n  /**\n   * The amount of times the task was retried. The task is retried only if it\n   * failed and `retry` option is set.\n   */\n  retryCount?: number\n  /**\n   * The amount of times the task was repeated. The task is repeated only if\n   * `repeats` option is set. This number also contains `retryCount`.\n   */\n  repeatCount?: number\n}\n```\n\n----------------------------------------\n\nTITLE: Defining matchesProjectFilter Function Signature (TypeScript)\nDESCRIPTION: This snippet shows the function signature for `matchesProjectFilter`. It takes a string `name` as input and returns a boolean indicating whether the name matches the current project filter set via the command line. If no project filter is set, it always returns `true`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/vitest.md#_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\nfunction matchesProjectFilter(name: string): boolean\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Coverage Provider Module (TypeScript)\nDESCRIPTION: Provides an example of how to implement a custom Vitest coverage provider module. The module must export an object implementing the `CoverageProviderModule` interface and a class implementing the `CoverageProvider` interface.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/coverage.md#_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type {\n  CoverageProvider,\n  CoverageProviderModule,\n  ResolvedCoverageOptions,\n  Vitest\n} from 'vitest'\n\nconst CustomCoverageProviderModule: CoverageProviderModule = {\n  getProvider(): CoverageProvider {\n    return new CustomCoverageProvider()\n  },\n\n  // Implements rest of the CoverageProviderModule ...\n}\n\nclass CustomCoverageProvider implements CoverageProvider {\n  name = 'custom-coverage-provider'\n  options!: ResolvedCoverageOptions\n\n  initialize(ctx: Vitest) {\n    this.options = ctx.config.coverage\n  }\n\n  // Implements rest of the CoverageProvider ...\n}\n\nexport default CustomCoverageProviderModule\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Istanbul Coverage Reporter (JavaScript)\nDESCRIPTION: Provides an example implementation of a custom Istanbul coverage reporter in a `.cjs` file. It extends `istanbul-lib-report.ReportBase`, shows how to access options passed from the Vitest config, and demonstrates writing content to the report file.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/coverage.md#_snippet_6\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst { ReportBase } = require('istanbul-lib-report')\n\nmodule.exports = class CustomReporter extends ReportBase {\n  constructor(opts) {\n    super()\n\n    // Options passed from configuration are available here\n    this.file = opts.file\n  }\n\n  onStart(root, context) {\n    this.contentWriter = context.writer.writeFile(this.file)\n    this.contentWriter.println('Start of custom coverage report')\n  }\n\n  onEnd() {\n    this.contentWriter.println('End of custom coverage report')\n    this.contentWriter.close()\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Snapshot Manager Usage\nDESCRIPTION: Demonstrates the usage of `SnapshotManager` to manage multiple snapshot results. A `SnapshotManager` is created with the provided options, the snapshot result is added, and then the manager's `summary` property can be accessed to obtain a summary of the snapshot results.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/snapshot/README.md#_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\n// you can use manager to manage several clients\nconst manager = new SnapshotManager(options)\nmanager.add(result)\n\n// do something\n// and then read the summary\n\nconsole.log(manager.summary)\n```\n\n----------------------------------------\n\nTITLE: Running Specific Test Specifications in Vitest (TypeScript)\nDESCRIPTION: Executes tests based on an array of provided `TestSpecification` objects. The optional `allTestsRun` boolean influences coverage instrumentation (`coverage.all`). This method does not trigger watcher-related callbacks like `onWatcherRerun`; use `rerunTestSpecifications` for reruns with events.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/vitest.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nfunction runTestSpecifications(\n  specifications: TestSpecification[],\n  allTestsRun = false\n): Promise<TestRunResult>\n```\n\n----------------------------------------\n\nTITLE: Extracting Constructor Parameters with Vitest in TypeScript\nDESCRIPTION: Utilizes `.constructorParameters` to get the constructor arguments' types as an array for a given class or constructor function. Requires Vitest and works with constructable types, enabling type assertions over class constructors.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect-typeof.md#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf(Date).constructorParameters.toEqualTypeOf<[] | [string | number | Date]>()\n```\n\n----------------------------------------\n\nTITLE: Installing V8 Coverage Provider (Bash)\nDESCRIPTION: Bash command to manually install the `@vitest/coverage-v8` package as a development dependency using npm. This package is required to enable the v8 code coverage provider in Vitest.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/coverage.md#_snippet_1\n\nLANGUAGE: Bash\nCODE:\n```\nnpm i -D @vitest/coverage-v8\n```\n\n----------------------------------------\n\nTITLE: Asynchronously Executing Only Initially Pending Fake Timers with Vitest vi.runOnlyPendingTimersAsync in TypeScript\nDESCRIPTION: Demonstrates `vi.runOnlyPendingTimersAsync`, which executes only the initially pending timers (scheduled before the call), including asynchronous ones, and waits for their completion. Timers scheduled during its execution are ignored. Requires `vi` from `vitest`, enabling fake timers, and using `await`.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_27\n\nLANGUAGE: ts\nCODE:\n```\nsetTimeout(() => {\n  console.log(1)\n}, 100)\nsetTimeout(() => {\n  Promise.resolve().then(() => {\n    console.log(2)\n    setInterval(() => {\n      console.log(3)\n    }, 40)\n  })\n}, 10)\n\nawait vi.runOnlyPendingTimersAsync()\n\n// log: 2\n// log: 3\n// log: 3\n// log: 1\n```\n\n----------------------------------------\n\nTITLE: Iterating allSuites in TestCollection\nDESCRIPTION: This code iterates through all suites within a module's children (TestCollection) and logs any errors encountered during collection.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/test-collection.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nfor (const suite of module.children.allSuites()) {\n  if (suite.errors().length) {\n    console.log('failed to collect', suite.errors())\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Text Selections in DOM Elements Using TypeScript with Vitest\nDESCRIPTION: Demonstrates multiple test scenarios using TypeScript where text selections are set programmatically via setSelectionRange for inputs and textareas, or via the Selection and Range DOM APIs for more complex selections spanning multiple nodes. The examples show how to assert the presence or absence of selected text using the toHaveSelection method on elements identified by data-testid selectors. It covers single node selections and composite selections spanning parent and sibling nodes.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_42\n\nLANGUAGE: TypeScript\nCODE:\n```\ngetByTestId('text').element().setSelectionRange(5, 13)\nawait expect.element(getByTestId('text')).toHaveSelection('selected')\n\ngetByTestId('textarea').element().setSelectionRange(0, 5)\nawait expect.element('textarea').toHaveSelection('text ')\n\nconst selection = document.getSelection()\nconst range = document.createRange()\nselection.removeAllRanges()\nselection.empty()\nselection.addRange(range)\n\n// selection of child applies to the parent as well\nrange.selectNodeContents(getByTestId('child').element())\nawait expect.element(getByTestId('child')).toHaveSelection('selected')\nawait expect.element(getByTestId('parent')).toHaveSelection('selected')\n\n// selection that applies from prev all, parent text before child, and part child.\nrange.setStart(getByTestId('prev').element(), 0)\nrange.setEnd(getByTestId('child').element().childNodes[0], 3)\nawait expect.element(queryByTestId('prev')).toHaveSelection('prev')\nawait expect.element(queryByTestId('child')).toHaveSelection('sel')\nawait expect.element(queryByTestId('parent')).toHaveSelection('text sel')\nawait expect.element(queryByTestId('next')).not.toHaveSelection()\n\n// selection that applies from part child, parent text after child and part next.\nrange.setStart(getByTestId('child').element().childNodes[0], 3)\nrange.setEnd(getByTestId('next').element().childNodes[0], 2)\nawait expect.element(queryByTestId('child')).toHaveSelection('ected')\nawait expect.element(queryByTestId('parent')).toHaveSelection('ected text')\nawait expect.element(queryByTestId('prev')).not.toHaveSelection()\nawait expect.element(queryByTestId('next')).toHaveSelection('ne')\n```\n\n----------------------------------------\n\nTITLE: Installing @vitest/web-worker via Package Managers\nDESCRIPTION: Demonstrates how to install the @vitest/web-worker package as a development dependency using common JavaScript package managers like npm, pnpm, or yarn.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/web-worker/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# with npm\nnpm install -D @vitest/web-worker\n\n# with pnpm\npnpm install -D @vitest/web-worker\n\n# with yarn\nyarn add --dev @vitest/web-worker\n```\n\n----------------------------------------\n\nTITLE: Merging Separate Vite and Vitest Configurations\nDESCRIPTION: Provides an example of merging configurations from separate `vite.config.mjs` and `vitest.config.mjs` files using the `mergeConfig` function from `vitest/config`. This approach is useful if separate files are necessary, but collocating configurations in a single file is generally recommended.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/index.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n// vitest.config.mjs\nimport { defineConfig, mergeConfig } from 'vitest/config'\nimport viteConfig from './vite.config.mjs'\n\nexport default mergeConfig(viteConfig, defineConfig({\n  test: {\n    // ...\n  },\n}))\n```\n\nLANGUAGE: typescript\nCODE:\n```\n// vite.config.mjs\nimport { defineConfig } from 'vite'\nimport Vue from '@vitejs/plugin-vue'\n\nexport default defineConfig({\n  plugins: [Vue()],\n})\n```\n\n----------------------------------------\n\nTITLE: Automatic Runtime Registration and Compiler Hints Setup - TypeScript\nDESCRIPTION: Illustrates the use of the auto-register feature to automate runtime mocking setup and the creation of compiler hints for downstream usage. Requires importing @vitest/mocker/auto-register at the entry point and optionally using createCompilerHints from @vitest/mocker/browser. This approach simplifies initialization and supports custom compiler hint generation.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/mocker/EXPORTS.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\n// you can also just import \"auto-register\" at the top of your entry point,\n// this will use the server interceptor by default\nimport '@vitest/mocker/auto-register'\n// if you do this, you can create compiler hints with \"createCompilerHints\"\n// utility to use in your own code\nimport { createCompilerHints } from '@vitest/mocker/browser'\nconst vi = createCompilerHints()\n```\n\n----------------------------------------\n\nTITLE: Test Context Functions\nDESCRIPTION: Defines placeholder functions `getCurrentFilepath` and `getCurrentTestName` that should be implemented by the test runner. These functions provide the file path and test name for the current test being executed, which are necessary for snapshot management.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/snapshot/README.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n// you need to implement this yourselves,\n// this depends on your runner\nfunction getCurrentFilepath() {\n  return '/file.spec.js'\n}\nfunction getCurrentTestName() {\n  return 'test1'\n}\n```\n\n----------------------------------------\n\nTITLE: CDP Session in Vitest Browser Mode (TypeScript)\nDESCRIPTION: Defines the `cdp` export, which provides access to the current Chrome DevTools Protocol (CDP) session within the Vitest browser environment. This is primarily intended for library authors who need to build tools on top of the CDP. It only works with the `playwright` provider and the `chromium` browser.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/context.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport const cdp: () => CDPSession\n```\n\n----------------------------------------\n\nTITLE: Referencing Playwright Provider Types Vitest TypeScript\nDESCRIPTION: Provides the TypeScript reference directive required to enable autocompletion and type checking for the Playwright-specific context properties and utilities available when using the Vitest browser provider with Playwright. This directive should be included in a setup file or Vitest config file.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/commands.md#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\n/// <reference types=\"@vitest/browser/providers/playwright\" />\n```\n\n----------------------------------------\n\nTITLE: Installing Vitest Browser Mode Dependencies Using Various Package Managers - Bash\nDESCRIPTION: Commands to initialize Vitest browser mode setup automatically using the `vitest init browser` command. This installs necessary dependencies and creates a browser-specific configuration. Variants for npm, yarn, pnpm, and bun package managers are provided for user convenience.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/index.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx vitest init browser\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn exec vitest init browser\n```\n\nLANGUAGE: bash\nCODE:\n```\npnpx vitest init browser\n```\n\nLANGUAGE: bash\nCODE:\n```\nbunx vitest init browser\n```\n\n----------------------------------------\n\nTITLE: Configuring Browser Instances in Vitest with TypeScript\nDESCRIPTION: Demonstrates migrating from deprecated 'browser.name' and 'browser.providerOptions' to the new 'browser.instances' configuration array in Vitest 4. Utilizes defineConfig to export the configuration object with multiple browser instance objects. Requires TypeScript and Vitest configuration context.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/migration.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport default defineConfig({\n  test: {\n    browser: {\n      // Deprecated\n      name: 'chromium',\n      providerOptions: {\n        launch: { devtools: true },\n      },\n      // Recommended\n      instances: [\n        {\n          browser: 'chromium',\n          launch: { devtools: true },\n        },\n      ],\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Node Module Directories in .npmrc (Shell)\nDESCRIPTION: This shell snippet shows the required configuration line for an `.npmrc` file located next to the `package.json`. It adjusts Vite's module resolution to include directories used in the local testing setup.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/CONTRIBUTING.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nVITE_NODE_DEPS_MODULE_DIRECTORIES=/node_modules/,/packages/\n```\n\n----------------------------------------\n\nTITLE: Node Snapshot Environment Setup\nDESCRIPTION: Creates a NodeSnapshotEnvironment instance for snapshot saving and reading. By default, this uses the `fs` module for file system operations. You can provide your own implementation to customize how snapshots are saved and retrieved, adapting it to different environments.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/snapshot/README.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// class that implements snapshot saving and reading\n// by default uses fs module, but you can provide your own implementation depending on the environment\nconst environment = new NodeSnapshotEnvironment()\n```\n\n----------------------------------------\n\nTITLE: Automocking Module Source Code with automockModule Utility - TypeScript\nDESCRIPTION: Performs programmatic automocking of module source code using automockModule, combined with parseAst from Vite for AST parsing. Suitable for transforming export bodies so that all functions are mocked. Returns a MagicString instance for the transformed source and its source map, enabling extension or direct emission.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/mocker/EXPORTS.md#_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { automockModule } from '@vitest/mocker/node'\nimport { parseAst } from 'vite'\n\nconst ms = await automockModule(\n  `export function test() {}`,\n  'automock',\n  parseAst,\n)\nconsole.log(\n  ms.toString(),\n  ms.generateMap({ hires: 'boundary' })\n)\n```\n\n----------------------------------------\n\nTITLE: Configure poolMatchGlobs - TypeScript\nDESCRIPTION: This snippet demonstrates how to automatically assign a test pool based on file globs. The deprecated `poolMatchGlobs` allows tests in certain directories to run in specific pools such as `threads` or an actual `browser`, independent of the global pool configuration.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_20\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    poolMatchGlobs: [\n      // all tests in \"worker-specific\" directory will run inside a worker as if you enabled `--pool=threads` for them,\n      ['**/tests/worker-specific/**', 'threads'],\n      // run all tests in \"browser\" directory in an actual browser\n      ['**/tests/browser/**', 'browser'],\n      // all other tests will run based on \"browser.enabled\" and \"threads\" options, if you didn't specify other globs\n      // ...\n    ]\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Sample Output of automockModule Transformation - TypeScript\nDESCRIPTION: Shows the produced code after applying automockModule to a module source. Wraps the module's exports with a mocked object and re-exports them, using the __vitest_mocker__ infrastructure. Demonstrates the low-level output developers can expect from programmatic mocking utilities.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/mocker/EXPORTS.md#_snippet_10\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction test() {}\n\nconst __vitest_es_current_module__ = {\n  __esModule: true,\n  test,\n}\nconst __vitest_mocked_module__ = __vitest_mocker__.mockObject(__vitest_es_current_module__, 'automock')\nconst __vitest_mocked_0__ = __vitest_mocked_module__.test\nexport {\n  __vitest_mocked_0__ as test,\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Test File Hashes Using generateFileHash in Vitest (TypeScript)\nDESCRIPTION: This snippet demonstrates use of the generateFileHash function from vitest/node to create deterministic test file hashes, which are part of test IDs. It expects the file path and optionally a project name; produces a unique hash string. Dependency is Vitest 3 or newer with vitest/node import available. It is not intended for parsing IDs, only for generation.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/test-case.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { generateFileHash } from 'vitest/node'\n\nconst hash = generateFileHash(\n  '/file/path.js', // relative path\n  undefined, // the project name or `undefined` is not set\n)\n```\n\n----------------------------------------\n\nTITLE: Visualizing Pull Request Review Workflow (Mermaid)\nDESCRIPTION: A Mermaid flowchart diagram outlining the process for reviewing pull requests submitted to the Vitest repository. It covers differentiating between bug fixes and features, code review steps, discussing side effects, requiring tests, assigning labels, and the final merge process.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/CONTRIBUTING.md#_snippet_4\n\nLANGUAGE: mermaid\nCODE:\n```\nflowchart TD\n    start{Bug fix<br/>or<br/>feature}\n    start --BUG FIX--> strict_bug{\"Is a 'strict fix'<br/>i.e. fixes an obvious<br/>oversight with no<br/>side effects\"}\n    start --FEATURE--> feature[- Discuss feature necessity<br/>- Is this the best way to address the need<br/>- Review code quality<br/>- Add feature labels<br/>- Approve if you feel strongly<br/>that the feature is needed]\n    feature --> merge\n    strict_bug --YES--> strict[- Verify the fix locally<br/>- Review code quality<br/>- Require test case if applicable<br/>- Request changes if necessary]\n    strict_bug --NO--> non_strict[- Discuss the potential side<br/>effects of the fix, e.g.<br/>- Could it introduce implicit<br/>behavior changes in other<br/>cases?<br/>- Does it introduce too much<br/>changes?]\n    non_strict --> label[\"Add priority labels<br/>(see issue triaging workflow)\"]\n    strict --> label\n    label --> approve\n    approve --> merge[\"Merge if approved by 2 or<br/>more team members<br/>- Use 'Squash and Merge'<br/>- Edit commit message to follow convention<br/>- In commit message body, list relevant issues being fixed<br/>e.g. 'fix #1234, fix #1235'\"]\n```\n\n----------------------------------------\n\nTITLE: Defining File Interface Representing Test File Task in Vitest (TypeScript)\nDESCRIPTION: This TypeScript interface declares the File type, which extends the Suite interface, representing a test file task in Vitest's internal runner architecture. It includes properties such as pool to identify the execution pool, filepath to store the file path in UNIX format, projectName for the workspace project, and optional collectDuration and setupDuration timing metrics. This interface models the metadata and hierarchical task structure used to organize test files and their execution details.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/runner.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\ninterface File extends Suite {\n  /**\n   * The name of the pool that the file belongs to.\n   * @default 'forks'\n   */\n  pool?: string\n  /**\n   * The path to the file in UNIX format.\n   */\n  filepath: string\n  /**\n   * The name of the workspace project the file belongs to.\n   */\n  projectName: string | undefined\n  /**\n   * The time it took to collect all tests in the file.\n   * This time also includes importing all the file dependencies.\n   */\n  collectDuration?: number\n  /**\n   * The time it took to import the setup file.\n   */\n  setupDuration?: number\n}\n```\n\n----------------------------------------\n\nTITLE: Visualizing Issue Triaging Workflow (Mermaid)\nDESCRIPTION: A Mermaid flowchart diagram illustrating the step-by-step process followed by Vitest maintainers for triaging newly submitted issues, including checks for templates, duplicates, reproductions, and assigning priority labels.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/CONTRIBUTING.md#_snippet_3\n\nLANGUAGE: mermaid\nCODE:\n```\nflowchart TD\n    start{Followed issue<br/>template?}\n    start --NO--> close1[Close and ask to<br/>follow template]\n    start --YES--> dupe{Is duplicate?}\n    dupe --YES--> close2[Close and point<br/>to duplicate]\n    dupe --NO--> repro{Has proper<br/>reproduction?}\n    repro --NO--> close3[Label: 'needs reproduction'<br/>bot will auto close if no update has been made in 3 days]\n    repro --YES--> real{Is actually a bug?}\n    real --NO--> intended{Is the intended<br/>behaviour?}\n    intended --YES--> explain[Explain and close<br/>point to docs if needed]\n    intended --NO--> open[Keep open for discussion<br/>Remove 'pending triage' label]\n    real --YES--> real2[\"1. Remove 'pending triage' label<br/>2. Add related feature label if<br/>applicable (e.g. 'feat: browser')<br/>3. Add priority and meta labels (see below)\"]\n    real2 --> unusable{Does the<br/>bug make Vitest<br/>unusable?}\n    unusable --YES--> maj{Does the bug<br/>affect the majority<br/>of Vitest users?}\n    maj --YES--> p5[p5: urgent]\n    maj --NO--> p4[p4: important]\n    unusable --NO--> workarounds{Are there<br/>workarounds for<br/>the bug?}\n    workarounds --YES--> p2[p2: edge case<br/>has workaround]\n    workarounds --NO--> p3[p3: minor bug]\n```\n\n----------------------------------------\n\nTITLE: Defining the 'Meet the Team' Page Structure with Vue Components\nDESCRIPTION: This snippet sets up the page layout for displaying team information using Vue components from the 'vitepress/theme' library. It exports a page title and description, and arranges components to show current and emeriti team members, passing relevant data via props.\nSOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/team.md#_snippet_0\n\nLANGUAGE: Vue\nCODE:\n```\n<script setup>\nimport {\n  VPTeamPage,\n  VPTeamPageTitle,\n  VPTeamPageSection,\n  VPTeamMembers\n} from 'vitepress/theme'\nimport { teamMembers, teamEmeritiMembers } from './.vitepress/contributors'\n</script>\n\n<VPTeamPage>\n  <VPTeamPageTitle>\n    <template #title>Meet the Team</template>\n    <template #lead>\n      The development of Vitest is guided by an international team, some of whom\n      have chosen to be featured below.\n    </template>\n  </VPTeamPageTitle>\n  <VPTeamMembers :members=\"teamMembers\" />\n  <VPTeamPageSection>\n    <template #title>Team Emeriti</template>\n    <template #lead>\n      Here we honor some no-longer-active team members who have made valuable\n      contributions in the past.\n    </template>\n    <template #members>\n      <VPTeamMembers size=\"small\" :members=\"teamEmeritiMembers\" />\n    </template>\n  </VPTeamPageSection>\n</VPTeamPage>\n```"
  }
]