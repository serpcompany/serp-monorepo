[
  {
    "owner": "tidyverse",
    "repo": "duckplyr",
    "content": "TITLE: Extracting Data Frame Columns with Optional Naming in R\nDESCRIPTION: Function that extracts columns from a data frame using tidyselect syntax. It allows pulling a single column with optional renaming based on another column's values. The function handles both named and unnamed extractions with proper error handling.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/pull.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\npull.data.frame <- function(.data, var = -1, name = NULL, ...) {\n  var <- tidyselect::vars_pull(names(.data), !!enquo(var))\n  name <- enquo(name)\n  if (quo_is_null(name)) {\n    return(.data[[var]])\n  }\n  name <- tidyselect::vars_pull(names(.data), !!name)\n  set_names(.data[[var]], nm = .data[[name]])\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Data Transformation Pipeline with duckplyr\nDESCRIPTION: Code demonstrating a data transformation pipeline using duckplyr. The pipeline filters out missing values, calculates inflight delay, and summarizes the mean and median inflight delay by year and month, filtering for the first half of the year.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/index.md#2025-04-21_snippet_6\n\nLANGUAGE: r\nCODE:\n```\nout <-\n  flights_df() |>\n  filter(!is.na(arr_delay), !is.na(dep_delay)) |>\n  mutate(inflight_delay = arr_delay - dep_delay) |>\n  summarize(\n    .by = c(year, month),\n    mean_inflight_delay = mean(inflight_delay),\n    median_inflight_delay = median(inflight_delay),\n  ) |>\n  filter(month <= 6)\n```\n\n----------------------------------------\n\nTITLE: Implementing mutate Function for Data Frames in R\nDESCRIPTION: This function extends the mutate functionality for data frames in R. It allows for adding or modifying columns, with options for grouping, keeping specific columns, and relocating new columns. The function handles argument matching, computes grouping, and applies the mutations while preserving the original structure as needed.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/mutate.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nmutate.data.frame <- function(.data,\n                              ...,\n                              .by = NULL,\n                              .keep = c(\"all\", \"used\", \"unused\", \"none\"),\n                              .before = NULL,\n                              .after = NULL) {\n  keep <- arg_match0(.keep, values = c(\"all\", \"used\", \"unused\", \"none\"))\n\n  by <- compute_by({{ .by }}, .data, by_arg = \".by\", data_arg = \".data\")\n\n  cols <- mutate_cols(.data, dplyr_quosures(...), by)\n  used <- attr(cols, \"used\")\n\n  out <- dplyr_col_modify(.data, cols)\n\n  names_original <- names(.data)\n\n  out <- mutate_relocate(\n    out = out,\n    before = {{ .before }},\n    after = {{ .after }},\n    names_original = names_original\n  )\n\n  names_new <- names(cols)\n  names_groups <- by$names\n\n  out <- mutate_keep(\n    out = out,\n    keep = keep,\n    used = used,\n    names_new = names_new,\n    names_groups = names_groups\n  )\n\n  out\n}\n```\n\n----------------------------------------\n\nTITLE: Data Manipulation with duckplyr in R\nDESCRIPTION: Illustrates a complex data manipulation pipeline using duckplyr functions on a flights dataset, including filtering, mutating, and summarizing operations.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/README.md#2025-04-21_snippet_4\n\nLANGUAGE: R\nCODE:\n```\nout <-\n  flights_df() |>\n  filter(!is.na(arr_delay), !is.na(dep_delay)) |>\n  mutate(inflight_delay = arr_delay - dep_delay) |>\n  summarize(\n    .by = c(year, month),\n    mean_inflight_delay = mean(inflight_delay),\n    median_inflight_delay = median(inflight_delay),\n  ) |>\n  filter(month <= 6)\n```\n\n----------------------------------------\n\nTITLE: Implementing relocate function for data frames in R using dplyr\nDESCRIPTION: This function allows reordering of columns in a data frame. It uses dplyr's column selection mechanism and supports specifying new positions using .before and .after arguments. The function evaluates the relocation expression, selects columns, and renames them accordingly.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/relocate.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nrelocate.data.frame <- function(.data, ..., .before = NULL, .after = NULL) {\n  loc <- eval_relocate(\n    expr = expr(c(...)),\n    data = .data,\n    before = enquo(.before),\n    after = enquo(.after),\n    before_arg = \".before\",\n    after_arg = \".after\"\n  )\n\n  out <- dplyr_col_select(.data, loc)\n  out <- set_names(out, names(loc))\n\n  out\n}\n```\n\n----------------------------------------\n\nTITLE: Complex Flight Delay Analysis\nDESCRIPTION: Performs a complex analysis of flight delays, including calculating mean and median in-flight delays by year and month, with execution plan explanation.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/README.md#2025-04-21_snippet_13\n\nLANGUAGE: r\nCODE:\n```\nout <-\n  flights |>\n  mutate(InFlightDelay = ArrDelay - DepDelay) |>\n  summarize(\n    .by = c(Year, Month),\n    MeanInFlightDelay = mean(InFlightDelay, na.rm = TRUE),\n    MedianInFlightDelay = median(InFlightDelay, na.rm = TRUE),\n  ) |>\n  filter(Year < 2024)\n\nout |>\n  explain()\n```\n\n----------------------------------------\n\nTITLE: Implementing slice_head Function for Data Frames in R\nDESCRIPTION: Function that extracts the first n or proportion of rows from a data frame. Supports optional grouping through the 'by' parameter and handles both absolute (n) and proportional (prop) row selection.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/slice_head.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nslice_head.data.frame <- function(.data, ..., n, prop, by = NULL) {\n  check_dots_empty0(...)\n\n  size <- get_slice_size(n = n, prop = prop)\n  idx <- function(n) {\n    seq2(1, size(n))\n  }\n\n  dplyr_local_error_call()\n  dplyr_local_slice_by_arg(\"by\")\n\n  slice(.data, idx(dplyr::n()), .by = {{ by }})\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing transmute.data.frame Function in R\nDESCRIPTION: Defines the transmute operation for data frames that creates new columns while dropping unmentioned ones, except for grouping variables. The function processes quosure expressions, handles column modifications, and maintains proper column ordering with group variables taking precedence.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/transmute.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\ntransmute.data.frame <- function(.data, ...) {\n  dots <- check_transmute_args(...)\n  dots <- dplyr_quosures(!!!dots)\n\n  # We don't expose `.by` because `transmute()` is superseded\n  by <- compute_by(by = NULL, data = .data)\n\n  cols <- mutate_cols(.data, dots, by)\n\n  out <- dplyr_col_modify(.data, cols)\n\n  # Compact out `NULL` columns that got removed.\n  # These won't exist in `out`, but we don't want them to look \"new\".\n  # Note that `dplyr_col_modify()` makes it impossible to `NULL` a group column,\n  # which we rely on below.\n  cols <- compact_null(cols)\n\n  # Retain expression columns in order of their appearance\n  cols_expr <- names(cols)\n\n  # Retain untouched group variables up front\n  cols_group <- by$names\n  cols_group <- setdiff(cols_group, cols_expr)\n\n  cols_retain <- c(cols_group, cols_expr)\n\n  dplyr_col_select(out, cols_retain)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing nest_join for data.frames in R\nDESCRIPTION: This function performs a nest join between two data frames, where matching rows from the second data frame are nested as a list-column in the first data frame. It handles various join conditions, argument validation, and data transformation while preserving the original data structure.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/nest_join.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nnest_join.data.frame <- function(x,\n                                 y,\n                                 by = NULL,\n                                 copy = FALSE,\n                                 keep = NULL,\n                                 name = NULL,\n                                 ...,\n                                 na_matches = c(\"na\", \"never\"),\n                                 unmatched = \"drop\") {\n  check_dots_empty0(...)\n  check_keep(keep)\n  na_matches <- check_na_matches(na_matches)\n\n  if (is.null(name)) {\n    name <- as_label(enexpr(y))\n  } else {\n    check_string(name)\n  }\n\n  x_names <- tbl_vars(x)\n  y_names <- tbl_vars(y)\n\n  if (is_cross_by(by)) {\n    warn_join_cross_by()\n    by <- new_join_by()\n    cross <- TRUE\n  } else {\n    cross <- FALSE\n  }\n\n  if (is_null(by)) {\n    by <- join_by_common(x_names, y_names)\n  } else {\n    by <- as_join_by(by)\n  }\n\n  vars <- join_cols(x_names, y_names, by = by, suffix = c(\"\", \"\"), keep = keep)\n  y <- auto_copy(x, y, copy = copy)\n\n  x_in <- as_tibble(x, .name_repair = \"minimal\")\n  y_in <- as_tibble(y, .name_repair = \"minimal\")\n\n  x_key <- set_names(x_in[vars$x$key], names(vars$x$key))\n  y_key <- set_names(y_in[vars$y$key], names(vars$x$key))\n\n  args <- join_cast_common(x_key, y_key, vars)\n  x_key <- args$x\n  y_key <- args$y\n\n  condition <- by$condition\n  filter <- by$filter\n\n  # We always want to retain all of the matches. We never experience a Cartesian\n  # explosion because `nrow(x) == nrow(out)` is an invariant of `nest_join()`,\n  # and the whole point of `nest_join()` is to nest all of the matches for that\n  # row of `x` (#6392).\n  multiple <- \"all\"\n\n  # Will be set to `\"none\"` in `join_rows()`. Because we can't have a Cartesian\n  # explosion, we don't care about many-to-many relationships.\n  relationship <- NULL\n\n  rows <- join_rows(\n    x_key = x_key,\n    y_key = y_key,\n    type = \"nest\",\n    na_matches = na_matches,\n    condition = condition,\n    filter = filter,\n    cross = cross,\n    multiple = multiple,\n    unmatched = unmatched,\n    relationship = relationship,\n    user_env = caller_env()\n  )\n\n  y_loc <- vec_split(rows$y, rows$x)$val\n\n  out <- set_names(x_in[vars$x$out], names(vars$x$out))\n\n  # Modify all columns in one step so that we only need to re-group once\n  new_cols <- vec_cast(out[names(x_key)], x_key)\n\n  y_out <- set_names(y_in[vars$y$out], names(vars$y$out))\n  y_out <- map(y_loc, vec_slice, x = y_out)\n  y_out <- map(y_out, dplyr_reconstruct, template = y)\n  new_cols[[name]] <- y_out\n\n  out <- dplyr_col_modify(out, new_cols)\n  dplyr_reconstruct(out, x)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing count Function for Data Frames in R\nDESCRIPTION: Defines a function that counts occurrences in data frames, with support for grouping, weighting, sorting, and custom column naming. The function first groups the data if variables are specified, then uses tally() to perform the count, and finally ensures the result maintains the original data structure.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/count.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\ncount.data.frame <- function(x, ..., wt = NULL, sort = FALSE, name = NULL, .drop = group_by_drop_default(x)) {\n  dplyr_local_error_call()\n\n  if (!missing(...)) {\n    out <- group_by(x, ..., .add = TRUE, .drop = .drop)\n  } else {\n    out <- x\n  }\n\n  out <- tally(out, wt = !!enquo(wt), sort = sort, name = name)\n\n  # Ensure grouping is transient\n  out <- dplyr_reconstruct(out, x)\n\n  out\n}\n```\n\n----------------------------------------\n\nTITLE: Complex Query Execution on Remote Data with duckplyr\nDESCRIPTION: This code demonstrates a complex query on the remote data, including data manipulation, aggregation, and filtering. It also shows how to explain the query execution plan.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/index.md#2025-04-21_snippet_17\n\nLANGUAGE: r\nCODE:\n```\nout <-\n  flights |>\n  mutate(InFlightDelay = ArrDelay - DepDelay) |>\n  summarize(\n    .by = c(Year, Month),\n    MeanInFlightDelay = mean(InFlightDelay, na.rm = TRUE),\n    MedianInFlightDelay = median(InFlightDelay, na.rm = TRUE),\n  ) |>\n  filter(Year < 2024)\n\nout |>\n  explain()\n\nout |>\n  print() |>\n  system.time()\n```\n\n----------------------------------------\n\nTITLE: Implementing rename_with Function for Data Frames in R\nDESCRIPTION: This function renames columns in a data frame using a user-provided function. It handles column selection, applies the renaming function, and performs error checking on the results. The function ensures that the new names are unique and valid.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/rename_with.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nrename_with.data.frame <- function(.data, .fn, .cols = everything(), ...) {\n  .fn <- as_function(.fn)\n  cols <- tidyselect::eval_select(enquo(.cols), .data, allow_rename = FALSE)\n\n  names <- names(.data)\n\n  sel <- vec_slice(names, cols)\n  new <- .fn(sel, ...)\n\n  if (!is_character(new)) {\n    cli::cli_abort(\n      \"{.arg .fn} must return a character vector, not {.obj_type_friendly {new}}.\"\n    )\n  }\n  if (length(new) != length(sel)) {\n    cli::cli_abort(\n      \"{.arg .fn} must return a vector of length {length(sel)}, not {length(new)}.\"\n    )\n  }\n\n  names <- vec_assign(names, cols, new)\n  names <- vec_as_names(names, repair = \"check_unique\")\n\n  set_names(.data, names)\n}\n```\n\n----------------------------------------\n\nTITLE: Counting Rows by Year in duckplyr\nDESCRIPTION: This snippet shows a simple aggregation operation on the remote data, counting the number of rows for each year in the flights dataset.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/index.md#2025-04-21_snippet_16\n\nLANGUAGE: r\nCODE:\n```\nflights |>\n  count(Year)\n```\n\n----------------------------------------\n\nTITLE: Implementing group_map.data.frame Function in R\nDESCRIPTION: This function applies a custom function to each group in a data frame. It processes grouped data frames by splitting them into chunks based on groups, applies the function to each chunk with its corresponding group key, and returns the results in a list. It also handles empty data frames by calling the function with prototype objects.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/group_map.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\ngroup_map.data.frame <- function(.data, .f, ..., .keep = FALSE, keep = deprecated()) {\n  if (!missing(keep)) {\n    lifecycle::deprecate_warn(\"1.0.0\", \"group_map(keep = )\", \"group_map(.keep = )\", always = TRUE)\n    .keep <- keep\n  }\n  .f <- as_group_map_function(.f)\n\n  # call the function on each group\n  chunks <- if (is_grouped_df(.data)) {\n    group_split(.data, .keep = isTRUE(.keep))\n  } else {\n    group_split(.data)\n  }\n  keys  <- group_keys(.data)\n  group_keys <- map(seq_len(nrow(keys)), function(i) keys[i, , drop = FALSE])\n\n  if (length(chunks)) {\n    map2(chunks, group_keys, .f, ...)\n  } else {\n    # calling .f with .x and .y set to prototypes\n    structure(list(), ptype = .f(attr(chunks, \"ptype\"), keys[integer(0L), ], ...))\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Slicing Data Frame Rows in R\nDESCRIPTION: Function that implements row slicing for data.frame objects with support for grouping via .by parameter and preservation of row order via .preserve flag. Uses enquos for non-standard evaluation of slice expressions and computes row locations based on grouping criteria.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/slice.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nslice.data.frame <- function(.data, ..., .by = NULL, .preserve = FALSE) {\n  check_dots_unnamed()\n\n  dots <- enquos(...)\n\n  by <- compute_by(\n    by = {{ .by }},\n    data = .data,\n    by_arg = the$slice_by_arg,\n    data_arg = \".data\"\n  )\n\n  loc <- slice_rows(.data, dots, by)\n  dplyr_row_slice(.data, loc, preserve = .preserve)\n}\n```\n\n----------------------------------------\n\nTITLE: Installing duckplyr Development Version from R-universe\nDESCRIPTION: Command to install the development version of duckplyr from R-universe. This provides access to newer features that haven't been released to CRAN yet.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/index.md#2025-04-21_snippet_1\n\nLANGUAGE: r\nCODE:\n```\ninstall.packages(\"duckplyr\", repos = c(\"https://tidyverse.r-universe.dev\", \"https://cloud.r-project.org\"))\n```\n\n----------------------------------------\n\nTITLE: Implementing rows_insert for Data Frames in R\nDESCRIPTION: Function that inserts rows from one data frame into another with conflict handling. It supports matching by specified columns, handles data type consistency, and provides options for conflict resolution and in-place modification.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/rows_insert.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nrows_insert.data.frame <- function(x,\n                                   y,\n                                   by = NULL,\n                                   ...,\n                                   conflict = c(\"error\", \"ignore\"),\n                                   copy = FALSE,\n                                   in_place = FALSE) {\n  check_dots_empty()\n  rows_df_in_place(in_place)\n\n  y <- auto_copy(x, y, copy = copy)\n\n  by <- rows_check_by(by, y)\n\n  rows_check_x_contains_y(x, y)\n  rows_check_contains_by(x, by, \"x\")\n  rows_check_contains_by(y, by, \"y\")\n\n  y <- rows_cast_y(y, x)\n\n  x_key <- dplyr_col_select(x, by)\n  y_key <- dplyr_col_select(y, by)\n\n  keep <- rows_check_y_conflict(x_key, y_key, conflict)\n\n  if (!is.null(keep)) {\n    y <- dplyr_row_slice(y, keep)\n  }\n\n  rows_bind(x, y)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing distinct Function for Data Frames in R\nDESCRIPTION: This function removes duplicate rows from a data frame based on specified columns. It prepares the data, identifies unique rows based on selected columns, and returns only the first occurrence of each unique combination. The optional .keep_all parameter controls whether to retain all columns in the output.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/distinct.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\ndistinct.data.frame <- function(.data, ..., .keep_all = FALSE) {\n  prep <- distinct_prepare(\n    .data,\n    vars = enquos(...),\n    group_vars = group_vars(.data),\n    .keep_all = .keep_all,\n    caller_env = caller_env()\n  )\n\n  out <- prep$data\n\n  cols <- dplyr_col_select(out, prep$vars)\n  loc <- vec_unique_loc(cols)\n\n  out <- dplyr_col_select(out, prep$keep)\n  dplyr_row_slice(out, loc)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing reframe Function for Data Frames in R\nDESCRIPTION: Defines a reframe function that processes data frames with optional grouping via `.by` parameter. Handles both tibble and standard data frame outputs while maintaining proper data types. Uses summarise_cols and summarise_build for internal computations.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/reframe.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nreframe.data.frame <- function(.data, ..., .by = NULL) {\n  by <- compute_by({{ .by }}, .data, by_arg = \".by\", data_arg = \".data\")\n\n  cols <- summarise_cols(.data, dplyr_quosures(...), by, \"reframe\")\n  out <- summarise_build(by, cols)\n\n  if (!is_tibble(.data)) {\n    # The `by` group data we build from is always a tibble,\n    # so we have to manually downcast as needed\n    out <- as.data.frame(out)\n  }\n\n  out\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating Number of Groups in Data Frame - R Implementation\nDESCRIPTION: Function that returns the number of groups in a data frame by counting rows in the group data structure. It takes a data frame as input and returns an integer representing the number of distinct groups.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/n_groups.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nn_groups.data.frame <- function(x) {\n  nrow(group_data(x))\n}\n```\n\n----------------------------------------\n\nTITLE: Analyzing Tip Percentages by Day and Hour in R using duckplyr\nDESCRIPTION: This query calculates the average tip percentage for taxi rides grouped by day of week and hour of day. It filters for positive total amounts, calculates tip percentage, and then aggregates data using summarise() with a .by parameter.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/demo.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\ntips_by_day_hour <- taxi_data_2019 %>% filter(total_amount > 0) %>% mutate(\n  tip_pct = 100 * tip_amount / total_amount, dn = wday(pickup_datetime), hr = hour(\n    pickup_datetime)) %>% summarise(avg_tip_pct = mean(tip_pct), n = n(), .by = c(\n  dn, hr)) %>% arrange(desc(avg_tip_pct))\ntips_by_day_hour\n```\n\n----------------------------------------\n\nTITLE: Complex Summarization with duckplyr Fallback in R\nDESCRIPTION: Shows a more complex summarization operation that automatically falls back to dplyr when the computation is not supported by DuckDB.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/README.md#2025-04-21_snippet_7\n\nLANGUAGE: R\nCODE:\n```\nflights_df() |>\n  summarize(\n    .by = origin,\n    dest = paste(sort(unique(dest)), collapse = \" \")\n  )\n#> # A tibble: 3 × 2\n#>   origin dest                                                          \n#>   <chr>  <chr>                                                         \n#> 1 EWR    ALB ANC ATL AUS AVL BDL BNA BOS BQN BTV BUF BWI BZN CAE CHS C…\n#> 2 LGA    ATL AVL BGR BHM BNA BOS BTV BUF BWI CAE CAK CHO CHS CLE CLT C…\n#> 3 JFK    ABQ ACK ATL AUS BHM BNA BOS BQN BTV BUF BUR BWI CHS CLE CLT C…\n```\n\n----------------------------------------\n\nTITLE: Implementing filter.data.frame Function in R\nDESCRIPTION: This function filters rows in a data frame based on logical conditions. It supports optional grouping with the .by parameter and preservation of row order with .preserve. The function processes quoted expressions, computes grouping, filters rows, and returns the filtered data frame.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/filter.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nfilter.data.frame <- function(.data, ..., .by = NULL, .preserve = FALSE) {\n  dots <- dplyr_quosures(...)\n  check_filter(dots)\n\n  by <- compute_by(\n    by = {{ .by }},\n    data = .data,\n    by_arg = \".by\",\n    data_arg = \".data\"\n  )\n\n  loc <- filter_rows(.data, dots, by)\n  dplyr_row_slice(.data, loc, preserve = .preserve)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing group_split.data.frame Function in R\nDESCRIPTION: This function splits a data frame into a list of data frames based on grouping variables. It handles backwards compatibility with the deprecated 'keep' parameter, forwards to the modern '.keep' parameter, and uses group_by and group_split_impl functions to perform the actual splitting operation.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/group_split.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\ngroup_split.data.frame <- function(.tbl, ..., .keep = TRUE, keep = deprecated()) {\n  if (!missing(keep)) {\n    lifecycle::deprecate_warn(\"1.0.0\", \"group_split(keep = )\", \"group_split(.keep = )\", always = TRUE)\n    .keep <- keep\n  }\n  data <- group_by(.tbl, ...)\n  group_split_impl(data, .keep = .keep)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing rows_patch.data.frame Function in R\nDESCRIPTION: Function that patches/updates values in a data frame (x) based on matching rows from another data frame (y). It matches rows using specified columns (by), handles unmatched rows according to the 'unmatched' parameter, and can operate in-place. The function ensures type compatibility and maintains data integrity.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/rows_patch.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nrows_patch.data.frame <- function(x,\n                                  y,\n                                  by = NULL,\n                                  ...,\n                                  unmatched = c(\"error\", \"ignore\"),\n                                  copy = FALSE,\n                                  in_place = FALSE) {\n  check_dots_empty()\n  rows_df_in_place(in_place)\n\n  y <- auto_copy(x, y, copy = copy)\n\n  by <- rows_check_by(by, y)\n\n  rows_check_x_contains_y(x, y)\n  rows_check_contains_by(x, by, \"x\")\n  rows_check_contains_by(y, by, \"y\")\n\n  x_key <- dplyr_col_select(x, by)\n  y_key <- dplyr_col_select(y, by)\n\n  rows_check_unique(y_key, \"y\")\n\n  args <- vec_cast_common(x = x_key, y = y_key)\n  x_key <- args$x\n  y_key <- args$y\n\n  values_names <- setdiff(names(y), names(y_key))\n\n  x_values <- dplyr_col_select(x, values_names)\n  y_values <- dplyr_col_select(y, values_names)\n  y_values <- rows_cast_y(y_values, x_values)\n\n  keep <- rows_check_y_unmatched(x_key, y_key, unmatched)\n\n  if (!is.null(keep)) {\n    y_key <- dplyr_row_slice(y_key, keep)\n    y_values <- dplyr_row_slice(y_values, keep)\n  }\n\n  loc <- vec_match(x_key, y_key)\n  match <- !is.na(loc)\n\n  y_loc <- loc[match]\n  x_loc <- which(match)\n\n  x_slice <- dplyr_row_slice(x_values, x_loc)\n  x_slice <- dplyr_new_list(x_slice)\n\n  y_slice <- dplyr_row_slice(y_values, y_loc)\n  y_slice <- dplyr_new_list(y_slice)\n\n  x_patched <- map2(x_slice, y_slice, coalesce)\n  x_patched <- new_data_frame(x_patched, n = length(x_loc))\n\n  x_values <- vec_assign(x_values, x_loc, x_patched)\n  x_values <- dplyr_new_list(x_values)\n\n  x <- dplyr_col_modify(x, x_values)\n\n  x\n}\n```\n\n----------------------------------------\n\nTITLE: Materializing duckplyr Results in R\nDESCRIPTION: Demonstrates how to materialize results from a duckplyr operation by querying a column or printing the entire result.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/README.md#2025-04-21_snippet_6\n\nLANGUAGE: R\nCODE:\n```\nout$month\n#> [1] 1 2 3 4 5 6\n```\n\nLANGUAGE: R\nCODE:\n```\nout\n#> # A tibble: 6 × 4\n#>    year month mean_inflight_delay median_inflight_delay\n#>   <int> <int>               <dbl>                 <dbl>\n#> 1  2013     1               -3.86                    -5\n#> 2  2013     2               -5.15                    -6\n#> 3  2013     3               -7.36                    -9\n#> 4  2013     4               -2.67                    -5\n#> 5  2013     5               -9.37                   -10\n#> 6  2013     6               -4.24                    -7\n```\n\n----------------------------------------\n\nTITLE: Implementing Full Join Operation for Data Frames in R\nDESCRIPTION: Defines a function that performs a full outer join between two data frames. Supports customization through parameters like suffix naming, NA matching behavior, and relationship specifications. The function handles data copying and delegates the actual join operation to join_mutate.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/full_join.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nfull_join.data.frame <- function(x,\n                                 y,\n                                 by = NULL,\n                                 copy = FALSE,\n                                 suffix = c(\".x\", \".y\"),\n                                 ...,\n                                 keep = NULL,\n                                 na_matches = c(\"na\", \"never\"),\n                                 multiple = \"all\",\n                                 relationship = NULL) {\n  check_dots_empty0(...)\n  y <- auto_copy(x, y, copy = copy)\n  join_mutate(\n    x = x,\n    y = y,\n    by = by,\n    type = \"full\",\n    suffix = suffix,\n    na_matches = na_matches,\n    keep = keep,\n    multiple = multiple,\n    # All keys from both inputs are retained. Erroring never makes sense.\n    unmatched = \"drop\",\n    relationship = relationship,\n    user_env = caller_env()\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Data Frame to Rowwise Data Frame in R\nDESCRIPTION: Function that transforms a standard data frame into a rowwise data frame. It accepts a data frame and optional column selections and uses tidyselect to evaluate the column selection before creating a rowwise_df object.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/rowwise.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nrowwise.data.frame <- function(data, ...) {\n  vars <- tidyselect::eval_select(expr(c(...)), data)\n  rowwise_df(data, vars)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing rows_upsert.data.frame Function in R for duckplyr\nDESCRIPTION: This function performs an upsert operation on data frames. It updates rows in 'x' with matching rows from 'y' based on 'by' columns, and inserts rows from 'y' that don't exist in 'x'. The function includes validation checks for parameters, proper type casting, and ensures data integrity during the operation.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/rows_upsert.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nrows_upsert.data.frame <- function(x,\n                                   y,\n                                   by = NULL,\n                                   ...,\n                                   copy = FALSE,\n                                   in_place = FALSE) {\n  check_dots_empty()\n  rows_df_in_place(in_place)\n\n  y <- auto_copy(x, y, copy = copy)\n\n  by <- rows_check_by(by, y)\n\n  rows_check_x_contains_y(x, y)\n  rows_check_contains_by(x, by, \"x\")\n  rows_check_contains_by(y, by, \"y\")\n\n  x_key <- dplyr_col_select(x, by)\n  y_key <- dplyr_col_select(y, by)\n\n  rows_check_unique(y_key, \"y\")\n\n  args <- vec_cast_common(x = x_key, y = y_key)\n  x_key <- args$x\n  y_key <- args$y\n\n  values_names <- setdiff(names(y), names(y_key))\n\n  x_values <- dplyr_col_select(x, values_names)\n  y_values <- dplyr_col_select(y, values_names)\n  y_values <- rows_cast_y(y_values, x_values)\n\n  loc <- vec_match(x_key, y_key)\n  match <- !is.na(loc)\n\n  y_loc <- loc[match]\n  x_loc <- which(match)\n\n  # Update\n  y_values <- dplyr_row_slice(y_values, y_loc)\n  x_values <- vec_assign(x_values, x_loc, y_values)\n  x_values <- dplyr_new_list(x_values)\n\n  x <- dplyr_col_modify(x, x_values)\n\n  # Insert\n  y_size <- vec_size(y_key)\n  y_extra <- vec_as_location_invert(y_loc, y_size)\n\n  y <- dplyr_row_slice(y, y_extra)\n  y <- rows_cast_y(y, x)\n\n  x <- rows_bind(x, y)\n\n  x\n}\n```\n\n----------------------------------------\n\nTITLE: Loading duckplyr and Handling Method Conflicts\nDESCRIPTION: Code to load the duckplyr package and handle method conflicts. The conflicted package is used to manage conflicts between different packages, and a message indicates that dplyr methods are being overwritten by duckplyr methods.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/index.md#2025-04-21_snippet_3\n\nLANGUAGE: r\nCODE:\n```\nlibrary(conflicted)\nlibrary(duckplyr)\n#> Loading required package: dplyr\n#> [1m[22m[32m✔[39m Overwriting [34mdplyr[39m methods with [34mduckplyr[39m methods.\n#> [36mℹ[39m Turn off with `duckplyr::methods_restore()`.\n```\n\n----------------------------------------\n\nTITLE: Creating Column Reference Expressions in duckplyr\nDESCRIPTION: Creates a relational expression that references a column. The function returns a list with the column name, NULL rel value, NULL alias, and appropriate class attributes.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/expr.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\nrelexpr_reference(\"column\")\n```\n\n----------------------------------------\n\nTITLE: Appending Rows to Data Frames in R\nDESCRIPTION: This function appends rows from one data frame to another. It checks for compatibility, performs necessary type casting, and handles in-place modification if specified. The function also supports an optional copy parameter.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/rows_append.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nrows_append.data.frame <- function(x,\n                                   y,\n                                   ...,\n                                   copy = FALSE,\n                                   in_place = FALSE) {\n  check_dots_empty()\n  rows_df_in_place(in_place)\n\n  y <- auto_copy(x, y, copy = copy)\n\n  rows_check_x_contains_y(x, y)\n  y <- rows_cast_y(y, x)\n\n  rows_bind(x, y)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing right_join for data.frame in R (duckplyr)\nDESCRIPTION: This function performs a right join between two data frames. It handles copying the right data frame if needed, and delegates the actual joining logic to the join_mutate function with 'right' as the join type. The function supports various parameters to control joining behavior including suffix naming, NA matching, handling of multiple matches, and unmatched rows.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/right_join.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nright_join.data.frame <- function(x,\n                                  y,\n                                  by = NULL,\n                                  copy = FALSE,\n                                  suffix = c(\".x\", \".y\"),\n                                  ...,\n                                  keep = NULL,\n                                  na_matches = c(\"na\", \"never\"),\n                                  multiple = \"all\",\n                                  unmatched = \"drop\",\n                                  relationship = NULL) {\n  check_dots_empty0(...)\n  y <- auto_copy(x, y, copy = copy)\n  join_mutate(\n    x = x,\n    y = y,\n    by = by,\n    type = \"right\",\n    suffix = suffix,\n    na_matches = na_matches,\n    keep = keep,\n    multiple = multiple,\n    unmatched = unmatched,\n    relationship = relationship,\n    user_env = caller_env()\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Special Join Conditions in R\nDESCRIPTION: This snippet tests the use and error handling of special join conditions like between(), within(), overlaps(), and closest() within join_by().\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-join-by.md#2025-04-21_snippet_4\n\nLANGUAGE: R\nCODE:\n```\njoin_by(between(x, lower, upper, bounds = 1))\njoin_by(between(x, lower, upper, bounds = \"a\"))\njoin_by(overlaps(x, y, lower, upper, bounds = 1))\njoin_by(overlaps(x, y, lower, upper, bounds = \"a\"))\njoin_by(between(x, lower, upper, foo = 1))\njoin_by(overlaps(x, y, lower, upper, foo = 1))\n```\n\n----------------------------------------\n\nTITLE: Testing duckplyr_expand_across with Complex Custom Function in R\nDESCRIPTION: This snippet tests the duckplyr_expand_across function using across() with a more complex custom function. It demonstrates how to use arithmetic operations within the custom function.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/duckplyr-across.md#2025-04-21_snippet_6\n\nLANGUAGE: R\nCODE:\n```\ntest_duckplyr_expand_across(c(\"x\", \"y\", \"a\"), across(c(a, x), function(x) x * 2 + 1))\n```\n\n----------------------------------------\n\nTITLE: Data Preview and Counting Records by Year\nDESCRIPTION: Demonstrates how to preview the flights dataset and perform a basic aggregation to count records by year.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/README.md#2025-04-21_snippet_12\n\nLANGUAGE: r\nCODE:\n```\nflights |>\n  count(Year)\n```\n\n----------------------------------------\n\nTITLE: Testing duckplyr_expand_across with Named List of Functions in R\nDESCRIPTION: This snippet tests the duckplyr_expand_across function using across() with a named list containing a single function. It demonstrates how to name functions within the list passed to across().\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/duckplyr-across.md#2025-04-21_snippet_10\n\nLANGUAGE: R\nCODE:\n```\ntest_duckplyr_expand_across(c(\"x\", \"y\"), across(x:y, list(mean = mean)))\n```\n\n----------------------------------------\n\nTITLE: Implementing slice_sample for Data Frames in R\nDESCRIPTION: This function randomly samples rows from a data frame with various options. It supports sampling by count (n) or proportion (prop), grouped sampling (by), weighted sampling (weight_by), and sampling with or without replacement. The function checks inputs and delegates to the slice function for the actual row selection.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/slice_sample.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nslice_sample.data.frame <- function(.data, ..., n, prop, by = NULL, weight_by = NULL, replace = FALSE) {\n  check_dots_empty0(...)\n\n  size <- get_slice_size(n = n, prop = prop, allow_outsize = replace)\n\n  dplyr_local_error_call()\n  dplyr_local_slice_by_arg(\"by\")\n\n  slice(\n    .data,\n    .by = {{ by }},\n    local({\n      weight_by <- {{ weight_by }}\n\n      n <- dplyr::n()\n      if (!is.null(weight_by)) {\n        vec_check_size(weight_by, size = n)\n      }\n      sample_int(n, size(n), replace = !!replace, wt = weight_by)\n    })\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating Group Indices for Data Frames in R using dplyr\nDESCRIPTION: This function calculates group indices for a data frame. It supports legacy usage with direct grouping (with a deprecation warning) and calls a C++ function for efficient computation. The function requires the dplyr package and uses lifecycle for deprecation warnings.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/group_indices.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\ngroup_indices.data.frame <- function(.data, ...) {\n  if (dots_n(...) > 0) {\n    lifecycle::deprecate_warn(\n      \"1.0.0\", \"group_indices(... = )\",\n      details = \"Please `group_by()` first\",\n      always = TRUE\n    )\n    .data <- group_by(.data, ...)\n  }\n\n  .Call(`dplyr_group_indices`, .data, group_rows(.data))\n}\n```\n\n----------------------------------------\n\nTITLE: Analyzing Zero-Tip Trips Between Boroughs in R using duckplyr\nDESCRIPTION: This multi-step analysis calculates the percentage of trips with zero tips between NYC boroughs. It first counts all trips between boroughs, then counts zero-tip trips, and finally joins the results to calculate percentages, sorting by highest zero-tip percentage.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/demo.md#2025-04-21_snippet_3\n\nLANGUAGE: r\nCODE:\n```\nnum_trips_per_borough <- taxi_data_2019 %>% filter(total_amount > 0) %>%\n  inner_join(zone_map, by = join_by(pickup_location_id == LocationID)) %>%\n  inner_join(zone_map, by = join_by(dropoff_location_id == LocationID)) %>%\n  mutate(pickup_borough = Borough.x, dropoff_borough = Borough.y) %>% select(\n  pickup_borough, dropoff_borough, tip_amount) %>% summarise(num_trips = n(),\n.by = c(pickup_borough, dropoff_borough))\nnum_trips_per_borough_no_tip <- taxi_data_2019 %>% filter(total_amount > 0,\ntip_amount == 0) %>% inner_join(zone_map, by = join_by(pickup_location_id ==\n  LocationID)) %>% inner_join(zone_map, by = join_by(dropoff_location_id ==\n  LocationID)) %>% mutate(pickup_borough = Borough.x, dropoff_borough = Borough.y,\n  tip_amount) %>% summarise(num_zero_tip_trips = n(), .by = c(pickup_borough,\n  dropoff_borough))\nnum_zero_percent_trips <- num_trips_per_borough %>% inner_join(\n  num_trips_per_borough_no_tip, by = join_by(pickup_borough, dropoff_borough)) %>%\n  mutate(num_trips = num_trips, percent_zero_tips_trips = 100 *\n    num_zero_tip_trips / num_trips) %>% select(pickup_borough, dropoff_borough,\n  num_trips, percent_zero_tips_trips) %>% arrange(desc(percent_zero_tips_trips))\nnum_zero_percent_trips\n```\n\n----------------------------------------\n\nTITLE: Implementing slice_tail for data.frame in R/dplyr\nDESCRIPTION: Function that extracts the last n or proportion of rows from a data frame. Supports grouping operations through the 'by' parameter and integrates with dplyr's error handling system. Uses sequence generation to identify the tail rows to keep.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/slice_tail.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nslice_tail.data.frame <- function(.data, ..., n, prop, by = NULL) {\n  check_dots_empty0(...)\n\n  size <- get_slice_size(n = n, prop = prop)\n  idx <- function(n) {\n    seq2(n - size(n) + 1, n)\n  }\n\n  dplyr_local_error_call()\n  dplyr_local_slice_by_arg(\"by\")\n\n  slice(.data, idx(dplyr::n()), .by = {{ by }})\n}\n```\n\n----------------------------------------\n\nTITLE: Testing duckplyr_expand_across with List of Functions in R\nDESCRIPTION: This snippet tests the duckplyr_expand_across function using across() with a list containing a single function. It shows how to pass a list of functions to across().\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/duckplyr-across.md#2025-04-21_snippet_9\n\nLANGUAGE: R\nCODE:\n```\ntest_duckplyr_expand_across(c(\"x\", \"y\"), across(x:y, list(mean)))\n```\n\n----------------------------------------\n\nTITLE: Testing duckplyr_expand_across with Custom Naming in R\nDESCRIPTION: This snippet tests the duckplyr_expand_across function using across() with custom naming for the resulting columns. It shows how to use the .names argument to control the output column names.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/duckplyr-across.md#2025-04-21_snippet_3\n\nLANGUAGE: R\nCODE:\n```\ntest_duckplyr_expand_across(c(\"x\", \"y\"), across(c(x_mean = x, y_mean = y), mean, .names = \"{.col}_{.fn}\"))\n```\n\n----------------------------------------\n\nTITLE: Adding counts to a data.frame in R\nDESCRIPTION: This function adds a count column to a data frame while preserving the original data. It takes a data frame, optional grouping variables, and a weight column, then adds the count as a new column with an optional name. The resulting data maintains the same structure as the input.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/add_count.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nadd_count.data.frame <- function(x, ..., wt = NULL, sort = FALSE, name = NULL, .drop = deprecated()) {\n  out <- add_count_impl(\n    x,\n    ...,\n    wt = {{ wt }},\n    sort = sort,\n    name = name,\n    .drop = .drop\n  )\n  dplyr_reconstruct(out, x)\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Default NA Handling in duckplyr Aggregations\nDESCRIPTION: This snippet shows that by default, aggregation functions in duckplyr do not remove NA values, maintaining compatibility with base R behavior.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/index.md#2025-04-21_snippet_18\n\nLANGUAGE: r\nCODE:\n```\nflights |>\n  summarize(mean(ArrDelay - DepDelay))\n```\n\n----------------------------------------\n\nTITLE: Extracting Group Variables as Symbols in R\nDESCRIPTION: This function extracts the group variables from a data frame and converts them to symbols using the syms function. It relies on the group_vars function to identify which variables are used for grouping in the data frame.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/groups.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\ngroups.data.frame <- function(x) {\n  syms(group_vars(x))\n}\n```\n\n----------------------------------------\n\nTITLE: Loading duckplyr and Handling Conflicts in R\nDESCRIPTION: Demonstrates loading the duckplyr library, which overwrites dplyr methods, and using conflicted to handle function conflicts.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/README.md#2025-04-21_snippet_3\n\nLANGUAGE: R\nCODE:\n```\nlibrary(conflicted)\nlibrary(duckplyr)\n#> Loading required package: dplyr\n#> ✔ Overwriting dplyr methods with duckplyr methods.\n#> ℹ Turn off with `duckplyr::methods_restore()`.\n```\n\nLANGUAGE: R\nCODE:\n```\nconflict_prefer(\"filter\", \"dplyr\")\n#> [conflicted] Will prefer dplyr::filter\n#> over any other package.\n```\n\n----------------------------------------\n\nTITLE: Testing Any/All Aggregation in R\nDESCRIPTION: Tests logical aggregation functions any() and all() with different NA handling scenarios\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/translate.md#2025-04-21_snippet_8\n\nLANGUAGE: R\nCODE:\n```\nrel_translate(expr(any(a)), df)\nrel_translate(expr(any(a, na.rm = TRUE)), df)\nrel_translate(expr(all(a)), df)\nrel_translate(expr(all(a, na.rm = TRUE)), df)\n```\n\n----------------------------------------\n\nTITLE: Implementing inner_join Function for Data Frames in R\nDESCRIPTION: Defines a function that performs an inner join operation between two data frames. The function supports various parameters including join columns specification, suffix naming, NA matching behavior, and handling of multiple/unmatched records. It utilizes join_mutate internally for the actual join operation.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/inner_join.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\ninner_join.data.frame <- function(x,\n                                  y,\n                                  by = NULL,\n                                  copy = FALSE,\n                                  suffix = c(\".x\", \".y\"),\n                                  ...,\n                                  keep = NULL,\n                                  na_matches = c(\"na\", \"never\"),\n                                  multiple = \"all\",\n                                  unmatched = \"drop\",\n                                  relationship = NULL) {\n  check_dots_empty0(...)\n  y <- auto_copy(x, y, copy = copy)\n  join_mutate(\n    x = x,\n    y = y,\n    by = by,\n    type = \"inner\",\n    suffix = suffix,\n    na_matches = na_matches,\n    keep = keep,\n    multiple = multiple,\n    unmatched = unmatched,\n    relationship = relationship,\n    user_env = caller_env()\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing DataFrame with UTF-8 Column Names in R\nDESCRIPTION: Creates a dataframe with Chinese column names and performs basic transformations using dplyr-style operations. Tests memory address consistency of column names through various operations.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/utf-8.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\ndf <- data.frame(中文1 = 1:10, 中文2 = 1:10, eng = 1:10)\ndf2 <- df %>% mutate(中文1 = 中文1 + 1)\ngdf2 <- df %>% group_by(eng) %>% mutate(中文1 = 中文1 + 1)\n\nexpect_equal(lobstr::obj_addrs(names(df)), lobstr::obj_addrs(names(df2)))\nexpect_equal(lobstr::obj_addrs(names(df)), lobstr::obj_addrs(names(gdf2)))\n```\n\n----------------------------------------\n\nTITLE: Implementing Anti-Join for Data Frames in R\nDESCRIPTION: This function performs an anti-join operation between two data frames. It checks for empty dots, copies the y data frame if necessary, and uses join_filter to perform the anti-join. The function handles NA matching and preserves the calling environment.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/anti_join.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nanti_join.data.frame <- function(x, y, by = NULL, copy = FALSE, ..., na_matches = c(\"na\", \"never\")) {\n  check_dots_empty0(...)\n  y <- auto_copy(x, y, copy = copy)\n  join_filter(x, y, by = by, type = \"anti\", na_matches = na_matches, user_env = caller_env())\n}\n```\n\n----------------------------------------\n\nTITLE: Extracting Group Variables from Data Frame in R\nDESCRIPTION: This function extracts group variables from a data frame by getting the difference between all column names and the '.rows' column. It relies on the 'group_data' function to retrieve group information.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/group_vars.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\ngroup_vars.data.frame <- function(x) {\n  setdiff(names(group_data(x)), \".rows\")\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Output Class in duckplyr\nDESCRIPTION: Code to check the class of the output object after duckplyr transformation. This demonstrates that the result is a standard tibble, maintaining compatibility with existing data manipulation workflows.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/index.md#2025-04-21_snippet_7\n\nLANGUAGE: r\nCODE:\n```\nclass(out)\n#> [1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n```\n\n----------------------------------------\n\nTITLE: Installing and Loading httpfs Extension in DuckDB\nDESCRIPTION: This code installs and loads the httpfs DuckDB extension, which allows querying remote files directly. It then reads the Parquet files into a duckplyr data frame.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/index.md#2025-04-21_snippet_13\n\nLANGUAGE: r\nCODE:\n```\ndb_exec(\"INSTALL httpfs\")\ndb_exec(\"LOAD httpfs\")\n\nflights <- read_parquet_duckdb(urls)\n```\n\n----------------------------------------\n\nTITLE: Testing Chained Count Operations with Weights\nDESCRIPTION: Shows how to chain multiple count operations with weighted values and demonstrates automatic column naming when conflicts occur.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-count-tally.md#2025-04-21_snippet_1\n\nLANGUAGE: r\nCODE:\n```\ndf <- data.frame(g = c(1, 1, 2, 2), n = 1:4)\ndf %>% duckplyr_count(g, wt = n)\ndf %>% duckplyr_count(g, wt = n) %>% duckplyr_count(wt = n)\ndf %>% duckplyr_count(n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Left Join Operation for Data Frames in R\nDESCRIPTION: Function that performs a left join operation between two data frames. It supports various join parameters including suffix handling, NA matching, multiple match handling, and relationship specifications. The function uses join_mutate internally after performing necessary parameter validation and data copying.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/left_join.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nleft_join.data.frame <- function(x,\n                                 y,\n                                 by = NULL,\n                                 copy = FALSE,\n                                 suffix = c(\".x\", \".y\"),\n                                 ...,\n                                 keep = NULL,\n                                 na_matches = c(\"na\", \"never\"),\n                                 multiple = \"all\",\n                                 unmatched = \"drop\",\n                                 relationship = NULL) {\n  check_dots_empty0(...)\n  y <- auto_copy(x, y, copy = copy)\n  join_mutate(\n    x = x,\n    y = y,\n    by = by,\n    type = \"left\",\n    suffix = suffix,\n    na_matches = na_matches,\n    keep = keep,\n    multiple = multiple,\n    unmatched = unmatched,\n    relationship = relationship,\n    user_env = caller_env()\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Filtering DataFrame with English Column Conditions in R\nDESCRIPTION: Applies filter operations on both grouped and ungrouped dataframes using English column name conditions. Verifies column name memory addresses remain consistent after filtering.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/utf-8.txt#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\ndf3 <- filter(df2, eng > 5)\ngdf3 <- filter(gdf2, eng > 5)\nexpect_equal(lobstr::obj_addrs(names(df)), lobstr::obj_addrs(names(df3)))\nexpect_equal(lobstr::obj_addrs(names(df)), lobstr::obj_addrs(names(gdf3)))\n```\n\n----------------------------------------\n\nTITLE: Implementing union_all for Data Frames in R\nDESCRIPTION: This function performs a union all operation by row-binding two data frames. It first checks for empty dots parameters and compatibility between the data frames before combining them with vec_rbind and reconstructing the output with the structure of the first data frame.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/union_all.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nunion_all.data.frame <- function(x, y, ...) {\n  check_dots_empty()\n  check_compatible(x, y)\n\n  out <- vec_rbind(x, y)\n  dplyr_reconstruct(out, x)\n}\n```\n\n----------------------------------------\n\nTITLE: Extracting Group Keys from Data Frame in R\nDESCRIPTION: Function that extracts group keys from a data frame. It handles both direct grouping specifications via ... arguments and pre-grouped data frames. Includes deprecation warning for direct grouping specification.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/group_keys.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\ngroup_keys.data.frame <- function(.tbl, ...) {\n  if (dots_n(...) > 0) {\n    lifecycle::deprecate_warn(\n      \"1.0.0\", \"group_keys(... = )\",\n      details = \"Please `group_by()` first\",\n      always = TRUE\n    )\n    .tbl <- group_by(.tbl, ...)\n  }\n  out <- group_data(.tbl)\n  group_keys0(out)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing do.data.frame Function in R for Custom Data Frame Operations\nDESCRIPTION: This function handles custom computations on data frames, supporting both named and unnamed argument formats. It creates a custom data mask with a '.' pronoun bound to the input data frame, evaluates the provided expressions within this context, and returns either a single data frame (for unnamed arguments) or a tibble of results (for named arguments).\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/do.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\ndo.data.frame <- function(.data, ...) {\n  args <- enquos(...)\n  named <- named_args(args)\n\n  # Create custom data mask with `.` pronoun\n  mask <- new_data_mask(new_environment())\n  env_bind_do_pronouns(mask, .data)\n\n  if (!named) {\n    out <- eval_tidy(args[[1]], mask)\n    if (!inherits(out, \"data.frame\")) {\n      msg <- glue(\"Result must be a data frame, not {fmt_classes(out)}.\")\n      abort(msg)\n    }\n  } else {\n    out <- map(args, function(arg) list(eval_tidy(arg, mask)))\n    names(out) <- names(args)\n    out <- tibble::as_tibble(out, .name_repair = \"minimal\")\n  }\n\n  out\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Automatic Fallback to dplyr in duckplyr\nDESCRIPTION: Code demonstrating how duckplyr automatically falls back to dplyr for operations not supported by DuckDB. This example uses a text concatenation operation that DuckDB cannot handle natively.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/index.md#2025-04-21_snippet_10\n\nLANGUAGE: r\nCODE:\n```\nflights_df() |>\n  summarize(\n    .by = origin,\n    dest = paste(sort(unique(dest)), collapse = \" \")\n  )\n#> [38;5;246m# A tibble: 3 × 2[39m\n#>   [1morigin[22m [1mdest[22m                                                          \n#>   [3m[38;5;246m<chr>[39m[23m  [3m[38;5;246m<chr>[39m[23m                                                         \n#> [38;5;250m1[39m EWR    ALB ANC ATL AUS AVL BDL BNA BOS BQN BTV BUF BWI BZN CAE CHS C…\n#> [38;5;250m2[39m LGA    ATL AVL BGR BHM BNA BOS BTV BUF BWI CAE CAK CHO CHS CLE CLT C…\n#> [38;5;250m3[39m JFK    ABQ ACK ATL AUS BHM BNA BOS BQN BTV BUF BUR BWI CHS CLE CLT C…\n```\n\n----------------------------------------\n\nTITLE: Filtering DataFrame with Chinese Column Conditions in R\nDESCRIPTION: Applies filter operations on both grouped and ungrouped dataframes using Chinese column name conditions. Verifies column name memory addresses remain consistent after filtering.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/utf-8.txt#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\ndf4 <- filter(df2, 中文1 > 5)\ngdf4 <- filter(gdf2, 中文1 > 5)\nexpect_equal(lobstr::obj_addrs(names(df)), lobstr::obj_addrs(names(df4)))\nexpect_equal(lobstr::obj_addrs(names(df)), lobstr::obj_addrs(names(gdf4)))\n```\n\n----------------------------------------\n\nTITLE: Creating Function Call Expressions in duckplyr\nDESCRIPTION: Creates a relational expression representing a function call with arguments. This example adds a column reference and a constant value with an alias, returning a nested list structure with appropriate class attributes.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/expr.md#2025-04-21_snippet_2\n\nLANGUAGE: r\nCODE:\n```\nrelexpr_function(\"+\", list(relexpr_reference(\"column\"), relexpr_constant(42, alias = \"fortytwo\")))\n```\n\n----------------------------------------\n\nTITLE: Reading CSV file into dataframe using duckplyr in R\nDESCRIPTION: New convenience function duckdb_df_from_csv() to read a CSV file into a dataframe using DuckDB.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/NEWS.md#2025-04-21_snippet_5\n\nLANGUAGE: R\nCODE:\n```\ndf <- duckdb_df_from_csv(\"input.csv\")\n```\n\n----------------------------------------\n\nTITLE: Installing duckplyr from CRAN in R\nDESCRIPTION: Shows how to install the duckplyr package from CRAN using the install.packages() function.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/README.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\ninstall.packages(\"duckplyr\")\n```\n\n----------------------------------------\n\nTITLE: Implementing group_nest function for data frames in R\nDESCRIPTION: This function creates nested data frames based on grouping variables. If grouping variables are provided, it groups the data and then nests it. Otherwise, it returns a tibble with the entire data frame in a list column with the specified key name.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/group_nest.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\ngroup_nest.data.frame <- function(.tbl, ..., .key = \"data\", keep = FALSE) {\n  if (dots_n(...)) {\n    group_nest_impl(group_by(.tbl, ...), .key = .key, keep = keep)\n  } else {\n    tibble(!!.key := list(.tbl))\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Class of duckplyr Result in R\nDESCRIPTION: Shows how to check the class of the result from a duckplyr operation, which returns a plain tibble.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/README.md#2025-04-21_snippet_5\n\nLANGUAGE: R\nCODE:\n```\nclass(out)\n#> [1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n```\n\n----------------------------------------\n\nTITLE: Printing Remote Data Frame in R\nDESCRIPTION: This code demonstrates how duckplyr prints only the first few rows of a remote data frame without materializing the entire result.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/index.md#2025-04-21_snippet_15\n\nLANGUAGE: r\nCODE:\n```\nflights\n```\n\n----------------------------------------\n\nTITLE: Implementing cross_join for data.frame in R\nDESCRIPTION: Function that performs a cross join between two data frames, creating all possible combinations of rows. It handles column naming conflicts using suffixes, supports optional data copying, and maintains the original data structure. The function performs size-based row replication to create the Cartesian product.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/cross_join.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\ncross_join.data.frame <- function(x,\n                                  y,\n                                  ...,\n                                  copy = FALSE,\n                                  suffix = c(\".x\", \".y\")) {\n  check_dots_empty0(...)\n\n  y <- auto_copy(x, y, copy = copy)\n\n  x_names <- tbl_vars(x)\n  y_names <- tbl_vars(y)\n\n  # Empty join by with no keys\n  by <- new_join_by()\n\n  # Particular value isn't too important, as there are no keys to keep/drop\n  keep <- FALSE\n\n  vars <- join_cols(\n    x_names = x_names,\n    y_names = y_names,\n    by = by,\n    suffix = suffix,\n    keep = keep\n  )\n\n  x_in <- as_tibble(x, .name_repair = \"minimal\")\n  y_in <- as_tibble(y, .name_repair = \"minimal\")\n\n  x_size <- vec_size(x_in)\n  y_size <- vec_size(y_in)\n\n  x_out <- set_names(x_in, names(vars$x$out))\n  y_out <- set_names(y_in, names(vars$y$out))\n\n  x_out <- vec_rep_each(x_out, times = y_size)\n  y_out <- vec_rep(y_out, times = x_size)\n\n  x_out[names(y_out)] <- y_out\n\n  dplyr_reconstruct(x_out, x)\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating NA Handling in Aggregations\nDESCRIPTION: Shows how aggregation functions handle NA values by default in duckplyr, maintaining compatibility with standard R behavior.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/README.md#2025-04-21_snippet_14\n\nLANGUAGE: r\nCODE:\n```\nflights |>\n  summarize(mean(ArrDelay - DepDelay))\n```\n\n----------------------------------------\n\nTITLE: Installing duckplyr Package from CRAN in R\nDESCRIPTION: Command to install the duckplyr package from CRAN. This is the recommended installation method for most users seeking the stable release.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/index.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\ninstall.packages(\"duckplyr\")\n```\n\n----------------------------------------\n\nTITLE: Fetching Remote Parquet File URLs in R\nDESCRIPTION: This snippet demonstrates how to construct URLs for remote Parquet files containing flight data for multiple years. It uses base R functions to create a tibble of URLs.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/index.md#2025-04-21_snippet_12\n\nLANGUAGE: r\nCODE:\n```\nyear <- 2022:2024\nbase_url <- \"https://blobs.duckdb.org/flight-data-partitioned/\"\nfiles <- paste0(\"Year=\", year, \"/data_0.parquet\")\nurls <- paste0(base_url, files)\ntibble(urls)\n```\n\n----------------------------------------\n\nTITLE: Generating URLs for Remote Parquet Files in R\nDESCRIPTION: Creates URLs for accessing flight data stored in Parquet format from DuckDB's blob storage. Demonstrates how to construct paths for multiple years of data.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/README.md#2025-04-21_snippet_9\n\nLANGUAGE: r\nCODE:\n```\nyear <- 2022:2024\nbase_url <- \"https://blobs.duckdb.org/flight-data-partitioned/\"\nfiles <- paste0(\"Year=\", year, \"/data_0.parquet\")\nurls <- paste0(base_url, files)\ntibble(urls)\n```\n\n----------------------------------------\n\nTITLE: Analyzing Tip Percentages by Passenger Count in R using duckplyr\nDESCRIPTION: This query calculates the median tip percentage for taxi rides grouped by passenger count. It filters for positive total amounts, calculates tip percentage, and aggregates data using summarise() with a .by parameter.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/demo.md#2025-04-21_snippet_1\n\nLANGUAGE: r\nCODE:\n```\ntips_by_passenger <- taxi_data_2019 %>% filter(total_amount > 0) %>% mutate(\n  tip_pct = 100 * tip_amount / total_amount) %>% summarise(avg_tip_pct = median(\n  tip_pct), n = n(), .by = passenger_count) %>% arrange(desc(passenger_count))\ntips_by_passenger\n```\n\n----------------------------------------\n\nTITLE: Testing Column Overwriting in DuckPlyr Mutate (R)\nDESCRIPTION: This snippet tests the behavior of duckplyr_mutate when attempting to overwrite a column's value using the <<- operator. It demonstrates that this operation is not allowed and results in an error.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-mutate.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nduckplyr_mutate(df, y = {\n  x <<- 2\n  x\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing setequal Function for Data Frames in R\nDESCRIPTION: This function compares two data frames to check if they contain the same set of rows, regardless of order. It uses vector casting for type consistency and the vec_in function for element comparison.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/setequal.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nsetequal.data.frame <- function(x, y, ...) {\n  check_dots_empty()\n  check_compatible(x, y)\n\n  cast <- vec_cast_common(x = x, y = y)\n  all(vec_in(cast$x, cast$y)) && all(vec_in(cast$y, cast$x))\n}\n```\n\n----------------------------------------\n\nTITLE: Sorting Data Frames with arrange.data.frame Function in R\nDESCRIPTION: This function implements the arrange functionality for data.frame objects, allowing for sorting based on specified columns. It supports group-wise sorting via the .by_group parameter and locale-specific sorting with .locale. The function uses quosures to capture column expressions, arranges rows based on these expressions, and returns a sliced data frame.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/arrange.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\narrange.data.frame <- function(.data,\n                               ...,\n                               .by_group = FALSE,\n                               .locale = NULL) {\n  dots <- enquos(...)\n\n  if (.by_group) {\n    dots <- c(quos(!!!groups(.data)), dots)\n  }\n\n  loc <- arrange_rows(.data, dots = dots, locale = .locale)\n  dplyr_row_slice(.data, loc)\n}\n```\n\n----------------------------------------\n\nTITLE: Aggregating DuckDB Relations Without Grouping\nDESCRIPTION: Demonstrates aggregation on ungrouped data to compute a single overall mean value.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/relational-duckdb.md#2025-04-21_snippet_3\n\nLANGUAGE: r\nCODE:\n```\nungrouped %>% rel_to_df(prudence = \"lavish\")\n```\n\n----------------------------------------\n\nTITLE: Testing mutate with duckplyr in R\nDESCRIPTION: Demonstrates mutate operations using duckplyr, expecting errors with telemetry data. Tests include simple mutate and mutate with grouping and keep options.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/telemetry.md#2025-04-21_snippet_9\n\nLANGUAGE: R\nCODE:\n```\nduckdb_tibble(a = 1:3, b = 4:6) %>% mutate(c = a + b)\n```\n\nLANGUAGE: R\nCODE:\n```\nduckdb_tibble(a = 1:3, b = 4:6) %>% mutate(c = a + b, .by = a, .keep = \"unused\")\n```\n\n----------------------------------------\n\nTITLE: Testing Aggregation Functions with na.rm in Window Context\nDESCRIPTION: Tests how aggregation functions (sum, min, max, mean) behave with na.rm=TRUE in window functions using rel_translate(). This validates that these functions properly handle missing values when used in window operations.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/translate.md#2025-04-21_snippet_10\n\nLANGUAGE: r\nCODE:\n```\n# Test aggregation primitives with na.rm = TRUE in window functions\nrel_translate(expr(sum(a, na.rm = TRUE)), df, need_window = TRUE)\n```\n\nLANGUAGE: r\nCODE:\n```\nrel_translate(expr(min(a, na.rm = TRUE)), df, need_window = TRUE)\n```\n\nLANGUAGE: r\nCODE:\n```\nrel_translate(expr(max(a, na.rm = TRUE)), df, need_window = TRUE)\n```\n\nLANGUAGE: r\nCODE:\n```\nrel_translate(expr(mean(a, na.rm = TRUE)), df, need_window = TRUE)\n```\n\n----------------------------------------\n\nTITLE: Testing duckplyr_expand_across with Multiple Named Functions in R\nDESCRIPTION: This snippet tests the duckplyr_expand_across function using across() with a named list containing multiple functions. It shows how to apply multiple functions to columns using across().\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/duckplyr-across.md#2025-04-21_snippet_11\n\nLANGUAGE: R\nCODE:\n```\ntest_duckplyr_expand_across(c(\"x\", \"y\"), across(x:y, list(mean = mean, median = median)))\n```\n\n----------------------------------------\n\nTITLE: Reading Parquet file into dataframe using duckplyr in R\nDESCRIPTION: New convenience function duckdb_df_from_parquet() to read a Parquet file into a dataframe using DuckDB.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/NEWS.md#2025-04-21_snippet_6\n\nLANGUAGE: R\nCODE:\n```\ndf <- duckdb_df_from_parquet(\"input.parquet\")\n```\n\n----------------------------------------\n\nTITLE: Validating 'n' Parameter in lead() Function in R\nDESCRIPTION: These tests check if lead() function properly validates the 'n' parameter. It tests for errors when 'n' is a vector or a negative number.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-lead-lag.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\nlead(1:5, n = 1:2)\n```\n\nLANGUAGE: R\nCODE:\n```\nlead(1:5, -1)\n```\n\n----------------------------------------\n\nTITLE: Testing summarise with DuckPlyr\nDESCRIPTION: Testing summarise operations with different grouping and parameter options\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/telemetry.md#2025-04-21_snippet_16\n\nLANGUAGE: R\nCODE:\n```\nduckdb_tibble(a = 1:3, b = 4:6) %>% summarise(c = sum(b))\n```\n\nLANGUAGE: R\nCODE:\n```\nduckdb_tibble(a = 1:3, b = 4:6) %>% summarise(c = sum(b), .by = a)\n```\n\nLANGUAGE: R\nCODE:\n```\nduckdb_tibble(a = 1:3, b = 4:6) %>% summarise(c = sum(b), .groups = \"rowwise\")\n```\n\n----------------------------------------\n\nTITLE: Testing Type Casting in duckplyr_rows_update\nDESCRIPTION: This snippet checks how duckplyr_rows_update handles type casting for keys and values, ensuring appropriate error messages for incompatible types.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-rows.md#2025-04-21_snippet_8\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(duckplyr_rows_update(x, y, \"key\")))\n```\n\n----------------------------------------\n\nTITLE: Implementing union.data.frame Function in R\nDESCRIPTION: Function that performs a set union operation between two data frames. It checks for empty dots arguments, validates compatibility between input data frames, and reconstructs the result while preserving the original data frame attributes.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/union.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nunion.data.frame <- function(x, y, ...) {\n  check_dots_empty()\n  check_compatible(x, y)\n\n  out <- vec_set_union(x, y, error_call = current_env())\n\n  dplyr_reconstruct(out, x)\n}\n```\n\n----------------------------------------\n\nTITLE: Finding Popular Manhattan Cab Rides in R using duckplyr\nDESCRIPTION: This query identifies the most popular Manhattan-to-Manhattan taxi routes. It joins taxi data with zone maps to get neighborhood names, filters for Manhattan pickup and dropoff locations, and counts the number of trips between each neighborhood pair.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/demo.md#2025-04-21_snippet_2\n\nLANGUAGE: r\nCODE:\n```\npopular_manhattan_cab_rides <- taxi_data_2019 %>% filter(total_amount > 0) %>%\n  inner_join(zone_map, by = join_by(pickup_location_id == LocationID)) %>%\n  inner_join(zone_map, by = join_by(dropoff_location_id == LocationID)) %>%\n  filter(Borough.x == \"Manhattan\", Borough.y == \"Manhattan\") %>% select(\n  start_neighborhood = Zone.x, end_neighborhood = Zone.y) %>% summarise(\n  num_trips = n(), .by = c(start_neighborhood, end_neighborhood), ) %>% arrange(\n  desc(num_trips))\npopular_manhattan_cab_rides\n```\n\n----------------------------------------\n\nTITLE: Displaying Flight Data with duckplyr\nDESCRIPTION: Code to display the flights dataset. This uses a function flights_df() that returns a variant of the nycflights13::flights dataset with timezone set to UTC to work around a limitation of duckplyr.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/index.md#2025-04-21_snippet_5\n\nLANGUAGE: r\nCODE:\n```\nflights_df()\n#> [38;5;246m# A tibble: 336,776 × 19[39m\n#>     [1myear[22m [1mmonth[22m   [1mday[22m [1mdep_time[22m [1msched_d…¹[22m [1mdep_d…²[22m [1marr_t…³[22m [1msched…⁴[22m [1marr_d…⁵[22m\n#>    [3m[38;5;246m<int>[39m[23m [3m[38;5;246m<int>[39m[23m [3m[38;5;246m<int>[39m[23m    [3m[38;5;246m<int>[39m[23m     [3m[38;5;246m<int>[39m[23m   [3m[38;5;246m<dbl>[39m[23m   [3m[38;5;246m<int>[39m[23m   [3m[38;5;246m<int>[39m[23m   [3m[38;5;246m<dbl>[39m[23m\n#> [38;5;250m 1[39m  [4m2[24m013     1     1      517       515       2     830     819      11\n#> [38;5;250m 2[39m  [4m2[24m013     1     1      533       529       4     850     830      20\n#> [38;5;250m 3[39m  [4m2[24m013     1     1      542       540       2     923     850      33\n#> [38;5;250m 4[39m  [4m2[24m013     1     1      544       545      -[31m1[39m    [4m1[24m004    [4m1[24m022     -[31m18[39m\n#> [38;5;250m 5[39m  [4m2[24m013     1     1      554       600      -[31m6[39m     812     837     -[31m25[39m\n#> [38;5;250m 6[39m  [4m2[24m013     1     1      554       558      -[31m4[39m     740     728      12\n#> [38;5;250m 7[39m  [4m2[24m013     1     1      555       600      -[31m5[39m     913     854      19\n#> [38;5;250m 8[39m  [4m2[24m013     1     1      557       600      -[31m3[39m     709     723     -[31m14[39m\n#> [38;5;250m 9[39m  [4m2[24m013     1     1      557       600      -[31m3[39m     838     846      -[31m8[39m\n#> [38;5;250m10[39m  [4m2[24m013     1     1      558       600      -[31m2[39m     753     745       8\n#> [38;5;246m# ℹ 336,766 more rows[39m\n#> [38;5;246m# ℹ abbreviated names: ¹​sched_dep_time, ²​dep_delay, ³​arr_time,[39m\n#> [38;5;246m#   ⁴​sched_arr_time, ⁵​arr_delay[39m\n#> [38;5;246m# ℹ 10 more variables: [1mcarrier[22m <chr>, [1mflight[22m <int>, [1mtailnum[22m <chr>,[39m\n#> [38;5;246m#   [1morigin[22m <chr>, [1mdest[22m <chr>, [1mair_time[22m <dbl>, [1mdistance[22m <dbl>,[39m\n#> [38;5;246m#   [1mhour[22m <dbl>, [1mminute[22m <dbl>, [1mtime_hour[22m <dttm>[39m\n```\n\n----------------------------------------\n\nTITLE: DuckDB Function Translation Example in R\nDESCRIPTION: Example showing how to use DuckDB function translation with dd$ prefix\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/NEWS.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\ndd$ROW()\n```\n\n----------------------------------------\n\nTITLE: Testing with_order() with mismatched sizes\nDESCRIPTION: Tests that with_order() correctly detects and reports when the order_by argument has a different size than the input x vector.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-order-by.md#2025-04-21_snippet_2\n\nLANGUAGE: r\nCODE:\n```\nwith_order(1:2, identity, 1:3)\n```\n\n----------------------------------------\n\nTITLE: Implementing Data Frame Intersection Operation in R\nDESCRIPTION: A function that finds the common rows between two data frames. It first checks for empty dots parameters, validates that both data frames are compatible, then uses the vec_set_intersect function to perform the intersection, and finally reconstructs the result with the structure of the first data frame.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/intersect.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nintersect.data.frame <- function(x, y, ...) {\n  check_dots_empty()\n  check_compatible(x, y)\n\n  out <- vec_set_intersect(x, y, error_call = current_env())\n\n  dplyr_reconstruct(out, x)\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Successful Function Translation Paths with rel_find_call()\nDESCRIPTION: Tests successful translation of function calls from different packages using rel_find_call(). Validates translations for base R functions, dplyr functions, DuckDB functions, and functions from other packages like stats and lubridate.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/translate.md#2025-04-21_snippet_12\n\nLANGUAGE: r\nCODE:\n```\n# Success: Translate base function\nrel_find_call(quote(mean), env)\n```\n\nLANGUAGE: r\nCODE:\n```\n# Success: Translate dplyr::n() function\n# https://github.com/tidyverse/dplyr/pull/7046\nrel_find_call(quote(n), env)\n```\n\nLANGUAGE: r\nCODE:\n```\n# Success: Translate DuckDB function with 'dd$' prefix\nrel_find_call(quote(dd$ROW), env)\n```\n\nLANGUAGE: r\nCODE:\n```\n# Success: Translate stats function when stats is available\nrel_find_call(quote(sd), new_environment(parent = asNamespace(\"stats\")))\n```\n\nLANGUAGE: r\nCODE:\n```\n# Success: Translate lubridate function\nrel_find_call(quote(lubridate::wday), env)\n```\n\nLANGUAGE: r\nCODE:\n```\n# Success: Translate lubridate function when exported\nrel_find_call(quote(wday), new_environment(list(wday = lubridate::wday)))\n```\n\n----------------------------------------\n\nTITLE: Querying R Repositories from GitHub Data\nDESCRIPTION: SQL query to filter repositories containing R language code, excluding CRAN repositories. Creates the tinker.r_repos table.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/gh-analysis/README.md#2025-04-21_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\nSELECT \n  DISTINCT repo_name\nFROM\n  `bigquery-public-data.github_repos.languages` l, UNNEST(language)\nWHERE\n  name = 'R' AND repo_name NOT LIKE 'cran/%'\nORDER BY\n  repo_name\n```\n\n----------------------------------------\n\nTITLE: Testing inner_join with duckplyr in R\nDESCRIPTION: Demonstrates inner_join operations using duckplyr, expecting errors with telemetry data. Tests include default join and join with various options like copying, suffixes, and relationship specification.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/telemetry.md#2025-04-21_snippet_6\n\nLANGUAGE: R\nCODE:\n```\nduckdb_tibble(a = 1:3, b = 4:6) %>% inner_join(tibble(a = 1:3, b = 4:6))\n```\n\nLANGUAGE: R\nCODE:\n```\nduckdb_tibble(a = 1:3, b = 4:6) %>% inner_join(tibble(a = 1:3, b = 4:6), by = \"a\", copy = TRUE, suffix = c(\"x\", \"y\"), keep = TRUE, na_matches = \"na\", multiple = \"all\", unmatched = \"error\", relationship = \"one-to-one\")\n```\n\n----------------------------------------\n\nTITLE: Implementing setdiff for Data Frames in R\nDESCRIPTION: This function performs a set difference operation between two data frames. It checks for compatibility between the input data frames, uses vec_set_difference for the actual set operation, and reconstructs the output using dplyr_reconstruct.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/setdiff.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nsetdiff.data.frame <- function(x, y, ...) {\n  check_dots_empty()\n  check_compatible(x, y)\n\n  out <- vec_set_difference(x, y, error_call = current_env())\n\n  dplyr_reconstruct(out, x)\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Namespaced Helpers in join_by() in R\nDESCRIPTION: This snippet tests the use of namespaced helper functions within join_by(), specifically dplyr's between(), within(), overlaps(), and closest() functions.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-join-by.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\njoin_by(dplyr::between(x, left, right))\njoin_by(dplyr::within(xl, xu, yl, yu))\njoin_by(dplyr::overlaps(xl, xu, yl, yu))\njoin_by(dplyr::closest(x < y))\n```\n\n----------------------------------------\n\nTITLE: Testing Complex Join Conditions in R\nDESCRIPTION: This snippet tests more complex join conditions using comparison operators and special functions like closest().\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-join-by.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\njoin_by(a == a, b >= c)\njoin_by(a == a, b >= \"c\")\njoin_by(a == a, closest(b >= c), closest(d < e))\n```\n\n----------------------------------------\n\nTITLE: Error using n_distinct() with multiple arguments in DuckDB with dplyr\nDESCRIPTION: Demonstrates that n_distinct() in DuckDB context only accepts a single argument (plus optional na.rm parameter). Trying to count distinct combinations of multiple columns will throw an error.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/n_distinct.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\ndf %>% summarise(dummy = n_distinct(a, b))\n```\n\n----------------------------------------\n\nTITLE: Executing TPC-H Query 1-22 in DuckPlyr\nDESCRIPTION: A series of TPC-H benchmark queries executed using DuckPlyr, showing the structure of returned data frames. Each query returns specific columns with defined data types including numeric, character, date and integer values.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/tpch.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\ntpch_01()\ntpch_02()\ntpch_03()\ntpch_04()\ntpch_05()\ntpch_06()\ntpch_07()\ntpch_08()\ntpch_09()\ntpch_10()\ntpch_11()\ntpch_12()\ntpch_13()\ntpch_14()\ntpch_15()\ntpch_16()\ntpch_17()\ntpch_18()\ntpch_19()\ntpch_20()\ntpch_21()\ntpch_22()\n```\n\n----------------------------------------\n\nTITLE: Aggregating DuckDB Relations with Group By\nDESCRIPTION: Shows how to use rel_to_df() with grouped data to compute aggregations like mean bill length by species.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/relational-duckdb.md#2025-04-21_snippet_2\n\nLANGUAGE: r\nCODE:\n```\ngrouped %>% rel_to_df(prudence = \"lavish\") %>% arrange(species)\n```\n\n----------------------------------------\n\nTITLE: Setting Filter Function Preference with conflicted Package\nDESCRIPTION: Code to explicitly set preference for the filter function from dplyr when conflicts arise. This ensures that the correct version of filter is used in case of naming conflicts with other packages.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/index.md#2025-04-21_snippet_4\n\nLANGUAGE: r\nCODE:\n```\nconflict_prefer(\"filter\", \"dplyr\")\n#> [1m[22m[90m[conflicted][39m Will prefer [1m[34mdplyr[39m[22m::filter\n#> over any other package.\n```\n\n----------------------------------------\n\nTITLE: Testing duckplyr_expand_across with Selective Column Operations in R\nDESCRIPTION: This snippet tests the duckplyr_expand_across function using across() to perform operations on specific columns. It shows how to select certain columns for processing within across().\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/duckplyr-across.md#2025-04-21_snippet_5\n\nLANGUAGE: R\nCODE:\n```\ntest_duckplyr_expand_across(c(\"x\", \"y\", \"a\"), across(c(a, x), function(x) x + 1))\n```\n\n----------------------------------------\n\nTITLE: Restoring Original dplyr Methods after Using duckplyr\nDESCRIPTION: Code to restore the original dplyr methods after using duckplyr. This function reverts all method overrides, returning the R session to standard dplyr functionality.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/index.md#2025-04-21_snippet_11\n\nLANGUAGE: r\nCODE:\n```\nduckplyr::methods_restore()\n#> [1m[22m[36mℹ[39m Restoring [34mdplyr[39m methods.\n```\n\n----------------------------------------\n\nTITLE: Testing Error Messages for Invalid Inputs in R Join Operations\nDESCRIPTION: This snippet tests various error messages produced by join_cols() function for invalid inputs, including non-unique columns, NA values, and missing columns.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-join-cols.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\njoin_cols(c(\"x\", \"y\"), c(\"y\", \"y\"), join_by(y))\n\njoin_cols(c(\"y\", \"y\"), c(\"x\", \"y\"), join_by(y))\n\njoin_cols(xy, xy, by = as_join_by(list(\"1\", y = \"2\")))\n\njoin_cols(xy, xy, by = as_join_by(list(x = \"1\", \"2\")))\n\njoin_cols(xy, xy, by = as_join_by(c(\"x\", NA)))\n\njoin_cols(xy, xy, by = as_join_by(c(\"aaa\", \"bbb\")))\n\njoin_cols(xy, xy, by = as_join_by(c(\"x\", \"x\", \"x\")))\n\njoin_cols(xyz, xyz, by = join_by(x, x > y, z))\n\njoin_cols(xy, xy, by = join_by(x), suffix = \"x\")\n\njoin_cols(xy, xy, by = join_by(x), suffix = c(\"\", NA))\n```\n\n----------------------------------------\n\nTITLE: Calculating Group Sizes for Data Frames in R\nDESCRIPTION: This function calculates the size of each group in a data frame. It uses the `group_rows` function to get the rows for each group, then applies the `lengths` function to count the number of rows in each group.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/group_size.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\ngroup_size.data.frame <- function(x) {\n  lengths(group_rows(x))\n}\n```\n\n----------------------------------------\n\nTITLE: Joining dataframes using IS NOT DISTINCT FROM in R\nDESCRIPTION: Performance improvement for joining dataframes using IS NOT DISTINCT FROM for faster execution.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/NEWS.md#2025-04-21_snippet_8\n\nLANGUAGE: R\nCODE:\n```\nleft_join(df1, df2, by = c(\"id\" = \"id\"))\n```\n\n----------------------------------------\n\nTITLE: Testing full_join with duckplyr in R\nDESCRIPTION: Demonstrates full_join operations using duckplyr, expecting errors with telemetry data. Tests include default join and join with various options like copying, suffixes, and relationship specification.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/telemetry.md#2025-04-21_snippet_5\n\nLANGUAGE: R\nCODE:\n```\nduckdb_tibble(a = 1:3, b = 4:6) %>% full_join(tibble(a = 1:3, b = 4:6))\n```\n\nLANGUAGE: R\nCODE:\n```\nduckdb_tibble(a = 1:3, b = 4:6) %>% full_join(tibble(a = 1:3, b = 4:6), by = \"a\", copy = TRUE, suffix = c(\"x\", \"y\"), keep = TRUE, na_matches = \"na\", multiple = \"all\", relationship = \"one-to-one\")\n```\n\n----------------------------------------\n\nTITLE: Testing as_join_by() Function in R\nDESCRIPTION: This snippet tests the as_join_by() function, which is used to convert various inputs into a join specification.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-join-by.md#2025-04-21_snippet_5\n\nLANGUAGE: R\nCODE:\n```\nas_join_by(FALSE)\n```\n\n----------------------------------------\n\nTITLE: Testing anti_join with duckplyr in R\nDESCRIPTION: Demonstrates various anti_join operations using duckplyr, expecting errors with telemetry data. Tests include default join, join by column, join with named columns, and join with custom conditions.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/telemetry.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nduckdb_tibble(a = 1:3, b = 4:6) %>% anti_join(tibble(a = 1:3, b = 4:6))\n```\n\nLANGUAGE: R\nCODE:\n```\nduckdb_tibble(a = 1:3, b = 4:6) %>% anti_join(tibble(a = 1:3, b = 4:6), by = \"a\", copy = FALSE, na_matches = \"na\")\n```\n\nLANGUAGE: R\nCODE:\n```\nduckdb_tibble(a = 1:3, b = 4:6) %>% anti_join(tibble(a = 1:3, b = 4:6), by = c(a = \"b\"), copy = FALSE, na_matches = \"na\")\n```\n\nLANGUAGE: R\nCODE:\n```\nduckdb_tibble(a = 1:3, b = 4:6) %>% anti_join(tibble(a = 1:3, b = 4:6), by = join_by(a == b), copy = FALSE, na_matches = \"never\")\n```\n\n----------------------------------------\n\nTITLE: Writing dataframe to Parquet file in R\nDESCRIPTION: New df_to_parquet() function to write a dataframe to a Parquet file format.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/NEWS.md#2025-04-21_snippet_4\n\nLANGUAGE: R\nCODE:\n```\ndf_to_parquet(dataframe, \"output.parquet\")\n```\n\n----------------------------------------\n\nTITLE: Testing duckplyr_expand_across with Column Exclusion in R\nDESCRIPTION: This snippet tests the duckplyr_expand_across function using across() to exclude specific columns. It shows how to use the minus sign to exclude columns from processing.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/duckplyr-across.md#2025-04-21_snippet_7\n\nLANGUAGE: R\nCODE:\n```\ntest_duckplyr_expand_across(c(\"x\", \"y\", \"a\"), across(-a, function(x) x * x))\n```\n\n----------------------------------------\n\nTITLE: Nesting Data Frames with Group-By in R\nDESCRIPTION: This function groups a data frame by specified columns and then nests the resulting groups. It uses the `group_by` function from tidyverse and then calls `nest_by.grouped_df`. The function allows specifying the key for the nested data and whether to keep the grouping columns.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/nest_by.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nnest_by.data.frame <- function(.data, ..., .key = \"data\", .keep = FALSE) {\n  .data <- group_by(.data, ...)\n  nest_by.grouped_df(.data, .key = .key, .keep = .keep)\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Error When Using Invalid Weights with sample_n() on Grouped Data\nDESCRIPTION: This snippet tests the error message when sample_n() is called on grouped data with invalid weights. It creates a grouped tibble and attempts to sample with weights containing zeros, which causes an error due to too few positive probabilities.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-sample.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\ndf2 <- tibble(x = rep(1:2, 100), y = rep(c(0, 1), 100), g = rep(1:2, each = 100))\ngrp <- df2 %>% duckplyr_group_by(g)\n(expect_error(sample_n(grp, nrow(df2) / 2, weight = y)))\n```\n\n----------------------------------------\n\nTITLE: Using deprecated multiple='warning' parameter with duckplyr_left_join function in R\nDESCRIPTION: Example showing deprecation warning when using 'multiple = \"warning\"' with the duckplyr_left_join function. This parameter has been deprecated in dplyr 1.1.1 in favor of 'relationship = \"many-to-one\"'. The code generates a warning but completes the join when a row in x matches multiple rows in y.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-join-rows.md#2025-04-21_snippet_15\n\nLANGUAGE: r\nCODE:\n```\nduckplyr_left_join(df1, df2, by = join_by(x), multiple = \"warning\")\n```\n\n----------------------------------------\n\nTITLE: Testing Multiple Group Columns in duckplyr_reframe()\nDESCRIPTION: Demonstrates usage of duckplyr_reframe() with multiple grouping columns. Tests that the function doesn't message about regrouping when multiple group columns are used.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-reframe.md#2025-04-21_snippet_2\n\nLANGUAGE: r\nCODE:\n```\nout <- duckplyr_reframe(df, x = mean(x), .by = c(a, b))\n```\n\n----------------------------------------\n\nTITLE: Testing filter with duckplyr in R\nDESCRIPTION: Demonstrates filter operations using duckplyr, expecting errors with telemetry data. Tests include simple filter, filter with grouping, and filter with preserve option.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/telemetry.md#2025-04-21_snippet_4\n\nLANGUAGE: R\nCODE:\n```\nduckdb_tibble(a = 1:3, b = 4:6) %>% filter(a > 1)\n```\n\nLANGUAGE: R\nCODE:\n```\nduckdb_tibble(a = 1:3, b = 4:6) %>% filter(a > 1, .by = b)\n```\n\nLANGUAGE: R\nCODE:\n```\nduckdb_tibble(a = 1:3, b = 4:6) %>% filter(a > 1, .preserve = TRUE)\n```\n\n----------------------------------------\n\nTITLE: Implementing select() for data.frame Objects in R\nDESCRIPTION: Function that handles column selection for data frames using tidyselect evaluation. It evaluates selection expressions, ensures group variables are preserved, and manages column names in the output. The function relies on tidyselect::eval_select for processing selection syntax and includes error handling.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/select.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nselect.data.frame <- function(.data, ...) {\n  error_call <- dplyr_error_call()\n\n  loc <- tidyselect::eval_select(\n    expr(c(...)),\n    data = .data,\n    error_call = error_call\n  )\n  loc <- ensure_group_vars(loc, .data, notify = TRUE)\n\n  out <- dplyr_col_select(.data, loc)\n  out <- set_names(out, names(loc))\n\n  out\n}\n```\n\n----------------------------------------\n\nTITLE: Testing rel_try() Function with Reason in R\nDESCRIPTION: This code tests the rel_try() function with a NULL input and two named parameters for success and failure cases. It demonstrates how the function handles failure, falls back to dplyr, and returns a specific message.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/relational.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nrel_try(NULL, `Not affected: {.code FALSE}` = FALSE, `Affected: {.code TRUE}` = TRUE,\n  { })\n```\n\n----------------------------------------\n\nTITLE: Testing Basic join_by() Usage in R\nDESCRIPTION: This snippet tests basic usage of join_by() function, including empty input, single column joins, and string column names.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-join-by.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\njoin_by()\njoin_by(a, b)\njoin_by(\"a\", \"b\")\n```\n\n----------------------------------------\n\nTITLE: Testing grouped_df() helper function error messages in R\nDESCRIPTION: Test cases for the grouped_df() helper function to ensure it gives meaningful error messages when attempting to group data frames with non-existent variables or when passing invalid arguments.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-grouped-df.md#2025-04-21_snippet_1\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(grouped_df(data.frame(x = 1), \"y\", FALSE)))\n```\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(grouped_df(data.frame(x = 1), 1)))\n```\n\n----------------------------------------\n\nTITLE: Testing duckplyr_expand_across with Named Columns in R\nDESCRIPTION: This snippet tests the duckplyr_expand_across function using across() with named columns. It demonstrates how to rename columns when using across() within the function.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/duckplyr-across.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\ntest_duckplyr_expand_across(c(\"x\", \"y\"), across(c(x_mean = x, y_mean = y), mean))\n```\n\n----------------------------------------\n\nTITLE: Implementing rows_delete.data.frame Function in R\nDESCRIPTION: This function removes rows from data frame x that match with rows in data frame y based on specified key columns. It handles automatic copying of data frames, validates matching columns, and supports different behaviors for unmatched rows through the 'unmatched' parameter. The function can operate either in-place or return a new data frame.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/rows_delete.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nrows_delete.data.frame <- function(x,\n                                   y,\n                                   by = NULL,\n                                   ...,\n                                   unmatched = c(\"error\", \"ignore\"),\n                                   copy = FALSE,\n                                   in_place = FALSE) {\n  check_dots_empty()\n  rows_df_in_place(in_place)\n\n  y <- auto_copy(x, y, copy = copy)\n\n  by <- rows_check_by(by, y)\n\n  rows_check_contains_by(x, by, \"x\")\n  rows_check_contains_by(y, by, \"y\")\n\n  x_key <- dplyr_col_select(x, by)\n  y_key <- dplyr_col_select(y, by)\n\n  args <- vec_cast_common(x = x_key, y = y_key)\n  x_key <- args$x\n  y_key <- args$y\n\n  keep <- rows_check_y_unmatched(x_key, y_key, unmatched)\n\n  if (!is.null(keep)) {\n    y_key <- dplyr_row_slice(y_key, keep)\n  }\n\n  extra <- setdiff(names(y), names(y_key))\n  if (!is_empty(extra)) {\n    message <- glue(\"Ignoring extra `y` columns: \", commas(tick_if_needed(extra)))\n    inform(message, class = c(\"dplyr_message_delete_extra_cols\", \"dplyr_message\"))\n  }\n\n  loc <- vec_match(x_key, y_key)\n  unmatched <- is.na(loc)\n\n  x_loc <- which(unmatched)\n\n  dplyr_row_slice(x, x_loc)\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Deprecated Non-Summary Results in duckplyr_summarise (R)\nDESCRIPTION: This snippet tests the behavior of duckplyr_summarise when returning non-summary results. It expects a deprecation warning suggesting the use of duckplyr_reframe instead.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-summarise.md#2025-04-21_snippet_3\n\nLANGUAGE: R\nCODE:\n```\nout <- duckplyr_summarise(df, x = which(x < 3))\n```\n\n----------------------------------------\n\nTITLE: Implementing ungroup.data.frame function in R\nDESCRIPTION: A function that removes grouping from a data frame. It takes a data frame parameter 'x' and additional arguments via '...', checks that no additional arguments are provided using check_dots_empty(), and returns the original data frame unmodified.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/ungroup.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nungroup.data.frame <- function(x, ...) {\n  check_dots_empty()\n  x\n}\n```\n\n----------------------------------------\n\nTITLE: Join By Common Columns - Standard Names\nDESCRIPTION: Demonstrates joining tables using common column names 'x' and 'y'. The function outputs a message confirming the join columns.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-join-by.md#2025-04-21_snippet_6\n\nLANGUAGE: r\nCODE:\n```\nby <- join_by_common(c(\"x\", \"y\"), c(\"x\", \"y\"))\n```\n\n----------------------------------------\n\nTITLE: Implementing summarise.data.frame Function in R for dplyr\nDESCRIPTION: This function implements the summarise operation for data frames in dplyr. It processes grouping variables via the .by parameter, evaluates summarization expressions, and builds the output data frame with appropriate structure. The function also handles output format preservation and supports transitioning to rowwise data when specified.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/summarise.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nsummarise.data.frame <- function(.data, ..., .by = NULL, .groups = NULL) {\n  by <- compute_by({{ .by }}, .data, by_arg = \".by\", data_arg = \".data\")\n\n  cols <- summarise_cols(.data, dplyr_quosures(...), by, \"summarise\")\n  out <- summarise_build(by, cols)\n\n  if (!cols$all_one) {\n    summarise_deprecate_variable_size()\n  }\n\n  if (!is_tibble(.data)) {\n    # The `by` group data we build from is always a tibble,\n    # so we have to manually downcast as needed\n    out <- as.data.frame(out)\n  }\n\n  if (identical(.groups, \"rowwise\")) {\n    out <- rowwise_df(out, character())\n  }\n\n  out\n}\n```\n\n----------------------------------------\n\nTITLE: Column Binding with Name Repair in R\nDESCRIPTION: Demonstrates how bind_cols() handles duplicate column names by automatically repairing them with numbered suffixes.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-bind-cols.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\nbound <- bind_cols(df, df)\n```\n\n----------------------------------------\n\nTITLE: Testing Error Handling in duckplyr_filter Function\nDESCRIPTION: This code shows the error handling in duckplyr_filter when an undefined function is used. The error message remains consistent with all the previous duckplyr function tests.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-conditions.md#2025-04-21_snippet_4\n\nLANGUAGE: R\nCODE:\n```\nduckplyr_filter(mtcars, !!foobarbaz())\n```\n\n----------------------------------------\n\nTITLE: Testing Rename Restrictions in DuckplyrRenameWith\nDESCRIPTION: Tests error handling when attempting to rename variables in the .cols parameter\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-rename.md#2025-04-21_snippet_2\n\nLANGUAGE: r\nCODE:\n```\nduckplyr_rename_with(df, toupper, .cols = c(y = x))\n```\n\n----------------------------------------\n\nTITLE: Setting up DuckDB httpfs Extension\nDESCRIPTION: Installs and loads the httpfs extension in DuckDB to enable direct querying of remote Parquet files without downloading them first.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/README.md#2025-04-21_snippet_10\n\nLANGUAGE: r\nCODE:\n```\ndb_exec(\"INSTALL httpfs\")\ndb_exec(\"LOAD httpfs\")\n\nflights <- read_parquet_duckdb(urls)\n```\n\n----------------------------------------\n\nTITLE: Testing Deprecated Non-Summary Results with Grouping in duckplyr_summarise (R)\nDESCRIPTION: This snippet tests the behavior of duckplyr_summarise when returning non-summary results with grouping. It expects a deprecation warning suggesting the use of duckplyr_reframe instead.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-summarise.md#2025-04-21_snippet_4\n\nLANGUAGE: R\nCODE:\n```\nout <- duckplyr_summarise(df, x = which(x < 3), .by = g)\n```\n\n----------------------------------------\n\nTITLE: Restoring Original dplyr Methods in R\nDESCRIPTION: Demonstrates how to revert to the default dplyr implementation using the methods_restore() function from duckplyr.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/README.md#2025-04-21_snippet_8\n\nLANGUAGE: R\nCODE:\n```\nduckplyr::methods_restore()\n#> ℹ Restoring dplyr methods.\n```\n\n----------------------------------------\n\nTITLE: Testing duckplyr_expand_across with Base R Function in R\nDESCRIPTION: This snippet tests the duckplyr_expand_across function using across() with a base R function. It demonstrates how to use fully qualified function names within across().\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/duckplyr-across.md#2025-04-21_snippet_8\n\nLANGUAGE: R\nCODE:\n```\ntest_duckplyr_expand_across(c(\"x\", \"y\"), across(x:y, base::mean))\n```\n\n----------------------------------------\n\nTITLE: Implementing group_by Function for Data Frames in R\nDESCRIPTION: This function implements the group_by operation for data frames in R. It prepares the grouping using a helper function, then creates and returns a grouped data frame object. The function allows for adding to existing groups and specifies whether to drop empty groups.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/group_by.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\ngroup_by.data.frame <- function(.data, ..., .add = FALSE, .drop = group_by_drop_default(.data)) {\n  groups <- group_by_prepare(\n    .data,\n    ...,\n    .add = .add,\n    error_call = current_env()\n  )\n  grouped_df(groups$data, groups$group_names, .drop)\n}\n```\n\n----------------------------------------\n\nTITLE: Examining Basic DuckDB Relation Tree\nDESCRIPTION: Shows the simplified relation tree when converting a standard dataframe to a DuckDB relation.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/relational-duckdb.md#2025-04-21_snippet_6\n\nLANGUAGE: r\nCODE:\n```\nduckdb_rel_from_df(df)\n```\n\n----------------------------------------\n\nTITLE: Testing Formula Evaluation Errors\nDESCRIPTION: Tests how case_match() handles errors that occur during the evaluation of formulas, including both left-hand and right-hand side errors.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-case-match.md#2025-04-21_snippet_3\n\nLANGUAGE: r\nCODE:\n```\ncase_match(1, 1 ~ 2, 3 ~ stop(\"oh no!\"))\n```\n\nLANGUAGE: r\nCODE:\n```\ncase_match(1, 1 ~ 2, stop(\"oh no!\") ~ 4)\n```\n\n----------------------------------------\n\nTITLE: Testing Recycling Rules in consecutive_id Function in R\nDESCRIPTION: This code tests the error handling when vectors of different lengths are passed to consecutive_id. It verifies that the function correctly identifies and reports size mismatches between arguments.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-consecutive-id.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\nconsecutive_id(1:3, 1:4)\n```\n\n----------------------------------------\n\nTITLE: Testing join_rows() with many-to-many relationship warning in R\nDESCRIPTION: This snippet tests the join_rows() function with a many-to-many relationship, expecting a warning about the unexpected relationship.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-join-rows.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nout <- join_rows(c(1, 1), c(1, 1), condition = \"==\")\n```\n\n----------------------------------------\n\nTITLE: Implementing group_modify Function for Data Frames in R\nDESCRIPTION: This function applies a given function to grouped data frames. It handles a deprecated 'keep' argument, converts the input function to a group map function, and applies it to the data and group keys. The function is likely part of duckplyr, a package in the tidyverse ecosystem.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/group_modify.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\ngroup_modify.data.frame <- function(.data, .f, ..., .keep = FALSE, keep = deprecated()) {\n  if (!missing(keep)) {\n    lifecycle::deprecate_warn(\"1.0.0\", \"group_modify(keep = )\", \"group_modify(.keep = )\", always = TRUE)\n    .keep <- keep\n  }\n  .f <- as_group_map_function(.f)\n  .f(.data, group_keys(.data), ...)\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Error Chaining in case_when() Function (R)\nDESCRIPTION: These snippets verify that case_when() correctly chains and reports errors when formula evaluation fails, providing informative error messages.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-case-when.md#2025-04-21_snippet_5\n\nLANGUAGE: R\nCODE:\n```\ncase_when(1 ~ 2, 3 ~ stop(\"oh no!\"))\n```\n\nLANGUAGE: R\nCODE:\n```\ncase_when(1 ~ 2, stop(\"oh no!\") ~ 4)\n```\n\n----------------------------------------\n\nTITLE: Testing transmute with DuckPlyr\nDESCRIPTION: Testing transmute operation to create new columns based on calculations\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/telemetry.md#2025-04-21_snippet_18\n\nLANGUAGE: R\nCODE:\n```\nduckdb_tibble(a = 1:3, b = 4:6) %>% transmute(c = a + b)\n```\n\n----------------------------------------\n\nTITLE: Testing Sum Aggregation in R\nDESCRIPTION: Tests the rel_translate() function with sum() operation using different parameter combinations and validates error handling\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/translate.md#2025-04-21_snippet_6\n\nLANGUAGE: R\nCODE:\n```\nrel_translate(expr(sum(a)), df)\nrel_translate(expr(sum(a, b)), df)\nrel_translate(expr(sum(a, na.rm = TRUE)), df)\nrel_translate(expr(sum(a, na.rm = FALSE)), df)\n```\n\n----------------------------------------\n\nTITLE: Triggering Computation in duckplyr with Column Access\nDESCRIPTION: Code showing how to trigger computation in duckplyr by querying a column. This demonstrates duckplyr's lazy evaluation strategy, where computation only happens when results are needed.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/index.md#2025-04-21_snippet_8\n\nLANGUAGE: r\nCODE:\n```\nout$month\n#> [1] 1 2 3 4 5 6\n```\n\n----------------------------------------\n\nTITLE: Using as_duckdb_tibble() with grouped data frames in R\nDESCRIPTION: Demonstrates the error when trying to convert a grouped data frame to a DuckDB-backed tibble. The error suggests using the .by syntax instead of group_by() or converting to a regular tibble first.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/ducktbl.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\nas_duckdb_tibble(dplyr::group_by(mtcars, cyl))\n```\n\n----------------------------------------\n\nTITLE: Testing NULL Values in Formula Components\nDESCRIPTION: Tests error handling when NULL is used as either the left-hand or right-hand side of a formula in case_match().\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-case-match.md#2025-04-21_snippet_2\n\nLANGUAGE: r\nCODE:\n```\ncase_match(1, 1 ~ NULL)\n```\n\nLANGUAGE: r\nCODE:\n```\ncase_match(1, NULL ~ 1)\n```\n\n----------------------------------------\n\nTITLE: Testing Name Parameter Validation in duckplyr_count\nDESCRIPTION: Demonstrates error handling when invalid name parameters are provided to duckplyr_count(). Shows that the name parameter must be a single string.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-count-tally.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\nduckplyr_count(df, x, name = 1)\nduckplyr_count(df, x, name = letters)\n```\n\n----------------------------------------\n\nTITLE: Testing NULL Handling in case_when() Function (R)\nDESCRIPTION: These snippets check how case_when() handles NULL values in both the left-hand and right-hand sides of formulas, ensuring proper error messages.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-case-when.md#2025-04-21_snippet_4\n\nLANGUAGE: R\nCODE:\n```\ncase_when(1 ~ NULL)\n```\n\nLANGUAGE: R\nCODE:\n```\ncase_when(NULL ~ 1)\n```\n\n----------------------------------------\n\nTITLE: Testing select with DuckPlyr\nDESCRIPTION: Testing select operation to rename columns in duckdb_tibble\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/telemetry.md#2025-04-21_snippet_13\n\nLANGUAGE: R\nCODE:\n```\nduckdb_tibble(a = 1:3, b = 4:6) %>% select(c = b)\n```\n\n----------------------------------------\n\nTITLE: Testing Min/Max Aggregation in R\nDESCRIPTION: Validates min() and max() operations with rel_translate(), including NA handling options\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/translate.md#2025-04-21_snippet_7\n\nLANGUAGE: R\nCODE:\n```\nrel_translate(expr(min(a)), df)\nrel_translate(expr(min(a, na.rm = TRUE)), df)\nrel_translate(expr(max(a)), df)\nrel_translate(expr(max(a, na.rm = TRUE)), df)\n```\n\n----------------------------------------\n\nTITLE: Examining DuckDB Relation Tree with Filter Predicate\nDESCRIPTION: Shows how duckdb_rel_from_df() creates a relation with filters and projections when the dataframe has been filtered.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/relational-duckdb.md#2025-04-21_snippet_4\n\nLANGUAGE: r\nCODE:\n```\nduckdb_rel_from_df(df)\n```\n\n----------------------------------------\n\nTITLE: Testing Type Compatibility with .default Parameter\nDESCRIPTION: Tests error handling when the .default parameter type is incompatible with the other conditions' return types.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-case-match.md#2025-04-21_snippet_1\n\nLANGUAGE: r\nCODE:\n```\ncase_match(1, 1 ~ 1L, .default = \"x\")\n```\n\n----------------------------------------\n\nTITLE: Testing Vector Recycling in Between Function (R)\nDESCRIPTION: These test cases verify that the 'between()' function correctly enforces vector recycling rules, throwing errors when 'left' or 'right' arguments can't be recycled to match the size of 'x'.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-funs.md#2025-04-21_snippet_1\n\nLANGUAGE: r\nCODE:\n```\nbetween(1:3, 1:2, 1L)\n```\n\nLANGUAGE: r\nCODE:\n```\nbetween(1:3, 1L, 1:2)\n```\n\n----------------------------------------\n\nTITLE: Testing Parameter Typo Detection in duckplyr_filter()\nDESCRIPTION: Tests that duckplyr_filter() correctly catches the common typo of using 'by' instead of '.by'. The function provides a helpful error message suggesting the correct parameter name.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-filter.md#2025-04-21_snippet_4\n\nLANGUAGE: r\nCODE:\n```\nduckplyr_filter(df, by = x)\n```\n\n----------------------------------------\n\nTITLE: Creating DuckDB Relation from Dataframe in R\nDESCRIPTION: This code snippet uses the duckdb_rel_from_df() function to create a DuckDB relation from a dataframe named 'out'. The output shows the structure of the resulting relation, including the relation tree and the result columns.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/compute.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nduckdb_rel_from_df(out)\n```\n\n----------------------------------------\n\nTITLE: Testing Error Handling for Function Failure in duckplyr_summarise with across()\nDESCRIPTION: These snippets test error handling when a function fails during expansion in `across()` within `duckplyr_summarise()`.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-across.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\nduckplyr_summarise(df, across(everything(), fn()))\n```\n\nLANGUAGE: R\nCODE:\n```\nduckplyr_summarise(df, across(everything(), fn()), .by = g)\n```\n\n----------------------------------------\n\nTITLE: Testing count with duckplyr in R\nDESCRIPTION: Demonstrates count operations using duckplyr, expecting errors with telemetry data. Tests include simple count and count with additional options like weighting and sorting.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/telemetry.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\nduckdb_tibble(a = 1:3, b = 4:6) %>% count(a)\n```\n\nLANGUAGE: R\nCODE:\n```\nduckdb_tibble(a = 1:3, b = 4:6) %>% count(a, wt = b, sort = TRUE, name = \"nn\", .drop = FALSE)\n```\n\n----------------------------------------\n\nTITLE: Testing Column Overwriting with Grouping in DuckPlyr Mutate (R)\nDESCRIPTION: This snippet extends the previous test by including a grouping variable. It shows that attempting to overwrite a column's value within a grouped operation also results in an error.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-mutate.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\nduckplyr_mutate(df, .by = g, y = {\n  x <<- 2\n  x\n})\n```\n\n----------------------------------------\n\nTITLE: Testing Multiple Row Output in duckplyr_reframe()\nDESCRIPTION: Shows how duckplyr_reframe() handles cases where multiple rows are returned per group. Verifies that no regrouping message is displayed when returning multiple rows.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-reframe.md#2025-04-21_snippet_3\n\nLANGUAGE: r\nCODE:\n```\nout <- duckplyr_reframe(df, x = vec_rep_each(x, x), .by = g)\n```\n\n----------------------------------------\n\nTITLE: Testing .default Behavior in case_when() Function (R)\nDESCRIPTION: This snippet tests the behavior of the .default parameter in case_when(). It checks that .default is not part of recycling and must have size 1.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-case-when.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\ncase_when(FALSE ~ 1L, .default = 2:5)\n```\n\n----------------------------------------\n\nTITLE: Testing Size Override in if_else() Function in R\nDESCRIPTION: This test case checks the 'size' parameter in if_else(), which overrides the 'condition' size. It demonstrates that the condition must match the specified size.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-if-else.md#2025-04-21_snippet_6\n\nLANGUAGE: R\nCODE:\n```\nif_else(TRUE, 1, 2, size = 2)\n```\n\n----------------------------------------\n\nTITLE: Testing duckplyr_expand_across with Simple Across Usage in R\nDESCRIPTION: This snippet tests the duckplyr_expand_across function using across() with a simple mean calculation on columns x and y. It demonstrates the basic usage of across() within the function.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/duckplyr-across.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\ntest_duckplyr_expand_across(c(\"x\", \"y\"), across(x:y, mean))\n```\n\n----------------------------------------\n\nTITLE: Testing rows_check_contains_by() for Missing Columns in R\nDESCRIPTION: Tests the rows_check_contains_by() function to verify it correctly reports errors when specified 'by' columns are missing from a dataframe. The function checks if columns referenced in the 'by' parameter exist in the source dataframes.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-rows.md#2025-04-21_snippet_22\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(rows_check_contains_by(x, \"y\", arg = \"x\")))\n```\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(rows_check_contains_by(x, c(\"y\", \"x\", \"z\"), arg = \"y\")))\n```\n\n----------------------------------------\n\nTITLE: Testing rows_check_unique() for Duplicate Key Values in R\nDESCRIPTION: Tests the rows_check_unique() function to verify it correctly reports errors when key columns contain duplicate values. The function ensures that specified key columns maintain uniqueness across rows.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-rows.md#2025-04-21_snippet_23\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(rows_check_unique(x[\"x\"], \"x\")))\n```\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(rows_check_unique(x[c(\"x\", \"y\")], \"y\")))\n```\n\n----------------------------------------\n\nTITLE: Testing rename with duckplyr in R\nDESCRIPTION: Demonstrates rename operation using duckplyr, expecting an error with telemetry data.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/telemetry.md#2025-04-21_snippet_11\n\nLANGUAGE: R\nCODE:\n```\nduckdb_tibble(a = 1:3, b = 4:6) %>% rename(c = a)\n```\n\n----------------------------------------\n\nTITLE: Collecting telemetry data in duckplyr for R\nDESCRIPTION: New fallback_sitrep() function for collecting telemetry data. No data is collected by default, only a message is displayed once per session and then every eight hours.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/NEWS.md#2025-04-21_snippet_7\n\nLANGUAGE: R\nCODE:\n```\nfallback_sitrep()\n```\n\n----------------------------------------\n\nTITLE: Testing Missing Row Equality\nDESCRIPTION: Verifies that data frames with different numbers of rows are not considered equal by comparing original dataframes with versions missing one row.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-all-equal.md#2025-04-21_snippet_1\n\nLANGUAGE: r\nCODE:\n```\nall_equal(mtcars, mtcars[-1, ])\nall_equal(iris, iris[-1, ])\nall_equal(df_all, df_all[-1, ])\n```\n\n----------------------------------------\n\nTITLE: Testing Deprecated across() Dot Notation\nDESCRIPTION: Shows that using across() with arguments passed via dots is deprecated as of dplyr 1.1.0, with a detailed warning message suggesting the use of anonymous functions instead.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-across.md#2025-04-21_snippet_13\n\nLANGUAGE: r\nCODE:\n```\nduckplyr_summarise(df, across(everything(), mean, na.rm = TRUE))\n```\n\n----------------------------------------\n\nTITLE: Validating Empty Dots in if_else() Function in R\nDESCRIPTION: This test case ensures that the if_else() function doesn't accept any additional unnamed arguments. It demonstrates that providing extra arguments results in an error.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-if-else.md#2025-04-21_snippet_4\n\nLANGUAGE: R\nCODE:\n```\nif_else(TRUE, 1, 2, missing = 3, 4)\n```\n\n----------------------------------------\n\nTITLE: Testing distinct() with multiple unknown columns\nDESCRIPTION: This test attempts to call distinct() with two non-existent columns 'aa' and 'bb', verifying that the error message lists both missing columns in the output.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-distinct.md#2025-04-21_snippet_1\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(df %>% duckplyr_distinct(aa, bb)))\n```\n\n----------------------------------------\n\nTITLE: Testing duckplyr_expand_across with Function Arguments in R\nDESCRIPTION: This snippet tests the duckplyr_expand_across function using across() with a custom function that includes additional arguments. It demonstrates how to pass arguments to functions used within across().\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/duckplyr-across.md#2025-04-21_snippet_4\n\nLANGUAGE: R\nCODE:\n```\ntest_duckplyr_expand_across(c(\"x\", \"y\"), across(x:y, function(x) mean(x, na.rm = TRUE)))\n```\n\n----------------------------------------\n\nTITLE: Validating Type Casting in duckplyr_rows_insert\nDESCRIPTION: This snippet tests the error handling when attempting to insert rows with incompatible data types. It checks for proper error messages when casting keys and values fails due to precision loss.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-rows.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(duckplyr_rows_insert(x, y, \"key\")))\n```\n\n----------------------------------------\n\nTITLE: Testing Key Existence Validation in duckplyr_rows_delete\nDESCRIPTION: This snippet checks if duckplyr_rows_delete correctly validates that keys in the source dataframe exist in the target dataframe by default.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-rows.md#2025-04-21_snippet_16\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(duckplyr_rows_delete(x, y, \"a\")))\n```\n\n----------------------------------------\n\nTITLE: Testing Type Computation with .default in case_when() Function (R)\nDESCRIPTION: This snippet verifies that .default is included in common type computation, ensuring type consistency across all arguments.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-case-when.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\ncase_when(TRUE ~ 1L, .default = \"x\")\n```\n\n----------------------------------------\n\nTITLE: Renaming DataFrame Columns with tidyselect in R\nDESCRIPTION: Function that renames columns in a data.frame using tidyselect's eval_rename. Takes a data.frame and name-value pairs for renaming, evaluates the renaming expressions, and returns the data.frame with updated column names.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/rename.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nrename.data.frame <- function(.data, ...) {\n  loc <- tidyselect::eval_rename(expr(c(...)), .data)\n  # eval_rename() only returns changes\n  names <- names(.data)\n  names[loc] <- names(loc)\n\n  set_names(.data, names)\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Local Variable Sharing in DuckPlyr Mutate (R)\nDESCRIPTION: This snippet tests the behavior of duckplyr_mutate when attempting to share local variables across multiple expressions. It demonstrates that variables defined in one expression are not accessible in subsequent expressions, resulting in an error.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-mutate.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\nduckplyr_mutate(df, x2 = {\n  foo <- x\n  x\n}, y2 = {\n  foo\n})\n```\n\n----------------------------------------\n\nTITLE: Testing across() with Default .cols Warning\nDESCRIPTION: Shows that using across() without explicitly supplying .cols triggers a deprecation warning, as the default value of everything() is deprecated since dplyr 1.1.0.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-across.md#2025-04-21_snippet_10\n\nLANGUAGE: r\nCODE:\n```\nout <- duckplyr_mutate(df, across(.fns = times_two))\n```\n\n----------------------------------------\n\nTITLE: Testing Recycling Rules in if_else() Function in R\nDESCRIPTION: These snippets test the recycling rules for 'true', 'false', and 'missing' parameters in if_else(). They show that these parameters must be able to recycle to the size of the 'condition' parameter.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-if-else.md#2025-04-21_snippet_3\n\nLANGUAGE: R\nCODE:\n```\nif_else(x < 2, bad, x)\n```\n\nLANGUAGE: R\nCODE:\n```\nif_else(x < 2, x, bad)\n```\n\nLANGUAGE: R\nCODE:\n```\nif_else(x < 2, x, x, missing = bad)\n```\n\n----------------------------------------\n\nTITLE: Validating Key Uniqueness in duckplyr_rows_update\nDESCRIPTION: This snippet tests if duckplyr_rows_update correctly handles and reports errors for duplicate keys in the source dataframe.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-rows.md#2025-04-21_snippet_7\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(duckplyr_rows_update(x, y, by = \"a\")))\n```\n\n----------------------------------------\n\nTITLE: Testing DuckPLYR Configuration Management\nDESCRIPTION: Tests for configuration management including loading, resetting, and handling configuration conflicts.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/fallback.md#2025-04-21_snippet_4\n\nLANGUAGE: R\nCODE:\n```\nfallback_config(reset_all = TRUE, logging = FALSE)\n```\n\nLANGUAGE: R\nCODE:\n```\nfallback_config_load()\n```\n\n----------------------------------------\n\nTITLE: Testing semi_join with DuckPlyr\nDESCRIPTION: Testing semi join operation between duckdb_tibble and regular tibble with different parameters\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/telemetry.md#2025-04-21_snippet_14\n\nLANGUAGE: R\nCODE:\n```\nduckdb_tibble(a = 1:3, b = 4:6) %>% semi_join(tibble(a = 1:3, b = 4:6))\n```\n\nLANGUAGE: R\nCODE:\n```\nduckdb_tibble(a = 1:3, b = 4:6) %>% semi_join(tibble(a = 1:3, b = 4:6), by = \"a\", copy = TRUE, na_matches = \"na\")\n```\n\n----------------------------------------\n\nTITLE: Implementing Semi-join Operation for Data Frames in R\nDESCRIPTION: This function implements a semi-join operation for data.frame objects, which keeps all rows from the first data frame (x) where there are matching values in the second data frame (y), but only returns columns from x. It handles NA matching options and auto-copies data if needed.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/semi_join.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nsemi_join.data.frame <- function(x, y, by = NULL, copy = FALSE, ..., na_matches = c(\"na\", \"never\")) {\n  check_dots_empty0(...)\n  y <- auto_copy(x, y, copy = copy)\n  join_filter(x, y, by = by, type = \"semi\", na_matches = na_matches, user_env = caller_env())\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Missing Value Handling in if_else() Function in R\nDESCRIPTION: This snippet checks how the if_else() function handles the 'missing' parameter in type compatibility. It shows that the missing value is included in the common type computation.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-if-else.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\nif_else(TRUE, 1, 2, missing = \"x\")\n```\n\n----------------------------------------\n\nTITLE: Testing Error Handling for Custom Function in duckplyr_summarise and duckplyr_mutate\nDESCRIPTION: These snippets test error handling when a custom function throws an error within `across()` in `duckplyr_summarise()` and `duckplyr_mutate()`.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-across.md#2025-04-21_snippet_4\n\nLANGUAGE: R\nCODE:\n```\nerror_fn <- (function(.) {\n  if (all(. > 10)) {\n    rlang::abort(\"too small\", call = call(\"error_fn\"))\n  } else {\n    42\n  }\n})\n(expect_error(tibble(x = 1:10, y = 11:20) %>% duckplyr_summarise(across(everything(), error_fn))))\n```\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(tibble(x = 1:10, y = 11:20) %>% duckplyr_mutate(across(everything(), error_fn))))\n```\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(tibble(x = 1:10, y = 11:20) %>% duckplyr_summarise(force(across(everything(), error_fn)))))\n```\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(tibble(x = 1:10, y = 11:20) %>% duckplyr_mutate(force(across(everything(), error_fn)))))\n```\n\n----------------------------------------\n\nTITLE: Testing Type Compatibility in if_else() Function in R\nDESCRIPTION: This snippet tests the type compatibility between the true and false values in the if_else() function. It demonstrates that mixing incompatible types (double and character) results in an error.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-if-else.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nif_else(TRUE, 1, \"x\")\n```\n\n----------------------------------------\n\nTITLE: Testing Error When Sampling More Rows Than Available in Group\nDESCRIPTION: This snippet tests the error message when sample_n() attempts to sample more rows than are available in a specific group. It groups the mtcars dataset by cylinder count and attempts to sample 10 rows from each group, which fails for the group with only 7 rows.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-sample.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(mtcars %>% duckplyr_group_by(cyl) %>% sample_n(10)))\n```\n\n----------------------------------------\n\nTITLE: Testing join_rows() with inner join and unmatched rows in R\nDESCRIPTION: This snippet tests the join_rows() function with an inner join type and specifies different unmatched behaviors for x and y, expecting an error for unmatched rows in y.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-join-rows.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\njoin_rows(c(1, 3), c(1, 2), type = \"inner\", unmatched = c(\"drop\", \"error\"))\n```\n\n----------------------------------------\n\nTITLE: Testing Type Casting in duckplyr_rows_upsert\nDESCRIPTION: This snippet checks how duckplyr_rows_upsert handles type casting for keys and values, ensuring appropriate error messages for incompatible types.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-rows.md#2025-04-21_snippet_14\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(duckplyr_rows_upsert(x, y, \"key\")))\n```\n\n----------------------------------------\n\nTITLE: Testing DuckPLYR Error Handling\nDESCRIPTION: Demonstrates error handling for various scenarios like unknown functions, invalid column types, and naming conflicts.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/fallback.md#2025-04-21_snippet_3\n\nLANGUAGE: R\nCODE:\n```\nduckdb_tibble(a = 1, b = 2) %>% mutate(c = foo(a, b))\n```\n\nLANGUAGE: R\nCODE:\n```\nduckdb_tibble(a = c(x = 1))\n```\n\n----------------------------------------\n\nTITLE: Testing .size Parameter in case_when() Function (R)\nDESCRIPTION: This snippet checks if the .size parameter is correctly passed through and enforced in the case_when() function.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-case-when.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\ncase_when(TRUE ~ 1:2, .size = 3)\n```\n\n----------------------------------------\n\nTITLE: Computing Symmetric Difference for Data Frames in R\nDESCRIPTION: This function calculates the symmetric difference between two data frames. It checks for empty dots, ensures the data frames are compatible, computes the symmetric difference using vec_set_symmetric_difference, and reconstructs the result using dplyr_reconstruct.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/symdiff.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nsymdiff.data.frame <- function(x, y, ...) {\n  check_dots_empty()\n  check_compatible(x, y)\n\n  out <- vec_set_symmetric_difference(x, y, error_call = current_env())\n\n  dplyr_reconstruct(out, x)\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Data Frame Compatibility Messages\nDESCRIPTION: Test cases for generating compatibility check messages between data frames, covering different scenarios like type mismatches, column order, and structure differences.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-sets.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\ncat(is_compatible(tibble(x = 1), 1))\ncat(is_compatible(tibble(x = 1), tibble(x = 1, y = 2)))\ncat(is_compatible(tibble(x = 1, y = 1), tibble(y = 1, x = 1), ignore_col_order = FALSE))\ncat(is_compatible(tibble(x = 1), tibble(y = 1)))\ncat(is_compatible(tibble(x = 1), tibble(x = 1L), convert = FALSE))\ncat(is_compatible(tibble(x = 1), tibble(x = \"a\")))\n```\n\n----------------------------------------\n\nTITLE: Testing Empty Input Error in Coalesce\nDESCRIPTION: Verifies that coalesce() throws appropriate error when called with no arguments or only NULL values\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-coalesce.md#2025-04-21_snippet_3\n\nLANGUAGE: r\nCODE:\n```\ncoalesce()\n```\n\nLANGUAGE: r\nCODE:\n```\ncoalesce(NULL, NULL)\n```\n\n----------------------------------------\n\nTITLE: Validating Condition Type in if_else() Function in R\nDESCRIPTION: This test case ensures that the 'condition' parameter in if_else() must be a logical vector. It demonstrates that using a non-logical vector (integer in this case) results in an error.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-if-else.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\nif_else(1:10, 1, 2)\n```\n\n----------------------------------------\n\nTITLE: Testing left_join with duckplyr in R\nDESCRIPTION: Demonstrates left_join operations using duckplyr, expecting errors with telemetry data. Tests include default join and join with various options like copying, suffixes, and relationship specification.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/telemetry.md#2025-04-21_snippet_8\n\nLANGUAGE: R\nCODE:\n```\nduckdb_tibble(a = 1:3, b = 4:6) %>% left_join(tibble(a = 1:3, b = 4:6))\n```\n\nLANGUAGE: R\nCODE:\n```\nduckdb_tibble(a = 1:3, b = 4:6) %>% left_join(tibble(a = 1:3, b = 4:6), by = \"a\", copy = TRUE, suffix = c(\"x\", \"y\"), keep = TRUE, na_matches = \"na\", multiple = \"all\", unmatched = \"error\", relationship = \"one-to-one\")\n```\n\n----------------------------------------\n\nTITLE: Testing Extra Column Handling in duckplyr_rows_delete\nDESCRIPTION: This snippet checks if duckplyr_rows_delete correctly ignores extra columns in the source dataframe and provides an appropriate message.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-rows.md#2025-04-21_snippet_15\n\nLANGUAGE: R\nCODE:\n```\nout <- duckplyr_rows_delete(x, y)\n```\n\n----------------------------------------\n\nTITLE: Testing Integer Comparison Translation in duckplyr\nDESCRIPTION: Demonstrates how rel_translate converts a comparison expression with an integer constant into a relational expression structure. The test shows the output when translating 'a > 123L' with a dataframe containing column 'a'.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/translate.md#2025-04-21_snippet_2\n\nLANGUAGE: r\nCODE:\n```\nrel_translate(quo(a > 123L), df)\n```\n\n----------------------------------------\n\nTITLE: Testing Slice Helper Functions\nDESCRIPTION: Tests input validation for slice_head, slice_tail, slice_min, slice_max, and slice_sample functions, particularly focusing on n parameter validation.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-slice.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\nduckplyr_slice_head(df, n = \"a\")\nduckplyr_slice_tail(df, n = \"a\")\nslice_min(df, x, n = \"a\")\nslice_max(df, x, n = \"a\")\nduckplyr_slice_sample(df, n = \"a\")\n```\n\n----------------------------------------\n\nTITLE: Printing Rowwise DataFrame in R\nDESCRIPTION: This snippet demonstrates the print output of a rowwise data frame in R. It shows a tibble with 5 rows and 1 column, where each row is treated as its own group.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-rowwise.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nrf\n```\n\n----------------------------------------\n\nTITLE: Testing Error Handling in tally\nDESCRIPTION: Shows error handling behavior when invalid arithmetic operations are attempted within tally().\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-count-tally.md#2025-04-21_snippet_3\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(tally(mtcars, wt = 1 + \"\")))\n```\n\n----------------------------------------\n\nTITLE: Validating Vector Input for lead() Function in R\nDESCRIPTION: This test ensures that lead() function requires the input 'x' to be a vector and throws an error when a non-vector (in this case, an environment) is provided.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-lead-lag.md#2025-04-21_snippet_5\n\nLANGUAGE: R\nCODE:\n```\nlead(environment())\n```\n\n----------------------------------------\n\nTITLE: Testing DuckPLYR Data Transformation\nDESCRIPTION: Examples of data transformation operations that trigger fallback behavior, including summarize and mutate operations.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/fallback.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\nduckdb_tibble(a = 1, b = 2, c = 3) %>% summarize(.by = a, e = sum(b), f = sum(e))\n```\n\n----------------------------------------\n\nTITLE: Testing Column Existence Validation in duckplyr_rows_insert\nDESCRIPTION: This snippet checks if duckplyr_rows_insert correctly validates the existence of specified columns in both the target and source dataframes.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-rows.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(duckplyr_rows_insert(x, y, by = \"c\")))\n```\n\n----------------------------------------\n\nTITLE: Join Filter Argument Validation\nDESCRIPTION: Validates arguments for join_filter function, specifically testing handling of invalid by and na_matches parameters.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-join.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\njoin_filter(df, df, by = 1, type = \"semi\")\njoin_filter(df, df, by = \"x\", type = \"semi\", na_matches = \"foo\")\n```\n\n----------------------------------------\n\nTITLE: Testing Error Handling for na.rm=FALSE in Window Functions\nDESCRIPTION: Tests error conditions when using aggregation functions with na.rm=FALSE in window contexts. Verifies that appropriate error messages are displayed when unsupported operations are attempted.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/translate.md#2025-04-21_snippet_11\n\nLANGUAGE: r\nCODE:\n```\n# Test error when na.rm = FALSE in window functions\nrel_translate(expr(sum(a, na.rm = FALSE)), df, need_window = TRUE)\n```\n\nLANGUAGE: r\nCODE:\n```\nrel_translate(expr(mean(a, na.rm = FALSE)), df, need_window = TRUE)\n```\n\n----------------------------------------\n\nTITLE: Testing Type Incompatibility Error in Coalesce\nDESCRIPTION: Verifies that coalesce() throws appropriate error when combining incompatible types (integer and character)\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-coalesce.md#2025-04-21_snippet_1\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(coalesce(1:2, letters[1:2])))\n```\n\n----------------------------------------\n\nTITLE: Installing Development Version of duckplyr from R-universe in R\nDESCRIPTION: Demonstrates installation of the development version of duckplyr from R-universe using install.packages() with custom repositories.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/README.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\ninstall.packages(\"duckplyr\", repos = c(\"https://tidyverse.r-universe.dev\", \"https://cloud.r-project.org\"))\n```\n\n----------------------------------------\n\nTITLE: Testing distinct() with expressions containing unknown variables\nDESCRIPTION: This test checks the error handling when trying to create a new column in distinct() using an expression with a non-existent variable 'a', verifying that it produces an error indicating the object was not found.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-distinct.md#2025-04-21_snippet_3\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(df %>% duckplyr_distinct(y = a + 1)))\n```\n\n----------------------------------------\n\nTITLE: Checking for Empty Dots in lag() Function in R\nDESCRIPTION: This test verifies that lag() function checks for empty dots and throws an error when unexpected arguments are provided.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-lead-lag.md#2025-04-21_snippet_4\n\nLANGUAGE: R\nCODE:\n```\nlag(1:5, deault = 1)\n```\n\n----------------------------------------\n\nTITLE: Validating Column Existence in rows_check_x_contains_y\nDESCRIPTION: This snippet tests if the rows_check_x_contains_y function correctly validates that all columns in the source dataframe exist in the target dataframe.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-rows.md#2025-04-21_snippet_18\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(rows_check_x_contains_y(x, y)))\n```\n\n----------------------------------------\n\nTITLE: Join By Common Columns - Error Case\nDESCRIPTION: Demonstrates error handling when attempting to join tables with no common column names. Suggests using cross_join() as an alternative.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-join-by.md#2025-04-21_snippet_8\n\nLANGUAGE: r\nCODE:\n```\njoin_by_common(c(\"x\", \"y\"), c(\"w\", \"z\"))\n```\n\n----------------------------------------\n\nTITLE: Testing Group-wise Error Handling in duckplyr_reframe()\nDESCRIPTION: Shows how duckplyr_reframe() handles recycling errors within grouped operations. Demonstrates error messaging that includes group context information.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-reframe.md#2025-04-21_snippet_1\n\nLANGUAGE: r\nCODE:\n```\nduckplyr_reframe(df, x = 1:2, y = 3:5, .by = g)\n```\n\n----------------------------------------\n\nTITLE: Testing Type Error Handling in R Join Operations\nDESCRIPTION: This snippet tests the error handling for incompatible types during join operations, specifically referencing the original column in 'y' when there are type errors.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-join-cols.md#2025-04-21_snippet_3\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(join_cast_common(x_key, y_key, vars)))\n```\n\n----------------------------------------\n\nTITLE: Installing duckplyr Development Version from GitHub\nDESCRIPTION: Command to install the development version of duckplyr directly from GitHub using the pak package. This is an alternative method for accessing the latest development version.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/index.md#2025-04-21_snippet_2\n\nLANGUAGE: r\nCODE:\n```\n# install.packages(\"pak\")\npak::pak(\"tidyverse/duckplyr\")\n```\n\n----------------------------------------\n\nTITLE: Testing desc() Function Argument Validation in duckplyr_arrange\nDESCRIPTION: Test case verifying that the desc() function used within duckplyr_arrange() checks that it receives exactly one argument.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-arrange.md#2025-04-21_snippet_7\n\nLANGUAGE: r\nCODE:\n```\ndf <- data.frame(x = 1, y = 2)\n(expect_error(duckplyr_arrange(df, desc(x, y))))\n```\n\n----------------------------------------\n\nTITLE: Testing duckplyr_transmute() with unsupported .before argument\nDESCRIPTION: This test verifies that duckplyr_transmute() produces an appropriate error message when the .before argument is used, which is not supported in this implementation.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-transmute.md#2025-04-21_snippet_1\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(duckplyr_transmute(mtcars, cyl2 = cyl, .before = disp)))\n```\n\n----------------------------------------\n\nTITLE: Join By Common Columns - Special Characters\nDESCRIPTION: Shows joining using column names containing special characters (_x) and spaces (foo bar). The function handles these special names by properly quoting them.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-join-by.md#2025-04-21_snippet_7\n\nLANGUAGE: r\nCODE:\n```\nby <- join_by_common(c(\"_x\", \"foo bar\"), c(\"_x\", \"foo bar\"))\n```\n\n----------------------------------------\n\nTITLE: Implementing collect Method for Data Frames in R\nDESCRIPTION: A simple function that implements the collect method for data.frame objects by returning the original data frame unchanged. This serves as an identity operation when collect is called on regular data frames.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/collect.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\ncollect.data.frame <- function(x, ...) {\n  x\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Extra Arguments Error in DuckPlyr Set Operations\nDESCRIPTION: Test cases verifying error handling when extra arguments are passed to DuckPlyr set operations functions. Demonstrates proper error messages for invalid additional parameters.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-sets.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nduckplyr_intersect(df1, df2, z = 3)\nduckplyr_union(df1, df2, z = 3)\nduckplyr_union_all(df1, df2, z = 3)\nduckplyr_setdiff(df1, df2, z = 3)\nduckplyr_symdiff(df1, df2, z = 3)\n```\n\n----------------------------------------\n\nTITLE: Testing Error With Invalid Weights in sample_frac() on Regular Data\nDESCRIPTION: This snippet tests the error message when sample_frac() is used with weights containing zeros. It attempts to sample a fraction of data with a weight vector containing a zero value, which causes an error due to too few positive probabilities.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-sample.md#2025-04-21_snippet_8\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(sample_frac(df, 1, weight = y)))\n```\n\n----------------------------------------\n\nTITLE: Testing union_all with DuckPlyr\nDESCRIPTION: Testing union all operation between duckdb_tibble and regular tibble\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/telemetry.md#2025-04-21_snippet_19\n\nLANGUAGE: R\nCODE:\n```\nduckdb_tibble(a = 1:3, b = 4:6) %>% union_all(tibble(a = 1:3, b = 4:6))\n```\n\n----------------------------------------\n\nTITLE: Testing duckplyr_expand_across with Custom Function in R\nDESCRIPTION: This snippet tests the duckplyr_expand_across function using across() with a custom anonymous function to calculate the mean. It shows how to use a custom function within across().\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/duckplyr-across.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\ntest_duckplyr_expand_across(c(\"x\", \"y\"), across(x:y, function(x) mean(x)))\n```\n\n----------------------------------------\n\nTITLE: Installing duckplyr from GitHub using pak in R\nDESCRIPTION: Shows how to install duckplyr from GitHub using the pak package, which needs to be installed separately.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/README.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\n# install.packages(\"pak\")\npak::pak(\"tidyverse/duckplyr\")\n```\n\n----------------------------------------\n\nTITLE: Testing duckplyr_arrange Error with Incorrect Size\nDESCRIPTION: Test case verifying that duckplyr_arrange errors when the arrange expression returns a vector with incorrect size (size 2 instead of 1).\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-arrange.md#2025-04-21_snippet_2\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(tibble(x = 1) %>% duckplyr_arrange(rep(x, 2))))\n```\n\n----------------------------------------\n\nTITLE: Testing Error Handling in duckplyr_rows_insert for Existing Keys\nDESCRIPTION: This snippet tests the error message when attempting to insert rows with keys that already exist in the target dataframe. It demonstrates the default behavior and the option to ignore conflicts.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-rows.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(duckplyr_rows_insert(x, y, by = \"a\")))\n```\n\n----------------------------------------\n\nTITLE: Testing pick() with Conditional Selection Across Groups\nDESCRIPTION: Tests error handling for conditional usage of `pick()` with grouped data, showing how expansion errors are reported with the pre-expansion quosure.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-pick.md#2025-04-21_snippet_4\n\nLANGUAGE: R\nCODE:\n```\nduckplyr_mutate(df, if (cur_group_id() == 1L) pick(x) else \"x\", .by = g)\n```\n\n----------------------------------------\n\nTITLE: Testing Set Equality Requirements for Tibbles\nDESCRIPTION: Test cases verifying error handling for set equality operations when tibbles have mismatched columns or incompatible data types.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-sets.md#2025-04-21_snippet_3\n\nLANGUAGE: R\nCODE:\n```\nduckplyr_setequal(tibble(x = 1:2), tibble(y = 1:2))\nduckplyr_setequal(tibble(x = 1:2), tibble(x = c(\"a\", \"b\")))\n```\n\n----------------------------------------\n\nTITLE: Validating .unpack Parameter in duckplyr_summarise with across()\nDESCRIPTION: These snippets test various invalid inputs for the `.unpack` parameter in `across()` within `duckplyr_summarise()`.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-across.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\nduckplyr_summarise(df, across(x, mean, .unpack = 1))\n```\n\nLANGUAGE: R\nCODE:\n```\nduckplyr_summarise(df, across(x, mean, .unpack = c(\"x\", \"y\")))\n```\n\nLANGUAGE: R\nCODE:\n```\nduckplyr_summarise(df, across(x, mean, .unpack = NA))\n```\n\n----------------------------------------\n\nTITLE: Using as_duckdb_tibble() with readr imported data in R\nDESCRIPTION: Demonstrates the error when trying to use as_duckdb_tibble() directly on data imported via readr. The error suggests using read_csv_duckdb() for direct CSV reading or converting to a tibble first.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/ducktbl.md#2025-04-21_snippet_2\n\nLANGUAGE: r\nCODE:\n```\nas_duckdb_tibble(readr::read_csv(path, show_col_types = FALSE))\n```\n\n----------------------------------------\n\nTITLE: Testing Type Compatibility in Between Function (R)\nDESCRIPTION: These test cases verify that the 'between()' function correctly throws errors when incompatible types are used between the main argument 'x' and the boundary arguments 'left' and 'right'.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-funs.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\nbetween(\"1\", 2, 3)\n```\n\nLANGUAGE: r\nCODE:\n```\nbetween(1, \"2\", 3)\n```\n\nLANGUAGE: r\nCODE:\n```\nbetween(1, 2, \"3\")\n```\n\n----------------------------------------\n\nTITLE: Validating 'unmatched' Parameter in duckplyr_rows_update\nDESCRIPTION: This snippet tests the validation of the 'unmatched' parameter in duckplyr_rows_update, ensuring it only accepts valid options.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-rows.md#2025-04-21_snippet_9\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(duckplyr_rows_update(x, y, by = \"a\", unmatched = \"foo\")))\n```\n\n----------------------------------------\n\nTITLE: Testing Error Handling in add_tally\nDESCRIPTION: Shows error handling behavior when invalid arithmetic operations are attempted within add_tally().\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-count-tally.md#2025-04-21_snippet_5\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(add_tally(mtcars, wt = 1 + \"\")))\n```\n\n----------------------------------------\n\nTITLE: Testing Rowwise DataFrame Validation Errors in R\nDESCRIPTION: This series of tests checks various error conditions in the validate_rowwise_df() function. It ensures proper error messages are generated for incorrectly structured rowwise data frames.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-rowwise.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(validate_rowwise_df(df1)))\n```\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(validate_rowwise_df(df2)))\n```\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(validate_rowwise_df(df3)))\n```\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(validate_rowwise_df(df4)))\n```\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(validate_rowwise_df(df7)))\n```\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(attr(df8, \"groups\")$.rows <- 1:8))\n```\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(validate_rowwise_df(df10)))\n```\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(validate_rowwise_df(df11)))\n```\n\n----------------------------------------\n\nTITLE: Testing Type Conversion in Equality\nDESCRIPTION: Demonstrates behavior when comparing columns of different types with and without type conversion enabled via the convert parameter.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-all-equal.md#2025-04-21_snippet_4\n\nLANGUAGE: r\nCODE:\n```\nall_equal(df1, df2, convert = FALSE)\nall_equal(df1, df2)\nall_equal(df1, df2, convert = TRUE)\n```\n\n----------------------------------------\n\nTITLE: Testing duckplyr_arrange Validation for Multiple Locales\nDESCRIPTION: Test case verifying that duckplyr_arrange validates that the .locale parameter must be a single string, not a vector of multiple strings.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-arrange.md#2025-04-21_snippet_5\n\nLANGUAGE: r\nCODE:\n```\nduckplyr_arrange(df, .locale = c(\"en_US\", \"fr_BF\"))\n```\n\n----------------------------------------\n\nTITLE: Testing Size Stability with Empty Vector in na_if Function in R\nDESCRIPTION: Tests that na_if properly handles cases where y is an empty vector, ensuring it raises an appropriate error about recycling issues.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-na-if.md#2025-04-21_snippet_1\n\nLANGUAGE: r\nCODE:\n```\nna_if(1, integer())\n```\n\n----------------------------------------\n\nTITLE: Testing na_rm Validation in nth Function\nDESCRIPTION: Tests that verify the nth function properly validates the na_rm parameter, ensuring it must be TRUE or FALSE and not other values like numbers or vectors.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-nth-value.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\nnth(1, 1, na_rm = 1)\n```\n\nLANGUAGE: r\nCODE:\n```\nnth(1, 1, na_rm = c(TRUE, FALSE))\n```\n\n----------------------------------------\n\nTITLE: Testing Type Casting in duckplyr_rows_delete\nDESCRIPTION: This snippet checks how duckplyr_rows_delete handles type casting for keys, ensuring appropriate error messages for incompatible types.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-rows.md#2025-04-21_snippet_17\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(duckplyr_rows_delete(x, y, \"key\")))\n```\n\n----------------------------------------\n\nTITLE: Testing Error When Applying sample_n() to Non-DataFrame Input\nDESCRIPTION: This snippet tests the error message when sample_n() is called with an empty list instead of a data frame. It verifies that the function correctly identifies and reports the inappropriate input type.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-sample.md#2025-04-21_snippet_3\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(sample_n(list())))\n```\n\n----------------------------------------\n\nTITLE: Testing Error Paths in Function Translation with rel_find_call()\nDESCRIPTION: Tests error handling in rel_find_call() for invalid inputs, unknown functions, and function mapping issues. Verifies appropriate error messages for different failure scenarios.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/translate.md#2025-04-21_snippet_13\n\nLANGUAGE: r\nCODE:\n```\n# Error: Can't translate function with invalid '::' structure\nrel_find_call(quote(pkg::\"\"), env)\n```\n\nLANGUAGE: r\nCODE:\n```\n# Error: Can't translate function with invalid '::' components\nrel_find_call(call(\"::\", \"pkg\", 123), env, env)\n```\n\nLANGUAGE: r\nCODE:\n```\n# Error: No translation for unknown function\nrel_find_call(quote(unknown_function), env)\n```\n\nLANGUAGE: r\nCODE:\n```\n# Error: No translation for unknown function from some package\nrel_find_call(quote(somepkg::unknown_function), env)\n```\n\nLANGUAGE: r\nCODE:\n```\n# Error: Function not found in the environment\nrel_find_call(quote(mean), new_environment())\n```\n\nLANGUAGE: r\nCODE:\n```\n# Error: Function does not map to the corresponding package\nrel_find_call(quote(mean), new_environment(list(mean = stats::sd)))\n```\n\n----------------------------------------\n\nTITLE: Testing Mean Aggregation in R\nDESCRIPTION: Validates mean() operation behavior including error cases and NA handling options\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/translate.md#2025-04-21_snippet_9\n\nLANGUAGE: R\nCODE:\n```\nrel_translate(expr(mean(a)), df)\nrel_translate(expr(mean(a, b)), df)\nrel_translate(expr(mean(a, na.rm = TRUE)), df)\nrel_translate(expr(mean(a, na.rm = FALSE)), df)\n```\n\n----------------------------------------\n\nTITLE: Testing locale_to_chr_proxy_collate Error without stringi\nDESCRIPTION: Test case verifying that an error is thrown when trying to use a locale identifier without having stringi installed.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-arrange.md#2025-04-21_snippet_3\n\nLANGUAGE: r\nCODE:\n```\nlocale_to_chr_proxy_collate(\"fr\", has_stringi = FALSE)\n```\n\n----------------------------------------\n\nTITLE: Testing Error on Multi-Column Matrices in duckplyr_filter()\nDESCRIPTION: Tests that duckplyr_filter() properly rejects matrices with more than one column. The function should throw an error indicating that it requires a logical vector, not a logical matrix.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-filter.md#2025-04-21_snippet_1\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(duckplyr_filter(df, matrix(TRUE, nrow = 3, ncol = 2))))\n```\n\n----------------------------------------\n\nTITLE: Testing Error Messages in case_when() Function (R)\nDESCRIPTION: This set of snippets tests various error scenarios in case_when(), including size mismatches, invalid inputs, and missing conditions, ensuring meaningful error messages are provided.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-case-when.md#2025-04-21_snippet_6\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(case_when(c(TRUE, FALSE) ~ 1:3, c(FALSE, TRUE) ~ 1:2)))\n```\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(case_when(c(TRUE, FALSE) ~ 1, c(FALSE, TRUE, FALSE) ~ 2, c(FALSE, TRUE, FALSE, NA) ~ 3)))\n```\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(case_when(50 ~ 1:3)))\n```\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(case_when(paste(50))))\n```\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(case_when(y ~ x, paste(50))))\n```\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(case_when()))\n```\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(case_when(NULL)))\n```\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(case_when(~ 1:2)))\n```\n\n----------------------------------------\n\nTITLE: Validating Key Uniqueness in duckplyr_rows_upsert\nDESCRIPTION: This snippet tests if duckplyr_rows_upsert correctly handles and reports errors for duplicate keys in the source dataframe.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-rows.md#2025-04-21_snippet_13\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(duckplyr_rows_upsert(x, y, by = \"a\")))\n```\n\n----------------------------------------\n\nTITLE: Error Handling in duckplyr_cross_join with Duplicate Column Names\nDESCRIPTION: This code demonstrates how duckplyr_cross_join handles the case when there are duplicate column names in the input dataframes. The function throws an error when it detects that the input columns in the first dataframe (`x`) are not unique, specifically identifying a problem with column `a`.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-join-cross.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\nduckplyr_cross_join(df1, df2)\n```\n\n----------------------------------------\n\nTITLE: Testing Incorrect Usage of pick_wrapper() Result in duckplyr_filter()\nDESCRIPTION: Tests error handling when incorrectly using the result of a wrapper around `pick()` in `duckplyr_filter()`. Shows error about incorrect vector type.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-pick.md#2025-04-21_snippet_12\n\nLANGUAGE: R\nCODE:\n```\nduckplyr_filter(df, pick_wrapper(x, y)$x)\n```\n\n----------------------------------------\n\nTITLE: Testing Error Handling in duckplyr_transmute Function\nDESCRIPTION: This snippet shows the error handling in duckplyr_transmute when an undefined function is called. The error message is identical to the one in duckplyr_mutate.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-conditions.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\nduckplyr_transmute(mtcars, !!foobarbaz())\n```\n\n----------------------------------------\n\nTITLE: Unnamed List Binding with Name Repair in R\nDESCRIPTION: Shows how bind_cols() handles unnamed list elements by assigning automatic sequential names.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-bind-cols.md#2025-04-21_snippet_1\n\nLANGUAGE: r\nCODE:\n```\ndf <- bind_cols(list(1, 2))\n```\n\n----------------------------------------\n\nTITLE: Testing distinct() with a single unknown column\nDESCRIPTION: This test creates a simple tibble with two columns and attempts to call distinct() with a non-existent column 'aa', verifying that the appropriate error message is displayed indicating the column was not found.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-distinct.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\ndf <- tibble(g = c(1, 2), x = c(1, 2))\n(expect_error(df %>% duckplyr_distinct(aa, x)))\n```\n\n----------------------------------------\n\nTITLE: Testing n() Function Error Message in R\nDESCRIPTION: Tests that n() function throws appropriate error when used outside data-masking verbs.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-context.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(n()))\n```\n\n----------------------------------------\n\nTITLE: Implementing group_trim Method for Data Frames in R\nDESCRIPTION: This function implements the group_trim method for data.frame objects. It takes a data frame and a drop parameter (with a default value determined by group_by_drop_default), but simply returns the input table unchanged without performing any actual trimming operations.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/group_trim.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\ngroup_trim.data.frame <- function(.tbl, .drop = group_by_drop_default(.tbl)) {\n  .tbl\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Numeric Comparison Translation in duckplyr\nDESCRIPTION: Shows how rel_translate converts a comparison expression with a numeric constant into a relational expression structure. The test demonstrates the output when translating 'a > 123' with a dataframe containing column 'a'.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/translate.md#2025-04-21_snippet_3\n\nLANGUAGE: r\nCODE:\n```\nrel_translate(quo(a > 123), df)\n```\n\n----------------------------------------\n\nTITLE: Testing setdiff with DuckPlyr\nDESCRIPTION: Testing set difference operation between duckdb_tibble and regular tibble\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/telemetry.md#2025-04-21_snippet_15\n\nLANGUAGE: R\nCODE:\n```\nduckdb_tibble(a = 1:3, b = 4:6) %>% setdiff(tibble(a = 1:3, b = 4:6))\n```\n\n----------------------------------------\n\nTITLE: Testing join_rows() unmatched row error messages in R\nDESCRIPTION: These snippets test join_rows() with various join types and unmatched settings, expecting specific error messages for unmatched rows in x or y.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-join-rows.md#2025-04-21_snippet_6\n\nLANGUAGE: R\nCODE:\n```\njoin_rows(data.frame(x = c(1, 2)), data.frame(x = c(3, 1)), type = \"left\", unmatched = \"error\")\n```\n\nLANGUAGE: R\nCODE:\n```\njoin_rows(data.frame(x = c(1, 2)), data.frame(x = c(3, 1)), type = \"nest\", unmatched = \"error\")\n```\n\nLANGUAGE: R\nCODE:\n```\njoin_rows(data.frame(x = c(1, 2)), data.frame(x = c(3, 1)), type = \"right\", unmatched = \"error\")\n```\n\nLANGUAGE: R\nCODE:\n```\njoin_rows(data.frame(x = c(1, 2)), data.frame(x = 1), type = \"inner\", unmatched = \"error\")\n```\n\nLANGUAGE: R\nCODE:\n```\njoin_rows(data.frame(x = c(1, 2)), data.frame(x = 1), type = \"inner\", unmatched = c(\"error\", \"drop\"))\n```\n\nLANGUAGE: R\nCODE:\n```\njoin_rows(data.frame(x = 1), data.frame(x = c(1, 2)), type = \"inner\", unmatched = \"error\")\n```\n\nLANGUAGE: R\nCODE:\n```\njoin_rows(data.frame(x = 1), data.frame(x = c(1, 2)), type = \"inner\", unmatched = c(\"drop\", \"error\"))\n```\n\n----------------------------------------\n\nTITLE: Testing distinct with duckplyr in R\nDESCRIPTION: Demonstrates distinct operations using duckplyr, expecting errors with telemetry data. Tests include simple distinct and distinct with keeping all columns.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/telemetry.md#2025-04-21_snippet_3\n\nLANGUAGE: R\nCODE:\n```\nduckdb_tibble(a = 1:3, b = 4:6) %>% distinct(a)\n```\n\nLANGUAGE: R\nCODE:\n```\nduckdb_tibble(a = 1:3, b = 4:6) %>% distinct(a, b, .keep_all = TRUE)\n```\n\n----------------------------------------\n\nTITLE: Error Handling for Incompatible Sizes in bind_cols()\nDESCRIPTION: Demonstrates error handling when attempting to bind columns with incompatible sizes, showing both cases of smaller and larger mismatches.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-bind-cols.md#2025-04-21_snippet_2\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(bind_cols(a = 1:2, mtcars)))\n(expect_error(bind_cols(mtcars, a = 1:3)))\n```\n\n----------------------------------------\n\nTITLE: Testing Error When Sampling Fraction Greater Than One\nDESCRIPTION: This snippet tests the error message when sample_frac() is called with a fraction greater than 1 without replacement. It attempts to sample twice the number of rows from a data frame without replacement, which is not possible.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-sample.md#2025-04-21_snippet_6\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(sample_frac(df, 2)))\n```\n\n----------------------------------------\n\nTITLE: Testing Error Handling in join_by() in R\nDESCRIPTION: This snippet tests various error conditions in join_by(), including invalid syntax, unsupported operations, and incorrect use of special functions.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-join-by.md#2025-04-21_snippet_3\n\nLANGUAGE: R\nCODE:\n```\njoin_by(a = b)\njoin_by(NULL)\njoin_by(foo(x > y))\njoin_by(x == y, x^y)\njoin_by(x + 1 == y)\njoin_by(x == y + 1)\njoin_by(1)\njoin_by(1())\njoin_by(dplyrr::between(x, left, right))\n```\n\n----------------------------------------\n\nTITLE: Validating Conflict Parameter in duckplyr_rows_insert\nDESCRIPTION: This snippet tests the validation of the 'conflict' parameter in duckplyr_rows_insert, ensuring it only accepts valid options.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-rows.md#2025-04-21_snippet_3\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(duckplyr_rows_insert(x, y, by = \"a\", conflict = \"foo\")))\n```\n\n----------------------------------------\n\nTITLE: Testing Equality Comparison between Columns in duckplyr\nDESCRIPTION: Illustrates how rel_translate handles an equality comparison between two columns. The test shows the resulting relational expression structure when translating 'a == b' with a dataframe containing columns 'a' and 'b'.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/translate.md#2025-04-21_snippet_4\n\nLANGUAGE: r\nCODE:\n```\nrel_translate(quo(a == b), df)\n```\n\n----------------------------------------\n\nTITLE: Testing relocate with duckplyr in R\nDESCRIPTION: Demonstrates relocate operations using duckplyr, expecting errors with telemetry data. Tests include simple relocate and relocate with before and after options.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/telemetry.md#2025-04-21_snippet_10\n\nLANGUAGE: R\nCODE:\n```\nduckdb_tibble(a = 1:3, b = 4:6) %>% relocate(b)\n```\n\nLANGUAGE: R\nCODE:\n```\nduckdb_tibble(a = 1:3, b = 4:6) %>% relocate(b, .before = a)\n```\n\nLANGUAGE: R\nCODE:\n```\nduckdb_tibble(a = 1:3, b = 4:6) %>% relocate(a, .after = b)\n```\n\n----------------------------------------\n\nTITLE: Testing Error When Using Invalid Weights with sample_frac() on Grouped Data\nDESCRIPTION: This snippet tests the error message when sample_frac() is called on grouped data with invalid weights. It attempts to sample a fraction of data with weights containing zeros, which causes an error due to too few positive probabilities.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-sample.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(sample_frac(grp, 1, weight = y)))\n```\n\n----------------------------------------\n\nTITLE: Testing pick() with Non-Existent Column in duckplyr_arrange()\nDESCRIPTION: Tests error handling when attempting to select a non-existent column using `pick()` inside `duckplyr_arrange()`. Should show a clear error about the missing column.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-pick.md#2025-04-21_snippet_7\n\nLANGUAGE: R\nCODE:\n```\nduckplyr_arrange(df, pick(y))\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Lazy Evaluation Error\nDESCRIPTION: Shows how duckplyr prevents automatic materialization of large datasets to protect memory usage.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/README.md#2025-04-21_snippet_11\n\nLANGUAGE: r\nCODE:\n```\nnrow(flights)\n```\n\n----------------------------------------\n\nTITLE: Testing Error Handling for Duplicate Names in across()\nDESCRIPTION: This snippet tests error handling when `across()` results in duplicate column names.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-across.md#2025-04-21_snippet_5\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(tibble(x = 1) %>% duckplyr_summarise(across(everything(), list(f = mean, f = mean)))))\n```\n\n----------------------------------------\n\nTITLE: Testing Slice Argument Validation\nDESCRIPTION: Validates argument naming requirements and restrictions for slice operations, including .by and .preserve parameter validation.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-slice.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\nduckplyr_slice(df, 1, foo = g)\nduckplyr_slice(df, .by = x, .preserve = TRUE)\nduckplyr_slice(df, by = x)\n```\n\n----------------------------------------\n\nTITLE: Testing New Rowwise DataFrame Creation Errors in R\nDESCRIPTION: These tests check error conditions in the new_rowwise_df() function. They ensure that the function correctly handles invalid inputs when creating new rowwise data frames.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-rowwise.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(new_rowwise_df(tibble(x = 1:10), tibble(\".rows\" := list(1:5, -1L)))))\n```\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(new_rowwise_df(tibble(x = 1:10), 1:10)))\n```\n\n----------------------------------------\n\nTITLE: Error using n_distinct() with mutate() in DuckDB with dplyr\nDESCRIPTION: Illustrates that n_distinct() can only be used with summarise() in DuckDB context, not with mutate(). This is because n_distinct() is not supported as a window function.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/n_distinct.md#2025-04-21_snippet_2\n\nLANGUAGE: r\nCODE:\n```\ndf %>% mutate(dummy = n_distinct(a))\n```\n\n----------------------------------------\n\nTITLE: Testing arrange with duckplyr in R\nDESCRIPTION: Demonstrates arrange operations using duckplyr, expecting errors with telemetry data. Tests include simple arrange and arrange with group-by option.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/telemetry.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\nduckdb_tibble(a = 1:3, b = 4:6) %>% arrange(a)\n```\n\nLANGUAGE: R\nCODE:\n```\nduckdb_tibble(a = 1:3, b = 4:6) %>% arrange(a, .by_group = TRUE)\n```\n\n----------------------------------------\n\nTITLE: Testing order_by() with NULL and integer input\nDESCRIPTION: Tests that order_by() correctly rejects an integer value instead of a function call when the data argument is NULL.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-order-by.md#2025-04-21_snippet_3\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(order_by(NULL, 1L)))\n```\n\n----------------------------------------\n\nTITLE: Testing pick_wrapper() with Invalid Selection in duckplyr_filter()\nDESCRIPTION: Tests error handling when using a wrapper around `pick()` with invalid column selection in `duckplyr_filter()`. Shows error propagation through the wrapper.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-pick.md#2025-04-21_snippet_10\n\nLANGUAGE: R\nCODE:\n```\nduckplyr_filter(df, pick_wrapper(x, a))\n```\n\n----------------------------------------\n\nTITLE: Testing Less-than-or-equal Comparison between Columns in duckplyr\nDESCRIPTION: Shows how rel_translate converts a less-than-or-equal comparison between two columns into a relational expression structure. The test demonstrates the output when translating 'a <= c' with a dataframe containing columns 'a' and 'c'.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/translate.md#2025-04-21_snippet_5\n\nLANGUAGE: r\nCODE:\n```\nrel_translate(quo(a <= c), df)\n```\n\n----------------------------------------\n\nTITLE: Testing Vector Type Requirement for y in na_if Function in R\nDESCRIPTION: Tests that na_if properly rejects non-vector inputs for the y parameter, ensuring the function only works with proper vector types.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-na-if.md#2025-04-21_snippet_5\n\nLANGUAGE: r\nCODE:\n```\nna_if(1, environment())\n```\n\n----------------------------------------\n\nTITLE: Testing Missing Column Equality\nDESCRIPTION: Checks that data frames with different numbers of columns are not considered equal by comparing original dataframes with versions missing one column.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-all-equal.md#2025-04-21_snippet_2\n\nLANGUAGE: r\nCODE:\n```\nall_equal(mtcars, mtcars[, -1])\nall_equal(iris, iris[, -1])\nall_equal(df_all, df_all[, -1])\n```\n\n----------------------------------------\n\nTITLE: Testing symdiff with DuckPlyr\nDESCRIPTION: Testing symmetric difference operation between duckdb_tibble and regular tibble\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/telemetry.md#2025-04-21_snippet_17\n\nLANGUAGE: R\nCODE:\n```\nduckdb_tibble(a = 1:3, b = 4:6) %>% symdiff(tibble(a = 1:3, b = 4:6))\n```\n\n----------------------------------------\n\nTITLE: Testing Type Stability in na_if Function in R\nDESCRIPTION: Tests that na_if properly rejects type conversion that would cause precision loss. This ensures the function maintains type stability when comparing values.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-na-if.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\nna_if(0L, 1.5)\n```\n\n----------------------------------------\n\nTITLE: Testing lag() Error for Time Series Objects in R\nDESCRIPTION: This snippet tests if lag() function gives an informative error message when used with a time series object. It expects an error suggesting the use of stats::lag() instead.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-lead-lag.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nlag(ts(1:10))\n```\n\n----------------------------------------\n\nTITLE: Testing cur_group_rows() Function Error Message in R\nDESCRIPTION: Tests that cur_group_rows() function throws appropriate error when used outside data-masking verbs.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-context.md#2025-04-21_snippet_4\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(cur_group_rows()))\n```\n\n----------------------------------------\n\nTITLE: Error using n_distinct() with invalid na.rm parameter in DuckDB with dplyr\nDESCRIPTION: Shows that the na.rm parameter in n_distinct() must be TRUE or FALSE when used with DuckDB. Passing a non-logical value like a string will result in an error.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/n_distinct.md#2025-04-21_snippet_1\n\nLANGUAGE: r\nCODE:\n```\ndf %>% summarise(dummy = n_distinct(a, na.rm = \"b\"))\n```\n\n----------------------------------------\n\nTITLE: Using deprecated multiple='warning' parameter with join_rows function in R\nDESCRIPTION: Example showing deprecation warning when using 'multiple = \"warning\"' with the join_rows function. This parameter has been deprecated in dplyr 1.1.1 in favor of 'relationship = \"many-to-one\"'. The code generates a warning when a row in x matches multiple rows in y.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-join-rows.md#2025-04-21_snippet_14\n\nLANGUAGE: r\nCODE:\n```\nout <- join_rows(df1, df2, multiple = \"warning\")\n```\n\n----------------------------------------\n\nTITLE: Checking for Empty Dots in lead() Function in R\nDESCRIPTION: This test verifies that lead() function checks for empty dots and throws an error when unexpected arguments are provided.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-lead-lag.md#2025-04-21_snippet_3\n\nLANGUAGE: R\nCODE:\n```\nlead(1:5, deault = 1)\n```\n\n----------------------------------------\n\nTITLE: Testing join_rows() unmatched parameter validation in R\nDESCRIPTION: These snippets test the validation of the unmatched parameter in join_rows(), checking for correct data types, values, and lengths.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-join-rows.md#2025-04-21_snippet_8\n\nLANGUAGE: R\nCODE:\n```\njoin_rows(df, df, unmatched = 1)\n```\n\nLANGUAGE: R\nCODE:\n```\njoin_rows(df, df, unmatched = \"foo\")\n```\n\nLANGUAGE: R\nCODE:\n```\njoin_rows(df, df, type = \"left\", unmatched = character())\n```\n\nLANGUAGE: R\nCODE:\n```\njoin_rows(df, df, type = \"left\", unmatched = c(\"drop\", \"error\"))\n```\n\nLANGUAGE: R\nCODE:\n```\njoin_rows(df, df, type = \"inner\", unmatched = character())\n```\n\nLANGUAGE: R\nCODE:\n```\njoin_rows(df, df, type = \"inner\", unmatched = c(\"drop\", \"error\", \"error\"))\n```\n\nLANGUAGE: R\nCODE:\n```\njoin_rows(df, df, type = \"inner\", unmatched = c(\"drop\", \"dr\"))\n```\n\n----------------------------------------\n\nTITLE: Testing join_rows() relationship parameter validation in R\nDESCRIPTION: These snippets test the validation of the relationship parameter in join_rows(), checking for correct data types and values.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-join-rows.md#2025-04-21_snippet_9\n\nLANGUAGE: R\nCODE:\n```\njoin_rows(df, df, relationship = 1)\n```\n\nLANGUAGE: R\nCODE:\n```\njoin_rows(df, df, relationship = \"none\")\n```\n\nLANGUAGE: R\nCODE:\n```\njoin_rows(df, df, relationship = \"warn-many-to-many\")\n```\n\n----------------------------------------\n\nTITLE: Testing Factor Level Equality\nDESCRIPTION: Shows that factors are only considered equal if they have identical levels, even if the actual values match.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-all-equal.md#2025-04-21_snippet_3\n\nLANGUAGE: r\nCODE:\n```\nall_equal(df1, df2)\nall_equal(df2, df1)\n```\n\n----------------------------------------\n\nTITLE: Testing Key Existence Validation in duckplyr_rows_update\nDESCRIPTION: This snippet checks if duckplyr_rows_update correctly validates that keys in the source dataframe exist in the target dataframe by default.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-rows.md#2025-04-21_snippet_6\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(duckplyr_rows_update(x, y, \"a\")))\n```\n\n----------------------------------------\n\nTITLE: Extracting R Files from Selected Repositories\nDESCRIPTION: SQL query to list all R source files from previously filtered repositories. Creates the tinker.r_files table. Note: may include duplicates from forks.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/gh-analysis/README.md#2025-04-21_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\nSELECT\n  repo_name, path, id\nFROM\n  `bigquery-public-data.github_repos.files`\nWHERE\n  path LIKE '%.R'\n  OR path LIKE '%.r'\n  AND repo_name IN (SELECT * FROM tinker.r_repos)\n```\n\n----------------------------------------\n\nTITLE: Testing cur_group_id() Function Error Message in R\nDESCRIPTION: Tests that cur_group_id() function throws appropriate error when used outside data-masking verbs.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-context.md#2025-04-21_snippet_3\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(cur_group_id()))\n```\n\n----------------------------------------\n\nTITLE: Testing Non-Equi Conditions with keep=FALSE in R Join Operations\nDESCRIPTION: This snippet tests the join_cols() function with non-equi conditions and keep=FALSE, which should raise an error. It covers various join types including inequality, rolling, and overlap joins.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-join-cols.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\njoin_cols(c(\"x\", \"y\"), c(\"x\", \"z\"), by = join_by(x, y > z), keep = FALSE)\n\njoin_cols(c(\"xl\", \"xu\"), c(\"yl\", \"yu\"), by = join_by(xl >= yl, xu < yu), keep = FALSE)\n\njoin_cols(\"x\", c(\"yl\", \"yu\"), by = join_by(between(x, yl, yu)), keep = FALSE)\n\njoin_cols(c(\"xl\", \"xu\"), c(\"yl\", \"yu\"), by = join_by(overlaps(xl, xu, yl, yu)),\nkeep = FALSE)\n```\n\n----------------------------------------\n\nTITLE: Testing Error Handling in duckplyr_select Function\nDESCRIPTION: This code tests the error handling in duckplyr_select when an undefined function is used. The error message remains consistent with the previous functions.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-conditions.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\nduckplyr_select(mtcars, !!foobarbaz())\n```\n\n----------------------------------------\n\nTITLE: Using deprecated multiple='error' parameter with join_rows function in R\nDESCRIPTION: Example showing deprecation warning when using 'multiple = \"error\"' with the join_rows function. This parameter has been deprecated in dplyr 1.1.1 in favor of 'relationship = \"many-to-one\"'. The code generates an error when a row in x matches multiple rows in y.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-join-rows.md#2025-04-21_snippet_12\n\nLANGUAGE: r\nCODE:\n```\njoin_rows(df1, df2, multiple = \"error\")\n```\n\n----------------------------------------\n\nTITLE: Testing Error When Sampling Fraction Greater Than One on Grouped Data\nDESCRIPTION: This snippet tests the error message when sample_frac() is called on grouped data with a fraction greater than 1. It groups a data frame by column y and attempts to sample a fraction of 2 without replacement.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-sample.md#2025-04-21_snippet_7\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(sample_frac(df %>% duckplyr_group_by(y), 2)))\n```\n\n----------------------------------------\n\nTITLE: Validating Column Subset in duckplyr_rows_append\nDESCRIPTION: This snippet tests if duckplyr_rows_append correctly requires that columns in the source dataframe are a subset of the target dataframe.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-rows.md#2025-04-21_snippet_5\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(duckplyr_rows_append(x, y)))\n```\n\n----------------------------------------\n\nTITLE: Checking Filtered Dataframe Row Count\nDESCRIPTION: Simple verification of the number of rows in a filtered dataframe.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/relational-duckdb.md#2025-04-21_snippet_5\n\nLANGUAGE: r\nCODE:\n```\nnrow(df)\n```\n\n----------------------------------------\n\nTITLE: Testing Error When Applying sample_frac() to Non-DataFrame Input\nDESCRIPTION: This snippet tests the error message when sample_frac() is called with an empty list instead of a data frame. It verifies that the function correctly identifies and reports the inappropriate input type.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-sample.md#2025-04-21_snippet_4\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(sample_frac(list())))\n```\n\n----------------------------------------\n\nTITLE: Implementing rows_update.data.frame Function in R\nDESCRIPTION: Function that updates matching rows in a target data frame (x) with values from a source data frame (y) based on specified matching columns (by). Includes validation for unmatched rows, data type casting, and column existence checks.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/rows_update.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nrows_update.data.frame <- function(x,\n                                   y,\n                                   by = NULL,\n                                   ...,\n                                   unmatched = c(\"error\", \"ignore\"),\n                                   copy = FALSE,\n                                   in_place = FALSE) {\n  check_dots_empty()\n  rows_df_in_place(in_place)\n\n  y <- auto_copy(x, y, copy = copy)\n\n  by <- rows_check_by(by, y)\n\n  rows_check_x_contains_y(x, y)\n  rows_check_contains_by(x, by, \"x\")\n  rows_check_contains_by(y, by, \"y\")\n\n  x_key <- dplyr_col_select(x, by)\n  y_key <- dplyr_col_select(y, by)\n\n  rows_check_unique(y_key, \"y\")\n\n  args <- vec_cast_common(x = x_key, y = y_key)\n  x_key <- args$x\n  y_key <- args$y\n\n  values_names <- setdiff(names(y), names(y_key))\n\n  x_values <- dplyr_col_select(x, values_names)\n  y_values <- dplyr_col_select(y, values_names)\n  y_values <- rows_cast_y(y_values, x_values)\n\n  keep <- rows_check_y_unmatched(x_key, y_key, unmatched)\n\n  if (!is.null(keep)) {\n    y_key <- dplyr_row_slice(y_key, keep)\n    y_values <- dplyr_row_slice(y_values, keep)\n  }\n\n  loc <- vec_match(x_key, y_key)\n  match <- !is.na(loc)\n\n  y_loc <- loc[match]\n  x_loc <- which(match)\n\n  y_values <- dplyr_row_slice(y_values, y_loc)\n\n  x_values <- vec_assign(x_values, x_loc, y_values)\n  x_values <- dplyr_new_list(x_values)\n\n  x <- dplyr_col_modify(x, x_values)\n\n  x\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Lazy Execution in duckplyr\nDESCRIPTION: This snippet shows that queries on remote data are executed lazily in duckplyr. It demonstrates an error when trying to materialize a large result without explicit collection.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/index.md#2025-04-21_snippet_14\n\nLANGUAGE: r\nCODE:\n```\nnrow(flights)\n```\n\n----------------------------------------\n\nTITLE: Testing duckplyr_arrange Error with Non-existent Column\nDESCRIPTION: Test case verifying that duckplyr_arrange properly errors when attempting to arrange by a column that doesn't exist in the tibble.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-arrange.md#2025-04-21_snippet_1\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(tibble(x = 1) %>% duckplyr_arrange(y)))\n```\n\n----------------------------------------\n\nTITLE: Testing pick() with Undefined Function in duckplyr_arrange()\nDESCRIPTION: Tests error handling when using `pick()` with an undefined function inside `duckplyr_arrange()`. Should show that the undefined function is the cause of the error.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-pick.md#2025-04-21_snippet_8\n\nLANGUAGE: R\nCODE:\n```\nduckplyr_arrange(df, foo(pick(x)))\n```\n\n----------------------------------------\n\nTITLE: Testing Type Mismatch Errors in case_when() Function (R)\nDESCRIPTION: This snippet verifies that case_when() correctly handles and reports type mismatch errors between different conditions.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-case-when.md#2025-04-21_snippet_3\n\nLANGUAGE: R\nCODE:\n```\ncase_when(TRUE ~ 1, TRUE ~ \"x\")\n```\n\n----------------------------------------\n\nTITLE: Testing Error Handling for Inlined and Non-inlined Lambdas\nDESCRIPTION: These snippets test error handling for inlined and non-inlined lambda functions in `across()` within `duckplyr_mutate()`.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-across.md#2025-04-21_snippet_7\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(df %>% duckplyr_mutate(across(1:2, ~ .y + mean(bar)))))\n```\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(df %>% duckplyr_mutate((across(1:2, ~ .y + mean(bar))))))\n```\n\n----------------------------------------\n\nTITLE: Implementing compute Method for data.frame\nDESCRIPTION: A basic implementation of the compute method for data.frame objects that returns the input data frame unchanged. This function serves as a pass-through operation, maintaining the original data structure.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/compute.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\ncompute.data.frame <- function(x, ...) {\n  x\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Type Casting in duckplyr_rows_append\nDESCRIPTION: This snippet checks if duckplyr_rows_append correctly handles type casting and throws appropriate errors for incompatible types.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-rows.md#2025-04-21_snippet_4\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(duckplyr_rows_append(x, y)))\n```\n\n----------------------------------------\n\nTITLE: Converting Factor Columns to DuckDB Relations - Error Handling\nDESCRIPTION: Demonstrates that trying to convert a dataframe with factor columns to a DuckDB relation via as_duckdb_tibble() results in an error.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/relational-duckdb.md#2025-04-21_snippet_1\n\nLANGUAGE: r\nCODE:\n```\nas_duckdb_tibble(data.frame(a = factor(letters)))\n```\n\n----------------------------------------\n\nTITLE: Testing Error Handling in duckplyr_mutate Function\nDESCRIPTION: This snippet demonstrates how duckplyr_mutate handles an error when an undefined function is called. It shows that the error is not enriched and returns a basic 'function not found' message.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-conditions.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nduckplyr_mutate(mtcars, !!foobarbaz())\n```\n\n----------------------------------------\n\nTITLE: Testing duckplyr_arrange Validation for Non-String Locale\nDESCRIPTION: Test case verifying that duckplyr_arrange validates that the .locale parameter must be a string or NULL, not a numeric value.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-arrange.md#2025-04-21_snippet_4\n\nLANGUAGE: r\nCODE:\n```\nduckplyr_arrange(df, .locale = 1)\n```\n\n----------------------------------------\n\nTITLE: Testing pick_wrapper() with No Selectors in duckplyr_mutate()\nDESCRIPTION: Tests error handling when a wrapper around `pick()` is called without any selectors inside `duckplyr_mutate()`. Shows that the error is properly propagated through the wrapper.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-pick.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\nduckplyr_mutate(df, y = pick_wrapper())\n```\n\n----------------------------------------\n\nTITLE: Testing order_by() with symbol instead of function call\nDESCRIPTION: Tests that order_by() correctly rejects a symbol input and suggests using arrange() as an alternative in the error message.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-order-by.md#2025-04-21_snippet_1\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(order_by(mtcars, cyl)))\n```\n\n----------------------------------------\n\nTITLE: Testing join_rows() error handling for incompatible types in R\nDESCRIPTION: This snippet tests the error handling of join_rows() when incompatible types are passed, expecting an internal error that should have been handled by join_cast_common().\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-join-rows.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(join_rows(data.frame(x = 1), data.frame(x = factor(\"a\")))))\n```\n\n----------------------------------------\n\nTITLE: Testing Incompatible Parameters .by and .preserve in duckplyr_filter()\nDESCRIPTION: Tests that duckplyr_filter() throws an error when both .by and .preserve parameters are supplied together. These parameters are mutually exclusive and cannot be used simultaneously.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-filter.md#2025-04-21_snippet_3\n\nLANGUAGE: r\nCODE:\n```\nduckplyr_filter(df, .by = x, .preserve = TRUE)\n```\n\n----------------------------------------\n\nTITLE: Testing Non-Vector Input Error in consecutive_id Function in R\nDESCRIPTION: This test case confirms that consecutive_id properly validates input types and rejects non-vector arguments. It verifies that an appropriate error message is produced when a function is passed instead of a vector.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-consecutive-id.md#2025-04-21_snippet_2\n\nLANGUAGE: r\nCODE:\n```\nconsecutive_id(mean)\n```\n\n----------------------------------------\n\nTITLE: Testing join_rows() overflow error handling in R\nDESCRIPTION: This snippet tests the error handling of join_rows() when the join would result in more rows than dplyr can handle, providing a helpful error message.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-join-rows.md#2025-04-21_snippet_10\n\nLANGUAGE: R\nCODE:\n```\njoin_rows(df, df, condition = \">=\")\n```\n\n----------------------------------------\n\nTITLE: Testing Column Order in Equality\nDESCRIPTION: Shows how column order affects equality comparisons when ignore_col_order parameter is set to FALSE.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-all-equal.md#2025-04-21_snippet_5\n\nLANGUAGE: r\nCODE:\n```\nall_equal(tibble(a = 1, b = 2), tibble(b = 2, a = 1), ignore_col_order = FALSE)\nall_equal(tibble(a = 1, b = 2), tibble(a = 1), ignore_col_order = FALSE)\n```\n\n----------------------------------------\n\nTITLE: Testing Empty Arguments Error in n_distinct() Function in R\nDESCRIPTION: Tests the error message when n_distinct() is called without any arguments. The function requires at least one argument to be supplied via the ellipsis (...) parameter.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-n-distinct.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\nn_distinct()\n```\n\n----------------------------------------\n\nTITLE: Testing Error Handling for Vector Recycling in duckplyr_reframe()\nDESCRIPTION: Demonstrates how duckplyr_reframe() handles vector recycling errors when vectors of incompatible lengths are provided. Shows error message when trying to recycle a vector of length 3 with a vector of length 2.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-reframe.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\nduckplyr_reframe(df, x = 1:2, y = 3:5)\n```\n\n----------------------------------------\n\nTITLE: Restoring original dplyr methods in R\nDESCRIPTION: Calls the methods_restore() function to revert back to the original dplyr methods after they have been overwritten by duckplyr methods. This function displays a confirmation message about the restoration.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/overwrite.md#2025-04-21_snippet_1\n\nLANGUAGE: r\nCODE:\n```\nmethods_restore()\n```\n\n----------------------------------------\n\nTITLE: Testing Missing Conditions in case_match()\nDESCRIPTION: Tests error handling when case_match() is called without any conditions or with NULL as a condition.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-case-match.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\ncase_match(1)\n```\n\nLANGUAGE: r\nCODE:\n```\ncase_match(1, NULL)\n```\n\n----------------------------------------\n\nTITLE: Testing pick() with Invalid Tidy-Selection in duckplyr_filter()\nDESCRIPTION: Tests error handling when using `pick()` with both valid and invalid column names inside `duckplyr_filter()`. Should indicate which column doesn't exist.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-pick.md#2025-04-21_snippet_9\n\nLANGUAGE: R\nCODE:\n```\nduckplyr_filter(df, pick(x, a))\n```\n\n----------------------------------------\n\nTITLE: Displaying the Full Materialized Output in duckplyr\nDESCRIPTION: Code to display the full materialized output after computation. This shows that duckplyr results are stable once materialized, though the initial order may differ from dplyr due to implementation differences.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/index.md#2025-04-21_snippet_9\n\nLANGUAGE: r\nCODE:\n```\nout\n#> [38;5;246m# A tibble: 6 × 4[39m\n#>    [1myear[22m [1mmonth[22m [1mmean_inflight_delay[22m [1mmedian_inflight_delay[22m\n#>   [3m[38;5;246m<int>[39m[23m [3m[38;5;246m<int>[39m[23m               [3m[38;5;246m<dbl>[39m[23m                 [3m[38;5;246m<dbl>[39m[23m\n#> [38;5;250m1[39m  [4m2[24m013     1               -[31m3[39m[31m.[39m[31m86[39m                    -[31m5[39m\n#> [38;5;250m2[39m  [4m2[24m013     2               -[31m5[39m[31m.[39m[31m15[39m                    -[31m6[39m\n#> [38;5;250m3[39m  [4m2[24m013     3               -[31m7[39m[31m.[39m[31m36[39m                    -[31m9[39m\n#> [38;5;250m4[39m  [4m2[24m013     4               -[31m2[39m[31m.[39m[31m67[39m                    -[31m5[39m\n#> [38;5;250m5[39m  [4m2[24m013     5               -[31m9[39m[31m.[39m[31m37[39m                   -[31m10[39m\n#> [38;5;250m6[39m  [4m2[24m013     6               -[31m4[39m[31m.[39m[31m24[39m                    -[31m7[39m\n```\n\n----------------------------------------\n\nTITLE: Testing join_rows() with unmatched missing values in R\nDESCRIPTION: These snippets test join_rows() handling of unmatched missing values with various join types and na_matches settings, expecting errors in all cases.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-join-rows.md#2025-04-21_snippet_7\n\nLANGUAGE: R\nCODE:\n```\njoin_rows(data.frame(x = 1), data.frame(x = NA), type = \"left\", unmatched = \"error\", na_matches = \"na\")\n```\n\nLANGUAGE: R\nCODE:\n```\njoin_rows(data.frame(x = NA), data.frame(x = NA), type = \"left\", unmatched = \"error\", na_matches = \"never\")\n```\n\nLANGUAGE: R\nCODE:\n```\njoin_rows(data.frame(x = 1), data.frame(x = NA), type = \"nest\", unmatched = \"error\", na_matches = \"na\")\n```\n\nLANGUAGE: R\nCODE:\n```\njoin_rows(data.frame(x = NA), data.frame(x = NA), type = \"nest\", unmatched = \"error\", na_matches = \"never\")\n```\n\nLANGUAGE: R\nCODE:\n```\njoin_rows(data.frame(x = NA), data.frame(x = 1), type = \"right\", unmatched = \"error\", na_matches = \"na\")\n```\n\nLANGUAGE: R\nCODE:\n```\njoin_rows(data.frame(x = NA), data.frame(x = NA), type = \"right\", unmatched = \"error\", na_matches = \"never\")\n```\n\nLANGUAGE: R\nCODE:\n```\njoin_rows(data.frame(x = 1), data.frame(x = c(1, NA)), type = \"inner\", unmatched = \"error\", na_matches = \"na\")\n```\n\nLANGUAGE: R\nCODE:\n```\njoin_rows(data.frame(x = 1), data.frame(x = c(1, NA)), type = \"inner\", unmatched = c(\"drop\", \"error\"), na_matches = \"na\")\n```\n\nLANGUAGE: R\nCODE:\n```\njoin_rows(data.frame(x = c(1, NA)), data.frame(x = 1), type = \"inner\", unmatched = \"error\", na_matches = \"na\")\n```\n\nLANGUAGE: R\nCODE:\n```\njoin_rows(data.frame(x = c(1, NA)), data.frame(x = 1), type = \"inner\", unmatched = c(\"error\", \"drop\"), na_matches = \"na\")\n```\n\nLANGUAGE: R\nCODE:\n```\njoin_rows(data.frame(x = NA), data.frame(x = NA), type = \"inner\", unmatched = \"error\", na_matches = \"never\")\n```\n\n----------------------------------------\n\nTITLE: Testing Non-Vector Input Error in n_distinct() Function in R\nDESCRIPTION: Tests the error message when n_distinct() is called with a function instead of a vector. The function explicitly requires vector inputs.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-n-distinct.md#2025-04-21_snippet_2\n\nLANGUAGE: r\nCODE:\n```\nn_distinct(mean)\n```\n\n----------------------------------------\n\nTITLE: Testing cur_column() Function Error Message in R\nDESCRIPTION: Tests that cur_column() function throws appropriate error when used outside across().\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-context.md#2025-04-21_snippet_1\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(cur_column()))\n```\n\n----------------------------------------\n\nTITLE: Testing duckplyr_arrange Error with Duplicate Column Names\nDESCRIPTION: Test case that verifies duckplyr_arrange produces a meaningful error when encountering duplicate column names in a tibble.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-arrange.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(tibble(x = 1, x = 1, .name_repair = \"minimal\") %>%\n  duckplyr_arrange(x)))\n```\n\n----------------------------------------\n\nTITLE: Testing Error Handling for Non-Unique Names in duckplyr_mutate with across()\nDESCRIPTION: This snippet tests the error handling when using `across()` with `.unpack` option that results in non-unique column names.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-across.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nduckplyr_mutate(df, across(x:y, fn, .unpack = \"{outer}\"))\n```\n\n----------------------------------------\n\nTITLE: Testing pick() with Renaming Attempt\nDESCRIPTION: Tests error handling when trying to rename variables using `pick()` inside `duckplyr_mutate()`. Should indicate that renaming isn't allowed in this context.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-pick.md#2025-04-21_snippet_5\n\nLANGUAGE: R\nCODE:\n```\nduckplyr_mutate(data.frame(x = 1), pick(y = x))\n```\n\n----------------------------------------\n\nTITLE: Testing Default Column Selection in rows_check_by\nDESCRIPTION: This snippet checks if rows_check_by correctly uses the first column from the source dataframe by default and provides an appropriate message.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-rows.md#2025-04-21_snippet_20\n\nLANGUAGE: R\nCODE:\n```\nby <- rows_check_by(by = NULL, y = y)\n```\n\n----------------------------------------\n\nTITLE: Testing join_rows() with one-to-one relationship errors in R\nDESCRIPTION: These snippets test join_rows() with a one-to-one relationship, expecting errors when multiple matches are found in either direction.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-join-rows.md#2025-04-21_snippet_3\n\nLANGUAGE: R\nCODE:\n```\njoin_rows(1, c(1, 1), relationship = \"one-to-one\")\n```\n\nLANGUAGE: R\nCODE:\n```\njoin_rows(c(1, 1), 1, relationship = \"one-to-one\")\n```\n\n----------------------------------------\n\nTITLE: Testing order_by Parameter Size Validation in nth Function\nDESCRIPTION: Tests that verify the nth function validates that the order_by parameter must be the same size as the input vector x.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-nth-value.md#2025-04-21_snippet_5\n\nLANGUAGE: r\nCODE:\n```\nnth(1:5, n = 1L, order_by = 1:2)\n```\n\nLANGUAGE: r\nCODE:\n```\nnth(1:5, n = 6L, order_by = 1:2)\n```\n\n----------------------------------------\n\nTITLE: Testing pick() Outside Data-Masking Context\nDESCRIPTION: Tests error handling when `pick()` is called outside of data-masking verbs like `mutate()`, `filter()`, and `group_by()`. Should produce an appropriate error message.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-pick.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\npick()\n```\n\n----------------------------------------\n\nTITLE: Testing desc() Function with Single Column in DuckDB\nDESCRIPTION: Test case demonstrating how desc() fails when pointing to an external reference in duckplyr with stingy prudence setting.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/handle_desc.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\nduckdb_tibble(a = 1:3, .prudence = \"stingy\") %>% arrange(desc(a))\n```\n\n----------------------------------------\n\nTITLE: Printing R Object in duckplyr Test\nDESCRIPTION: This snippet shows the output of printing an R object 'z', which appears to be a data frame or tibble with a single column 'a' containing the value 1. The output is formatted as would appear in an R console after using collect() to materialize a lazy query.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/duckplyr.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nprint(z)\n```\n\n----------------------------------------\n\nTITLE: Testing order_by() with non-function call numeric input\nDESCRIPTION: Tests that order_by() correctly rejects a numeric value instead of a function call and provides a meaningful error message.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-order-by.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(order_by(mtcars, 10)))\n```\n\n----------------------------------------\n\nTITLE: Creating Constant Value Expressions in duckplyr\nDESCRIPTION: Creates a relational expression for a constant numeric value. The function returns a list containing the constant value, NULL alias, and appropriate class attributes.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/expr.md#2025-04-21_snippet_1\n\nLANGUAGE: r\nCODE:\n```\nrelexpr_constant(42)\n```\n\n----------------------------------------\n\nTITLE: Testing duckplyr_slice Validation\nDESCRIPTION: Tests error handling for mixed positive/negative indices, matrix slicing deprecation, and non-numeric indices in duckplyr_slice function.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-slice.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nduckplyr_slice(tibble(), 1, -1)\nduckplyr_slice(df, matrix(c(1, 3)))\nduckplyr_slice(tibble(), \"a\")\n```\n\n----------------------------------------\n\nTITLE: Setting environment variable for method overwriting in R\nDESCRIPTION: If the environment variable DUCKPLYR_METHODS_OVERWRITE is set to TRUE, loading duckplyr automatically calls methods_overwrite().\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/NEWS.md#2025-04-21_snippet_3\n\nLANGUAGE: R\nCODE:\n```\nSys.setenv(DUCKPLYR_METHODS_OVERWRITE = \"TRUE\")\n```\n\n----------------------------------------\n\nTITLE: Testing desc() Function with Multiple Columns in DuckDB\nDESCRIPTION: Test case showing how desc() fails when attempting to use multiple arguments in duckplyr with stingy prudence setting.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/handle_desc.md#2025-04-21_snippet_1\n\nLANGUAGE: r\nCODE:\n```\nduckdb_tibble(a = 1:3, b = 4:6, .prudence = \"stingy\") %>% arrange(desc(a, b))\n```\n\n----------------------------------------\n\nTITLE: Testing pick_wrapper() with Renaming Attempt\nDESCRIPTION: Tests error handling when trying to rename variables using a wrapper around `pick()` inside `duckplyr_mutate()`. Shows error propagation through wrapper.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-pick.md#2025-04-21_snippet_6\n\nLANGUAGE: R\nCODE:\n```\nduckplyr_mutate(data.frame(x = 1), pick_wrapper(y = x))\n```\n\n----------------------------------------\n\nTITLE: Using as_duckdb_tibble() with rowwise data frames in R\nDESCRIPTION: Shows the error when attempting to convert a rowwise data frame to a DuckDB-backed tibble. The error indicates that rowwise() is not supported and suggests converting to a regular tibble first.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/ducktbl.md#2025-04-21_snippet_1\n\nLANGUAGE: r\nCODE:\n```\nas_duckdb_tibble(dplyr::rowwise(mtcars))\n```\n\n----------------------------------------\n\nTITLE: Testing get_slice_size Function\nDESCRIPTION: Validates the get_slice_size function behavior with various inputs, including proper handling of proportions and numeric values.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-slice.md#2025-04-21_snippet_3\n\nLANGUAGE: R\nCODE:\n```\nget_slice_size(n = 1, prop = 1)\nget_slice_size(n = \"a\")\nget_slice_size(prop = \"a\")\n```\n\n----------------------------------------\n\nTITLE: Testing across() with .funs Parameter\nDESCRIPTION: Shows that using the deprecated .funs parameter with non-empty dots triggers an error in across(), as the function expects .fns instead.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-across.md#2025-04-21_snippet_12\n\nLANGUAGE: r\nCODE:\n```\nduckplyr_mutate(df, across(x, .funs = ~ . * 1000))\n```\n\n----------------------------------------\n\nTITLE: Testing Result Size Validation in DuckplyrRenameWith\nDESCRIPTION: Tests error handling when .fn returns a vector of incorrect length (3 instead of expected 2)\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-rename.md#2025-04-21_snippet_1\n\nLANGUAGE: r\nCODE:\n```\nduckplyr_rename_with(df, fn)\n```\n\n----------------------------------------\n\nTITLE: Defining auto_copy function for data frames in R\nDESCRIPTION: This function auto_copy.data.frame takes a data frame x, an object y, and optional parameters. It converts y to a data frame using as.data.frame() and returns the result. The x parameter and copy flag are not used in the function body.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/dplyr-methods/auto_copy.txt#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nauto_copy.data.frame <- function(x, y, copy = FALSE, ...) {\n  as.data.frame(y)\n}\n```\n\n----------------------------------------\n\nTITLE: Testing intersect with duckplyr in R\nDESCRIPTION: Demonstrates intersect operation using duckplyr, expecting an error with telemetry data.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/telemetry.md#2025-04-21_snippet_7\n\nLANGUAGE: R\nCODE:\n```\nduckdb_tibble(a = 1:3, b = 4:6) %>% intersect(tibble(a = 1:3, b = 4:6))\n```\n\n----------------------------------------\n\nTITLE: Testing Matrix Column Handling with Deprecation Warning in duckplyr_filter()\nDESCRIPTION: Tests that duckplyr_filter() allows matrices with 1 column but displays a deprecation warning. The function accepts the input but warns users to use one-dimensional logical vectors instead.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-filter.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\nout <- duckplyr_filter(df, matrix(c(TRUE, FALSE), nrow = 2))\n```\n\n----------------------------------------\n\nTITLE: Testing tidyselect Error for Non-existent Column in R\nDESCRIPTION: Verifies that compute_by throws an appropriate error when attempting to select a column that doesn't exist in the dataframe.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-by.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\ncompute_by(by = y, data = df)\n```\n\n----------------------------------------\n\nTITLE: Testing Deprecated all_equal Function\nDESCRIPTION: Demonstrates that all_equal() is deprecated in dplyr 1.1.0 and shows warning message recommending all.equal() instead.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-all-equal.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\nall_equal(mtcars, mtcars)\n```\n\n----------------------------------------\n\nTITLE: Testing Column Overwrite in duckplyr_summarise (R)\nDESCRIPTION: This snippet tests the behavior of duckplyr_summarise when attempting to overwrite a column using active bindings. It expects an error to be thrown.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-summarise.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nduckplyr_summarise(df, y = {\n  x <<- x + 2L\n  mean(x)\n})\n```\n\n----------------------------------------\n\nTITLE: Testing Named Argument Translation Error in duckplyr\nDESCRIPTION: Demonstrates that the rel_translate function cannot translate the c() function with named arguments. The test shows the expected error message when attempting to translate a call to c() with a named parameter.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/translate.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\nrel_translate(quo(c(1, b = 2)))\n```\n\n----------------------------------------\n\nTITLE: Validating Key Uniqueness in duckplyr_rows_patch\nDESCRIPTION: This snippet tests if duckplyr_rows_patch correctly handles and reports errors for duplicate keys in the source dataframe.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-rows.md#2025-04-21_snippet_11\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(duckplyr_rows_patch(x, y, by = \"a\")))\n```\n\n----------------------------------------\n\nTITLE: Testing default Parameter Size Validation in nth Function\nDESCRIPTION: Tests that verify the nth function validates that the default parameter must be of size 1 when not used with lists.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-nth-value.md#2025-04-21_snippet_1\n\nLANGUAGE: r\nCODE:\n```\nnth(1L, n = 2L, default = 1:2)\n```\n\n----------------------------------------\n\nTITLE: Converting Tibble to duckplyr Tibble in R\nDESCRIPTION: This snippet tests the as_duckplyr_tibble() function, which is deprecated. It converts a simple tibble to a duckplyr data frame, triggering a deprecation warning.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/as_duckplyr_tibble.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nas_duckplyr_tibble(tibble(a = 1))\n```\n\n----------------------------------------\n\nTITLE: Retrieving R File Contents with Repository Details\nDESCRIPTION: SQL query to join file metadata with actual content from the GitHub datasets. Creates the final tinker.r_contents table available for download.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/gh-analysis/README.md#2025-04-21_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\nSELECT\n  r_files.repo_name AS repo_name,\n  r_files.path AS path,\n  r_files.id AS id,\n  content,\n  binary\nFROM\n  tinker.r_files\nLEFT JOIN\n  `bigquery-public-data.github_repos.contents`\nUSING\n  (id)\n```\n\n----------------------------------------\n\nTITLE: Testing Error for Grouped DataFrame in R\nDESCRIPTION: Verifies that compute_by throws an appropriate error when attempting to use .by with an already grouped dataframe.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-by.md#2025-04-21_snippet_1\n\nLANGUAGE: r\nCODE:\n```\ncompute_by(x, gdf)\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variable Example in R\nDESCRIPTION: Example of setting environment variable for DuckPlyr fallback information display\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/NEWS.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nSys.setenv(DUCKPLYR_FALLBACK_INFO = TRUE)\n```\n\n----------------------------------------\n\nTITLE: Testing pick() with No Selectors in duckplyr_mutate()\nDESCRIPTION: Tests error handling when `pick()` is called without any selectors inside a `duckplyr_mutate()` function. Should require at least one input to `pick()`.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-pick.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nduckplyr_mutate(df, y = pick())\n```\n\n----------------------------------------\n\nTITLE: Testing duckplyr_transmute() with unsupported .after argument\nDESCRIPTION: This test verifies that duckplyr_transmute() produces an appropriate error message when the .after argument is used, which is not supported in this implementation.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-transmute.md#2025-04-21_snippet_2\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(duckplyr_transmute(mtcars, cyl2 = cyl, .after = disp)))\n```\n\n----------------------------------------\n\nTITLE: Testing Named Arguments Error in n_distinct() Function in R\nDESCRIPTION: Tests the error message when n_distinct() is called with named arguments. The function requires arguments to be passed by position only, not by name.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-n-distinct.md#2025-04-21_snippet_1\n\nLANGUAGE: r\nCODE:\n```\nn_distinct(x = 1:4)\n```\n\n----------------------------------------\n\nTITLE: DuckPlyr File Path Environment Variable in R\nDESCRIPTION: Example showing the environment variable used to control DuckPlyr temporary directory location\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/NEWS.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\nDUCKPLYR_TEMP_DIR\n```\n\n----------------------------------------\n\nTITLE: Testing Error on Multi-Dimensional Arrays in duckplyr_filter()\nDESCRIPTION: Tests that duckplyr_filter() rejects arrays with more than 2 dimensions. The function should throw an error specifying that it requires a logical vector, not a logical array.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-filter.md#2025-04-21_snippet_2\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(duckplyr_filter(df, array(TRUE, dim = c(3, 1, 1)))))\n```\n\n----------------------------------------\n\nTITLE: Testing ptype Override in if_else() Function in R\nDESCRIPTION: This snippet tests the 'ptype' parameter in if_else(), which overrides the common type. It shows that attempting to convert incompatible types results in an error.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-if-else.md#2025-04-21_snippet_5\n\nLANGUAGE: R\nCODE:\n```\nif_else(TRUE, 1L, 2.5, ptype = integer())\n```\n\n----------------------------------------\n\nTITLE: Converting Custom Vector Types to DuckDB Relations - Error Handling\nDESCRIPTION: Shows that attempting to convert a dataframe containing a custom vctrs_vctr type to a DuckDB relation results in an error.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/relational-duckdb.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\ndata.frame(a = vctrs::new_vctr(1:3)) %>% duckdb_rel_from_df()\n```\n\n----------------------------------------\n\nTITLE: Testing Key Existence Validation in duckplyr_rows_patch\nDESCRIPTION: This snippet checks if duckplyr_rows_patch correctly validates that keys in the source dataframe exist in the target dataframe by default.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-rows.md#2025-04-21_snippet_10\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(duckplyr_rows_patch(x, y, \"a\")))\n```\n\n----------------------------------------\n\nTITLE: Testing Vector Type Requirement for x in na_if Function in R\nDESCRIPTION: Tests that na_if properly rejects non-vector inputs for the x parameter, ensuring the function only works with proper vector types.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-na-if.md#2025-04-21_snippet_4\n\nLANGUAGE: r\nCODE:\n```\nna_if(environment(), 1)\n```\n\n----------------------------------------\n\nTITLE: Testing Anonymous Function Access to .data Pronoun in across()\nDESCRIPTION: Tests that anonymous functions in the .fns argument cannot access the .data pronoun when not inlined, resulting in an error.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-across.md#2025-04-21_snippet_8\n\nLANGUAGE: r\nCODE:\n```\nduckplyr_mutate(df, across(y, fn))\n```\n\n----------------------------------------\n\nTITLE: Testing if_any() and if_all() Default Columns Warning\nDESCRIPTION: Demonstrates that using if_any() without explicitly supplying .cols triggers a deprecation warning, as the default value of everything() is deprecated since dplyr 1.1.0.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-across.md#2025-04-21_snippet_11\n\nLANGUAGE: r\nCODE:\n```\nout <- duckplyr_filter(df, if_any())\n```\n\n----------------------------------------\n\nTITLE: Join Mutate Argument Validation\nDESCRIPTION: Tests input validation for join_mutate function, checking handling of invalid by, suffix, na_matches, and keep parameters.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-join.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\njoin_mutate(df, df, by = 1, type = \"left\")\njoin_mutate(df, df, by = \"x\", type = \"left\", suffix = 1)\njoin_mutate(df, df, by = \"x\", type = \"left\", na_matches = \"foo\")\njoin_mutate(df, df, by = \"x\", type = \"left\", keep = 1)\n```\n\n----------------------------------------\n\nTITLE: Testing DuckPlyr Relocate Invalid Parameters in R\nDESCRIPTION: Shows error handling when attempting to use both .before and .after parameters in duckplyr_relocate function. The function throws an error since these parameters are mutually exclusive.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-relocate.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\nduckplyr_relocate(df, .before = 1, .after = 1)\n```\n\n----------------------------------------\n\nTITLE: Testing x Parameter Type Validation in nth Function\nDESCRIPTION: Tests that verify the nth function validates that the x parameter must be a vector and not other types like environment.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-nth-value.md#2025-04-21_snippet_4\n\nLANGUAGE: r\nCODE:\n```\nnth(environment(), 1L)\n```\n\n----------------------------------------\n\nTITLE: Testing Type Casting in duckplyr_rows_patch\nDESCRIPTION: This snippet checks how duckplyr_rows_patch handles type casting for keys and values, ensuring appropriate error messages for incompatible types.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-rows.md#2025-04-21_snippet_12\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(duckplyr_rows_patch(x, y, \"key\")))\n```\n\n----------------------------------------\n\nTITLE: Testing Named Arguments Error in consecutive_id Function in R\nDESCRIPTION: This test verifies that consecutive_id correctly rejects named arguments. The function expects all arguments to be passed by position only, and this test confirms it raises an appropriate error when named arguments are provided.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-consecutive-id.md#2025-04-21_snippet_1\n\nLANGUAGE: r\nCODE:\n```\nconsecutive_id(x = 1:4)\n```\n\n----------------------------------------\n\nTITLE: Validating 'by' Parameter in rows_check_by\nDESCRIPTION: This snippet tests the validation of the 'by' parameter in rows_check_by, ensuring it only accepts valid options and formats.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-rows.md#2025-04-21_snippet_21\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(rows_check_by(by = 1, y = y)))\n```\n\n----------------------------------------\n\nTITLE: Testing Invalid Numeric Operation in DuckPlyr Select - R\nDESCRIPTION: Tests the error handling of duckplyr_select() when attempting to perform an invalid numeric operation (adding a number to an empty string). Expects an error message about non-numeric argument to binary operator.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-select.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(duckplyr_select(mtcars, 1 + \"\")))\n```\n\n----------------------------------------\n\nTITLE: Testing duckplyr_arrange Validation for Invalid Locale\nDESCRIPTION: Test case verifying that duckplyr_arrange validates that the .locale parameter must be one of the locales from stringi::stri_locale_list().\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-arrange.md#2025-04-21_snippet_6\n\nLANGUAGE: r\nCODE:\n```\nduckplyr_arrange(df, .locale = \"x\")\n```\n\n----------------------------------------\n\nTITLE: Testing Size Stability with Mismatched Vector Sizes in na_if Function in R\nDESCRIPTION: Tests that na_if properly rejects cases where the size of y cannot be recycled to match the size of x. These tests ensure vector length compatibility is enforced.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-na-if.md#2025-04-21_snippet_2\n\nLANGUAGE: r\nCODE:\n```\nna_if(1, c(1, 2))\n```\n\n----------------------------------------\n\nTITLE: Validating Vector Input for lag() Function in R\nDESCRIPTION: This test ensures that lag() function requires the input 'x' to be a vector and throws an error when a non-vector (in this case, an environment) is provided.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-lead-lag.md#2025-04-21_snippet_6\n\nLANGUAGE: R\nCODE:\n```\nlag(environment())\n```\n\n----------------------------------------\n\nTITLE: Testing Renaming During Selection in c_across()\nDESCRIPTION: Demonstrates that attempting to rename variables during selection within c_across() is not supported and generates an error.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-across.md#2025-04-21_snippet_9\n\nLANGUAGE: r\nCODE:\n```\nduckplyr_mutate(df, z = c_across(c(y = x)))\n```\n\n----------------------------------------\n\nTITLE: Testing Column Overwrite with Grouping in duckplyr_summarise (R)\nDESCRIPTION: This snippet tests the behavior of duckplyr_summarise when attempting to overwrite a column using active bindings, with grouping. It expects an error to be thrown.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-summarise.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\nduckplyr_summarise(df, .by = g, y = {\n  x <<- x + 2L\n  mean(x)\n})\n```\n\n----------------------------------------\n\nTITLE: Validating 'n' Parameter in lag() Function in R\nDESCRIPTION: These tests check if lag() function properly validates the 'n' parameter. It tests for errors when 'n' is a vector or a negative number.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-lead-lag.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\nlag(1:5, n = 1:2)\n```\n\nLANGUAGE: R\nCODE:\n```\nlag(1:5, -1)\n```\n\n----------------------------------------\n\nTITLE: Testing Error Handling for Misuse of Predicates in if_any() and if_all()\nDESCRIPTION: These snippets test error handling when predicates are mistakenly used as column selections in `if_any()` and `if_all()`.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-across.md#2025-04-21_snippet_6\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(duckplyr_filter(df, if_any(~ .x > 5))))\n```\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(duckplyr_filter(df, if_all(~ .x > 5))))\n```\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(duckplyr_filter(df, !if_any(~ .x > 5))))\n```\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(duckplyr_filter(df, !if_all(~ .x > 5))))\n```\n\n----------------------------------------\n\nTITLE: Testing Size Mismatch Error in Coalesce\nDESCRIPTION: Verifies that coalesce() throws appropriate error when input vectors have incompatible sizes\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-coalesce.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(coalesce(1:2, 1:3)))\n```\n\n----------------------------------------\n\nTITLE: Testing right_join with DuckPlyr\nDESCRIPTION: Testing right join operation between duckdb_tibble and regular tibble with various parameters\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/telemetry.md#2025-04-21_snippet_12\n\nLANGUAGE: R\nCODE:\n```\nduckdb_tibble(a = 1:3, b = 4:6) %>% right_join(tibble(a = 1:3, b = 4:6))\n```\n\nLANGUAGE: R\nCODE:\n```\nduckdb_tibble(a = 1:3, b = 4:6) %>% right_join(tibble(a = 1:3, b = 4:6), by = \"a\", copy = TRUE, suffix = c(\"x\", \"y\"), keep = TRUE, na_matches = \"na\", multiple = \"all\", unmatched = \"error\", relationship = \"one-to-one\")\n```\n\n----------------------------------------\n\nTITLE: Testing Size Override Error in Coalesce\nDESCRIPTION: Verifies that coalesce() respects the .size parameter and throws error on size mismatch\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-coalesce.md#2025-04-21_snippet_2\n\nLANGUAGE: r\nCODE:\n```\ncoalesce(x, 1:2, .size = vec_size(x))\n```\n\n----------------------------------------\n\nTITLE: Testing Result Type Validation in DuckplyrRenameWith\nDESCRIPTION: Tests error handling when .fn returns an incorrect type (integer instead of character vector)\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-rename.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\nduckplyr_rename_with(df, fn)\n```\n\n----------------------------------------\n\nTITLE: Testing Non-equi Join Conditions with keep=FALSE\nDESCRIPTION: Verifies that using keep=FALSE with non-equi conditions (overlaps) throws appropriate errors in left and full joins.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-join.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nduckplyr_left_join(df1, df2, join_by(overlaps(xl, xu, yl, yu)), keep = FALSE)\nduckplyr_full_join(df1, df2, join_by(overlaps(xl, xu, yl, yu)), keep = FALSE)\n```\n\n----------------------------------------\n\nTITLE: Running Analysis Scripts\nDESCRIPTION: Bash command demonstrating how to execute the analysis scripts from the project root directory in a fresh R session.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/gh-analysis/README.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nR -q -f gh-analysis/60-gh.R\n```\n\n----------------------------------------\n\nTITLE: Testing duckplyr_transmute() with unsupported .keep argument\nDESCRIPTION: This test verifies that duckplyr_transmute() produces an appropriate error message when the .keep argument is used, which is not supported in this implementation.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-transmute.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(duckplyr_transmute(mtcars, cyl2 = cyl, .keep = \"all\")))\n```\n\n----------------------------------------\n\nTITLE: Testing Invalid Additional Arguments in Joins\nDESCRIPTION: Verifies that passing additional unexpected arguments to various join functions results in appropriate error messages.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-join.md#2025-04-21_snippet_3\n\nLANGUAGE: R\nCODE:\n```\nduckplyr_inner_join(df1, df2, on = \"a\")\nduckplyr_left_join(df1, df2, on = \"a\")\nduckplyr_right_join(df1, df2, on = \"a\")\nduckplyr_full_join(df1, df2, on = \"a\")\nduckplyr_nest_join(df1, df2, on = \"a\")\nduckplyr_anti_join(df1, df2, on = \"a\")\nduckplyr_semi_join(df1, df2, on = \"a\")\n```\n\n----------------------------------------\n\nTITLE: Testing Date Operations with DuckPLYR\nDESCRIPTION: Shows fallback behavior when using date manipulation functions like wday() and strftime() with unsupported parameters.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/fallback.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\nduckdb_tibble(a = as.Date(\"2024-03-08\")) %>% mutate(b = lubridate::wday(a, label = TRUE))\n```\n\nLANGUAGE: R\nCODE:\n```\nduckdb_tibble(a = as.Date(\"2024-03-08\")) %>% mutate(b = strftime(a, format = \"%Y-%m-%d\", tz = \"CET\"))\n```\n\n----------------------------------------\n\nTITLE: Attempting to Convert Grouped Data Frame to duckplyr DataFrame in R\nDESCRIPTION: This snippet tests the as_duckplyr_df() function with a grouped data frame (by_cyl). It demonstrates that the function is deprecated and cannot handle grouped data frames, resulting in an error.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/as_duckplyr_tibble.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\nas_duckplyr_df(by_cyl)\n```\n\n----------------------------------------\n\nTITLE: Creating Empty Relational Object in R\nDESCRIPTION: This code snippet shows how to create a new empty relational object using the new_relational() function. The function takes an empty list as input and returns it with an added 'relational' class attribute.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/relational-rel.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nnew_relational(list())\n```\n\n----------------------------------------\n\nTITLE: Overwriting dplyr methods with DuckPlyr methods in R\nDESCRIPTION: Calls the methods_overwrite() function to replace dplyr methods with corresponding duckplyr implementations. This function displays a success message and instructions on how to restore the original methods.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/overwrite.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\nmethods_overwrite()\n```\n\n----------------------------------------\n\nTITLE: Testing Incompatible Arguments in duckplyr_summarise (R)\nDESCRIPTION: This snippet tests the behavior of duckplyr_summarise when both .by and .groups arguments are supplied. It expects an error indicating that these arguments can't be used together.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-summarise.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\nduckplyr_summarise(df, .by = x, .groups = \"drop\")\n```\n\n----------------------------------------\n\nTITLE: Testing Error for Rowwise DataFrame in R\nDESCRIPTION: Verifies that compute_by throws an appropriate error when attempting to use .by with a rowwise dataframe.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-by.md#2025-04-21_snippet_2\n\nLANGUAGE: r\nCODE:\n```\ncompute_by(x, rdf)\n```\n\n----------------------------------------\n\nTITLE: Testing Custom Error Arguments in R\nDESCRIPTION: Demonstrates how to customize error messages by specifying custom argument names in the error output.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-by.md#2025-04-21_snippet_3\n\nLANGUAGE: r\nCODE:\n```\ncompute_by(x, gdf, by_arg = \"x\", data_arg = \"dat\")\n```\n\n----------------------------------------\n\nTITLE: Testing join_rows() with many-to-one relationship error in R\nDESCRIPTION: This snippet tests join_rows() with a many-to-one relationship, expecting an error when multiple matches are found in y for a single x value.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-join-rows.md#2025-04-21_snippet_5\n\nLANGUAGE: R\nCODE:\n```\njoin_rows(1, c(1, 1), relationship = \"many-to-one\")\n```\n\n----------------------------------------\n\nTITLE: Testing join_rows() with one-to-many relationship error in R\nDESCRIPTION: This snippet tests join_rows() with a one-to-many relationship, expecting an error when multiple matches are found in x for a single y value.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-join-rows.md#2025-04-21_snippet_4\n\nLANGUAGE: R\nCODE:\n```\njoin_rows(c(1, 1), 1, relationship = \"one-to-many\")\n```\n\n----------------------------------------\n\nTITLE: Using deprecated multiple='error' parameter with duckplyr_left_join function in R\nDESCRIPTION: Example showing deprecation warning when using 'multiple = \"error\"' with the duckplyr_left_join function. This parameter has been deprecated in dplyr 1.1.1 in favor of 'relationship = \"many-to-one\"'. The code generates an error when a row in x matches multiple rows in y.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-join-rows.md#2025-04-21_snippet_13\n\nLANGUAGE: r\nCODE:\n```\nduckplyr_left_join(df1, df2, by = join_by(x), multiple = \"error\")\n```\n\n----------------------------------------\n\nTITLE: Testing deprecated multiple = NULL behavior in join functions in R\nDESCRIPTION: These snippets test the deprecated behavior of setting multiple = NULL in join_rows() and duckplyr_left_join(), expecting a warning and fallback to 'all'.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-join-rows.md#2025-04-21_snippet_11\n\nLANGUAGE: R\nCODE:\n```\nout <- join_rows(df1, df2, multiple = NULL)\n```\n\nLANGUAGE: R\nCODE:\n```\nduckplyr_left_join(df1, df2, by = join_by(x), multiple = NULL)\n```\n\n----------------------------------------\n\nTITLE: Testing Key Duplication in R Join Operations\nDESCRIPTION: This snippet tests the join_cols() function for scenarios where a key is duplicated between equi and non-equi conditions, which should raise an error about unique join columns.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-join-cols.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\njoin_cols(\"x\", c(\"xl\", \"xu\"), by = join_by(x > xl, x == xu))\n\njoin_cols(c(\"xl\", \"xu\"), \"x\", by = join_by(xl < x, xu == x))\n```\n\n----------------------------------------\n\nTITLE: Testing Meaningful Error Messages in across() within duckplyr Functions\nDESCRIPTION: This set of snippets tests various error scenarios to ensure meaningful error messages are provided when using `across()` in duckplyr functions.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-across.md#2025-04-21_snippet_3\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(tibble(x = 1) %>% duckplyr_summarise(across(where(is.numeric), 42))))\n```\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(tibble(x = 1) %>% duckplyr_summarise(across(y, mean))))\n```\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(tibble(x = 1) %>% duckplyr_summarise(res = across(where(is.numeric), 42))))\n```\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(tibble(x = 1) %>% duckplyr_summarise(z = across(y, mean))))\n```\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(tibble(x = 1) %>% duckplyr_summarise(res = sum(if_any(where(is.numeric), 42)))))\n```\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(tibble(x = 1) %>% duckplyr_summarise(res = sum(if_all(~ mean(.x))))))\n```\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(tibble(x = 1) %>% duckplyr_summarise(res = sum(if_any(~ mean(.x))))))\n```\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(across()))\n```\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(c_across()))\n```\n\n----------------------------------------\n\nTITLE: Testing Column Existence in rows_check_by\nDESCRIPTION: This snippet checks if the rows_check_by function correctly validates that the source dataframe has at least one column before using it for matching.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-rows.md#2025-04-21_snippet_19\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(rows_check_by(by = NULL, y = y)))\n```\n\n----------------------------------------\n\nTITLE: Testing pick() with Arguments Outside Data-Masking Context\nDESCRIPTION: Tests error handling when `pick()` is called with arguments outside of data-masking verbs. Should still produce an error about proper context.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-pick.md#2025-04-21_snippet_3\n\nLANGUAGE: R\nCODE:\n```\npick(a, b)\n```\n\n----------------------------------------\n\nTITLE: Testing Incorrect Usage of pick() Result in duckplyr_filter()\nDESCRIPTION: Tests error handling when incorrectly using the result of `pick()` in `duckplyr_filter()`. Should indicate that a double vector is being used where a logical vector is required.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-pick.md#2025-04-21_snippet_11\n\nLANGUAGE: R\nCODE:\n```\nduckplyr_filter(df, pick(x, y)$x)\n```\n\n----------------------------------------\n\nTITLE: Testing %in% Operator Translation Error in duckplyr\nDESCRIPTION: Tests the rel_translate function with the %in% operator, showing that it cannot access data in this context. The test passes a data frame with columns a and b to demonstrate the error condition.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/translate.md#2025-04-21_snippet_1\n\nLANGUAGE: r\nCODE:\n```\nrel_translate(quo(a %in% b), data.frame(a = 1:3, b = 2:4))\n```\n\n----------------------------------------\n\nTITLE: Testing distinct() with unknown column using .data pronoun\nDESCRIPTION: This test verifies that using the .data pronoun with a non-existent column still produces the appropriate error message, showing that the column was not found in the data.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-distinct.md#2025-04-21_snippet_2\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(df %>% duckplyr_distinct(.data$aa)))\n```\n\n----------------------------------------\n\nTITLE: Testing Size Stability with Incompatible Vector Sizes in na_if Function in R\nDESCRIPTION: Tests that na_if properly rejects cases where y's size doesn't match or can't be recycled to match x's size, ensuring vector length compatibility.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-na-if.md#2025-04-21_snippet_3\n\nLANGUAGE: r\nCODE:\n```\nna_if(c(1, 2, 3), c(1, 2))\n```\n\n----------------------------------------\n\nTITLE: Testing Incompatible Data Frames Error in DuckPlyr\nDESCRIPTION: Test cases for error handling when attempting set operations between incompatible data frames with different column counts.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-sets.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\nduckplyr_intersect(df1, df2)\nduckplyr_union(df1, df2)\nduckplyr_union_all(df1, df2)\nduckplyr_setdiff(df1, df2)\nduckplyr_symdiff(df1, df2)\n```\n\n----------------------------------------\n\nTITLE: Testing Extra Arguments in Set Equality\nDESCRIPTION: Test case for verifying error handling when extra arguments are passed to the setequal function.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-sets.md#2025-04-21_snippet_4\n\nLANGUAGE: R\nCODE:\n```\nduckplyr_setequal(mtcars, mtcars, z = 2)\n```\n\n----------------------------------------\n\nTITLE: Testing default Parameter Type Compatibility in nth Function\nDESCRIPTION: Tests that verify the nth function validates type compatibility between the default parameter and the input vector x.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-nth-value.md#2025-04-21_snippet_2\n\nLANGUAGE: r\nCODE:\n```\nnth(\"x\", 2, default = 2)\n```\n\n----------------------------------------\n\nTITLE: Testing n Parameter Validation in nth Function\nDESCRIPTION: Tests that verify the nth function validates the n parameter for correct type, size, and value, ensuring it's an integer of size 1 and not NA.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-nth-value.md#2025-04-21_snippet_3\n\nLANGUAGE: r\nCODE:\n```\nnth(1:10, n = \"x\")\n```\n\nLANGUAGE: r\nCODE:\n```\nnth(1:10, n = 1:2)\n```\n\nLANGUAGE: r\nCODE:\n```\nnth(1:10, n = NA_integer_)\n```\n\n----------------------------------------\n\nTITLE: Testing validate_grouped_df() error messages in R\nDESCRIPTION: A series of test cases that verify validate_grouped_df() provides helpful error messages when validating grouped data frames with various issues such as invalid .rows columns, incorrect group attribute formats, and out-of-bounds indices.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-grouped-df.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(validate_grouped_df(df1)))\n```\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(group_data(df1)))\n```\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(validate_grouped_df(df2)))\n```\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(validate_grouped_df(df2)))\n```\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(validate_grouped_df(df3)))\n```\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(validate_grouped_df(df4)))\n```\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(validate_grouped_df(df5)))\n```\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(validate_grouped_df(df6, check_bounds = TRUE)))\n```\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(validate_grouped_df(df7, check_bounds = TRUE)))\n```\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(validate_grouped_df(df8, check_bounds = TRUE)))\n```\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(validate_grouped_df(df10)))\n```\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(validate_grouped_df(df11)))\n```\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(new_grouped_df(tibble(x = 1:10), tibble(other = list(1:2)))))\n```\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(new_grouped_df(10)))\n```\n\n----------------------------------------\n\nTITLE: Testing Error Handling in duckplyr_arrange Function\nDESCRIPTION: This snippet demonstrates how duckplyr_arrange handles an error when an undefined function is called. The error message is the same as in the other duckplyr functions.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-conditions.md#2025-04-21_snippet_3\n\nLANGUAGE: R\nCODE:\n```\nduckplyr_arrange(mtcars, !!foobarbaz())\n```\n\n----------------------------------------\n\nTITLE: Testing cur_group() Function Error Message in R\nDESCRIPTION: Tests that cur_group() function throws appropriate error when used outside data-masking verbs.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-context.md#2025-04-21_snippet_2\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(cur_group()))\n```\n\n----------------------------------------\n\nTITLE: Testing Error Handling in duckplyr_add_count\nDESCRIPTION: Demonstrates error handling behavior when invalid arithmetic operations are attempted within duckplyr_add_count().\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-count-tally.md#2025-04-21_snippet_4\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(duckplyr_add_count(mtcars, new = 1 + \"\")))\n(expect_error(duckplyr_add_count(mtcars, wt = 1 + \"\")))\n```\n\n----------------------------------------\n\nTITLE: Testing DuckPLYR Default Fallback Status\nDESCRIPTION: Demonstrates the default fallback configuration status output showing logging enabled but printing and uploading disabled.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/fallback.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nfallback_sitrep()\n```\n\n----------------------------------------\n\nTITLE: Testing Non-Vector Input Error in Coalesce\nDESCRIPTION: Verifies that coalesce() throws appropriate error when input is not a vector\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-coalesce.md#2025-04-21_snippet_4\n\nLANGUAGE: r\nCODE:\n```\ncoalesce(1, environment())\n```\n\n----------------------------------------\n\nTITLE: Testing Error Handling in duckplyr_count\nDESCRIPTION: Demonstrates error handling behavior when invalid arithmetic operations are attempted within duckplyr_count().\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-count-tally.md#2025-04-21_snippet_2\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(duckplyr_count(mtcars, new = 1 + \"\")))\n(expect_error(duckplyr_count(mtcars, wt = 1 + \"\")))\n```\n\n----------------------------------------\n\nTITLE: Testing desc() function error handling with non-vector input in R\nDESCRIPTION: This code snippet tests that the desc() function from duckplyr properly rejects a function input and returns a clear error message. The test verifies that the function performs appropriate type checking by passing 'mean' (a function) as input.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-desc.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\ndesc(mean)\n```\n\n----------------------------------------\n\nTITLE: Testing Error with Invalid Weights in sample_n() on Regular Data\nDESCRIPTION: This snippet tests the error message when sample_n() is used with weights containing zeros on a regular (non-grouped) data frame. It creates a simple data frame and attempts to sample with a weight vector containing a zero value.\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-sample.md#2025-04-21_snippet_5\n\nLANGUAGE: R\nCODE:\n```\ndf <- data.frame(x = 1:2, y = c(0, 1))\n(expect_error(sample_n(df, 2, weight = y)))\n```\n\n----------------------------------------\n\nTITLE: Testing Error Message Naming in Coalesce\nDESCRIPTION: Verifies that error messages correctly index and name the problematic arguments\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/dplyr-coalesce.md#2025-04-21_snippet_5\n\nLANGUAGE: r\nCODE:\n```\ncoalesce(1, \"x\")\n```\n\nLANGUAGE: r\nCODE:\n```\ncoalesce(1, y = \"x\")\n```\n\n----------------------------------------\n\nTITLE: Testing Expression Scrubbing\nDESCRIPTION: Testing function to scrub expressions for across operations\nSOURCE: https://github.com/tidyverse/duckplyr/blob/main/tests/testthat/_snaps/telemetry.md#2025-04-21_snippet_20\n\nLANGUAGE: R\nCODE:\n```\nexpr <- expr(across(x:y, function(arg) mean(arg, na.rm = TRUE)))\nexpr_scrub(expr)\n```"
  }
]