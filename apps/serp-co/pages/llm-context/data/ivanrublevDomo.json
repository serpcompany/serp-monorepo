[
  {
    "owner": "ivanrublev",
    "repo": "domo",
    "content": "TITLE: Defining LineItem and PurchaseOrder Structs with Domo\nDESCRIPTION: Demonstrates creating two related structs with type validation and a business rule that the sum of line item amounts must be less than the purchase order's approved limit.\nSOURCE: https://github.com/ivanrublev/domo/blob/master/README.md#2025-04-21_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule LineItem do\n  use Domo\n\n  defstruct amount: 0\n\n  @type t :: %__MODULE__{amount: non_neg_integer()}\nend\n\ndefmodule PurchaseOrder do\n  use Domo\n\n  defstruct id: 1000, approved_limit: 200, items: []\n\n  @type id :: non_neg_integer()\n  precond(id: &(1000 <= &1 and &1 <= 5000))\n\n  @type t :: %__MODULE__{\n          id: id(),\n          approved_limit: pos_integer(),\n          items: [LineItem.t()]\n        }\n  precond(t: &validate_invariants/1)\n\n  defp validate_invariants(po) do\n    amounts = po.items |> Enum.map(& &1.amount) |> Enum.sum()\n\n    if amounts <= po.approved_limit do\n      :ok\n    else\n      {:error, \"Sum of line item amounts (#{amounts}) should be <= to approved limit (#{po.approved_limit}).\"}\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Handling Validation Errors in Nested Structs\nDESCRIPTION: Shows how Domo returns descriptive errors when validation fails, including validation of nested structs and precondition functions.\nSOURCE: https://github.com/ivanrublev/domo/blob/master/README.md#2025-04-21_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\nPurchaseOrder.new(id: 500, items: [%LineItem{amount: -5}])\n```\n\n----------------------------------------\n\nTITLE: Type Validation with Ecto Integration in Elixir\nDESCRIPTION: Example showing how to integrate Domo validation with Ecto schema and changeset validation. Uses Domo.Changeset to automatically validate against t() type and preconditions.\nSOURCE: https://github.com/ivanrublev/domo/blob/master/README.md#2025-04-21_snippet_15\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule Customer do\n  use Ecto.Schema\n  use Domo, skip_defaults: true\n\n  import Ecto.Changeset\n  import Domo.Changeset\n\n  schema \"customers\" do\n    field :first_name, :string\n    field :last_name, :string\n    field :birth_date, :date\n\n    timestamps()\n  end\n\n  @type t :: %__MODULE__{\n          first_name: String.t(),\n          last_name: String.t(),\n          birth_date: Date.t()\n        }\n\n  def changeset(changeset, attrs) do\n    changeset\n    |> cast(attrs, __schema__(:fields))\n    # Domo.Changeset defines validate_type/1 function.\n    |> validate_type()\n  end \nend\n```\n\n----------------------------------------\n\nTITLE: Using Domo's new Function to Create Validated Structs\nDESCRIPTION: Shows how to create a new PurchaseOrder struct with validation using the generated new/1 function. The function returns {:ok, struct} or {:error, errors} tuples.\nSOURCE: https://github.com/ivanrublev/domo/blob/master/README.md#2025-04-21_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\nPurchaseOrder.new()\n```\n\n----------------------------------------\n\nTITLE: Validating Passenger and Shipment Structs with Domo in Elixir\nDESCRIPTION: Examples of creating and validating Passenger and Shipment structs using Domo's new!/1 and ensure_type!/1/2 functions. Shows how to handle both successful creation and validation errors for domain objects.\nSOURCE: https://github.com/ivanrublev/domo/blob/master/example_avialia/README.md#2025-04-21_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\nalias ExampleAvialia.Boardings.Passenger\n\np = Passenger.new!(flight: \"ALA-1215\", first_name: \"John\", last_name: \"Smith\", seat: \"5C\")\n\nPassenger.ensure_type!(%{p | flight: \"invalid\"})\n\nalias ExampleAvialia.Cargos.Shipment\n\n{:ok, s} = Shipment.new(flight: \"ALA-1215\", kind: {:passenger_baggage, \"5C\"}, weight: {:kilograms, 29}, documents_count: 0, documents: [])\n\nShipment.ensure_type(%{s | kind: {:passenger_baggage, \"invalid\"}}, maybe_filter_precond_errors: true)\n```\n\n----------------------------------------\n\nTITLE: Validating Modified Structs with ensure_type\nDESCRIPTION: Demonstrates how to validate a manually updated struct using the ensure_type/1 function generated by Domo.\nSOURCE: https://github.com/ivanrublev/domo/blob/master/README.md#2025-04-21_snippet_5\n\nLANGUAGE: elixir\nCODE:\n```\npo\n|> Map.put(:items, [LineItem.new!(amount: 150)])\n|> PurchaseOrder.ensure_type()\n```\n\n----------------------------------------\n\nTITLE: Failing Precondition Validation in Domo\nDESCRIPTION: Shows how Domo returns an error when a precondition function for the t() type fails validation.\nSOURCE: https://github.com/ivanrublev/domo/blob/master/README.md#2025-04-21_snippet_6\n\nLANGUAGE: elixir\nCODE:\n```\nupdated_po = %{po | items: [LineItem.new!(amount: 180), LineItem.new!(amount: 100)]}\nPurchaseOrder.ensure_type(updated_po)\n```\n\n----------------------------------------\n\nTITLE: Defining a Struct with Sum Type Fields\nDESCRIPTION: Demonstrates how Domo supports sum types for struct fields, allowing a field to accept multiple types.\nSOURCE: https://github.com/ivanrublev/domo/blob/master/README.md#2025-04-21_snippet_7\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule FruitBasket do\n  use Domo\n  \n  defstruct fruits: []\n  \n  @type t() :: %__MODULE__{fruits: [String.t() | :banana]}\nend\n```\n\n----------------------------------------\n\nTITLE: Handling Validation Errors with Sum Types\nDESCRIPTION: Illustrates error handling when validation fails for a sum type field, showing how Domo provides detailed error messages.\nSOURCE: https://github.com/ivanrublev/domo/blob/master/README.md#2025-04-21_snippet_9\n\nLANGUAGE: elixir\nCODE:\n```\n{:error, [fruits: message]} = FruitBasket.new(fruits: [:banana, \"Maracuja\", nil])\nIO.puts(message)\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Constructor Functions with Domo\nDESCRIPTION: Demonstrates creating custom constructor functions that generate default values while still leveraging Domo's validation by using the gen_constructor_name option.\nSOURCE: https://github.com/ivanrublev/domo/blob/master/README.md#2025-04-21_snippet_13\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule Foo do\n  use Domo, skip_defaults: true, gen_constructor_name: :_new\n\n  defstruct [:id, :token]\n\n  @type id :: non_neg_integer()\n  @type token :: String.t()\n  precond token: &byte_size(&1) == 8\n\n  @type t :: %__MODULE__{id: id(), token: token()}\n\n  def new(id) do\n    _new(id: id, token: random_string(8))\n  end\n\n  def new!(id) do\n    _new!(id: id, token: random_string(8))\n  end\n\n  defp random_string(length),\n    do: :crypto.strong_rand_bytes(length) |> Base.encode64() |> binary_part(0, length)\nend\n```\n\n----------------------------------------\n\nTITLE: Creating a Struct with Sum Type Fields\nDESCRIPTION: Shows creating a FruitBasket struct with a list of mixed types (string and atom), demonstrating sum type support.\nSOURCE: https://github.com/ivanrublev/domo/blob/master/README.md#2025-04-21_snippet_8\n\nLANGUAGE: elixir\nCODE:\n```\nFruitBasket.new(fruits: [:banana, \"Maracuja\"])\n```\n\n----------------------------------------\n\nTITLE: Creating a PurchaseOrder with Custom Parameters\nDESCRIPTION: Demonstrates creating a PurchaseOrder with a map of parameters, showing how the constructor accepts any Enumerable as input.\nSOURCE: https://github.com/ivanrublev/domo/blob/master/README.md#2025-04-21_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\n{:ok, po} = PurchaseOrder.new(%{approved_limit: 250})\n```\n\n----------------------------------------\n\nTITLE: Creating User-Friendly Error Messages with precond\nDESCRIPTION: Shows how to attach user-friendly error messages to types using the precond macro and filter them with the maybe_filter_precond_errors option.\nSOURCE: https://github.com/ivanrublev/domo/blob/master/README.md#2025-04-21_snippet_12\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule Book do\n  use Domo\n\n  defstruct [:title, :pages]\n\n  @type title :: String.t()\n  precond title: &(if String.length(&1) > 1, do: :ok, else: {:error, \"Book title is required.\"})\n\n  @type pages :: pos_integer()\n  precond pages: &(if &1 > 2, do: :ok, else: {:error, \"Book should have more then 3 pages. Given (#{&1}).\"})\n\n  @type t :: %__MODULE__{title: nil | title(), pages: nil | pages()}\nend\n\ndefmodule Shelf do\n  use Domo\n\n  defstruct books: []\n\n  @type t :: %__MODULE__{books: [Book.t()]}\nend\n\ndefmodule PublicLibrary do\n  use Domo\n\n  defstruct shelves: []\n\n  @type t :: %__MODULE__{shelves: [Shelf.t()]}\nend\n\nPublicLibrary.new(\n  %{shelves: [struct!(Shelf, %{books: [struct!(Book, %{title: \"\", pages: 1})]})]}, \n  maybe_filter_precond_errors: true\n)\n```\n\n----------------------------------------\n\nTITLE: Using Custom Constructor with Generated Token\nDESCRIPTION: Shows how to use a custom constructor that generates a random token while still benefiting from Domo's validation.\nSOURCE: https://github.com/ivanrublev/domo/blob/master/README.md#2025-04-21_snippet_14\n\nLANGUAGE: elixir\nCODE:\n```\nFoo.new!(15245)\n```\n\n----------------------------------------\n\nTITLE: Getting Required Fields with Domo's Reflection Functions\nDESCRIPTION: Shows how to use the required_fields/0 function generated by Domo to get a list of fields that have types other than nil or any.\nSOURCE: https://github.com/ivanrublev/domo/blob/master/README.md#2025-04-21_snippet_10\n\nLANGUAGE: elixir\nCODE:\n```\nPurchaseOrder.required_fields()\n```\n\n----------------------------------------\n\nTITLE: Domo Performance Benchmark Results in Elixir\nDESCRIPTION: Benchmark results comparing the performance of Domo's generated constructor function, Ecto's changeset validation, and Domo.Changeset's validate_type function. The benchmark measures execution time and memory usage for processing an Album struct with multiple Track structs.\nSOURCE: https://github.com/ivanrublev/domo/blob/master/README.md#2025-04-21_snippet_21\n\nLANGUAGE: plaintext\nCODE:\n```\nOperating System: macOS\nCPU Information: Intel(R) Core(TM) i7-4870HQ CPU @ 2.50GHz\nNumber of Available Cores: 8\nAvailable memory: 16 GB\nElixir 1.11.0\nErlang 24.3.3\n\nBenchmark suite executing with the following configuration:\nwarmup: 2 s\ntime: 8 s\nmemory time: 2 s\nparallel: 1\ninputs: none specified\nEstimated total run time: 36 s\n\nBenchmarking Domo Album.new!/1...\nBenchmarking Domo.Changeset validate_type/1...\nBenchmarking Ecto.Changeset validate_.../1...\n\nName                                     ips        average  deviation         median         99th %\nDomo Album.new!/1                       5.31      188.25 ms     ±1.79%      188.28 ms      196.57 ms\nEcto.Changeset validate_.../1           5.21      191.85 ms     ±1.94%      191.00 ms      202.22 ms\nDomo.Changeset validate_type/1          3.76      266.19 ms     ±1.20%      266.58 ms      271.01 ms\n\nComparison: \nDomo Album.new!/1                       5.31\nEcto.Changeset validate_.../1           5.21 - 1.02x slower +3.59 ms\nDomo.Changeset validate_type/1          3.76 - 1.41x slower +77.93 ms\n\nMemory usage statistics:\n\nName                              Memory usage\nDomo Album.new!/1                    245.73 MB\nEcto.Changeset validate_.../1        186.59 MB - 0.76x memory usage -59.13956 MB\nDomo.Changeset validate_type/1       238.69 MB - 0.97x memory usage -7.04444 MB\n\n**All measurements for memory usage were the same**\n```\n\n----------------------------------------\n\nTITLE: Viewing Original Type Spec with __t__ Function\nDESCRIPTION: Demonstrates using the __t__/0 function to view the original type specification of a struct for debugging purposes.\nSOURCE: https://github.com/ivanrublev/domo/blob/master/README.md#2025-04-21_snippet_11\n\nLANGUAGE: elixir\nCODE:\n```\nPurchaseOrder.__t__()\n```\n\n----------------------------------------\n\nTITLE: Configuring Phoenix Hot-Reload with Domo\nDESCRIPTION: Mix and endpoint configuration for enabling Phoenix hot-reload with Domo type ensurers\nSOURCE: https://github.com/ivanrublev/domo/blob/master/README.md#2025-04-21_snippet_20\n\nLANGUAGE: elixir\nCODE:\n```\ncompilers: [:domo_compiler] ++ Mix.compilers() ++ [:domo_phoenix_hot_reload]\n```\n\nLANGUAGE: elixir\nCODE:\n```\nconfig :my_app, MyApp.Endpoint,\n  reloadable_compilers: [:phoenix, :domo_compiler] ++ Mix.compilers() ++ [:domo_phoenix_hot_reload]\n```\n\n----------------------------------------\n\nTITLE: Installing Domo in Mix Project\nDESCRIPTION: Mix dependency configuration for adding Domo to an Elixir project\nSOURCE: https://github.com/ivanrublev/domo/blob/master/README.md#2025-04-21_snippet_16\n\nLANGUAGE: elixir\nCODE:\n```\n{:domo, \"~> 1.5\"}\n```\n\n----------------------------------------\n\nTITLE: Installing Domo with Mix\nDESCRIPTION: Installs the Domo package using Mix.install/2 with the force option set to true to ensure the latest version is used.\nSOURCE: https://github.com/ivanrublev/domo/blob/master/README.md#2025-04-21_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\nMix.install([:domo], force: true)\n```\n\n----------------------------------------\n\nTITLE: Configuring Domo Compiler in Mix\nDESCRIPTION: Adding Domo compiler to Mix compilers list\nSOURCE: https://github.com/ivanrublev/domo/blob/master/README.md#2025-04-21_snippet_17\n\nLANGUAGE: elixir\nCODE:\n```\ncompilers: [:domo_compiler] ++ Mix.compilers()\n```\n\n----------------------------------------\n\nTITLE: Running Benchmark Commands in Mix\nDESCRIPTION: Shell commands to install dependencies and run the benchmark comparison between Ecto and Domo validation performance.\nSOURCE: https://github.com/ivanrublev/domo/blob/master/benchmark_ecto_domo/README.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nmix deps.get && mix benchmark\n```\n\n----------------------------------------\n\nTITLE: Configuring Mix Formatter for Domo\nDESCRIPTION: Formatter configuration to handle precond/1 macro calls correctly\nSOURCE: https://github.com/ivanrublev/domo/blob/master/README.md#2025-04-21_snippet_19\n\nLANGUAGE: elixir\nCODE:\n```\n[\n  import_deps: [:domo]\n]\n```\n\n----------------------------------------\n\nTITLE: Configuring Test Coverage for Domo\nDESCRIPTION: Configuration to exclude TypeEnsurer modules from test coverage reports\nSOURCE: https://github.com/ivanrublev/domo/blob/master/README.md#2025-04-21_snippet_18\n\nLANGUAGE: elixir\nCODE:\n```\ntest_coverage: [ignore_modules: [~r/\\.TypeEnsurer$/]]\n```\n\n----------------------------------------\n\nTITLE: Building Domo Structs in Interactive Elixir\nDESCRIPTION: Command for launching an interactive Elixir shell and creating struct instances by calling the new!/1 function on the example modules.\nSOURCE: https://github.com/ivanrublev/domo/blob/master/example_typed_integrations/README.md#2025-04-21_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\niex -S mix\n```\n\n----------------------------------------\n\nTITLE: Configuring Web Crawler Access with robots.txt\nDESCRIPTION: Standard robots.txt configuration file that controls web crawler access to a website. Currently, all crawlers are allowed to access the entire site. The file includes commented examples showing how to ban all spiders by uncommenting the User-agent and Disallow directives.\nSOURCE: https://github.com/ivanrublev/domo/blob/master/example_avialia/assets/static/robots.txt#2025-04-21_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n# See http://www.robotstxt.org/robotstxt.html for documentation on how to use the robots.txt file\n#\n# To ban all spiders from the entire site uncomment the next two lines:\n# User-agent: *\n# Disallow: /\n```"
  }
]