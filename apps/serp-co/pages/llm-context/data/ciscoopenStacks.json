[
  {
    "owner": "cisco-open",
    "repo": "stacks",
    "content": "TITLE: Creating Base Directory Structure\nDESCRIPTION: Shows the initial directory structure required for a Stacks project.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/2.2. I am starting from scratch.md#2025-04-17_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n|-- environments/\n`-- stacks/\n```\n\n----------------------------------------\n\nTITLE: Optimized Stack Structure\nDESCRIPTION: Demonstrates the recommended directory structure with shared backend configuration and global variables.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/2.2. I am starting from scratch.md#2025-04-17_snippet_6\n\nLANGUAGE: plaintext\nCODE:\n```\n|-- environments/\n`-- stacks/\n   |-- backend.tf        # (Step 3) Make it a Jinja template and put it here for all stacks to share.\n   |-- globals.tfvars  # put common variables here\n   |-- ec2/\n   `-- vpc/\n```\n\n----------------------------------------\n\nTITLE: Illustrating Stacks Project Directory Structure\nDESCRIPTION: This snippet shows the full directory structure of a Stacks project, including environments, stacks, layers, and configuration files. It also provides annotations explaining the purpose and constraints of each directory and file.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/3.4. Directory structure.md#2025-04-17_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n|\n|-- environments/               # The environments folder must be named after the value of the STACKS_ENVIRONMENTS_DIR environment variable, which defaults to \"environments\".\n|   `-- production/             # Environment names must follow the ^[a-zA-Z0-9-]{,254}$ regular expression.\n|       `-- env.tfvars          # Environments can only have one env.tfvars file to define environment-specific variables.\n`-- stacks/                     # The stacks folder must be named after the value of the STACKS_STACKS_DIR environment variable, which defaults to \"stacks\".\n   |-- ec2/                     # Stack names must follow the ^[a-zA-Z0-9-]{,254}$ regular expression.\n   |   |-- base/                # The stack base folder must be named after the value of the STACKS_BASE_DIR environment variable, which defaults to \"base\".\n   |   |   |-- backend.tf       # The base folder contains a Terraform root module, you can use Jinja on any one of its *.tf files.\n   |   |   `-- modules/...      # You can also have folders here for stuff like local modules, but those don't get Jinja support unless added to the var.stacks_jinja_enabled_modules special variable.\n   |   |-- layers/              # The layers folder must be named after the value of the STACKS_LAYERS_DIR environment variable, which defaults to \"layers\".\n   |   |   |-- production/      # Stack layers must be named after an existing environment. Stacks must run within one of these layer directories.\n   |   |   |   |-- layer.tfvars # Layers can contain any number of *.tfvars files, which are sorted alphabetically for preference (i.e. a.tfvars is overriden by z.tfvars).\n   |   |   |   `-- stacks.out/  # Stacks operations that produce output code store it in stacks.out (or the value of the STACKS_OUTPUT_DIR environment variable). Make sure to exclude this directory from version control.\n   |   |   `-- production_foo/  # If you want to deploy your stack multiple times per environment you can use layer instances, which are represented by a layer suffixed by an underscore followed by a string that must follow the ^[a-zA-Z0-9-]{,254}$ regular expression.\n   |   |       `-- .keep        # Technically, you don't have to have anything in layer directories, but make sure your version control checks out empty directories, otherwise you can create something like an empty \".keep\" file like so.\n   |   `-- stack.tfvars         # Stacks can contain any number of *.tfvars files, which are sorted alphabetically for preference (i.e. a.tfvars is overriden by z.tfvars).\n   |-- global.tf                # The stacks folder can contain any number of *.tf files, which are joined with the stack base code for cross-stack Terraform code reusability (for example, to define state backends and providers).\n   `-- globals.tfvars           # The stacks folder can contain any number of *.tfvars files, which are sorted alphabetically for preference (i.e. a.tfvars is overriden by z.tfvars).\n```\n\n----------------------------------------\n\nTITLE: Defining AWS Provider Template in Terraform\nDESCRIPTION: Template for generating AWS providers with support for multiple accounts and regions. Uses Jinja-style templating to create providers with different aliases, regions, and role assumptions.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/3.2.2. Terraform provider generation.md#2025-04-17_snippet_0\n\nLANGUAGE: hcl\nCODE:\n```\n# stacks/aws.tf\n{% macro aws_provider(alias, region, role) -%}\nprovider \"aws\" {\n  {% if alias -%}\n  alias = \"{{ alias }}\"\n  {% endif -%}\n  region = \"{{ region }}\"\n  assume_role {\n    role_arn = \"{{ role }}\"\n  }\n  default_tags {\n    tags = {\n      stacks_path = \"{{ var.stacks_path }}\"\n    }\n  }\n}\n{% endmacro -%}\n\n# injects default provider in var.aws_region with var.aws_role_arn\n{{ aws_provider(alias=None, region=var.aws_region, role=var.aws_role_arn) }}\n\n# injects provider with var.aws_role_arn in all var.aws_regions\n{% for region in var.aws_regions -%}\n{{ aws_provider(alias=region, region=region, role=var.aws_role_arn) }}\n{% endfor -%}\n\n# injects providers for all other environments in all var.aws_regions\n{% for environment, variables in var.stacks_environments.items() -%}\n{{ aws_provider(alias=environment, region=variables.aws_region, role=variables.aws_role_arn) }}\n{% for region in var.aws_regions -%}\n{{ aws_provider(alias=[environment,region]|join(\"_\"), region=region, role=variables.aws_role_arn) }}\n{% endfor -%}\n{% endfor -%}\n```\n\n----------------------------------------\n\nTITLE: Defining Terraform State Backend Template in HCL\nDESCRIPTION: This snippet defines a template for the Terraform state backend configuration. It uses variables to dynamically set the backend type and arguments, with a special focus on setting the state file path based on the Stacks project structure.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/3.2.1. Terraform state backend configuration.md#2025-04-17_snippet_0\n\nLANGUAGE: hcl\nCODE:\n```\nterraform {\n  backend \"{{ var.backend_type }}\" {\n    {% for key, value in var.backend_args.items() -%}\n    {{ key }} = \"{{ value }}\"\n    {% endfor -%}\n    key = \"{{ var.stacks_path }}/terraform.tfstate\"  # e.g. \"stacks/vpc/layers/production/terraform.tfstate\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Example Structure of stacks_environments Variable in Stacks\nDESCRIPTION: This example shows the structure of the var.stacks_environments map which contains all environments and their settings. The map includes production and development environments with their respective configuration values for AWS region, assume role, and production flag.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/3.5. Special variables.md#2025-04-17_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n\tproduction = {\n\t\tproduction      = true\n\t\taws_region      = \"eu-south-2\"\n\t\taws_assume_role = \"Admin\"\n\t}\n\tdevelopment = {\n\t\tproduction      = false\n\t\taws_region      = \"eu-south-2\"\n\t\taws_assume_role = \"Developer\"\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Stack Directory Structure\nDESCRIPTION: Shows the complete directory structure for creating a VPC stack with base configuration and environment layers.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/2.2. I am starting from scratch.md#2025-04-17_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\n|-- environments/\n|   `-- development/\n|       `-- env.tfvars\n`-- stacks/\n   `-- vpc/\n       |-- base/\n       |   |-- backend.tf\n       |   `-- main.tf           # you can do any code structure you want here\n       |-- layers/\n       |   `-- development/      # must be named after an existing environment\n       |       `-- layer.tfvars  # can be named <anything>.tfvars\n       `-- stack.tfvars          # can be named <anything>.tfvars\n```\n\n----------------------------------------\n\nTITLE: Conditional Resource Creation with Jinja in Terraform\nDESCRIPTION: This snippet shows how to use Jinja's conditional logic to include or exclude Terraform resources based on a variable. This approach provides cleaner and more maintainable code compared to using Terraform's count attribute with ternary operators.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/3.1.3. Jinja templating for Terraform.md#2025-04-17_snippet_2\n\nLANGUAGE: hcl\nCODE:\n```\n{% if var.enable_cloudtrail %}\nresource \"aws_cloudtrail\" \"main\" {\n  name = \"main\"\n}\n{% endif %}\n```\n\n----------------------------------------\n\nTITLE: Directory Structure for Jinja-templated Terraform Variables\nDESCRIPTION: This snippet illustrates the project structure, highlighting where Jinja-templated variable files (*.tfvars.jinja) can be used alongside standard Terraform variable files (*.tfvars). It shows the hierarchy and placement of these files within environments, stacks, and layers.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/3.1.4. Jinja templating for variables.md#2025-04-17_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n|\n|-- environments/\n|   `-- production/\n|       `-- env.tfvars                 # not here\n`-- stacks/\n   |-- ec2/\n   |   |-- base/\n   |   |-- layers/\n   |   |   `-- production/\n   |   |       |-- layer.tfvars        # not here\n   |   |       `-- layer.tfvars.jinja  # here\n   |   |-- stack.tfvars                # not here\n   |   `-- stack.tfvars.jinja          # here\n   |-- globals.tfvars                  # not here\n   `-- globals.tfvars.jinja            # here\n```\n\n----------------------------------------\n\nTITLE: Installing Stacks using pip in Shell\nDESCRIPTION: Command to install Stacks directly from the GitHub repository using pip. The --break-system-packages flag is used to allow installation outside of virtual environments.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/2.1. Installation instructions.md#2025-04-17_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npip3 install --break-system-packages git+https://github.com/cisco-open/stacks.git\n```\n\n----------------------------------------\n\nTITLE: Executing Stacks Terraform Apply Command\nDESCRIPTION: Shows an example of how to use the 'stacks terraform' command to apply Terraform configurations. The command is executed within a specific layer directory of the Stacks project.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/3.3.2. stacks terraform.md#2025-04-17_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ cd stacks/vpc/layers/production\n$ stacks terraform apply\n...\n```\n\n----------------------------------------\n\nTITLE: Implementing Input Validation with Jinja in Terraform Configuration\nDESCRIPTION: This code snippet demonstrates how to validate the 'owner' variable in a Terraform configuration file using Jinja's throw filter. It checks if the owner variable is defined and if its value is within the allowed list of owners.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/3.2.3. Input validation.md#2025-04-17_snippet_0\n\nLANGUAGE: hcl\nCODE:\n```\n# stacks/owners.tf\n{% if 'owner' not in var %}{{ throw('var.owner is not defined') }}{% endif %}\n{% if var.owner not in var.owners %}{{ throw('var.owner not in var.owners') }}{% endif %}\n```\n\n----------------------------------------\n\nTITLE: Fetching VPC ID Variable with Full Stack, Environment, and Instance Specification\nDESCRIPTION: Demonstrates a full example of using the 'variable' function to fetch a vpc_id variable, specifying stack, environment, subenvironment, and instance.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/3.1.5. Custom Jinja functions.md#2025-04-17_snippet_2\n\nLANGUAGE: hcl\nCODE:\n```\n# stacks/ec2/layers/development@us-east-1_foo/layer.tfvars.jinja:\nvpc_id = \"{{ variable(\\\"vpc_id\\\", stack=\\\"vpc\\\", environment=\\\"development\\\", subenvironment=\\\"us-east-1\\\", instance=\\\"foo\\\") }}\"  # stack/environment/subenvironment/instance all default to the caller's\n```\n\n----------------------------------------\n\nTITLE: Production Environment AWS Configuration\nDESCRIPTION: Production environment-specific AWS configuration defining the default region and IAM role.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/3.2.2. Terraform provider generation.md#2025-04-17_snippet_2\n\nLANGUAGE: hcl\nCODE:\n```\n# environments/production/env.tfvars\naws_region   = \"us-east-1\"\naws_role_arn = \"arn:aws:iam::0123456789:role/Terraform\"\n```\n\n----------------------------------------\n\nTITLE: Terraform Project Structure with Jinja Support\nDESCRIPTION: This snippet illustrates the directory structure of a Terraform project where Jinja templating can be applied. It shows that *.tf files in the base directory and specified modules support Jinja, while other file types do not.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/3.1.3. Jinja templating for Terraform.md#2025-04-17_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n|-- environments/\n`-- stacks/\n   `-- vpc/\n       |-- base/\n       |   |-- main.tf      # you get Jinja support here (any *.tf files)\n       |   |-- module\n       |   |   `-- main.tf  # and here (if you add the module to var.stacks_jinja_enabled_modules)\n       |   `-- script.py    # but not here (since it's not Terraform code)\n       `-- layers/\n```\n\n----------------------------------------\n\nTITLE: Directory Structure for Global Terraform Code in Stacks\nDESCRIPTION: Shows the expected directory structure for implementing global Terraform code in a Stacks project. Global Terraform files must be placed directly in the stacks directory with a .tf extension.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/3.1.1. Global Terraform code.md#2025-04-17_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n|-- environments/\n`-- stacks/\n   |-- ...\n   `-- global.tf   # here\n```\n\n----------------------------------------\n\nTITLE: Using Jinja Variables in Terraform Module Source\nDESCRIPTION: This example demonstrates how to use Jinja templating to dynamically set the source of a Terraform module. This allows for greater flexibility in module sourcing across different environments or configurations.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/3.1.3. Jinja templating for Terraform.md#2025-04-17_snippet_1\n\nLANGUAGE: hcl\nCODE:\n```\nmodule \"vpc\" {\n\tsource = \"{{ var.module_vpc_source }}\"\n\n\tname = \"main\"\n\tcidr = \"10.0.0.0/16\"\n}\n```\n\n----------------------------------------\n\nTITLE: Multiple Stacks Structure\nDESCRIPTION: Complete directory structure showing multiple stacks (VPC and EC2) with their respective environments and layers.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/2.2. I am starting from scratch.md#2025-04-17_snippet_5\n\nLANGUAGE: plaintext\nCODE:\n```\n|-- environments/\n|   |-- development/\n|   |   `-- env.tfvars\n|   `-- production/\n|       `-- env.tfvars\n`-- stacks/\n   |-- ec2/\n   |   |-- base/\n   |   |   |-- backend.tf\n   |   |   `-- main.tf\n   |   |-- layers/\n   |   |   |-- development/\n   |   |   |   `-- layer.tfvars\n   |   |   `-- production/\n   |   |       `-- layer.tfvars\n   |   `-- stack.tfvars\n   `-- vpc/\n       |-- base/\n       |   |-- backend.tf\n       |   `-- main.tf\n       |-- layers/\n       |   |-- development/\n       |   |   `-- layer.tfvars\n       |   `-- production/\n       |       `-- layer.tfvars\n       `-- stack.tfvars\n```\n\n----------------------------------------\n\nTITLE: Defining Backend Type and Arguments in HCL\nDESCRIPTION: This snippet sets the values for the backend_type and backend_args variables used in the backend configuration template. It specifies an S3 backend with various parameters including region, bucket, DynamoDB table, and IAM role ARN.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/3.2.1. Terraform state backend configuration.md#2025-04-17_snippet_1\n\nLANGUAGE: hcl\nCODE:\n```\nbackend_type = \"s3\"\nbackend-args = {\n  region         = \"eu-south-2\"\n  bucket         = \"my-terraform-state\"\n  dynamodb_table = \"my-terraform-state\"\n  role_arn       = \"arn:aws:iam::0123456789:role/Terraform\"\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching VPC Resource Attribute from Same Layer in Different Stack\nDESCRIPTION: Demonstrates how to use the 'resource' function to fetch the id attribute of an aws_vpc.main resource from the same layer in a different stack.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/3.1.5. Custom Jinja functions.md#2025-04-17_snippet_4\n\nLANGUAGE: hcl\nCODE:\n```\n# stacks/ec2/stack.tfvars.jinja:\nvpc_id = \"{{ resource(\\\"aws_vpc.main\\\", stack=\\\"vpc\\\")[\\\"id\\\"] }}\"\n```\n\n----------------------------------------\n\nTITLE: Example of Moving AWS VPC Resource Between Environments\nDESCRIPTION: Demonstrates how to use the 'stacks surgery move' command to transfer an AWS VPC resource named 'main' from the production environment to the development environment.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/3.3.10. stacks surgery move.md#2025-04-17_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ cd stacks/vpc/layers/production\n$ stacks surgery move aws_vpc.main aws_vpc.main stacks/vpc/layers/development\n```\n\n----------------------------------------\n\nTITLE: Environment Directory Structure\nDESCRIPTION: Demonstrates the directory structure for creating a development environment with environment-specific variables.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/2.2. I am starting from scratch.md#2025-04-17_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n|-- environments/\n|   `-- development/\n|       `-- env.tfvars  # must be named \"env.tfvars\"\n`-- stacks/\n```\n\n----------------------------------------\n\nTITLE: Environment-Specific Provider Usage Example\nDESCRIPTION: Example showing how to use a provider for a specific environment's account and region.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/3.2.2. Terraform provider generation.md#2025-04-17_snippet_6\n\nLANGUAGE: hcl\nCODE:\n```\n# stacks/vpc/base/foo.tf\nresource \"foo\" \"bar\" {\n  provider = aws.development  # uses the \"development\" environment's account and region\n\n  foo = \"bar\"\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching VPC ID Output from Same Layer in Different Stack\nDESCRIPTION: Shows how to use the 'output' function to fetch a vpc_id output from the same layer in a different stack.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/3.1.5. Custom Jinja functions.md#2025-04-17_snippet_3\n\nLANGUAGE: hcl\nCODE:\n```\n# stacks/ec2/stack.tfvars.jinja:\nvpc_id = \"{{ output(\\\"vpc_id\\\", stack=\\\"vpc\\\") }}\"\n```\n\n----------------------------------------\n\nTITLE: Usage of stacks render Command\nDESCRIPTION: Displays the usage instructions and available options for the 'stacks render' command. It shows that the command is used to render a layer into working Terraform code and provides an option to control Terraform initialization.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/3.3.1. stacks render.md#2025-04-17_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nUsage: stacks render [OPTIONS]\n\n  Render a layer into working Terraform code.\n\nOptions:\n  --init TEXT  Run terraform init (auto, always, never)\n  --help       Show this message and exit.\n```\n\n----------------------------------------\n\nTITLE: Using Stacks Terraform Command in Shell\nDESCRIPTION: Demonstrates the usage syntax for the 'stacks terraform' command, including available options. The command is a wrapper for Terraform operations and must be run within a layer directory of the Stacks project.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/3.3.2. stacks terraform.md#2025-04-17_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nUsage: stacks terraform [OPTIONS] [ARGS]...\n\n  Terraform command wrapper.\n\nOptions:\n  --init TEXT  Run terraform init (auto, always, never)\n  --help       Show this message and exit.\n```\n\n----------------------------------------\n\nTITLE: Environment and Region-Specific Provider Usage Example\nDESCRIPTION: Example showing how to use a provider for a specific environment's account in a specific region.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/3.2.2. Terraform provider generation.md#2025-04-17_snippet_7\n\nLANGUAGE: hcl\nCODE:\n```\n# stacks/vpc/base/foo.tf\nresource \"foo\" \"bar\" {\n  provider = aws.development_us-east-2  # uses the \"development\" environment's account in the us-east-2 region\n\n  foo = \"bar\"\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Stacks from source for development in Shell\nDESCRIPTION: Series of commands to clone the Stacks repository, navigate to the project directory, and install it in editable mode using uv. This allows for immediate testing of changes without reinstallation.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/2.1. Installation instructions.md#2025-04-17_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ngit clone git@github.com:cisco-open/stacks.git\ncd stacks/\nuv tool install --editable .\n```\n\n----------------------------------------\n\nTITLE: Using Encrypted Secret in Terraform Variables File\nDESCRIPTION: Shows how to include an encrypted secret in a Terraform variables file (.tfvars) for use in Stacks configuration.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/3.1.6. Inline secret encryption.md#2025-04-17_snippet_1\n\nLANGUAGE: hcl\nCODE:\n```\n# environments/production/env.tfvars\naws_secret_access_key = \"ENC[l42kj562...v349120j]\"\n```\n\n----------------------------------------\n\nTITLE: Fetching VPC ID Variable from Same Layer in Different Stack\nDESCRIPTION: Demonstrates how to use the 'variable' function to fetch a vpc_id variable from the same layer in a different stack.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/3.1.5. Custom Jinja functions.md#2025-04-17_snippet_0\n\nLANGUAGE: hcl\nCODE:\n```\n# stacks/ec2/stack.tfvars.jinja:\nvpc_id = \"{{ variable(\\\"vpc_id\\\", stack=\\\"vpc\\\") }}\"\n```\n\n----------------------------------------\n\nTITLE: Encrypting a Secret with Stacks CLI\nDESCRIPTION: Demonstrates how to use the Stacks CLI to encrypt a secret using a public key. The encrypted output can be used in configuration files.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/3.1.6. Inline secret encryption.md#2025-04-17_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ stacks encrypt --public-key-path path/to/public.pem -- 'mysecr3t'  # the \"--\" before your secret is only required if your secret begins with \"--\", so Stacks doesn't parse it as a non-existent flag, but it doesn't hurt to always use it\nENC[l42kj562...v349120j]\n```\n\n----------------------------------------\n\nTITLE: Configuring AWS Regions in Terraform\nDESCRIPTION: Definition of AWS regions that will be used across the provider configuration.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/3.2.2. Terraform provider generation.md#2025-04-17_snippet_1\n\nLANGUAGE: hcl\nCODE:\n```\n# stacks/aws.tfvars\naws_regions = [\n  \"us-east-1\",\n  \"us-east-2\",\n  \"us-west-1\",\n  \"us-west-2\",\n  \"eu-central-1\",\n]\n```\n\n----------------------------------------\n\nTITLE: Deploying Stack Layer\nDESCRIPTION: Commands for deploying a stack layer using Stacks terraform apply.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/2.2. I am starting from scratch.md#2025-04-17_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ncd stacks/vpc/layers/development\nstacks terraform apply\n```\n\n----------------------------------------\n\nTITLE: Development Environment AWS Configuration\nDESCRIPTION: Development environment-specific AWS configuration defining the default region and IAM role.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/3.2.2. Terraform provider generation.md#2025-04-17_snippet_3\n\nLANGUAGE: hcl\nCODE:\n```\n# environments/development/env.tfvars\naws_region   = \"eu-south-2\"\naws_role_arn = \"arn:aws:iam::9876543210:role/Terraform\"\n```\n\n----------------------------------------\n\nTITLE: Default Provider Usage Example\nDESCRIPTION: Example showing how to use the default provider in the environment's account and region.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/3.2.2. Terraform provider generation.md#2025-04-17_snippet_4\n\nLANGUAGE: hcl\nCODE:\n```\n# stacks/vpc/base/foo.tf\nresource \"foo\" \"bar\" {  # uses the environment's account and region (default provider)\n  foo = \"bar\"\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Valid Owner Values in Terraform Variables\nDESCRIPTION: This snippet shows how to define a list of valid owner values in a Terraform variables file. These values will be used to validate the owner variable during stack rendering.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/3.2.3. Input validation.md#2025-04-17_snippet_1\n\nLANGUAGE: hcl\nCODE:\n```\n# stacks/owners.tfvars\nowners = [\n  \"engineering\",\n  \"marketing\",\n  \"operations\",\n  \"sales\",\n]\n```\n\n----------------------------------------\n\nTITLE: Region-Specific Provider Usage Example\nDESCRIPTION: Example showing how to use a provider for a specific region within the environment's account.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/3.2.2. Terraform provider generation.md#2025-04-17_snippet_5\n\nLANGUAGE: hcl\nCODE:\n```\n# stacks/vpc/base/foo.tf\nresource \"foo\" \"bar\" {\n  provider = aws.us-west-2  # uses the environment's account in the us-west-2 region\n\n  foo = \"bar\"\n}\n```\n\n----------------------------------------\n\nTITLE: Example Usage of stacks render Command\nDESCRIPTION: Demonstrates how to use the 'stacks render' command within a specific layer directory. This example shows navigating to the production layer of a VPC stack and executing the render command.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/3.3.1. stacks render.md#2025-04-17_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ cd stacks/vpc/layers/production\n$ stacks render\n```\n\n----------------------------------------\n\nTITLE: Decrypting a Secret with Stacks CLI\nDESCRIPTION: Illustrates the process of decrypting a previously encrypted secret using the Stacks CLI and a private key.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/3.1.6. Inline secret encryption.md#2025-04-17_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ stacks decrypt --private-key-path path/to/private.pem 'ENC[l42kj562...v349120j]'\nmysecr3t\n```\n\n----------------------------------------\n\nTITLE: Installing Stacks using uv in Shell\nDESCRIPTION: Command to install Stacks directly from the GitHub repository using uv, an alternative to pip.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/2.1. Installation instructions.md#2025-04-17_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nuv tool install git+https://github.com/cisco-open/stacks.git\n```\n\n----------------------------------------\n\nTITLE: Fetching VPC ID Variable from Different Environment and Stack\nDESCRIPTION: Shows how to use the 'variable' function to fetch a vpc_id variable from a different environment in a different stack.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/3.1.5. Custom Jinja functions.md#2025-04-17_snippet_1\n\nLANGUAGE: hcl\nCODE:\n```\n# stacks/ec2/layers/development/layer.tfvars.jinja:\nvpc_id = \"{{ variable(\\\"vpc_id\\\", stack=\\\"vpc\\\", environment=\\\"production\\\") }}\"\n```\n\n----------------------------------------\n\nTITLE: Generating MD5 Checksum of a String\nDESCRIPTION: Shows how to use the 'md5' function to generate an MD5 checksum of a given string. Similar functions exist for SHA-1, SHA-256, and SHA-512.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/3.1.5. Custom Jinja functions.md#2025-04-17_snippet_5\n\nLANGUAGE: hcl\nCODE:\n```\n# stacks/ec2/stacks.tfvars.jinja\nfoo_md5 = \"{{ md5(\\\"foo\\\") }}\"\n```\n\n----------------------------------------\n\nTITLE: Using the stacks diff command syntax\nDESCRIPTION: Shows the CLI usage syntax for the stacks diff command which compares Git HEAD version with uncommitted changes in Terraform code.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/3.3.3. stacks diff.md#2025-04-17_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nUsage: stacks diff [OPTIONS]\n\n  Render and compare Git HEAD vs current uncommitted changes.\n\nOptions:\n  --help  Show this message and exit.\n```\n\n----------------------------------------\n\nTITLE: Example usage of stacks diff for comparing Terraform code versions\nDESCRIPTION: Demonstrates how to use the stacks diff command within a layer directory to compare the current uncommitted changes with the Git HEAD version.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/3.3.3. stacks diff.md#2025-04-17_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ cd stacks/vpc/layers/production\n$ stacks diff\n```\n\n----------------------------------------\n\nTITLE: Using Stacks Encrypt CLI Command\nDESCRIPTION: Command line usage pattern for the stacks encrypt command. The command requires a public key path and a string to encrypt. It can be executed from any directory location.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/3.3.4. stacks encrypt.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nUsage: stacks encrypt [OPTIONS] STRING\n\n  Encrypt a secret string using a public key. Can run in any directory.\n\nOptions:\n  --public-key-path TEXT  [required]\n  --help                  Show this message and exit.\n```\n\n----------------------------------------\n\nTITLE: Using the Stacks Decrypt Command with CLI Options\nDESCRIPTION: Command-line usage example for the 'stacks decrypt' command, showing how to decrypt an encrypted string using a private key. The command requires a private key path option and the encrypted string as an argument.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/3.3.5. stacks decrypt.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nUsage: stacks decrypt [OPTIONS] STRING\n\n  Decrypt an encrypted string using a private key. Can run in any directory.\n\nOptions:\n  --private-key-path TEXT  [required]\n  --help                   Show this message and exit.\n```\n\n----------------------------------------\n\nTITLE: Usage of 'stacks surgery list' Command in Bash\nDESCRIPTION: This snippet shows the usage syntax for the 'stacks surgery list' command. It lists all resources in the state by address and has an optional --help flag to display the usage message.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/3.3.6. stacks surgery list.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nUsage: stacks surgery list [OPTIONS]\n\n  List all resources in state by address.\n\nOptions:\n  --help  Show this message and exit.\n```\n\n----------------------------------------\n\nTITLE: Using the Stacks Surgery Import Command in Bash\nDESCRIPTION: This snippet shows the usage syntax for the 'stacks surgery import' command. It requires an ADDRESS and RESOURCE parameter and has a --help option to display usage information.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/3.3.7. stacks surgery import.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nUsage: stacks surgery import [OPTIONS] ADDRESS RESOURCE\n\n  Import a resource into state by id.\n\nOptions:\n  --help  Show this message and exit.\n```\n\n----------------------------------------\n\nTITLE: Usage of 'stacks surgery remove' Command in Bash\nDESCRIPTION: Shows the command syntax and options for the 'stacks surgery remove' command. This command removes a resource from the Terraform state by specifying its address as an argument. It's equivalent to running 'stacks terraform state rm'.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/3.3.8. stacks surgery remove.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nUsage: stacks surgery remove [OPTIONS] ADDRESS\n\n  Remove a resource from state by address.\n\nOptions:\n  --help  Show this message and exit.\n```\n\n----------------------------------------\n\nTITLE: Usage of Stacks Surgery Rename Command in Bash\nDESCRIPTION: Displays the usage syntax for the 'stacks surgery rename' command. It shows the command structure, required arguments (FROM_ADDRESS and TO_ADDRESS), and available options.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/3.3.9. stacks surgery rename.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nUsage: stacks surgery rename [OPTIONS] FROM_ADDRESS TO_ADDRESS\n\n  Rename a resource in the current state.\n\nOptions:\n  --help  Show this message and exit.\n```\n\n----------------------------------------\n\nTITLE: Usage Syntax for Stacks Surgery Move Command\nDESCRIPTION: Displays the command syntax for the 'stacks surgery move' command, showing required parameters FROM_ADDRESS, TO_ADDRESS, and TO_PATH along with available options.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/3.3.10. stacks surgery move.md#2025-04-17_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nUsage: stacks surgery move [OPTIONS] FROM_ADDRESS TO_ADDRESS TO_PATH\n\n  Move a resource from one state to another by address.\n\nOptions:\n  --help  Show this message and exit.\n```\n\n----------------------------------------\n\nTITLE: Usage of Stacks Surgery Edit Command\nDESCRIPTION: Displays the usage instructions for the 'stacks surgery edit' command, showing the command syntax and available options.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/3.3.11. stacks surgery edit.md#2025-04-17_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nUsage: stacks surgery edit [OPTIONS]\n\n  Edit state with vi.\n\nOptions:\n  --help  Show this message and exit.\n```\n\n----------------------------------------\n\nTITLE: Example Usage of Stacks Surgery Edit Command\nDESCRIPTION: Demonstrates how to use the 'stacks surgery edit' command by first changing to a specific directory and then executing the command.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/3.3.11. stacks surgery edit.md#2025-04-17_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ cd stacks/vpc/layers/production\n$ stacks surgery edit\n```\n\n----------------------------------------\n\nTITLE: Using the Stacks Version Command\nDESCRIPTION: Shows the usage syntax for the 'stacks version' command, which prints version information for Stacks and Python and then exits.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/3.3.12. stacks version.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nUsage: stacks version\n\n  Print the Stacks and Python version numbers \n```\n\n----------------------------------------\n\nTITLE: Example of Stacks Version Command Output\nDESCRIPTION: Demonstrates the output of running the 'stacks version' command, which displays the version numbers for both Stacks and Python.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/3.3.12. stacks version.md#2025-04-17_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ stacks version\nStacks 2.0.8\nPython 3.12.8\n```\n\n----------------------------------------\n\nTITLE: Production Environment Structure\nDESCRIPTION: Directory structure showing both development and production environments with their respective layers.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/2.2. I am starting from scratch.md#2025-04-17_snippet_4\n\nLANGUAGE: plaintext\nCODE:\n```\n|-- environments/\n|   |-- development/\n|   |   `-- env.tfvars\n|   `-- production/\n|       `-- env.tfvars\n`-- stacks/\n   `-- vpc/\n       |-- base/\n       |   |-- backend.tf\n       |   `-- main.tf\n       |-- layers/\n       |   |-- development/\n       |   |   `-- layer.tfvars\n       |   `-- production/\n       |       `-- layer.tfvars\n       `-- stack.tfvars\n```\n\n----------------------------------------\n\nTITLE: Displaying Stack Directory Structure in Plaintext\nDESCRIPTION: Shows the standard directory structure for stacks, including environments, base files, and layer-specific configuration files. This structure illustrates how stacks are organized with base modules and layer-specific variables.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/2.3. I am collaborating to an existing stack.md#2025-04-17_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n|-- environments/\n`-- stacks/\n   `-- vpc/\n       |-- base/\n       |   |-- backend.tf\n       |   `-- main.tf\n       |-- layers/\n       |   |-- development/\n       |   |   `-- layer.tfvars\n       |   `-- production/\n       |       `-- layer.tfvars\n       `-- stack.tfvars\n```\n\n----------------------------------------\n\nTITLE: Generating a New Key Pair with Stacks CLI\nDESCRIPTION: Demonstrates how to generate a new public-private key pair using the Stacks CLI for encrypting and decrypting secrets.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/3.1.6. Inline secret encryption.md#2025-04-17_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ stacks genkey --public-key-path public.pem --private-key-path private.pem\n```\n\n----------------------------------------\n\nTITLE: Terraform Command Reference\nDESCRIPTION: Reference to the terraform fmt command that cannot be used with Stacks due to invalid HCL syntax in input code.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/1.1. Considerations before using.md#2025-04-17_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\nterraform fmt\n```\n\n----------------------------------------\n\nTITLE: Using a Valid Owner in Terraform Configuration\nDESCRIPTION: This example shows how to properly define the owner variable in a Terraform configuration file. The value must match one of the predefined valid owners to pass validation.\nSOURCE: https://github.com/cisco-open/stacks/blob/main/docs/3.2.3. Input validation.md#2025-04-17_snippet_2\n\nLANGUAGE: hcl\nCODE:\n```\nowner = \"engineering\"\n```"
  }
]