[
  {
    "owner": "pytest-dev",
    "repo": "pytest-mock",
    "content": "TITLE: Patching Function with mocker Fixture in pytest (Python)\nDESCRIPTION: This code demonstrates how to use the mocker fixture provided by pytest-mock to patch a function (os.remove) within a test. It patches the os.remove function, calls the UnixFS.rm method, and then asserts that os.remove was called with the expected argument. The mocker fixture automatically undoes the patching after the test completes. Dependencies: pytest, pytest-mock, mock.\nSOURCE: https://github.com/pytest-dev/pytest-mock/blob/main/docs/index.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport os\n\nclass UnixFS:\n\n    @staticmethod\n    def rm(filename):\n        os.remove(filename)\n\n\ndef test_unix_fs(mocker):\n    mocker.patch('os.remove')\n    UnixFS.rm('file')\n    os.remove.assert_called_once_with('file')\n```\n\n----------------------------------------\n\nTITLE: Patching with mocker fixture in pytest\nDESCRIPTION: This code snippet demonstrates how to use the mocker fixture provided by the pytest-mock plugin to patch the os.remove function. It defines a UnixFS class with a rm method that calls os.remove, and a test function that uses mocker.patch to replace os.remove with a mock object. After calling UnixFS.rm, it asserts that os.remove was called once with the expected argument.\nSOURCE: https://github.com/pytest-dev/pytest-mock/blob/main/README.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nimport os\n\nclass UnixFS:\n\n    @staticmethod\n    def rm(filename):\n        os.remove(filename)\n\n    def test_unix_fs(mocker):\n        mocker.patch('os.remove')\n        UnixFS.rm('file')\n        os.remove.assert_called_once_with('file')\n```\n\n----------------------------------------\n\nTITLE: Patching with mocker fixture in pytest\nDESCRIPTION: This code demonstrates how to use the `mocker` fixture in pytest to patch objects. It showcases different ways of using `mocker.patch` and `mocker.patch.object` to replace functions and methods with mock objects. These mocks can then be used to control the behavior of the code under test and verify interactions.\nSOURCE: https://github.com/pytest-dev/pytest-mock/blob/main/docs/usage.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef test_foo(mocker):\n    # all valid calls\n    mocker.patch('os.remove')\n    mocker.patch.object(os, 'listdir', autospec=True)\n    mocked_isfile = mocker.patch('os.path.isfile')\n```\n\n----------------------------------------\n\nTITLE: Spying on methods with mocker.spy\nDESCRIPTION: This code shows how to use `mocker.spy` to track calls to a method of a class. It creates a spy on the `bar` method of the `Foo` class and then asserts that the method was called with the expected arguments and that the return value is correct. The `spy` object allows checking the call count and return value.\nSOURCE: https://github.com/pytest-dev/pytest-mock/blob/main/docs/usage.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef test_spy_method(mocker):\n    class Foo(object):\n        def bar(self, v):\n            return v * 2\n\n    foo = Foo()\n    spy = mocker.spy(foo, 'bar')\n    assert foo.bar(21) == 42\n\n    spy.assert_called_once_with(21)\n    assert spy.spy_return == 42\n```\n\n----------------------------------------\n\nTITLE: Spying on functions with mocker.spy\nDESCRIPTION: This code shows how to use `mocker.spy` to track calls to a function in a module. It creates a spy on the `myfunction` function in the `mymodule` and asserts that the function was called, the call count is 1 and that the return value is correct. The `spy` object allows checking the call count and return value.\nSOURCE: https://github.com/pytest-dev/pytest-mock/blob/main/docs/usage.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef test_spy_function(mocker):\n    # mymodule declares `myfunction` which just returns 42\n    import mymodule\n\n    spy = mocker.spy(mymodule, \"myfunction\")\n    assert mymodule.myfunction() == 42\n    assert spy.call_count == 1\n    assert spy.spy_return == 42\n```\n\n----------------------------------------\n\nTITLE: Using mocker.stub to mock callbacks\nDESCRIPTION: This code snippet shows how to use `mocker.stub` to create a mock object that can be used as a callback function. The stub is then called with the expected arguments. The `assert_called_once_with` method is used to verify that the stub was called with the correct arguments. The stub can accept any arguments.\nSOURCE: https://github.com/pytest-dev/pytest-mock/blob/main/docs/usage.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef test_stub(mocker):\n    def foo(on_something):\n        on_something('foo', 'bar')\n\n    stub = mocker.stub(name='on_something_stub')\n\n    foo(stub)\n    stub.assert_called_once_with('foo', 'bar')\n```\n\n----------------------------------------\n\nTITLE: Type Annotations with pytest-mock\nDESCRIPTION: Demonstrates how to use type annotations with pytest-mock's MockerFixture. This enables static type checking for test functions, improving code reliability and maintainability. The example shows annotating the 'mocker' fixture with 'pytest_mock.MockerFixture'.\nSOURCE: https://github.com/pytest-dev/pytest-mock/blob/main/docs/remarks.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pytest_mock import MockerFixture\n\ndef test_foo(mocker: MockerFixture) -> None:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Type Annotations with MockerFixture in pytest-mock (Python)\nDESCRIPTION: Demonstrates how to use type annotations with the MockerFixture in pytest-mock. This helps improve code readability and allows static analysis tools like mypy to catch potential errors. This was introduced in version 3.3.0.\nSOURCE: https://github.com/pytest-dev/pytest-mock/blob/main/CHANGELOG.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pytest_mock import MockerFixture\n\ndef test_foo(mocker: MockerFixture) -> None:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Stopping spies with mocker.stop\nDESCRIPTION: This example demonstrates how to use `mocker.stop` to selectively stop spying on a function.  After stopping the spy, further calls to the function will not be tracked by the spy object. This example spies on the bar method of the Foo class and stops the spy object. After the spy object is stopped, the call_count remains 1.\nSOURCE: https://github.com/pytest-dev/pytest-mock/blob/main/docs/usage.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef test_with_unspy(mocker):\n    class Foo:\n        def bar(self):\n            return 42\n\n    spy = mocker.spy(Foo, \"bar\")\n    foo = Foo()\n    assert foo.bar() == 42\n    assert spy.call_count == 1\n    mocker.stop(spy)\n    assert foo.bar() == 42\n    assert spy.call_count == 1\n```\n\n----------------------------------------\n\nTITLE: Mocking with contextlib.ExitStack\nDESCRIPTION: Demonstrates using 'contextlib.ExitStack' to manage multiple patches in a single level of indentation. This improves test flow compared to nested 'with' statements but can be more complex than using pytest-mock. The example shows using ExitStack to patch 'os.remove', 'os.listdir', and 'shutil.copy'.\nSOURCE: https://github.com/pytest-dev/pytest-mock/blob/main/docs/remarks.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport contextlib\nimport mock\n\ndef test_unix_fs():\n    with contextlib.ExitStack() as stack:\n        stack.enter_context(mock.patch('os.remove'))\n        UnixFS.rm('file')\n        os.remove.assert_called_once_with('file')\n\n        stack.enter_context(mock.patch('os.listdir'))\n        assert UnixFS.ls('dir') == expected\n        # ...\n\n        stack.enter_context(mock.patch('shutil.copy'))\n        UnixFS.cp('src', 'dst')\n        # ...\n```\n\n----------------------------------------\n\nTITLE: Mocking with Decorators\nDESCRIPTION: Illustrates using the 'patch' decorator from the standard 'mock' library for mocking. This can improve the flow of the test but introduces challenges such as the order of mocked objects as parameters and conflicts with pytest's fixture naming. The example shows decorating a function with patches for 'os.remove', 'os.listdir', and 'shutil.copy'.\nSOURCE: https://github.com/pytest-dev/pytest-mock/blob/main/docs/remarks.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@mock.patch('os.remove')\n@mock.patch('os.listdir')\n@mock.patch('shutil.copy')\ndef test_unix_fs(mocked_copy, mocked_listdir, mocked_remove):\n    UnixFS.rm('file')\n    os.remove.assert_called_once_with('file')\n\n    assert UnixFS.ls('dir') == expected\n    # ...\n\n    UnixFS.cp('src', 'dst')\n    # ...\n```\n\n----------------------------------------\n\nTITLE: Mocking with Nested 'with' Statements\nDESCRIPTION: Shows an example of using nested 'with' statements for patching with the standard 'mock' library. This approach can lead to excessive indentation and reduced readability when multiple patches are required. The example demonstrates patching 'os.remove', 'os.listdir', and 'shutil.copy'.\nSOURCE: https://github.com/pytest-dev/pytest-mock/blob/main/docs/remarks.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport mock\n\ndef test_unix_fs():\n    with mock.patch('os.remove'):\n        UnixFS.rm('file')\n        os.remove.assert_called_once_with('file')\n\n        with mock.patch('os.listdir'):\n            assert UnixFS.ls('dir') == expected\n            # ...\n\n    with mock.patch('shutil.copy'):\n        UnixFS.cp('src', 'dst')\n        # ...\n```\n\n----------------------------------------\n\nTITLE: Avoid using mocker.patch as a context manager\nDESCRIPTION: This code demonstrates the anti-pattern of using `mocker.patch` as a context manager.  The `pytest-mock` plugin is designed to make the use of context managers for mocking unnecessary. It emits a warning when used as such. The correct way is to use mocker.patch within the test function directly without `with` statement.\nSOURCE: https://github.com/pytest-dev/pytest-mock/blob/main/docs/usage.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef test_context_manager(mocker):\n    a = A()\n    with mocker.patch.object(a, 'doIt', return_value=True, autospec=True):  # DO NOT DO THIS\n        assert a.doIt() == True\n```\n\n----------------------------------------\n\nTITLE: Running pytest-mock tests with tox\nDESCRIPTION: This command runs the tests for the `pytest-mock` package using `tox`. The `-e py38` option specifies the testing environment, in this case, Python 3.8. `tox` automates the process of running tests in isolated environments, ensuring consistency and compatibility across different Python versions.\nSOURCE: https://github.com/pytest-dev/pytest-mock/blob/main/docs/contributing.rst#_snippet_1\n\nLANGUAGE: console\nCODE:\n```\n$ tox -e py38\n```\n\n----------------------------------------\n\nTITLE: Installing pytest-mock in editable mode\nDESCRIPTION: This command installs the `pytest-mock` package in editable mode with the `dev` extras, which includes development dependencies. Editable mode allows changes to the codebase to be immediately reflected without reinstalling the package. The `pre-commit install` command installs the pre-commit hooks which automatically run style checks and formatting during commit.\nSOURCE: https://github.com/pytest-dev/pytest-mock/blob/main/docs/contributing.rst#_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ pip install --editable .[dev]\n$ pre-commit install\n```\n\n----------------------------------------\n\nTITLE: Using a standalone mock package with pytest-mock\nDESCRIPTION: This configuration option forces the pytest-mock plugin to import the standalone mock package from PyPI instead of the unittest.mock module bundled with Python 3.4+.\nSOURCE: https://github.com/pytest-dev/pytest-mock/blob/main/docs/configuration.rst#_snippet_0\n\nLANGUAGE: ini\nCODE:\n```\n[pytest]\nmock_use_standalone_module = true\n```\n\n----------------------------------------\n\nTITLE: Disable traceback monkeypatch for mock call assertions\nDESCRIPTION: This configuration option disables the monkeypatch that improves pytest output for failures of mock call assertions. This can be useful if the monkeypatch causes issues or conflicts with other pytest configurations.\nSOURCE: https://github.com/pytest-dev/pytest-mock/blob/main/docs/configuration.rst#_snippet_1\n\nLANGUAGE: ini\nCODE:\n```\n[pytest]\nmock_traceback_monkeypatch = false\n```\n\n----------------------------------------\n\nTITLE: Run Deployment Workflow with GitHub CLI\nDESCRIPTION: This command uses the GitHub CLI to manually trigger the `deploy.yml` workflow for the `pytest-mock` repository. It specifies the release branch (`release-VERSION`) and sets the `version` input parameter to `VERSION`.\nSOURCE: https://github.com/pytest-dev/pytest-mock/blob/main/RELEASING.rst#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ngh workflow run deploy.yml --repo pytest-dev/pytest-mock --ref release-VERSION -f version=VERSION\n```"
  }
]