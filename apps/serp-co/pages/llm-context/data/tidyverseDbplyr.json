[
  {
    "owner": "tidyverse",
    "repo": "dbplyr",
    "content": "TITLE: Using across() with Namespaced Functions in R\nDESCRIPTION: Example showing how across() now supports namespaced functions like dplyr::dense_rank in dbplyr 2.3.5. This allows referencing functions from specific packages when using across() with database tables.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/NEWS.md#2025-04-21_snippet_2\n\nLANGUAGE: r\nCODE:\n```\nacross(x, dplyr::dense_rank)\n```\n\n----------------------------------------\n\nTITLE: Connecting to SQLite Database in R\nDESCRIPTION: Demonstrates creating an in-memory SQLite database connection and copying data to it using dplyr and DBI packages.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/README.md#2025-04-21_snippet_1\n\nLANGUAGE: r\nCODE:\n```\nlibrary(dplyr, warn.conflicts = FALSE)\n\ncon <- DBI::dbConnect(RSQLite::SQLite(), \":memory:\")\ncopy_to(con, mtcars)\n```\n\n----------------------------------------\n\nTITLE: Pivoting All Columns to Long Format in DBPlyr\nDESCRIPTION: Demonstrates how to transform a data frame from wide to long format by pivoting all columns using tidyr::pivot_longer in a DBPlyr context. This produces SQL that uses UNION ALL to combine results for each pivoted column.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-pivot-longer.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\nlazy_frame(x = 1:2, y = 3:4) %>% tidyr::pivot_longer(x:y)\n```\n\nLANGUAGE: sql\nCODE:\n```\nSELECT 'x' AS `name`, `x` AS `value`\nFROM `df`\n\nUNION ALL\n\nSELECT 'y' AS `name`, `y` AS `value`\nFROM `df`\n```\n\n----------------------------------------\n\nTITLE: Translating case_when() Function in dbplyr to SQLite SQL\nDESCRIPTION: Illustrates how dbplyr translates the R case_when() function into a SQL CASE statement for SQLite. It includes multiple conditions and a default case using TRUE ~.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-sqlite.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\ntest_translate_sql(case_when(x == 1L ~ \"yes\", x == 0L ~ \"no\", TRUE ~ \"undefined\"), con = simulate_sqlite())\n```\n\nLANGUAGE: SQL\nCODE:\n```\nCASE WHEN (`x` = 1) THEN 'yes' WHEN (`x` = 0) THEN 'no' ELSE 'undefined' END\n```\n\n----------------------------------------\n\nTITLE: Testing Cancellation of arrange() in dbplyr\nDESCRIPTION: Demonstrates how an empty arrange() call cancels previous ordering operations.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-arrange.md#2025-04-21_snippet_5\n\nLANGUAGE: R\nCODE:\n```\n# un-arrange\nlf %>% arrange(a) %>% arrange()\n```\n\n----------------------------------------\n\nTITLE: Using in_schema Function for Schema References in R\nDESCRIPTION: Shows how to use the in_schema() function to reference tables within a specific database schema. This function simplifies referencing tables that are organized within schema structures.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/NEWS.md#2025-04-21_snippet_19\n\nLANGUAGE: R\nCODE:\n```\nin_schema(\"my_schema_name\", \"my_table_name\")\n```\n\n----------------------------------------\n\nTITLE: Installing dbplyr Package in R\nDESCRIPTION: Shows different ways to install dbplyr - either as part of tidyverse, standalone package, or development version from GitHub using pak.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/README.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\n# The easiest way to get dbplyr is to install the whole tidyverse:\ninstall.packages(\"tidyverse\")\n\n# Alternatively, install just dbplyr:\ninstall.packages(\"dbplyr\")\n\n# Or the development version from GitHub:\n# install.packages(\"pak\")\npak::pak(\"tidyverse/dbplyr\")\n```\n\n----------------------------------------\n\nTITLE: Using Rank Functions with Multiple Variables in dbplyr\nDESCRIPTION: Example of using rank functions (like row_number, min_rank, rank, dense_rank, percent_rank, and cume_dist) with multiple variables by wrapping them in tibble().\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/NEWS.md#2025-04-21_snippet_5\n\nLANGUAGE: r\nCODE:\n```\nrank(tibble(x, y))\n```\n\n----------------------------------------\n\nTITLE: Error Handling in Select, Relocate, and Rename Operations with R using dbplyr\nDESCRIPTION: These snippets demonstrate error handling in dbplyr for select, relocate, and rename operations when dealing with non-existent columns or invalid inputs. It shows various error messages for different scenarios.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-select.md#2025-04-21_snippet_6\n\nLANGUAGE: R\nCODE:\n```\nlf %>% select(non_existent)\n```\n\nLANGUAGE: R\nCODE:\n```\nlf %>% select(non_existent + 1)\n```\n\nLANGUAGE: R\nCODE:\n```\nlf %>% relocate(non_existent)\n```\n\nLANGUAGE: R\nCODE:\n```\nlf %>% relocate(non_existent + 1)\n```\n\nLANGUAGE: R\nCODE:\n```\nlf %>% rename(x)\n```\n\nLANGUAGE: R\nCODE:\n```\nlf %>% rename(y = non_existent)\n```\n\nLANGUAGE: R\nCODE:\n```\nlf %>% rename(y = non_existent + 1)\n```\n\nLANGUAGE: R\nCODE:\n```\nlf %>% rename_with(toupper, .cols = non_existent)\n```\n\nLANGUAGE: R\nCODE:\n```\nlf %>% rename_with(toupper, .cols = non_existent + 1)\n```\n\n----------------------------------------\n\nTITLE: Upsert Query with ON CONFLICT\nDESCRIPTION: SQL query for upserting data using ON CONFLICT DO UPDATE with specified columns for matching and updating.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-postgres.md#2025-04-21_snippet_4\n\nLANGUAGE: SQL\nCODE:\n```\nINSERT INTO `df_x` (`c`, `d`, `a`, `b`)\nSELECT `c`, `d`, `a`, `b`\nFROM (\n  SELECT `a`, `b`, `c` + 1.0 AS `c`, `d`\n  FROM `df_y`\n) AS `...y`\nWHERE true\nON CONFLICT  (`c`, `d`)\nDO UPDATE\nSET `a` = `excluded`.`a`, `b` = `excluded`.`b`\nRETURNING `df_x`.`a`, `df_x`.`b` AS `b2`\n```\n\n----------------------------------------\n\nTITLE: Database Query Generation and Execution\nDESCRIPTION: Demonstrates lazy query generation using dplyr chain operations, showing the generated SQL, and executing the query to retrieve results.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/README.md#2025-04-21_snippet_3\n\nLANGUAGE: r\nCODE:\n```\n# lazily generates query\nsummary <- mtcars2 %>% \n  group_by(cyl) %>% \n  summarise(mpg = mean(mpg, na.rm = TRUE)) %>% \n  arrange(desc(mpg))\n\n# see query\nsummary %>% show_query()\n\n# execute query and retrieve results\nsummary %>% collect()\n```\n\n----------------------------------------\n\nTITLE: Using in_schema with Joins in dbplyr\nDESCRIPTION: Demonstrates how joins work with database schema references using in_schema. The examples show how schema-qualified tables are represented in the generated SQL with appropriate table aliases when needed.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-joins.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\nleft_join(df1, df2, by = \"x\") %>% remote_query()\n```\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL> SELECT `df`.*, `z`\nFROM `foo`.`df`\nLEFT JOIN `foo`.`df2`\n  ON (`df`.`x` = `df2`.`x`)\n```\n\nLANGUAGE: R\nCODE:\n```\nleft_join(df1, df3, by = \"x\") %>% remote_query()\n```\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL> SELECT `df_LHS`.*, `z`\nFROM `foo`.`df` AS `df_LHS`\nLEFT JOIN `foo2`.`df` AS `df_RHS`\n  ON (`df_LHS`.`x` = `df_RHS`.`x`)\n```\n\nLANGUAGE: R\nCODE:\n```\nleft_join(df4, df5, by = \"x\") %>% remote_query()\n```\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL> SELECT `df_LHS`.*, `z`\nFROM foo.df AS `df_LHS`\nLEFT JOIN foo2.df AS `df_RHS`\n  ON (`df_LHS`.`x` = `df_RHS`.`x`)\n```\n\n----------------------------------------\n\nTITLE: Pivoting with Group By in DBplyr\nDESCRIPTION: Shows how pivoting data with an ID column works, generating SQL that includes GROUP BY. This example demonstrates handling implicit missings in the pivot operation.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-pivot-wider.md#2025-04-21_snippet_1\n\nLANGUAGE: r\nCODE:\n```\nlazy_frame(a = 1:2, key = c(\"x\", \"y\"), val = 1:2) %>% dbplyr_pivot_wider_spec(spec)\n```\n\nLANGUAGE: sql\nCODE:\n```\nSELECT\n  `a`,\n  MAX(CASE WHEN (`key` = 'x') THEN `val` END) AS `x`,\n  MAX(CASE WHEN (`key` = 'y') THEN `val` END) AS `y`\nFROM `df`\nGROUP BY `a`\n```\n\n----------------------------------------\n\nTITLE: Handling Previous Select in Joins with R using dbplyr\nDESCRIPTION: These snippets show how dbplyr handles previous select operations in joins. It demonstrates the SQL generation for semi join and left join scenarios with previously selected and renamed columns.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-select.md#2025-04-21_snippet_5\n\nLANGUAGE: R\nCODE:\n```\nprint(lf)\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT `x` AS `x2`, `y` AS `y3`, `z`\nFROM `df` AS `df_LHS`\nWHERE EXISTS (\n  SELECT 1 FROM `df` AS `df_RHS`\n  WHERE (`df_LHS`.`x` = `df_RHS`.`x`)\n)\n```\n\nLANGUAGE: R\nCODE:\n```\nprint(lf2)\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT `df_LHS`.`x` AS `x2`, `df_LHS`.`y` AS `y3`, `z`\nFROM `df` AS `df_LHS`\nLEFT JOIN `df` AS `df_RHS`\n  ON (`df_LHS`.`x` = `df_RHS`.`x`)\n```\n\n----------------------------------------\n\nTITLE: Rendering SELECT * Query with dbplyr\nDESCRIPTION: Example showing how to render a SQL SELECT * query using dbplyr's sql_render function with pipe operator. Demonstrates the basic syntax for generating SQL queries from R code.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/sql-build.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nout %>% sql_render()\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT *\nFROM `test-sql-build`\n```\n\n----------------------------------------\n\nTITLE: SQL MERGE/UPSERT Query Generation in dbplyr\nDESCRIPTION: Demonstrates the sql_query_upsert() function which generates a SQL MERGE statement (upsert operation) that can insert new records or update existing ones based on matching keys. The query includes OUTPUT clause to return specific columns after the operation.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-mssql.md#2025-04-21_snippet_4\n\nLANGUAGE: R\nCODE:\n```\nsql_query_upsert(con = con, table = ident(\"df_x\"), from = sql_render(df_y, con,\n  lvl = 1), by = c(\"a\", \"b\"), update_cols = c(\"c\", \"d\"), returning_cols = c(\"a\",\nb2 = \"b\"))\n```\n\n----------------------------------------\n\nTITLE: Implementing Left Join with Table Aliases in dbplyr\nDESCRIPTION: Demonstrates how left join operations translate to SQL with custom table aliases specified through x_as and y_as parameters. The resulting SQL query shows proper table qualification with the assigned aliases.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-joins.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nleft_join(lf1, lf2, by = \"x\", x_as = \"df1\", y_as = \"df2\")\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT `df1`.`x` AS `x`, `y`\nFROM `lf1` AS `df1`\nLEFT JOIN `lf2` AS `df2`\n  ON (`df1`.`x` = `df2`.`x`)\n```\n\n----------------------------------------\n\nTITLE: Full Join with Custom SQL Join Condition\nDESCRIPTION: Demonstrates a full join with a custom SQL join condition. This allows for using non-equality conditions while still returning all records from both tables when there's any match.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/query-join.md#2025-04-21_snippet_12\n\nLANGUAGE: R\nCODE:\n```\nfull_join(lf1, lf2, sql_on = \"LHS.y < RHS.z\")\n```\n\n----------------------------------------\n\nTITLE: Connecting to a Database with DBI in R\nDESCRIPTION: Demonstrates how to connect to an SQLite in-memory database using DBI, copy data to it, and create a dplyr table reference. This showcases the direct DBI connection support introduced in dbplyr 1.0.0.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/NEWS.md#2025-04-21_snippet_18\n\nLANGUAGE: R\nCODE:\n```\nlibrary(dplyr)\n\ncon <- DBI::dbConnect(RSQLite::SQLite(), \":memory:\")\ncopy_to(con, mtcars)\n\nmtcars2 <- tbl(con, \"mtcars\")\nmtcars2\n```\n\n----------------------------------------\n\nTITLE: Implementing tidyr::expand with DISTINCT and CROSS JOIN in SQL\nDESCRIPTION: Shows how tidyr::expand() generates SQL queries with DISTINCT selections and CROSS JOINs to produce all combinations of values from specified columns.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-expand.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nlazy_frame(x = 1, y = 1) %>% tidyr::expand(x, y)\n```\n\n----------------------------------------\n\nTITLE: Using Common Table Expressions (CTE) with joins in dbplyr\nDESCRIPTION: Demonstrates how to generate SQL with Common Table Expressions using the remote_query function with sql_options(cte = TRUE). Shows the WITH clause structure and nested joins.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-joins.md#2025-04-21_snippet_24\n\nLANGUAGE: r\nCODE:\n```\nleft_join(lf, lf) %>% remote_query(sql_options = sql_options(cte = TRUE))\n```\n\nLANGUAGE: sql\nCODE:\n```\nWITH `q01` AS (\n  SELECT `lf1_LHS`.`x` AS `x`\n  FROM `lf1` AS `lf1_LHS`\n  INNER JOIN `lf1` AS `lf1_RHS`\n    ON (`lf1_LHS`.`x` = `lf1_RHS`.`x`)\n)\nSELECT `lf1...1`.`x` AS `x`\nFROM `lf1` AS `lf1...1`\nINNER JOIN `lf1` AS `lf1...2`\n  ON (`lf1...1`.`x` = `lf1...2`.`x`)\nLEFT JOIN `q01` AS `...3`\n  ON (`lf1...1`.`x` = `...3`.`x`)\n```\n\n----------------------------------------\n\nTITLE: Using HAVING with Aggregated Variables in filter()\nDESCRIPTION: Shows how dbplyr handles filter conditions on aggregated variables created by summarise(). The condition becomes part of the HAVING clause in SQL.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-filter.md#2025-04-21_snippet_8\n\nLANGUAGE: r\nCODE:\n```\n(out <- lf %>% filter(x_mean > 1))\n```\n\n----------------------------------------\n\nTITLE: Case-Sensitive Column Disambiguation in Left Join\nDESCRIPTION: Shows how DBplyr handles column names that differ only in case. The join operation preserves both columns and distinguishes them in the output SQL.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/query-join.md#2025-04-21_snippet_7\n\nLANGUAGE: R\nCODE:\n```\nleft_join(lf1, lf2, by = \"y\")\n```\n\n----------------------------------------\n\nTITLE: Collapsing Multiple Selects in R using dbplyr\nDESCRIPTION: These snippets show how dbplyr collapses multiple select operations. It demonstrates the SQL generation for various combinations of select operations, including column reordering and renaming.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-select.md#2025-04-21_snippet_9\n\nLANGUAGE: R\nCODE:\n```\nlf %>% select(2:1) %>% select(2:1)\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT `df`.*\nFROM `df`\n```\n\nLANGUAGE: R\nCODE:\n```\nlf %>% select(2:1) %>% select(2:1) %>% select(2:1)\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT `y`, `x`\nFROM `df`\n```\n\nLANGUAGE: R\nCODE:\n```\nlf %>% select(x1 = x) %>% select(x2 = x1)\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT `x` AS `x2`\nFROM `df`\n```\n\n----------------------------------------\n\nTITLE: Implementing lag() Window Function\nDESCRIPTION: Shows translation of R's lag() function into SQL LAG window function with grouping and ordering.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-teradata.md#2025-04-21_snippet_3\n\nLANGUAGE: R\nCODE:\n```\nmf %>% group_by(y) %>% mutate(val2 = lag(x, order_by = x)) %>% sql_render()\n```\n\n----------------------------------------\n\nTITLE: Filtering Data with SQL Server in R\nDESCRIPTION: Examples of translating R filter operations to SQL Server syntax using dbplyr. This includes handling NA values, logical operations, and bit conversions.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-mssql.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nmf %>% filter(is.na(x))\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT `df`.*\nFROM `df`\nWHERE ((`x` IS NULL))\n```\n\nLANGUAGE: R\nCODE:\n```\nmf %>% filter(!is.na(x))\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT `df`.*\nFROM `df`\nWHERE (NOT((`x` IS NULL)))\n```\n\nLANGUAGE: R\nCODE:\n```\nmf %>% filter(x == 1L || x == 2L)\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT `df`.*\nFROM `df`\nWHERE (`x` = 1 OR `x` = 2)\n```\n\n----------------------------------------\n\nTITLE: Left Join SQL Generation in DBplyr\nDESCRIPTION: Demonstrates how left_join is translated to SQL. The function creates a LEFT JOIN clause that returns all records from the left table and matching records from the right table.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/query-join.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\nleft_join(lf, lf)\n```\n\n----------------------------------------\n\nTITLE: Combining full_join with Other Joins in dbplyr\nDESCRIPTION: Shows how full_join can be combined with other join types in a chain. The examples demonstrate the SQL generation for complex join sequences involving full_join with left_join and another full_join.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-joins.md#2025-04-21_snippet_8\n\nLANGUAGE: R\nCODE:\n```\nfull_join(lf1, lf2, by = \"x\") %>% left_join(lf3, by = \"x\")\n```\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL>\nSELECT `LHS`.*, `z`\nFROM (\n  SELECT COALESCE(`df_LHS`.`x`, `df_RHS`.`x`) AS `x`, `y`\n  FROM `df` AS `df_LHS`\n  FULL JOIN `df` AS `df_RHS`\n    ON (`df_LHS`.`x` = `df_RHS`.`x`)\n) AS `LHS`\nLEFT JOIN `df`\n  ON (`LHS`.`x` = `df`.`x`)\n```\n\nLANGUAGE: R\nCODE:\n```\nleft_join(lf1, lf2, by = \"x\") %>% full_join(lf3, by = \"x\")\n```\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL>\nSELECT COALESCE(`LHS`.`x`, `df`.`x`) AS `x`, `y`, `z`\nFROM (\n  SELECT `df_LHS`.`x` AS `x`, `y`\n  FROM `df` AS `df_LHS`\n  LEFT JOIN `df` AS `df_RHS`\n    ON (`df_LHS`.`x` = `df_RHS`.`x`)\n) AS `LHS`\nFULL JOIN `df`\n  ON (`LHS`.`x` = `df`.`x`)\n```\n\nLANGUAGE: R\nCODE:\n```\nfull_join(lf1, lf2, by = \"x\") %>% full_join(lf3, by = \"x\")\n```\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL>\nSELECT COALESCE(`LHS`.`x`, `df`.`x`) AS `x`, `y`, `z`\nFROM (\n  SELECT COALESCE(`df_LHS`.`x`, `df_RHS`.`x`) AS `x`, `y`\n  FROM `df` AS `df_LHS`\n  FULL JOIN `df` AS `df_RHS`\n    ON (`df_LHS`.`x` = `df_RHS`.`x`)\n) AS `LHS`\nFULL JOIN `df`\n  ON (`LHS`.`x` = `df`.`x`)\n```\n\n----------------------------------------\n\nTITLE: Joining Multiple Tables in a Single Query with dbplyr\nDESCRIPTION: Shows how multiple joins are combined into a single SQL query when using equi-joins like left_join and inner_join. The example demonstrates joining three tables with automatic column name disambiguation.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-joins.md#2025-04-21_snippet_11\n\nLANGUAGE: R\nCODE:\n```\nout\n```\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL>\nSELECT `df1`.*, `df2`.`b` AS `b.x`, `df3`.`b` AS `b.y`\nFROM `df1`\nLEFT JOIN `df2`\n  ON (`df1`.`x` = `df2`.`x`)\nINNER JOIN `df3`\n  ON (`df1`.`x` = `df3`.`x`)\n```\n\n----------------------------------------\n\nTITLE: Using sql_options() for Query Generation Control in dbplyr\nDESCRIPTION: Creates SQL options that control how SQL is generated by show_query() and remote_query(). Allows specifying use of common table expressions, column selection strategies, and column qualification behavior.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/NEWS.md#2025-04-21_snippet_3\n\nLANGUAGE: r\nCODE:\n```\nsql_options(\n  cte,              # use common table expressions?\n  use_star,         # use `SELECT *` or explicitly select every column?\n  qualify_all_columns # qualify all columns in a join or only the ambiguous ones?\n)\n```\n\n----------------------------------------\n\nTITLE: Translating String Concatenation in R to SQL using dbplyr\nDESCRIPTION: This snippet shows how dbplyr translates R's paste0 and paste functions to SQL string concatenation. It uses the || operator for concatenation and adds spaces when necessary.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-hana.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\ntest_translate_sql(paste0(\"a\", \"b\"))\n```\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL> 'a' || 'b'\n```\n\nLANGUAGE: R\nCODE:\n```\ntest_translate_sql(paste(\"a\", \"b\"))\n```\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL> 'a' || ' ' || 'b'\n```\n\n----------------------------------------\n\nTITLE: Generating EXPLAIN Output for Query Plan Analysis\nDESCRIPTION: Shows how to use the explain() function to get both the SQL query and its execution plan when working with dbplyr. The output includes both the generated SQL and a tabular representation of the execution plan.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-mysql.md#2025-04-21_snippet_8\n\nLANGUAGE: R\nCODE:\n```\ndb %>% mutate(y = x + 1) %>% explain()\n```\n\n----------------------------------------\n\nTITLE: Translating Basic case_when to SQL CASE WHEN\nDESCRIPTION: Demonstrates how a simple case_when expression with a single condition is translated to SQL CASE WHEN syntax.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/translate-sql-conditional.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\ntest_translate_sql(case_when(x > 1L ~ \"a\"))\n```\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL> CASE WHEN (`x` > 1) THEN 'a' END\n```\n\n----------------------------------------\n\nTITLE: SQL Output for tidyr::complete with COALESCE and FULL JOIN\nDESCRIPTION: The SQL translation of complete, using FULL JOIN to include all combinations and COALESCE to fill missing values.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-expand.md#2025-04-21_snippet_25\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL>\nSELECT `x`, `y`, COALESCE(`z`, 'c') AS `z`\nFROM (\n  SELECT\n    COALESCE(`LHS`.`x`, `df`.`x`) AS `x`,\n    COALESCE(`LHS`.`y`, `df`.`y`) AS `y`,\n    `z`\n  FROM (\n    SELECT `x`, `y`\n    FROM (\n      SELECT DISTINCT `x`\n      FROM `df`\n    ) AS `LHS`\n    CROSS JOIN (\n      SELECT DISTINCT `y`\n      FROM `df`\n    ) AS `RHS`\n  ) AS `LHS`\n  FULL JOIN `df`\n    ON (`LHS`.`x` = `df`.`x` AND `LHS`.`y` = `df`.`y`)\n) AS `q01`\n```\n\n----------------------------------------\n\nTITLE: Basic Semi-Join SQL Generation in dbplyr\nDESCRIPTION: Shows the SQL query generated for a simple semi-join between two identical lazy frames. The query uses EXISTS clause to implement the semi-join operation with matching on columns x and y.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/query-semi-join.md#2025-04-21_snippet_1\n\nLANGUAGE: r\nCODE:\n```\nsemi_join(lf, lf)\n```\n\n----------------------------------------\n\nTITLE: Using WHERE Instead of HAVING after mutate()\nDESCRIPTION: Shows that filter() after mutate() uses a WHERE clause rather than HAVING. The query includes a subquery with the window function from mutate().\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-filter.md#2025-04-21_snippet_12\n\nLANGUAGE: r\nCODE:\n```\n(out <- lf %>% filter(x_mean > 1))\n```\n\n----------------------------------------\n\nTITLE: Implementing lead() Window Function\nDESCRIPTION: Demonstrates translation of R's lead() function into SQL LEAD window function with grouping and ordering.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-teradata.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\nmf %>% group_by(y) %>% mutate(val2 = lead(x, order_by = x)) %>% sql_render()\n```\n\n----------------------------------------\n\nTITLE: Using window_frame with preceding rows only\nDESCRIPTION: Demonstrates how to create a window frame that includes only the current row and 3 preceding rows for a sum aggregation, translated to SQL ROWS clause.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/translate-sql-window.md#2025-04-21_snippet_6\n\nLANGUAGE: R\nCODE:\n```\nlf %>% window_frame(-3, 0) %>% window_order(x) %>% mutate(z = sum(y, na.rm = TRUE)) %>%\n  show_query()\n```\n\n----------------------------------------\n\nTITLE: Accessing Previously Created Variables with across() in dbplyr (R)\nDESCRIPTION: This snippet demonstrates how across() can access variables created in the same mutate() call in dbplyr. It shows that across() can use both original and newly created variables.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-mutate.md#2025-04-21_snippet_5\n\nLANGUAGE: R\nCODE:\n```\nremote_query(lf)\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT `x`, SQRT(`y`) AS `y`\nFROM (\n  SELECT `df`.*, 2.0 AS `y`\n  FROM `df`\n) AS `q01`\n```\n\n----------------------------------------\n\nTITLE: Using rank() with desc() for Descending Order in dbplyr\nDESCRIPTION: Example showing how rank functions support variables wrapped in desc() for ordering in descending order. This functionality works with row_number(), min_rank(), rank(), dense_rank(), percent_rank(), and cume_dist().\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/NEWS.md#2025-04-21_snippet_7\n\nLANGUAGE: r\nCODE:\n```\nrow_number(desc(x))\n```\n\n----------------------------------------\n\nTITLE: Translating grouped tidyr::fill() using non-standard SQL\nDESCRIPTION: Shows the SQL translation of tidyr::fill() with grouping on a non-standard SQL database. This implementation respects groups by including them in the partition clause of the window functions.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-fill.md#2025-04-21_snippet_6\n\nLANGUAGE: R\nCODE:\n```\ngroup_by(df_lazy_ns, group) %>% window_order(id) %>% tidyr::fill(n1)\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT\n  `id`,\n  `group`,\n  MAX(`n1`) OVER (PARTITION BY `group`, `..dbplyr_partition_1`) AS `n1`\nFROM (\n  SELECT\n    `df`.*,\n    SUM(CASE WHEN ((`n1` IS NULL)) THEN 0 ELSE 1 END) OVER (PARTITION BY `group` ORDER BY `id` ROWS UNBOUNDED PRECEDING) AS `..dbplyr_partition_1`\n  FROM `df`\n) AS `q01`\n```\n\n----------------------------------------\n\nTITLE: Handling Temporary Variables with Nested Arguments in dbplyr (R)\nDESCRIPTION: This snippet demonstrates how dbplyr handles temporary variables with nested arguments in mutate() operations. It shows the generation of subqueries for complex expressions involving multiple variables.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-mutate.md#2025-04-21_snippet_12\n\nLANGUAGE: R\nCODE:\n```\nremote_query(lf)\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT `x`, `y` * 2.0 AS `z`\nFROM (\n  SELECT `df`.*, 2.0 AS `y`\n  FROM `df`\n) AS `q01`\n```\n\n----------------------------------------\n\nTITLE: Inner Join SQL Generation in DBplyr\nDESCRIPTION: Shows how inner_join is translated to SQL. The function automatically determines the join columns when not explicitly specified, and creates an INNER JOIN clause with the appropriate conditions.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/query-join.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\ninner_join(lf, lf)\n```\n\n----------------------------------------\n\nTITLE: Row Number Window Function Implementation in dbplyr\nDESCRIPTION: Illustrates how dbplyr translates row_number() window function into SQL with different contexts. Shows default behavior (ORDER BY NULL), partitioning with group_by(), and custom ordering with arrange(), demonstrating window function syntax generation.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-mssql.md#2025-04-21_snippet_6\n\nLANGUAGE: R\nCODE:\n```\nmf %>% mutate(rown = row_number())\n```\n\nLANGUAGE: R\nCODE:\n```\nmf %>% group_by(y) %>% mutate(rown = row_number())\n```\n\nLANGUAGE: R\nCODE:\n```\nmf %>% arrange(y) %>% mutate(rown = row_number())\n```\n\n----------------------------------------\n\nTITLE: Filtering with Window Functions in dbplyr\nDESCRIPTION: Shows how dbplyr handles filter operations that use window functions. The query includes a subquery that calculates the window function (AVG) and then applies filter conditions.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-filter.md#2025-04-21_snippet_1\n\nLANGUAGE: r\nCODE:\n```\nlf1 %>% remote_query()\n```\n\n----------------------------------------\n\nTITLE: Translating Complex Join Conditions in dbplyr\nDESCRIPTION: Shows how dbplyr translates complex join conditions including equality, greater than or equal, and less than comparisons. The example demonstrates how these conditions are combined in the ON clause of the SQL query.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-joins.md#2025-04-21_snippet_15\n\nLANGUAGE: R\nCODE:\n```\nleft_join(lf1, lf1, by = join_by(a == a, b >= b, c < c), keep = TRUE)\n```\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL>\nSELECT\n  `df_LHS`.`a` AS `a.x`,\n  `df_LHS`.`b` AS `b.x`,\n  `df_LHS`.`c` AS `c.x`,\n  `df_RHS`.`a` AS `a.y`,\n  `df_RHS`.`b` AS `b.y`,\n  `df_RHS`.`c` AS `c.y`\nFROM `df` AS `df_LHS`\nLEFT JOIN `df` AS `df_RHS`\n  ON (\n    `df_LHS`.`a` = `df_RHS`.`a` AND\n    `df_LHS`.`b` >= `df_RHS`.`b` AND\n    `df_LHS`.`c` < `df_RHS`.`c`\n  )\n```\n\n----------------------------------------\n\nTITLE: Mutating Data with SQL Server in R\nDESCRIPTION: Examples of translating R mutate operations to SQL Server syntax using dbplyr. This includes conditional statements, logical operations, and bit conversions.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-mssql.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\nmf %>% mutate(z = ifelse(x == 1L, 1L, 2L))\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT `df`.*, IIF(`x` = 1, 1, 2) AS `z`\nFROM `df`\n```\n\nLANGUAGE: R\nCODE:\n```\nmf %>% mutate(z = case_when(x == 1L ~ 1L))\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT `df`.*, CASE WHEN (`x` = 1) THEN 1 END AS `z`\nFROM `df`\n```\n\nLANGUAGE: R\nCODE:\n```\nmf %>% mutate(z = !is.na(x))\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT `df`.*, ~CAST(IIF((`x` IS NULL), 1, 0) AS BIT) AS `z`\nFROM `df`\n```\n\n----------------------------------------\n\nTITLE: SQL Explain Query for SQLite\nDESCRIPTION: Shows that the explain() function in dbplyr now generates EXPLAIN QUERY PLAN for SQLite databases, which provides a more human-friendly query explanation.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/NEWS.md#2025-04-21_snippet_16\n\nLANGUAGE: SQL\nCODE:\n```\nEXPLAIN QUERY PLAN\n```\n\n----------------------------------------\n\nTITLE: Generating SQL for Basic Count Operation in R using dbplyr\nDESCRIPTION: This snippet demonstrates how dbplyr translates a basic count operation in R to SQL. It groups the data by the 'g' column and counts the occurrences in each group.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-count.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\ndb %>% count(g)\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT `g`, COUNT(*) AS `n`\nFROM `df`\nGROUP BY `g`\n```\n\n----------------------------------------\n\nTITLE: Full Join SQL Generation in DBplyr\nDESCRIPTION: Demonstrates how full_join is translated to SQL. The function creates a FULL JOIN clause that returns all records when there's a match in either the left or right table, using COALESCE to handle nulls.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/query-join.md#2025-04-21_snippet_4\n\nLANGUAGE: R\nCODE:\n```\nfull_join(lf, lf)\n```\n\n----------------------------------------\n\nTITLE: Translating pmin() with na.rm to SQL\nDESCRIPTION: Shows the SQL translation of R's pmin() function with na.rm=TRUE for three variables, using nested IFF and COALESCE functions.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-snowflake.md#2025-04-21_snippet_1\n\nLANGUAGE: SQL\nCODE:\n```\nCOALESCE(IFF(COALESCE(IFF(`x` <= `y`, `x`, `y`), `x`, `y`) <= `z`, COALESCE(IFF(`x` <= `y`, `x`, `y`), `x`, `y`), `z`), COALESCE(IFF(`x` <= `y`, `x`, `y`), `x`, `y`), `z`)\n```\n\n----------------------------------------\n\nTITLE: Chaining Two Filters in dbplyr\nDESCRIPTION: Demonstrates how chaining two filter() operations is equivalent to using a single filter with AND. The result is a SQL query with multiple WHERE conditions.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-filter.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\nlf1 %>% remote_query()\n```\n\n----------------------------------------\n\nTITLE: Pivoting All Columns to Wide Format in DBplyr\nDESCRIPTION: Demonstrates converting a lazy frame with key-value pairs to a wide format where each key becomes a column. The SQL generated uses MAX with CASE WHEN to pivot the data.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-pivot-wider.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\nlazy_frame(key = c(\"x\", \"y\", \"z\"), val = 1:3) %>% dbplyr_pivot_wider_spec(spec)\n```\n\nLANGUAGE: sql\nCODE:\n```\nSELECT\n  MAX(CASE WHEN (`key` = 'x') THEN `val` END) AS `x`,\n  MAX(CASE WHEN (`key` = 'y') THEN `val` END) AS `y`,\n  MAX(CASE WHEN (`key` = 'z') THEN `val` END) AS `z`\nFROM `df`\n```\n\n----------------------------------------\n\nTITLE: Executing Union and Union All Operations in dbplyr\nDESCRIPTION: This snippet shows how to perform union and union all operations on lazy tables using dbplyr. It demonstrates the SQL output for combining multiple tables.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/query-set-op.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nsql_build(union(lf1, lf2) %>% union_all(lf3))\n```\n\n----------------------------------------\n\nTITLE: Generating SQL for Add Count with Sorting Operation in R using dbplyr\nDESCRIPTION: This snippet demonstrates how dbplyr translates an add_count operation with sorting in R to SQL. It uses a window function to add a count column partitioned by 'g' and sorts the result by the count in descending order.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-count.md#2025-04-21_snippet_3\n\nLANGUAGE: R\nCODE:\n```\ndb %>% add_count(g, sort = TRUE)\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT `df`.*, COUNT(*) OVER (PARTITION BY `g`) AS `n`\nFROM `df`\nORDER BY `n` DESC\n```\n\n----------------------------------------\n\nTITLE: New Columns Taking Precedence in dbplyr (R)\nDESCRIPTION: This snippet demonstrates that newly created columns take precedence over global variables in dbplyr. It shows how dbplyr handles variable scoping in mutate() operations.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-mutate.md#2025-04-21_snippet_7\n\nLANGUAGE: R\nCODE:\n```\nremote_query(lf)\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT `q01`.*, `y` + 1.0 AS `z`\nFROM (\n  SELECT `df`.*, 2.0 AS `y`\n  FROM `df`\n) AS `q01`\n```\n\n----------------------------------------\n\nTITLE: Testing arrange() Before Joins in dbplyr\nDESCRIPTION: Shows warnings when arrange() is used before join operations, as the ordering would be lost in the subquery.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-arrange.md#2025-04-21_snippet_15\n\nLANGUAGE: R\nCODE:\n```\nlf <- lazy_frame(a = 1:3, b = 3:1)\nrf <- lazy_frame(a = 1:3, c = 4:6)\n# warn if arrange before join\nlf %>% arrange(a) %>% left_join(rf)\n```\n\n----------------------------------------\n\nTITLE: Filling Missing Values in Pivot Wider with values_fill\nDESCRIPTION: Demonstrates using the values_fill parameter to replace NULL values with zeros in the pivot operation. The SQL uses an extended CASE WHEN with an ELSE clause.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-pivot-wider.md#2025-04-21_snippet_5\n\nLANGUAGE: r\nCODE:\n```\ndbplyr_pivot_wider_spec(df_lazy, spec, values_fill = 0)\n```\n\nLANGUAGE: sql\nCODE:\n```\nSELECT\n  `g`,\n  MAX(CASE WHEN (`name` = 'x') THEN `value` WHEN NOT (`name` = 'x') THEN 0.0 END) AS `x`,\n  MAX(CASE WHEN (`name` = 'y') THEN `value` WHEN NOT (`name` = 'y') THEN 0.0 END) AS `y`\nFROM `df`\nGROUP BY `g`\n```\n\n----------------------------------------\n\nTITLE: Case-Sensitive Column Disambiguation in Full Join\nDESCRIPTION: Demonstrates how full_join handles case-sensitive column conflicts. The COALESCE function is used for joined columns while maintaining distinct names for columns that differ only in case.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/query-join.md#2025-04-21_snippet_8\n\nLANGUAGE: R\nCODE:\n```\nfull_join(lf1, lf2, by = \"y\")\n```\n\n----------------------------------------\n\nTITLE: Combining Union Operations with Joins and CTE in dbplyr\nDESCRIPTION: This snippet shows a more complex example that combines multiple union operations followed by a left join, with the SQL output formatted using Common Table Expressions (CTEs). It demonstrates how dbplyr structures complex queries with temporary result sets.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-set-ops.md#2025-04-21_snippet_1\n\nLANGUAGE: r\nCODE:\n```\nlf1 %>% union_all(lf2) %>% union(lf3) %>% left_join(lf1, by = \"x\") %>%\n  show_query(sql_options = sql_options(cte = TRUE))\n```\n\nLANGUAGE: sql\nCODE:\n```\nWITH `q01` AS (\n  SELECT `lf1`.*, NULL AS `z`\n  FROM `lf1`\n),\n`q02` AS (\n  SELECT NULL AS `x`, `lf2`.*\n  FROM `lf2`\n),\n`q03` AS (\n  SELECT `q01`.*, NULL AS `z`\n  FROM `q02` AS `q01`\n),\n`q04` AS (\n  SELECT NULL AS `x`, NULL AS `y`, `lf3`.*\n  FROM `lf3`\n),\n`q05` AS (\n  SELECT *\n  FROM `q01`\n\n  UNION ALL\n\n  SELECT *\n  FROM `q03`\n\n  UNION\n\n  SELECT *\n  FROM `q04`\n)\nSELECT `LHS`.`x` AS `x`, `LHS`.`y` AS `y.x`, `z`, `lf1`.`y` AS `y.y`\nFROM `q05` AS `LHS`\nLEFT JOIN `lf1`\n  ON (`LHS`.`x` = `lf1`.`x`)\n```\n\n----------------------------------------\n\nTITLE: Generating SQL for rows_update with in_place=FALSE\nDESCRIPTION: Shows SQL generation for rows_update with in_place=FALSE, using UNION ALL to combine non-matching rows and updated rows.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/rows.md#2025-04-21_snippet_23\n\nLANGUAGE: R\nCODE:\n```\nrows_update(lazy_frame(x = 1:3, y = 11:13, .name = \"df_x\"), lazy_frame(x = 2:3, y = 22:23, .name = \"df_y\"), by = \"x\", unmatched = \"ignore\", in_place = FALSE)\n```\n\n----------------------------------------\n\nTITLE: Testing Window Functions with arrange() in dbplyr\nDESCRIPTION: Demonstrates how ORDER BY is preserved when window functions like lag() are used after arranging data.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-arrange.md#2025-04-21_snippet_7\n\nLANGUAGE: R\nCODE:\n```\n# use order\nlf %>% arrange(a) %>% select(-a) %>% mutate(c = lag(b))\n```\n\n----------------------------------------\n\nTITLE: Generating SQL for semi_join with NA matching in dbplyr\nDESCRIPTION: Shows the SQL generation for semi_join with 'na_matches = \"na\"'. Uses 'IS NOT DISTINCT FROM' in the WHERE EXISTS clause to properly handle NA value matching.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-joins.md#2025-04-21_snippet_22\n\nLANGUAGE: r\nCODE:\n```\nsemi_join(lf1, lf2, by = \"x\", na_matches = \"na\")\n```\n\nLANGUAGE: sql\nCODE:\n```\nSELECT `lf1`.*\nFROM `lf1`\nWHERE EXISTS (\n  SELECT 1 FROM `lf2`\n  WHERE (`lf1`.`x` IS NOT DISTINCT FROM `lf2`.`x`)\n)\n```\n\n----------------------------------------\n\nTITLE: Right Join with Custom SQL Join Condition\nDESCRIPTION: Shows a right join with a custom SQL join condition. The sql_on parameter allows for specifying arbitrary SQL expressions as the join criteria.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/query-join.md#2025-04-21_snippet_11\n\nLANGUAGE: R\nCODE:\n```\nright_join(lf1, lf2, sql_on = \"LHS.y < RHS.z\")\n```\n\n----------------------------------------\n\nTITLE: Translating runif() Function in dbplyr to SQL\nDESCRIPTION: Shows how dbplyr translates the R function runif(n()) into SQL. The translation uses a combination of constants and the RANDOM() function to simulate uniform random number generation.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-sqlite.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\ntest_translate_sql(runif(n()))\n```\n\nLANGUAGE: SQL\nCODE:\n```\n(0.5 + RANDOM() / 18446744073709551616.0)\n```\n\n----------------------------------------\n\nTITLE: Generating SQL for Add Count with Group By Operation in R using dbplyr\nDESCRIPTION: This snippet shows how dbplyr translates an add_count operation with a preceding group_by in R to SQL. It uses a window function to add a count column partitioned by 'g' without changing the original grouping.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-count.md#2025-04-21_snippet_4\n\nLANGUAGE: R\nCODE:\n```\ndb %>% group_by(g) %>% add_count()\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT `df`.*, COUNT(*) OVER (PARTITION BY `g`) AS `n`\nFROM `df`\n```\n\n----------------------------------------\n\nTITLE: Generating SQL MERGE Statement for Upsert Operations\nDESCRIPTION: Demonstrates how sql_query_upsert() creates a MERGE statement for performing upsert operations. The example includes update conditions, matching columns, and returning specific columns.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-oracle.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\nsql_query_upsert(con = con, table = ident(\"df_x\"), from = sql_render(df_y, con,\n  lvl = 1), by = c(\"a\", \"b\"), update_cols = c(\"c\", \"d\"), returning_cols = c(\"a\",\n  b2 = \"b\"), method = \"merge\")\n```\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL> MERGE INTO `df_x`\nUSING (\n  SELECT `a`, `b`, `c` + 1.0 AS `c`, `d`\n  FROM `df_y`\n) `...y`\n  ON (`...y`.`a` = `df_x`.`a` AND `...y`.`b` = `df_x`.`b`)\nWHEN MATCHED THEN\n  UPDATE SET `c` = `...y`.`c`, `d` = `...y`.`d`\nWHEN NOT MATCHED THEN\n  INSERT (`a`, `b`, `c`, `d`)\n  VALUES (`...y`.`a`, `...y`.`b`, `...y`.`c`, `...y`.`d`)\nRETURNING `df_x`.`a`, `df_x`.`b` AS `b2`\n;\n```\n\n----------------------------------------\n\nTITLE: Using across() with Grouping Variables in dbplyr (R)\nDESCRIPTION: These snippets show how across() behaves with grouping variables in dbplyr. It demonstrates that across() does not select grouping variables when used with mutate() or transmute().\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-mutate.md#2025-04-21_snippet_4\n\nLANGUAGE: R\nCODE:\n```\ndf %>% group_by(g) %>% mutate(across(.fns = ~0))\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT `g`, 0.0 AS `x`\nFROM `df`\n```\n\nLANGUAGE: R\nCODE:\n```\ndf %>% group_by(g) %>% transmute(across(.fns = ~0))\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT `g`, 0.0 AS `x`\nFROM `df`\n```\n\n----------------------------------------\n\nTITLE: Translating row_number() with group_by and arrange\nDESCRIPTION: Shows how dbplyr translates row_number() with both group_by and arrange into SQL using PARTITION BY and ORDER BY in the OVER clause.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/translate-sql-window.md#2025-04-21_snippet_4\n\nLANGUAGE: R\nCODE:\n```\nmf %>% group_by(y) %>% arrange(y) %>% mutate(rown = row_number())\n```\n\n----------------------------------------\n\nTITLE: Using copy_inline with UNION ALL in dbplyr\nDESCRIPTION: This snippet shows how copy_inline function in dbplyr uses UNION ALL for data insertion. It demonstrates handling of empty data frames and custom data types, creating a temporary table structure.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-hana.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\ncopy_inline(con, y %>% slice(0)) %>% remote_query()\n```\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL> SELECT CAST(NULL AS INTEGER) AS `id`, CAST(NULL AS VARCHAR) AS `arr`\nFROM `DUMMY`\nWHERE (0 = 1)\n```\n\nLANGUAGE: R\nCODE:\n```\ncopy_inline(con, y) %>% remote_query()\n```\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL> SELECT CAST(`id` AS INTEGER) AS `id`, CAST(`arr` AS VARCHAR) AS `arr`\nFROM (\n  SELECT NULL AS `id`, NULL AS `arr`\n  FROM `DUMMY`\n  WHERE (0 = 1)\n\n  UNION ALL\n\n  SELECT 1, '{1,2,3}' FROM DUMMY\n) AS `values_table`\n```\n\nLANGUAGE: R\nCODE:\n```\ncopy_inline(con, y %>% slice(0), types = types) %>% remote_query()\n```\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL> SELECT CAST(NULL AS bigint) AS `id`, CAST(NULL AS integer[]) AS `arr`\nFROM `DUMMY`\nWHERE (0 = 1)\n```\n\nLANGUAGE: R\nCODE:\n```\ncopy_inline(con, y, types = types) %>% remote_query()\n```\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL> SELECT CAST(`id` AS bigint) AS `id`, CAST(`arr` AS integer[]) AS `arr`\nFROM (\n  SELECT NULL AS `id`, NULL AS `arr`\n  FROM `DUMMY`\n  WHERE (0 = 1)\n\n  UNION ALL\n\n  SELECT 1, '{1,2,3}' FROM DUMMY\n) AS `values_table`\n```\n\n----------------------------------------\n\nTITLE: Translating case_when with TRUE as Default Condition\nDESCRIPTION: Demonstrates how case_when with multiple conditions and a TRUE fallback is translated to SQL with an ELSE clause.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/translate-sql-conditional.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\ntest_translate_sql(case_when(x == 1L ~ \"yes\", x == 0L ~ \"no\", TRUE ~ \"undefined\"))\n```\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL> CASE WHEN (`x` = 1) THEN 'yes' WHEN (`x` = 0) THEN 'no' ELSE 'undefined' END\n```\n\n----------------------------------------\n\nTITLE: Using I() to Specify Qualified Table Names in dbplyr\nDESCRIPTION: Demonstrates how to refer to qualified table names in dbplyr using the I() function, which is the simplest way to specify schema-qualified tables.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/NEWS.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nI(\"schema_name.table_name\")\n```\n\n----------------------------------------\n\nTITLE: Overriding Output Column Type in DBPlyr pivot_longer\nDESCRIPTION: Shows how to use values_transform to override the default output column type during a pivot_longer operation. This example converts the value column to TEXT type using CAST in the resulting SQL.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-pivot-longer.md#2025-04-21_snippet_5\n\nLANGUAGE: r\nCODE:\n```\nlazy_frame(x = 1) %>% tidyr::pivot_longer(x, values_transform = list(value = as.character))\n```\n\nLANGUAGE: sql\nCODE:\n```\nSELECT 'x' AS `name`, CAST(`x` AS TEXT) AS `value`\nFROM `df`\n```\n\n----------------------------------------\n\nTITLE: Copying Inline Data to MariaDB with Type Casting\nDESCRIPTION: Shows how dbplyr generates SQL to create an inline table from R data in MariaDB. It uses UNION ALL with VALUES to insert data and applies appropriate type casting for different columns.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-mysql.md#2025-04-21_snippet_5\n\nLANGUAGE: R\nCODE:\n```\ncopy_inline(con_maria, tibble(x = 1:2, y = letters[1:2])) %>% remote_query()\n```\n\n----------------------------------------\n\nTITLE: Collapsing Mutate Over Nested Select in R using dbplyr\nDESCRIPTION: These snippets demonstrate how dbplyr collapses mutate operations over nested select operations. It shows SQL generation for selecting computed columns and existing columns after a mutate operation.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-select.md#2025-04-21_snippet_10\n\nLANGUAGE: R\nCODE:\n```\nlf %>% mutate(a = 1, b = 2) %>% select(a)\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT 1.0 AS `a`\nFROM `df`\n```\n\nLANGUAGE: R\nCODE:\n```\nlf %>% mutate(a = 1, b = 2) %>% select(x)\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT `x`\nFROM `df`\n```\n\n----------------------------------------\n\nTITLE: Creating Separate Queries for Right/Full Joins in dbplyr\nDESCRIPTION: Shows how multiple joins involving right or full joins produce separate nested queries rather than a single query. This demonstrates dbplyr's handling of more complex join types that require separate treatment.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-joins.md#2025-04-21_snippet_13\n\nLANGUAGE: R\nCODE:\n```\nremote_query(out)\n```\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL> SELECT `df3`.`x` AS `x`, `a`, `LHS`.`b` AS `b.x`, `df3`.`b` AS `b.y`\nFROM (\n  SELECT `df1`.*, `b`\n  FROM `df1`\n  LEFT JOIN `df2`\n    ON (`df1`.`x` = `df2`.`x`)\n) AS `LHS`\nRIGHT JOIN `df3`\n  ON (`LHS`.`x` = `df3`.`x`)\n```\n\n----------------------------------------\n\nTITLE: SQL Output for tidyr::expand with CROSS JOIN\nDESCRIPTION: The SQL translation of tidyr::expand() that selects distinct values from each column and cross joins them to create all combinations.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-expand.md#2025-04-21_snippet_1\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL>\nSELECT `x`, `y`\nFROM (\n  SELECT DISTINCT `x`\n  FROM `df`\n) AS `LHS`\nCROSS JOIN (\n  SELECT DISTINCT `y`\n  FROM `df`\n) AS `RHS`\n```\n\n----------------------------------------\n\nTITLE: Using a Formula as values_fn in Pivot Wider\nDESCRIPTION: Shows how to use a formula as the values_fn parameter for aggregation with custom options. The example uses sum with na.rm=TRUE via formula syntax.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-pivot-wider.md#2025-04-21_snippet_4\n\nLANGUAGE: r\nCODE:\n```\ndbplyr_pivot_wider_spec(df, spec1, values_fn = ~ sum(.x, na.rm = TRUE))\n```\n\nLANGUAGE: sql\nCODE:\n```\nSELECT `a`, SUM(CASE WHEN (`key` = 'x') THEN `val` END) AS `x`\nFROM `df`\nGROUP BY `a`\n```\n\n----------------------------------------\n\nTITLE: Left Join with Custom SQL Join Condition\nDESCRIPTION: Demonstrates a left join with a custom SQL join condition. The sql_on parameter allows for complex join criteria while maintaining the left join behavior.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/query-join.md#2025-04-21_snippet_10\n\nLANGUAGE: R\nCODE:\n```\nleft_join(lf1, lf2, sql_on = \"LHS.y < RHS.z\")\n```\n\n----------------------------------------\n\nTITLE: Dropping Missing Values in DBPlyr pivot_longer\nDESCRIPTION: Shows how to use the values_drop_na parameter to remove NULL values when pivoting data to long format. This creates a subquery and filters out rows where the value is NULL using a WHERE clause.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-pivot-longer.md#2025-04-21_snippet_3\n\nLANGUAGE: r\nCODE:\n```\nlazy_frame(x = c(1, NA), y = c(NA, 2)) %>% tidyr::pivot_longer(x:y,\nvalues_drop_na = TRUE)\n```\n\nLANGUAGE: sql\nCODE:\n```\nSELECT `q01`.*\nFROM (\n  SELECT 'x' AS `name`, `x` AS `value`\n  FROM `df`\n\n  UNION ALL\n\n  SELECT 'y' AS `name`, `y` AS `value`\n  FROM `df`\n) AS `q01`\nWHERE (NOT((`value` IS NULL)))\n```\n\n----------------------------------------\n\nTITLE: Demonstrating rows_patch() with in_place=FALSE\nDESCRIPTION: Shows how rows_patch() generates SQL to update rows from one table with matching rows from another, using in_place=FALSE. The operation matches rows by 'x' column and ignores unmatched rows.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/rows.md#2025-04-21_snippet_27\n\nLANGUAGE: R\nCODE:\n```\nrows_patch(lazy_frame(x = 1:3, y = c(11, 12, NA), .name = \"df_x\"), lazy_frame(\n  x = 2:3, y = 22:23, .name = \"df_y\"), by = \"x\", unmatched = \"ignore\",\nin_place = FALSE)\n```\n\n----------------------------------------\n\nTITLE: Joining Four Tables with Same Column in dbplyr\nDESCRIPTION: Demonstrates joining four tables that share a common join column. The example shows how inner joins on multiple tables are translated to SQL with appropriate column name disambiguation.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-joins.md#2025-04-21_snippet_12\n\nLANGUAGE: R\nCODE:\n```\nremote_query(out)\n```\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL> SELECT `lf1`.*, `b`, `c`, `lf4`.`a` AS `a4`\nFROM `lf1`\nINNER JOIN `lf2`\n  ON (`lf1`.`x` = `lf2`.`x`)\nINNER JOIN `lf3`\n  ON (`lf1`.`x` = `lf3`.`x`)\nINNER JOIN `lf4`\n  ON (`lf1`.`x` = `lf4`.`x`)\n```\n\n----------------------------------------\n\nTITLE: Translating tidyr::fill() with 'up' direction using non-standard SQL\nDESCRIPTION: Shows the SQL translation of tidyr::fill() with upward direction on a non-standard SQL database. This implementation uses a complex approach with window functions, partitioning, and subqueries to achieve the fill behavior.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-fill.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\ndf_lazy_ns %>% window_order(id) %>% tidyr::fill(n1, .direction = \"up\")\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT\n  `id`,\n  `group`,\n  MAX(`n1`) OVER (PARTITION BY `..dbplyr_partition_1`) AS `n1`\nFROM (\n  SELECT\n    `df`.*,\n    SUM(CASE WHEN ((`n1` IS NULL)) THEN 0 ELSE 1 END) OVER (ORDER BY `id` DESC ROWS UNBOUNDED PRECEDING) AS `..dbplyr_partition_1`\n  FROM `df`\n) AS `q01`\n```\n\n----------------------------------------\n\nTITLE: Using Window Function after Summarise in dbplyr (R)\nDESCRIPTION: This snippet demonstrates the use of a window function (row_number()) after a summarise operation in dbplyr. It shows that window functions can be applied to the result of a group-by and summarise operation.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-mutate.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\n(expect_no_error(lf %>% mutate(r = row_number())))\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT `q01`.*, ROW_NUMBER() OVER () AS `r`\nFROM (\n  SELECT `g`\n  FROM `df`\n  GROUP BY `g`\n) AS `q01`\n```\n\n----------------------------------------\n\nTITLE: Insert with Conflict Handling Query\nDESCRIPTION: SQL query for inserting data with ON CONFLICT DO NOTHING clause and returning specific columns.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-postgres.md#2025-04-21_snippet_3\n\nLANGUAGE: SQL\nCODE:\n```\nINSERT INTO `df_x` (`a`, `b`, `c`, `d`)\nSELECT *\nFROM (\n  SELECT `a`, `b`, `c` + 1.0 AS `c`, `d`\n  FROM `df_y`\n) AS `...y`\nON CONFLICT (`a`, `b`)\nDO NOTHING\nRETURNING `df_x`.`a`, `df_x`.`b` AS `b2`\n```\n\n----------------------------------------\n\nTITLE: Using a Named List for values_fill in Pivot Wider\nDESCRIPTION: Shows how to use a named list for the values_fill parameter to specify fill values for particular columns. The SQL result is equivalent to using a scalar values_fill.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-pivot-wider.md#2025-04-21_snippet_6\n\nLANGUAGE: r\nCODE:\n```\ndbplyr_pivot_wider_spec(df_lazy, spec, values_fill = list(value = 0))\n```\n\nLANGUAGE: sql\nCODE:\n```\nSELECT\n  `g`,\n  MAX(CASE WHEN (`name` = 'x') THEN `value` WHEN NOT (`name` = 'x') THEN 0.0 END) AS `x`,\n  MAX(CASE WHEN (`name` = 'y') THEN `value` WHEN NOT (`name` = 'y') THEN 0.0 END) AS `y`\nFROM `df`\nGROUP BY `g`\n```\n\n----------------------------------------\n\nTITLE: Example of case_match() Usage in dbplyr\nDESCRIPTION: Demonstration of case_match() support added in dbplyr 2.3.5, which works with strings on the left-hand side. This provides a simpler syntax for matching values against patterns.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/NEWS.md#2025-04-21_snippet_6\n\nLANGUAGE: r\nCODE:\n```\ncase_match(\"string_value\", pattern ~ result)\n```\n\n----------------------------------------\n\nTITLE: Handling Missing Combinations in DBPlyr pivot_longer\nDESCRIPTION: Demonstrates how DBPlyr handles missing combinations in pivoted data, adding NULL for values that don't exist in the original data. This example shows how to pivot with potentially incomplete data structures.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-pivot-longer.md#2025-04-21_snippet_4\n\nLANGUAGE: r\nCODE:\n```\nsql\n```\n\nLANGUAGE: sql\nCODE:\n```\nSELECT `q01`.*, NULL AS `y`\nFROM (\n  SELECT `id`, '1' AS `n`, `x_1` AS `x`\n  FROM `df`\n) AS `q01`\n\nUNION ALL\n\nSELECT `id`, '2' AS `n`, `x_2` AS `x`, `y_2` AS `y`\nFROM `df`\n```\n\n----------------------------------------\n\nTITLE: Implementing Inner Join with Table Aliases in dbplyr\nDESCRIPTION: Shows how inner_join translates to SQL with custom table aliases. This example demonstrates the SQL generation for inner joins with aliased tables.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-joins.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\ninner_join(lf1, lf2, by = \"x\", x_as = \"df1\", y_as = \"df2\")\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT `df1`.*\nFROM `df` AS `df1`\nINNER JOIN `df` AS `df2`\n  ON (`df1`.`x` = `df2`.`x`)\n```\n\n----------------------------------------\n\nTITLE: Left Join with Column Renaming in DBplyr\nDESCRIPTION: Demonstrates how to join tables with explicit column mapping. This example joins using different column names (y in the left table matched to z in the right table) and renames columns to avoid conflicts.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/query-join.md#2025-04-21_snippet_6\n\nLANGUAGE: R\nCODE:\n```\nleft_join(lf1, lf2, by = c(y = \"z\"))\n```\n\n----------------------------------------\n\nTITLE: Using translate_sql() and partial_eval() in R with dbplyr\nDESCRIPTION: This snippet demonstrates the refined usage of translate_sql() and partial_eval() functions, showing that translate_sql() no longer takes a vars argument and works with a list of dots.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/NEWS.md#2025-04-21_snippet_24\n\nLANGUAGE: R\nCODE:\n```\ntranslate_sql()\npartial_eval()\n```\n\n----------------------------------------\n\nTITLE: SQL Output for tidyr::replace_na with COALESCE\nDESCRIPTION: The SQL translation of replace_na, using COALESCE to replace NULL values with specified defaults.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-expand.md#2025-04-21_snippet_21\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL>\nSELECT COALESCE(`x`, 0.0) AS `x`, COALESCE(`y`, 'unknown') AS `y`\nFROM `df`\n```\n\n----------------------------------------\n\nTITLE: Translating head() to SQL FETCH FIRST\nDESCRIPTION: Shows how the head() function in dplyr is translated to SQL using FETCH FIRST syntax to limit the number of rows returned.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-oracle.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\nmf %>% head()\n```\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL>\nSELECT `df`.*\nFROM `df`\nFETCH FIRST 6 ROWS ONLY\n```\n\n----------------------------------------\n\nTITLE: Anti Join with Custom SQL Join Condition\nDESCRIPTION: Demonstrates how anti_join with a custom SQL condition is translated to SQL using NOT EXISTS. This returns all rows from the left table where there is no match in the right table based on the condition.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/query-join.md#2025-04-21_snippet_14\n\nLANGUAGE: R\nCODE:\n```\nanti_join(lf1, lf2, sql_on = \"LHS.y < RHS.z\")\n```\n\n----------------------------------------\n\nTITLE: Semi-Join with Filter Condition in dbplyr\nDESCRIPTION: Demonstrates a semi-join operation between two lazy frames (lf1 and lf2) with an additional filter condition. Shows the SQL build output structure including the join condition and filter clause.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/query-semi-join.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\nsql_build(semi_join(lf1, lf2 %>% filter(z == 2)))\n```\n\n----------------------------------------\n\nTITLE: Translating grouped tidyr::fill() using standard SQL\nDESCRIPTION: Shows the SQL translation of tidyr::fill() with grouping on a standard SQL database. This implementation respects groups by including them in the partition clause of the LAST_VALUE window function.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-fill.md#2025-04-21_snippet_7\n\nLANGUAGE: R\nCODE:\n```\ngroup_by(df_lazy_std, group) %>% window_order(id) %>% tidyr::fill(n1)\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT\n  `id`,\n  `group`,\n  LAST_VALUE(`n1` IGNORE NULLS) OVER (PARTITION BY `group` ORDER BY `id` ROWS UNBOUNDED PRECEDING) AS `n1`\nFROM `df`\n```\n\n----------------------------------------\n\nTITLE: Generating SQL for Sorted Count Operation in R using dbplyr\nDESCRIPTION: This snippet illustrates how dbplyr translates a sorted count operation in R to SQL. It groups the data by the 'g' column, counts occurrences, and sorts the result in descending order.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-count.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\ndb %>% count(g, sort = TRUE)\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT `g`, COUNT(*) AS `n`\nFROM `df`\nGROUP BY `g`\nORDER BY `n` DESC\n```\n\n----------------------------------------\n\nTITLE: Translating R quantile() to SQL PERCENTILE_CONT with grouping\nDESCRIPTION: Tests the translation of R's quantile function to SQL with grouping, using PARTITION BY clause for group-wise calculation of the 75th percentile.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/translate-sql-quantile.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\ntest_translate_sql(quantile(x, 0.75, na.rm = TRUE), vars_group = \"g\")\n```\n\n----------------------------------------\n\nTITLE: Demonstrating rows_upsert() with in_place=FALSE\nDESCRIPTION: Shows the SQL generated by rows_upsert() to update matching rows and insert new rows from one table to another. The operation uses UNION ALL to combine preserved rows, updated rows, and new rows.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/rows.md#2025-04-21_snippet_31\n\nLANGUAGE: R\nCODE:\n```\nrows_upsert(lazy_frame(x = 1:3, y = 11:13, .name = \"df_x\"), lazy_frame(x = 2:3,\ny = 22:23, .name = \"df_y\"), by = \"x\", in_place = FALSE)\n```\n\n----------------------------------------\n\nTITLE: Rendering Lazy Frame SQL Query in R\nDESCRIPTION: This code snippet shows the SQL query generated by dbplyr for a simple select operation on a lazy frame. It demonstrates that unnecessary aliasing is avoided in the generated SQL.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/query-select.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\nlf_render\n```\n\n----------------------------------------\n\nTITLE: Querying Database Table with dplyr\nDESCRIPTION: Shows how to retrieve and display database table data using tbl() function, which lazily loads only the first few rows.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/README.md#2025-04-21_snippet_2\n\nLANGUAGE: r\nCODE:\n```\nmtcars2 <- tbl(con, \"mtcars\")\nmtcars2\n```\n\n----------------------------------------\n\nTITLE: Left Join with Column Selection in DBplyr\nDESCRIPTION: Shows how left_join selectively disambiguates only shared variables. When joining tables with some columns in common, DBplyr only needs to disambiguate the overlapping column names.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/query-join.md#2025-04-21_snippet_5\n\nLANGUAGE: R\nCODE:\n```\nleft_join(lf1, lf2)\n```\n\n----------------------------------------\n\nTITLE: Right Join SQL Generation in DBplyr\nDESCRIPTION: Shows how right_join is translated to SQL. The function creates a RIGHT JOIN clause that returns all records from the right table and matching records from the left table.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/query-join.md#2025-04-21_snippet_3\n\nLANGUAGE: R\nCODE:\n```\nright_join(lf, lf)\n```\n\n----------------------------------------\n\nTITLE: Testing Basic arrange() Usage with dbplyr\nDESCRIPTION: Demonstrates basic SQL generation for arrange() operations on lazy frames, including double arrange, removing ordered columns, and canceling ordering.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-arrange.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\nlf <- lazy_frame(a = 1:3, b = 3:1)\n# basic\nlf %>% arrange(a)\n```\n\n----------------------------------------\n\nTITLE: Using nesting() with tidyr::expand\nDESCRIPTION: Shows how tidyr::nesting() with expand() preserves existing combinations rather than expanding to all possible combinations.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-expand.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\ndf_lazy %>% tidyr::expand(nesting(x, y))\n```\n\n----------------------------------------\n\nTITLE: across() Using Original Columns in dbplyr (R)\nDESCRIPTION: This snippet shows that across() uses the original column values rather than overridden ones in dbplyr. It demonstrates how across() preserves the original column values even when they are modified in the same mutate() call.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-mutate.md#2025-04-21_snippet_6\n\nLANGUAGE: R\nCODE:\n```\nlf %>% mutate(x = -x, across(everything(), ~ .x / x), y = y + x)\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT `x`, `y` + `x` AS `y`, `z`\nFROM (\n  SELECT `x` / `x` AS `x`, `y` / `x` AS `y`, `z` / `x` AS `z`\n  FROM (\n    SELECT -`x` AS `x`, `y`, `z`\n    FROM `df`\n  ) AS `q01`\n) AS `q01`\n```\n\n----------------------------------------\n\nTITLE: Testing sql_query_upsert() SQL generation\nDESCRIPTION: Shows the advanced SQL generated by sql_query_upsert() for database systems that support CTE (WITH clauses) and RETURNING functionality. The query updates existing rows and inserts new ones in a single transaction.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/rows.md#2025-04-21_snippet_33\n\nLANGUAGE: R\nCODE:\n```\nsql_query_upsert(con = con, table = ident(\"df_x\"), from = sql_render(df_y, con,\n  lvl = 1), by = c(\"a\", \"b\"), update_cols = c(\"c\", \"d\"), returning_cols = c(\"a\",\n  b2 = \"b\"))\n```\n\n----------------------------------------\n\nTITLE: Translating tidyr::fill() with 'up' direction using standard SQL\nDESCRIPTION: Shows the SQL translation of tidyr::fill() with upward direction on a standard SQL database. This implementation uses LAST_VALUE with IGNORE NULLS in a window function for a more elegant solution.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-fill.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\ndf_lazy_std %>% window_order(id) %>% tidyr::fill(n1, .direction = \"up\")\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT\n  `id`,\n  `group`,\n  LAST_VALUE(`n1` IGNORE NULLS) OVER (ORDER BY `id` DESC ROWS UNBOUNDED PRECEDING) AS `n1`\nFROM `df`\n```\n\n----------------------------------------\n\nTITLE: Creating Left Join SQL with NA Matching in MySQL/MariaDB\nDESCRIPTION: Demonstrates how dbplyr generates a LEFT JOIN SQL query with special handling for NA values using the <=> operator instead of the standard equals operator. This ensures proper NA matching behavior.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-mysql.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\nleft_join(lf, lf, by = \"x\", na_matches = \"na\")\n```\n\n----------------------------------------\n\nTITLE: Query Collapsing with Nested select() in dbplyr (R)\nDESCRIPTION: These snippets demonstrate how mutate() collapses over nested select() operations in dbplyr. They show that dbplyr can optimize queries by combining select() and mutate() operations.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-mutate.md#2025-04-21_snippet_10\n\nLANGUAGE: R\nCODE:\n```\nlf %>% select(x:y) %>% mutate(x = x * 2, y = y * 2)\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT `x` * 2.0 AS `x`, `y` * 2.0 AS `y`\nFROM `df`\n```\n\nLANGUAGE: R\nCODE:\n```\nlf %>% select(y:x) %>% mutate(x = x * 2, y = y * 2)\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT `y` * 2.0 AS `y`, `x` * 2.0 AS `x`\nFROM `df`\n```\n\n----------------------------------------\n\nTITLE: Filtering with Window Functions and External Vectors\nDESCRIPTION: Shows how dbplyr handles filter operations that combine window functions (max) with external vector references (%in%). This generates a SQL query with a subquery for the window function.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-filter.md#2025-04-21_snippet_6\n\nLANGUAGE: r\nCODE:\n```\nlazy_frame(x = 1L) %>% filter(x == max(x, na.rm = T), x %in% to_filter)\n```\n\n----------------------------------------\n\nTITLE: Inner Join with Custom SQL Join Condition\nDESCRIPTION: Shows how to create an inner join with a custom SQL condition using sql_on parameter. This allows for join conditions beyond simple equality, such as inequalities between columns.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/query-join.md#2025-04-21_snippet_9\n\nLANGUAGE: R\nCODE:\n```\ninner_join(lf1, lf2, sql_on = \"LHS.y < RHS.z\")\n```\n\n----------------------------------------\n\nTITLE: Using HAVING Clause with filter() after summarise()\nDESCRIPTION: Demonstrates how dbplyr generates SQL with a HAVING clause when filter() is used after summarise(). The filter condition uses a grouping variable.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-filter.md#2025-04-21_snippet_7\n\nLANGUAGE: r\nCODE:\n```\n(out <- lf %>% filter(g == 1))\n```\n\n----------------------------------------\n\nTITLE: Handling Long Table Names in Joins with dbplyr\nDESCRIPTION: Shows how dbplyr handles long table names in join operations by truncating aliases at database limits. The examples demonstrate complex joins with very long table names and how they are aliased in the SQL output.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-joins.md#2025-04-21_snippet_3\n\nLANGUAGE: R\nCODE:\n```\nself_join2 %>% remote_query()\n```\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL> SELECT \"a01234567890123456789012345678901234567890123456789012345678901\".*\nFROM \"a01234567890123456789012345678901234567890123456789012345678901\"\nLEFT JOIN \"a01234567890123456789012345678901234567890123456789012345678901\" AS \"34567890123456789012345678901234567890123456789012345678901_RHS\"\n  ON (\n    \"a01234567890123456789012345678901234567890123456789012345678901\".\"x\" = \"34567890123456789012345678901234567890123456789012345678901_RHS\".\"x\" AND\n    \"a01234567890123456789012345678901234567890123456789012345678901\".\"y\" = \"34567890123456789012345678901234567890123456789012345678901_RHS\".\"y\"\n  )\n```\n\nLANGUAGE: R\nCODE:\n```\nself_join3 %>% remote_query()\n```\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL> SELECT\n  \"a01234567890123456789012345678901234567890123456789012345678901\".\"x\" AS \"x\",\n  \"a01234567890123456789012345678901234567890123456789012345678901\".\"y\" AS \"y.x\",\n  \"b01234567890123456789012345678901234567890123456789012345678901\".\"y\" AS \"y.y\"\nFROM \"a01234567890123456789012345678901234567890123456789012345678901\"\nLEFT JOIN \"a01234567890123456789012345678901234567890123456789012345678901\" AS \"34567890123456789012345678901234567890123456789012345678901...2\"\n  ON (\n    \"a01234567890123456789012345678901234567890123456789012345678901\".\"x\" = \"34567890123456789012345678901234567890123456789012345678901...2\".\"x\" AND\n    \"a01234567890123456789012345678901234567890123456789012345678901\".\"y\" = \"34567890123456789012345678901234567890123456789012345678901...2\".\"y\"\n  )\nINNER JOIN \"b01234567890123456789012345678901234567890123456789012345678901\"\n  ON (\"a01234567890123456789012345678901234567890123456789012345678901\".\"x\" = \"b01234567890123456789012345678901234567890123456789012345678901\".\"x\")\n```\n\n----------------------------------------\n\nTITLE: Basic dbplyr Uncount Query Generation\nDESCRIPTION: Demonstrates the SQL query generated when using dbplyr_uncount with a direct weight column. The query creates a row expansion based on the weight column 'w' using an INNER JOIN with a generated sequence.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-uncount.md#2025-04-21_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\nSELECT `x`\nFROM `test`\nINNER JOIN (\n  SELECT CAST(`..dbplyr_row_id` AS INTEGER) AS `..dbplyr_row_id`\n  FROM (\n    SELECT NULL AS `..dbplyr_row_id`\n    WHERE (0 = 1)\n\n    UNION ALL\n\n    VALUES (1)\n  ) AS `values_table`\n) AS `RHS`\n  ON (`RHS`.`..dbplyr_row_id` <= `test`.`w`)\n```\n\n----------------------------------------\n\nTITLE: Ordering by Multiple Variables in slice_min/max with dbplyr\nDESCRIPTION: Example of using slice_min/max with multiple ordering variables in dbplyr 2.3.5. This feature allows ordering by multiple columns by wrapping them in a tibble() call.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/NEWS.md#2025-04-21_snippet_4\n\nLANGUAGE: r\nCODE:\n```\nslice_min(lf, tibble(x, y))\n```\n\n----------------------------------------\n\nTITLE: Translating Substring Operations in R to SQL using dbplyr\nDESCRIPTION: This snippet demonstrates how dbplyr translates R's substr, substring, and str_sub functions to SQL SUBSTRING function. It handles different input formats and negative indexing.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-hana.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\ntest_translate_sql(substr(x, 2, 4))\n```\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL> SUBSTRING(`x`, 2, 3)\n```\n\nLANGUAGE: R\nCODE:\n```\ntest_translate_sql(substring(x, 2, 4))\n```\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL> SUBSTRING(`x`, 2, 3)\n```\n\nLANGUAGE: R\nCODE:\n```\ntest_translate_sql(str_sub(x, 2, -2))\n```\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL> SUBSTRING(`x`, 2, LENGTH(`x`) - 2)\n```\n\n----------------------------------------\n\nTITLE: Testing arrange() After Joins in dbplyr\nDESCRIPTION: Demonstrates correct SQL generation when arrange() follows join operations.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-arrange.md#2025-04-21_snippet_18\n\nLANGUAGE: R\nCODE:\n```\n# can arrange after join\nlf %>% left_join(rf) %>% arrange(a)\n```\n\n----------------------------------------\n\nTITLE: Distinct with Window Ordering\nDESCRIPTION: Demonstrates distinct operation with window_order and .keep_all=TRUE, using ROW_NUMBER() OVER with custom partition and ordering.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-distinct.md#2025-04-21_snippet_1\n\nLANGUAGE: r\nCODE:\n```\nlf %>% window_order(desc(y)) %>% distinct(x, .keep_all = TRUE)\n```\n\nLANGUAGE: sql\nCODE:\n```\nSELECT `x`, `y`\nFROM (\n  SELECT\n    `df`.*,\n    ROW_NUMBER() OVER (PARTITION BY `x` ORDER BY `y` DESC) AS `col01`\n  FROM `df`\n) AS `q01`\nWHERE (`col01` = 1)\n```\n\n----------------------------------------\n\nTITLE: Preserving Original Keys in DBPlyr pivot_longer\nDESCRIPTION: Demonstrates how pivot_longer preserves original keys (x column) when pivoting other columns to a long format. The operation keeps the key column while transforming y and z columns into name-value pairs.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-pivot-longer.md#2025-04-21_snippet_2\n\nLANGUAGE: r\nCODE:\n```\npv\n```\n\nLANGUAGE: sql\nCODE:\n```\nSELECT `x`, 'y' AS `name`, `y` AS `value`\nFROM `df`\n\nUNION ALL\n\nSELECT `x`, 'z' AS `name`, `z` AS `value`\nFROM `df`\n```\n\n----------------------------------------\n\nTITLE: Executing non-query SQL commands in R with dbplyr\nDESCRIPTION: This snippet shows the use of DBI::dbExecute() for non-query SQL commands, replacing the deprecated fetch() function.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/NEWS.md#2025-04-21_snippet_22\n\nLANGUAGE: R\nCODE:\n```\nDBI::dbExecute()\n```\n\n----------------------------------------\n\nTITLE: Demonstrating rows_patch() with multiple columns\nDESCRIPTION: Shows how rows_patch() handles updating multiple columns (y and z) from one table with values from another table. It matches rows by 'x' column and uses COALESCE to handle NULL values in both tables.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/rows.md#2025-04-21_snippet_28\n\nLANGUAGE: R\nCODE:\n```\nrows_patch(lazy_frame(x = 1:3, y = c(11, 12, NA), z = c(31, NA, 33), .name = \"df_x\"),\nlazy_frame(x = 2:3, y = 22:23, z = 42:43, .name = \"df_y\"), by = \"x\", unmatched = \"ignore\",\nin_place = FALSE)\n```\n\n----------------------------------------\n\nTITLE: Executing Union All Operation in dbplyr\nDESCRIPTION: This code snippet shows how to perform a union all operation on two identical lazy tables using dbplyr. It generates SQL for combining all rows from both tables, including duplicates.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/query-set-op.md#2025-04-21_snippet_4\n\nLANGUAGE: R\nCODE:\n```\nunion(lf, lf, all = TRUE)\n```\n\n----------------------------------------\n\nTITLE: Translating row_number() with no grouping or ordering\nDESCRIPTION: Shows how dbplyr translates a simple row_number() call without any grouping or ordering into SQL using OVER clause.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/translate-sql-window.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\nmf %>% mutate(rown = row_number())\n```\n\n----------------------------------------\n\nTITLE: Generating Random Sampling SQL for MySQL/MariaDB\nDESCRIPTION: Demonstrates how dbplyr creates SQL to randomly sample rows from a table using the slice_sample function. It uses ROW_NUMBER() with ORDER BY RAND() to implement randomized sampling.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-mysql.md#2025-04-21_snippet_4\n\nLANGUAGE: R\nCODE:\n```\nslice_sample(lf, n = 1)\n```\n\n----------------------------------------\n\nTITLE: Testing summarise() Modifying Grouping Variables\nDESCRIPTION: These snippets demonstrate that summarise() can modify grouping variables in dbplyr, showing the resulting SQL queries.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-summarise.md#2025-04-21_snippet_3\n\nLANGUAGE: R\nCODE:\n```\n(result1 <- lf %>% group_by(g) %>% summarise(g = g + 1))\n```\n\nLANGUAGE: R\nCODE:\n```\n(result2 <- lf %>% group_by(g) %>% summarise(x = x + 1, g = g + 1))\n```\n\n----------------------------------------\n\nTITLE: Generating SQL for insert with returning columns\nDESCRIPTION: Demonstrates SQL generation for insert operation with returning columns specified, using the NOT EXISTS approach for conflict handling.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/rows.md#2025-04-21_snippet_10\n\nLANGUAGE: R\nCODE:\n```\nsql_query_insert(con = con, table = ident(\"df_x\"), from = sql_render(df_y, con, lvl = 1), insert_cols = colnames(df_y), by = c(\"a\", \"b\"), conflict = \"ignore\", returning_cols = c(\"a\", b2 = \"b\"))\n```\n\n----------------------------------------\n\nTITLE: Chained Mutations in dbplyr (R)\nDESCRIPTION: This snippet shows how multiple chained mutations are handled in dbplyr. It demonstrates that dbplyr can optimize the query by combining multiple mutations into a single operation.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-mutate.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\nshow_query(out2)\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT `x` + 4.0 AS `x`\nFROM (\n  SELECT `x` + 2.0 AS `x`\n  FROM (\n    SELECT `x` + 1.0 AS `x`\n    FROM `multi_mutate`\n  ) AS `q01`\n) AS `q01`\n```\n\n----------------------------------------\n\nTITLE: Using op_vars() in R with dbplyr\nDESCRIPTION: This code shows that op_vars() now returns a list of quoted expressions, enabling escaping to happen at the correct time when the connection is known.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/NEWS.md#2025-04-21_snippet_25\n\nLANGUAGE: R\nCODE:\n```\nop_vars()\n```\n\n----------------------------------------\n\nTITLE: Implementing row_number() With Ordering\nDESCRIPTION: Shows row_number() implementation with explicit ORDER BY clause in SQL.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-teradata.md#2025-04-21_snippet_7\n\nLANGUAGE: R\nCODE:\n```\nmf %>% arrange(y) %>% mutate(rown = row_number())\n```\n\n----------------------------------------\n\nTITLE: Using copy_to() in R with dbplyr for MySQL\nDESCRIPTION: This code demonstrates that copy_to() now succeeds for MySQL when a character column contains NA values, addressing multiple issues.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/NEWS.md#2025-04-21_snippet_21\n\nLANGUAGE: R\nCODE:\n```\ncopy_to()\n```\n\n----------------------------------------\n\nTITLE: Generating SQL Query from Local Dataframe using copy_inline in R\nDESCRIPTION: This snippet demonstrates how copy_inline translates a local dataframe into a SQL query. It handles various data types including logical, integer, double, character, date, and datetime.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-copy-to.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\ncopy_inline(con, df) %>% remote_query()\n```\n\n----------------------------------------\n\nTITLE: Using HAVING with IS NULL Expressions\nDESCRIPTION: Demonstrates how dbplyr handles complex expressions like !is.na() in filter() after summarise(). The condition is translated to a NOT IS NULL expression in the HAVING clause.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-filter.md#2025-04-21_snippet_11\n\nLANGUAGE: r\nCODE:\n```\nlf %>% summarise(x_sum = sum(x, na.rm = TRUE)) %>% filter(!is.na(x_sum))\n```\n\n----------------------------------------\n\nTITLE: Translating row_number() with arrange\nDESCRIPTION: Demonstrates SQL translation of row_number() with explicit ordering by column 'y'.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-snowflake.md#2025-04-21_snippet_5\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT `df`.*, ROW_NUMBER() OVER (ORDER BY `y`) AS `rown`\nFROM `df`\nORDER BY `y`\n```\n\n----------------------------------------\n\nTITLE: Advanced SQL Server Operations in R\nDESCRIPTION: Examples of advanced SQL Server operations implemented in dbplyr, including insert, update, and delete operations with custom conditions and returning clauses.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-mssql.md#2025-04-21_snippet_3\n\nLANGUAGE: R\nCODE:\n```\nsql_query_insert(con = con, table = ident(\"df_x\"), from = sql_render(df_y, con, lvl = 1), insert_cols = colnames(df_y), by = c(\"a\", \"b\"), conflict = \"ignore\", returning_cols = c(\"a\", b2 = \"b\"))\n```\n\nLANGUAGE: SQL\nCODE:\n```\nINSERT INTO `df_x` (`a`, `b`, `c`, `d`)\nOUTPUT `INSERTED`.`a`, `INSERTED`.`b` AS `b2`\nSELECT *\nFROM (\n  SELECT `a`, `b`, `c` + 1.0 AS `c`, `d`\n  FROM `df_y`\n) AS `...y`\nWHERE NOT EXISTS (\n  SELECT 1 FROM `df_x`\n  WHERE (`df_x`.`a` = `...y`.`a`) AND (`df_x`.`b` = `...y`.`b`)\n)\n```\n\nLANGUAGE: R\nCODE:\n```\nsql_query_update_from(con = con, table = ident(\"df_x\"), from = sql_render(df_y, con, lvl = 1), by = c(\"a\", \"b\"), update_values = sql(c = \"COALESCE(`df_x`.`c`, `...y`.`c`)\", d = \"`...y`.`d`\"), returning_cols = c(\"a\", b2 = \"b\"))\n```\n\nLANGUAGE: SQL\nCODE:\n```\nUPDATE `df_x`\nSET `c` = COALESCE(`df_x`.`c`, `...y`.`c`), `d` = `...y`.`d`\nOUTPUT `INSERTED`.`a`, `INSERTED`.`b` AS `b2`\nFROM `df_x`\nINNER JOIN (\n  SELECT `a`, `b`, `c` + 1.0 AS `c`, `d`\n  FROM `df_y`\n) AS `...y`\n  ON `...y`.`a` = `df_x`.`a` AND `...y`.`b` = `df_x`.`b`\n```\n\nLANGUAGE: R\nCODE:\n```\nsql_query_delete(con = simulate_mssql(), table = ident(\"df_x\"), from = sql_render(df_y, simulate_mssql(), lvl = 2), by = c(\"a\", \"b\"), returning_cols = c(\"a\", b2 = \"b\"))\n```\n\nLANGUAGE: SQL\nCODE:\n```\nDELETE FROM `df_x`\nOUTPUT `DELETED`.`a`, `DELETED`.`b` AS `b2`\nWHERE EXISTS (\n  SELECT 1 FROM (\n    SELECT `a`, `b`, `c` + 1.0 AS `c`, `d`\n    FROM `df_y`\n) AS `...y`\n  WHERE (`...y`.`a` = `df_x`.`a`) AND (`...y`.`b` = `df_x`.`b`)\n)\n```\n\n----------------------------------------\n\nTITLE: SQL Generation Generic Renames\nDESCRIPTION: Renaming of SQL generation generic functions to facilitate migration from dplyr to dbplyr.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/NEWS.md#2025-04-21_snippet_12\n\nLANGUAGE: R\nCODE:\n```\ndplyr::sql_select() -> dbplyr::sql_query_select()\ndplyr::sql_join() -> dbplyr::sql_query_join()\ndplyr::sql_semi_join() -> dbplyr::sql_query_semi_join()\ndplyr::sql_set_op() -> dbplyr::sql_query_set_op()\ndplyr::sql_subquery() -> dbplyr::sql_query_wrap()\ndplyr::db_desc() -> dbplyr::db_connection_describe()\n```\n\n----------------------------------------\n\nTITLE: Handling Filtered Aggregates in Semi Joins with dbplyr\nDESCRIPTION: Demonstrates that filtered aggregates with subsequent select operations are not inlined away in semi_join operations. The example shows how grouped aggregation is preserved in a subquery when used with semi_join.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-joins.md#2025-04-21_snippet_10\n\nLANGUAGE: R\nCODE:\n```\nout\n```\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL>\nSELECT `df`.*\nFROM `df`\nWHERE EXISTS (\n  SELECT 1 FROM (\n  SELECT `x`\n  FROM `df`\n  GROUP BY `x`\n  HAVING (COUNT(*) = 1.0)\n) AS `RHS`\n  WHERE (`df`.`x` = `RHS`.`x`)\n)\n```\n\n----------------------------------------\n\nTITLE: Slice Min/Max Error Handling\nDESCRIPTION: Shows error handling for slice_min and slice_max operations, including required arguments, property constraints, and NA handling requirements for database backends.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-slice.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\ndb %>% slice_min()\ndb %>% slice_min(id, prop = 0.5, with_ties = FALSE)\ndb %>% slice_min(id, n = 1, na_rm = FALSE)\ndb %>% slice_max()\ndb %>% slice_max(id, n = 1, na_rm = FALSE)\n```\n\n----------------------------------------\n\nTITLE: Executing Intersection All Operation in dbplyr\nDESCRIPTION: This code snippet shows how to perform an intersection all operation on two identical lazy tables using dbplyr. It generates SQL to find all common rows between both tables, including duplicates.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/query-set-op.md#2025-04-21_snippet_6\n\nLANGUAGE: R\nCODE:\n```\nintersect(lf, lf, all = TRUE)\n```\n\n----------------------------------------\n\nTITLE: Translating head() Function to SQL Query in dbplyr\nDESCRIPTION: Demonstrates how the head() function in dplyr translates to a SQL TOP statement when applied to a database table. This shows the SQL transformation for limiting results to the first 6 rows.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-access.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\nmf %>% head()\n```\n\n----------------------------------------\n\nTITLE: Executing Set Difference Operation in dbplyr\nDESCRIPTION: This code snippet shows how to perform a set difference operation on two identical lazy tables using dbplyr. It generates SQL for finding distinct rows in the first table that are not in the second.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/query-set-op.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\nsetdiff(lf, lf)\n```\n\n----------------------------------------\n\nTITLE: Example of Logical Value Translation in SQL Server\nDESCRIPTION: Shows how dbplyr translates R's as.logical() function to SQL Server's CAST with BIT type for proper boolean conversion.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/NEWS.md#2025-04-21_snippet_14\n\nLANGUAGE: R\nCODE:\n```\nas.logical(x)\n```\n\nLANGUAGE: SQL\nCODE:\n```\nCAST(x as BIT)\n```\n\n----------------------------------------\n\nTITLE: Testing rows_insert with error handling in dbplyr\nDESCRIPTION: Examples of error handling in rows_insert() when invalid parameters are provided. Shows that 'conflict = \"error\"' is not supported on database backends and must be 'ignore' instead.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/rows.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\n(rows_insert(lf, lf, by = \"x\", conflict = \"error\"))\n```\n\nLANGUAGE: R\nCODE:\n```\n(rows_insert(lf, lf, by = \"x\"))\n```\n\n----------------------------------------\n\nTITLE: Transmute Operation in dbplyr (R)\nDESCRIPTION: This snippet demonstrates the transmute operation in dbplyr, which creates new variables and drops existing ones. It shows how transmute includes all necessary variables for the calculation.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-mutate.md#2025-04-21_snippet_3\n\nLANGUAGE: R\nCODE:\n```\nout\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT `x`, `x` + `y` AS `x2`\nFROM (\n  SELECT `x` / 2.0 AS `x`, `y`\n  FROM `df`\n) AS `q01`\n```\n\n----------------------------------------\n\nTITLE: Translating paste() to SQL Server String Concatenation\nDESCRIPTION: Example of how dbplyr translates R's paste() and str_c() functions to SQL Server's string concatenation operator (+) rather than using CONCAT or other functions.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/NEWS.md#2025-04-21_snippet_13\n\nLANGUAGE: R\nCODE:\n```\npaste()\npaste0()\nstr_c()\n```\n\n----------------------------------------\n\nTITLE: Inlining Select After Left Join in R using dbplyr\nDESCRIPTION: These snippets show how dbplyr inlines select and relocate operations after a left join. It selects 'b' and 'x' columns, and relocates 'b' in separate examples.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-select.md#2025-04-21_snippet_3\n\nLANGUAGE: R\nCODE:\n```\n(out <- left_join(lf1, lf2, by = \"x\") %>% select(b, x))\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT `b`, `lf1`.`x` AS `x`\nFROM `lf1`\nLEFT JOIN `lf2`\n  ON (`lf1`.`x` = `lf2`.`x`)\n```\n\nLANGUAGE: R\nCODE:\n```\n(out <- left_join(lf1, lf2, by = \"x\") %>% relocate(b))\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT `b`, `lf1`.*\nFROM `lf1`\nLEFT JOIN `lf2`\n  ON (`lf1`.`x` = `lf2`.`x`)\n```\n\n----------------------------------------\n\nTITLE: Translating tidyr::fill() with 'updown' direction using standard SQL\nDESCRIPTION: Shows the SQL translation of tidyr::fill() with bidirectional updown filling on a standard SQL database. This implementation uses nested queries with LAST_VALUE and IGNORE NULLS in both directions.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-fill.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\ndf_lazy_std %>% window_order(id) %>% tidyr::fill(n1, .direction = \"updown\")\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT\n  `id`,\n  `group`,\n  LAST_VALUE(`n1` IGNORE NULLS) OVER (ORDER BY `id` ROWS UNBOUNDED PRECEDING) AS `n1`\nFROM (\n  SELECT\n    `id`,\n    `group`,\n    LAST_VALUE(`n1` IGNORE NULLS) OVER (ORDER BY `id` DESC ROWS UNBOUNDED PRECEDING) AS `n1`\n  FROM `df`\n) AS `q01`\n```\n\n----------------------------------------\n\nTITLE: Inlining filter() Before Semi Join in dbplyr\nDESCRIPTION: Shows how filter() operations before semi_join are inlined in the SQL query. The generated SQL demonstrates how filtering conditions are incorporated into the semi-join operation for better query performance.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-joins.md#2025-04-21_snippet_9\n\nLANGUAGE: R\nCODE:\n```\nout\n```\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL>\nSELECT `df_LHS`.*\nFROM `df` AS `df_LHS`\nWHERE EXISTS (\n  SELECT 1 FROM `df` AS `df_RHS`\n  WHERE\n    (`df_LHS`.`x` = `df_RHS`.`x2`) AND\n    (`df_RHS`.`a` = 1) AND\n    (`df_RHS`.`b` = 2)\n)\n```\n\n----------------------------------------\n\nTITLE: Using tidyr::expand with grouped data\nDESCRIPTION: Demonstrates how tidyr::expand() respects existing groups when generating combinations.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-expand.md#2025-04-21_snippet_10\n\nLANGUAGE: R\nCODE:\n```\ndf_lazy %>% group_by(a) %>% tidyr::expand(b, c)\n```\n\n----------------------------------------\n\nTITLE: Chaining Filters on Different Variables after summarise()\nDESCRIPTION: Shows how filter() calls on different grouping variables after summarise() are combined in the HAVING clause. Each condition targets a different grouping variable.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-filter.md#2025-04-21_snippet_10\n\nLANGUAGE: r\nCODE:\n```\n(out <- lf %>% filter(g == 1) %>% filter(h == 2))\n```\n\n----------------------------------------\n\nTITLE: Database Generic Functions Migration\nDESCRIPTION: List of database generic functions that have been renamed or replaced in dbplyr.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/NEWS.md#2025-04-21_snippet_11\n\nLANGUAGE: R\nCODE:\n```\ndplyr::db_analyze() -> dbplyr::sql_table_analyze()\ndplyr::db_create_index() -> dbplyr::sql_table_index()\ndplyr::db_explain() -> dbplyr::sql_queriy_explain()\ndplyr::db_query_fields() -> dbplyr::sql_query_fields()\ndplyr::db_save_query() -> dbplyr::sql_query_save()\n```\n\n----------------------------------------\n\nTITLE: Implementing copy_inline with UNION ALL for Data Insertion\nDESCRIPTION: Shows how copy_inline() generates SQL using UNION ALL to insert data rows into a database. Both empty and populated datasets are shown, along with type specifications.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-oracle.md#2025-04-21_snippet_8\n\nLANGUAGE: R\nCODE:\n```\ncopy_inline(con, y %>% slice(0)) %>% remote_query()\n```\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL> SELECT CAST(NULL AS INT) AS `id`, CAST(NULL AS VARCHAR2(255)) AS `arr`\nFROM `DUAL`\nWHERE (0 = 1)\n```\n\nLANGUAGE: R\nCODE:\n```\ncopy_inline(con, y) %>% remote_query()\n```\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL> SELECT CAST(`id` AS INT) AS `id`, CAST(`arr` AS VARCHAR2(255)) AS `arr`\nFROM (\n  SELECT NULL AS `id`, NULL AS `arr`\n  FROM `DUAL`\n  WHERE (0 = 1)\n\n  UNION ALL\n\n  SELECT 1, '{1,2,3}' FROM DUAL\n) `values_table`\n```\n\nLANGUAGE: R\nCODE:\n```\ncopy_inline(con, y %>% slice(0), types = types) %>% remote_query()\n```\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL> SELECT CAST(NULL AS bigint) AS `id`, CAST(NULL AS integer[]) AS `arr`\nFROM `DUAL`\nWHERE (0 = 1)\n```\n\nLANGUAGE: R\nCODE:\n```\ncopy_inline(con, y, types = types) %>% remote_query()\n```\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL> SELECT CAST(`id` AS bigint) AS `id`, CAST(`arr` AS integer[]) AS `arr`\nFROM (\n  SELECT NULL AS `id`, NULL AS `arr`\n  FROM `DUAL`\n  WHERE (0 = 1)\n\n  UNION ALL\n\n  SELECT 1, '{1,2,3}' FROM DUAL\n) `values_table`\n```\n\n----------------------------------------\n\nTITLE: Copying Inline Data to MySQL with Type Casting\nDESCRIPTION: Shows how dbplyr generates SQL to create an inline table from R data in MySQL. Note the differences from MariaDB, including the use of ROW syntax in VALUES and TRUNCATE with DOUBLE casting for numeric values.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-mysql.md#2025-04-21_snippet_6\n\nLANGUAGE: R\nCODE:\n```\ncopy_inline(con_mysql, tibble(x = 1:2, y = letters[1:2])) %>% remote_query()\n```\n\n----------------------------------------\n\nTITLE: Implementing tidyr::replace_na in SQL with COALESCE\nDESCRIPTION: Shows how tidyr::replace_na() translates to SQL COALESCE() function to replace NULL values.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-expand.md#2025-04-21_snippet_20\n\nLANGUAGE: R\nCODE:\n```\nlazy_frame(x = 1, y = \"a\") %>% tidyr::replace_na(list(x = 0, y = \"unknown\"))\n```\n\n----------------------------------------\n\nTITLE: Error Handling for Named Filter Inputs in dbplyr\nDESCRIPTION: Shows the error message when using = instead of == in a filter operation. The function catches this common mistake and suggests the correct syntax.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-filter.md#2025-04-21_snippet_2\n\nLANGUAGE: r\nCODE:\n```\nfilter(lf, x = 1)\n```\n\n----------------------------------------\n\nTITLE: Translating slice_sample() to SQL with RANDOM\nDESCRIPTION: Shows how dbplyr translates slice_sample() to SQL using ROW_NUMBER() with DBMS_RANDOM.VALUE() to randomly select rows from a table.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-oracle.md#2025-04-21_snippet_7\n\nLANGUAGE: R\nCODE:\n```\nslice_sample(lf, n = 1)\n```\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL>\nSELECT `x`\nFROM (\n  SELECT `df`.*, ROW_NUMBER() OVER (ORDER BY DBMS_RANDOM.VALUE()) AS `col01`\n  FROM `df`\n) `q01`\nWHERE (`col01` <= 1)\n```\n\n----------------------------------------\n\nTITLE: Testing DBI Error Handling in Collect Function for R\nDESCRIPTION: This snippet tests the error handling of the `collect()` function when an invalid SQL statement is used in a mutation. It ensures that DBI errors are properly propagated.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-compute.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(mf %>% mutate(a = sql(\"invalid sql\")) %>% collect()))\n```\n\n----------------------------------------\n\nTITLE: SQL Output for tidyr::expand with multiple expressions\nDESCRIPTION: The SQL translation of expand with multiple expressions in nesting(), preserving the named outputs.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-expand.md#2025-04-21_snippet_7\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL>\nSELECT DISTINCT ROUND(`x` / 2.0, 0) AS `x_half`, `x` + 1.0 AS `x1`\nFROM `df`\n```\n\n----------------------------------------\n\nTITLE: Demonstrating collect() behavior in R with dbplyr\nDESCRIPTION: This snippet shows that collect() now defaults to returning all rows in the data, making it behave the same as as.data.frame() and as_tibble().\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/NEWS.md#2025-04-21_snippet_20\n\nLANGUAGE: R\nCODE:\n```\ncollect()\n```\n\n----------------------------------------\n\nTITLE: Performing Union Operation on Identical Tables in dbplyr\nDESCRIPTION: This snippet demonstrates a union operation on two identical lazy tables using dbplyr. It shows the generated SQL for combining two tables with distinct results.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/query-set-op.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\nunion(lf, lf)\n```\n\n----------------------------------------\n\nTITLE: Generating SQL for update_from with returning columns\nDESCRIPTION: Demonstrates SQL generation for update operation with custom value expressions and returning columns specified.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/rows.md#2025-04-21_snippet_25\n\nLANGUAGE: R\nCODE:\n```\nsql_query_update_from(con = con, table = ident(\"df_x\"), from = sql_render(df_y, con, lvl = 1), by = c(\"a\", \"b\"), update_values = sql(c = \"COALESCE(`df_x`.`c`, `...y`.`c`)\", d = \"`...y`.`d`\"), returning_cols = c(\"a\", b2 = \"b\"))\n```\n\n----------------------------------------\n\nTITLE: Translating left_join with NA Matching to SQL\nDESCRIPTION: Shows how dbplyr translates a left_join() with NA matching to SQL using decode() function for equality comparison with NULL handling.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-oracle.md#2025-04-21_snippet_5\n\nLANGUAGE: R\nCODE:\n```\nleft_join(lf, lf, by = \"x\", na_matches = \"na\")\n```\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL>\nSELECT `df_LHS`.`x` AS `x`\nFROM `df` `df_LHS`\nLEFT JOIN `df` `df_RHS`\n  ON (decode(`df_LHS`.`x`, `df_RHS`.`x`, 0, 1) = 0)\n```\n\n----------------------------------------\n\nTITLE: Handling Arranged Computed Columns in Select with R using dbplyr\nDESCRIPTION: This snippet demonstrates how dbplyr handles arranged computed columns in select operations. It shows that arranged computed columns are not inlined away and generates a warning about ORDER BY in subqueries.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-select.md#2025-04-21_snippet_8\n\nLANGUAGE: R\nCODE:\n```\nlf %>% mutate(z = 1) %>% arrange(x, z) %>% select(x)\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT `x`\nFROM (\n  SELECT `df`.*, 1.0 AS `z`\n  FROM `df`\n) AS `q01`\n```\n\n----------------------------------------\n\nTITLE: Handling NULL Assignments in mutate() in dbplyr (R)\nDESCRIPTION: These snippets show how dbplyr handles NULL assignments in mutate() operations. They demonstrate the behavior when assigning NULL to variables that are in the original data or in the final output.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-mutate.md#2025-04-21_snippet_11\n\nLANGUAGE: R\nCODE:\n```\nremote_query(lf)\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT `x` * 2.0 AS `z`\nFROM (\n  SELECT 2.0 AS `x`\n  FROM `df`\n) AS `q01`\n```\n\nLANGUAGE: R\nCODE:\n```\nremote_query(lf)\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT `df`.*, 3.0 AS `y`\nFROM `df`\n```\n\n----------------------------------------\n\nTITLE: Customizing Keyword Highlighting in dbplyr\nDESCRIPTION: Example of how to customize the SQL keyword highlighting in dbplyr via options. You can turn highlighting off completely or specify a custom style using the cli package.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/NEWS.md#2025-04-21_snippet_9\n\nLANGUAGE: R\nCODE:\n```\noptions(dbplyr_highlight = FALSE)\n# or\noptions(dbplyr_highlight = cli::combine_ansi_styles(\"bold\", \"cyan\"))\n```\n\n----------------------------------------\n\nTITLE: Combining distinct() and head() Operations\nDESCRIPTION: Demonstrates how combining distinct() and head() operations creates a subquery in SQL.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-teradata.md#2025-04-21_snippet_8\n\nLANGUAGE: R\nCODE:\n```\nlf %>% distinct() %>% head()\n```\n\n----------------------------------------\n\nTITLE: Using Window Functions in filter() after summarise()\nDESCRIPTION: Demonstrates how dbplyr handles window functions in filter() after summarise(). This generates a nested query structure with the window function in a separate subquery rather than using HAVING.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-filter.md#2025-04-21_snippet_13\n\nLANGUAGE: r\nCODE:\n```\n(out <- lf %>% filter(cumsum(x_mean) == 1))\n```\n\n----------------------------------------\n\nTITLE: Accessing case_when Translation Within mutate\nDESCRIPTION: Shows how case_when expressions are formatted when used inside a mutate operation in dbplyr.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/translate-sql-conditional.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\nout$select[[2]]\n```\n\nLANGUAGE: SQL\nCODE:\n```\n[1] \"CASE WHEN (`x` > 1) THEN 'a' END\"\n```\n\n----------------------------------------\n\nTITLE: Testing SQL Translation of across() in Summarise\nDESCRIPTION: Shows how across() translates R operations to SQL when used with summarise()\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/tidyeval-across.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\nlazy_frame(x = 1, y = 1) %>% summarise(across(.fns = ~ . + 1))\n```\n\n----------------------------------------\n\nTITLE: Generating SQL for Select After Distinct in R using dbplyr\nDESCRIPTION: This snippet demonstrates how dbplyr generates a SQL subquery when selecting columns after a distinct operation. It selects the 'x' column after applying distinct to a lazy frame.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-select.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nlf %>% distinct() %>% select(x)\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT `x`\nFROM (\n  SELECT DISTINCT `df`.*\n  FROM `df`\n) AS `q01`\n```\n\n----------------------------------------\n\nTITLE: Translating row_number() with arrange only\nDESCRIPTION: Shows how dbplyr translates row_number() with arrange but no grouping into SQL using ORDER BY in the OVER clause.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/translate-sql-window.md#2025-04-21_snippet_5\n\nLANGUAGE: R\nCODE:\n```\nmf %>% arrange(y) %>% mutate(rown = row_number())\n```\n\n----------------------------------------\n\nTITLE: Testing Complex Mutations with arrange() in dbplyr\nDESCRIPTION: Tests a more complex scenario where ordering and mutation operations are interleaved.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-arrange.md#2025-04-21_snippet_12\n\nLANGUAGE: R\nCODE:\n```\n# complex mutate\nlf %>% arrange(a) %>% mutate(a = b) %>% arrange(a)\n```\n\n----------------------------------------\n\nTITLE: Using Bang Bang (!!) Injection with case_match\nDESCRIPTION: Demonstrates how rlang's bang bang operator can be used with case_match to inject values for SQL translation.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/translate-sql-conditional.md#2025-04-21_snippet_9\n\nLANGUAGE: R\nCODE:\n```\ntest_translate_sql(case_match(x, !!1L ~ \"x\"))\n```\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL> CASE WHEN (`x` IN (1)) THEN 'x' END\n```\n\nLANGUAGE: R\nCODE:\n```\ntest_translate_sql(case_match(x, !!c(1L, 2L) ~ \"x\"))\n```\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL> CASE WHEN (`x` IN (1, 2)) THEN 'x' END\n```\n\nLANGUAGE: R\nCODE:\n```\ntest_translate_sql(case_match(x, !!c(NA, 1L) ~ \"x\"))\n```\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL> CASE WHEN (`x` IN (1) OR `x` IS NULL) THEN 'x' END\n```\n\n----------------------------------------\n\nTITLE: Computing Weighted Mean in SQL\nDESCRIPTION: Demonstrates how weighted.mean() is translated into SQL using sum and division operations.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-teradata.md#2025-04-21_snippet_4\n\nLANGUAGE: R\nCODE:\n```\nmf %>% summarise(wt_mean = weighted.mean(x, y))\n```\n\n----------------------------------------\n\nTITLE: Translating R median() to SQL PERCENTILE_CONT without grouping\nDESCRIPTION: Tests the translation of R's median function to SQL without grouping. Median is implemented as the 50th percentile using PERCENTILE_CONT.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/translate-sql-quantile.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\ntest_translate_sql(median(x, na.rm = TRUE), window = FALSE)\n```\n\n----------------------------------------\n\nTITLE: SQL Output for tidyr::expand with nesting\nDESCRIPTION: The SQL translation of expand with nesting(), which uses a simple DISTINCT selection without cross joins.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-expand.md#2025-04-21_snippet_3\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL>\nSELECT DISTINCT `df`.*\nFROM `df`\n```\n\n----------------------------------------\n\nTITLE: SQL Filter Translation with Column References\nDESCRIPTION: Test cases for translating filter operations with column references using the $ operator.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\nlazy_frame(x = 1, y = 1) %>% filter(x == y$id)\n```\n\nLANGUAGE: R\nCODE:\n```\nlazy_frame(x = 1) %>% filter(x == y$id)\n```\n\n----------------------------------------\n\nTITLE: Printing select_query() Output in R\nDESCRIPTION: This snippet demonstrates the expected output format of the select_query() print method in dbplyr. It shows a formatted SQL SELECT query with various clauses including From, Select, Where, Order by, and Limit.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/query-select.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nmf\n```\n\n----------------------------------------\n\nTITLE: Generating Query Explanation SQL for MariaDB\nDESCRIPTION: Shows how to generate SQL for explaining a query in MariaDB using the sql_query_explain function. This creates an EXPLAIN statement to analyze query execution plans.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-mysql.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\nsql_query_explain(con_maria, sql(\"SELECT * FROM table\"))\n```\n\n----------------------------------------\n\nTITLE: Error Handling for Invalid case_when and switch Arguments\nDESCRIPTION: Shows error messages for case_when with no cases and switch with multiple unnamed inputs.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/translate-sql-conditional.md#2025-04-21_snippet_8\n\nLANGUAGE: R\nCODE:\n```\ntest_translate_sql(case_when())\n```\n\nLANGUAGE: text\nCODE:\n```\nError in `sql_case_when()`:\n! No cases provided\n```\n\nLANGUAGE: R\nCODE:\n```\ntest_translate_sql(switch(x, 1L, 2L))\n```\n\nLANGUAGE: text\nCODE:\n```\nError in `sql_switch()`:\n! Can only have one unnamed (ELSE) input\n```\n\n----------------------------------------\n\nTITLE: Combining Union Operations in dbplyr\nDESCRIPTION: This snippet demonstrates how to chain multiple union operations on dbplyr lazy frames. It shows the generated SQL which includes UNION and UNION ALL operations with proper column alignment.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-set-ops.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\nlf1 %>% union_all(lf2) %>% union(lf3)\n```\n\nLANGUAGE: sql\nCODE:\n```\nSELECT `lf1`.*, NULL AS `z`\nFROM `lf1`\n\nUNION ALL\n\nSELECT `q01`.*, NULL AS `z`\nFROM (\n  SELECT NULL AS `x`, `lf2`.*\n  FROM `lf2`\n) AS `q01`\n\nUNION\n\nSELECT NULL AS `x`, NULL AS `y`, `lf3`.*\nFROM `lf3`\n```\n\n----------------------------------------\n\nTITLE: Testing arrange() with head() in dbplyr\nDESCRIPTION: Tests the interaction between arrange() and head() operations, showing how the ordering is applied in different sequences.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-arrange.md#2025-04-21_snippet_8\n\nLANGUAGE: R\nCODE:\n```\nlf <- lazy_frame(a = 1:3, b = 3:1)\n# head\nlf %>% head(1) %>% arrange(a)\n```\n\n----------------------------------------\n\nTITLE: Translating R median() to SQL PERCENTILE_CONT with grouping\nDESCRIPTION: Tests the translation of R's median function to SQL with grouping, implementing median as the 50th percentile with PARTITION BY clause for group-wise calculations.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/translate-sql-quantile.md#2025-04-21_snippet_3\n\nLANGUAGE: R\nCODE:\n```\ntest_translate_sql(median(x, na.rm = TRUE), vars_group = \"g\")\n```\n\n----------------------------------------\n\nTITLE: Data Masking in Slice Operations\nDESCRIPTION: Demonstrates how slice_max handles data masking pronouns and generates corresponding SQL queries, including support for .data and .env pronouns.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-slice.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\nlf %>% slice_max(x)\nlf %>% slice_max(.data$x)\nlf %>% slice_max(.data$x * .env$x)\n```\n\n----------------------------------------\n\nTITLE: Subquery Generation in mutate() in dbplyr (R)\nDESCRIPTION: These snippets show how mutate() generates subqueries as needed in dbplyr. They demonstrate how dbplyr optimizes multiple mutations and handles dependencies between newly created variables.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-mutate.md#2025-04-21_snippet_9\n\nLANGUAGE: R\nCODE:\n```\nlf %>% mutate(x = x + 1, x = x + 1)\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT `x` + 1.0 AS `x`\nFROM (\n  SELECT `x` + 1.0 AS `x`\n  FROM `df`\n) AS `q01`\n```\n\nLANGUAGE: R\nCODE:\n```\nlf %>% mutate(x1 = x + 1, x2 = x1 + 1)\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT `q01`.*, `x1` + 1.0 AS `x2`\nFROM (\n  SELECT `df`.*, `x` + 1.0 AS `x1`\n  FROM `df`\n) AS `q01`\n```\n\n----------------------------------------\n\nTITLE: Pivoting to Multiple Measure Columns in DBPlyr\nDESCRIPTION: Shows how to pivot data to create multiple measure columns rather than the default name-value pair structure. This transforms the data to a wider format with specific column names for each measure.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-pivot-longer.md#2025-04-21_snippet_8\n\nLANGUAGE: r\nCODE:\n```\npv\n```\n\nLANGUAGE: sql\nCODE:\n```\nSELECT 1.0 AS `row`, `x` AS `X`, `y` AS `Y`\nFROM `df`\n```\n\n----------------------------------------\n\nTITLE: Generating COMPUTE STATS SQL Command with dbplyr in R\nDESCRIPTION: This code uses the sql_table_analyze function from dbplyr to generate a SQL command for computing statistics on a table. It specifies a schema and table name using the in_schema function.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-impala.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nsql_table_analyze(con, in_schema(\"schema\", \"tbl\"))\n```\n\n----------------------------------------\n\nTITLE: Testing SQL Rendering for Ordered Tables in dbplyr\nDESCRIPTION: Tests SQL query generation for tables with ordering applied, showing how ORDER BY is included in the generated SQL.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-arrange.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nsql_render(out)\n```\n\n----------------------------------------\n\nTITLE: Using tidyr::nesting with tidyr::expand\nDESCRIPTION: Shows how to use tidyr::nesting() directly with tidyr::expand().\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-expand.md#2025-04-21_snippet_8\n\nLANGUAGE: R\nCODE:\n```\ndf_lazy %>% tidyr::expand(tidyr::nesting(x, y))\n```\n\n----------------------------------------\n\nTITLE: Filtering with Boolean Values in dbplyr SQL Translation\nDESCRIPTION: Shows how dbplyr translates logical expressions in filter() to SQL, casting column references and literal values to BIT type. The examples demonstrate simple column filtering, TRUE/FALSE literals, and complex logical operations.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-mssql.md#2025-04-21_snippet_5\n\nLANGUAGE: R\nCODE:\n```\nmf %>% filter(x)\n```\n\nLANGUAGE: R\nCODE:\n```\nmf %>% filter(TRUE)\n```\n\nLANGUAGE: R\nCODE:\n```\nmf %>% filter((!x) | FALSE)\n```\n\nLANGUAGE: R\nCODE:\n```\nmf %>% filter(x) %>% inner_join(mf, by = \"x\")\n```\n\n----------------------------------------\n\nTITLE: Translating stringr Functions to SQL\nDESCRIPTION: Shows how dbplyr translates stringr functions str_replace() and str_replace_all() into SQL REGEXP_REPLACE expressions. The examples demonstrate the difference in translation for single replacement versus all replacements.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-oracle.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\ntest_translate_sql(str_replace(col, \"pattern\", \"replacement\"))\n```\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL> REGEXP_REPLACE(`col`, 'pattern', 'replacement', 1, 1)\n```\n\nLANGUAGE: R\nCODE:\n```\ntest_translate_sql(str_replace_all(col, \"pattern\", \"replacement\"))\n```\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL> REGEXP_REPLACE(`col`, 'pattern', 'replacement')\n```\n\n----------------------------------------\n\nTITLE: Testing Print Method for tbl_lazy - R\nDESCRIPTION: Demonstrates the print output of a tbl_lazy object showing the generated SQL query\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/tbl-lazy.md#2025-04-21_snippet_2\n\nLANGUAGE: r\nCODE:\n```\ntbl_lazy(mtcars)\n```\n\n----------------------------------------\n\nTITLE: Custom SQL Server Operations in R\nDESCRIPTION: Examples of custom SQL Server operations implemented in dbplyr, including table analysis, data insertion, and sampling.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-mssql.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\nsql_table_analyze(con, in_schema(\"schema\", \"tbl\"))\n```\n\nLANGUAGE: SQL\nCODE:\n```\nUPDATE STATISTICS `schema`.`tbl`\n```\n\nLANGUAGE: R\nCODE:\n```\nsql_query_save(con, sql(\"SELECT * FROM foo\"), in_schema(\"schema\", \"tbl\"))\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT * INTO `schema`.`tbl` FROM (\n  SELECT * FROM foo\n) AS temp\n```\n\nLANGUAGE: R\nCODE:\n```\nlf %>% slice_sample(n = 1)\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT `x`\nFROM (\n  SELECT `df`.*, ROW_NUMBER() OVER (ORDER BY RAND()) AS `col01`\n  FROM `df`\n) AS `q01`\nWHERE (`col01` <= 1)\n```\n\n----------------------------------------\n\nTITLE: Testing window_order with renamed variables (first approach)\nDESCRIPTION: Tests that window_order works correctly when a variable is renamed after setting the order. Creates a SQL query with a window function that uses the renamed column in the ORDER BY clause.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-window.md#2025-04-21_snippet_3\n\nLANGUAGE: r\nCODE:\n```\nlazy_frame(x = 1, y = 1) %>% window_order(y) %>% rename(y2 = y) %>% mutate(\n  x_cum = cumsum(x))\n```\n\n----------------------------------------\n\nTITLE: Testing arrange() Before union() in dbplyr\nDESCRIPTION: Shows how ORDER BY is applied in a UNION operation when arrange() is used before union().\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-arrange.md#2025-04-21_snippet_17\n\nLANGUAGE: R\nCODE:\n```\nlf %>% arrange(a) %>% union(rf)\n```\n\n----------------------------------------\n\nTITLE: Testing across() Function with Anonymous Functions in R\nDESCRIPTION: Demonstrates error handling when using anonymous functions with multiple statements in across()\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/tidyeval-across.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nexpect_error(capture_across(lf, across(a, function(x) {\n  x <- x + 2\n  log(x)\n})))\n```\n\n----------------------------------------\n\nTITLE: Testing if_all/any Functions in Filter Operations\nDESCRIPTION: Demonstrates SQL translation of if_all() and if_any() functions in filter operations\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/tidyeval-across.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\nlf %>% filter(if_all(a:b, ~ . > 0))\n\nlf %>% filter(if_any(a:b, ~ . > 0))\n```\n\n----------------------------------------\n\nTITLE: Translating pmax() with na.rm to SQL\nDESCRIPTION: Shows the SQL translation of R's pmax() function with na.rm=TRUE for three variables, using nested IFF and COALESCE functions.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-snowflake.md#2025-04-21_snippet_2\n\nLANGUAGE: SQL\nCODE:\n```\nCOALESCE(IFF(COALESCE(IFF(`x` >= `y`, `x`, `y`), `x`, `y`) >= `z`, COALESCE(IFF(`x` >= `y`, `x`, `y`), `x`, `y`), `z`), COALESCE(IFF(`x` >= `y`, `x`, `y`), `x`, `y`), `z`)\n```\n\n----------------------------------------\n\nTITLE: Preserving Grouping Variables in Select with R using dbplyr\nDESCRIPTION: This snippet demonstrates how dbplyr preserves grouping variables when using select. It selects column 'a' and automatically adds the missing grouping variable 'b'.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-select.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\nout <- mf %>% select(a) %>% collect()\n```\n\n----------------------------------------\n\nTITLE: Testing copy_inline with UNION ALL in SQL Generation\nDESCRIPTION: These test cases show how dbplyr's copy_inline function uses UNION ALL to combine SQL data. The examples demonstrate behavior both with and without slicing, and with custom type specifications.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-redshift.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\ncopy_inline(con, y %>% slice(0)) %>% remote_query()\n```\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL> SELECT CAST(NULL AS INTEGER) AS `id`, CAST(NULL AS TEXT) AS `arr`\nWHERE (0 = 1)\n```\n\nLANGUAGE: R\nCODE:\n```\ncopy_inline(con, y) %>% remote_query()\n```\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL> SELECT CAST(`id` AS INTEGER) AS `id`, CAST(`arr` AS TEXT) AS `arr`\nFROM (\n  SELECT NULL AS `id`, NULL AS `arr`\n  WHERE (0 = 1)\n\n  UNION ALL\n\n  SELECT 1, '{1,2,3}'\n) AS `values_table`\n```\n\nLANGUAGE: R\nCODE:\n```\ncopy_inline(con, y %>% slice(0), types = types) %>% remote_query()\n```\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL> SELECT CAST(NULL AS bigint) AS `id`, CAST(NULL AS integer[]) AS `arr`\nWHERE (0 = 1)\n```\n\nLANGUAGE: R\nCODE:\n```\ncopy_inline(con, y, types = types) %>% remote_query()\n```\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL> SELECT CAST(`id` AS bigint) AS `id`, CAST(`arr` AS integer[]) AS `arr`\nFROM (\n  SELECT NULL AS `id`, NULL AS `arr`\n  WHERE (0 = 1)\n\n  UNION ALL\n\n  SELECT 1, '{1,2,3}'\n) AS `values_table`\n```\n\n----------------------------------------\n\nTITLE: Creating Persistent Tables with Schema in Spark SQL\nDESCRIPTION: Shows how to create persistent tables with fully qualified names in Spark SQL backend using compute() with I() notation and temporary=FALSE.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/NEWS.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\ncompute(x, name = I(\"x.y.z\"), temporary = FALSE)\n```\n\n----------------------------------------\n\nTITLE: Chaining Multiple Filters after summarise()\nDESCRIPTION: Demonstrates how multiple filter() calls after summarise() are combined in the HAVING clause using AND. Both conditions filter on grouping variables.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-filter.md#2025-04-21_snippet_9\n\nLANGUAGE: r\nCODE:\n```\n(out <- lf %>% filter(g == 1) %>% filter(g == 2))\n```\n\n----------------------------------------\n\nTITLE: Translating row_number() with group_by\nDESCRIPTION: Shows SQL translation of row_number() with grouping by column 'y', using PARTITION BY clause.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-snowflake.md#2025-04-21_snippet_4\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT\n  `df`.*,\n  ROW_NUMBER() OVER (PARTITION BY `y` ORDER BY (SELECT NULL)) AS `rown`\nFROM `df`\n```\n\n----------------------------------------\n\nTITLE: Handling Zero-Row Tables with copy_inline in R\nDESCRIPTION: These tests check how copy_inline handles empty dataframes. It shows the SQL generation for tables with no rows, both with multiple columns and a single column.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-copy-to.md#2025-04-21_snippet_3\n\nLANGUAGE: R\nCODE:\n```\ncopy_inline(con, tibble(dbl = numeric(), chr = character())) %>% remote_query()\n```\n\nLANGUAGE: R\nCODE:\n```\ncopy_inline(con, tibble(dbl = numeric())) %>% remote_query()\n```\n\n----------------------------------------\n\nTITLE: Using a Single Aggregation Function with values_fn in Pivot Wider\nDESCRIPTION: Demonstrates using a single function (sum) as the values_fn parameter to aggregate values when pivoting. The SQL uses SUM instead of MAX in the CASE WHEN clause.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-pivot-wider.md#2025-04-21_snippet_3\n\nLANGUAGE: r\nCODE:\n```\nsuppressWarnings(dbplyr_pivot_wider_spec(df, spec1, values_fn = sum))\n```\n\nLANGUAGE: sql\nCODE:\n```\nSELECT `a`, SUM(CASE WHEN (`key` = 'x') THEN `val` END) AS `x`\nFROM `df`\nGROUP BY `a`\n```\n\n----------------------------------------\n\nTITLE: Generating SQL for rows_insert with in_place=FALSE\nDESCRIPTION: Demonstrates SQL generation for rows_insert operation with in_place=FALSE, showing the UNION ALL approach with NOT EXISTS subquery.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/rows.md#2025-04-21_snippet_6\n\nLANGUAGE: R\nCODE:\n```\nrows_insert(lazy_frame(x = 1:3, y = 11:13, .name = \"df_x\"), lazy_frame(x = 3:4, y = 23:24, .name = \"df_y\"), by = \"x\", conflict = \"ignore\", in_place = FALSE)\n```\n\n----------------------------------------\n\nTITLE: Mutating after Distinct Operation in dbplyr (R)\nDESCRIPTION: This snippet shows how mutate() behaves after a distinct() operation in dbplyr. It demonstrates that the mutation is applied to the result of the distinct operation.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-mutate.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nlf %>% distinct(x) %>% mutate(x = 0)\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT 0.0 AS `x`\nFROM (\n  SELECT DISTINCT `df`.*\n  FROM `df`\n) AS `q01`\n```\n\n----------------------------------------\n\nTITLE: Modified Weight dbplyr Uncount Query Generation\nDESCRIPTION: Shows the SQL query generated when using dbplyr_uncount with a modified weight calculation (w + 1). The query includes a subquery for the weight modification before performing the row expansion.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-uncount.md#2025-04-21_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\nSELECT `x`\nFROM (\n  SELECT `x`, `w` + 1.0 AS `w`\n  FROM `test`\n) AS `LHS`\nINNER JOIN (\n  SELECT CAST(`..dbplyr_row_id` AS INTEGER) AS `..dbplyr_row_id`\n  FROM (\n    SELECT NULL AS `..dbplyr_row_id`\n    WHERE (0 = 1)\n\n    UNION ALL\n\n    VALUES (1), (2)\n  ) AS `values_table`\n) AS `RHS`\n  ON (`RHS`.`..dbplyr_row_id` <= `LHS`.`w`)\n```\n\n----------------------------------------\n\nTITLE: Translating case_when with .default as Expression\nDESCRIPTION: Demonstrates how case_when can use an expression (x + 1) as a .default value in the SQL translation.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/translate-sql-conditional.md#2025-04-21_snippet_4\n\nLANGUAGE: R\nCODE:\n```\ntest_translate_sql(case_when(x == 1L ~ \"yes\", x == 0L ~ \"no\", .default = x + 1))\n```\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL> CASE WHEN (`x` = 1) THEN 'yes' WHEN (`x` = 0) THEN 'no' ELSE `x` + 1.0 END\n```\n\n----------------------------------------\n\nTITLE: Converting head() to TOP in SQL\nDESCRIPTION: Shows how dbplyr translates R's head() function into SQL TOP clause for limiting results.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-teradata.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\nmf %>% head() %>% sql_render()\n```\n\n----------------------------------------\n\nTITLE: Generating Table Analyze SQL for MariaDB\nDESCRIPTION: Demonstrates how to generate SQL for analyzing a table in MariaDB using the sql_table_analyze function. This function creates the appropriate ANALYZE TABLE statement with proper schema qualification.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-mysql.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nsql_table_analyze(con_maria, in_schema(\"schema\", \"tbl\"))\n```\n\n----------------------------------------\n\nTITLE: Error Handling for .by Parameter with Grouped Data\nDESCRIPTION: Demonstrates the error when attempting to use the .by parameter with an already grouped data frame. This combination is not supported in dbplyr.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-filter.md#2025-04-21_snippet_5\n\nLANGUAGE: r\nCODE:\n```\nfilter(gdf, .by = x)\n```\n\n----------------------------------------\n\nTITLE: Implementing row_number() With Grouping\nDESCRIPTION: Demonstrates row_number() implementation with GROUP BY clause in SQL.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-teradata.md#2025-04-21_snippet_6\n\nLANGUAGE: R\nCODE:\n```\nmf %>% group_by(y) %>% mutate(rown = row_number())\n```\n\n----------------------------------------\n\nTITLE: Error Handling for Multiple Unnamed Arguments in dplyr do()\nDESCRIPTION: Example showing that do() can only accept a single unnamed argument. Attempting to provide multiple unnamed arguments (nrow(.) and ncol(.)) results in an error.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-do.md#2025-04-21_snippet_2\n\nLANGUAGE: r\nCODE:\n```\nmf %>% do(nrow(.), ncol(.))\n```\n\n----------------------------------------\n\nTITLE: Using window_frame with unbounded following rows\nDESCRIPTION: Shows how specifying only a 'from' parameter creates a window frame from 3 rows preceding to all following rows, translated to SQL ROWS BETWEEN syntax.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/translate-sql-window.md#2025-04-21_snippet_7\n\nLANGUAGE: R\nCODE:\n```\nlf %>% window_frame(-3) %>% window_order(x) %>% mutate(z = sum(y, na.rm = TRUE)) %>%\n  show_query()\n```\n\n----------------------------------------\n\nTITLE: Generating SQL for Weighted Count Operation in R using dbplyr\nDESCRIPTION: This snippet shows how dbplyr translates a weighted count operation in R to SQL. It groups the data by the 'g' column and sums the 'x' column as weights.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-count.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\ndb %>% count(g, wt = x)\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT `g`, SUM(`x`) AS `n`\nFROM `df`\nGROUP BY `g`\n```\n\n----------------------------------------\n\nTITLE: Translating tidyr::fill() with descending order and 'up' direction using non-standard SQL\nDESCRIPTION: Shows the SQL translation of tidyr::fill() with upward direction and descending ID order on a non-standard SQL database. This implementation uses window functions with custom partitioning logic.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-fill.md#2025-04-21_snippet_4\n\nLANGUAGE: R\nCODE:\n```\ndf_lazy_ns %>% window_order(desc(id)) %>% tidyr::fill(n1, .direction = \"up\")\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT\n  `id`,\n  `group`,\n  MAX(`n1`) OVER (PARTITION BY `..dbplyr_partition_1`) AS `n1`\nFROM (\n  SELECT\n    `df`.*,\n    SUM(CASE WHEN ((`n1` IS NULL)) THEN 0 ELSE 1 END) OVER (ORDER BY `id` ROWS UNBOUNDED PRECEDING) AS `..dbplyr_partition_1`\n  FROM `df`\n) AS `q01`\n```\n\n----------------------------------------\n\nTITLE: Translating case_when with .default Parameter\nDESCRIPTION: Shows how case_when's .default parameter is translated to SQL ELSE clause with a string value.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/translate-sql-conditional.md#2025-04-21_snippet_3\n\nLANGUAGE: R\nCODE:\n```\ntest_translate_sql(case_when(x == 1L ~ \"yes\", x == 0L ~ \"no\", .default = \"undefined\"))\n```\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL> CASE WHEN (`x` = 1) THEN 'yes' WHEN (`x` = 0) THEN 'no' ELSE 'undefined' END\n```\n\n----------------------------------------\n\nTITLE: Translating R quantile() to SQL PERCENTILE_CONT without grouping\nDESCRIPTION: Tests the translation of R's quantile function to SQL, specifically for the 75th percentile without grouping. Uses PERCENTILE_CONT for continuous percentile calculation.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/translate-sql-quantile.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\ntest_translate_sql(quantile(x, 0.75, na.rm = TRUE), window = FALSE)\n```\n\n----------------------------------------\n\nTITLE: Error handling for in_place operations in rows_insert\nDESCRIPTION: Demonstrates error handling when attempting in-place modifications without a determinable target table name.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/rows.md#2025-04-21_snippet_3\n\nLANGUAGE: R\nCODE:\n```\n(df %>% mutate(x = x + 1) %>% rows_insert(df, by = \"x\", conflict = \"ignore\", in_place = TRUE))\n```\n\n----------------------------------------\n\nTITLE: Using Formula in values_transform for DBPlyr pivot_longer\nDESCRIPTION: Demonstrates using a formula with values_transform parameter to transform data types in pivot_longer. This approach allows using the formula syntax (~) to specify transformations that will be applied to the pivoted values.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-pivot-longer.md#2025-04-21_snippet_6\n\nLANGUAGE: r\nCODE:\n```\nlazy_frame(x = 1) %>% tidyr::pivot_longer(x, values_transform = list(value = ~\n  as.character(.x)))\n```\n\nLANGUAGE: sql\nCODE:\n```\nSELECT 'x' AS `name`, CAST(`x` AS TEXT) AS `value`\nFROM `df`\n```\n\n----------------------------------------\n\nTITLE: Generating Table Analysis SQL Command\nDESCRIPTION: Shows how sql_table_analyze() generates SQL to compute statistics for a table, useful for database query optimization.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-oracle.md#2025-04-21_snippet_3\n\nLANGUAGE: R\nCODE:\n```\nsql_table_analyze(con, in_schema(\"schema\", \"tbl\"))\n```\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL> ANALYZE TABLE `schema`.`tbl` COMPUTE STATISTICS\n```\n\n----------------------------------------\n\nTITLE: Implementing tidyr::complete in SQL\nDESCRIPTION: Shows how tidyr::complete() generates SQL to fill in missing combinations of values with optional default values.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-expand.md#2025-04-21_snippet_24\n\nLANGUAGE: R\nCODE:\n```\ndf_lazy %>% tidyr::complete(x, y, fill = list(z = \"c\"))\n```\n\n----------------------------------------\n\nTITLE: Generating SQL Query for Single-Column Dataframe using copy_inline in R\nDESCRIPTION: This test shows how copy_inline handles a single-column dataframe, specifically with a double value. It demonstrates the SQL generation for a simplified case.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-copy-to.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\ncopy_inline(con, tibble(dbl = 1.5)) %>% remote_query()\n```\n\n----------------------------------------\n\nTITLE: Testing Error for Unsupported SQL Functions in dbplyr\nDESCRIPTION: Demonstrates how dbplyr handles unsupported functions like 'cor()' by throwing an informative error message.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/translate-sql-helpers.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nsql_not_supported(\"cor\")()\n```\n\n----------------------------------------\n\nTITLE: Error Handling for Untranslatable Objects in dbplyr\nDESCRIPTION: Demonstrates error messages when attempting to use various R objects that cannot be translated to SQL in a filter operation. Includes examples with Shiny inputs, reactive expressions, data frames, and functions, along with suggestions for workarounds.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/escape.md#2025-04-21_snippet_1\n\nLANGUAGE: r\nCODE:\n```\nlf %>% filter(x == input)\n```\n\nLANGUAGE: r\nCODE:\n```\nlf %>% filter(x == x())\n```\n\nLANGUAGE: r\nCODE:\n```\nlf %>% filter(x == df)\n```\n\nLANGUAGE: r\nCODE:\n```\nlf %>% filter(x == mean)\n```\n\n----------------------------------------\n\nTITLE: Error testing for tidyr::fill() with non-existent column\nDESCRIPTION: Demonstrates the error message when trying to use tidyr::fill() with a column that doesn't exist in the dataframe. This provides clear guidance to users about the issue.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-fill.md#2025-04-21_snippet_9\n\nLANGUAGE: R\nCODE:\n```\nlazy_frame(x = 1) %>% tidyr::fill(non_existent)\n```\n\nLANGUAGE: error\nCODE:\n```\nError in `tidyr::fill()`:\n! Can't select columns that don't exist.\nx Column `non_existent` doesn't exist.\n```\n\n----------------------------------------\n\nTITLE: Error Handling in mutate() and across() in dbplyr (R)\nDESCRIPTION: These snippets demonstrate error handling in mutate() and across() functions in dbplyr. They show how dbplyr provides informative error messages for various scenarios like non-existent objects, invalid arguments, and incorrect function specifications.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-mutate.md#2025-04-21_snippet_8\n\nLANGUAGE: R\nCODE:\n```\nlazy_frame(x = 1) %>% mutate(z = non_existent + 1)\n```\n\nLANGUAGE: R\nCODE:\n```\nlazy_frame(x = 1) %>% mutate(across(x, mean, na.rm = z))\n```\n\nLANGUAGE: R\nCODE:\n```\nlazy_frame(x = 1) %>% mutate(across(x, .fns = \"a\"))\n```\n\n----------------------------------------\n\nTITLE: Adding Multiple Columns from Spec in DBPlyr Pivoting\nDESCRIPTION: Shows a pivoting operation that adds multiple columns (a and b) from a specification while creating a long format in DBPlyr. The result combines data from multiple columns using UNION ALL.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-pivot-longer.md#2025-04-21_snippet_1\n\nLANGUAGE: r\nCODE:\n```\npv\n```\n\nLANGUAGE: sql\nCODE:\n```\nSELECT 11 AS `a`, 13 AS `b`, `x` AS `v`\nFROM `df`\n\nUNION ALL\n\nSELECT 12 AS `a`, 14 AS `b`, `y` AS `v`\nFROM `df`\n```\n\n----------------------------------------\n\nTITLE: Multiple Column Ordering in Slice Operations\nDESCRIPTION: Shows how slice_min and slice_max can order by multiple columns using tibble and data.frame inputs, generating appropriate SQL RANK() OVER clauses.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-slice.md#2025-04-21_snippet_3\n\nLANGUAGE: R\nCODE:\n```\nlf %>% slice_min(tibble(x))\nlf %>% slice_min(tibble::tibble(x, y))\nlf %>% slice_min(data.frame(y, x))\nlf %>% slice_max(tibble(x))\nlf %>% slice_max(tibble::tibble(x, y))\nlf %>% slice_max(data.frame(y, x))\n```\n\n----------------------------------------\n\nTITLE: Translating tidyr::fill() with descending order and 'up' direction using standard SQL\nDESCRIPTION: Shows the SQL translation of tidyr::fill() with upward direction and descending ID order on a standard SQL database. This implementation uses LAST_VALUE with IGNORE NULLS to achieve the filling behavior.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-fill.md#2025-04-21_snippet_5\n\nLANGUAGE: R\nCODE:\n```\ndf_lazy_std %>% window_order(desc(id)) %>% tidyr::fill(n1, .direction = \"up\")\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT\n  `id`,\n  `group`,\n  LAST_VALUE(`n1` IGNORE NULLS) OVER (ORDER BY `id` ROWS UNBOUNDED PRECEDING) AS `n1`\nFROM `df`\n```\n\n----------------------------------------\n\nTITLE: Testing Named Argument Validation in sql_prefix Functions\nDESCRIPTION: Demonstrates how sql_prefix validates argument names, throwing an error when the provided name doesn't match the expected parameter name.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/translate-sql-helpers.md#2025-04-21_snippet_5\n\nLANGUAGE: R\nCODE:\n```\nsin_db(sin(a = 1))\n```\n\n----------------------------------------\n\nTITLE: Translating tidyr::fill() with 'downup' direction using standard SQL\nDESCRIPTION: Shows the SQL translation of tidyr::fill() with bidirectional downup filling on a standard SQL database. This implementation applies filling in the opposite order compared to 'updown', using nested queries with LAST_VALUE and IGNORE NULLS.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-fill.md#2025-04-21_snippet_3\n\nLANGUAGE: R\nCODE:\n```\ndf_lazy_std %>% window_order(id) %>% tidyr::fill(n1, .direction = \"downup\")\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT\n  `id`,\n  `group`,\n  LAST_VALUE(`n1` IGNORE NULLS) OVER (ORDER BY `id` DESC ROWS UNBOUNDED PRECEDING) AS `n1`\nFROM (\n  SELECT\n    `id`,\n    `group`,\n    LAST_VALUE(`n1` IGNORE NULLS) OVER (ORDER BY `id` ROWS UNBOUNDED PRECEDING) AS `n1`\n  FROM `df`\n) AS `q01`\n```\n\n----------------------------------------\n\nTITLE: SQL Join Translation with NA Matching\nDESCRIPTION: Demonstrates translation of left join with NA matching specification into SQL query.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-postgres.md#2025-04-21_snippet_0\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT `df_LHS`.`x` AS `x`\nFROM `df` AS `df_LHS`\nLEFT JOIN `df` AS `df_RHS`\n  ON (`df_LHS`.`x` IS NOT DISTINCT FROM `df_RHS`.`x`)\n```\n\n----------------------------------------\n\nTITLE: Translating row_number() with group_by\nDESCRIPTION: Shows how dbplyr translates row_number() with group_by into SQL using PARTITION BY in the OVER clause.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/translate-sql-window.md#2025-04-21_snippet_3\n\nLANGUAGE: R\nCODE:\n```\nmf %>% group_by(y) %>% mutate(rown = row_number())\n```\n\n----------------------------------------\n\nTITLE: Handling NULL inputs in tidyr::expand\nDESCRIPTION: Shows how tidyr::expand() behaves when NULL values are provided as inputs.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-expand.md#2025-04-21_snippet_12\n\nLANGUAGE: R\nCODE:\n```\ntidyr::expand(lazy_frame(x = 1), x, y = NULL)\n```\n\n----------------------------------------\n\nTITLE: Printing a Lazy Select Query with dbplyr\nDESCRIPTION: Demonstrates how to create and print a lazy select query using dbplyr. The query selects mean(x) as x_mean and y as y2, applies filtering conditions y > 1 and x == y - 2, and groups by x.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/lazy-select-query.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\nlazy_select_query(x = lf$lazy_query, select = quos(x_mean = mean(x), y2 = y),\nwhere = quos(y > 1, x == y - 2), group_by = quos(\"x\"))\n```\n\n----------------------------------------\n\nTITLE: Generating UPDATE FROM SQL for MySQL/MariaDB\nDESCRIPTION: Demonstrates how dbplyr generates SQL for an UPDATE with JOIN operation in MySQL/MariaDB. This allows updating one table based on values from another table using a JOIN condition and custom update expressions.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-mysql.md#2025-04-21_snippet_7\n\nLANGUAGE: R\nCODE:\n```\nsql_query_update_from(con = con, table = ident(\"df_x\"), from = sql_render(df_y,\n        con, lvl = 1), by = c(\"a\", \"b\"), update_values = sql(c = \"COALESCE(`df_x`.`c`, `...y`.`c`)\",\n        d = \"`...y`.`d`\"))\n```\n\n----------------------------------------\n\nTITLE: Example of Logical Value Translation in MySQL/MariaDB\nDESCRIPTION: Shows how dbplyr translates R's as.logical() function to an IF statement in MySQL/MariaDB for boolean conversion.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/NEWS.md#2025-04-21_snippet_15\n\nLANGUAGE: R\nCODE:\n```\nas.logical(x)\n```\n\nLANGUAGE: SQL\nCODE:\n```\nIF(x, TRUE, FALSE)\n```\n\n----------------------------------------\n\nTITLE: Performing Set Difference All Operation in dbplyr\nDESCRIPTION: This snippet demonstrates a set difference all operation on two identical lazy tables using dbplyr. It generates SQL for finding all rows in the first table that are not in the second, including duplicates.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/query-set-op.md#2025-04-21_snippet_5\n\nLANGUAGE: R\nCODE:\n```\nsetdiff(lf, lf, all = TRUE)\n```\n\n----------------------------------------\n\nTITLE: Creating a UNION ALL query between identical datasets\nDESCRIPTION: Generates a SQL query that performs a UNION ALL operation between two instances of the same dataframe. This combines all rows from both datasets without removing duplicates.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-hive.md#2025-04-21_snippet_1\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT *\nFROM `df`\n\nUNION ALL\n\nSELECT *\nFROM `df`\n```\n\n----------------------------------------\n\nTITLE: Generating Table Analysis SQL\nDESCRIPTION: Demonstrates how to generate SQL for analyzing table statistics using sql_table_analyze function.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-teradata.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nsql_table_analyze(con, in_schema(\"schema\", \"tbl\"))\n```\n\n----------------------------------------\n\nTITLE: Using .value at Different Positions in names_to Parameter\nDESCRIPTION: Demonstrates how the .value special parameter can be used at different positions in the names_to parameter of pivot_longer. This showcases flexibility in column naming patterns for pivoting operations.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-pivot-longer.md#2025-04-21_snippet_9\n\nLANGUAGE: r\nCODE:\n```\nvalue_first\n```\n\nLANGUAGE: sql\nCODE:\n```\nSELECT `i`, 't1' AS `time`, `y_t1` AS `y`, `z_t1` AS `z`\nFROM `df`\n\nUNION ALL\n\nSELECT `i`, 't2' AS `time`, `y_t2` AS `y`, `z_t2` AS `z`\nFROM `df`\n```\n\nLANGUAGE: r\nCODE:\n```\nvalue_second\n```\n\nLANGUAGE: sql\nCODE:\n```\nSELECT `i`, 't1' AS `time`, `t1_y` AS `y`, `t1_z` AS `z`\nFROM `df`\n\nUNION ALL\n\nSELECT `i`, 't2' AS `time`, `t2_y` AS `y`, `t2_z` AS `z`\nFROM `df`\n```\n\n----------------------------------------\n\nTITLE: Distinct with Default Window Ordering\nDESCRIPTION: Shows distinct operation with .keep_all=TRUE but no explicit ordering, using default ORDER BY on the partition column.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-distinct.md#2025-04-21_snippet_2\n\nLANGUAGE: r\nCODE:\n```\nlf %>% distinct(x, .keep_all = TRUE)\n```\n\nLANGUAGE: sql\nCODE:\n```\nSELECT `x`, `y`\nFROM (\n  SELECT `df`.*, ROW_NUMBER() OVER (PARTITION BY `x` ORDER BY `x`) AS `col01`\n  FROM `df`\n) AS `q01`\nWHERE (`col01` = 1)\n```\n\n----------------------------------------\n\nTITLE: Semi Join with Custom SQL Join Condition\nDESCRIPTION: Shows how semi_join with a custom SQL condition is translated to SQL using EXISTS. This returns all rows from the left table where there is at least one match in the right table based on the condition.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/query-join.md#2025-04-21_snippet_13\n\nLANGUAGE: R\nCODE:\n```\nsemi_join(lf1, lf2, sql_on = \"LHS.y < RHS.z\")\n```\n\n----------------------------------------\n\nTITLE: Validating keep=FALSE with Non-equi Joins in dbplyr\nDESCRIPTION: Demonstrates validation for the keep parameter with non-equi joins. The examples show error conditions when attempting to use keep=FALSE with overlap joins which isn't supported.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-joins.md#2025-04-21_snippet_14\n\nLANGUAGE: R\nCODE:\n```\nleft_join(df1, df2, join_by(overlaps(xl, xu, yl, yu)), keep = FALSE)\n```\n\nLANGUAGE: R\nCODE:\n```\nfull_join(df1, df2, join_by(overlaps(xl, xu, yl, yu)), keep = FALSE)\n```\n\n----------------------------------------\n\nTITLE: Using expressions in tidyr::expand\nDESCRIPTION: Demonstrates how tidyr::expand() can accept expressions that transform columns.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-expand.md#2025-04-21_snippet_4\n\nLANGUAGE: R\nCODE:\n```\ntidyr::expand(df, round(x / 2))\n```\n\n----------------------------------------\n\nTITLE: Testing arrange() with Column Removal Followed by New Ordering\nDESCRIPTION: Shows how the ORDER BY clause is updated when ordering is re-applied after column removal.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-arrange.md#2025-04-21_snippet_4\n\nLANGUAGE: R\nCODE:\n```\nlf %>% arrange(a) %>% select(-a) %>% arrange(b)\n```\n\n----------------------------------------\n\nTITLE: Multi-line Formatting for Complex case_when Expressions\nDESCRIPTION: Shows how complex case_when expressions are formatted across multiple lines in SQL for better readability.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/translate-sql-conditional.md#2025-04-21_snippet_7\n\nLANGUAGE: R\nCODE:\n```\ntest_translate_sql(case_when(x == 1L ~ \"this is long\", x == 0L ~ \"so it should\", TRUE ~ \"be wrapped\"))\n```\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL> CASE\nWHEN (`x` = 1) THEN 'this is long'\nWHEN (`x` = 0) THEN 'so it should'\nELSE 'be wrapped'\nEND\n```\n\n----------------------------------------\n\nTITLE: Testing Variable Reference Limitations in summarise()\nDESCRIPTION: These snippets show that in dbplyr's summarise(), you cannot refer to variables created within the same summarise() call. This applies to both direct references and use within across().\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-summarise.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(summarise(lf1, a_sum = sum(a), issue_col = sum(a_sum))))\n```\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(summarise(lf1, across(c(a, b), list(sum = sum)), issue_col = sum(a_sum))))\n```\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(summarise(lf1, across(c(a, b), list(sum = sum)), issue_col = sum(b_sum))))\n```\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(summarise(lf1, a_sum = sum(a), issue_col = across(a_sum, sum))))\n```\n\n----------------------------------------\n\nTITLE: Dividing Columns Using across() in dbplyr\nDESCRIPTION: Example of using across() to divide multiple columns by a reference column. This demonstrates how across() uses original values when a column is overridden to match dplyr's behavior.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/NEWS.md#2025-04-21_snippet_8\n\nLANGUAGE: r\nCODE:\n```\nmutate(df, across(c(x, y), ~ .x / x))\n```\n\n----------------------------------------\n\nTITLE: Using multiple expressions with nesting in tidyr::expand\nDESCRIPTION: Shows how to use multiple expressions with custom column names in nesting() within expand().\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-expand.md#2025-04-21_snippet_6\n\nLANGUAGE: R\nCODE:\n```\ntidyr::expand(df, nesting(x_half = round(x / 2), x1 = x + 1))\n```\n\n----------------------------------------\n\nTITLE: Testing as_table_path SQL Warning in R\nDESCRIPTION: Demonstrates how as_table_path warns when using a SQL expression where a table identifier is expected, suggesting to use I() for literal identifiers instead.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/table-name.md#2025-04-21_snippet_3\n\nLANGUAGE: r\nCODE:\n```\nas_table_path(sql(\"x\"), con)\n```\n\n----------------------------------------\n\nTITLE: Testing across() Behavior with Grouping Variables\nDESCRIPTION: This snippet shows that across() does not select grouping variables when used within summarise().\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-summarise.md#2025-04-21_snippet_4\n\nLANGUAGE: R\nCODE:\n```\ndf %>% group_by(g) %>% summarise(across(.fns = ~0))\n```\n\n----------------------------------------\n\nTITLE: Validating Table Aliases in dbplyr Joins\nDESCRIPTION: Demonstrates validation of x_as and y_as parameters in join functions. The examples show error conditions when providing invalid aliases such as non-string values or identical aliases for both tables.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-joins.md#2025-04-21_snippet_5\n\nLANGUAGE: R\nCODE:\n```\nleft_join(x, x, by = \"x\", y_as = c(\"A\", \"B\"))\n```\n\nLANGUAGE: R\nCODE:\n```\nleft_join(x, x, by = \"x\", x_as = \"LHS\", y_as = \"LHS\")\n```\n\n----------------------------------------\n\nTITLE: Testing pull() with non-existent column name in dbplyr\nDESCRIPTION: Tests the error message when trying to access a non-existent column by name using the pull() function on a database frame. The test creates a simple database frame with a single column 'x' and attempts to extract a non-existent column.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-pull.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\nmemdb_frame(x = 1) %>% pull(non_existent)\n```\n\n----------------------------------------\n\nTITLE: Error Handling for Duplicate Column Names in Pivot Wider\nDESCRIPTION: Tests error handling when attempting to pivot data would result in duplicate column names. The function checks for uniqueness in the resulting columns.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-pivot-wider.md#2025-04-21_snippet_2\n\nLANGUAGE: r\nCODE:\n```\ntidyr::pivot_wider(df, names_from = key, values_from = val)\n```\n\n----------------------------------------\n\nTITLE: Handling Precedence of TRUE over .default in case_when\nDESCRIPTION: Shows that when both TRUE ~ value and .default are specified, the TRUE ~ value takes precedence in the SQL translation.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/translate-sql-conditional.md#2025-04-21_snippet_5\n\nLANGUAGE: R\nCODE:\n```\ntest_translate_sql(case_when(x == 1L ~ \"yes\", x == 0L ~ \"no\", TRUE ~ \"true\", .default = \"undefined\"))\n```\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL> CASE WHEN (`x` = 1) THEN 'yes' WHEN (`x` = 0) THEN 'no' ELSE 'true' END\n```\n\n----------------------------------------\n\nTITLE: Testing difftime Auto Units Translation\nDESCRIPTION: Tests the translation of difftime() function with auto units parameter, which is not supported in database backends.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-spark-sql.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\ntest_translate_sql(difftime(start_date, end_date, units = \"auto\"))\n```\n\n----------------------------------------\n\nTITLE: Multiple Left Joins Print Method in DBplyr\nDESCRIPTION: Demonstrates how multiple left joins are represented in the SQL_BUILD output. This shows the join relationship structure when chaining multiple tables together with left_join operations.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/query-join.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nleft_join(lf1, lf2, by = \"x\") %>% left_join(lf3, by = \"x\") %>% sql_build()\n```\n\n----------------------------------------\n\nTITLE: Empty Table Creation Query\nDESCRIPTION: SQL translation for creating an empty table with specified column types.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-postgres.md#2025-04-21_snippet_1\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT CAST(NULL AS INTEGER) AS `x`, CAST(NULL AS TEXT) AS `y`\nWHERE (0 = 1)\n```\n\n----------------------------------------\n\nTITLE: Testing rows_upsert() early return with no columns to update\nDESCRIPTION: Demonstrates how rows_upsert() behaves when the source table has no columns to update in the target. It handles this edge case by returning the original table with potentially new rows appended.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/rows.md#2025-04-21_snippet_30\n\nLANGUAGE: R\nCODE:\n```\nrows_upsert(lazy_frame(x = 1:3, y = 11:13, .name = \"df_x\"), lazy_frame(x = 1:3,\n.name = \"df_y\"), by = \"x\", in_place = FALSE)\n```\n\n----------------------------------------\n\nTITLE: Generating SQL for table analysis with schema specification\nDESCRIPTION: Creates SQL syntax for analyzing a table and computing statistics. The table is specified with a schema prefix using the in_schema() function.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-hive.md#2025-04-21_snippet_0\n\nLANGUAGE: SQL\nCODE:\n```\nANALYZE TABLE `schema`.`tbl` COMPUTE STATISTICS\n```\n\n----------------------------------------\n\nTITLE: Testing Query Explanation Error\nDESCRIPTION: Tests error handling when attempting to explain an invalid SQL query using EXPLAIN QUERY PLAN.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/db-sql.md#2025-04-21_snippet_3\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(db_explain(con, \"invalid sql\")))\n```\n\n----------------------------------------\n\nTITLE: Inlining Select After Semi Join and Anti Join in R using dbplyr\nDESCRIPTION: These snippets demonstrate how dbplyr inlines select and relocate operations after semi join and anti join. It selects and renames columns in semi join, and relocates a column in anti join.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-select.md#2025-04-21_snippet_4\n\nLANGUAGE: R\nCODE:\n```\n(out <- semi_join(lf1, lf2, by = \"x\") %>% select(x, a2 = a))\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT `x`, `a` AS `a2`\nFROM `lf1`\nWHERE EXISTS (\n  SELECT 1 FROM `lf2`\n  WHERE (`lf1`.`x` = `lf2`.`x`)\n)\n```\n\nLANGUAGE: R\nCODE:\n```\n(out <- anti_join(lf1, lf2, by = \"x\") %>% relocate(a))\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT `a`, `x`\nFROM `lf1`\nWHERE NOT EXISTS (\n  SELECT 1 FROM `lf2`\n  WHERE (`lf1`.`x` = `lf2`.`x`)\n)\n```\n\n----------------------------------------\n\nTITLE: Testing glue_sql Collapse Restrictions\nDESCRIPTION: Verifies that collapsing is only allowed for 'col' and 'val' types, showing error cases for 'tbl', 'name', and 'from'.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/build-sql.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\nglue_sql2(\"{.tbl x*}\", .con = con)\nglue_sql2(\"{.name x*}\", .con = con)\nglue_sql2(\"{.from x*}\", .con = con)\n```\n\n----------------------------------------\n\nTITLE: SQL Output for tidyr::replace_na with missing columns\nDESCRIPTION: The SQL translation of replace_na when the specified column doesn't exist, which returns all columns unchanged.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-expand.md#2025-04-21_snippet_23\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL>\nSELECT *\nFROM `df`\n```\n\n----------------------------------------\n\nTITLE: Testing arrange() with Column Removal in dbplyr\nDESCRIPTION: Tests SQL generation when a column used for ordering is subsequently removed with select(), showing that the ORDER BY clause remains.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-arrange.md#2025-04-21_snippet_3\n\nLANGUAGE: R\nCODE:\n```\n# remove ordered by\nlf %>% arrange(a) %>% select(-a)\n```\n\n----------------------------------------\n\nTITLE: Error handling for rows_insert with in_place=TRUE\nDESCRIPTION: Shows the error message when attempting to use rows_insert with in_place=TRUE on simulated connections.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/rows.md#2025-04-21_snippet_7\n\nLANGUAGE: R\nCODE:\n```\n(rows_insert(lazy_frame(x = 1:3, y = 11:13, .name = \"df_x\"), lazy_frame(x = 2:3, y = 22:23, .name = \"df_y\"), by = \"x\", in_place = TRUE))\n```\n\n----------------------------------------\n\nTITLE: Testing date_count_between Custom Interval Translation\nDESCRIPTION: Tests the translation of date_count_between() function with custom interval parameter (n=5), which is not supported in database backends.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-spark-sql.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\ntest_translate_sql(date_count_between(date_column_1, date_column_2, \"day\", n = 5))\n```\n\n----------------------------------------\n\nTITLE: Testing window_order with renamed variables (second approach)\nDESCRIPTION: Tests that window_order works correctly when used after renaming a variable. Creates a SQL query with a window function that uses the new column name in the ORDER BY clause.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-window.md#2025-04-21_snippet_4\n\nLANGUAGE: r\nCODE:\n```\nlazy_frame(x = 1, y = 1) %>% rename(y2 = y) %>% window_order(y2) %>% mutate(\n  x_cum = cumsum(x))\n```\n\n----------------------------------------\n\nTITLE: Testing arrange() Before head() in dbplyr\nDESCRIPTION: Shows how ORDER BY is applied directly before LIMIT when arrange() precedes head().\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-arrange.md#2025-04-21_snippet_9\n\nLANGUAGE: R\nCODE:\n```\nlf %>% arrange(a) %>% head(1)\n```\n\n----------------------------------------\n\nTITLE: Error handling for rows_append with in_place=TRUE\nDESCRIPTION: Shows the error message when attempting to use rows_append with in_place=TRUE on simulated connections.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/rows.md#2025-04-21_snippet_13\n\nLANGUAGE: R\nCODE:\n```\n(rows_append(lazy_frame(x = 1:3, y = 11:13, .name = \"df_x\"), lazy_frame(x = 2:3, y = 22:23, .name = \"df_y\"), in_place = TRUE))\n```\n\n----------------------------------------\n\nTITLE: Testing Incompatibility of .by and .groups Arguments\nDESCRIPTION: These snippets show that .by and .groups arguments cannot be used together in summarise(), and .by cannot be used with grouped data frames.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-summarise.md#2025-04-21_snippet_6\n\nLANGUAGE: R\nCODE:\n```\nsummarise(df, .by = x, .groups = \"drop\")\n```\n\nLANGUAGE: R\nCODE:\n```\nsummarise(gdf, .by = x)\n```\n\n----------------------------------------\n\nTITLE: Testing arrange() Before semi_join() in dbplyr\nDESCRIPTION: Demonstrates warning when arrange() is used before a semi_join operation.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-arrange.md#2025-04-21_snippet_16\n\nLANGUAGE: R\nCODE:\n```\nlf %>% arrange(a) %>% semi_join(rf)\n```\n\n----------------------------------------\n\nTITLE: Testing SQL translation with warning for windowed expressions without explicit order\nDESCRIPTION: Demonstrates attempting to translate a sum function with na.rm parameter in windowed context, which generates a warning about deterministic ordering.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/translate-sql-window.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\ntest_translate_sql(sum(x, na.rm = TRUE), vars_frame = c(1, 0))\n```\n\n----------------------------------------\n\nTITLE: Handling Unsupported Rolling Joins in dbplyr\nDESCRIPTION: Demonstrates that rolling joins are not supported on database backends in dbplyr. The examples show the error messages for both left_join and semi_join when attempting to use closest() in join conditions.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-joins.md#2025-04-21_snippet_16\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(left_join(lf, lf, join_by(closest(x >= y)))))\n```\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(semi_join(lf, lf, join_by(closest(x >= y)))))\n```\n\n----------------------------------------\n\nTITLE: Testing pull() with out-of-bounds column index in dbplyr\nDESCRIPTION: Tests the error message when trying to access a column by an index that is out of bounds. The test creates a database frame with a single column and attempts to extract column at position 1000, which doesn't exist.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-pull.md#2025-04-21_snippet_2\n\nLANGUAGE: r\nCODE:\n```\nmemdb_frame(x = 1) %>% pull(1000)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating rows_delete() with in_place=FALSE\nDESCRIPTION: Shows how rows_delete() generates SQL to remove matching rows from one table based on keys in another table. The operation uses NOT EXISTS to keep only rows that don't match the deletion criteria.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/rows.md#2025-04-21_snippet_34\n\nLANGUAGE: R\nCODE:\n```\nrows_delete(lazy_frame(x = 1:3, y = c(11, 12, NA), .name = \"df_x\"), lazy_frame(\n  x = 2:3, .name = \"df_y\"), by = \"x\", unmatched = \"ignore\", in_place = FALSE)\n```\n\n----------------------------------------\n\nTITLE: Error Handling for Named Filter Inputs with Multiple Conditions\nDESCRIPTION: Demonstrates error handling when one condition is correct but another uses = instead of ==. The function identifies the problematic condition and suggests a fix.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-filter.md#2025-04-21_snippet_3\n\nLANGUAGE: r\nCODE:\n```\nfilter(lf, y > 1, x = 1)\n```\n\n----------------------------------------\n\nTITLE: Translating row_number() without grouping\nDESCRIPTION: Demonstrates SQL translation of row_number() without grouping, using ORDER BY (SELECT NULL) as default ordering.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-snowflake.md#2025-04-21_snippet_3\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT `df`.*, ROW_NUMBER() OVER (ORDER BY (SELECT NULL)) AS `rown`\nFROM `df`\n```\n\n----------------------------------------\n\nTITLE: SQL Alias and Multiple Statement Generation\nDESCRIPTION: Shows how to generate SQL statements with column aliasing and multiple expressions using the sql() function.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/sql.md#2025-04-21_snippet_1\n\nLANGUAGE: r\nCODE:\n```\nsql(a = \"x\", \"y\")\n```\n\n----------------------------------------\n\nTITLE: Testing Ordering with Consecutive Mutations in dbplyr\nDESCRIPTION: Demonstrates warning generation when arrange() is used between mutations without LIMIT, as the ordering would be ineffective.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-arrange.md#2025-04-21_snippet_14\n\nLANGUAGE: R\nCODE:\n```\nlf %>% mutate(a = -a) %>% arrange(a) %>% mutate(a = -a)\n```\n\n----------------------------------------\n\nTITLE: Testing Non-Unique Breaks Error in cut() Function in R\nDESCRIPTION: Tests that cut() throws an error when the breaks are not unique values. The function requires distinct break points to create proper intervals.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/translate-sql-cut.md#2025-04-21_snippet_2\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(test_translate_sql(cut(x, c(1, 1)))))\n```\n\n----------------------------------------\n\nTITLE: Demonstrating rows_upsert() error with in_place=TRUE\nDESCRIPTION: Shows that rows_upsert() with in_place=TRUE produces an error for simulated connections, similar to rows_patch(). This indicates a consistent limitation in dbplyr's handling of direct database modifications.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/rows.md#2025-04-21_snippet_32\n\nLANGUAGE: R\nCODE:\n```\n(rows_upsert(lazy_frame(x = 1:3, y = 11:13, .name = \"df_x\"), lazy_frame(x = 2:3,\ny = 22:23, .name = \"df_y\"), by = \"x\", in_place = TRUE))\n```\n\n----------------------------------------\n\nTITLE: Integer64 Translation to SQL BIGINT\nDESCRIPTION: Shows how dbplyr translates R's as.integer64() function to SQL's CAST with BIGINT type for handling large integer values.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/NEWS.md#2025-04-21_snippet_17\n\nLANGUAGE: R\nCODE:\n```\nas.integer64(x)\n```\n\nLANGUAGE: SQL\nCODE:\n```\nCAST(x AS BIGINT)\n```\n\n----------------------------------------\n\nTITLE: Translating Left Join in dbplyr to SQL\nDESCRIPTION: Demonstrates how dbplyr translates a left join operation with na_matches parameter into SQL. The join is performed on the 'x' column with null value matching.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-sqlite.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nleft_join(lf, lf, by = \"x\", na_matches = \"na\")\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT `df_LHS`.`x` AS `x`\nFROM `df` AS `df_LHS`\nLEFT JOIN `df` AS `df_RHS`\n  ON (`df_LHS`.`x` IS `df_RHS`.`x`)\n```\n\n----------------------------------------\n\nTITLE: Anti-Join SQL Generation in dbplyr\nDESCRIPTION: Demonstrates the SQL query generated for an anti-join between two identical lazy frames. The query uses NOT EXISTS clause to implement the anti-join operation with matching on columns x and y.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/query-semi-join.md#2025-04-21_snippet_2\n\nLANGUAGE: r\nCODE:\n```\nanti_join(lf, lf)\n```\n\n----------------------------------------\n\nTITLE: Error Messages for Invalid Group Expressions\nDESCRIPTION: Demonstrates error handling for invalid group_by() expressions, including non-existent variables in computations and across() selections.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-group_by.md#2025-04-21_snippet_3\n\nLANGUAGE: r\nCODE:\n```\nlf %>% group_by(z = non_existent + 1)\nlf %>% group_by(across(non_existent))\n```\n\n----------------------------------------\n\nTITLE: Testing arrange() Cancellation After Column Removal\nDESCRIPTION: Shows cancellation of ordering after a column has been removed from the result set.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-arrange.md#2025-04-21_snippet_6\n\nLANGUAGE: R\nCODE:\n```\nlf %>% arrange(a) %>% select(-a) %>% arrange()\n```\n\n----------------------------------------\n\nTITLE: Testing Double arrange() in dbplyr\nDESCRIPTION: Shows how a second arrange() operation replaces the previous ordering rather than adding to it.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-arrange.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\n# double arrange\nlf %>% arrange(a) %>% arrange(b)\n```\n\n----------------------------------------\n\nTITLE: Support for legacy interface in sql_query_append\nDESCRIPTION: Shows backward compatibility support for old interface in sql_query_append with warning message.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/rows.md#2025-04-21_snippet_15\n\nLANGUAGE: R\nCODE:\n```\nsql_query_append(con = con, table = ident(\"df_x\"), from = df_y, returning_cols = c(\"a\", b2 = \"b\"))\n```\n\n----------------------------------------\n\nTITLE: Error When Using tidyr::pivot_wider Directly with Lazy Frames\nDESCRIPTION: Shows that direct use of tidyr::pivot_wider with lazy frames is not supported. Users should use memdb_frame() together with show_query() to see the SQL code.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-pivot-wider.md#2025-04-21_snippet_8\n\nLANGUAGE: r\nCODE:\n```\ntidyr::pivot_wider(lazy_frame(name = \"x\", value = 1))\n```\n\n----------------------------------------\n\nTITLE: Explaining a Query in dbplyr\nDESCRIPTION: Demonstrates how to use the explain() function in dbplyr to get the SQL query and execution plan for a simple filter operation. The plan shows the use of an index for the query.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-sqlite.md#2025-04-21_snippet_3\n\nLANGUAGE: R\nCODE:\n```\ndb %>% filter(x > 2) %>% explain()\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT `test`.*\nFROM `test`\nWHERE (`x` > 2.0)\n\n<PLAN>\n  id parent notused                                        detail\n1  2      0      35 SEARCH test USING COVERING INDEX test_x (x>?)\n```\n\n----------------------------------------\n\nTITLE: Using deprecated check_from parameter in dbplyr\nDESCRIPTION: Demonstrates the warning message shown when using the deprecated 'check_from' parameter in a tbl function call. The warning indicates that this parameter is deprecated as of dbplyr 2.5.0.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/tbl-sql.md#2025-04-21_snippet_2\n\nLANGUAGE: r\nCODE:\n```\nout <- tbl(con, \"x\", check_from = FALSE)\n```\n\n----------------------------------------\n\nTITLE: Testing difftime Function Translations\nDESCRIPTION: These test cases verify error handling for unsupported parameters in the difftime function when translating to SQL. The tests demonstrate that only the 'days' unit is supported and timezone parameters are not allowed.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-redshift.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\ntest_translate_sql(difftime(start_date, end_date, units = \"auto\"))\n```\n\nLANGUAGE: R\nCODE:\n```\ntest_translate_sql(difftime(start_date, end_date, tz = \"UTC\", units = \"days\"))\n```\n\n----------------------------------------\n\nTITLE: Error handling for invalid suffix arguments in inner_join with dbplyr\nDESCRIPTION: Shows error messages for invalid suffix arguments in inner_join. The function requires a character vector of length 2 and validates this requirement.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-joins.md#2025-04-21_snippet_23\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(inner_join(lf1, lf2, by = \"x\", suffix = \"a\")))\n```\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(inner_join(lf1, lf2, by = \"x\", suffix = 1L)))\n```\n\n----------------------------------------\n\nTITLE: Generating SQL for rows_append with in_place=FALSE\nDESCRIPTION: Shows SQL generation for rows_append operation with in_place=FALSE, using UNION ALL to combine tables.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/rows.md#2025-04-21_snippet_12\n\nLANGUAGE: R\nCODE:\n```\nrows_append(lazy_frame(x = 1:3, y = 11:13, .name = \"df_x\"), lazy_frame(x = 3:4, y = 23:24, .name = \"df_y\"), in_place = FALSE)\n```\n\n----------------------------------------\n\nTITLE: Testing Unsupported reframe() Function in dbplyr\nDESCRIPTION: This snippet demonstrates that the reframe() function is not supported in dbplyr when used with database backends.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-summarise.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nlazy_frame(x = 1) %>% reframe()\n```\n\n----------------------------------------\n\nTITLE: Creating Temporary Tables with Prefix in dbplyr\nDESCRIPTION: Shows how db_table_temporary() creates a temporary table with appropriate naming convention. The function extracts the table name from a path and prefixes it with # to indicate a temporary table in SQL Server syntax.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-mssql.md#2025-04-21_snippet_7\n\nLANGUAGE: R\nCODE:\n```\nout <- db_table_temporary(con, table_path(\"foo.bar\"), temporary = TRUE)\n```\n\n----------------------------------------\n\nTITLE: Performing Intersection Operation in dbplyr\nDESCRIPTION: This snippet demonstrates an intersection operation on two identical lazy tables using dbplyr. It generates SQL to find distinct rows that are common to both tables.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/query-set-op.md#2025-04-21_snippet_3\n\nLANGUAGE: R\nCODE:\n```\nintersect(lf, lf)\n```\n\n----------------------------------------\n\nTITLE: Testing arrange() After union() in dbplyr\nDESCRIPTION: Demonstrates how ordering is applied to the result of a UNION operation.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-arrange.md#2025-04-21_snippet_20\n\nLANGUAGE: R\nCODE:\n```\nlf %>% union(rf) %>% arrange(a)\n```\n\n----------------------------------------\n\nTITLE: Column existence checking in rows_update\nDESCRIPTION: Shows error handling when attempting to update with columns that don't exist in the target table.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/rows.md#2025-04-21_snippet_20\n\nLANGUAGE: R\nCODE:\n```\n(rows_update(lf, lazy_frame(x = 1, y = 2, z = 3), by = \"x\", unmatched = \"ignore\"))\n```\n\n----------------------------------------\n\nTITLE: Validating na_matches Parameter in dbplyr Joins\nDESCRIPTION: Shows validation for the na_matches parameter in join functions. The examples demonstrate error conditions when providing invalid values for this parameter in left_join and semi_join operations.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-joins.md#2025-04-21_snippet_17\n\nLANGUAGE: R\nCODE:\n```\nleft_join(df, df, by = \"x\", na_matches = 1)\n```\n\nLANGUAGE: R\nCODE:\n```\nleft_join(df, df, by = \"x\", na_matches = \"foo\")\n```\n\nLANGUAGE: R\nCODE:\n```\nsemi_join(df, df, by = \"x\", na_matches = 1)\n```\n\nLANGUAGE: R\nCODE:\n```\nsemi_join(df, df, by = \"x\", na_matches = \"foo\")\n```\n\n----------------------------------------\n\nTITLE: Testing Multiple Ordering Operations with head() in dbplyr\nDESCRIPTION: Demonstrates how ordering is handled when multiple arrange() operations are interspersed with head().\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-arrange.md#2025-04-21_snippet_10\n\nLANGUAGE: R\nCODE:\n```\nlf %>% arrange(a) %>% head(1) %>% arrange(b)\n```\n\n----------------------------------------\n\nTITLE: Testing paste0() Translation Error Handling\nDESCRIPTION: Demonstrates error handling when attempting to translate R's paste0() with collapse parameter to SQL, suggesting str_flatten() as alternative.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-snowflake.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\ntest_translate_sql(paste0(x, collapse = \"\"))\n```\n\n----------------------------------------\n\nTITLE: Testing db_copy_to Table Overwrite\nDESCRIPTION: Tests error handling when attempting to copy data to an existing table. Verifies proper error propagation from DBI write operations.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/db-io.md#2025-04-21_snippet_1\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(db_copy_to(con = con, table = \"tmp\", values = data.frame(x = c(1, 1)))))\n```\n\n----------------------------------------\n\nTITLE: SQL Output for tidyr::expand with grouped data\nDESCRIPTION: The SQL translation of expand with grouped data, using LEFT JOIN to maintain group relationships.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-expand.md#2025-04-21_snippet_11\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL>\nSELECT `LHS`.*, `c`\nFROM (\n  SELECT DISTINCT `a`, `b`\n  FROM `df`\n) AS `LHS`\nLEFT JOIN (\n  SELECT DISTINCT `a`, `c`\n  FROM `df`\n) AS `RHS`\n  ON (`LHS`.`a` = `RHS`.`a`)\n```\n\n----------------------------------------\n\nTITLE: Testing db_copy_to Error with Unique Index\nDESCRIPTION: Tests error handling when attempting to copy data to a table with unique index constraints. Verifies proper error propagation from DBI operations.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/db-io.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(db_copy_to(con = con, table = \"tmp2\", values = data.frame(x = c(1, 1)), unique_indexes = list(\"x\"))))\n```\n\n----------------------------------------\n\nTITLE: Testing db_save_query Table Overwrite\nDESCRIPTION: Tests error handling when attempting to save a query result to an existing table. Verifies proper error handling for CREATE TABLE AS operations.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/db-io.md#2025-04-21_snippet_2\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(db_save_query(con = con, sql = \"SELECT 2 FROM tmp\", name = \"tmp\")))\n```\n\n----------------------------------------\n\nTITLE: Error handling for in_place operations in rows_update\nDESCRIPTION: Shows error handling when attempting in-place updates without a determinable target table name.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/rows.md#2025-04-21_snippet_22\n\nLANGUAGE: R\nCODE:\n```\n(df %>% mutate(x = x + 1) %>% rows_update(df, by = \"x\", unmatched = \"ignore\", in_place = TRUE))\n```\n\n----------------------------------------\n\nTITLE: Testing difftime with Timezone Parameter\nDESCRIPTION: Tests the translation of difftime() function with timezone parameter, which is not supported in database backends.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-spark-sql.md#2025-04-21_snippet_3\n\nLANGUAGE: R\nCODE:\n```\ntest_translate_sql(difftime(start_date, end_date, tz = \"UTC\", units = \"days\"))\n```\n\n----------------------------------------\n\nTITLE: Testing Subsetting Translation\nDESCRIPTION: Test cases for subsetting operations showing error handling for invalid indexing.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\ntest_translate_sql(a[[x]])\n```\n\nLANGUAGE: R\nCODE:\n```\ntest_translate_sql(a[[TRUE]])\n```\n\n----------------------------------------\n\nTITLE: Table Values Insertion Query\nDESCRIPTION: SQL translation for inserting values into a table using VALUES clause.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-postgres.md#2025-04-21_snippet_2\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT CAST(`x` AS INTEGER) AS `x`, CAST(`y` AS TEXT) AS `y`\nFROM (  VALUES (1, 'a'), (2, 'b')) AS drvd(`x`, `y`)\n```\n\n----------------------------------------\n\nTITLE: Testing summarise() with .groups Argument\nDESCRIPTION: This snippet shows the default grouping behavior of summarise() and demonstrates that 'rowwise' is not a valid .groups option in dbplyr.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-summarise.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\neval_bare(expr(lazy_frame(x = 1, y = 2) %>% dplyr::group_by(x, y) %>% dplyr::summarise() %>% remote_query()), env(global_env()))\n```\n\nLANGUAGE: R\nCODE:\n```\ndf %>% summarise(.groups = \"rowwise\")\n```\n\n----------------------------------------\n\nTITLE: Testing date_count_between Function Translations\nDESCRIPTION: These test cases verify the error handling for unsupported parameters in the date_count_between function when translating to SQL. The tests show that only specific precision and n values are supported.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-redshift.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\ntest_translate_sql(date_count_between(date_column_1, date_column_2, \"year\"))\n```\n\nLANGUAGE: R\nCODE:\n```\ntest_translate_sql(date_count_between(date_column_1, date_column_2, \"day\", n = 5))\n```\n\n----------------------------------------\n\nTITLE: Testing row_number() with invalid c() usage in dbplyr\nDESCRIPTION: Shows the error thrown when trying to use c() within row_number() function, providing a helpful error message suggesting the use of tibble() instead.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/translate-sql-window.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\ntest_translate_sql(row_number(c(x)))\n```\n\n----------------------------------------\n\nTITLE: Error handling for returning parameter in rows_update\nDESCRIPTION: Shows error handling for the 'returning' parameter in rows_update with simulated connections.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/rows.md#2025-04-21_snippet_21\n\nLANGUAGE: R\nCODE:\n```\n(rows_update(lf, lf, by = \"x\", unmatched = \"ignore\", returning = everything()))\n```\n\n----------------------------------------\n\nTITLE: Testing arrange() After semi_join() in dbplyr\nDESCRIPTION: Shows how ordering is applied after a semi_join operation.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-arrange.md#2025-04-21_snippet_19\n\nLANGUAGE: R\nCODE:\n```\nlf %>% semi_join(rf) %>% arrange(a)\n```\n\n----------------------------------------\n\nTITLE: Error Handling in ungroup() for Invalid Columns\nDESCRIPTION: Shows error message generation when attempting to ungroup by non-existent columns.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-group_by.md#2025-04-21_snippet_4\n\nLANGUAGE: r\nCODE:\n```\nlazy_frame(x = 1) %>% ungroup(non_existent)\n```\n\n----------------------------------------\n\nTITLE: Error handling for incorrect table name specification in dbplyr\nDESCRIPTION: Shows the error message generated when trying to reference a table with a period in its name without using I(). The error provides guidance on the correct syntax using I(\"foo.bar\").\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/tbl-sql.md#2025-04-21_snippet_1\n\nLANGUAGE: r\nCODE:\n```\ntbl(src_memdb(), \"foo.bar\")\n```\n\n----------------------------------------\n\nTITLE: DBI Connection Database Query Example\nDESCRIPTION: Example showing SQL string escaping and database query using DBI interface.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/NEWS.md#2025-04-21_snippet_10\n\nLANGUAGE: R\nCODE:\n```\nDBI::dbQuoteIdentifier()\nDBI::dbQuoteString()\nDBI::dbExecute(immediate = TRUE)\n```\n\n----------------------------------------\n\nTITLE: Testing SQL Rendering of Summarized Grouped Table\nDESCRIPTION: This snippet demonstrates the SQL rendering of a summarized grouped table in dbplyr.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-summarise.md#2025-04-21_snippet_7\n\nLANGUAGE: R\nCODE:\n```\nout %>% sql_render\n```\n\n----------------------------------------\n\nTITLE: Error Handling for Mixed Named/Unnamed Arguments in dplyr do()\nDESCRIPTION: Example demonstrating that arguments to do() must be consistently named or unnamed. This error occurs when trying to mix a named argument (nrow) with an unnamed argument (ncol(.)).\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-do.md#2025-04-21_snippet_1\n\nLANGUAGE: r\nCODE:\n```\nmf %>% do(nrow = nrow(.), ncol(.))\n```\n\n----------------------------------------\n\nTITLE: Argument checking in rows_append\nDESCRIPTION: Demonstrates error handling when invalid arguments are passed to rows_append function.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/rows.md#2025-04-21_snippet_11\n\nLANGUAGE: R\nCODE:\n```\n(lf %>% rows_append(df, by = \"x\"))\n```\n\nLANGUAGE: R\nCODE:\n```\n(lf %>% rows_append(df, conflict = \"error\"))\n```\n\n----------------------------------------\n\nTITLE: Schema Access Error in get_schema Example\nDESCRIPTION: An example showing that get_schema() works for connections but fails when trying to extract schema from tables. The error occurs when trying to access the schema property on an atomic vector.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/revdep/problems.md#2025-04-21_snippet_2\n\nLANGUAGE: r\nCODE:\n```\nconn <- get_connection(drv = RSQLite::SQLite())\n\ndplyr::copy_to(conn, mtcars, name = \"mtcars\")\n\nget_schema(conn)\n[1] \"temp\"\nget_schema(get_table(conn, id(\"mtcars\", conn = conn)))\nError in unclass(dbplyr::remote_table(.x))$schema : \n  $ operator is invalid for atomic vectors\nCalls: get_schema -> get_schema.tbl_dbi\nExecution halted\n```\n\n----------------------------------------\n\nTITLE: Defining op_base function in R for dbplyr\nDESCRIPTION: This code shows the updated signature of the op_base function, which now takes three parameters: x, vars, and class.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/NEWS.md#2025-04-21_snippet_23\n\nLANGUAGE: R\nCODE:\n```\nop_base(x, vars, class)\n```\n\n----------------------------------------\n\nTITLE: SQL Output for tidyr::expand with expressions\nDESCRIPTION: The SQL translation of expand with an expression, using ROUND function and aliasing the result.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-expand.md#2025-04-21_snippet_5\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL>\nSELECT DISTINCT ROUND(`x` / 2.0, 0) AS `round(x/2)`\nFROM `df`\n```\n\n----------------------------------------\n\nTITLE: Generating SQL for append with returning columns\nDESCRIPTION: Demonstrates SQL generation for append operation with returning columns specified.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/rows.md#2025-04-21_snippet_14\n\nLANGUAGE: R\nCODE:\n```\nsql_query_append(con = con, table = ident(\"df_x\"), from = sql_render(df_y, con, lvl = 1), insert_cols = colnames(df_y), returning_cols = c(\"a\", b2 = \"b\"))\n```\n\n----------------------------------------\n\nTITLE: Error context handling in rows_get_or_execute\nDESCRIPTION: Demonstrates how rows_get_or_execute provides context for database modification errors, including the SQL query that caused the error.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/rows.md#2025-04-21_snippet_8\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(rows_append(tbl(con, \"mtcars\"), tibble(x = 1), copy = TRUE, in_place = TRUE)))\n```\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(rows_append(tbl(con, \"mtcars\"), tibble(x = 1), copy = TRUE, in_place = TRUE, returning = x)))\n```\n\n----------------------------------------\n\nTITLE: Error handling with NULL in tidyr::expand\nDESCRIPTION: Shows the error when tidyr::expand() is called with only NULL values.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-expand.md#2025-04-21_snippet_16\n\nLANGUAGE: R\nCODE:\n```\ntidyr::expand(memdb_frame(x = 1), x = NULL)\n```\n\n----------------------------------------\n\nTITLE: Testing as_table_path Input Validation in R\nDESCRIPTION: A series of tests showing various validation errors when calling as_table_path with invalid inputs, including missing connection object, character vector instead of a single string, and numeric input.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/table-name.md#2025-04-21_snippet_2\n\nLANGUAGE: r\nCODE:\n```\nas_table_path(\"x\")\n```\n\nLANGUAGE: r\nCODE:\n```\nas_table_path(c(\"x\", \"y\"), con)\n```\n\nLANGUAGE: r\nCODE:\n```\nas_table_path(1, con)\n```\n\nLANGUAGE: r\nCODE:\n```\nas_table_path(I(1), con)\n```\n\n----------------------------------------\n\nTITLE: Testing SQL Translation in dplyr Pipelines with mutate()\nDESCRIPTION: Tests how namespace-qualified function calls behave within dplyr pipelines using mutate(). Shows error handling for non-existent packages, functions, and functions without SQL translation implementations.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/translate-sql.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\nlz %>% mutate(x = NOSUCHPACKAGE::foo())\n```\n\nLANGUAGE: R\nCODE:\n```\nlz %>% mutate(x = dbplyr::NOSUCHFUNCTION())\n```\n\nLANGUAGE: R\nCODE:\n```\nlz %>% mutate(x = base::abbreviate(x))\n```\n\n----------------------------------------\n\nTITLE: Handling Unsupported .drop Parameter\nDESCRIPTION: Demonstrates error handling when attempting to use .drop = FALSE with database backends, which is not supported.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-group_by.md#2025-04-21_snippet_1\n\nLANGUAGE: r\nCODE:\n```\nlazy_frame(x = 1:3, y = 1:3) %>% group_by(y, .drop = FALSE)\n```\n\n----------------------------------------\n\nTITLE: Error Handling for case_match with No Conditions\nDESCRIPTION: Shows error messages when case_match is called with no valid match conditions.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/translate-sql-conditional.md#2025-04-21_snippet_10\n\nLANGUAGE: R\nCODE:\n```\ntest_translate_sql(case_match(x))\n```\n\nLANGUAGE: text\nCODE:\n```\nError in `case_match()`:\n! No cases provided\n```\n\nLANGUAGE: R\nCODE:\n```\ntest_translate_sql(case_match(x, NULL))\n```\n\nLANGUAGE: text\nCODE:\n```\nError in `case_match()`:\n! No cases provided\n```\n\n----------------------------------------\n\nTITLE: Testing sql_query_delete() SQL generation\nDESCRIPTION: Shows the SQL generated by sql_query_delete() for performing a conditional deletion with RETURNING clause. The query deletes rows from df_x that match criteria in df_y and returns specified columns from the deleted rows.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/rows.md#2025-04-21_snippet_36\n\nLANGUAGE: R\nCODE:\n```\nsql_query_delete(con = simulate_dbi(), table = ident(\"df_x\"), from = sql_render(\n  df_y, simulate_dbi(), lvl = 2), by = c(\"a\", \"b\"), returning_cols = c(\"a\", b2 = \"b\"))\n```\n\n----------------------------------------\n\nTITLE: Error handling for named by parameter in rows_update\nDESCRIPTION: Shows error handling when providing named vector for by parameter in rows_update.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/rows.md#2025-04-21_snippet_17\n\nLANGUAGE: R\nCODE:\n```\n(rows_update(lf, lf, by = c(y = \"x\"), unmatched = \"ignore\"))\n```\n\n----------------------------------------\n\nTITLE: Testing substr() Function with Missing Stop Parameter in R\nDESCRIPTION: This test case verifies the error handling when the 'stop' parameter is missing in the substr() function call.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/translate-sql-string.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\nsubstr(\"test\", 0)\n```\n\n----------------------------------------\n\nTITLE: Testing build_sql Connection Requirement\nDESCRIPTION: Demonstrates that build_sql() requires a connection parameter and throws an error when con is NULL.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/build-sql.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nbuild_sql(\"SELECT * FROM \", x)\n```\n\n----------------------------------------\n\nTITLE: Handling Deprecated 'add' Argument in group_by()\nDESCRIPTION: Shows error handling for the deprecated 'add' argument in group_by(), directing users to use '.add' instead. This change was made in dplyr 1.0.0.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-group_by.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\ngf <- mf %>% group_by(x) %>% group_by(y, add = TRUE)\n```\n\n----------------------------------------\n\nTITLE: Inlining select() Before Joins in dbplyr\nDESCRIPTION: Shows how select() operations before joins are inlined in the SQL query rather than creating subqueries. This demonstrates dbplyr's query optimization by incorporating column selection directly in the join operation.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-joins.md#2025-04-21_snippet_6\n\nLANGUAGE: R\nCODE:\n```\nout_left\n```\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL>\nSELECT `a` AS `a2`, `x1` AS `x`, `b`\nFROM `lf1`\nLEFT JOIN `lf2`\n  ON (`lf1`.`x1` = `lf2`.`x2`)\n```\n\n----------------------------------------\n\nTITLE: Testing arrange() with mutate() in dbplyr\nDESCRIPTION: Shows SQL generation when arrange() follows a mutate() operation that changes column values.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-arrange.md#2025-04-21_snippet_11\n\nLANGUAGE: R\nCODE:\n```\n# mutate\nlf %>% mutate(a = b) %>% arrange(a)\n```\n\n----------------------------------------\n\nTITLE: Testing pull() with non-existent column as string in dbplyr\nDESCRIPTION: Tests the error message when trying to access a non-existent column by string name using the pull() function on a database frame. The test creates a simple database frame with a single column 'x' and attempts to extract a column called 'non_existent'.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-pull.md#2025-04-21_snippet_1\n\nLANGUAGE: r\nCODE:\n```\nmemdb_frame(x = 1) %>% pull(\"non_existent\")\n```\n\n----------------------------------------\n\nTITLE: Testing Empty SQL Identifier in R using dbplyr\nDESCRIPTION: Demonstrates calling ident() with no arguments to generate an empty SQL identifier. The output shows the IDENT type with an [empty] value.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/ident.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nident()\n```\n\n----------------------------------------\n\nTITLE: Error handling for column mismatch in rows_insert\nDESCRIPTION: Demonstrates error handling when attempting to insert data with columns that don't exist in the target table.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/rows.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\n(rows_insert(lf, lazy_frame(x = 1, y = 2, z = 3), by = \"x\", conflict = \"ignore\"))\n```\n\n----------------------------------------\n\nTITLE: Generating SQL EXPLAIN Plan\nDESCRIPTION: Demonstrates how sql_query_explain() creates SQL to get the execution plan for a query, useful for debugging performance issues.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-oracle.md#2025-04-21_snippet_4\n\nLANGUAGE: R\nCODE:\n```\nsql_query_explain(con, sql(\"SELECT * FROM foo\"))\n```\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL> EXPLAIN PLAN FOR SELECT * FROM foo\n<SQL> SELECT PLAN_TABLE_OUTPUT FROM TABLE(DBMS_XPLAN.DISPLAY())\n```\n\n----------------------------------------\n\nTITLE: Testing get_returned_rows() error handling\nDESCRIPTION: Demonstrates how get_returned_rows() handles the case when no returned rows are available. This shows proper error handling for operations that don't return row data.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/rows.md#2025-04-21_snippet_37\n\nLANGUAGE: R\nCODE:\n```\n(get_returned_rows(df))\n```\n\n----------------------------------------\n\nTITLE: SQL Output for tidyr::expand with tidyr::nesting\nDESCRIPTION: The SQL translation of expand with tidyr::nesting(), which generates a simple DISTINCT selection.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-expand.md#2025-04-21_snippet_9\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL>\nSELECT DISTINCT `df`.*\nFROM `df`\n```\n\n----------------------------------------\n\nTITLE: Handling returning parameter in rows_insert\nDESCRIPTION: Shows error handling for the 'returning' parameter in rows_insert with simulated connections.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/rows.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\n(rows_insert(lf, lf, by = \"x\", conflict = \"ignore\", returning = everything()))\n```\n\n----------------------------------------\n\nTITLE: Testing substr() Function with Invalid Start Parameter Type in R\nDESCRIPTION: This test case checks the error handling when the 'start' parameter is a string instead of a number in the substr() function call.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/translate-sql-string.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\nsubstr(\"test\", \"x\", 1)\n```\n\n----------------------------------------\n\nTITLE: Repairing Column Names in DBPlyr pivot_longer\nDESCRIPTION: Shows how to handle name conflicts during pivot_longer operations using the names_repair parameter. When column names conflict, this parameter ensures uniqueness by adding suffixes to duplicated names.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-pivot-longer.md#2025-04-21_snippet_10\n\nLANGUAGE: r\nCODE:\n```\nout <- df %>% tidyr::pivot_longer(c(x, y), names_repair = \"unique\")\n```\n\nLANGUAGE: message\nCODE:\n```\nNew names:\n* `name` -> `name...2`\n* `value` -> `value...3`\n* `name` -> `name...4`\n* `value` -> `value...5`\n```\n\n----------------------------------------\n\nTITLE: Generating SQL for Table Creation with Temporary Option\nDESCRIPTION: Shows how sql_query_save() generates SQL to create tables from query results, with options for temporary vs permanent tables.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-oracle.md#2025-04-21_snippet_6\n\nLANGUAGE: R\nCODE:\n```\nsql_query_save(con, sql(\"SELECT * FROM foo\"), in_schema(\"schema\", \"tbl\"))\n```\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL> CREATE GLOBAL TEMPORARY TABLE `schema`.`tbl` AS\nSELECT * FROM foo\n```\n\nLANGUAGE: R\nCODE:\n```\nsql_query_save(con, sql(\"SELECT * FROM foo\"), in_schema(\"schema\", \"tbl\"),\ntemporary = FALSE)\n```\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL> CREATE TABLE `schema`.`tbl` AS\nSELECT * FROM foo\n```\n\n----------------------------------------\n\nTITLE: Handling missing columns in tidyr::replace_na\nDESCRIPTION: Shows how tidyr::replace_na() handles columns that don't exist in the data frame.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-expand.md#2025-04-21_snippet_22\n\nLANGUAGE: R\nCODE:\n```\nlazy_frame(x = 1) %>% tidyr::replace_na(list(not_there = 0))\n```\n\n----------------------------------------\n\nTITLE: Testing Index Creation Error\nDESCRIPTION: Tests error handling when attempting to create an index on a table column that encounters a DBI error.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/db-sql.md#2025-04-21_snippet_2\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(db_create_index(con, \"tbl\", \"col\")))\n```\n\n----------------------------------------\n\nTITLE: Testing substr() Function with Missing Start Parameter in R\nDESCRIPTION: This test case checks the error handling when the 'start' parameter is missing in the substr() function call.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/translate-sql-string.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nsubstr(\"test\")\n```\n\n----------------------------------------\n\nTITLE: Testing arrange() with Column Replacement in dbplyr\nDESCRIPTION: Shows how ordering is handled when the ordered column is replaced with a constant value.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-arrange.md#2025-04-21_snippet_13\n\nLANGUAGE: R\nCODE:\n```\nlf %>% arrange(a) %>% mutate(a = 1) %>% arrange(b)\n```\n\n----------------------------------------\n\nTITLE: Printing SQL table output in R with dbplyr\nDESCRIPTION: Demonstrates how SQL table output is formatted when printing a dbplyr table object named 'mf2'. The output shows a table with 3 rows and 2 columns from an in-memory SQLite database.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/tbl-sql.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\nmf2\n```\n\n----------------------------------------\n\nTITLE: Testing Database Table Analysis Error\nDESCRIPTION: Tests error handling when attempting to analyze a non-existent table using ANALYZE SQL command.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/db-sql.md#2025-04-21_snippet_1\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(db_analyze(con, \"tbl\")))\n```\n\n----------------------------------------\n\nTITLE: Testing Data Frame Conversion of tbl_lazy - R\nDESCRIPTION: Shows error when attempting to convert a tbl_lazy object to a data.frame using as.data.frame()\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/tbl-lazy.md#2025-04-21_snippet_1\n\nLANGUAGE: r\nCODE:\n```\nas.data.frame(tbl_lazy(mtcars, con = simulate_sqlite()))\n```\n\n----------------------------------------\n\nTITLE: Testing across() with .by Argument\nDESCRIPTION: This snippet demonstrates that across() doesn't select columns specified in the .by argument of summarise().\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-summarise.md#2025-04-21_snippet_5\n\nLANGUAGE: R\nCODE:\n```\nout\n```\n\n----------------------------------------\n\nTITLE: Table Copy Failure in Tests\nDESCRIPTION: A test failure showing an error when attempting to copy data to a table that already exists. Both overwrite and append parameters are set to FALSE, causing the operation to fail.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/revdep/problems.md#2025-04-21_snippet_3\n\nLANGUAGE: r\nCODE:\n```\ntemporary = temporary, unique_indexes = unique_indexes, indexes = indexes, \nanalyze = analyze, in_transaction = in_transaction, ...)`:\nCan't copy data to table `SCDB_log_patch`.\nCaused by error in `dplyr::db_write_table()`:\n! Can't write table table `SCDB_log_patch`.\nCaused by error:\n! Table `SCDB_log_patch` exists in database, and both overwrite and append are FALSE\n```\n\n----------------------------------------\n\nTITLE: Vignette Rebuilding Error in basic-principles.Rmd\nDESCRIPTION: An error occurring when rebuilding the 'basic-principles.Rmd' vignette. The error appears to be related to an invalid environment argument when calling dbRemoveTable function.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/revdep/problems.md#2025-04-21_snippet_4\n\nLANGUAGE: r\nCODE:\n```\nError: processing vignette 'basic-principles.Rmd' failed with diagnostics:\nerror in evaluating the argument 'name' in selecting a method for function 'dbRemoveTable': invalid 'envir' argument of type 'character'\n```\n\n----------------------------------------\n\nTITLE: Testing win_rank Function Acceptance in SQL Translator\nDESCRIPTION: Demonstrates that the win_rank() function is properly accepted by the sql_translator when defining custom window functions.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/translate-sql-helpers.md#2025-04-21_snippet_3\n\nLANGUAGE: R\nCODE:\n```\nsql_variant(sql_translator(test = win_rank(\"test\")))\n```\n\n----------------------------------------\n\nTITLE: Basic Distinct SQL Generation with Limit\nDESCRIPTION: Shows how dbplyr optimizes a distinct operation after a head() call by using SELECT DISTINCT with a subquery containing LIMIT.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-distinct.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\n(out <- lf %>% head(2) %>% distinct(x, y))\n```\n\nLANGUAGE: sql\nCODE:\n```\nSELECT DISTINCT `q01`.*\nFROM (\n  SELECT `df`.*\n  FROM `df`\n  LIMIT 2\n) AS `q01`\n```\n\n----------------------------------------\n\nTITLE: Testing Basic Arithmetic Translation in R to SQL\nDESCRIPTION: Test case for integer division translation that shows error handling for unsupported SQL variant.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\ntest_translate_sql(100L %/% 3L)\n```\n\n----------------------------------------\n\nTITLE: Package Installation Error Block Format\nDESCRIPTION: Empty code block template used repeatedly to indicate installation errors for both development and CRAN versions of packages\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/revdep/failures.md#2025-04-21_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n\"\"\n```\n\n----------------------------------------\n\nTITLE: Example test execution error in Andromeda package\nDESCRIPTION: Error output from running examples in Andromeda package showing a failure in SQL translation and evaluation\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/revdep/problems.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nRunning examples in 'Andromeda-Ex.R' failed\nThe error most likely occurred in:\n\n> ### Name: groupApply\n> ### Title: Apply a function to groups of data in an Andromeda table\n> ### Aliases: groupApply\n> \n> ### ** Examples\n> \n> andr <- andromeda(cars = cars)\n```\n\n----------------------------------------\n\nTITLE: Styling SQL Output in R using dbplyr\nDESCRIPTION: This snippet shows how dbplyr styles the SQL output. It demonstrates the use of color coding and formatting for different SQL keywords and clauses in a complex query involving CTEs, window functions, and joins.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-select.md#2025-04-21_snippet_11\n\nLANGUAGE: R\nCODE:\n```\nshow_query(out, sql_options = sql_options(cte = TRUE))\n```\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL>\n[34mWITH[39m `q01` [34mAS[39m (\n  [34mSELECT[39m `x`, AVG(`y`) OVER (PARTITION BY `x`)[34m AS [39m`y`, `z` + 1.0[34m AS [39m`z`\n  [34mFROM[39m `df`\n),\n`q02` [34mAS[39m (\n  [34mSELECT[39m `q01`.*\n  [34mFROM[39m `q01`\n  [34mWHERE[39m (`z` = 1.0)\n)\n[34mSELECT[39m\n  `LHS`.`x`[34m AS [39m`x`,\n  `LHS`.`y`[34m AS [39m`y.x`,\n  `LHS`.`z`[34m AS [39m`z.x`,\n  `df`.`y`[34m AS [39m`y.y`,\n  `df`.`z`[34m AS [39m`z.y`\n[34mFROM[39m `q02`[34m AS [39m`LHS`\n[34mLEFT JOIN[39m `df`\n  [34mON[39m (`LHS`.`x` = `df`.`x`)\n```\n\n----------------------------------------\n\nTITLE: Error handling for missing columns in rows_update\nDESCRIPTION: Demonstrates error handling when by columns do not exist in the source or target tables.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/rows.md#2025-04-21_snippet_18\n\nLANGUAGE: R\nCODE:\n```\n(rows_update(lf, lf, by = \"z\", unmatched = \"ignore\"))\n```\n\n----------------------------------------\n\nTITLE: Dependency Check Status Report in Markdown\nDESCRIPTION: A markdown formatted report showing the results of dependency checks for the dbplyr package, listing packages with new errors in their examples, tests, and vignette rebuilding processes.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/revdep/cran.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n## revdepcheck results\n\nWe checked 112 reverse dependencies (101 from CRAN + 11 from Bioconductor), comparing R CMD check results across CRAN and dev versions of this package.\n\n * We saw 8 new problems\n * We failed to check 0 packages\n\nIssues with CRAN packages are summarised below.\n\n### New problems\n(This reports the first line of each new failure)\n\n* Andromeda\n  checking examples ... ERROR\n  checking tests ... ERROR\n  checking re-building of vignette outputs ... ERROR\n\n* CDMConnector\n  checking tests ... ERROR\n  checking re-building of vignette outputs ... ERROR\n\n* CohortSurvival\n  checking tests ... ERROR\n  checking re-building of vignette outputs ... ERROR\n\n* diseasystore\n  checking tests ... ERROR\n\n* DrugUtilisation\n  checking tests ... ERROR\n  checking re-building of vignette outputs ... ERROR\n\n* IncidencePrevalence\n  checking tests ... ERROR\n  checking re-building of vignette outputs ... ERROR\n\n* PatientProfiles\n  checking re-building of vignette outputs ... ERROR\n\n* SCDB\n  checking examples ... ERROR\n  checking tests ... ERROR\n  checking re-building of vignette outputs ... ERROR\n```\n\n----------------------------------------\n\nTITLE: Testing Schema Handling in Compute Function for R\nDESCRIPTION: This test checks the behavior of the `compute()` function when dealing with schemas. It attempts to create a table in a specific schema and expects a DBI error.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-compute.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\ndf %>% compute(name = in_schema(\"main\", \"db1\"), temporary = FALSE)\n```\n\n----------------------------------------\n\nTITLE: Testing window_order error handling with data frame input\nDESCRIPTION: Tests the error message when window_order() is incorrectly used with a data frame instead of a tbl_lazy object. The function suggests using arrange() as an alternative.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-window.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(window_order(data.frame(x = 1))))\n```\n\n----------------------------------------\n\nTITLE: Early return in rows_patch with no updatable columns\nDESCRIPTION: Shows that rows_patch returns early if there are no columns to update, simply returning the original table.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/rows.md#2025-04-21_snippet_26\n\nLANGUAGE: R\nCODE:\n```\nrows_patch(lazy_frame(x = 1:3, y = c(11, 12, NA), .name = \"df_x\"), lazy_frame(x = 1:3, .name = \"df_y\"), by = \"x\", unmatched = \"ignore\", in_place = FALSE)\n```\n\n----------------------------------------\n\nTITLE: Testing SQL Translation with Strict Mode for Unknown Functions\nDESCRIPTION: Tests how dbplyr handles unknown functions when strict SQL mode is enabled. The test demonstrates error messages generated when trying to translate an unknown function 'blah()' and an unknown operator '%blah%'.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/translate-sql.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\ntest_translate_sql(blah(x))\n```\n\nLANGUAGE: R\nCODE:\n```\ntest_translate_sql(x %blah% y)\n```\n\n----------------------------------------\n\nTITLE: Error Handling for Unsupported Arguments in case_when\nDESCRIPTION: Demonstrates error messages when using unsupported arguments (.ptype and .size) in case_when with dbplyr.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/translate-sql-conditional.md#2025-04-21_snippet_6\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(test_translate_sql(case_when(x == 1L ~ \"yes\", .ptype = character()))))\n```\n\nLANGUAGE: text\nCODE:\n```\n<error/dbplyr_error_unsupported_arg>\nError in `case_when()`:\n! Argument `.ptype` isn't supported on database backends.\n```\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(test_translate_sql(case_when(x == 1L ~ \"yes\", .size = 1))))\n```\n\nLANGUAGE: text\nCODE:\n```\n<error/dbplyr_error_unsupported_arg>\nError in `case_when()`:\n! Argument `.size` isn't supported on database backends.\n```\n\n----------------------------------------\n\nTITLE: Input Validation for copy_inline Function in R\nDESCRIPTION: This set of tests checks various error conditions for the copy_inline function. It includes cases for empty tibbles, lazy frames, mismatched column names, and incorrect type specifications.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-copy-to.md#2025-04-21_snippet_4\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(copy_inline(con, tibble())))\n```\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(copy_inline(con, lazy_frame(a = 1))))\n```\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(copy_inline(con, tibble(a = 1), types = c(b = \"bigint\"))))\n```\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(copy_inline(con, tibble(a = 1), types = c(b = 1))))\n```\n\n----------------------------------------\n\nTITLE: Inlining Rename and Relocate After Distinct in R using dbplyr\nDESCRIPTION: These snippets show how dbplyr inlines rename and relocate operations after a distinct operation, without creating a subquery. It renames 'y' to 'z' and relocates 'y' in separate examples.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-select.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\nlf %>% distinct() %>% rename(z = y)\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT DISTINCT `x`, `y` AS `z`\nFROM `df`\n```\n\nLANGUAGE: R\nCODE:\n```\nlf %>% distinct() %>% relocate(y)\n```\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT DISTINCT `y`, `x`\nFROM `df`\n```\n\n----------------------------------------\n\nTITLE: DDL Operations SQL Generation\nDESCRIPTION: Test cases for generating SQL DDL operations including ANALYZE, EXPLAIN, and INDEX creation.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-.md#2025-04-21_snippet_3\n\nLANGUAGE: R\nCODE:\n```\nsql_table_analyze(con, in_schema(\"schema\", \"tbl\"))\n```\n\nLANGUAGE: R\nCODE:\n```\nsql_query_explain(con, sql(\"SELECT * FROM foo\"))\n```\n\nLANGUAGE: R\nCODE:\n```\nsql_query_wrap(con, ident(\"table\"))\n```\n\nLANGUAGE: R\nCODE:\n```\nsql_table_index(con, in_schema(\"schema\", \"tbl\"), c(\"a\", \"b\"))\n```\n\nLANGUAGE: R\nCODE:\n```\nsql_table_index(con, in_schema(\"schema\", \"tbl\"), \"c\", unique = TRUE)\n```\n\nLANGUAGE: R\nCODE:\n```\nsql_query_save(con, sql(\"SELECT * FROM foo\"), in_schema(\"temp\", \"tbl\"))\n```\n\n----------------------------------------\n\nTITLE: Testing Output Format of sql_variant Print Method in dbplyr\nDESCRIPTION: Verifies the correct output format when printing a sql_variant object that contains multiple translators.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/translate-sql-helpers.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\nsql_variant(sim_trans, sim_trans, sim_trans)\n```\n\n----------------------------------------\n\nTITLE: Handling non-existent columns in returning parameter\nDESCRIPTION: Shows error handling when attempting to return columns that don't exist in the result set.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/rows.md#2025-04-21_snippet_4\n\nLANGUAGE: R\nCODE:\n```\n(df %>% rows_insert(df, by = \"x\", conflict = \"ignore\", returning = c(y)))\n```\n\n----------------------------------------\n\nTITLE: Testing SQL Translation of Namespace-Qualified Function Calls\nDESCRIPTION: Tests how dbplyr handles namespace-qualified function calls in SQL translation. Examples include non-existent package, non-existent function in a valid package, and valid function with no SQL translation.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/translate-sql.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\ntest_translate_sql(NOSUCHPACKAGE::foo())\n```\n\nLANGUAGE: R\nCODE:\n```\ntest_translate_sql(dbplyr::NOSUCHFUNCTION())\n```\n\nLANGUAGE: R\nCODE:\n```\ntest_translate_sql(base::abbreviate(x))\n```\n\n----------------------------------------\n\nTITLE: Handling Unsupported Full Join in MySQL/MariaDB\nDESCRIPTION: Shows the error handling when attempting to use a full join with MySQL, which is not supported by the database. The error message clearly indicates that MySQL does not support full joins.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-mysql.md#2025-04-21_snippet_3\n\nLANGUAGE: R\nCODE:\n```\nfull_join(lf, lf, by = \"x\")\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Unsupported .drop Argument in add_count for Database Backends\nDESCRIPTION: This snippet shows an error case where the .drop argument is used with add_count on a database backend, which is not supported. It demonstrates how dbplyr handles unsupported operations.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-count.md#2025-04-21_snippet_5\n\nLANGUAGE: R\nCODE:\n```\nlazy_frame(g = 1) %>% add_count(.drop = TRUE)\n```\n\n----------------------------------------\n\nTITLE: SQL Output for tidyr::expand with NULL inputs\nDESCRIPTION: The SQL translation of expand with NULL inputs, which returns the original data with DISTINCT.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-expand.md#2025-04-21_snippet_13\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL>\nSELECT DISTINCT `df`.*\nFROM `df`\n```\n\n----------------------------------------\n\nTITLE: Testing Label Size Error in cut() Function in R\nDESCRIPTION: Tests that cut() throws an appropriate error when the labels vector size doesn't match the number of breaks intervals. This verifies that the function checks for compatible vector sizes.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/translate-sql-cut.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(test_translate_sql(cut(x, 1:3, labels = c(\"a\", \"b\", \"c\")))))\n```\n\n----------------------------------------\n\nTITLE: Testing Row Count Display in dbplyr SQL Output (R)\nDESCRIPTION: This code snippet tests how dbplyr formats the header of SQL query results, particularly focusing on the display of row counts. It creates two test cases: one with a small dataset where the exact row count is shown, and another with a larger dataset where the row count is hidden.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/pillar.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\n# Number of rows is shown\nx <- memdb_frame(a = 1:3) %>% filter(a > 0)\nsetup <- pillar::tbl_format_setup(x)\ntbl_format_header(x, setup)[[1]]\n```\n\nLANGUAGE: R\nCODE:\n```\n# Number of rows still can't be shown\nx <- memdb_frame(a = 1:11) %>% filter(a > 0)\nsetup <- pillar::tbl_format_setup(x)\ntbl_format_header(x, setup)[[1]]\n```\n\n----------------------------------------\n\nTITLE: Testing date_count_between Year Precision Translation\nDESCRIPTION: Tests the translation of date_count_between() function with year precision parameter, which is not supported in database backends.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-spark-sql.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\ntest_translate_sql(date_count_between(date_column_1, date_column_2, \"year\"))\n```\n\n----------------------------------------\n\nTITLE: Error Handling for Missing Variables\nDESCRIPTION: Shows error message generation when attempting to group by a non-existent column.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-group_by.md#2025-04-21_snippet_2\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(lazy_frame(x = 1:3) %>% group_by(y)))\n```\n\n----------------------------------------\n\nTITLE: Testing Field Query Error\nDESCRIPTION: Tests error handling when attempting to query fields from a non-existent table.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/db-sql.md#2025-04-21_snippet_4\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(db_query_fields(con, \"does not exist\")))\n```\n\n----------------------------------------\n\nTITLE: Error handling for unmatched parameter in rows_update\nDESCRIPTION: Shows that 'unmatched = \"error\"' is not supported on database backends and must be 'ignore' instead.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/rows.md#2025-04-21_snippet_19\n\nLANGUAGE: R\nCODE:\n```\n(rows_update(lf, lf, by = \"x\", unmatched = \"error\"))\n```\n\nLANGUAGE: R\nCODE:\n```\n(rows_update(lf, lf, by = \"x\"))\n```\n\n----------------------------------------\n\nTITLE: Testing glue_sql Size Validation\nDESCRIPTION: Shows size validation in glue_sql2() where values must have exactly size 1. Tests with both size 2 and size 0 cases.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/build-sql.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\nglue_sql2(\"{.col x}\", .con = con)\nglue_sql2(\"{.col character()}\", .con = con)\n```\n\n----------------------------------------\n\nTITLE: Testing window_frame argument validation - string in from\nDESCRIPTION: Shows the error thrown when passing a string instead of a number to the 'from' parameter of window_frame().\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/translate-sql-window.md#2025-04-21_snippet_8\n\nLANGUAGE: R\nCODE:\n```\nwindow_frame(lf, \"a\")\n```\n\n----------------------------------------\n\nTITLE: Error Handling for Invalid values_fill Parameter in Pivot Wider\nDESCRIPTION: Tests error handling when an invalid values_fill parameter (a vector instead of a scalar or named list) is provided to the pivot_wider function.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-pivot-wider.md#2025-04-21_snippet_7\n\nLANGUAGE: r\nCODE:\n```\ndbplyr_pivot_wider_spec(lf, spec, values_fill = 1:2)\n```\n\n----------------------------------------\n\nTITLE: Testing error handling for conflict parameter with in_place=FALSE\nDESCRIPTION: Verifies that rows_insert produces an error when conflict='error' is combined with in_place=FALSE.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/rows.md#2025-04-21_snippet_5\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(rows_insert(lf, lf, by = \"x\", conflict = \"error\", in_place = FALSE)))\n```\n\n----------------------------------------\n\nTITLE: Error handling for rows_update with in_place=TRUE\nDESCRIPTION: Shows the error message when attempting to use rows_update with in_place=TRUE on simulated connections.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/rows.md#2025-04-21_snippet_24\n\nLANGUAGE: R\nCODE:\n```\n(rows_update(lazy_frame(x = 1:3, y = 11:13, .name = \"df_x\"), lazy_frame(x = 2:3, y = 22:23, .name = \"df_y\"), by = \"x\", unmatched = \"ignore\", in_place = TRUE))\n```\n\n----------------------------------------\n\nTITLE: Testing Index Failure for Missing Columns in R\nDESCRIPTION: This snippet tests the error handling of the `compute()` function when specified columns are missing from the indexes. It checks both regular and unique indexes.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-compute.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(compute(mf, indexes = list(c(\"y\", \"x\", \"z\"), \"a\"))))\n(expect_error(compute(mf, unique_indexes = list(c(\"y\", \"x\", \"z\"), \"a\"))))\n```\n\n----------------------------------------\n\nTITLE: Testing window_frame argument validation - string in to\nDESCRIPTION: Shows the error thrown when passing a string instead of a number to the 'to' parameter of window_frame().\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/translate-sql-window.md#2025-04-21_snippet_10\n\nLANGUAGE: R\nCODE:\n```\nwindow_frame(lf, 1, \"a\")\n```\n\n----------------------------------------\n\nTITLE: Demonstrating rows_delete() error with in_place=TRUE\nDESCRIPTION: Shows that rows_delete() with in_place=TRUE produces an error for simulated connections, consistent with other in-place operations. This further demonstrates the limitation in dbplyr's simulation capabilities.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/rows.md#2025-04-21_snippet_35\n\nLANGUAGE: R\nCODE:\n```\n(rows_delete(lazy_frame(x = 1:3, y = 11:13, .name = \"df_x\"), lazy_frame(x = 2:3,\n.name = \"df_y\"), by = \"x\", unmatched = \"ignore\", in_place = TRUE))\n```\n\n----------------------------------------\n\nTITLE: Argument validation in rows_update\nDESCRIPTION: Demonstrates error handling for invalid arguments in rows_update, such as non-character by parameter.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/rows.md#2025-04-21_snippet_16\n\nLANGUAGE: R\nCODE:\n```\n(rows_update(lf, lf, by = 1, unmatched = \"ignore\"))\n```\n\n----------------------------------------\n\nTITLE: Basic Slice Operations Unsupported Cases\nDESCRIPTION: Demonstrates that basic slice operations (slice, slice_head, slice_tail) are not supported on database backends, with suggestions to use slice_min/max instead.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-slice.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\nlf %>% slice()\nlf %>% slice_head()\nlf %>% slice_tail()\n```\n\n----------------------------------------\n\nTITLE: Testing NA Values in Breaks Error in cut() Function in R\nDESCRIPTION: Tests that cut() throws an error when the breaks contain NA values. The function requires all break points to be non-missing values.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/translate-sql-cut.md#2025-04-21_snippet_3\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(test_translate_sql(cut(x, c(1, 2, NA)))))\n```\n\n----------------------------------------\n\nTITLE: Testing window_frame argument validation - vector in to\nDESCRIPTION: Shows the error thrown when passing a vector instead of a single number to the 'to' parameter of window_frame().\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/translate-sql-window.md#2025-04-21_snippet_11\n\nLANGUAGE: R\nCODE:\n```\nwindow_frame(lf, 1, 1:2)\n```\n\n----------------------------------------\n\nTITLE: Testing Defunct vars Argument in partial_eval\nDESCRIPTION: Demonstrates error handling when using the deprecated vars argument in partial_eval() which was removed in dbplyr 2.1.2.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/tidyeval.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\npartial_eval(quote(x), vars = c(\"x\", \"y\"))\n```\n\n----------------------------------------\n\nTITLE: Error handling in sql_query_insert\nDESCRIPTION: Shows error handling for unsupported conflict parameter in sql_query_insert function.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/rows.md#2025-04-21_snippet_9\n\nLANGUAGE: R\nCODE:\n```\n(sql_query_insert(con = con, table = ident(\"df_x\"), from = sql_render(df_y, con, lvl = 1), insert_cols = colnames(df_y), by = c(\"a\", \"b\"), conflict = \"error\", returning_cols = c(\"a\", b2 = \"b\")))\n```\n\n----------------------------------------\n\nTITLE: Error handling for unsupported 'unmatched' parameter in left_join with dbplyr\nDESCRIPTION: Shows the error message when using the 'unmatched' parameter in left_join with a database backend. The error suggests using foreign keys as an alternative approach.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-joins.md#2025-04-21_snippet_19\n\nLANGUAGE: r\nCODE:\n```\nleft_join(lf, lf, by = \"x\", unmatched = \"error\")\n```\n\n----------------------------------------\n\nTITLE: Testing Invalid data Argument in partial_eval\nDESCRIPTION: Shows error handling when passing an invalid data argument to partial_eval(). As of dbplyr 2.1.2, the data argument must be a lazy frame.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/tidyeval.md#2025-04-21_snippet_1\n\nLANGUAGE: r\nCODE:\n```\npartial_eval(quote(x), data = c(\"x\", \"y\"))\n```\n\n----------------------------------------\n\nTITLE: Testing Error for Duplicate Translator Definitions in dbplyr\nDESCRIPTION: Shows how dbplyr handles duplicate function definitions in sql_translator by throwing an error that identifies the duplicate name.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/translate-sql-helpers.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\nsql_translator(round = function(x) x, round = function(y) y)\n```\n\n----------------------------------------\n\nTITLE: Testing window_order error handling with string input\nDESCRIPTION: Tests the error message when window_order() is incorrectly used with a string instead of a tbl_lazy object.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-window.md#2025-04-21_snippet_1\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(window_order(\"a\")))\n```\n\n----------------------------------------\n\nTITLE: Error Handling for Unsupported .preserve Parameter\nDESCRIPTION: Shows the error message when attempting to use the .preserve parameter with a database backend. This feature is not supported with dbplyr and must be set to FALSE.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-filter.md#2025-04-21_snippet_4\n\nLANGUAGE: r\nCODE:\n```\nlf %>% filter(x == 1, .preserve = TRUE)\n```\n\n----------------------------------------\n\nTITLE: Error testing for tidyr::fill() without window_order()\nDESCRIPTION: Demonstrates the error message when trying to use tidyr::fill() on a database frame without first specifying an ordering with window_order(). This is a safety check to ensure correct results.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-fill.md#2025-04-21_snippet_8\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(df_db %>% tidyr::fill(n1)))\n```\n\nLANGUAGE: error\nCODE:\n```\n<error/rlang_error>\nError in `tidyr::fill()`:\nx `.data` does not have explicit order.\ni Please use `dbplyr::window_order()` to make order explicit.\n```\n\n----------------------------------------\n\nTITLE: Testing Argument Checking in sql_prefix Functions\nDESCRIPTION: Shows how sql_prefix validates the number of arguments passed to a function, throwing an error when too many arguments are provided.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/translate-sql-helpers.md#2025-04-21_snippet_4\n\nLANGUAGE: R\nCODE:\n```\nsin_db(sin(1, 2))\n```\n\n----------------------------------------\n\nTITLE: Error handling for unsupported 'relationship' parameter in left_join with dbplyr\nDESCRIPTION: Demonstrates the error message when using a 'one-to-one' relationship in left_join with a database backend. The error indicates only 'many-to-many' or NULL are supported values.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-joins.md#2025-04-21_snippet_20\n\nLANGUAGE: r\nCODE:\n```\nleft_join(lf, lf, by = \"x\", relationship = \"one-to-one\")\n```\n\n----------------------------------------\n\nTITLE: Error condition for tidyr::expand without variables\nDESCRIPTION: The error message when tidyr::expand() is called without specifying variables.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-expand.md#2025-04-21_snippet_15\n\nLANGUAGE: R\nCODE:\n```\nError in `tidyr::expand()`:\n! Must supply variables in `...`\n```\n\n----------------------------------------\n\nTITLE: Generating SQL for left_join with NA matching in dbplyr\nDESCRIPTION: Demonstrates how SQL is generated when using 'na_matches = \"na\"' in a left_join operation. This uses 'IS NOT DISTINCT FROM' to properly handle NA value matching.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-joins.md#2025-04-21_snippet_21\n\nLANGUAGE: r\nCODE:\n```\nleft_join(lf1, lf2, by = \"x\", na_matches = \"na\")\n```\n\nLANGUAGE: sql\nCODE:\n```\nSELECT `lf1`.`x` AS `x`\nFROM `lf1`\nLEFT JOIN `lf2`\n  ON (`lf1`.`x` IS NOT DISTINCT FROM `lf2`.`x`)\n```\n\n----------------------------------------\n\nTITLE: Deprecated Cross Join Syntax in dbplyr\nDESCRIPTION: Shows that using by = character() for cross joins is deprecated in dbplyr 1.1.0 and should be replaced with cross_join(). Examples demonstrate the deprecation warning with inner_join and full_join.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-joins.md#2025-04-21_snippet_4\n\nLANGUAGE: R\nCODE:\n```\nout_inner <- collect(inner_join(df1, df2, by = character()))\n```\n\nLANGUAGE: R\nCODE:\n```\nout_full <- collect(full_join(df1, df2, by = character()))\n```\n\n----------------------------------------\n\nTITLE: Unsupported cols_vary Parameter in DBPlyr\nDESCRIPTION: Shows the error that occurs when attempting to use the cols_vary parameter, which is not supported in DBPlyr's implementation of pivot_longer. This parameter controls column ordering behavior which cannot be directly mapped to SQL operations.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-pivot-longer.md#2025-04-21_snippet_12\n\nLANGUAGE: r\nCODE:\n```\nlazy_frame(x = 1:2, y = 3:4) %>% tidyr::pivot_longer(x:y, cols_vary = \"fastest\")\n```\n\nLANGUAGE: error\nCODE:\n```\nError in `tidyr::pivot_longer()`:\n! Argument `cols_vary` isn't supported on database backends.\n```\n\n----------------------------------------\n\nTITLE: Testing runif Function Translation Restrictions in dbplyr\nDESCRIPTION: Shows the error thrown when trying to use runif() with an argument other than n() in SQL translation.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/translate-sql-helpers.md#2025-04-21_snippet_6\n\nLANGUAGE: R\nCODE:\n```\ntest_translate_sql(runif(2))\n```\n\n----------------------------------------\n\nTITLE: Error handling for unsupported 'multiple' parameter in left_join with dbplyr\nDESCRIPTION: Demonstrates the error message when using the 'multiple' parameter in left_join with a database backend. The error suggests using a unique index on join columns as an alternative.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-joins.md#2025-04-21_snippet_18\n\nLANGUAGE: r\nCODE:\n```\nleft_join(lf, lf, by = \"x\", multiple = \"first\")\n```\n\n----------------------------------------\n\nTITLE: Test failure trace from CDMConnector package\nDESCRIPTION: Error output showing database connection cleanup warnings and test execution failures\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/revdep/problems.md#2025-04-21_snippet_1\n\nLANGUAGE: R\nCODE:\n```\nRunning 'testthat.R'\nRunning the tests in 'tests/testthat.R' failed.\nComplete output:\n> # This file is part of the standard setup for testthat.\n> # It is recommended that you do not modify it.\n```\n\n----------------------------------------\n\nTITLE: Error condition for tidyr::expand with only NULL values\nDESCRIPTION: The error message when tidyr::expand() is called with only NULL values.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-expand.md#2025-04-21_snippet_17\n\nLANGUAGE: R\nCODE:\n```\nError in `tidyr::expand()`:\n! Must supply variables in `...`\n```\n\n----------------------------------------\n\nTITLE: Inlining select() Before Semi Join in dbplyr\nDESCRIPTION: Demonstrates how select() operations before semi_join are inlined in the SQL query. The SQL shows how column selections are incorporated directly in the semi-join operation, optimizing the query.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-joins.md#2025-04-21_snippet_7\n\nLANGUAGE: R\nCODE:\n```\nout_semi\n```\n\nLANGUAGE: SQL\nCODE:\n```\n<SQL>\nSELECT `a` AS `a2`, `x1` AS `x`\nFROM `lf1`\nWHERE EXISTS (\n  SELECT 1 FROM `lf2`\n  WHERE (`lf1`.`x1` = `lf2`.`x2`)\n)\n```\n\n----------------------------------------\n\nTITLE: Unsupported values_ptype Parameter in DBPlyr\nDESCRIPTION: Demonstrates the error that occurs when trying to use the values_ptype parameter, which is not supported on database backends. This limitation arises from the inability to directly control column types in the same way as in-memory data frames.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-pivot-longer.md#2025-04-21_snippet_11\n\nLANGUAGE: r\nCODE:\n```\nlazy_frame(x = 1:2, y = 3:4) %>% tidyr::pivot_longer(x:y, values_ptypes = character())\n```\n\nLANGUAGE: error\nCODE:\n```\nError in `tidyr::pivot_longer()`:\n! Argument `values_ptypes` isn't supported on database backends.\n```\n\n----------------------------------------\n\nTITLE: Validating values_transform Parameter in DBPlyr pivot_longer\nDESCRIPTION: Shows the validation errors that occur when values_transform is provided with incorrect arguments. The parameter must be NULL, a function, or a named list of functions to be valid.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-pivot-longer.md#2025-04-21_snippet_7\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(tidyr::pivot_longer(df, x, values_transform = 1)))\n```\n\nLANGUAGE: error\nCODE:\n```\n<error/rlang_error>\nError in `dbplyr_pivot_longer_spec()`:\n! `values_transform` must be `NULL`, a function, or a named list of functions.\n```\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(tidyr::pivot_longer(df, x, values_transform = list(~.x))))\n```\n\nLANGUAGE: error\nCODE:\n```\n<error/rlang_error>\nError in `dbplyr_pivot_longer_spec()`:\n! All elements of `values_transform` must be named.\n```\n\n----------------------------------------\n\nTITLE: Error handling with duplicate names in nesting\nDESCRIPTION: Shows the error when nesting() is called with duplicate column names.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-expand.md#2025-04-21_snippet_18\n\nLANGUAGE: R\nCODE:\n```\ntidyr::expand(memdb_frame(x = 1, y = 1), nesting(x, x = x + 1))\n```\n\n----------------------------------------\n\nTITLE: Testing window_order error handling with expressions\nDESCRIPTION: Tests the error message when window_order() is provided with an expression (x + y) instead of a simple column name or desc() wrapper.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-window.md#2025-04-21_snippet_2\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(window_order(lf, x + y)))\n```\n\n----------------------------------------\n\nTITLE: Error Handling for difftime() Translation to SQL\nDESCRIPTION: Shows error messages when attempting to use unsupported parameters with difftime() in SQL translation. Only 'days' units are supported, and timezone parameters are not allowed.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-oracle.md#2025-04-21_snippet_9\n\nLANGUAGE: R\nCODE:\n```\ntest_translate_sql(difftime(start_date, end_date, units = \"auto\"))\n```\n\nLANGUAGE: text\nCODE:\n```\nCondition\n  Error in `difftime()`:\n  ! The only supported value for `units` on SQL backends is \"days\"\n```\n\nLANGUAGE: R\nCODE:\n```\ntest_translate_sql(difftime(start_date, end_date, tz = \"UTC\", units = \"days\"))\n```\n\nLANGUAGE: text\nCODE:\n```\nCondition\n  Error in `difftime()`:\n  ! The `tz` argument is not supported for SQL backends.\n```\n\n----------------------------------------\n\nTITLE: Handling Non-Data Frame Results in dplyr do() Function\nDESCRIPTION: Example showing that do() requires results to be data frames, not atomic values. When attempting to return just the row count (nrow(.)) without wrapping it in a data frame, dplyr raises an error.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-do.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\nmf %>% do(nrow(.))\n```\n\n----------------------------------------\n\nTITLE: Error condition for duplicate names in nesting\nDESCRIPTION: The error message when nesting() contains duplicate column names.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-expand.md#2025-04-21_snippet_19\n\nLANGUAGE: R\nCODE:\n```\nError in `tidyr::expand()`:\n! In expression `nesting(x, x = x + 1)`:\nCaused by error:\n! Names must be unique.\nx These names are duplicated:\n  * \"x\" at locations 1 and 2.\n```\n\n----------------------------------------\n\nTITLE: Testing Insufficient Breaks Error in cut() Function in R\nDESCRIPTION: Tests that cut() throws an error when provided with fewer than two break values. The function requires at least two break points to create intervals.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/translate-sql-cut.md#2025-04-21_snippet_1\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(test_translate_sql(cut(x, 1))))\n```\n\n----------------------------------------\n\nTITLE: Error Handling for Outdated do() Syntax in dplyr\nDESCRIPTION: Example demonstrating that older syntax patterns from dplyr versions before 0.2 are no longer supported. Attempting to pass a function reference with a named parameter (.f = nrow) produces an error.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-do.md#2025-04-21_snippet_3\n\nLANGUAGE: r\nCODE:\n```\nmf %>% do(.f = nrow)\n```\n\n----------------------------------------\n\nTITLE: Testing names() Method Warning - R\nDESCRIPTION: Shows warning message when using names() on a tbl_lazy object, suggesting to use colnames() instead\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/tbl-lazy.md#2025-04-21_snippet_3\n\nLANGUAGE: r\nCODE:\n```\nnames(lazy_frame(x = 1))\n```\n\n----------------------------------------\n\nTITLE: Testing window_frame argument validation - vector in from\nDESCRIPTION: Shows the error thrown when passing a vector instead of a single number to the 'from' parameter of window_frame().\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/translate-sql-window.md#2025-04-21_snippet_9\n\nLANGUAGE: R\nCODE:\n```\nwindow_frame(lf, 1:2)\n```\n\n----------------------------------------\n\nTITLE: Testing Query Saving Error\nDESCRIPTION: Tests error handling when attempting to save an invalid SQL query to a temporary table.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/db-sql.md#2025-04-21_snippet_5\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(db_save_query(con, \"invalid sql\", \"tbl\")))\n```\n\n----------------------------------------\n\nTITLE: Implementing row_number() Without Ordering\nDESCRIPTION: Shows how row_number() is implemented in SQL without explicit ordering.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-teradata.md#2025-04-21_snippet_5\n\nLANGUAGE: R\nCODE:\n```\nmf %>% mutate(rown = row_number())\n```\n\n----------------------------------------\n\nTITLE: Testing pull() with non-existent name parameter in dbplyr\nDESCRIPTION: Tests the error message when trying to use a non-existent column as the name parameter in the pull() function. The test creates a database frame with column 'x' and attempts to use 'name_non_existent' as the name parameter, which doesn't exist.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-pull.md#2025-04-21_snippet_3\n\nLANGUAGE: r\nCODE:\n```\nmemdb_frame(x = 1) %>% pull(x, \"name_non_existent\")\n```\n\n----------------------------------------\n\nTITLE: Handling Empty select() in dbplyr\nDESCRIPTION: This snippet tests the error handling of dbplyr when an empty select() operation is performed on a lazy frame. It expects an error to be thrown indicating that the query contains no columns.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/query-select.md#2025-04-21_snippet_2\n\nLANGUAGE: R\nCODE:\n```\nlazy_frame(x = 1, y = 1) %>% select()\n```\n\n----------------------------------------\n\nTITLE: Error handling in tidyr::expand\nDESCRIPTION: Demonstrates error conditions when tidyr::expand() is used incorrectly, such as without specifying variables.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-expand.md#2025-04-21_snippet_14\n\nLANGUAGE: R\nCODE:\n```\ntidyr::expand(memdb_frame(x = 1))\n```\n\n----------------------------------------\n\nTITLE: Demonstrating rows_patch() error with in_place=TRUE\nDESCRIPTION: Shows that rows_patch() with in_place=TRUE produces an error for simulated connections. This demonstrates a limitation of dbplyr's simulation capabilities for direct database modifications.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/rows.md#2025-04-21_snippet_29\n\nLANGUAGE: R\nCODE:\n```\n(rows_patch(lazy_frame(x = 1:3, y = 11:13, .name = \"df_x\"), lazy_frame(x = 2:3,\ny = 22:23, .name = \"df_y\"), by = \"x\", unmatched = \"ignore\", in_place = TRUE))\n```\n\n----------------------------------------\n\nTITLE: Testing substr() Function with Invalid Stop Parameter Type in R\nDESCRIPTION: This test case verifies the error handling when the 'stop' parameter is a string instead of a number in the substr() function call.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/translate-sql-string.md#2025-04-21_snippet_3\n\nLANGUAGE: R\nCODE:\n```\nsubstr(\"test\", 1, \"x\")\n```\n\n----------------------------------------\n\nTITLE: Creating and Displaying a Table Path in R\nDESCRIPTION: Creates a table_path object from a character vector of path components and displays its representation. This demonstrates how table_path objects are formatted when printed.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/table-name.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\nname <- table_path(c(\"x\", \"y\", \"z\"))\nname\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Type Checking Error for Table Path in R\nDESCRIPTION: Shows the error message when a function expecting a table_path object receives a string instead. This illustrates the type checking mechanism in dbplyr's internal functions.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/table-name.md#2025-04-21_snippet_1\n\nLANGUAGE: r\nCODE:\n```\nfoo(1)\n```\n\n----------------------------------------\n\nTITLE: Error Handling for Unsupported .ptype in case_match\nDESCRIPTION: Demonstrates the error message when using the unsupported .ptype argument with case_match in dbplyr.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/translate-sql-conditional.md#2025-04-21_snippet_11\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(test_translate_sql(case_match(x, 1 ~ 1, .ptype = integer()))))\n```\n\nLANGUAGE: text\nCODE:\n```\n<error/dbplyr_error_unsupported_arg>\nError in `case_match()`:\n! Argument `.ptype` isn't supported on database backends.\n```\n\n----------------------------------------\n\nTITLE: Testing window_frame error handling with data frame input\nDESCRIPTION: Tests the error message when window_frame() is incorrectly used with a data frame instead of a tbl_lazy object.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-window.md#2025-04-21_snippet_5\n\nLANGUAGE: r\nCODE:\n```\n(expect_error(window_frame(data.frame(x = 1))))\n```\n\n----------------------------------------\n\nTITLE: Error Handling for Non-Symbol .x in case_match\nDESCRIPTION: Shows the error message when trying to use a literal value instead of a variable name as the first argument to case_match.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/translate-sql-conditional.md#2025-04-21_snippet_12\n\nLANGUAGE: R\nCODE:\n```\n(expect_error(test_translate_sql(case_match(1, 1 ~ 1))))\n```\n\nLANGUAGE: text\nCODE:\n```\n<error/rlang_error>\nError in `case_match()`:\n! `.x` must be a variable or function call, not a number.\n```\n\n----------------------------------------\n\nTITLE: Unsupported Where Function in Select with R using dbplyr\nDESCRIPTION: This snippet shows that the 'where()' function is not supported in dbplyr's select operation. It demonstrates the error message when attempting to use 'where()' with a predicate.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-select.md#2025-04-21_snippet_7\n\nLANGUAGE: R\nCODE:\n```\nlf %>% select(where(is.integer))\n```\n\n----------------------------------------\n\nTITLE: Testing pick() Function Error Handling\nDESCRIPTION: Shows error handling for pick() function when used with non-existent columns and invalid renaming\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/tidyeval-across.md#2025-04-21_snippet_3\n\nLANGUAGE: R\nCODE:\n```\narrange(df, pick(y))\n\narrange(lazy_frame(x = 1), pick(y = x))\n```\n\n----------------------------------------\n\nTITLE: Testing copy_to Function with Invalid Input in R\nDESCRIPTION: This snippet tests the copy_to function with an invalid input (a list instead of a dataframe). It expects an error message indicating that the input must be a local dataframe or remote tbl_sql.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/verb-copy-to.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\ncopy_to(con, list(x = 1), name = \"df\")\n```\n\n----------------------------------------\n\nTITLE: Error Handling for NULL Connection in dbplyr\nDESCRIPTION: Shows error messages when attempting to use SQL escaping functions without providing a database connection. Both escape() and sql_vector() functions require a non-NULL connection object.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/escape.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\nescape(\"a\")\n```\n\nLANGUAGE: r\nCODE:\n```\nsql_vector(\"a\")\n```\n\n----------------------------------------\n\nTITLE: Empty SQL Statement Generation in R\nDESCRIPTION: Demonstrates creating an empty SQL statement using the sql() function without any parameters.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/sql.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\nsql()\n```\n\n----------------------------------------\n\nTITLE: Testing Error Handling for paste() with collapse Parameter in dbplyr\nDESCRIPTION: Tests the translation of paste() with collapse parameter in dbplyr, which should throw an error suggesting to use str_flatten() instead, as collapse is not supported in database translations.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/backend-access.md#2025-04-21_snippet_0\n\nLANGUAGE: R\nCODE:\n```\ntest_translate_sql(paste(x, collapse = \"-\"))\n```\n\n----------------------------------------\n\nTITLE: Testing dbplyr Version Warning\nDESCRIPTION: Tests the warning message when using an old dbplyr interface, expecting a db_method error.\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/db-sql.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\nexpect_error(dbplyr_analyze(con), \"db_method\")\n```\n\n----------------------------------------\n\nTITLE: Testing Deprecated src Argument in tbl_lazy - R\nDESCRIPTION: Demonstrates error handling when using the deprecated src argument in tbl_lazy function with simulate_sqlite()\nSOURCE: https://github.com/tidyverse/dbplyr/blob/main/tests/testthat/_snaps/tbl-lazy.md#2025-04-21_snippet_0\n\nLANGUAGE: r\nCODE:\n```\ntbl_lazy(mtcars, src = simulate_sqlite())\n```"
  }
]