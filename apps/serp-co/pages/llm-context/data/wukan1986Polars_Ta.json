[
  {
    "owner": "wukan1986",
    "repo": "polars_ta",
    "content": "TITLE: Calculating Kaufman Adaptive Moving Average (KAMA) in Python using Polars\nDESCRIPTION: Implements Kaufman Adaptive Moving Average, which dynamically adjusts smoothing based on market volatility. It uses an efficiency ratio to determine the optimal smoothing factor and responds quickly to price changes while filtering noise.\nSOURCE: https://github.com/wukan1986/polars_ta/blob/main/docs/tdx/moving_average.md#_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\ndef kama(close: pl.Expr, length: int, fast: int = 2, slow: int = 30) -> pl.Expr:\n    \"\"\"\n    Kaufman Adaptive Moving Average\n\n    Parameters\n    ----------\n    close: pl.Expr\n        Source\n    length: int\n        Length\n    fast: int\n        Fast EMA period\n    slow: int\n        Slow EMA period\n    \"\"\"\n    return close.map_batches(\n        lambda s: _kama_core(s.to_numpy(), length, fast, slow),\n        return_dtype=pl.Float64,\n    )\n```\n\n----------------------------------------\n\nTITLE: Calculating Simple Moving Average (SMA) in Python using Polars\nDESCRIPTION: Calculates a simple moving average (SMA) of a column in a Polars DataFrame over a specified window. The function handles missing values and returns a Series with the same length as the input.\nSOURCE: https://github.com/wukan1986/polars_ta/blob/main/docs/tdx/moving_average.md#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\ndef sma(close: pl.Expr, length: int) -> pl.Expr:\n    \"\"\"\n    Simple Moving Average\n\n    Parameters\n    ----------\n    close: pl.Expr\n        Source\n    length: int\n        Length\n    \"\"\"\n    return pl.moving_average(close, window_size=length)\n```\n\n----------------------------------------\n\nTITLE: Calculating Hull Moving Average (HMA) in Python using Polars\nDESCRIPTION: Implements Hull Moving Average calculation, which is designed to reduce lag compared to traditional moving averages. It uses a weighted formula based on multiple WMA calculations with different periods.\nSOURCE: https://github.com/wukan1986/polars_ta/blob/main/docs/tdx/moving_average.md#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\ndef hma(close: pl.Expr, length: int) -> pl.Expr:\n    \"\"\"\n    Hull Moving Average\n\n    HMA = WMA(2*WMA(n/2) - WMA(n)), sqrt(n))\n\n    Parameters\n    ----------\n    close: pl.Expr\n        Source\n    length: int\n        Length\n    \"\"\"\n    length_half = length // 2\n    length_sqrt = int(length ** 0.5)\n    return WMA(2 * WMA(close, length_half) - WMA(close, length), length_sqrt)\n```\n\n----------------------------------------\n\nTITLE: Calculating Jurik Moving Average (JMA) in Python using Polars\nDESCRIPTION: Implements Jurik Moving Average, a complex smoothing algorithm designed by Mark Jurik. It uses parameterized filters to achieve superior smoothing with minimal lag compared to traditional moving averages.\nSOURCE: https://github.com/wukan1986/polars_ta/blob/main/docs/tdx/moving_average.md#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\ndef jma(close: pl.Expr, length: int, power: float = 2) -> pl.Expr:\n    \"\"\"\n    Jurik Moving Average\n\n    :ref: https://www.prorealcode.com/prorealtime-indicators/jurik-moving-average/\n\n    Parameters\n    ----------\n    close: pl.Expr\n        Source\n    length: int\n        Length\n    power: float\n        Power/Phase\n    \"\"\"\n    # function to compute beta\n    def beta_cal(p_length, p_phase):\n        beta = 0.45 * (p_length - 1) / (0.45 * (p_length - 1) + 2)\n        alpha = p_phase\n        alpha = (alpha < -100) and -100 or alpha\n        alpha = (alpha > 100) and 100 or alpha\n        alpha = 2 / (2 + alpha / 100)\n        return beta, alpha\n\n    return close.map_batches(\n        lambda s: _jma_core(s.to_numpy(), length, power),\n        return_dtype=pl.Float64,\n    )\n```\n\n----------------------------------------\n\nTITLE: Calculating Triple Exponential Moving Average (TEMA) in Python using Polars\nDESCRIPTION: Implements Triple Exponential Moving Average (TEMA) which applies EMA three times to reduce lag. It uses a specific formula that combines the three EMAs to eliminate overshooting in the smoothing process.\nSOURCE: https://github.com/wukan1986/polars_ta/blob/main/docs/tdx/moving_average.md#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\ndef tema(close: pl.Expr, length: int) -> pl.Expr:\n    \"\"\"\n    Triple Exponential Moving Average\n\n    TEMA = 3 * EMA1 - 3 * EMA2 + EMA3\n    where:\n    EMA1 = EMA(Source, Length)\n    EMA2 = EMA(EMA1, Length)\n    EMA3 = EMA(EMA2, Length)\n\n    Parameters\n    ----------\n    close: pl.Expr\n        Source\n    length: int\n        Length\n    \"\"\"\n    from polars_ta.util.math import EMA\n\n    ema1 = EMA(close, length)\n    ema2 = EMA(ema1, length)\n    ema3 = EMA(ema2, length)\n    return 3 * ema1 - 3 * ema2 + ema3\n```\n\n----------------------------------------\n\nTITLE: Calculating Double Moving Average (DMA) in Python using Polars\nDESCRIPTION: Implements a Double Moving Average calculation by applying SMA twice to a time series data column. It takes both a primary and optional secondary length parameter for the two smoothing operations.\nSOURCE: https://github.com/wukan1986/polars_ta/blob/main/docs/tdx/moving_average.md#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\ndef dma(close: pl.Expr, length1: int, length2: Optional[int] = None) -> pl.Expr:\n    \"\"\"\n    Double Moving Average\n\n    Parameters\n    ----------\n    close: pl.Expr\n        Source\n    length1: int\n        Length 1\n    length2: Optional[int]\n        Length 2\n    \"\"\"\n    if length2 is None:\n        length2 = length1\n\n    return sma(sma(close, length1), length2)\n```\n\n----------------------------------------\n\nTITLE: Calculating Moving Average using Polars in Python\nDESCRIPTION: This snippet demonstrates how to compute a moving average of a specified column in a Polars DataFrame. It requires the 'polars' library and a loaded DataFrame with numerical data. The function outputs a new column containing the moving average over a defined window, useful for technical indicators.\nSOURCE: https://github.com/wukan1986/polars_ta/blob/main/docs/tdx/logical.md#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\ndef calculate_moving_average(df, column_name, window_size):\n    return df.with_columns(\n        pl.col(column_name).rolling_mean(window_size).alias(f\"{column_name}_ma\")\n    )\n```\n\n----------------------------------------\n\nTITLE: Implementing Volume Analysis in Polars DataFrame\nDESCRIPTION: This code snippet implements volume analysis functions using Polars DataFrame. It calculates technical indicators related to volume, aiding in identifying trading signals. Dependencies include 'polars' and 'polars_ta' libraries. Inputs are Polars DataFrames with volume data, and outputs are computed indicator values used for analysis.\nSOURCE: https://github.com/wukan1986/polars_ta/blob/main/docs/tdx/volume.md#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n::: polars_ta.tdx.volume\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Indicators in Polars for Technical Analysis\nDESCRIPTION: This code creates a custom technical indicator by combining existing columns to generate a new metric within a Polars DataFrame. It requires prior data loading and calculations. The new indicator helps in identifying trading signals or market conditions.\nSOURCE: https://github.com/wukan1986/polars_ta/blob/main/docs/tdx/logical.md#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\ndef create_custom_indicator(df):\n    return df.with_columns(\n        (pl.col(\"high\") - pl.col(\"low\")).alias(\"high_low_range\")\n    )\n```\n\n----------------------------------------\n\nTITLE: Initializing DataFrame for Technical Analysis with Polars\nDESCRIPTION: This code snippet sets up a Polars DataFrame for technical analysis, including loading data, setting parameters, and preparing for further operations. It depends on the 'polars' library and expects input data in a suitable format, often a CSV or similar dataset. The snippet initializes variables and prepares the dataframe for subsequent analysis tasks.\nSOURCE: https://github.com/wukan1986/polars_ta/blob/main/docs/tdx/logical.md#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nimport polars as pl\n\ndef initialize_dataframe(data_path):\n    df = pl.read_csv(data_path)\n    df = df.with_columns([\n        (pl.col(\"close\") - pl.col(\"open\")).alias(\"diff\")\n    ])\n    return df\n```\n\n----------------------------------------\n\nTITLE: Filtering DataFrame Rows Based on Conditions in Polars\nDESCRIPTION: This snippet filters rows in a Polars DataFrame that meet specific conditions, such as volume greater than a threshold and price above a certain value. It requires a loaded DataFrame and parameters to set the filtering criteria. This operation isolates relevant data points for analysis.\nSOURCE: https://github.com/wukan1986/polars_ta/blob/main/docs/tdx/logical.md#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\ndef filter_data(df, volume_threshold, price_threshold):\n    return df.filter(\n        (pl.col(\"volume\") > volume_threshold) &\n        (pl.col(\"close\") > price_threshold)\n    )\n```\n\n----------------------------------------\n\nTITLE: Comparing None and NaN Equality in Python\nDESCRIPTION: Demonstrates the fundamental difference in equality comparison between Python's `None` object and NumPy's `np.nan`. `None == None` evaluates to `True` (though the idiomatic check is `None is None`), whereas `np.nan == np.nan` evaluates to `False` due to the nature of NaN. This illustrates the need for specific functions like `is_null` or `is_nan` when checking for missing values in data analysis libraries. Requires the `numpy` library to be imported as `np`.\nSOURCE: https://github.com/wukan1986/polars_ta/blob/main/nan_to_null.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\n\nNone == None  # True # (It should be `None is None`)\nnp.nan == np.nan  # False\n```\n\n----------------------------------------\n\nTITLE: Python Package Dependencies for polars_ta Project\nDESCRIPTION: This code snippet lists the required Python packages for the polars_ta project. It specifies Polars 1.26.0 or newer as the primary dependency, along with polars-ols, numpy, numba, and pandas packages.\nSOURCE: https://github.com/wukan1986/polars_ta/blob/main/requirements.txt#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\npolars>=1.26.0\npolars-ols>=0.3.0\nnumpy\nnumba\npandas\n```\n\n----------------------------------------\n\nTITLE: Documentation Dependencies for polars_ta Project\nDESCRIPTION: A list of required packages for generating project documentation. Includes MkDocs core, Python API documentation via mkdocstrings, material theme for MkDocs, and an LLM extension.\nSOURCE: https://github.com/wukan1986/polars_ta/blob/main/requirements-docs.txt#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nmkdocs\nmkdocstrings[python]\nmkdocs-material\nmkdocs-llmstxt\n```"
  }
]