[
  {
    "owner": "hinthornw",
    "repo": "trustcall",
    "content": "TITLE: Using trustcall to Extract Complex Schema Reliably\nDESCRIPTION: This snippet demonstrates how to use the trustcall library to successfully extract complex nested schema information from a conversation, handling validation errors through JSON patching.\nSOURCE: https://github.com/hinthornw/trustcall/blob/main/README.md#2025-04-18_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom trustcall import create_extractor\n\nbound = create_extractor(\n    llm,\n    tools=[TelegramAndTrustFallPreferences],\n    tool_choice=\"TelegramAndTrustFallPreferences\",\n)\n\nresult = bound.invoke(\n    f\"\"\"Extract the preferences from the following conversation:\n<convo>\n{conversation}\n</convo>\"\"\"\n)\nresult[\"responses\"][0]\n```\n\n----------------------------------------\n\nTITLE: Implementing LangChain Graph with Trustcall\nDESCRIPTION: Demonstrates setting up a LangChain graph using Fireworks LLM model with trustcall extractor for handling user interactions and tool execution.\nSOURCE: https://github.com/hinthornw/trustcall/blob/main/README.md#2025-04-18_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport operator\nfrom datetime import datetime\nfrom typing import List\n\nimport pytz\nfrom langchain_fireworks import ChatFireworks\nfrom langgraph.checkpoint.memory import MemorySaver\nfrom langgraph.graph import START, StateGraph\nfrom langgraph.prebuilt import ToolNode, tools_condition\nfrom pydantic.v1 import BaseModel, Field, validator\nfrom trustcall import create_extractor\nfrom typing_extensions import Annotated, TypedDict\n\n\nllm = ChatFireworks(model=\"accounts/fireworks/models/firefunction-v2\")\n\n\ndef save_user_information(preferences: Preferences):\n    \"\"\"Save user information to a database.\"\"\"\n    return \"User information saved\"\n\n\ndef lookup_time(tz: str) -> str:\n    \"\"\"Lookup the current time in a given timezone.\"\"\"\n    try:\n        # Convert the timezone string to a timezone object\n        timezone = pytz.timezone(tz)\n        # Get the current time in the given timezone\n        tm = datetime.now(timezone)\n        return f\"The current time in {tz} is {tm.strftime('%H:%M:%S')}\"\n    except pytz.UnknownTimeZoneError:\n        return f\"Unknown timezone: {tz}\"\n\n\nagent = create_extractor(llm, tools=[save_user_information, lookup_time])\n\n\nclass State(TypedDict):\n    messages: Annotated[list, operator.add]\n\n\nbuilder = StateGraph(State)\nbuilder.add_node(\"agent\", agent)\nbuilder.add_node(\"tools\", ToolNode([save_user_information, lookup_time]))\nbuilder.add_edge(\"tools\", \"agent\")\nbuilder.add_edge(START, \"agent\")\nbuilder.add_conditional_edges(\"agent\", tools_condition)\n\ngraph = builder.compile(checkpointer=MemorySaver())\nconfig = {\"configurable\": {\"thread_id\": \"1234\"}}\nres = graph.invoke({\"messages\": [(\"user\", \"Hi there!\")]}, config)\nres[\"messages\"][-1].pretty_print()\nres = graph.invoke(\n    {\"messages\": [(\"user\", \"Curious; what's the time in denver right now?\")]}, config\n)\nres[\"messages\"][-1].pretty_print()\nres = graph.invoke(\n    {\n        \"messages\": [\n            (\"user\", \"Did you know my favorite foods are spinach and potatoes?\")\n        ]\n    },\n    config,\n)\nres[\"messages\"][-1].pretty_print()\n```\n\n----------------------------------------\n\nTITLE: Defining User Profile Schema with Pydantic Models in Python\nDESCRIPTION: Creates a structured schema for user profiles using Pydantic models. Includes nested models for address, pets, hobbies, and media preferences with type hints and optional fields.\nSOURCE: https://github.com/hinthornw/trustcall/blob/main/README.md#2025-04-18_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Dict, List, Optional\n\nfrom pydantic import BaseModel\n\n\nclass Address(BaseModel):\n    street: str\n    city: str\n    country: str\n    postal_code: str\n\n\nclass Pet(BaseModel):\n    kind: str\n    name: Optional[str]\n    age: Optional[int]\n\n\nclass Hobby(BaseModel):\n    name: str\n    skill_level: str\n    frequency: str\n\n\nclass FavoriteMedia(BaseModel):\n    shows: List[str]\n    movies: List[str]\n    books: List[str]\n\n\nclass User(BaseModel):\n    preferred_name: str\n    favorite_media: FavoriteMedia\n    favorite_foods: List[str]\n    hobbies: List[Hobby]\n    age: int\n    occupation: str\n    address: Address\n    favorite_color: Optional[str] = None\n    pets: Optional[List[Pet]] = None\n    languages: Dict[str, str] = {}\n```\n\n----------------------------------------\n\nTITLE: Updating User Profile Using LLM with Naive Approach\nDESCRIPTION: Demonstrates a naive approach to updating user profile information using an LLM bound to the User model structure. Shows potential issues with information loss during updates.\nSOURCE: https://github.com/hinthornw/trustcall/blob/main/README.md#2025-04-18_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nbound = llm.with_structured_output(User)\nnaive_result = bound.invoke(\n    f\"\"\"Update the memory (JSON doc) to incorporate new information from the following conversation:\n<user_info>\n{initial_user.model_dump()}\n</user_info>\n<convo>\n{conversation}\n</convo>\"\"\"\n)\nprint(\"Naive approach result:\")\nnaive_output = naive_result.model_dump()\nprint(naive_output)\n```\n\n----------------------------------------\n\nTITLE: Extracting Complex Schema with Standard LLM Approach\nDESCRIPTION: This snippet demonstrates a naive approach to extract complex nested JSON schema using gpt-4o, which results in validation errors due to incomplete schema generation.\nSOURCE: https://github.com/hinthornw/trustcall/blob/main/README.md#2025-04-18_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom langchain_openai import ChatOpenAI\n\nllm = ChatOpenAI(model=\"gpt-4o\")\nbound = llm.with_structured_output(TelegramAndTrustFallPreferences)\n\nconversation = \"\"\"Operator: How may I assist with your telegram, sir?\nCustomer: I need to send a message about our trust fall exercise.\nOperator: Certainly. Morse code or standard encoding?\nCustomer: Morse, please. I love using a straight key.\nOperator: Excellent. What's your message?\nCustomer: Tell him I'm ready for a higher fall, and I prefer the diamond formation for catching.\nOperator: Done. Shall I use our \"Daredevil\" paper for this daring message?\nCustomer: Perfect! Send it by your fastest carrier pigeon.\nOperator: It'll be there within the hour, sir.\"\"\"\n\nbound.invoke(f\"\"\"Extract the preferences from the following conversation:\n<convo>\n{conversation}\n</convo>\"\"\")\n```\n\n----------------------------------------\n\nTITLE: Attempting Strict Mode JSON Extraction with OpenAI\nDESCRIPTION: This snippet shows attempting to use strict mode with OpenAI's bind_tools method, which also fails because OpenAI's parser doesn't support complex JSON schemas.\nSOURCE: https://github.com/hinthornw/trustcall/blob/main/README.md#2025-04-18_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nbound = llm.bind_tools([TelegramAndTrustFallPreferences], strict=True, response_format=TelegramAndTrustFallPreferences)\n\nbound.invoke(f\"\"\"Extract the preferences from the following conversation:\n<convo>\n{conversation}\n</convo>\"\"\")\n```\n\n----------------------------------------\n\nTITLE: Defining Preferences Schema with Pydantic\nDESCRIPTION: Creates a Pydantic model for user food preferences with validation to ensure at least 3 foods are specified.\nSOURCE: https://github.com/hinthornw/trustcall/blob/main/README.md#2025-04-18_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nclass Preferences(BaseModel):\n    foods: List[str] = Field(description=\"Favorite foods\")\n\n    @validator(\"foods\")\n    def at_least_three_foods(cls, v):\n        if len(v) < 3:\n            raise ValueError(\"Must have at least three favorite foods\")\n        return v\n```"
  }
]