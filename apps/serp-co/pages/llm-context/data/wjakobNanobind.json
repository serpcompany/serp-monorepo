[
  {
    "owner": "wjakob",
    "repo": "nanobind",
    "content": "TITLE: Basic Function Binding in C++ with nanobind\nDESCRIPTION: Demonstrates how to create a simple Python extension that binds a C++ function to add two numbers. Includes the necessary nanobind header and module declaration.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/basics.rst#2025-04-17_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n#include <nanobind/nanobind.h>\n\nint add(int a, int b) { return a + b; }\n\nNB_MODULE(my_ext, m) {\n    m.def(\"add\", &add);\n}\n```\n\n----------------------------------------\n\nTITLE: Class Construction with Default Constructor Example in C++\nDESCRIPTION: Example of binding a C++ class 'A' with a method 'f' to Python using nanobind. Shows how to bind the default constructor and a class method.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_13\n\nLANGUAGE: cpp\nCODE:\n```\nstruct A {\n    void f() { /*...*/ }\n};\n\nnb::class_<A>(m, \"A\")\n    .def(nb::init<>()) // Bind the default constructor\n    .def(\"f\", &A::f);  // Bind the method A::f\n```\n\n----------------------------------------\n\nTITLE: Binding a C++ Class with a Trampoline for Python Overriding using nanobind\nDESCRIPTION: This snippet shows how to bind a C++ class with its trampoline to allow overriding of virtual functions in Python. The trampoline class is specified as a template parameter in the class_ constructor.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/classes.rst#2025-04-17_snippet_10\n\nLANGUAGE: cpp\nCODE:\n```\nnb::class_<Dog, PyDog /* <-- trampoline */>(m, \"Dog\")\n```\n\n----------------------------------------\n\nTITLE: Defining Functions in a Python Module with nanobind\nDESCRIPTION: Example of binding a C++ function to a Python module using nanobind's module_ class. This demonstrates how to create a test function and bind it with documentation.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nvoid test() { printf(\"Hello world!\"); }\n\nNB_MODULE(example, m) {\n    // here, \"m\" is variable of type 'module_'.\n    m.def(\"test\", &test, \"A test function\")\n     .def(...); // more binding declarations\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Trampoline Class for Overriding Virtual Functions in Python with nanobind\nDESCRIPTION: This snippet demonstrates how to implement a trampoline class to allow overriding of C++ virtual functions in Python using nanobind. It includes the trampoline class definition and the necessary macros.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/classes.rst#2025-04-17_snippet_9\n\nLANGUAGE: cpp\nCODE:\n```\n#include <nanobind/trampoline.h>\n\nstruct PyDog : Dog {\n    NB_TRAMPOLINE(Dog, 1);\n\n    std::string bark() const override {\n        NB_OVERRIDE(bark);\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Field Binding Example with Read-Write Access in C++\nDESCRIPTION: Example of binding a C++ class field with mutable access (read-write) to Python. Creates a property that allows Python code to directly access and modify the C++ field.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_14\n\nLANGUAGE: cpp\nCODE:\n```\nstruct A { int value; };\n\nnb::class_<A>(m, \"A\")\n    .def_rw(\"value\", &A::value); // Enable mutable access to the field A::value\n```\n\n----------------------------------------\n\nTITLE: Building Python Extension with CMake\nDESCRIPTION: Commands to set up and build the Python extension using CMake. Includes steps to create the build directory, configure CMake, and compile the extension.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/basics.rst#2025-04-17_snippet_1\n\nLANGUAGE: Bash\nCODE:\n```\ncmake -S . -B build\ncmake --build build\ncd build\npython3\n```\n\n----------------------------------------\n\nTITLE: Binding C++ Classes with nanobind for Python Subclassing\nDESCRIPTION: This snippet shows how to bind C++ classes using nanobind to allow subclassing in Python. It includes bindings for Dog and DogHouse classes with their respective methods and attributes.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/classes.rst#2025-04-17_snippet_8\n\nLANGUAGE: cpp\nCODE:\n```\n#include <nanobind/stl/string.h>\n\nnamespace nb = nanobind;\n\nstruct Dog {\n    std::string name;\n    std::string bark() const { return name + \": woof!\"; }\n};\n\nstruct DogHouse {\n    Dog dog;\n};\n\nNB_MODULE(my_ext, m) {\n    nb::class_<Dog>(m, \"Dog\")\n       .def(nb::init<const std::string &>())\n       .def(\"bark\", &Dog::bark)\n       .def_rw(\"name\", &Dog::name);\n\n    nb::class_<DogHouse>(m, \"DogHouse\")\n       .def(nb::init<Dog>())\n       .def_rw(\"dog\", &DogHouse::dog);\n}\n```\n\n----------------------------------------\n\nTITLE: Field Binding Example with Read-Only Access in C++\nDESCRIPTION: Example of binding a C++ class field with read-only access to Python. Creates a property that allows Python code to read but not modify the C++ field.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_15\n\nLANGUAGE: cpp\nCODE:\n```\nstruct A { int value; };\n\nnb::class_<A>(m, \"A\")\n    .def_ro(\"value\", &A::value);  // Enable read-only access to the field A::value\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic nanobind Module in C++\nDESCRIPTION: Example showing how to create a basic nanobind module using the NB_MODULE macro. The snippet demonstrates defining a module with documentation and adding a simple function binding.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nNB_MODULE(example, m) {\n    m.doc() = \"Example module\";\n\n    // Add bindings here\n    m.def(\"add\", []() {\n        return \"Hello, World!\";\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Constructors and Members to Class Binding in nanobind (C++)\nDESCRIPTION: Adds two constructor overloads, a method, and a mutable field to the Dog class binding. This enables creating Dog instances, calling the bark method, and accessing/modifying the name field from Python.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/basics.rst#2025-04-17_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\n.def(nb::init<>())\n.def(nb::init<const std::string &>())\n.def(\"bark\", &Dog::bark)\n.def_rw(\"name\", &Dog::name);\n```\n\n----------------------------------------\n\nTITLE: Defining Base and Derived Classes in C++\nDESCRIPTION: Demonstrates how to define a base 'Pet' class and a derived 'Dog' class in C++.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/classes.rst#2025-04-17_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nstruct Pet {\n   std::string name;\n};\n\nstruct Dog : Pet {\n   std::string bark() const { return name + \": woof!\"; }\n};\n```\n\n----------------------------------------\n\nTITLE: Enhanced Function Binding with Keyword Arguments and Docstring\nDESCRIPTION: Improved version of the function binding that includes keyword arguments, default values, and a docstring. Demonstrates use of nanobind's argument annotation syntax.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/basics.rst#2025-04-17_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\n#include <nanobind/nanobind.h>\n\nnamespace nb = nanobind;\nusing namespace nb::literals;\n\nint add(int a, int b = 1) { return a + b; }\n\nNB_MODULE(my_ext, m) {\n    m.def(\"add\", &add, \"a\"_a, \"b\"_a = 1,\n          \"This function adds two numbers and increments if only one is provided.\");\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Property from C++ Getter and Setter Methods\nDESCRIPTION: Example of creating a Python property that uses C++ getter and setter methods. Demonstrates how to make C++ methods appear as a Pythonic property with custom access control.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_16\n\nLANGUAGE: cpp\nCODE:\n```\nclass A {\npublic:\n    A(int value) : m_value(value) { }\n    void set_value(int value) { m_value = value; }\n    int value() const { return m_value; }\nprivate:\n    int m_value;\n};\n\nnb::class_<A>(m, \"A\")\n    .def(nb::init<int>())\n    .def_prop_rw(\"value\",\n        [](A &t) { return t.value() ; },\n        [](A &t, int value) { t.set_value(value); });\n```\n\n----------------------------------------\n\nTITLE: Binding C++ Template Functions\nDESCRIPTION: Demonstration of how to bind C++ template functions in nanobind by explicitly instantiating the template with concrete types, either as overloads or as separate named functions.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/functions.rst#2025-04-17_snippet_8\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate <typename T> void process(T t);\n\nm.def(\"process\", &process); // <-- this will not compile\n\n// Option 1:\nm.def(\"process\", &process<int>);\nm.def(\"process\", &process<std::string>);\n\n// Option 2:\nm.def(\"process_int\", &process<int>);\nm.def(\"process_string\", &process<std::string>);\n```\n\n----------------------------------------\n\nTITLE: Creating a Dynamic 2D NumPy Array with Explicit Ownership\nDESCRIPTION: Demonstrates creating a dynamically sized 2D NumPy array with explicit ownership management using a capsule. The function allocates memory, initializes it with values, and ensures proper cleanup when the array is no longer used.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/ndarray.rst#2025-04-17_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\nm.def(\"create_2d\",\n         [](size_t rows, size_t cols) {\n             // Allocate a memory region an initialize it\n             float *data = new float[rows * cols];\n             for (size_t i = 0; i < rows * cols; ++i)\n                 data[i] = (float) i;\n\n             // Delete 'data' when the 'owner' capsule expires\n             nb::capsule owner(data, [](void *p) noexcept {\n                delete[] (float *) p;\n             });\n\n             return nb::ndarray<nb::numpy, float, nb::ndim<2>>(\n                 /* data = */ data,\n                 /* shape = */ { rows, cols },\n                 /* owner = */ owner\n             );\n   });\n```\n\n----------------------------------------\n\nTITLE: Binding Custom C++ Class with nanobind\nDESCRIPTION: Example of binding a custom C++ class (Dog) to Python using nanobind. Includes constructor bindings, method bindings, and attribute access.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/basics.rst#2025-04-17_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\n#include <nanobind/nanobind.h>\n#include <nanobind/stl/string.h>\n\nnamespace nb = nanobind;\n\nNB_MODULE(my_ext, m) {\n    nb::class_<Dog>(m, \"Dog\")\n        .def(nb::init<>())\n        .def(nb::init<const std::string &>())\n        .def(\"bark\", &Dog::bark)\n        .def_rw(\"name\", &Dog::name);\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying Default Arguments in C++ Class Method Bindings\nDESCRIPTION: Demonstrates how to specify default arguments when binding C++ class methods to Python using nanobind. It also shows how to customize the string representation of default arguments.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/functions.rst#2025-04-17_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nnb::class_<MyClass>(m, \"MyClass\")\n    .def(\"f\", &MyClass::f, \"value\"_a = SomeType(123));\n```\n\nLANGUAGE: cpp\nCODE:\n```\nnb::class_<MyClass>(m, \"MyClass\")\n    .def(\"f\", &MyClass::f, \"value\"_a.sig(\"SomeType(123)\") = SomeType(123));\n```\n\n----------------------------------------\n\nTITLE: Implementing Call Guards for Function Execution\nDESCRIPTION: Using nb::call_guard<> to wrap function execution in scope guards, which can be used for releasing the GIL during long-running operations or for other scoped operations around function calls.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/functions.rst#2025-04-17_snippet_10\n\nLANGUAGE: cpp\nCODE:\n```\nm.def(\"foo\", foo, nb::call_guard<T>());\n\n// This is equivalent to the following pseudocode:\nm.def(\"foo\", [](args...) {\n    T scope_guard;\n    return foo(args...); // forwarded arguments\n});\n```\n\n----------------------------------------\n\nTITLE: Binding and Using Higher-Order Functions\nDESCRIPTION: Examples of binding C++ functions that accept or return other functions, including lambdas with captures, and how to use nb::cpp_function to create Python-friendly callbacks with named parameters.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/functions.rst#2025-04-17_snippet_11\n\nLANGUAGE: cpp\nCODE:\n```\nint func_arg(const std::function<int(int)> &f) {\n    return f(10);\n}\n\nstd::function<int(int)> func_ret(const std::function<int(int)> &f) {\n    return [f](int i) {\n        return f(i) + 1;\n    };\n}\n\nnb::object func_cpp() {\n    return nb::cpp_function([](int i) { return i+1; },\n       nb::arg(\"number\"));\n}\n\n#include <nanobind/stl/function.h>\n\nNB_MODULE(my_ext, m) {\n    m.def(\"func_arg\", &func_arg);\n    m.def(\"func_ret\", &func_ret);\n    m.def(\"func_cpp\", &func_cpp);\n}\n```\n\n----------------------------------------\n\nTITLE: Using nanobind_add_module for Python Extension Module Creation in CMake\nDESCRIPTION: Example showing how to use the nanobind_add_module command to create a Python extension module with optional flags and source files. This is the primary high-level interface for building nanobind extensions.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_cmake.rst#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nnanobind_add_module(\n  my_ext                   # Target name\n  NB_STATIC STABLE_ABI LTO # Optional flags (see below)\n  my_ext.h                 # Source code files below\n  my_ext.cpp)\n```\n\n----------------------------------------\n\nTITLE: Custom Object Creation with nb::new_\nDESCRIPTION: Implementation of custom object creation using nb::new_ to bind a factory method, allowing Pythonic object instantiation for classes with non-standard constructors.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/classes.rst#2025-04-17_snippet_28\n\nLANGUAGE: cpp\nCODE:\n```\nnb::class_<Pet>(m, \"Pet\")\n    .def(nb::new_(&Pet::make), \"name\"_a, \"age\"_a)\n    .def(\"speak\", &Pet::speak);\n```\n\n----------------------------------------\n\nTITLE: Binding Overloaded Methods with nanobind\nDESCRIPTION: Demonstrates how to bind overloaded C++ methods using nb::overload_cast in nanobind.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/classes.rst#2025-04-17_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nnb::class_<Pet>(m, \"Pet\")\n   .def(nb::init<const std::string &, int>())\n   .def(\"set\", nb::overload_cast<int>(&Pet::set), \"Set the pet's age\")\n   .def(\"set\", nb::overload_cast<const std::string &>(&Pet::set), \"Set the pet's name\");\n```\n\n----------------------------------------\n\nTITLE: Initializing CMake Project with Python Detection\nDESCRIPTION: Sets up a new CMake project with Python dependencies. Configures minimum CMake version, project name, and finds Python 3.8+ with required development components.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/building.rst#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.15...3.27)\nproject(my_project) # Replace 'my_project' with the name of your project\n\nif (CMAKE_VERSION VERSION_LESS 3.18)\n  set(DEV_MODULE Development)\nelse()\n  set(DEV_MODULE Development.Module)\nendif()\n\nfind_package(Python 3.8 COMPONENTS Interpreter ${DEV_MODULE} REQUIRED)\n```\n\n----------------------------------------\n\nTITLE: Correctly Binding Template Classes with Specific Instantiations\nDESCRIPTION: Correct approach to binding template classes by explicitly specifying each template instantiation. Each combination of template class and type parameters must be bound separately.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/classes.rst#2025-04-17_snippet_21\n\nLANGUAGE: cpp\nCODE:\n```\n// ok\nnb::class_<PetHouse<Cat>>(m, \"CatHouse\")\n    .def(\"get\", &PetHouse<Cat>::get);\n\n// ok\nnb::class_<PetHouse<Dog>>(m, \"DogHouse\")\n    .def(\"get\", &PetHouse<Dog>::get);\n```\n\n----------------------------------------\n\nTITLE: Using Lifetime Annotations with keep_alive\nDESCRIPTION: Example of using nb::keep_alive<> to ensure the proper lifetime relationship between objects, preventing premature garbage collection of objects that are still needed by other objects.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/functions.rst#2025-04-17_snippet_9\n\nLANGUAGE: cpp\nCODE:\n```\nnb::class_<Log>(m, \"Log\")\n    .def(\"append\",\n         [](Log &log, Entry *entry) -> void { ... },\n         nb::keep_alive<1, 2>());\n```\n\n----------------------------------------\n\nTITLE: Binding C++ Operators to Python\nDESCRIPTION: This example demonstrates how to use nanobind's operator binding syntax to expose C++ arithmetic operators in Python.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_23\n\nLANGUAGE: cpp\nCODE:\n```\nstruct A {\n   float value;\n\n   A operator-() const { return { -value }; }\n   A operator-(const A &o) const { return { value - o.value }; }\n   A operator-(float o) const { return { value - o }; }\n};\n\nnb::class_<A>(m, \"A\")\n    .def(nb::init<float>())\n    .def(-nb::self)\n    .def(nb::self - nb::self)\n    .def(nb::self - float());\n```\n\n----------------------------------------\n\nTITLE: Defining a simple C++ function binding with nanobind\nDESCRIPTION: Example of a typical function binding in the microbenchmark, showing how a C++ lambda function is exposed to Python using nanobind's 'def' method.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/benchmark.rst#2025-04-17_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nm.def(\"test_0050\", [](uint16_t a, int64_t b, int32_t c, uint64_t d, uint32_t e, float f) {\n    return a+b+c+d+e+f;\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Higher-Order Functions in nanobind (C++)\nDESCRIPTION: Extends the Dog class with a bark_later method that returns a callable Python function. This demonstrates creating stateful lambda closures and converting them to Python function objects using nb::cpp_function.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/basics.rst#2025-04-17_snippet_10\n\nLANGUAGE: cpp\nCODE:\n```\nnb::class_<Dog>(m, \"Dog\")\n    // ... skipped ...\n    .def(\"bark_later\", [](const Dog &p) {\n        auto callback = [name = p.name] {\n            nb::print(nb::str(\"{}: woof!\").format(name));\n        };\n        return nb::cpp_function(callback);\n    });\n```\n\n----------------------------------------\n\nTITLE: Handling Python Exceptions in C++ (C++)\nDESCRIPTION: Shows how to catch and handle Python exceptions that occur when calling Python code from C++. This example demonstrates handling specific Python exception types like FileNotFoundError and PermissionError.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/exceptions.rst#2025-04-17_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\ntry {\n    nb::object file = nb::module_::import_(\"io\").attr(\"open\")(\"file.txt\", \"r\");\n    nb::object text = file.attr(\"read\")();\n    file.attr(\"close\")();\n} catch (const nb::python_error &e) {\n    if (e.matches(PyExc_FileNotFoundError)) {\n        nb::print(\"file.txt not found\");\n    } else if (e.matches(PyExc_PermissionError)) {\n        nb::print(\"file.txt found but not accessible\");\n    } else {\n        throw;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Including Trampoline Support in nanobind\nDESCRIPTION: This directive imports macros needed to implement trampolines, which are used to forward C++ virtual function calls to Python implementations. Trampolines enable Python classes to override C++ virtual methods.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_extra.rst#2025-04-17_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n#include <nanobind/trampoline.h>\n```\n\n----------------------------------------\n\nTITLE: Compiling Combined C++ Library and Python Extension with nanobind in CMake\nDESCRIPTION: Example demonstrating how to compile a C++ library with regular optimization levels and then link it to a nanobind Python extension. This approach allows different optimization strategies for library code versus binding code.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_cmake.rst#2025-04-17_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\n# Compile project code with current optimization mode configured in CMake\nadd_library(example_lib STATIC source_1.cpp source_2.cpp)\n# Need position independent code (-fPIC) to link into 'example_ext' below\nset_target_properties(example_lib PROPERTIES POSITION_INDEPENDENT_CODE ON)\n\n# Compile extension module with size optimization and add 'example_lib'\nnanobind_add_module(example_ext common.h source_1.cpp source_2.cpp)\ntarget_link_libraries(example_ext PRIVATE example_lib)\n```\n\n----------------------------------------\n\nTITLE: Intrusive Reference Counting with nanobind\nDESCRIPTION: Example showing how to implement intrusive reference counting in a class to be used with nanobind. This approach is more efficient than shared_ptr for shared ownership.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/ownership.rst#2025-04-17_snippet_11\n\nLANGUAGE: cpp\nCODE:\n```\nclass Object {\n...\nprivate:\n    mutable std::atomic<size_t> m_ref_count { 0 };\n    PyObject *m_py_object = nullptr;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a C++ class binding with nanobind\nDESCRIPTION: Example of a class binding in the microbenchmark, demonstrating how a C++ struct is exposed to Python using nanobind's class_ and def methods.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/benchmark.rst#2025-04-17_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nstruct Struct50 {\n    uint16_t a; int64_t b; int32_t c; uint64_t d; uint32_t e; float f;\n    Struct50(uint16_t a, int64_t b, int32_t c, uint64_t d, uint32_t e, float f)\n        : a(a), b(b), c(c), d(d), e(e), f(f) { }\n    float sum() const { return a+b+c+d+e+f; }\n};\n\npy::class_<Struct50>(m, \"Struct50\")\n    .def(py::init<uint16_t, int64_t, int32_t, uint64_t, uint32_t, float>())\n    .def(\"sum\", &Struct50::sum);\n```\n\n----------------------------------------\n\nTITLE: Binding Vector2 Class with Operators Using nanobind\nDESCRIPTION: Implementation of a nanobind module that binds the Vector2 class to Python, exposing its constructor and various operators. Uses nb::self syntax to provide shorthand notation for operator binding.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/classes.rst#2025-04-17_snippet_12\n\nLANGUAGE: cpp\nCODE:\n```\n#include <nanobind/operators.h>\n\nNB_MODULE(my_ext, m) {\n    nb::class_<Vector2>(m, \"Vector2\")\n        .def(nb::init<float, float>())\n        .def(nb::self + nb::self)\n        .def(nb::self += nb::self)\n        .def(nb::self *= float())\n        .def(float() * nb::self)\n        .def(nb::self * float())\n        .def(-nb::self)\n        .def(\"__repr__\", &Vector2::to_string);\n}\n```\n\n----------------------------------------\n\nTITLE: Using std::unique_ptr with nanobind\nDESCRIPTION: Example showing how to use std::unique_ptr with nanobind for transferring ownership from Python to C++. Demonstrates creation and consumption of a unique pointer.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/ownership.rst#2025-04-17_snippet_8\n\nLANGUAGE: cpp\nCODE:\n```\n#include <nanobind/stl/unique_ptr.h>\n\nnamespace nb = nanobind;\n\nNB_MODULE(my_ext, m) {\n    struct Data { };\n    nb::class_<Data>(m, \"Data\");\n    m.def(\"create\", []() { return std::make_unique<Data>(); });\n    m.def(\"consume\", [](std::unique_ptr<Data> x) { /* no-op */ });\n}\n```\n\n----------------------------------------\n\nTITLE: Binding Classes with Internal Types and Enumerations\nDESCRIPTION: Shows how to bind a class with internal types like enumerations and nested structures using nanobind.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/classes.rst#2025-04-17_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nnb::class_<Pet> pet(m, \"Pet\");\n\npet.def(nb::init<const std::string &, Pet::Kind>())\n    .def_rw(\"name\", &Pet::name)\n    .def_rw(\"type\", &Pet::type)\n    .def_rw(\"attr\", &Pet::attr);\n\nnb::enum_<Pet::Kind>(pet, \"Kind\")\n    .value(\"Dog\", Pet::Kind::Dog)\n    .value(\"Cat\", Pet::Kind::Cat)\n    .export_values();\n\nnb::class_<Pet::Attributes>(pet, \"Attributes\")\n    .def(nb::init<>())\n    .def_rw(\"age\", &Pet::Attributes::age);\n```\n\n----------------------------------------\n\nTITLE: Including nanobind Typing Functionality\nDESCRIPTION: Include directive for accessing typing-related functionality in nanobind, which provides ways to work with Python's typing system.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_extra.rst#2025-04-17_snippet_26\n\nLANGUAGE: cpp\nCODE:\n```\n#include <nanobind/typing.h>\n```\n\n----------------------------------------\n\nTITLE: Implementing Object with nanobind Intrusive Reference Counting\nDESCRIPTION: Implementation of a class using nanobind's intrusive counter to manage references between C++ and Python. Includes methods for reference counting and handling Python object references.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/ownership_adv.rst#2025-04-17_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n#include <nanobind/intrusive/counter.h>\n\nclass Object {\npublic:\n    void inc_ref() noexcept { m_ref_count.inc_ref(); }\n    bool dec_ref() noexcept { return m_ref_count.dec_ref(); }\n\n    // Important: must declare virtual destructor\n    virtual ~Object() = default;\n\n    void set_self_py(PyObject *self) noexcept {\n        m_ref_count.set_self_py(self);\n    }\n\nprivate:\n    nb::intrusive_counter m_ref_count;\n};\n\n// Convenience function for increasing the reference count of an instance\ninline void inc_ref(Object *o) noexcept {\n    if (o)\n       o->inc_ref();\n}\n\n// Convenience function for decreasing the reference count of an instance\n// and potentially deleting it when the count reaches zero\ninline void dec_ref(Object *o) noexcept {\n    if (o && o->dec_ref())\n        delete o;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Vector2 Class with Operator Overloading in C++\nDESCRIPTION: Implementation of a Vector2 class with various operator overloads including addition, scalar multiplication, negation, and compound assignment operators in C++. The class stores x and y coordinates as floats and includes a to_string method for representation.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/classes.rst#2025-04-17_snippet_11\n\nLANGUAGE: cpp\nCODE:\n```\nclass Vector2 {\npublic:\n    Vector2(float x, float y) : x(x), y(y) { }\n\n    Vector2 operator+(const Vector2 &v) const { return Vector2(x + v.x, y + v.y); }\n    Vector2 operator*(float value) const { return Vector2(x * value, y * value); }\n    Vector2 operator-() const { return Vector2(-x, -y); }\n    Vector2& operator+=(const Vector2 &v) { x += v.x; y += v.y; return *this; }\n    Vector2& operator*=(float v) { x *= v; y *= v; return *this; }\n\n    friend Vector2 operator*(float f, const Vector2 &v) {\n        return Vector2(f * v.x, f * v.y);\n    }\n\n    std::string to_string() const {\n        return \"[\" + std::to_string(x) + \", \" + std::to_string(y) + \"]\";\n    }\nprivate:\n    float x, y;\n};\n```\n\n----------------------------------------\n\nTITLE: Registering Custom Exception Type in Nanobind (C++)\nDESCRIPTION: Demonstrates how to register a C++ exception type as a Python exception using nb::exception<T>. This allows C++ exceptions to automatically convert to equivalent Python exceptions when crossing the language barrier.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/exceptions.rst#2025-04-17_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nNB_MODULE(my_ext, m) {\n    nb::exception<CppExp>(m, \"PyExp\");\n}\n```\n\n----------------------------------------\n\nTITLE: Inspecting Any ndarray Properties in C++\nDESCRIPTION: A function that accepts any array and inspects its properties, including data pointer, dimensions, shape, stride, device information, and data type.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/ndarray.rst#2025-04-17_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nm.def(\"inspect\", [](const nb::ndarray<>& a) {\n    printf(\"Array data pointer : %p\\n\", a.data());\n    printf(\"Array dimension : %zu\\n\", a.ndim());\n    for (size_t i = 0; i < a.ndim(); ++i) {\n        printf(\"Array dimension [%zu] : %zu\\n\", i, a.shape(i));\n        printf(\"Array stride    [%zu] : %zd\\n\", i, a.stride(i));\n    }\n    printf(\"Device ID = %u (cpu=%i, cuda=%i)\\n\", a.device_id(),\n        int(a.device_type() == nb::device::cpu::value),\n        int(a.device_type() == nb::device::cuda::value)\n    );\n    printf(\"Array dtype: int16=%i, uint32=%i, float32=%i\\n\",\n        a.dtype() == nb::dtype<int16_t>(),\n        a.dtype() == nb::dtype<uint32_t>(),\n        a.dtype() == nb::dtype<float>()\n    );\n});\n```\n\n----------------------------------------\n\nTITLE: Binding Class Methods with Template Parameters\nDESCRIPTION: Example of binding a class method that itself has template parameters. Shows how to specify both class and method template parameters when binding to Python.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/classes.rst#2025-04-17_snippet_22\n\nLANGUAGE: cpp\nCODE:\n```\ntypename <typename T> struct MyClass {\n    template <typename V> T fn(V v);\n};\n\nnb::class_<MyClass<int>>(m, \"MyClassT\")\n    .def(\"fn\", &MyClass<int>::fn<std::string>);\n```\n\n----------------------------------------\n\nTITLE: Implementing Keyword-Only Parameters in nanobind\nDESCRIPTION: C++ code demonstrating how to use the nb::kw_only() annotation to create Python bindings with keyword-only parameters, equivalent to using the '*,' syntax in Python function signatures.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/functions.rst#2025-04-17_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\nvoid example(int val, bool check);\nint munge(nb::args args, bool invert);\n\nm.def(\"example\", &example,\n      nb::arg(\"val\"), nb::kw_only(), nb::arg(\"check\"));\n\n// Parameters after *args are implicitly keyword-only:\nm.def(\"munge\", &munge,\n      nb::arg(\"args\"), nb::arg(\"invert\"));\n\n// But you can be explicit about it too, as long as you put the\n// kw_only annotation in the correct position:\nm.def(\"munge\", &munge,\n      nb::arg(\"args\"), nb::kw_only(), nb::arg(\"invert\"));\n```\n\n----------------------------------------\n\nTITLE: Including nanobind ndarray Header in C++\nDESCRIPTION: Include directive for nanobind's n-dimensional array type, required to use the ndarray class and related functions.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_extra.rst#2025-04-17_snippet_12\n\nLANGUAGE: C++\nCODE:\n```\n#include <nanobind/ndarray.h>\n```\n\n----------------------------------------\n\nTITLE: Configuring cibuildwheel in pyproject.toml for nanobind\nDESCRIPTION: Basic configuration for cibuildwheel in pyproject.toml to build Python wheels for nanobind projects. Sets build verbosity and configures macOS environment with proper deployment target for C++17 support.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/packaging.rst#2025-04-17_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[tool.cibuildwheel]\n# Necessary to see build output from the actual compilation\nbuild-verbosity = 1\n\n# Optional: run pytest to ensure that the package was correctly built\n# test-command = \"pytest {project}/tests\"\n# test-requires = \"pytest\"\n\n# Needed for full C++17 support on macOS\n[tool.cibuildwheel.macos.environment]\nMACOSX_DEPLOYMENT_TARGET = \"10.14\"\n```\n\n----------------------------------------\n\nTITLE: Creating a View of a Matrix4f as a NumPy Array with Reference Policy\nDESCRIPTION: Example showing how to return a NumPy array view of a Matrix4f instance with proper ownership handling using the reference_internal return value policy.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/ndarray.rst#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nview(self) -> numpy.ndarray[float32, shape=(4, 4), order='F']\n```\n\n----------------------------------------\n\nTITLE: Evaluating Python expressions and statements in C++\nDESCRIPTION: Demonstrates how to import the __main__ module scope, evaluate a Python expression with nb::eval(), and execute multiple Python statements with nb::exec().\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/utilities.rst#2025-04-17_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n// Evaluate in scope of main module\nnb::object scope = nb::module_::import_(\"__main__\").attr(\"__dict__\");\n\n// Evaluate an isolated expression\nint result = nb::eval(\"my_variable + 10\", scope).cast<int>();\n\n// Evaluate a sequence of statements\nnb::exec(\n    \"print('Hello')\\n\"\n    \"print('world!');\",\n    scope);\n```\n\n----------------------------------------\n\nTITLE: Binding C++ Function with None Argument Support\nDESCRIPTION: Illustrates how to bind a C++ function that can accept None as an argument, using the .none() annotation.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/functions.rst#2025-04-17_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\nstruct Dog { };\nconst char *bark(Dog *dog) {\n    return dog != nullptr ? \"woof!\" : \"(no dog)\";\n}\n\nNB_MODULE(my_ext, m) {\n    nb::class_<Dog>(m, \"Dog\")\n        .def(nb::init<>());\n    m.def(\"bark\", &bark);\n}\n```\n\nLANGUAGE: cpp\nCODE:\n```\nm.def(\"bark\", &bark, nb::arg(\"dog\").none());\n```\n\nLANGUAGE: cpp\nCODE:\n```\nm.def(\"bark\", &bark, nb::arg(\"dog\") = nb::none());\n```\n\n----------------------------------------\n\nTITLE: Implementing tp_traverse and tp_clear for Cycle Detection in C++ Class with nanobind\nDESCRIPTION: Example showing how to implement the tp_traverse and tp_clear type slots for a C++ Wrapper class to enable Python's garbage collector to detect and break reference cycles. This includes proper traversal of dependencies and safe handling of the instance state.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/refleaks.rst#2025-04-17_snippet_11\n\nLANGUAGE: cpp\nCODE:\n```\nstruct Wrapper { std::shared_ptr<Wrapper> value; };\n\nint wrapper_tp_traverse(PyObject *self, visitproc visit, void *arg) {\n    // On Python 3.9+, we must traverse the implicit dependency\n    // of an object on its associated type object.\n    #if PY_VERSION_HEX >= 0x03090000\n        Py_VISIT(Py_TYPE(self));\n    #endif\n\n    // The tp_traverse method may be called after __new__ but before or during\n    // __init__, before the C++ constructor has been completed. We must not\n    // inspect the C++ state if the constructor has not yet completed.\n    if (!nb::inst_ready(self)) {\n       return 0;\n    }\n\n    // Get the C++ object associated with 'self' (this always succeeds)\n    Wrapper *w = nb::inst_ptr<Wrapper>(self);\n\n    // If w->value has an associated Python object, return it.\n    // If not, value.ptr() will equal NULL, which is also fine.\n    nb::handle value = nb::find(w->value);\n\n    // Inform the Python GC about the instance\n    Py_VISIT(value.ptr());\n\n    return 0;\n}\n\nint wrapper_tp_clear(PyObject *self) {\n    // Get the C++ object associated with 'self' (this always succeeds)\n    Wrapper *w = nb::inst_ptr<Wrapper>(self);\n\n    // Break the reference cycle!\n    w->value = {};\n\n    return 0;\n}\n\n// Table of custom type slots we want to install\nPyType_Slot wrapper_slots[] = {\n    { Py_tp_traverse, (void *) wrapper_tp_traverse },\n    { Py_tp_clear, (void *) wrapper_tp_clear },\n    { 0, 0 }\n};\n```\n\n----------------------------------------\n\nTITLE: Adding a __repr__ Method with Lambda Function in nanobind (C++)\nDESCRIPTION: Enhances the Dog class binding by adding a __repr__ method using a lambda function. This provides a better string representation when printing Dog instances in Python.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/basics.rst#2025-04-17_snippet_9\n\nLANGUAGE: cpp\nCODE:\n```\nnb::class_<Dog>(m, \"Dog\")\n    // ... skipped ...\n    .def(\"__repr__\",\n         [](const Dog &p) { return \"<my_ext.Dog named '\" + p.name + \"'>\"; });\n```\n\n----------------------------------------\n\nTITLE: Using the Publicist Pattern to Expose Protected Members\nDESCRIPTION: A solution to expose protected member functions to Python using a helper class that changes the access modifier. This pattern preserves the function's signature and address while making it publicly accessible.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/classes.rst#2025-04-17_snippet_17\n\nLANGUAGE: cpp\nCODE:\n```\nclass A {\nprotected:\n    int foo() const { return 42; }\n};\n\nclass Publicist : public A { // helper type for exposing protected functions\npublic:\n    using A::foo; // inherited with different access modifier\n};\n\nnb::class_<A>(m, \"A\") // bind the primary class\n    .def(\"foo\", &Publicist::foo); // expose protected methods via the publicist\n```\n\n----------------------------------------\n\nTITLE: Array Shape Constraint Template\nDESCRIPTION: Template class that allows specifying dimension constraints for ndarrays. Each value in the parameter pack defines a fixed size for that dimension, with -1 indicating any size is acceptable.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_extra.rst#2025-04-17_snippet_17\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate <ssize_t... Is> class shape {\n   // Require the array to have sizeof...(Is) dimensions\n   // Each entry of Is specifies a fixed size constraint for that dimension\n   // An entry equal to -1 indicates any size should be accepted\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing trampoline classes in nanobind\nDESCRIPTION: Demonstrates how to implement a trampoline class in nanobind for forwarding virtual function calls to Python, using the NB_TRAMPOLINE and NB_OVERRIDE macros.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/porting.rst#2025-04-17_snippet_10\n\nLANGUAGE: cpp\nCODE:\n```\nstruct PyAnimal : Animal {\n    NB_TRAMPOLINE(Animal, 1);\n\n    std::string name() const override {\n        NB_OVERRIDE(name);\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Handling Python C API Errors (C++)\nDESCRIPTION: Demonstrates how to properly handle errors from the Python C API by throwing nb::python_error. Also shows the simpler approach using nanobind's error wrappers.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/exceptions.rst#2025-04-17_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\nPyErr_SetString(PyExc_TypeError, \"C API type error demo\");\nthrow nb::python_error();\n\n// But it would be easier to simply...\nthrow nb::type_error(\"nanobind wrapper type error\");\n```\n\n----------------------------------------\n\nTITLE: Building nanobind Extension Module\nDESCRIPTION: Compiles a nanobind extension module from source files. Shows both default size-optimized version and optional speed-optimized variant.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/building.rst#2025-04-17_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nnanobind_add_module(my_ext my_ext.cpp)\n\n# Alternative without size optimization:\n# nanobind_add_module(my_ext NOMINSIZE my_ext.cpp)\n```\n\n----------------------------------------\n\nTITLE: Function Argument Annotation in NanoBind C++\nDESCRIPTION: Examples demonstrating how to use argument annotations for function bindings, including keyword arguments and shortened syntax using namespace literals.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\nm.def(\"add\", [](int a, int b) { return a + b; }, nb::arg(\"a\"), nb::arg(\"b\"));\n```\n\nLANGUAGE: cpp\nCODE:\n```\nusing namespace nb::literals;\n\nm.def(\"add\", [](int a, int b) { return a + b; }, \"a\"_a, \"b\"_a);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Type Casters with Vector Doubling Function in C++\nDESCRIPTION: A C++ function that doubles all entries in a std::vector<int> and returns the result. This example demonstrates how to use type casters to automatically convert between C++ vectors and Python lists.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/exchanging.rst#2025-04-17_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nusing IntVector = std::vector<int>;\n\nIntVector double_it(const IntVector &in) {\n    IntVector out(in.size());\n    for (size_t i = 0; i < in.size(); ++i)\n        out[i] = in[i] * 2;\n    return out;\n}\n```\n\n----------------------------------------\n\nTITLE: Array Contiguity Constraint Classes\nDESCRIPTION: Classes that specify memory layout constraints for ndarrays, allowing functions to require C-contiguous or Fortran-contiguous storage for optimal performance.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_extra.rst#2025-04-17_snippet_19\n\nLANGUAGE: cpp\nCODE:\n```\nclass c_contig {\n   // Request that the array storage uses a C-contiguous representation\n};\n\nclass f_contig {\n   // Request that the array storage uses a F (Fortran)-contiguous representation\n};\n\nclass any_contig {\n   // Accept any contiguous representation\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing a Basic Class Binding in nanobind (C++)\nDESCRIPTION: Creates a basic binding for a C++ Dog class with no members. This associates the C++ type Dog with a new Python type of the same name and installs it in the provided module.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/basics.rst#2025-04-17_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\nnb::class_<Dog>(m, \"Dog\")\n```\n\n----------------------------------------\n\nTITLE: Creating Python Iterator from C++ Vector in C++\nDESCRIPTION: Example of creating a Python iterator for a std::vector<int> using nanobind's make_iterator function. The keep_alive annotation is used to tie the iterator's lifetime to the vector.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_extra.rst#2025-04-17_snippet_11\n\nLANGUAGE: C++\nCODE:\n```\nusing IntVec = std::vector<int>;\n\nnb::class_<IntVec>(m, \"IntVec\")\n   .def(\"__iter__\",\n        [](const IntVec &v) {\n            return nb::make_iterator(nb::type<IntVec>(), \"iterator\",\n                                     v.begin(), v.end());\n        }, nb::keep_alive<0, 1>());\n```\n\n----------------------------------------\n\nTITLE: Using Type Bindings for Vector in nanobind Module\nDESCRIPTION: This snippet demonstrates how to use bindings instead of type casters by replacing the vector.h header with bind_vector.h and explicitly binding the vector type as a new Python class named IntVector.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/exchanging.rst#2025-04-17_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n#include <nanobind/stl/bind_vector.h>\n\nusing IntVector = std::vector<int>;\nIntVector double_it(const IntVector &in) { /* .. omitted .. */ }\n\nnamespace nb = nanobind;\n\nNB_MODULE(my_ext, m) {\n    nb::bind_vector<IntVector>(m, \"IntVector\");\n    m.def(\"double_it\", &double_it);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Polymorphic Classes for Automatic Downcasting\nDESCRIPTION: Shows how to make a base class polymorphic by adding a virtual destructor, enabling automatic downcasting in nanobind.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/classes.rst#2025-04-17_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nstruct Pet {\n   virtual ~Pet() = default;\n   std::string name;\n};\n```\n\n----------------------------------------\n\nTITLE: Using the RAII ref<T> Helper for Automatic Reference Counting\nDESCRIPTION: Example of using nanobind's ref<T> RAII helper class to automate reference counting operations, automatically handling reference increments and decrements.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/ownership_adv.rst#2025-04-17_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\n#include <nanobind/intrusive/ref.h>\n\nvoid foo() {\n    /// Assignment to ref<T> automatically increases the object's reference count\n    ref<MyObject> x = new MyObject();\n\n    // ref<T> can be used like a normal pointer\n    x->func();\n\n} // <-- ref::~ref() calls dec_ref(), which deletes the now-unreferenced instance\n```\n\n----------------------------------------\n\nTITLE: Implementing type_hook for Tag-based Polymorphism\nDESCRIPTION: Implementation of the nanobind::detail::type_hook specialization to enable automatic downcasting for tag-based polymorphism. The get() method inspects the Pet instance and returns the appropriate derived type info.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/classes.rst#2025-04-17_snippet_24\n\nLANGUAGE: cpp\nCODE:\n```\nnamespace nanobind::detail {\n    template <> struct type_hook<Pet> {\n        static const std::type_info *get(Pet *p) {\n            if (p) {\n                switch (p->kind) {\n                    case PetKind::Dog: return &typeid(Dog);\n                    case PetKind::Cat: return &typeid(Cat);\n                }\n            }\n            return &typeid(Pet);\n        }\n    };\n} // namespace nanobind::detail\n```\n\n----------------------------------------\n\nTITLE: Read-Only Array Annotation Class\nDESCRIPTION: Class that indicates read-only access to an ndarray when no specific data type is specified, allowing functions to accept arbitrary input arrays but prevent modification.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_extra.rst#2025-04-17_snippet_16\n\nLANGUAGE: cpp\nCODE:\n```\nclass ro {\n   // Indicate read-only access (use only when no data type is specified.)\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Call Policy Implementation for C++ Reference Management\nDESCRIPTION: Example implementation of a custom call policy that can be used with nanobind function bindings. This policy treats return values as a list of references and ensures they are kept alive in relation to a specific function argument.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_12\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate <size_t I>\nstruct returns_references_to {\n    static void precall(PyObject **, size_t, nb::detail::cleanup_list *) {}\n\n    template <size_t N>\n    static void postcall(PyObject **args,\n                         std::integral_constant<size_t, N>,\n                         nb::handle ret) {\n        static_assert(I > 0 && I <= N,\n                      \"I in returns_references_to<I> must be in the \"\n                      \"range [1, number of C++ function arguments]\");\n        if (!nb::isinstance<nb::sequence>(ret)) {\n            throw std::runtime_error(\"return value should be a sequence\");\n        }\n        for (nb::handle nurse : ret) {\n            nb::detail::keep_alive(nurse.ptr(), args[I - 1]);\n        }\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Removing Elements from Python Sequences or Mappings in C++\nDESCRIPTION: Implementation of the del() function that removes elements from Python sequences or mappings. This is equivalent to Python's 'del obj[key]' syntax.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nnb::del(o[key]);\n```\n\n----------------------------------------\n\nTITLE: Creating Python Submodules with nanobind\nDESCRIPTION: Demonstrates how to create hierarchical submodules within a Python module using nanobind's def_submodule method.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\nNB_MODULE(example, m) {\n    nb::module_ m2 = m.def_submodule(\"sub\", \"A submodule of 'example'\");\n    nb::module_ m3 = m2.def_submodule(\"subsub\", \"A submodule of 'example.sub'\");\n}\n```\n\n----------------------------------------\n\nTITLE: Reference Internal Return Value Policy Example\nDESCRIPTION: Demonstrates exposing an internal field of a class with proper lifetime management, ensuring the parent object isn't garbage collected while the field is in use.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/ownership.rst#2025-04-17_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\nstruct MyClass {\npublic:\n    MyField &field() { return m_field; }\n\nprivate:\n    MyField m_field;\n};\n\nnb::class_<MyClass>(m, \"MyClass\")\n   .def(\"field\", &MyClass::field, nb::rv_policy::reference_internal);\n```\n\n----------------------------------------\n\nTITLE: Using rv_policy with enable_shared_from_this in nanobind\nDESCRIPTION: Return value policies that affect how nanobind handles enable_shared_from_this objects when passing from C++ to Python. Policies like take_ownership or reference will result in shared ownership, while copy and move create new objects.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/ownership_adv.rst#2025-04-17_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\nrv_policy::take_ownership\nrv_policy::reference\nrv_policy::copy\nrv_policy::move\n```\n\n----------------------------------------\n\nTITLE: Registering Custom Exception Translator (C++)\nDESCRIPTION: Demonstrates how to register a custom exception translator using nb::register_exception_translator(). This allows for converting specific C++ exception types to appropriate Python exceptions.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/exceptions.rst#2025-04-17_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nnb::register_exception_translator(\n    [](const std::exception_ptr &p, void * /* unused */) {\n        try {\n            std::rethrow_exception(p);\n        } catch (const MyCustomException &e) {\n            PyErr_SetString(PyExc_IndexError, e.what());\n        }\n    });\n```\n\n----------------------------------------\n\nTITLE: Setting Up Vector Type Caster in nanobind Module\nDESCRIPTION: Code showing how to include the necessary STL vector header and define a module that exposes the double_it function. The vector type caster handles automatic conversion between C++ vectors and Python lists.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/exchanging.rst#2025-04-17_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n#include <nanobind/stl/vector.h>\n\nNB_MODULE(my_ext, m) {\n    m.def(\"double_it\", &double_it);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Python List Doubling Function in C++ with nanobind\nDESCRIPTION: This example demonstrates how to use nanobind wrappers to implement a function that doubles the values in a Python list. It showcases the use of nb::list and nb::int_ wrappers.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/exchanging.rst#2025-04-17_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\n#include <nanobind/nanobind.h>\n\nnamespace nb = nanobind;\n\nnb::list double_it(nb::list l) {\n    nb::list result;\n    for (nb::handle h: l)\n        result.append(h * nb::int_(2));\n    return result;\n}\n\nNB_MODULE(my_ext, m) {\n    m.def(\"double_it\", &double_it);\n}\n```\n\n----------------------------------------\n\nTITLE: Binding Classes with Inheritance using nanobind\nDESCRIPTION: Shows how to bind the Pet and Dog classes using nanobind, specifying the inheritance relationship.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/classes.rst#2025-04-17_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\n#include <nanobind/stl/string.h>\n\nNB_MODULE(my_ext, m) {\n   nb::class_<Pet>(m, \"Pet\")\n      .def(nb::init<const std::string &>())\n      .def_rw(\"name\", &Pet::name);\n\n   nb::class_<Dog, Pet /* <- C++ parent type */>(m, \"Dog\")\n       .def(nb::init<const std::string &>())\n       .def(\"bark\", &Dog::bark);\n}\n```\n\n----------------------------------------\n\nTITLE: Minimizing Binding Overheads in nanobind\nDESCRIPTION: Example showing how to optimize nanobind function bindings for performance by removing keyword arguments and advanced annotations when high-performance is required.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/functions.rst#2025-04-17_snippet_13\n\nLANGUAGE: cpp\nCODE:\n```\nNB_MODULE(my_ext, m) {\n    m.def(\"f1\", [](int) { /* no-op */ });\n    m.def(\"f2\", [](int) { /* no-op */ }, \"arg\"_a);\n}\n```\n\n----------------------------------------\n\nTITLE: Returning Eigen Expression with eval()\nDESCRIPTION: Example of safely returning an Eigen expression using eval(). This forces evaluation of the expression, creating a new container that owns the storage, which prevents undefined behavior.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/eigen.rst#2025-04-17_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nm.def(\"sum\", [](Eigen::Vector3f a, Eigen::Vector3d b) { return (a + b).eval(); });\n```\n\n----------------------------------------\n\nTITLE: Binding In-place Operators with Return Value Policy\nDESCRIPTION: Example showing how to bind in-place operators with the appropriate return value policy. Using nb::rv_policy::none prevents creating unnecessary copies when the C++ method returns *this.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/classes.rst#2025-04-17_snippet_15\n\nLANGUAGE: cpp\nCODE:\n```\n.def(nb::self += nb::self, nb::rv_policy::none)\n```\n\n----------------------------------------\n\nTITLE: Combining Publicist Pattern with Trampolines for Virtual Functions\nDESCRIPTION: Advanced example that combines the publicist pattern with trampolines to allow overriding protected virtual functions from Python. Shows how to separate the concerns of exposure and override functionality.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/classes.rst#2025-04-17_snippet_18\n\nLANGUAGE: cpp\nCODE:\n```\nclass A {\npublic:\n    virtual ~A() = default;\n\nprotected:\n    virtual int foo() const { return 42; }\n};\n\nclass Trampoline : public A {\npublic:\n    NB_TRAMPOLINE(A, 1);\n    int foo() const override { NB_OVERRIDE(foo); }\n};\n\nclass Publicist : public A {\npublic:\n    using A::foo;\n};\n\nnb::class_<A, Trampoline>(m, \"A\") // <-- `Trampoline` here\n    .def(\"foo\", &Publicist::foo); // <-- `Publicist` here, not `Trampoline`!\n```\n\n----------------------------------------\n\nTITLE: Implementing from_python() Method in Nanobind Type Caster\nDESCRIPTION: Guidelines for implementing the from_python() method in a Nanobind type caster. This method should handle Python to C++ conversion, return false on failure, and use CPython warning API for severe errors.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/porting.rst#2025-04-17_snippet_11\n\nLANGUAGE: C++\nCODE:\n```\nbool from_python(handle src, type_info *ti) noexcept {\n    // Implementation\n    if (conversion_failed) {\n        return false;\n    }\n    if (severe_error) {\n        PyErr_Warn(PyExc_RuntimeWarning, \"Severe error occurred\");\n    }\n    return true;\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Exception Base Class (C++)\nDESCRIPTION: Shows how to specify a Python exception base class when registering a custom C++ exception. This example creates a custom exception that inherits from Python's RuntimeError.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/exceptions.rst#2025-04-17_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nnb::exception<CppExp>(module, \"PyExp\", PyExc_RuntimeError);\n```\n\n----------------------------------------\n\nTITLE: Python Usage of Higher-Order Functions\nDESCRIPTION: Interactive Python session demonstrating how to use the bound higher-order functions, including passing Python functions to C++, receiving function objects back, and using named parameters.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/functions.rst#2025-04-17_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nPython 3.11.1 (main, Dec 23 2022, 09:28:24) [Clang 14.0.0 (clang-1400.0.29.202)] on darwin\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> import my_ext\n>>> def square(i):\n...     return i*i\n...\n>>> my_ext.func_arg(square)\n100\n>>> square_plus_1 = my_ext.func_ret(square)\n>>> square_plus_1(4)\n17\n>>> plus_1 = my_ext.func_cpp()\n>>> plus_1.__doc__\n'<anonymous>(number: int) -> int'\n>>> plus_1(number=43)\n44\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Intrusive Reference Counting in C++\nDESCRIPTION: A simple class implementation demonstrating basic intrusive reference counting with increment and decrement methods. When the counter reaches zero, the object deallocates itself.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/ownership_adv.rst#2025-04-17_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nclass Object {\npublic:\n    void inc_ref() const noexcept { ++m_ref_count; }\n\n    void dec_ref() const noexcept {\n        if (--m_ref_count == 0)\n            delete this;\n    }\n\nprivate:\n    mutable std::atomic<size_t> m_ref_count { 0 };\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing a generic wrapper in C++ with nanobind\nDESCRIPTION: Shows how to create a generic parameterized type in C++ using nanobind's typing facilities to mirror Python's Generic types.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/typing.rst#2025-04-17_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\n#include <nanobind/typing.h> // needed by nb::type_var below\n\nstruct Wrapper {\n    nb::object value;\n};\n\nNB_MODULE(my_ext, m) {\n    // 1. Instantiate a placeholder type (\"type variable\") used below\n    m.attr(\"T\") = nb::type_var(\"T\");\n\n    // 2. Create a generic type, and indicate in generated stubs\n    //    that it derives from Generic[T]\n\n```\n\n----------------------------------------\n\nTITLE: Function Signature Override Example in nanobind\nDESCRIPTION: Example showing how to override a function's type signature using nb::sig annotation to add decorators and customize argument rendering.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_8\n\nLANGUAGE: cpp\nCODE:\n```\nnb::def(\"function_name\", &function_name,\n        nb::sig(\n            \"@decorator(decorator_args..)\n\"\n            \"def function_name(arg_1: type_1 = def_1, ...) -> ret\"\n        ));\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Constructors with Placement New in nanobind\nDESCRIPTION: Demonstrates how to manually bind constructors that don't exist in the C++ type using placement new syntax. This lower-level approach allows creating Python-specific constructors.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_24\n\nLANGUAGE: cpp\nCODE:\n```\nnb::class_<MyType>(m, \"MyType\")\n    .def(nb::init<const char*, int>());\n```\n\nLANGUAGE: cpp\nCODE:\n```\nnb::class_<MyType>(m, \"MyType\")\n    .def(\"__init__\",\n         [](MyType* t, const char* arg0, int arg1) {\n             new (t) MyType(arg0, arg1);\n         });\n```\n\n----------------------------------------\n\nTITLE: Overloaded Object Creation with Lambda Functions\nDESCRIPTION: Advanced example showing multiple nb::new_ bindings including a lambda function for random pet creation and a regular factory method.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/classes.rst#2025-04-17_snippet_29\n\nLANGUAGE: cpp\nCODE:\n```\nnb::class_<Pet>(m, \"Pet\")\n    .def(nb::new_([]() { return Pet::make(getRandomName(), 0); }))\n    .def(nb::new_(&Pet::make), \"name\"_a, \"age\"_a)\n    .def(\"speak\", &Pet::speak);\n```\n\n----------------------------------------\n\nTITLE: Take Ownership Return Value Policy Example\nDESCRIPTION: Demonstrates transferring ownership of a heap-allocated C++ instance to Python using the take_ownership return value policy.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/ownership.rst#2025-04-17_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nm.def(\"make_data\", []{ return new Data(); }, nb::rv_policy::take_ownership);\n```\n\n----------------------------------------\n\nTITLE: Defining Constrained RGB Image Processing Function\nDESCRIPTION: Function that processes a CPU-resident RGB image with constraints on shape and data type, demonstrating direct access to array elements with operator().\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/ndarray.rst#2025-04-17_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\nusing RGBImage = nb::ndarray<uint8_t, nb::shape<-1, -1, 3>, nb::device::cpu>;\n\nm.def(\"process\", [](RGBImage data) {\n    // Double brightness of the MxNx3 RGB image\n    for (size_t y = 0; y < data.shape(0); ++y)\n        for (size_t x = 0; x < data.shape(1); ++x)\n            for (size_t ch = 0; ch < 3; ++ch)\n                data(y, x, ch) = (uint8_t) std::min(255, data(y, x, ch) * 2);\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling Dynamic Attributes for C++ Classes in Python with nanobind\nDESCRIPTION: This snippet shows how to enable dynamic attributes for C++ classes when binding them to Python using nanobind. The nb::dynamic_attr() tag is added to the class constructor.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/classes.rst#2025-04-17_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\nnb::class_<Pet>(m, \"Pet\", nb::dynamic_attr())\n    .def(nb::init<>())\n    .def_rw(\"name\", &Pet::name);\n```\n\n----------------------------------------\n\nTITLE: Registering a Class with Intrusive Reference Counting in nanobind\nDESCRIPTION: Code showing how to bind a C++ class with intrusive reference counting to Python using the intrusive_ptr annotation to inform instances about Python ownership.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/ownership_adv.rst#2025-04-17_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\nnb::class_<Object>(\n  m, \"Object\",\n  nb::intrusive_ptr<Object>(\n      [](Object *o, PyObject *po) noexcept { o->set_self_py(po); }));\n```\n\n----------------------------------------\n\nTITLE: Building a Basic nanobind Extension with Bazel\nDESCRIPTION: Demonstrates how to declare and build a simple nanobind extension module using the nanobind_extension rule in a BUILD file.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/bazel.rst#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# In a BUILD file, e.g. my_project/BUILD\nload(\"@nanobind_bazel//:build_defs.bzl\", \"nanobind_extension\")\n\nnanobind_extension(\n    name = \"my_ext\",\n    srcs = [\"my_ext.cpp\"],\n)\n```\n\n----------------------------------------\n\nTITLE: Runtime specialization of ndarray views in C++\nDESCRIPTION: This snippet demonstrates how to create specialized views at runtime, allowing a function to handle different array types efficiently based on runtime checks.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/ndarray.rst#2025-04-17_snippet_14\n\nLANGUAGE: C++\nCODE:\n```\nvoid fill(nb::ndarray<nb::c_contig, nb::device::cpu> arg) {\n    if (arg.dtype() == nb::dtype<float>() && arg.ndim() == 2) {\n        auto v = arg.view<float, nb::ndim<2>>(); // <-- new!\n\n        for (size_t i = 0; i < v.shape(0); ++i) {\n            for (size_t j = 0; j < v.shape(1); ++j) {\n                v(i, j) = /* ... */;\n            }\n        }\n     } else { /* ... */ }\n}\n```\n\n----------------------------------------\n\nTITLE: Binding Function with Implicit Type Conversion in C++\nDESCRIPTION: Shows how to bind a C++ function that accepts a float argument, demonstrating implicit conversion from int to float in Python calls.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/functions.rst#2025-04-17_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nm.def(\"double\", [](float x) { return 2.f * x; });\n```\n\n----------------------------------------\n\nTITLE: Creating Implicit Conversion Constructors in nanobind\nDESCRIPTION: Shows how to implement constructors that support implicit conversion from another type. The example demonstrates both the high-level init_implicit approach and the equivalent lower-level implementation.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_25\n\nLANGUAGE: cpp\nCODE:\n```\nnb::class_<MyType>(m, \"MyType\")\n    .def(nb::init_implicit<const char*>());\n```\n\nLANGUAGE: cpp\nCODE:\n```\nnb::class_<MyType>(m, \"MyType\")\n    .def(\"__init__\",\n         [](MyType* t, const char* arg0) {\n             new (t) MyType(arg0);\n         });\n\nnb::implicitly_convertible<const char*, MyType>();\n```\n\n----------------------------------------\n\nTITLE: Copy Return Value Policy Example\nDESCRIPTION: Shows how to safely return a reference to a C++ instance by making a copy that will be owned by Python.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/ownership.rst#2025-04-17_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\nstruct A {\n   B &b() { /* .. unknown code .. */ }\n};\n\nnb::class_<A>(m, \"A\")\n   .def(\"b\", &A::b, nb::rv_policy::copy);\n```\n\n----------------------------------------\n\nTITLE: Using nanobind's Intrusive Counter Implementation\nDESCRIPTION: Example of using nanobind's built-in intrusive_counter class for efficient reference counting that supports both C++ and Python-managed lifetimes.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/ownership.rst#2025-04-17_snippet_12\n\nLANGUAGE: cpp\nCODE:\n```\n#include <nanobind/intrusive/counter.h>\n\nclass Object {\n...\nprivate:\n    intrusive_counter m_ref_count;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining and Returning ndarray in C++ with nanobind\nDESCRIPTION: Demonstrates how to define and return an ndarray with specific template arguments for shape, memory order, device type, framework, and data type.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/changelog.rst#2025-04-17_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\nusing Array = nb::ndarray<float, nb::numpy, nb::shape<4, 4>, nb::f_contig>;\n\nstruct Matrix4f {\n    float m[4][4];\n    Array data() { return Array(m); }\n};\n\nnb::class_<Matrix4f>(m, \"Matrix4f\")\n    .def(\"data\", &Matrix4f::data, nb::rv_policy::reference_internal);\n```\n\n----------------------------------------\n\nTITLE: Generating Type Stubs for nanobind Extensions with Bazel\nDESCRIPTION: Shows how to set up automatic stub generation for a nanobind extension using the nanobind_stubgen macro to create Python typing stubs.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/bazel.rst#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Same as before in a BUILD file\nload(\n    \"@nanobind_bazel//:build_defs.bzl\",\n    \"nanobind_extension\",\n    \"nanobind_stubgen\",\n)\n\nnanobind_extension(\n    name = \"my_ext\",\n    srcs = [\"my_ext.cpp\"],\n)\n\nnanobind_stubgen(\n    name = \"my_ext_stubgen\",\n    module = \":my_ext\",\n)\n```\n\n----------------------------------------\n\nTITLE: Verifying Instance Properties in Nanobind\nDESCRIPTION: Shows how to check that an instance is managed by nanobind, has the correct type, and verify its initialization state using inst_check() and inst_ready().\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/lowlevel.rst#2025-04-17_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\nassert(nb::inst_check(py_inst) &&\n       py_inst.type().is(py_type) &&\n       !nb::inst_ready(py_inst));\n```\n\n----------------------------------------\n\nTITLE: Creating Generic Type Wrapper in nanobind C++\nDESCRIPTION: Example showing how to create a generic wrapper class with type parameter T using nanobind. Demonstrates initialization and getter method with proper type signatures.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/typing.rst#2025-04-17_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\nnb::class_<Wrapper> wrapper(m, \"Wrapper\", nb::is_generic(),\n                                   nb::sig(\"class Wrapper(typing.Generic[T])\"))\n           .def(nb::init<nb::object>(),\n                nb::sig(\"def __init__(self, arg: T, /) -> None\"))\n           .def(\"get\", [](Wrapper &w) { return w.value; },\n                nb::sig(\"def get(self, /) -> T\"));\n```\n\n----------------------------------------\n\nTITLE: Creating Matrix View as ndarray in C++\nDESCRIPTION: Class definition with a view method that creates a 44 column-major NumPy array view into a Matrix4f instance, demonstrating returning ndarrays from C++ to Python.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/ndarray.rst#2025-04-17_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\nstruct Matrix4f { float m[4][4] { }; };\n\nusing Array = nb::ndarray<float, nb::numpy, nb::shape<4, 4>, nb::f_contig>;\n\nnb::class_<Matrix4f>(m, \"Matrix4f\")\n    .def(nb::init<>())\n    .def(\"view\",\n         [](Matrix4f &m){ return Array(data); },\n         nb::rv_policy::reference_internal);\n```\n\n----------------------------------------\n\nTITLE: Adding Supplemental Data to a Python Type in nanobind\nDESCRIPTION: Demonstrates how to add supplemental metadata to a Python class using nb::type_supplement<T>. The example adds a 'stored_on_gpu' flag to a tensor class type metadata.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/lowlevel.rst#2025-04-17_snippet_13\n\nLANGUAGE: cpp\nCODE:\n```\nMyTensorMedadata &supplement = nb::type_supplement<MyTensorMedadata>(cls);\nsupplement.stored_on_gpu = true;\n```\n\n----------------------------------------\n\nTITLE: Registering Exception Translator in NanoBind C++\nDESCRIPTION: Example showing how to register a custom exception translator that converts a C++ ZeroDivisionException into a Python ZeroDivisionError. The translator is registered using the register_exception_translator function.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\nregister_exception_translator(\n    [](const std::exception_ptr &p, void * /*payload*/) {\n        try {\n            std::rethrow_exception(p);\n        } catch (const ZeroDivisionException &e) {\n            PyErr_SetString(PyExc_ZeroDivisionError, e.what());\n        }\n    }, nullptr /*payload*/);\n```\n\n----------------------------------------\n\nTITLE: Argument Locking in nanobind Method Bindings\nDESCRIPTION: This C++ code snippet shows how to use argument locking in nanobind method bindings to ensure thread-safety without modifying the underlying class implementation.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/free_threaded.rst#2025-04-17_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\nstruct Counter {\n    int value = 0;\n\n    void inc() { value++; }\n    void merge(Counter &other) {\n        value += other.value;\n        other.value = 0;\n    }\n};\n\nnb::class_<Counter>(m, \"Counter\")\n    .def(\"inc\", &Counter::inc, nb::lock_self())\n    .def(\"merge\", &Counter::merge, nb::lock_self(), \"other\"_a.lock())\n    .def_ro(\"value\", &Counter::value);\n```\n\n----------------------------------------\n\nTITLE: Example of Different Eigen Parameter Types\nDESCRIPTION: Demonstrates three different ways to accept Eigen matrices as function parameters, with different trade-offs regarding copying behavior. The DRef variant supports any memory layout without copying.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/eigen.rst#2025-04-17_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\nvoid f1(const Eigen::MatrixXf &x) { ... }\nvoid f2(const Eigen::Ref<Eigen::MatrixXf> &x) { ... }\nvoid f3(const nb::DRef<Eigen::MatrixXf> &x) { ... }\n```\n\n----------------------------------------\n\nTITLE: Exporting Values in nanobind Module\nDESCRIPTION: Shows how to export a simple value to the Python module using nanobind's attr function.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/basics.rst#2025-04-17_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nm.attr(\"the_answer\") = 42;\n```\n\n----------------------------------------\n\nTITLE: Implementing from_cpp() Method in Nanobind Type Caster\nDESCRIPTION: Guidelines for implementing the from_cpp() method in a Nanobind type caster. This method should handle C++ to Python conversion, set Python exceptions on failure, and return nullptr.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/porting.rst#2025-04-17_snippet_12\n\nLANGUAGE: C++\nCODE:\n```\nhandle from_cpp(const void *ptr, return_value_policy rvp, cleanup_list *cleanup) noexcept {\n    // Implementation\n    if (conversion_failed) {\n        PyErr_Format(PyExc_RuntimeError, \"Conversion failed\");\n        return nb::handle();\n    }\n    return handle(result);\n}\n```\n\n----------------------------------------\n\nTITLE: Using call_guard with GIL Release for Parallel Execution\nDESCRIPTION: Demonstrates how to release the Python GIL during execution of expensive functions using call_guard and gil_scoped_release to enable parallel execution from multiple Python threads.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_28\n\nLANGUAGE: cpp\nCODE:\n```\nm.def(\"expensive\", &expensive, nb::call_guard<nb::gil_scoped_release>());\n```\n\n----------------------------------------\n\nTITLE: Chaining Exceptions in C++ (raise from) (C++)\nDESCRIPTION: Shows how to implement Python's 'raise from' exception chaining behavior in C++ using nb::raise_from. This allows indicating that one exception was caused by another.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/exceptions.rst#2025-04-17_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\nnb::callable f = ...;\nint arg = 123;\ntry {\n    f(arg);\n} catch (nb::python_error &e) {\n    nb::raise_from(e, PyExc_RuntimeError, \"Could not call 'f' with %i\", arg);\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Type Metadata in Nanobind\nDESCRIPTION: Shows how to access size, alignment, and type information for a bound C++ type using the type_size(), type_align(), and type_info() functions.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/lowlevel.rst#2025-04-17_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nassert(nb::type_size(py_type) == sizeof(MyClass) &&\n       nb::type_align(py_type) == alignof(MyClass) &&\n       nb::type_info(py_type) == typeid(MyClass));\n```\n\n----------------------------------------\n\nTITLE: Copy and Move Construction in Nanobind\nDESCRIPTION: Demonstrates how to copy or move-construct a nanobind instance from another instance using nb::inst_copy() and nb::inst_move().\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/lowlevel.rst#2025-04-17_snippet_9\n\nLANGUAGE: cpp\nCODE:\n```\nif (copy_instance)\n    nb::inst_copy(/* dst = */ py_inst, /* src = */ some_other_instance);\nelse\n    nb::inst_move(/* dst = */ py_inst, /* src = */ some_other_instance);\n```\n\n----------------------------------------\n\nTITLE: Implementing custom constructors in nanobind\nDESCRIPTION: Shows nanobind's approach to custom constructors using in-place construction with placement new.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/porting.rst#2025-04-17_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\nnb::class_<MyType>(m, \"MyType\")\n    .def(\"__init__\", [](MyType *t) { new (t) MyType(...); });\n```\n\n----------------------------------------\n\nTITLE: Thread-Safe Counter Implementation Using nanobind's ft_mutex\nDESCRIPTION: This C++ code snippet demonstrates a thread-safe implementation of the Counter class using nanobind's ft_mutex and ft_lock_guard for synchronization.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/free_threaded.rst#2025-04-17_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\nstruct Counter {\n    int value = 0;\n    nb::ft_mutex mutex;\n\n    void inc() {\n        nb::ft_lock_guard guard(mutex);\n        value++;\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Exposing C++ Getter as Python Property\nDESCRIPTION: This example demonstrates how to use def_prop_ro to expose a C++ getter as a more Pythonic property in Python.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_17\n\nLANGUAGE: cpp\nCODE:\n```\nclass A {\npublic:\n    A(int value) : m_value(value) { }\n    int value() const { return m_value; }\nprivate:\n    int m_value;\n};\n\nnb::class_<A>(m, \"A\")\n    .def(nb::init<int>())\n    .def_prop_ro(\"value\",\n        [](A &t) { return t.value() ; });\n```\n\n----------------------------------------\n\nTITLE: Using typed with callable for Function Signature Annotations\nDESCRIPTION: Special form of nb::typed that produces Python callable signatures with specific parameter and return types for improved type checking.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/changelog.rst#2025-04-17_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nnb::typed<nb::callable, R(Args...)>\n```\n\nLANGUAGE: cpp\nCODE:\n```\nnb::typed<nb::callable, R(...)>\n```\n\n----------------------------------------\n\nTITLE: Using parameterized types with nb::typed\nDESCRIPTION: Demonstrates how to use the nb::typed template to generate parameterized type annotations for function arguments and return values.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/typing.rst#2025-04-17_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\nm.def(\"f\", [](nb::typed<nb::mapping, nb::str, int> arg)\n            -> nb::typed<nb::list, int> { ... });\n```\n\n----------------------------------------\n\nTITLE: Verifying Type Lookup Success in Nanobind\nDESCRIPTION: Shows how to check that a type lookup succeeded and represents a nanobind-owned type using is_valid() and nb::type_check().\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/lowlevel.rst#2025-04-17_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nassert(py_type.is_valid() && nb::type_check(py_type));\n```\n\n----------------------------------------\n\nTITLE: Preventing Implicit Type Conversion with noconvert()\nDESCRIPTION: Example of binding a function with the noconvert() option to prevent implicit type conversions. This raises a TypeError when input arrays don't match the expected type exactly.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/eigen.rst#2025-04-17_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\nm.def(\"f1\", &f1, nb::arg(\"x\").noconvert());\n```\n\n----------------------------------------\n\nTITLE: Replacing Instance Contents in Nanobind\nDESCRIPTION: Shows how to destruct an initialized instance and replace it with the contents of another by copying or moving using nb::inst_replace_copy() and nb::inst_replace_move().\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/lowlevel.rst#2025-04-17_snippet_10\n\nLANGUAGE: cpp\nCODE:\n```\nif (copy_instance)\n    nb::inst_replace_copy(/* dst = */ py_inst, /* src = */ some_other_instance);\nelse\n    nb::inst_replace_move(/* dst = */ py_inst, /* src = */ some_other_instance);\n```\n\n----------------------------------------\n\nTITLE: Configuring meson.build for stable ABI nanobind extension\nDESCRIPTION: This Meson configuration demonstrates how to build a nanobind extension targeting Python's stable ABI for version 3.12.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/meson.rst#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\npy.extension_module(\n  'my_module_name',\n  sources: ['path_to_module.cc'],\n  dependencies: [nanobind_dep],\n  install: true,\n  limited_api: '3.12',\n)\n```\n\n----------------------------------------\n\nTITLE: Exposing Static Field with Read-Write Access\nDESCRIPTION: This example demonstrates how to use def_rw_static to expose a static C++ field with read-write access in Python.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_19\n\nLANGUAGE: cpp\nCODE:\n```\nstruct A { inline static int value = 5; };\n\nnb::class_<A>(m, \"A\")\n    // Enable mutable access to the static field A::value\n    .def_rw_static(\"value\", &A::value);\n```\n\n----------------------------------------\n\nTITLE: Returning Multiple PyTorch Tensors with Shared Ownership\nDESCRIPTION: Example showing how to return multiple PyTorch tensors that share ownership of an underlying data structure. Uses a capsule with a deleter that manages the lifetime of multiple storage regions.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/ndarray.rst#2025-04-17_snippet_8\n\nLANGUAGE: cpp\nCODE:\n```\nm.def(\"return_multiple\", []() {\n       struct Temp {\n           std::vector<float> vec_1;\n           std::vector<float> vec_2;\n       };\n\n       Temp *temp = new Temp();\n       temp->vec_1 = std::move(...);\n       temp->vec_2 = std::move(...);\n\n       nb::capsule deleter(temp, [](void *p) noexcept {\n           delete (Temp *) p;\n       });\n\n       size_t size_1 = temp->vec_1.size();\n       size_t size_2 = temp->vec_2.size();\n\n       return std::make_pair(\n           nb::ndarray<nb::pytorch, float>(temp->vec_1.data(), { size_1 }, deleter),\n           nb::ndarray<nb::pytorch, float>(temp->vec_2.data(), { size_2 }, deleter)\n       );\n   });\n```\n\n----------------------------------------\n\nTITLE: Enabling Weak References for C++ Classes in Python with nanobind\nDESCRIPTION: This snippet demonstrates how to enable weak reference support for C++ classes when binding them to Python using nanobind. The nb::is_weak_referenceable tag is added to the class constructor.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/classes.rst#2025-04-17_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\nnb::class_<Pet>(m, \"Pet\", nb::is_weak_referenceable());\n```\n\n----------------------------------------\n\nTITLE: Implementing handle_t Type Wrapper in nanobind\nDESCRIPTION: Example of using the handle_t wrapper class to bind functions that accept Python objects representing instances of a specific C++ type. This demonstrates obtaining both the PyObject pointer and a reference to the wrapped C++ instance.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\n// Bind the class A\nclass A { int value; };\nnb::class_<A>(m, \"A\");\n\n// Bind a function that takes a Python object representing a 'A' instance\nm.def(\"process_a\", [](nb::handle_t<A> h) {\n   PyObject * a_py = h.ptr();   // PyObject* pointer to wrapper\n   A &a_cpp = nb::cast<A &>(h); // Reference to C++ instance\n});\n```\n\n----------------------------------------\n\nTITLE: Improved Binding Using typed<> Template for Type-Parameterized Lists\nDESCRIPTION: Enhanced version that uses nb::typed<nb::list, MyType> to indicate that the function expects a list of MyType objects. This improves the generated Python function signature without adding runtime checks.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_64\n\nLANGUAGE: cpp\nCODE:\n```\nm.def(\"f\", [](nb::typed<nb::list, MyType> l) {\n    for (nb::handle h : l) {\n        // ...\n    }\n});\n```\n\n----------------------------------------\n\nTITLE: Generating Type Stubs for nanobind Extension\nDESCRIPTION: Creates a Bazel target for generating Python typing stub files from a built nanobind extension. Provides options for customizing stub generation including output location and typing features.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_bazel.rst#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef nanobind_stubgen(\n    name,\n    module,\n    output_file = None,\n    output_directory = None,\n    imports = [],\n    pattern_file = None,\n    marker_file = None,\n    include_private_members = False,\n    exclude_docstrings = False,\n    recursive = False):\n```\n\n----------------------------------------\n\nTITLE: Binding Map with Reference Internal Policy in C++\nDESCRIPTION: Example of binding a std::map with reference_internal policy. While somewhat safer than with vectors due to node-based storage, this can still cause issues if referenced elements are removed.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_extra.rst#2025-04-17_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\nnb::bind_map<std::map<std::string, SomeValue>,\n              nb::rv_policy::reference_internal>(m, \"ExampleMap\");\n```\n\n----------------------------------------\n\nTITLE: Creating Nanobind Module with Domain Restriction in CMake\nDESCRIPTION: Demonstrates how to create a nanobind module with domain-restricted type visibility using CMake. The NB_DOMAIN parameter restricts inter-extension type visibility to extensions within the specified domain.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/faq.rst#2025-04-17_snippet_10\n\nLANGUAGE: cmake\nCODE:\n```\nnanobind_add_module(my_ext\n                       NB_DOMAIN my_project\n                       my_ext.cpp)\n```\n\n----------------------------------------\n\nTITLE: Implementing Pickling with State Methods in nanobind\nDESCRIPTION: Example showing how to implement pickling support for a C++ class using __getstate__ and __setstate__ methods. The state is represented as a tuple containing the object's name and age properties.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/classes.rst#2025-04-17_snippet_26\n\nLANGUAGE: cpp\nCODE:\n```\n#include <nanobind/stl/tuple.h>\n\nstruct Pet {\n     std::string name;\n     int age;\n     Pet(const std::string &name, int age) : name(name), age(age) { }\n};\n\nNB_MODULE(my_ext, m) {\n    nb::class_<Pet>(m, \"Pet\")\n       // ...\n       .def(\"__getstate__\", [](const Pet &pet) { return std::make_tuple(pet.name, pet.age); })\n       .def(\"__setstate__\", [](Pet &pet, const std::tuple<std::string, int> &state) {\n             new (&pet) Pet(\n                 std::get<0>(state),\n                 std::get<1>(state)\n             );\n       });\n }\n```\n\n----------------------------------------\n\nTITLE: Customizing class signature with collections.abc inheritance\nDESCRIPTION: Shows how to make a C++ class appear to inherit from a Python abstract base class in the generated stubs by using nb::sig.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/typing.rst#2025-04-17_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nnb::class_<IntVec>(m, \"IntVec\",\n                   nb::sig(\"class IntVec(collections.abc.Iterable[int])\"));\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Type Slot Functions in nanobind\nDESCRIPTION: Defines a custom type slot function that overrides Python's addition operation to perform multiplication instead, along with the PyType_Slot array configuration.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/lowlevel.rst#2025-04-17_snippet_15\n\nLANGUAGE: cpp\nCODE:\n```\nPyObject *myclass_tp_add(PyObject *a, PyObject *b) {\n    return PyNumber_Multiply(a, b);\n}\n\nPyType_Slot slots[] = {\n    { Py_nb_add, (void *) myclass_tp_add },\n    { 0, nullptr }\n};\n```\n\n----------------------------------------\n\nTITLE: Importing Python Modules with nanobind\nDESCRIPTION: Shows how to import a Python module (NumPy) using nanobind's module_::import_ method and access its attributes.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\nnb::module_ np = nb::module_::import_(\"numpy\");\nnb::object np_array = np.attr(\"array\");\n```\n\n----------------------------------------\n\nTITLE: Casting ndarray using .cast() method in C++\nDESCRIPTION: This snippet shows an improved way to cast a Vector3f ndarray using the .cast() method, which preserves the type signature and results in a more informative docstring.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/ndarray.rst#2025-04-17_snippet_11\n\nLANGUAGE: C++\nCODE:\n```\nusing Vector3f = nb::ndarray<float, nb::numpy, nb::shape<3>>;\nm.def(\"return_vec3\", []{\n    float data[] { 1, 2, 3 };\n    // Perfect.\n    return Vector3f(data).cast();\n});\n```\n\n----------------------------------------\n\nTITLE: Keyword-Only Parameters Example in nanobind\nDESCRIPTION: Example showing how to mark function parameters as keyword-only using the kw_only annotation with named arguments.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_10\n\nLANGUAGE: cpp\nCODE:\n```\nint some_func(int one, const char* two);\n\nm.def(\"some_func\", &some_func,\n        nb::arg(\"one\"), nb::kw_only(), nb::arg(\"two\"));\n```\n\n----------------------------------------\n\nTITLE: Referencing Existing C++ Instances in Nanobind\nDESCRIPTION: Demonstrates how to wrap existing C++ instances using nb::inst_take_ownership() and nb::inst_reference() functions.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/lowlevel.rst#2025-04-17_snippet_11\n\nLANGUAGE: cpp\nCODE:\n```\nMyClass *inst = new MyClass();\n\n// Transfer ownership of 'inst' to Python (which will use a delete\n// expression to free it when the Python instance is garbage collected)\nnb::object py_inst = nb::inst_take_ownership(py_type, inst);\n\n// We can also wrap C++ instances that should not be destructed since\n// they represent offsets into another data structure. In this case,\n// the optional 'parent' parameter ensures that 'py_inst' remains alive\n// while 'py_subinst' exists to prevent undefined behavior.\nnb::object py_subinst = nb::inst_reference(\n    py_field_type, &inst->field, /* parent = */ py_inst);\n```\n\n----------------------------------------\n\nTITLE: Shorthand Operator Binding in nanobind\nDESCRIPTION: Example showing how nb::self syntax expands to a lambda function that calls the corresponding C++ operator. This syntax simplifies binding operators in nanobind.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/classes.rst#2025-04-17_snippet_13\n\nLANGUAGE: cpp\nCODE:\n```\n.def(nb::self * float())\n```\n\n----------------------------------------\n\nTITLE: Template Class Definitions for Binding Example\nDESCRIPTION: Example of template classes that will be used to demonstrate binding templated classes in nanobind. Shows a PetHouse template class with a pet type parameter.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/classes.rst#2025-04-17_snippet_19\n\nLANGUAGE: cpp\nCODE:\n```\nstruct Cat {};\nstruct Dog {};\n\ntemplate <typename PetType> struct PetHouse {\n    PetHouse(PetType& pet);\n    PetType& get();\n};\n```\n\n----------------------------------------\n\nTITLE: Including std::shared_ptr Support in nanobind\nDESCRIPTION: Code snippet showing how to include shared pointer support in nanobind applications. Shared pointers allow for shared ownership between C++ and Python.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/ownership.rst#2025-04-17_snippet_10\n\nLANGUAGE: cpp\nCODE:\n```\n#include <nanobind/stl/shared_ptr.h>\n```\n\n----------------------------------------\n\nTITLE: Using In-place Operations with Vector Elements in Python\nDESCRIPTION: Example of safely modifying vector elements using in-place operations in Python, which automatically performs array assignment and prevents reference issues.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_extra.rst#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nv[i] += 5\n```\n\n----------------------------------------\n\nTITLE: Printing C-Style String in nanobind\nDESCRIPTION: Function to invoke Python's print() function to print a null-terminated C-style string with UTF-8 encoding, with optional line ending and file handle parameters.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_56\n\nLANGUAGE: cpp\nCODE:\n```\nvoid print(const char * str, handle end = handle(), handle file = handle())\n```\n\n----------------------------------------\n\nTITLE: Customizing Type Slots with nb::type_slots() in nanobind\nDESCRIPTION: Shows how to use low-level type slots to customize type behavior. This example overrides the addition operator to perform multiplication instead.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/lowlevel.rst#2025-04-17_snippet_14\n\nLANGUAGE: cpp\nCODE:\n```\nnb::class_<MyClass>(m, \"MyClass\", nb::type_slots(slots));\n```\n\n----------------------------------------\n\nTITLE: Optimizing ndarray access with views in C++\nDESCRIPTION: This snippet shows how to use ndarray::view() to create a fast array view, which can improve performance by enabling compiler optimizations when accessing array elements.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/ndarray.rst#2025-04-17_snippet_13\n\nLANGUAGE: C++\nCODE:\n```\nvoid fill(nb::ndarray<float, nb::ndim<2>, nb::c_contig, nb::device::cpu> arg) {\n    auto v = arg.view(); // <-- new!\n\n    for (size_t i = 0; i < v.shape(0); ++i) // Important; use 'v' instead of 'arg' everywhere in loop\n        for (size_t j = 0; j < v.shape(1); ++j)\n            v(i, j) = /* ... */;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Exception Handling in noexcept Function with nanobind\nDESCRIPTION: Shows implementation of a noexcept function that properly handles both Python and C++ exceptions. Python errors are discarded as unraisable using the __func__ magic variable, while C++ exceptions are logged through a third-party logging system.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/exceptions.rst#2025-04-17_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\nvoid nonthrowing_func() noexcept(true) {\n    try {\n        // ...\n    } catch (nb::python_error &e) {\n        // Discard the Python error using Python APIs, using the C++ magic\n        // variable __func__. Python already knows the type and value and of the\n        // exception object.\n        e.discard_as_unraisable(__func__);\n    } catch (const std::exception &e) {\n        // Log and discard C++ exceptions.\n        third_party::log(e);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Exposing Static Field with Read-Only Access\nDESCRIPTION: This snippet shows how to use def_ro_static to expose a static C++ field with read-only access in Python.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_20\n\nLANGUAGE: cpp\nCODE:\n```\nstruct A { inline static int value = 5; };\n\nnb::class_<A>(m, \"A\")\n    // Enable read-only access to the static field A::value\n    .def_ro_static(\"value\", &A::value);\n```\n\n----------------------------------------\n\nTITLE: Taking Ownership of C++ Instance in nanobind\nDESCRIPTION: Function that creates a Python object wrapping an existing C++ instance and takes ownership of it. Both ready and destruct flags are set to true. Similar to using rv_policy::take_ownership.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_37\n\nLANGUAGE: cpp\nCODE:\n```\nobject inst_take_ownership(handle h, void * p)\n```\n\n----------------------------------------\n\nTITLE: Using nb::cast with Reference Internal Return Value Policy in C++\nDESCRIPTION: Example showing how to use nb::cast with the reference_internal return value policy, which allows specifying an owner object.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/changelog.rst#2025-04-17_snippet_9\n\nLANGUAGE: C++\nCODE:\n```\nnb::cast<T>(value, nb::rv_policy::reference_internal, owner)\n```\n\n----------------------------------------\n\nTITLE: Getting None Value in nanobind\nDESCRIPTION: Function to get an object representing the Python None value.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_58\n\nLANGUAGE: cpp\nCODE:\n```\nobject none()\n```\n\n----------------------------------------\n\nTITLE: Creating Custom def_visitor for Reusable Binding Logic\nDESCRIPTION: Shows how to create custom def_visitor implementations that can be reused across multiple class bindings to apply the same set of operations.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_27\n\nLANGUAGE: cpp\nCODE:\n```\nstruct my_ops : nb::def_visitor<my_ops> {\n    template <typename Class, typename... Extra>\n    void execute(Class &cl, const Extra&... extra) {\n        /* series of def() statements on `cl`, which is a nb::class_ */\n    }\n};\n```\n\nLANGUAGE: cpp\nCODE:\n```\nnb::class_<MyType>(m, \"MyType\")\n    .def(\"some_method\", &MyType::some_method)\n    .def(my_ops())\n    ... ;\n```\n\n----------------------------------------\n\nTITLE: Returning Eigen Expression with Explicit Return Type\nDESCRIPTION: Example of safely returning an Eigen expression by specifying an explicit return type. This forces evaluation of the expression into a container that owns the storage, avoiding undefined behavior.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/eigen.rst#2025-04-17_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nm.def(\"sum\", [](Eigen::Vector3f a, Eigen::Vector3d b) -> Eigen::Vector3d { return a + b; });\n```\n\n----------------------------------------\n\nTITLE: Creating Read-Only Static Property in Python\nDESCRIPTION: This snippet shows how to use def_prop_ro_static to create a read-only static property in Python from a C++ getter function.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_22\n\nLANGUAGE: cpp\nCODE:\n```\nclass A {\npublic:\n   static int value() { return s_value; }\nprivate:\n   inline static int s_value = 5;\n};\n\nnb::class_<A>(m, \"A\")\n    .def_prop_ro_static(\"value\",\n        [](nb::handle /*unused*/) { return A::value() ; });\n```\n\n----------------------------------------\n\nTITLE: Creating Mutable Static Property in Python\nDESCRIPTION: This example demonstrates how to use def_prop_rw_static to create a mutable static property in Python from C++ getter and setter functions.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_21\n\nLANGUAGE: cpp\nCODE:\n```\nclass A {\npublic:\n   static void set_value(int value) { s_value = value; }\n   static int value() { return s_value; }\nprivate:\n   inline static int s_value = 5;\n};\n\nnb::class_<A>(m, \"A\")\n    .def_prop_rw_static(\"value\",\n        [](nb::handle /*unused*/) { return A::value() ; },\n        [](nb::handle /*unused*/, int value) { A::set_value(value); });\n```\n\n----------------------------------------\n\nTITLE: Implementing Signature Override for Static Type Checking in C++\nDESCRIPTION: This snippet demonstrates how to use nb::sig to override the default signature of a C++ function binding. It creates an overload that should only be called with an integer literal value of 1, allowing static type checkers to ensure this condition at compile-time.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/why.rst#2025-04-17_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nm.def(\"f\",\n       [](int arg) {\n           if (arg != 1)\n              nb::raise(\"invalid input\");\n           return arg;\n       },\n       nb::sig(\"def f(arg: typing.Literal[1], /) -> int\"));\n```\n\n----------------------------------------\n\nTITLE: Move Return Value Policy Example\nDESCRIPTION: Demonstrates using move semantics to efficiently transfer a C++ instance returned by value to Python.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/ownership.rst#2025-04-17_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\nstruct A {\n   B b() { return B(...); }\n};\n\nnb::class_<A>(m, \"A\")\n   .def(\"b\", &A::b, nb::rv_policy::move);\n```\n\n----------------------------------------\n\nTITLE: Getting Type Name in nanobind\nDESCRIPTION: Function to retrieve the full module-qualified name of a type object as a Python string.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_30\n\nLANGUAGE: cpp\nCODE:\n```\nstr type_name(handle h)\n```\n\n----------------------------------------\n\nTITLE: Getting Python Builtins in nanobind\nDESCRIPTION: Function to retrieve the Python __builtins__ dictionary.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_59\n\nLANGUAGE: cpp\nCODE:\n```\ndict builtins()\n```\n\n----------------------------------------\n\nTITLE: Binding C++ Function with Variadic Arguments\nDESCRIPTION: Shows how to bind a C++ function that accepts arbitrary positional and keyword arguments using nb::args and nb::kwargs.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/functions.rst#2025-04-17_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\nvoid generic(nb::args args, nb::kwargs kwargs) {\n    for (auto v: args)\n        nb::print(nb::str(\"Positional: {}\").format(v));\n    for (auto kv: kwargs)\n        nb::print(nb::str(\"Keyword: {} -> {}\").format(kv.first, kv.second));\n}\n\n// Binding code\nm.def(\"generic\", &generic);\n```\n\n----------------------------------------\n\nTITLE: Checking nanobind Initialization Status\nDESCRIPTION: Function to check if nanobind is initialized and ready for use. Returns false when the Python interpreter has shut down and nanobind internal data structures are destroyed.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_53\n\nLANGUAGE: cpp\nCODE:\n```\ninline bool is_alive() noexcept\n```\n\n----------------------------------------\n\nTITLE: Disabling Leak Warnings in nanobind C++ Module\nDESCRIPTION: Code snippet showing how to disable nanobind's reference leak warnings by calling nb::set_leak_warnings(false) in the module initialization function.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/refleaks.rst#2025-04-17_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nNB_MODULE(my_ext, m) {\n    nb::set_leak_warnings(false);\n    // ...\n }\n```\n\n----------------------------------------\n\nTITLE: Using nanobind's intrusive_base Class for Reference Counting\nDESCRIPTION: A simpler approach to intrusive reference counting by inheriting from nanobind's intrusive_base class, which provides all the necessary reference counting functionality.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/ownership_adv.rst#2025-04-17_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nclass Object : public nb::intrusive_base {\npublic:\n    // ...\n};\n```\n\n----------------------------------------\n\nTITLE: Destructing Instance in nanobind\nDESCRIPTION: Function to destruct an instance by calling the C++ destructor if the destruct flag is set, then setting both ready and destruct flags to false.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_43\n\nLANGUAGE: cpp\nCODE:\n```\nvoid inst_destruct(handle h)\n```\n\n----------------------------------------\n\nTITLE: Configuring meson.build for nanobind extension module\nDESCRIPTION: This Meson build configuration sets up a C++ project with Python and nanobind dependencies, and defines an extension module build.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/meson.rst#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nproject(\n  'my_project_name',\n  'cpp',\n  version: '0.0.1',\n)\n\npy = import('python').find_installation()\nnanobind_dep = dependency('nanobind', static: true)\npy.extension_module(\n  'my_module_name',\n  sources: ['path_to_module.cc'],\n  dependencies: [nanobind_dep],\n  install: true,\n)\n```\n\n----------------------------------------\n\nTITLE: Expanding Args and Kwargs in C++ Function Calls\nDESCRIPTION: Demonstrates how to expand standard containers to add positional and keyword arguments to a Python call from C++.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/functions.rst#2025-04-17_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\nnb::object my_call(nb::callable callable) {\n    nb::list list;\n    nb::dict dict;\n\n    list.append(\"positional\");\n    dict[\"keyword\"] = \"value\";\n\n    return callable(1, *list, **dict);\n}\n\nNB_MODULE(my_ext, m) {\n    m.def(\"my_call\", &my_call);\n}\n```\n\n----------------------------------------\n\nTITLE: Registering nonstandard arithmetic type in C++\nDESCRIPTION: This snippet demonstrates how to register a nonstandard arithmetic type (__fp16) with nanobind by creating a partial overload of nanobind::detail::dtype_traits.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/ndarray.rst#2025-04-17_snippet_12\n\nLANGUAGE: C++\nCODE:\n```\nnamespace nanobind::detail {\n    template <> struct dtype_traits<__fp16> {\n        static constexpr dlpack::dtype value {\n            (uint8_t) dlpack::dtype_code::Float, // type code\n            16, // size in bits\n            1   // lanes (simd), usually set to 1\n        };\n        static constexpr auto name = const_name(\"float16\");\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Instance Type in nanobind\nDESCRIPTION: Function to check if a handle represents an instance of a type that was previously bound using class_.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_32\n\nLANGUAGE: cpp\nCODE:\n```\nbool inst_check(handle h)\n```\n\n----------------------------------------\n\nTITLE: Creating nanobind Test Target\nDESCRIPTION: Defines a Bazel target for C++ tests that depend on nanobind. Corresponds to Bazel's cc_test rule with nanobind integration.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_bazel.rst#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef nanobind_test(\n    name,\n    copts = [],\n    deps = [],\n    **kwargs):\n```\n\n----------------------------------------\n\nTITLE: Enabling Free-Threading in CMake for nanobind Module\nDESCRIPTION: This CMake snippet shows how to enable free-threading support when building a nanobind module using the nanobind_add_module command.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/free_threaded.rst#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nnanobind_add_module(\n  my_ext                   # Target name\n  FREE_THREADED            # Opt into free-threading\n  my_ext.h                 # Source code files below\n  my_ext.cpp)\n```\n\n----------------------------------------\n\nTITLE: Setting Instance State in nanobind\nDESCRIPTION: Function to separately set the ready and destruct flags of an instance.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_42\n\nLANGUAGE: cpp\nCODE:\n```\nvoid inst_set_state(handle h, bool ready, bool destruct)\n```\n\n----------------------------------------\n\nTITLE: Tag-based Polymorphism Class Hierarchy\nDESCRIPTION: Implementation of a class hierarchy using tag-based polymorphism with an enum to identify different types. This example shows a Pet base class with Dog and Cat derived classes, each identified by a PetKind enum value.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/classes.rst#2025-04-17_snippet_23\n\nLANGUAGE: cpp\nCODE:\n```\n#include <nanobind/nanobind.h>\n\nnamespace nb = nanobind;\n\nenum class PetKind { Cat, Dog };\n\nstruct Pet { const PetKind kind; };\nstruct Dog : Pet { Dog() : Pet{PetKind::Dog} { } };\nstruct Cat : Pet { Cat() : Pet{PetKind::Cat} { } };\n\nnamespace nb = nanobind;\n\nNB_MODULE(my_ext, m) {\n    nb::class_<Pet>(m, \"Pet\");\n    nb::class_<Dog>(m, \"Dog\");\n    nb::class_<Cat>(m, \"Cat\");\n\n    nb::enum_<PetKind>(m, \"PetKind\")\n        .value(\"Cat\", PetKind::Cat)\n        .value(\"Dog\", PetKind::Dog);\n\n    m.def(\"make_pet\", [](PetKind kind) -> Pet* {\n        switch (kind) {\n            case PetKind::Dog: return new Dog();\n            case PetKind::Cat: return new Cat();\n        }\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Including Sparse Eigen Types in nanobind\nDESCRIPTION: Include directive needed to enable exchange of sparse Eigen types between C++ and Python. This allows conversion between Eigen::SparseMatrix and scipy.sparse.csr_matrix or scipy.sparse.csc_matrix.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/eigen.rst#2025-04-17_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\n#include <nanobind/eigen/sparse.h>\n```\n\n----------------------------------------\n\nTITLE: Using nb::sig with operator overload for type compatibility\nDESCRIPTION: Shows how to use nb::sig to override the default signature of an equality operator to make it compatible with the object base class for static type checking.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/typing.rst#2025-04-17_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nnb::class_<Int>(m, \"Int\")\n    .def(nb::self == nb::self,\n         nb::sig(\"def __eq__(self, arg: object, /) -> bool\"));\n```\n\n----------------------------------------\n\nTITLE: Equivalent Implementation Using Built-in Operator Methods in nanobind\nDESCRIPTION: Shows a simpler alternative to the custom type slot approach by using nanobind's built-in operator overloading capabilities with lambda functions.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/lowlevel.rst#2025-04-17_snippet_16\n\nLANGUAGE: cpp\nCODE:\n```\nnb::class_<MyClass>(m, \"MyClass\")\n    .def(\"__add__\",\n         [](const MyClass &a, const MyClass &b) { return a * b; },\n         nb::is_operator())\n```\n\n----------------------------------------\n\nTITLE: Reference Return Value Policy Example\nDESCRIPTION: Shows how to reference a global C++ variable without transferring ownership, which requires careful lifetime management.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/ownership.rst#2025-04-17_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\nData data; // This is a global variable\n\nm.def(\"get_data\", []{ return &data; }, nb::rv_policy::reference)\n```\n\n----------------------------------------\n\nTITLE: Using nanobind_add_module with LTO in CMake\nDESCRIPTION: Shows how to use the high-level nanobind_add_module command to create a Python extension module with Link Time Optimization (LTO) enabled.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_cmake.rst#2025-04-17_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nnanobind_add_module(my_ext NB_SHARED LTO my_ext.cpp)\n```\n\n----------------------------------------\n\nTITLE: Including Dense Eigen Types in nanobind\nDESCRIPTION: Include directive needed to enable exchange of dense Eigen types (Matrix, Array, Vector, etc.) between C++ and Python. This allows bidirectional conversion between Eigen types and NumPy arrays.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/eigen.rst#2025-04-17_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#include <nanobind/eigen/dense.h>\n```\n\n----------------------------------------\n\nTITLE: Python Unique Pointer Usage Example\nDESCRIPTION: Python console example demonstrating the behavior of unique pointers in nanobind. Shows how attempting to use an object after its ownership has been transferred to C++ results in a runtime error.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/ownership.rst#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nPython 3.11.1 (main, Dec 23 2022, 09:28:24) [Clang 14.0.0 (clang-1400.0.29.202)] on darwin\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> import my_ext\n\n>>> x = my_ext.create()\n>>> my_ext.consume(x)\n\n>>> my_ext.consume(x)\n<stdin>:1: RuntimeWarning: nanobind: attempted to access an uninitialized instance of type 'my_ext.Data'!\n\nTypeError: consume(): incompatible function arguments. The following argument types are supported:\n    1. consume(arg: my_ext.Data, /) -> None\n\nInvoked with types: my_ext.Data\n```\n\n----------------------------------------\n\nTITLE: Accessing Instance Pointer in nanobind\nDESCRIPTION: Function to get a pointer to the underlying C++ instance from a Python object. Does not verify that the instance is actually of type T.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_33\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate <typename T> T * inst_ptr(handle h)\n```\n\n----------------------------------------\n\nTITLE: Declaring a Generic Class in C++\nDESCRIPTION: Example showing how to declare a class as generic using nb::is_generic(), allowing it to be parameterized in Python.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/changelog.rst#2025-04-17_snippet_12\n\nLANGUAGE: C++\nCODE:\n```\nnb::class_<MyType>(m, \"MyType\", nb::is_generic())\n```\n\n----------------------------------------\n\nTITLE: Implicit conversions in nanobind\nDESCRIPTION: Shows nanobind's preferred approach to specifying implicit conversions directly in the constructor declaration.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/porting.rst#2025-04-17_snippet_9\n\nLANGUAGE: cpp\nCODE:\n```\nnb::class_<MyType>(m, \"MyType\")\n    .def(nb::init_implicit<MyOtherType>());\n```\n\n----------------------------------------\n\nTITLE: Retrieving Type Supplement in nanobind\nDESCRIPTION: Function to retrieve supplemental data stored in a type object. The type parameter must match the exact type specified in the nb::supplement annotation used when creating the type.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_29\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate <typename T> T &type_supplement(handle h)\n```\n\n----------------------------------------\n\nTITLE: Template Function for Obtaining dtype from C++ Type\nDESCRIPTION: Function template that returns a populated instance of the dlpack::dtype structure given a scalar C++ arithmetic type, making it easy to specify the correct dtype for array creation.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_extra.rst#2025-04-17_snippet_15\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate <typename T> dlpack::dtype dtype()\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Build Type\nDESCRIPTION: Sets default build type to Release for optimal performance unless explicitly specified otherwise. Defines available build type options.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/building.rst#2025-04-17_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nif (NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)\n  set(CMAKE_BUILD_TYPE Release CACHE STRING \"Choose the type of build.\" FORCE)\n  set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS \"Debug\" \"Release\" \"MinSizeRel\" \"RelWithDebInfo\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Incorrect vs Correct way to use nb::find in tp_traverse\nDESCRIPTION: Comparison showing the incorrect way (using nb::object which holds a reference) versus the correct way (using nb::handle which doesn't increase the reference count) when implementing tp_traverse for free-threaded Python.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/refleaks.rst#2025-04-17_snippet_13\n\nLANGUAGE: cpp\nCODE:\n```\n// Incorrect - holds additional references\nnb::object value = nb::find(w->value);\nPy_VISIT(value.ptr());\n```\n\nLANGUAGE: cpp\nCODE:\n```\n// Correct - doesn't increase the reference count\nnb::handle value = nb::find(w->value);\nPy_VISIT(value.ptr());\n```\n\n----------------------------------------\n\nTITLE: Using a Higher-Order Function in Python\nDESCRIPTION: Shows how to use the bark_later method which returns a callable Python function. The function captures the Dog's name property and prints a message when called.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/basics.rst#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> f = d.bark_later()\n>>> f\n<nanobind.nb_func object at 0x10537c140>\n>>> f()\nCharlie: woof!\n```\n\n----------------------------------------\n\nTITLE: Allocating Uninitialized Instance in nanobind\nDESCRIPTION: Function to allocate an uninitialized object of a bound type. Both ready and destruct flags are set to false in the returned instance.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_34\n\nLANGUAGE: cpp\nCODE:\n```\nobject inst_alloc(handle h)\n```\n\n----------------------------------------\n\nTITLE: Casting ndarray to Specific Framework in C++\nDESCRIPTION: Shows how to use the new .cast() method on ndarray to force creation of a Python object with a specified target framework and return value policy.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/changelog.rst#2025-04-17_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\nndarray::cast()\n```\n\n----------------------------------------\n\nTITLE: Conditional Compilation for Free-Threaded Support in C++\nDESCRIPTION: This C++ code snippet demonstrates how to use preprocessor directives to conditionally compile code based on whether free-threading is enabled.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/free_threaded.rst#2025-04-17_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n#if !defined(NB_FREE_THREADED)\n... // simple GIL-protected code\n#else\n... // more complex thread-aware code\n#endif\n```\n\n----------------------------------------\n\nTITLE: Generating Python stubs with nanobind_add_stub\nDESCRIPTION: Demonstrates how to generate type stubs for a nanobind extension module.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_cmake.rst#2025-04-17_snippet_14\n\nLANGUAGE: cmake\nCODE:\n```\nnanobind_add_stub(\n    my_ext_stub\n    MODULE my_ext\n    OUTPUT my_ext.pyi\n    PYTHON_PATH $<TARGET_FILE_DIR:my_ext>\n    DEPENDS my_ext\n)\n```\n\n----------------------------------------\n\nTITLE: Creating Flag Enum Bindings in C++ with nanobind\nDESCRIPTION: Shows how to use the new nb::is_flag() annotation to create enum bindings that derive from enum.Flag or enum.IntFlag in Python.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/changelog.rst#2025-04-17_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\nnb::enum_<T>().def(nb::is_flag())\n```\n\n----------------------------------------\n\nTITLE: Suppressing Implicit Conversion in Function Bindings\nDESCRIPTION: Demonstrates how to use the .noconvert() annotation to suppress implicit type conversion when binding C++ functions to Python.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/functions.rst#2025-04-17_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nm.def(\"double\", [](float x) { return 2.f * x; }, nb::arg(\"x\").noconvert());\n```\n\n----------------------------------------\n\nTITLE: Class Member Reference Leak Example in C++\nDESCRIPTION: C++ code showing a common pattern that leads to reference leaks: a class with a nanobind::object member that can create cycles Python's garbage collector can't detect.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/refleaks.rst#2025-04-17_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\n#include <nanobind/nanobind.h>\n\nnamespace nb = nanobind;\n\nstruct Wrapper { nb::object value; };\n\nNB_MODULE(my_ext, m) {\n    nb::class_<Wrapper>(m, \"Wrapper\")\n        .def(nb::init<>())\n        .def_rw(\"value\", &Wrapper::value);\n}\n```\n\n----------------------------------------\n\nTITLE: Unsafe Counter Implementation in C++ with nanobind Bindings\nDESCRIPTION: This code snippet shows an unsafe implementation of a Counter class and its nanobind bindings, which can lead to race conditions in a free-threaded environment.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/free_threaded.rst#2025-04-17_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nstruct Counter {\n    int value = 0;\n    void inc() { value++; }\n};\n\nnb::class_<Counter>(m, \"Counter\")\n    .def(\"inc\", &Counter::inc)\n    .def_ro(\"value\", &Counter::value);\n```\n\n----------------------------------------\n\nTITLE: Updated shape specification example\nDESCRIPTION: Shows the change in specifying unconstrained array dimensions, replacing nb::any with -1\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/changelog.rst#2025-04-17_snippet_17\n\nLANGUAGE: C++\nCODE:\n```\nnb::shape<3, -1, 4>           // new way\nnb::shape<3, nb::any, 4>     // old way\n```\n\n----------------------------------------\n\nTITLE: Adding Module-level Docstring in nanobind\nDESCRIPTION: Demonstrates how to add a docstring to the entire Python extension module using nanobind.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/basics.rst#2025-04-17_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nm.doc() = \"A simple example python extension\";\n```\n\n----------------------------------------\n\nTITLE: Problematic Example of Ownership Transfer in nanobind\nDESCRIPTION: Demonstrates an incorrect binding that causes a segmentation fault due to improper ownership transfer of a non-heap-allocated object from C++ to Python.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/ownership.rst#2025-04-17_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#include <nanobind/nanobind.h>\nnamespace nb = nanobind;\n\nstruct Data { };\nData data; // Data global variable & function returning a pointer to it\nData *get_data() { return &data; }\n\nNB_MODULE(my_ext, m) {\n    nb::class_<Data>(m, \"Data\");\n\n    // KABOOM, calling this function will crash the Python interpreter\n    m.def(\"get_data\", &get_data);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring a Python Toolchain for Free-Threaded CPython\nDESCRIPTION: Demonstrates how to set up a Python toolchain in MODULE.bazel to support building extensions for free-threaded Python 3.13.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/bazel.rst#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nbazel_dep(name = \"rules_python\", version = \"1.0.0\")\n\npython = use_extension(\"@rules_python//python/extensions:python.bzl\", \"python\")\npython.toolchain(python_version = \"3.13\")\n```\n\n----------------------------------------\n\nTITLE: Including STL Vector Binding Support in nanobind\nDESCRIPTION: This directive imports functionality to expose std::vector variants in Python. The bind_vector function allows creating Python list-like objects backed by C++ vectors.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_extra.rst#2025-04-17_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n#include <nanobind/stl/bind_vector.h>\n```\n\n----------------------------------------\n\nTITLE: Overriding Class Signatures for Type Hints in C++\nDESCRIPTION: Example showing how to override a class signature to add type information such as implemented interfaces or base classes for better IDE support.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/changelog.rst#2025-04-17_snippet_14\n\nLANGUAGE: C++\nCODE:\n```\nusing IntVec = std::vector<int>;\n\nnb::class_<IntVec>(m, \"IntVec\",\n                   nb::sig(\"class IntVec(collections.abc.Iterable[int])\"));\n```\n\n----------------------------------------\n\nTITLE: Binding Static Method in C++\nDESCRIPTION: This snippet shows how to bind a static C++ method to a Python class using def_static.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_18\n\nLANGUAGE: cpp\nCODE:\n```\nstruct A {\n    static void f() { /*...*/ }\n};\n\nnb::class_<A>(m, \"A\")\n    .def_static(\"f\", &A::f);  // Bind the static method A::f\n```\n\n----------------------------------------\n\nTITLE: In-Place Construction of C++ Objects with Nanobind\nDESCRIPTION: Demonstrates how to use placement new to construct a C++ object in-place into memory allocated by nanobind.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/lowlevel.rst#2025-04-17_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\n// Get a C++ pointer to the uninitialized instance data\nMyClass *ptr = nb::inst_ptr<MyClass>(py_inst);\n\n// Perform an in-place construction of the C++ object at address 'ptr'\nnew (ptr) MyClass(/* constructor arguments go here */);\n```\n\n----------------------------------------\n\nTITLE: Alternative Method for Specifying Parent Type in nanobind\nDESCRIPTION: Demonstrates an alternative way to specify the parent type when binding classes with inheritance.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/classes.rst#2025-04-17_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nauto pet = nb::class_<Pet>(m, \"Pet\")\n   .def(nb::init<const std::string &>())\n   .def_rw(\"name\", &Pet::name);\n\nnb::class_<Dog>(m, \"Dog\", pet /* <- Parent type object */)\n    .def(nb::init<const std::string &>())\n    .def(\"bark\", &Dog::bark);\n```\n\n----------------------------------------\n\nTITLE: Example of Unsafe Map Element References in Python\nDESCRIPTION: Demonstrates how using reference semantics with map elements can lead to crashes if an element is removed after being referenced.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_extra.rst#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef unsafe_pop(map: ext.ExampleMap, key: str) -> ext.SomeValue:\n    value = map[key]\n    del map[key]\n    # Oops! `value` now points to a dangling element. Anything you\n    # do with it now is liable to crash the interpreter.\n    return value  # uh-oh...\n```\n\n----------------------------------------\n\nTITLE: Allocating Zero-Initialized Instance in nanobind\nDESCRIPTION: Function to allocate a zero-initialized object of a bound type. Both ready and destruct flags are set to true. Equivalent to calling inst_alloc followed by inst_zero.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_35\n\nLANGUAGE: cpp\nCODE:\n```\nobject inst_alloc_zero(handle h)\n```\n\n----------------------------------------\n\nTITLE: Creating Reference to Existing C++ Instance in nanobind\nDESCRIPTION: Function that creates a Python object wrapping an existing C++ instance. The ready flag is set to true and destruct flag to false. Similar to using rv_policy::reference in C++ object casting.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_36\n\nLANGUAGE: cpp\nCODE:\n```\nobject inst_reference(handle h, void * p, handle parent = handle())\n```\n\n----------------------------------------\n\nTITLE: Setting Leak Warnings in nanobind\nDESCRIPTION: Function to enable or disable warnings about nanobind instances, types, or functions that are still alive when the Python interpreter shuts down.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_51\n\nLANGUAGE: cpp\nCODE:\n```\nvoid set_leak_warnings(bool value) noexcept\n```\n\n----------------------------------------\n\nTITLE: Shared pointer binding in pybind11 vs nanobind\nDESCRIPTION: Compares how shared pointer holders are specified in pybind11 versus how they're handled in nanobind (which doesn't require explicit holder types).\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/porting.rst#2025-04-17_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\npy::class_<MyType, std::shared_ptr<MyType>>(m, \"MyType\")\n```\n\nLANGUAGE: cpp\nCODE:\n```\nnb::class_<MyType>(m, \"MyType\")\n```\n\n----------------------------------------\n\nTITLE: Marking Instances as Ready in Nanobind\nDESCRIPTION: Shows how to inform nanobind that an instance is fully constructed using nb::inst_mark_ready().\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/lowlevel.rst#2025-04-17_snippet_8\n\nLANGUAGE: cpp\nCODE:\n```\nnb::inst_mark_ready(py_inst);\nassert(nb::inst_ready(py_inst));\n```\n\n----------------------------------------\n\nTITLE: Using a Bound Class in Python\nDESCRIPTION: Demonstrates how to instantiate and use the bound Dog class in a Python interactive session. Shows creating an instance, accessing and modifying properties, and calling methods.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/basics.rst#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nPython 3.11.1 (main, Dec 23 2022, 09:28:24) [Clang 14.0.0 (clang-1400.0.29.202)] on darwin\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> import my_ext\n>>> d = my_ext.Dog('Max')\n>>> print(d)\n<my_ext.Dog object at 0x1044540f0>\n>>> d.name\n'Max'\n>>> d.name = 'Charlie'\n>>> d.bark()\n'Charlie: woof!'\n```\n\n----------------------------------------\n\nTITLE: Using for_getter and for_setter Annotations with Property Bindings in C++\nDESCRIPTION: Example showing how to use the for_getter and for_setter annotations to customize property bindings in a class. This allows specifying separate function signatures and docstrings for getters and setters.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_11\n\nLANGUAGE: cpp\nCODE:\n```\nnb::class_<MyClass>(m, \"MyClass\")\n  .def_prop_rw(\"value\", &MyClass::value,\n          nb::for_getter(nb::sig(\"def value(self, /) -> int\")),\n          nb::for_setter(nb::sig(\"def value(self, value: int, /) -> None\")),\n          nb::for_getter(\"docstring for getter\"),\n          nb::for_setter(\"docstring for setter\"));\n```\n\n----------------------------------------\n\nTITLE: Accessing Type Slots in nanobind\nDESCRIPTION: Function to get type object members that works consistently on heap and non-heap types across Python versions. Wraps PyType_GetSlot on Python 3.10+.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_31\n\nLANGUAGE: cpp\nCODE:\n```\nvoid * type_get_slot(handle h, int slot_id)\n```\n\n----------------------------------------\n\nTITLE: Marking Types as Implicitly Convertible in nanobind\nDESCRIPTION: Function to indicate that a source type is implicitly convertible to a target type that was previously bound via class_. The init_implicit interface is preferred for more compact code.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_62\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate <typename Source, typename Target> void implicitly_convertible()\n```\n\n----------------------------------------\n\nTITLE: Registering Type Slots with nanobind Class\nDESCRIPTION: Shows how to register the custom type slots with a nanobind class definition using the nb::type_slots parameter. This enables the Python garbage collector to properly handle reference cycles involving this class.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/refleaks.rst#2025-04-17_snippet_12\n\nLANGUAGE: cpp\nCODE:\n```\nnb::class_<Wrapper>(m, \"Wrapper\", nb::type_slots(slots))\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of Returning Array from Temporary Memory\nDESCRIPTION: Shows an incorrect example of returning an ndarray from stack-allocated memory, which can lead to use-after-free bugs since the array metadata is created during the function call but the array itself is created after the function returns.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/ndarray.rst#2025-04-17_snippet_9\n\nLANGUAGE: cpp\nCODE:\n```\nusing Vector3f = nb::ndarray<float, nb::numpy, nb::shape<3>>;\nm.def(\"return_vec3\", []{\n    float data[] { 1, 2, 3 };\n    // !!! BAD don't do this !!!\n    return Vector3f(data);\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing DLPack protocol for custom array types in C++\nDESCRIPTION: This snippet shows how to implement the __dlpack__ and __dlpack_device__ methods for a custom array type, enabling inter-framework data exchange using the DLPack protocol.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/ndarray.rst#2025-04-17_snippet_15\n\nLANGUAGE: C++\nCODE:\n```\nnb::class_<MyArray>(m, \"MyArray\")\n   // ...\n   .def(\"__dlpack__\", [](nb::kwargs kwargs) {\n       return nb::ndarray<>( /* ... */);\n   })\n   .def(\"__dlpack_device__\", []() {\n       return std::make_pair(nb::device::cpu::value, 0);\n   });\n```\n\n----------------------------------------\n\nTITLE: Example of Unsafe Reference Semantics in Python\nDESCRIPTION: Demonstrates how using reference semantics with vector elements can lead to crashes, as elements may become invalidated after deletion operations.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_extra.rst#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef looks_fine_but_crashes(vec: ext.ExampleVec) -> None:\n    # Trying to remove all the elements too much older than the last:\n    last = vec[-1]\n    # Even being careful to iterate backwards so we visit each\n    # index only once...\n    for idx in range(len(vec) - 2, -1, -1):\n        if last.timestamp - vec[idx].timestamp > 5:\n            del vec[idx]\n            # Oops! After the first deletion, 'last' now refers to\n            # uninitialized memory.\n```\n\n----------------------------------------\n\nTITLE: Setting link options with nanobind\nDESCRIPTION: Shows how to set recommended linker flags for a nanobind target.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_cmake.rst#2025-04-17_snippet_12\n\nLANGUAGE: cmake\nCODE:\n```\nnanobind_link_options(my_target)\n```\n\n----------------------------------------\n\nTITLE: Using new_ to Customize Object Creation in nanobind\nDESCRIPTION: Demonstrates how to use the new_ helper class to completely replace nanobind's object creation process, which is useful when working with types that can only provide pointers to instances.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_26\n\nLANGUAGE: cpp\nCODE:\n```\nclass MyType {\nprivate:\n    MyType();\npublic:\n    static std::shared_ptr<MyType> create();\n    int value = 0;\n};\n\nnb::class_<MyType>(m, \"MyType\")\n    .def(nb::new_(&MyType::create));\n```\n\n----------------------------------------\n\nTITLE: Setting Implicit Cast Warnings in nanobind\nDESCRIPTION: Function to enable or disable warnings when nanobind attempts to perform an implicit conversion that is not successful.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_52\n\nLANGUAGE: cpp\nCODE:\n```\nvoid set_implicit_cast_warnings(bool value) noexcept\n```\n\n----------------------------------------\n\nTITLE: Accessing ndarray Data Types with dlpack::dtype Enumeration\nDESCRIPTION: Definition of the dlpack::dtype_code enumeration that characterizes the elementary array data type regardless of bit depth. It includes types for signed/unsigned integers, floating point formats, and complex numbers.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_extra.rst#2025-04-17_snippet_13\n\nLANGUAGE: cpp\nCODE:\n```\nenum-class dlpack::dtype_code : uint8_t {\n   Int = 0,      // Signed integer format\n   UInt = 1,     // Unsigned integer format\n   Float = 2,    // IEEE-754 floating point format\n   Bfloat = 4,   // \"Brain\" floating point format\n   Complex = 5   // Complex numbers parameterized by real and imaginary component\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Reference Counting Hooks with intrusive_init in a Python Extension\nDESCRIPTION: Example of initializing the intrusive reference counting system in a Python extension module by registering custom reference counting hooks that manage Python reference counts.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_extra.rst#2025-04-17_snippet_25\n\nLANGUAGE: cpp\nCODE:\n```\nNB_MODULE(my_ext, m) {\n    nb::intrusive_init(\n        [](PyObject * o) noexcept {\n            nb::gil_scoped_acquire guard;\n            Py_INCREF(o);\n        },\n        [](PyObject * o) noexcept {\n            nb::gil_scoped_acquire guard;\n            Py_DECREF(o);\n        });\n\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Using StubGen Programmatically in Python\nDESCRIPTION: Example showing how to use the nanobind.stubgen.StubGen class to programmatically generate type stubs from Python code. The API is marked as experimental and not subject to semantic versioning.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/typing.rst#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom nanobind.stubgen import StubGen\nimport my_module\n\nsg = StubGen()\nsg.put(my_module)\nprint(sg.get())\n```\n\n----------------------------------------\n\nTITLE: Binding a C++ Union with nanobind\nDESCRIPTION: Example of binding a C++ union to Python using nanobind. This demonstrates making union members accessible from Python, though it should be used with caution as unions have undefined behavior when reading from inactive members.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/classes.rst#2025-04-17_snippet_25\n\nLANGUAGE: cpp\nCODE:\n```\nunion Example {\n    int ival;\n    double dval;\n\n    std::string to_string(size_t active_idx) const {\n        return active_idx == 1 ? std::to_string(dval) : std::to_string(ival);\n    }\n};\nstatic_assert(sizeof(Example) == sizeof(double));\n\nnb::class_<Example>(m, \"Example\")\n    .def_rw(\"ival\", &Example::ival)\n    .def_rw(\"dval\", &Example::dval)\n    .def(\"to_string\", &Example::to_string);\n```\n\n----------------------------------------\n\nTITLE: Using nanobind's low-level CMake interface\nDESCRIPTION: Demonstrates the equivalent low-level commands that compose the nanobind_add_module functionality, providing more granular control over the build process.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_cmake.rst#2025-04-17_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\n# Build the core parts of nanobind once\nnanobind_build_library(nanobind SHARED)\n\n# Compile an extension library\nadd_library(my_ext MODULE my_ext.cpp)\n\n# .. and link it against the nanobind parts\ntarget_link_libraries(my_ext PRIVATE nanobind)\n\n# .. enable size optimizations\nnanobind_opt_size(my_ext)\n\n# .. enable link time optimization\nnanobind_lto(my_ext)\n\n# .. set the default symbol visibility to 'hidden'\nnanobind_set_visibility(my_ext)\n\n# .. strip unneeded symbols and debug info from the binary (only active in release builds)\nnanobind_strip(my_ext)\n\n# .. disable the stack protector\nnanobind_disable_stack_protector(my_ext)\n\n# .. set the Python extension suffix\nnanobind_extension(my_ext)\n\n# .. set important compilation flags\nnanobind_compile_options(my_ext)\n\n# .. set important linker flags\nnanobind_link_options(my_ext)\n\n# Statically link against libstdc++/libgcc when targeting musllinux\nnanobind_musl_static_libcpp(my_ext)\n```\n\n----------------------------------------\n\nTITLE: Array Dimension Constraint Template\nDESCRIPTION: Template class that constrains only the number of dimensions in an ndarray without specifying the exact shape, equivalent to using shape with all dimensions set to -1.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_extra.rst#2025-04-17_snippet_18\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate <size_t N> class ndim {\n   // Alternative that only constrains the array dimension\n   // nb::ndim<2> is equivalent to nb::shape<-1, -1>\n}\n```\n\n----------------------------------------\n\nTITLE: Binding Protected Member Functions in C++\nDESCRIPTION: Example of a class with a protected member function that cannot be directly exposed to Python. Shows the problem when trying to bind protected members.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/classes.rst#2025-04-17_snippet_16\n\nLANGUAGE: cpp\nCODE:\n```\nclass A {\nprotected:\n    int foo() const { return 42; }\n};\n\nnb::class_<A>(m, \"A\")\n    .def(\"foo\", &A::foo); // error: 'foo' is a protected member of 'A'\n```\n\n----------------------------------------\n\nTITLE: Structure Definition for ndarray Data Type\nDESCRIPTION: Definition of the dlpack::dtype structure that represents the data type of elements in an n-dimensional array. It includes fields for the type code, bit depth, and SIMD lanes.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_extra.rst#2025-04-17_snippet_14\n\nLANGUAGE: cpp\nCODE:\n```\nstruct dlpack::dtype {\n   uint8_t code = 0;    // Contains one of the dlpack::dtype_code values\n   uint8_t bits = 0;    // Number of bits per entry\n   uint16_t lanes = 0;  // Number of SIMD lanes (typically 1)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Call Policy in C++ with nanobind\nDESCRIPTION: Demonstrates how to use the new nb::call_policy annotation to define custom function wrapping logic with precall and postcall hooks.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/changelog.rst#2025-04-17_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nnb::call_policy<Policy>()\n```\n\n----------------------------------------\n\nTITLE: Creating a Self-Referential Wrapper Object in Python\nDESCRIPTION: Python code demonstrating how to create a self-referential cycle using a C++ class exposed through nanobind, which the garbage collector cannot resolve.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/refleaks.rst#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> import my_ext\n>>> w = my_ext.Wrapper()\n>>> w.value = w\n```\n\n----------------------------------------\n\nTITLE: Returning Eigen Expression with Reference Arguments\nDESCRIPTION: Example of safely returning an Eigen expression by using reference arguments. This is safe because nanobind keeps the referenced objects alive until the expression has been evaluated.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/eigen.rst#2025-04-17_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\nm.def(\"sum\", [](const Eigen::Vector3f &a, const Eigen::Vector3d &b) { return a + b; });\n```\n\n----------------------------------------\n\nTITLE: Configuring nanobind Shared Library Output Directory in CMake\nDESCRIPTION: CMake commands to control the build output directory of the nanobind shared library component for proper installation.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/faq.rst#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nset_target_properties(nanobind\n  PROPERTIES\n  LIBRARY_OUTPUT_DIRECTORY                <path>\n  LIBRARY_OUTPUT_DIRECTORY_RELEASE        <path>\n  LIBRARY_OUTPUT_DIRECTORY_DEBUG          <path>\n  LIBRARY_OUTPUT_DIRECTORY_RELWITHDEBINFO <path>\n  LIBRARY_OUTPUT_DIRECTORY_MINSIZEREL     <path>\n)\n```\n\n----------------------------------------\n\nTITLE: Setting hidden visibility with nanobind\nDESCRIPTION: Shows how to set default symbol visibility to hidden for a target.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_cmake.rst#2025-04-17_snippet_6\n\nLANGUAGE: cmake\nCODE:\n```\nnanobind_trim(my_target)\n```\n\n----------------------------------------\n\nTITLE: Compiling nanobind extension with Meson\nDESCRIPTION: These shell commands set up the Meson build directory and compile the nanobind extension module.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/meson.rst#2025-04-17_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\nmeson setup builddir\nmeson compile -C builddir\n```\n\n----------------------------------------\n\nTITLE: Generating Type Stubs for nanobind Modules\nDESCRIPTION: Creates Python typing stub (.pyi) files for selected test modules, with special handling for the typing module that requires additional marker files.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/tests/CMakeLists.txt#2025-04-17_snippet_10\n\nLANGUAGE: CMake\nCODE:\n```\nforeach (NAME functions classes ndarray jax tensorflow stl enum typing make_iterator)\n  if (NAME STREQUAL typing)\n    set(EXTRA\n      MARKER_FILE py.typed\n      PATTERN_FILE \"${CMAKE_CURRENT_SOURCE_DIR}/pattern_file.nb\"\n    )\n    set(EXTRA_DEPENDS \"${OUT_DIR}/py_stub_test.py\")\n  else()\n    set(EXTRA \"\")\n    set(EXTRA_DEPENDS \"\")\n  endif()\n\n  if (CMAKE_CONFIGURATION_TYPES)\n    # On multi-config generators like Visual Studio, put stubs in the 'Debug' / 'Release' /.. folders\n    set(PYI_PREFIX $<CONFIG>/)\n  endif()\n\n  nanobind_add_stub(\n    ${NAME}_ext_stub\n    MODULE test_${NAME}_ext\n    OUTPUT ${PYI_PREFIX}test_${NAME}_ext.pyi\n    PYTHON_PATH $<TARGET_FILE_DIR:test_${NAME}_ext>\n    DEPENDS test_${NAME}_ext ${EXTRA_DEPENDS}\n    ${EXTRA})\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Including Unique Pointer Support in nanobind\nDESCRIPTION: Shows how to include the necessary header file to enable support for std::unique_ptr in nanobind bindings.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/ownership.rst#2025-04-17_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\n#include <nanobind/stl/unique_ptr.h>\n```\n\n----------------------------------------\n\nTITLE: Implementing a generic iterable vector with customized signature\nDESCRIPTION: Demonstrates how to customize a class signature to make an integer vector appear as a Python iterable collection by specifying an inheritance from collections.abc.Iterable[int].\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/typing.rst#2025-04-17_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nusing IntVec = std::vector<int>;\n\nnb::class_<IntVec>(m, \"IntVec\")\n   .def(\"__iter__\",\n        [](const IntVec &v) -> GeneralIterator { ... })\n```\n\n----------------------------------------\n\nTITLE: Example Type-Annotated Python Function\nDESCRIPTION: Demonstrates a simple Python function with type annotations that will be used to generate a stub file.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/typing.rst#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef square(x: int) -> int:\n    '''Return the square of the input'''\n    return x*x\n```\n\n----------------------------------------\n\nTITLE: Replacing Instance with Move in nanobind\nDESCRIPTION: Function to destruct the contents of a destination instance and replace it with a moved source instance, similar to inst_replace_copy but using the move constructor.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_47\n\nLANGUAGE: cpp\nCODE:\n```\nvoid inst_replace_move(handle dst, handle src)\n```\n\n----------------------------------------\n\nTITLE: Disabling stack protector with nanobind\nDESCRIPTION: Shows how to disable the stack protector for optimization purposes in a Python extension.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_cmake.rst#2025-04-17_snippet_8\n\nLANGUAGE: cmake\nCODE:\n```\nnanobind_disable_stack_protector(my_target)\n```\n\n----------------------------------------\n\nTITLE: Generating Test Files for Python Bindings\nDESCRIPTION: Function to generate test files for different binding libraries (Cython, Boost, pybind11, nanobind) with debug and optimized variants. Handles file creation, code generation and compilation.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/microbenchmark.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\ndef gen_file(name, func, libs=('cython', 'boost', 'pybind11', 'pybind11_sh', 'nanobind')):\n    for i, lib in enumerate(libs):    \n        for opt_mode, opt_flags in {'debug' : ['-O0', '-g3'], 'opt' : ['-Os', '-g0']}.items():\n            if lib != 'cython':\n                fname = name + '_' + lib + '.cpp'\n            else:\n                fname = name + '_' + lib + '_' + opt_mode + '.pyx'\n            # ... rest of implementation\n```\n\n----------------------------------------\n\nTITLE: Hashing Python Object in nanobind\nDESCRIPTION: Function to hash a Python object, equivalent to hash() in Python. Returns an implementation-specific signed integer type Py_hash_t.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_61\n\nLANGUAGE: cpp\nCODE:\n```\nPy_hash_t hash(handle h)\n```\n\n----------------------------------------\n\nTITLE: Stripping unused symbols with nanobind\nDESCRIPTION: Shows how to strip unused and debug symbols in release builds.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_cmake.rst#2025-04-17_snippet_7\n\nLANGUAGE: cmake\nCODE:\n```\nnanobind_strip(my_target)\n```\n\n----------------------------------------\n\nTITLE: Creating nanobind Test Modules\nDESCRIPTION: Generates test modules for each feature in the test names list, configuring them with the appropriate build options and CUDA language setting if enabled.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/tests/CMakeLists.txt#2025-04-17_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\nforeach (NAME ${TEST_NAMES})\n  nanobind_add_module(test_${NAME}_ext test_${NAME}.cpp ${NB_EXTRA_ARGS})\n\n  if (NB_TEST_CUDA)\n    set_property(SOURCE test_${NAME}.cpp PROPERTY LANGUAGE CUDA)\n  endif()\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Default Python Stub with Docstring\nDESCRIPTION: Shows the generated stub file format that preserves type annotations and docstring but removes implementation.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/typing.rst#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef square(x: int) -> int:\n    '''Return the square of the input'''\n```\n\n----------------------------------------\n\nTITLE: Looking up Python Type Objects for C++ Classes in Nanobind\nDESCRIPTION: Demonstrates how to look up the Python type object associated with a C++ class using nb::type<T>() and verify the result is valid.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/lowlevel.rst#2025-04-17_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nnb::handle py_type = nb::type<MyClass>();\n```\n\n----------------------------------------\n\nTITLE: Updated enum usage example\nDESCRIPTION: Shows the correct way to access enum values in nanobind, replacing direct int casting with .value access\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/changelog.rst#2025-04-17_snippet_16\n\nLANGUAGE: Python\nCODE:\n```\nmy_enum_entry.value  # correct way\nint(my_enum_entry)    # incorrect way\n```\n\n----------------------------------------\n\nTITLE: Declaring nanobind Extension in Bazel\nDESCRIPTION: Defines a Bazel target for creating a nanobind extension that contains Python bindings for C++ code. Corresponds to Bazel's cc_binary rule with additional nanobind-specific configurations.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_bazel.rst#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef nanobind_extension(\n    name,\n    domain = \"\",\n    srcs = [],\n    copts = [],\n    deps = [],\n    local_defines = [],\n    **kwargs):\n```\n\n----------------------------------------\n\nTITLE: Setting ABI3 extension suffix with nanobind\nDESCRIPTION: Shows how to assign a stable ABI3 extension suffix to a compiled binding.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_cmake.rst#2025-04-17_snippet_10\n\nLANGUAGE: cmake\nCODE:\n```\nnanobind_extension_abi3(my_target)\n```\n\n----------------------------------------\n\nTITLE: Replacing Instance with Copy in nanobind\nDESCRIPTION: Function to destruct the contents of a destination instance and replace it with a copy of a source instance. Preserves the destination's original destruct flag value.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_46\n\nLANGUAGE: cpp\nCODE:\n```\nvoid inst_replace_copy(handle dst, handle src)\n```\n\n----------------------------------------\n\nTITLE: Using typed with nb::object and handle for Type Annotations\nDESCRIPTION: Special form of nb::typed that allows creating parameters or return values described with specific type annotations while accepting any Python object at runtime.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/changelog.rst#2025-04-17_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nnb::typed<nb::object, T>\n```\n\nLANGUAGE: cpp\nCODE:\n```\nnb::typed<nb::handle, T>\n```\n\n----------------------------------------\n\nTITLE: Creating a Python TypeVar with nanobind\nDESCRIPTION: Example of creating a typing.TypeVar instance with nanobind's type_var function, demonstrating how to set parameters like contravariance, covariance, and bounds.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_extra.rst#2025-04-17_snippet_27\n\nLANGUAGE: cpp\nCODE:\n```\nm.attr(\"T\") = nb::type_var(\"T\",\n                           \"contravariant\"_a = true,\n                           \"covariant\"_a = false,\n                           \"bound\"_a = nb::type<MyClass>());\n```\n\n----------------------------------------\n\nTITLE: Pattern File Example - Using Regular Expression Groups\nDESCRIPTION: Example showing how to use regex pattern groups in stubgen pattern files to create generic replacement rules for multiple similar methods at once.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/typing.rst#2025-04-17_snippet_13\n\nLANGUAGE: text\nCODE:\n```\n__(eq|ne)__:\n    def __\\1__(self, arg, /) -> bool: ...\n```\n\n----------------------------------------\n\nTITLE: Configuring Python with Thread Sanitizer for Free-threaded nanobind\nDESCRIPTION: Command to configure Python with thread sanitizer support for use with nanobind. This requires building Python from source with specific configuration options to properly instrument locks that nanobind relies on, avoiding false positives in thread sanitizer analysis.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/free_threaded.rst#2025-04-17_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ ./configure --disable-gil --with-thread-sanitizer <.. other options ..>\n```\n\n----------------------------------------\n\nTITLE: Adding nanobind-bazel as a Dependency in MODULE.bazel\nDESCRIPTION: Demonstrates how to add nanobind-bazel as a dependency in a Bazel project using the MODULE.bazel file. This example shows using the standard version-based dependency approach.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/bazel.rst#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Place this in your MODULE.bazel file.\n# The major version of nanobind-bazel is equal to the version\n# of the internally used nanobind.\n# In this case, we are building bindings with nanobind v2.5.0.\nbazel_dep(name = \"nanobind_bazel\", version = \"2.5.0\")\n```\n\n----------------------------------------\n\nTITLE: Initializing Python Reference Counting Hooks in nanobind\nDESCRIPTION: Registration of Python reference counting hooks with nanobind's intrusive reference counter, allowing it to operate without depending directly on Python.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/ownership_adv.rst#2025-04-17_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\nnb::intrusive_init(\n    [](PyObject *o) noexcept {\n        nb::gil_scoped_acquire guard;\n        Py_INCREF(o);\n    },\n    [](PyObject *o) noexcept {\n        nb::gil_scoped_acquire guard;\n        Py_DECREF(o);\n    });\n```\n\n----------------------------------------\n\nTITLE: Marking Instance as Ready in nanobind\nDESCRIPTION: Function to simultaneously set both the ready and destruct flags of an instance to true.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_41\n\nLANGUAGE: cpp\nCODE:\n```\nvoid inst_mark_ready(handle h)\n```\n\n----------------------------------------\n\nTITLE: Installing nanobind as a Git submodule\nDESCRIPTION: Commands to add nanobind as a Git submodule to your project repository. This method avoids external package managers and directly references the GitHub repository.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/installing.rst#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit submodule add https://github.com/wjakob/nanobind ext/nanobind\ngit submodule update --init --recursive\n```\n\n----------------------------------------\n\nTITLE: Expanded Form of Operator Binding in nanobind\nDESCRIPTION: The expanded form of the operator binding using lambda functions. Shows how nb::self syntax is translated internally, with nb::is_operator() flag to properly handle Python's operator fallback mechanism.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/classes.rst#2025-04-17_snippet_14\n\nLANGUAGE: cpp\nCODE:\n```\n.def(\"__mul__\", [](const Vector2 &a, float b) {\n    return a * b;\n}, nb::is_operator())\n```\n\n----------------------------------------\n\nTITLE: Using C++11 raw string literals for multiline Python code\nDESCRIPTION: Shows how to use C++11 raw string literals to write multiline Python code in C++, maintaining proper indentation and readability.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/utilities.rst#2025-04-17_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nnb::exec(R\"(\n    x = get_answer()\n    if x == 42:\n        print('Hello World!')\n    else:\n        print('Bye!')\n    )\", scope\n);\n```\n\n----------------------------------------\n\nTITLE: Modifying Array Parameters with DRef\nDESCRIPTION: Example of using nb::DRef to create a mutable reference to a matrix parameter. This allows the function to modify the array in-place, with changes visible to the Python caller.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/eigen.rst#2025-04-17_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\nvoid f4(nb::DRef<Eigen::MatrixXf> x) { x *= 2; }\n```\n\n----------------------------------------\n\nTITLE: Zero-Initializing Instance in nanobind\nDESCRIPTION: Function to zero-initialize the contents of an instance and set both ready and destruct flags to true.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_38\n\nLANGUAGE: cpp\nCODE:\n```\nvoid inst_zero(handle h)\n```\n\n----------------------------------------\n\nTITLE: Finding nanobind via Pip/Conda Installation\nDESCRIPTION: Detects installed nanobind package location and imports it into CMake configuration. Used when nanobind is installed via pip or conda.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/building.rst#2025-04-17_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nexecute_process(\n  COMMAND \"${Python_EXECUTABLE}\" -m nanobind --cmake_dir\n  OUTPUT_STRIP_TRAILING_WHITESPACE OUTPUT_VARIABLE nanobind_ROOT)\nfind_package(nanobind CONFIG REQUIRED)\n```\n\n----------------------------------------\n\nTITLE: Using nanobind_opt_size in CMake\nDESCRIPTION: Demonstrates how to enable size optimizations for a target in release builds.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_cmake.rst#2025-04-17_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\nnanobind_opt_size(my_target)\n```\n\n----------------------------------------\n\nTITLE: Checking Instance Ready State in nanobind\nDESCRIPTION: Function to query the ready flag of an instance, which indicates if the instance is fully constructed and can be passed to bound C++ functions.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_39\n\nLANGUAGE: cpp\nCODE:\n```\nbool inst_ready(handle h)\n```\n\n----------------------------------------\n\nTITLE: Getting Object Representation in nanobind\nDESCRIPTION: Function to get a stringified version of a Python object, equivalent to repr() in Python.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_54\n\nLANGUAGE: cpp\nCODE:\n```\nstr repr(handle h)\n```\n\n----------------------------------------\n\nTITLE: Move-Constructing Instance in nanobind\nDESCRIPTION: Function to move-construct the contents of one instance into another, similar to inst_copy but using the move constructor instead.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_45\n\nLANGUAGE: cpp\nCODE:\n```\nvoid inst_move(handle dst, handle src)\n```\n\n----------------------------------------\n\nTITLE: Pattern File Example - Preserving Docstrings\nDESCRIPTION: Example showing how to preserve existing docstrings when rewriting method signatures in stubgen pattern files using the \\doc escape code.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/typing.rst#2025-04-17_snippet_15\n\nLANGUAGE: text\nCODE:\n```\nmy_ext.lookup:\n    def lookup(array: Array[T], index: int) -> T:\n        \\doc\n```\n\n----------------------------------------\n\nTITLE: Checking Implicit Cast Warnings Status in nanobind\nDESCRIPTION: Function to check if nanobind is configured to warn when an implicit conversion is not successful.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_50\n\nLANGUAGE: cpp\nCODE:\n```\nbool implicit_cast_warnings() noexcept\n```\n\n----------------------------------------\n\nTITLE: Installing nanobind via Pip\nDESCRIPTION: Command to install nanobind package using Python's pip package manager. This installs both C++ and CMake source code needed to compile extension modules.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/installing.rst#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npython -m pip install nanobind\n```\n\n----------------------------------------\n\nTITLE: Defining Keyword-Only Arguments in Python\nDESCRIPTION: Examples of Python functions using keyword-only arguments, demonstrating how positional-only and keyword-only parameters operate in Python function calls.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/functions.rst#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nexample(check=False, val=5)   # good\nexample(100, check=True)      # good\nexample(200, False)           # TypeError:\n    # example() takes 1 positional argument but 2 were given\n\ndef munge(*args: int, invert: bool = False) -> int:\n    return sum(args) * (-1 if invert else 1)\n\nmunge(1, 2, 3)                # 6\nmunge(4, 5, 6, invert=True)   # -15\n```\n\n----------------------------------------\n\nTITLE: Getting Instance State in nanobind\nDESCRIPTION: Function to query both the ready and destruct flags of an instance, returned as a pair of booleans.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_40\n\nLANGUAGE: cpp\nCODE:\n```\nstd::pair<bool, bool> inst_state(handle h)\n```\n\n----------------------------------------\n\nTITLE: Function Reference in Global Scope Leak Example\nDESCRIPTION: Python code demonstrating how even simple function references can create complex reference cycles through the global namespace when used with C++ objects.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/refleaks.rst#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> def f():\n...     pass\n...\n>>> w = my_ext.Wrapper()\n>>> w.value = f\n```\n\n----------------------------------------\n\nTITLE: Adding a Static Method to an Enumeration in C++\nDESCRIPTION: Example showing how to add a static method to an enum class using the def_static() method.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/changelog.rst#2025-04-17_snippet_10\n\nLANGUAGE: C++\nCODE:\n```\nnb::enum_<MyEnum>(m, \"MyEnum\").def_static(\"static_method\", &some_function)\n```\n\n----------------------------------------\n\nTITLE: Pattern File Example - Importing Types\nDESCRIPTION: Example showing how to import typing types in a stubgen pattern file using \\from escape code to enhance type annotations in the generated stubs.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/typing.rst#2025-04-17_snippet_16\n\nLANGUAGE: text\nCODE:\n```\n@overload\nmy_ext.lookup:\n    \\from typing import Optional as _Opt, Literal\n    def lookup(array: Array[T], index: Literal[0] = 0) -> _Opt[T]:\n        \\doc\n```\n\n----------------------------------------\n\nTITLE: Using nb::arg().lock() for Argument Locking in C++\nDESCRIPTION: Demonstrates the syntax for locking arguments in nanobind function bindings to maintain fast path execution. This is particularly useful in free-threaded extensions where performance is critical.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/functions.rst#2025-04-17_snippet_14\n\nLANGUAGE: cpp\nCODE:\n```\nnb::arg().lock()\n```\n\n----------------------------------------\n\nTITLE: Getting Iterator in nanobind\nDESCRIPTION: Function to get an iterator for a Python object, equivalent to iter() in Python.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_57\n\nLANGUAGE: cpp\nCODE:\n```\niterator iter(handle h)\n```\n\n----------------------------------------\n\nTITLE: Enabling None-valued function arguments with explicit annotation\nDESCRIPTION: Demonstrates how to explicitly allow None values for function arguments using arg::none() annotation.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/porting.rst#2025-04-17_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nm.def(\"func\", &func, \"arg\"_a.none());\n```\n\n----------------------------------------\n\nTITLE: Class Signature Override Example in nanobind\nDESCRIPTION: Example demonstrating how to customize class rendering in stubgen using nb::sig annotation to add decorators and specify type parameters.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_9\n\nLANGUAGE: cpp\nCODE:\n```\nnb::class_<Class>(m, \"Class\",\n                  nb::sig(\n                      \"@decorator(decorator_args..)\n\"\n                      \"class Class(Base1[T], Base2, meta=Meta)\"\n                  ));\n```\n\n----------------------------------------\n\nTITLE: Setting compilation options with nanobind\nDESCRIPTION: Shows how to set recommended compilation flags for a nanobind target.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_cmake.rst#2025-04-17_snippet_11\n\nLANGUAGE: cmake\nCODE:\n```\nnanobind_compile_options(my_target)\n```\n\n----------------------------------------\n\nTITLE: Customizing Argument Type Information in C++\nDESCRIPTION: Example showing how to customize argument type information using the .sig() method on argument annotations.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/changelog.rst#2025-04-17_snippet_15\n\nLANGUAGE: C++\nCODE:\n```\nnb::arg(\"name\").sig(\"signature\")\n```\n\n----------------------------------------\n\nTITLE: Including STL Vector Bindings in C++ with nanobind\nDESCRIPTION: This snippet shows how to include the necessary header for binding std::vector types using nanobind.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/exchanging.rst#2025-04-17_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\n#include <nanobind/stl/bind_vector.h>\n```\n\n----------------------------------------\n\nTITLE: Including Required nanobind Intrusive Counter Implementation\nDESCRIPTION: Instructions for including the implementation of the intrusive counter functionality, which needs to be compiled somewhere in the project.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/ownership_adv.rst#2025-04-17_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\n#include <nanobind/intrusive/counter.inl>\n```\n\n----------------------------------------\n\nTITLE: Including Operator Overloading Support in nanobind\nDESCRIPTION: This directive imports the special 'self' value used for operator overloading in nanobind. The 'self' value enables a shorthand notation for binding C++ operators to Python.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_extra.rst#2025-04-17_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#include <nanobind/operators.h>\n```\n\n----------------------------------------\n\nTITLE: Including STL smart pointer support in nanobind\nDESCRIPTION: Shows the include directives needed to enable support for std::unique_ptr and std::shared_ptr in nanobind.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/porting.rst#2025-04-17_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\n#include <nanobind/stl/unique_ptr.h>\n#include <nanobind/stl/shared_ptr.h>\n```\n\n----------------------------------------\n\nTITLE: Using NB_MAKE_OPAQUE to Fix Type Conflict in nanobind\nDESCRIPTION: C++ code showing the use of NB_MAKE_OPAQUE macro to prevent a type from being handled by nanobind's type caster system.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/faq.rst#2025-04-17_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\nNB_MAKE_OPAQUE(std::vector<int>);\n```\n\n----------------------------------------\n\nTITLE: Multi-file nanobind Project Structure - Extension File 1\nDESCRIPTION: Example of a separate implementation file for nanobind bindings that can be compiled independently.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/faq.rst#2025-04-17_snippet_8\n\nLANGUAGE: cpp\nCODE:\n```\nvoid init_ex1(nb::module_ &m) {\n    m.def(\"add\", [](int a, int b) { return a + b; });\n}\n```\n\n----------------------------------------\n\nTITLE: Including nanobind namespace using alias\nDESCRIPTION: Creates a namespace alias 'nb' for the nanobind namespace to simplify code.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/porting.rst#2025-04-17_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nnamespace nb = nanobind;\n```\n\n----------------------------------------\n\nTITLE: Using Python with ndarray Inspection Function\nDESCRIPTION: Python example showing how to call the inspection function with a NumPy array, displaying array properties like dimensions, strides, and data type.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/ndarray.rst#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> my_module.inspect(np.array([[1,2,3], [3,4,5]], dtype=np.float32))\nArray data pointer : 0x1c30f60\nArray dimension : 2\nArray dimension [0] : 2\nArray stride    [0] : 3\nArray dimension [1] : 3\nArray stride    [1] : 1\nDevice ID = 0 (cpu=1, cuda=0)\nArray dtype: int16=0, uint32=0, float32=1\n```\n\n----------------------------------------\n\nTITLE: Including the ndarray Header in C++\nDESCRIPTION: The required include directive to use ndarray functionality in nanobind.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/ndarray.rst#2025-04-17_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#include <nanobind/ndarray.h>\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of nb::list in C++ Bindings\nDESCRIPTION: Example showing a basic binding that iterates over a Python list without type information. This approach works but doesn't clearly indicate what type of objects the list should contain.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_63\n\nLANGUAGE: cpp\nCODE:\n```\nm.def(\"f\", [](nb::list l) {\n    for (handle h : l) {\n        // ...\n    }\n});\n```\n\n----------------------------------------\n\nTITLE: Including bind_map.h in C++\nDESCRIPTION: Shows the include directive needed to use the bind_map function for exposing std::map or std::unordered_map variants in Python.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_extra.rst#2025-04-17_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\n#include <nanobind/stl/bind_map.h>\n```\n\n----------------------------------------\n\nTITLE: Debugging ImportError for nanobind module\nDESCRIPTION: Example showing a Python import error that occurs when the module name in nanobind_add_module() and NB_MODULE() don't match.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/faq.rst#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import my_ext\nImportError: dynamic module does not define module export function (PyInit_my_ext)\n```\n\n----------------------------------------\n\nTITLE: Customizing cibuildwheel build matrix for nanobind\nDESCRIPTION: Additional cibuildwheel configuration options to narrow down the build matrix by skipping Python 3.8 and targeting only 64-bit architectures. Useful for projects with specific version and architecture requirements.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/packaging.rst#2025-04-17_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\nskip = [\"cp38-*\", \"pp38-*\"] # Skip CPython and PyPy 3.8\narchs = [\"auto64\"]          # Only target 64 bit architectures\n```\n\n----------------------------------------\n\nTITLE: Including STL Map Bindings in C++ with nanobind\nDESCRIPTION: This snippet demonstrates how to include the header for binding std::map and std::unordered_map types using nanobind.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/exchanging.rst#2025-04-17_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\n#include <nanobind/stl/bind_map.h>\n```\n\n----------------------------------------\n\nTITLE: Including nanobind eval header\nDESCRIPTION: Shows how to include the necessary header file for using nanobind's Python evaluation functions.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/utilities.rst#2025-04-17_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#include <nanobind/eval.h>\n```\n\n----------------------------------------\n\nTITLE: Creating Generic Types with nb::typed in C++\nDESCRIPTION: Example showing how to create generic parameterized types using the nb::typed wrapper.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/changelog.rst#2025-04-17_snippet_11\n\nLANGUAGE: C++\nCODE:\n```\nnb::typed<nb::list, int>\n```\n\n----------------------------------------\n\nTITLE: Creating Self-Referential Python List Example\nDESCRIPTION: Python code demonstrating how reference cycles work with built-in Python types, where the garbage collector can properly identify and clean up cycles.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/refleaks.rst#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nl = []       # 'l' ref. count = 1\nl.append(l)  # 'l' ref. count = 2\ndel l        # 'l' ref. count = 1\n```\n\n----------------------------------------\n\nTITLE: Including Python Expression Evaluation Headers\nDESCRIPTION: Include directive required to access nanobind's utilities for evaluating Python expressions and functions from C++ code.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_extra.rst#2025-04-17_snippet_22\n\nLANGUAGE: cpp\nCODE:\n```\n#include <nanobind/eval.h>\n```\n\n----------------------------------------\n\nTITLE: Multi-file nanobind Project Structure - Main Module\nDESCRIPTION: Example of how to structure a large nanobind project with multiple files to improve build times, showing the main module file.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/faq.rst#2025-04-17_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\nvoid init_ex1(nb::module_ &);\nvoid init_ex2(nb::module_ &);\n/* ... */\n\nNB_MODULE(my_ext, m) {\n    init_ex1(m);\n    init_ex2(m);\n    /* ... */\n}\n```\n\n----------------------------------------\n\nTITLE: Using Local Path Override for nanobind-bazel in MODULE.bazel\nDESCRIPTION: Shows how to use a local copy of nanobind-bazel during development using the local_path_override directive in MODULE.bazel.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/bazel.rst#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# MODULE.bazel\nbazel_dep(name = \"nanobind_bazel\", version = \"\")\nlocal_path_override(\n    module_name = \"nanobind_bazel\",\n    path = \"/path/to/nanobind-bazel/\", # replace this with the actual path.\n)\n```\n\n----------------------------------------\n\nTITLE: Including Iterator Bindings in C++ with nanobind\nDESCRIPTION: This code shows how to include the header for binding forward iterators using nanobind.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/exchanging.rst#2025-04-17_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\n#include <nanobind/make_iterator.h>\n```\n\n----------------------------------------\n\nTITLE: Including Eigen Dense Header for nanobind\nDESCRIPTION: Include directive needed to access nanobind's Eigen convenience type aliases for zero-copy data exchange between Eigen and NumPy arrays.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_extra.rst#2025-04-17_snippet_20\n\nLANGUAGE: cpp\nCODE:\n```\n#include <nanobind/eigen/dense.h>\n```\n\n----------------------------------------\n\nTITLE: Binding Vector with Reference Internal Policy in C++\nDESCRIPTION: Shows how to override nanobind's default copy policy for __getitem__ with reference_internal policy. This is generally unsafe and should be avoided unless necessary and carefully managed.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_extra.rst#2025-04-17_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\nnb::bind_vector<std::vector<MyType>,\n                 nb::rv_policy::reference_internal>(m, \"ExampleVec\");\n```\n\n----------------------------------------\n\nTITLE: Minimal Import Causing Default Argument Leak\nDESCRIPTION: Python code showing that simply importing a module with problematic default arguments can cause reference leaks, even without explicitly using the affected types.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/refleaks.rst#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nimport my_ext\n```\n\n----------------------------------------\n\nTITLE: Overriding Function Signatures with nb::sig in C++\nDESCRIPTION: Example showing how to override a function signature using the nb::sig annotation to customize type information in stubs.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/changelog.rst#2025-04-17_snippet_13\n\nLANGUAGE: C++\nCODE:\n```\nm.def(\"f\", &f, nb::sig(\"def f(x: Foo = Foo(0)) -> None\"), \"docstring\");\n```\n\n----------------------------------------\n\nTITLE: Using make_iterator with Value Arguments in C++\nDESCRIPTION: Shows the updated usage of nb::make_iterator which now accepts iterator arguments by value instead of forwarding reference to prevent dangling references.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/changelog.rst#2025-04-17_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nnb::make_iterator\n```\n\n----------------------------------------\n\nTITLE: Adding Stub Generation for Python Stub Test Module\nDESCRIPTION: Sets up stub generation for a Python module used to test the stub generator itself, ensuring the output goes to the correct directory.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/tests/CMakeLists.txt#2025-04-17_snippet_16\n\nLANGUAGE: CMake\nCODE:\n```\nnanobind_add_stub(\n  py_stub\n  MODULE py_stub_test\n  OUTPUT ${PYI_PREFIX}py_stub_test.pyi\n  PYTHON_PATH $<TARGET_FILE_DIR:test_stl_ext>\n  DEPENDS ${PY_STUB_TEST}\n)\n```\n\n----------------------------------------\n\nTITLE: Including Intrusive Reference Counting Headers\nDESCRIPTION: Include directives needed to use nanobind's intrusive reference counting system that simplifies shared ownership in C++/Python binding projects.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_extra.rst#2025-04-17_snippet_23\n\nLANGUAGE: cpp\nCODE:\n```\n#include <nanobind/intrusive/counter.h>\n#include <nanobind/intrusive/ref.h>\n```\n\n----------------------------------------\n\nTITLE: Static linking against libstdc++ for musllinux\nDESCRIPTION: Shows how to statically link against libstdc++ and libgcc when targeting the musllinux platform.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_cmake.rst#2025-04-17_snippet_13\n\nLANGUAGE: cmake\nCODE:\n```\nnanobind_musl_static_libcpp(my_target)\n```\n\n----------------------------------------\n\nTITLE: Including nanobind Iterator Header in C++\nDESCRIPTION: Include directive for nanobind's iterator bindings, required to use the make_iterator functions.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_extra.rst#2025-04-17_snippet_10\n\nLANGUAGE: C++\nCODE:\n```\n#include <nanobind/make_iterator.h>\n```\n\n----------------------------------------\n\nTITLE: STL Function Object in C++ Class\nDESCRIPTION: C++ code showing that using std::function in a class exposed to Python doesn't resolve reference cycle issues, as it still creates the same cyclic dependency pattern.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/refleaks.rst#2025-04-17_snippet_8\n\nLANGUAGE: cpp\nCODE:\n```\n#include <nanobind/stl/functional.h>\n\nstruct Wrapper {\n    std::function<void()> value;\n};\n```\n\n----------------------------------------\n\nTITLE: Importing Libraries for Python Benchmarking\nDESCRIPTION: Imports various Python libraries needed for benchmarking and visualization, including random, subprocess, numpy, and matplotlib. Sets up matplotlib configuration parameters for visualization.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/microbenchmark.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport random\nimport subprocess\nimport itertools\nfrom collections import defaultdict\nimport importlib.machinery\nimport os\nimport time\nimport cython\nfrom matplotlib.patches import Rectangle\n    \nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib as mpl\nmpl.rcParams['hatch.linewidth'] = 5.0 \ncycle = [x['color'] for x in mpl.rcParams['axes.prop_cycle']]\n```\n\n----------------------------------------\n\nTITLE: Testing Python Object Instance Type in C++\nDESCRIPTION: Demonstrates the new overload of nb::isinstance that checks if a Python object is an instance of a Python class.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/changelog.rst#2025-04-17_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nnb::isinstance\n```\n\n----------------------------------------\n\nTITLE: Creating Inter-Module Test Modules with Custom Domain\nDESCRIPTION: Builds two test modules that share a custom nanobind domain and depend on the inter_module shared library to test cross-module type interactions.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/tests/CMakeLists.txt#2025-04-17_snippet_13\n\nLANGUAGE: CMake\nCODE:\n```\nnanobind_add_module(test_inter_module_1_ext NB_DOMAIN mydomain test_inter_module_1.cpp ${NB_EXTRA_ARGS})\nnanobind_add_module(test_inter_module_2_ext NB_DOMAIN mydomain test_inter_module_2.cpp ${NB_EXTRA_ARGS})\ntarget_link_libraries(test_inter_module_1_ext PRIVATE inter_module)\ntarget_link_libraries(test_inter_module_2_ext PRIVATE inter_module)\n```\n\n----------------------------------------\n\nTITLE: Configuring Benchmark Data Structures and Paths\nDESCRIPTION: Initializes data structures for storing benchmark results and defines repository paths for pybind11. Sets up experiment tracking with sizes and times dictionaries, and identifies the Python extension suffix.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/microbenchmark.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nexperiment_labels = []\nsizes = defaultdict(lambda: [])\ntimes = defaultdict(lambda: [])\n\nfrom sysconfig import get_paths as gp\nsuffix = importlib.machinery.EXTENSION_SUFFIXES[0]\n\n# Path to pybind11 git repository\npybind11_path = '/home/wjakob/pybind11/include'\n\n# Path to pybind11 git repository (smartholder branch)\npybind11_sh_path = '/home/wjakob/pybind11_sh/include'\n```\n\n----------------------------------------\n\nTITLE: Custom Deleter Declaration for std::unique_ptr in nanobind\nDESCRIPTION: nanobind provides a custom deleter (nb::deleter<T>) that enables safe ownership transfer between C++ and Python in all scenarios, unlike std::default_delete which has limitations with Python-allocated objects.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/ownership_adv.rst#2025-04-17_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\nstd::unique_ptr<T, nb::deleter<T>>\n```\n\n----------------------------------------\n\nTITLE: Installing nanobind via Conda\nDESCRIPTION: Command to install nanobind package using Conda package manager. This is intended for users developing Conda-based extensions with a build-time dependency on nanobind.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/installing.rst#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nconda install -c conda-forge nanobind\n```\n\n----------------------------------------\n\nTITLE: Building nanobind library variants in CMake\nDESCRIPTION: Shows how to build different variants of the nanobind library, including shared/static builds and ABI3-compatible versions.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_cmake.rst#2025-04-17_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\n# Normal shared library build\nnanobind_build_library(nanobind)\n\n# Static ABI3 build\nnanobind_build_library(nanobind-static-abi3)\n```\n\n----------------------------------------\n\nTITLE: Creating Shared Library for Inter-Module Tests\nDESCRIPTION: Builds a shared library that will be used by multiple test modules to test cross-module functionality in nanobind.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/tests/CMakeLists.txt#2025-04-17_snippet_12\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library(\n  inter_module\n  SHARED\n  inter_module.h\n  inter_module.cpp\n)\n\ntarget_compile_definitions(inter_module PRIVATE -DSHARED_BUILD)\ntarget_compile_features(inter_module PRIVATE cxx_std_17)\ntarget_include_directories(inter_module PRIVATE ${NB_DIR}/include)\n```\n\n----------------------------------------\n\nTITLE: Nanobind Shape Constraint Example\nDESCRIPTION: Demonstrates the usage of shape constraints for n-dimensional arrays, showing both the verbose and new shorthand notation.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/changelog.rst#2025-04-17_snippet_19\n\nLANGUAGE: C++\nCODE:\n```\nnb::shape<nb::any, nb::any, nb::any>\nnb::ndim<3>\n```\n\n----------------------------------------\n\nTITLE: Zero-Initializing Objects in Nanobind\nDESCRIPTION: Demonstrates how to zero-initialize a POD (Plain Old Data) object and mark it as ready using nb::inst_zero().\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/lowlevel.rst#2025-04-17_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\nnb::inst_zero(py_inst);\nassert(nb::inst_ready(py_inst));\n```\n\n----------------------------------------\n\nTITLE: Adding Leak Detection Definition in nanobind Tests\nDESCRIPTION: Adds a compiler definition to abort during interpreter shutdown if memory leaks are detected, which helps catch leaks in CI testing.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/tests/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nadd_definitions(-DNB_ABORT_ON_LEAK)\n```\n\n----------------------------------------\n\nTITLE: Copy-Constructing Instance in nanobind\nDESCRIPTION: Function to copy-construct the contents of one instance into another and set the ready and destruct flags of the destination to true. No-op when source and destination are the same object.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_44\n\nLANGUAGE: cpp\nCODE:\n```\nvoid inst_copy(handle dst, handle src)\n```\n\n----------------------------------------\n\nTITLE: Finding nanobind via Git Submodule\nDESCRIPTION: Adds nanobind subdirectory to CMake configuration when installed as a Git submodule.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/building.rst#2025-04-17_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nadd_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/ext/nanobind)\n```\n\n----------------------------------------\n\nTITLE: Using Git Override for nanobind-bazel in MODULE.bazel\nDESCRIPTION: Demonstrates how to use a development version of nanobind-bazel from GitHub using the git_override directive in MODULE.bazel.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/bazel.rst#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# MODULE.bazel\nbazel_dep(name = \"nanobind_bazel\", version = \"\")\ngit_override(\n    module_name = \"nanobind_bazel\",\n    commit = COMMIT_SHA, # replace this with the actual commit you want.\n    remote = \"https://github.com/nicholasjng/nanobind-bazel\",\n)\n```\n\n----------------------------------------\n\nTITLE: Complex Value Deletion in C++\nDESCRIPTION: Example showing how to delete entries from a Python object using the nb::del() function in C++. This is equivalent to the Python 'del' statement.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/changelog.rst#2025-04-17_snippet_18\n\nLANGUAGE: C++\nCODE:\n```\nnb::del(o[key]);\n```\n\n----------------------------------------\n\nTITLE: Adding Eigen3 Support for Tests if Available\nDESCRIPTION: Conditionally includes Eigen3 matrix library support for tests if the library is found, creating an additional test module linked against Eigen3.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/tests/CMakeLists.txt#2025-04-17_snippet_11\n\nLANGUAGE: CMake\nCODE:\n```\nfind_package (Eigen3 3.3.1 NO_MODULE)\nif (TARGET Eigen3::Eigen)\n  nanobind_add_module(test_eigen_ext test_eigen.cpp ${NB_EXTRA_ARGS})\n  target_link_libraries(test_eigen_ext PRIVATE Eigen3::Eigen)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring pyproject.toml for Meson-based nanobind project\nDESCRIPTION: This snippet shows how to set up the pyproject.toml file to use meson-python as the build backend for a nanobind project.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/meson.rst#2025-04-17_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[project]\nname = \"my_project_name\"\ndynamic = ['version']\n\n[build-system]\nrequires = ['meson-python']\n\nbuild-backend = 'mesonpy'\n```\n\n----------------------------------------\n\nTITLE: Performance Visualization\nDESCRIPTION: Creates bar plots comparing compilation times and binary sizes between different binding libraries. Includes formatting, labels and annotations for comparison.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/microbenchmark.ipynb#2025-04-17_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\ndef bars(data, ylim_scale = 1, figsize_scale = 1, width_scale=1.0, debug_shift=0.1):\n    ylim = 0\n    for n, d in data.items():\n        if len(d) == 0:\n            continue\n        ylim = max(max(d), ylim)\n    # ... rest of plotting implementation\n```\n\n----------------------------------------\n\nTITLE: Including Intrusive Counter Implementation\nDESCRIPTION: Additional include needed in a single .cpp file to provide the implementation of the intrusive reference counting system.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_extra.rst#2025-04-17_snippet_24\n\nLANGUAGE: cpp\nCODE:\n```\n#include <nanobind/intrusive/counter.inl>\n```\n\n----------------------------------------\n\nTITLE: Setting Output Directory for Test Modules\nDESCRIPTION: Configures the output directory for test modules, handling both single-configuration and multi-configuration build systems.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/tests/CMakeLists.txt#2025-04-17_snippet_9\n\nLANGUAGE: CMake\nCODE:\n```\nif (CMAKE_CONFIGURATION_TYPES)\n  set(OUT_DIR ${CMAKE_CURRENT_BINARY_DIR}/$<CONFIG>)\nelse()\n  set(OUT_DIR ${CMAKE_CURRENT_BINARY_DIR})\nendif()\n```\n\n----------------------------------------\n\nTITLE: Incorrect Binding of Template Classes\nDESCRIPTION: Example of incorrect binding of a template class in nanobind. This approach fails because C++ templates must be instantiated with specific types at compile time.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/classes.rst#2025-04-17_snippet_20\n\nLANGUAGE: cpp\nCODE:\n```\n// BROKEN (this will not compile)\nnb::class_<PetHouse>(m, \"PetHouse\");\n    .def(\"get\", &PetHouse::get);\n```\n\n----------------------------------------\n\nTITLE: Including unique_ptr.h in C++\nDESCRIPTION: Shows the include directive needed to use the deleter with std::unique_ptr for maximum flexibility.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_extra.rst#2025-04-17_snippet_9\n\nLANGUAGE: cpp\nCODE:\n```\n#include <nanobind/stl/unique_ptr.h>\n```\n\n----------------------------------------\n\nTITLE: Configuring Compiler Warnings for Different Compilers\nDESCRIPTION: Sets up compiler-specific warning options for MSVC and GCC/Clang compilers to enable stricter warning levels during compilation.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/tests/CMakeLists.txt#2025-04-17_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nif (MSVC)\n  if (CMAKE_CXX_FLAGS MATCHES \"/W[0-4]\")\n    string(REGEX REPLACE \"/W[0-4]\" \"/W4\" CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS}\")\n  elseif (NOT NB_TEST_CUDA)\n    add_compile_options(/W4)\n  endif()\nelseif (CMAKE_CXX_COMPILER_ID MATCHES \"Clang|GNU\")\n  add_compile_options(-Wall -Wextra -Wno-unused-local-typedefs)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Adding Supplemental Data to Type Objects in Nanobind\nDESCRIPTION: Shows how to stash supplemental data inside the type object of bound types using nb::supplement<T>() and access it with nb::type_supplement<T>().\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/lowlevel.rst#2025-04-17_snippet_12\n\nLANGUAGE: cpp\nCODE:\n```\nstruct MyTensorMetadata {\n    bool stored_on_gpu;\n    // ..\n    // should be a POD (plain old data) type\n};\n\n// Register a new type MyTensor, and reserve space for sizeof(MyTensorMedadata)\nnb::class_<MyTensor> cls(m, \"MyTensor\", nb::supplement<MyTensorMedadata>())\n\n/// Mutable reference to 'MyTensorMedadata' portion in Python type object\n```\n\n----------------------------------------\n\nTITLE: Error Message for Incompatible Array Arguments\nDESCRIPTION: Example showing the error message when passing an incompatible array to a function with constraints, demonstrating nanobind's type signature display.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/ndarray.rst#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> my_module.process(np.zeros(1))\n\nTypeError: process(): incompatible function arguments. The following argument types are supported:\n1. process(arg: ndarray[dtype=uint8, shape=(*, *, 3), device='cpu'], /) -> None\n\nInvoked with types: numpy.ndarray\n```\n\n----------------------------------------\n\nTITLE: Workaround for Reference Leaks in Old Python Versions\nDESCRIPTION: Python code pattern to avoid reference leaks in older Python versions (e.g., 3.8) by wrapping top-level code in a function to improve cleanup during interpreter shutdown.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/refleaks.rst#2025-04-17_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n# Problematic pattern that may leak on older Python versions\na = my_ext.MyObject()\n```\n\nLANGUAGE: python\nCODE:\n```\n# Better pattern that avoids leaks\ndef run():\n    a = my_ext.MyObject()\n    # ...\n\nif __name__ == '__main__':\n    run()\n```\n\n----------------------------------------\n\nTITLE: Adding Additional Source Files for Intrusive Test Module\nDESCRIPTION: Adds an implementation file to the intrusive test module, demonstrating how to include multiple source files in a nanobind module.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/tests/CMakeLists.txt#2025-04-17_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(test_intrusive_ext PRIVATE test_intrusive_impl.cpp)\n```\n\n----------------------------------------\n\nTITLE: Implicit conversions in pybind11\nDESCRIPTION: Shows how implicit type conversions are specified in pybind11 using a separate function call.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/porting.rst#2025-04-17_snippet_8\n\nLANGUAGE: cpp\nCODE:\n```\npy::class_<MyType>(m, \"MyType\")\n    .def(py::init<MyOtherType>());\n\npy::implicitly_convertible<MyOtherType, MyType>();\n```\n\n----------------------------------------\n\nTITLE: Benchmarking Function and Class Performance Across Python Libraries\nDESCRIPTION: This code benchmarks performance by repeatedly calling functions or class methods from different libraries (cppyy, nanobind, or native Python). It runs each test 5 times, sorts the results, and selects the median time to avoid outliers.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/microbenchmark.ipynb#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nif lib == 'cppyy':\n    m = cppyy.gbl\nelif lib == 'nanobind_sh':\n    continue # Performance identical, not an interesting data point\nelif lib == 'python':\n    m = native_module\nelse:\n    m = importlib.import_module(f'{name}_{lib}_{mode}')\n \ntime_list = []\nfor i in range(5):\n    time_before = time.perf_counter()\n    if name == 'func':\n        func = m.test_0000\n        for i in range(its):\n            func(1,2,3,4,5,6)\n    elif name == 'class':\n        cls = m.Struct0\n        sum_member = cls.sum\n        for i in range(its):\n            sum_member(cls(1,2,3,4,5,6))\n\n    time_after = time.perf_counter()\n    time_list.append(time_after-time_before)\ntime_list.sort()\n\nrtimes[lib].append(time_list[len(time_list)//2])\n```\n\n----------------------------------------\n\nTITLE: Configuring Optional nanobind Build Features\nDESCRIPTION: Sets up conditional compilation options for testing stable ABI compatibility, free-threaded operation, and shared library builds.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/tests/CMakeLists.txt#2025-04-17_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nif (NB_TEST_STABLE_ABI)\n  set(NB_EXTRA_ARGS ${NB_EXTRA_ARGS} STABLE_ABI)\nendif()\n\nif (NB_TEST_FREE_THREADED)\n  set(NB_EXTRA_ARGS ${NB_EXTRA_ARGS} FREE_THREADED)\nendif()\n\nif (NB_TEST_SHARED_BUILD)\n  set(NB_EXTRA_ARGS ${NB_EXTRA_ARGS} NB_SHARED)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Setting None as default value for function arguments\nDESCRIPTION: Shows how to set None as the default value for a function parameter, which implicitly enables None values.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/porting.rst#2025-04-17_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nm.def(\"func\", &func, \"arg\"_a = nb::none());\n```\n\n----------------------------------------\n\nTITLE: Citation Reference for nanobind in BibTeX\nDESCRIPTION: BibTeX citation template for referencing the nanobind library in academic and scientific publications. Includes author, year, project URL, and title information.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/README.md#2025-04-17_snippet_0\n\nLANGUAGE: bibtex\nCODE:\n```\n@misc{nanobind,\n   author = {Wenzel Jakob},\n   year = {2022},\n   note = {https://github.com/wjakob/nanobind},\n   title = {nanobind: tiny and efficient C++/Python bindings}\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern File Example - Using Named Groups\nDESCRIPTION: Example of a stubgen pattern file using named regex groups to customize method signatures for comparison operators.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/typing.rst#2025-04-17_snippet_14\n\nLANGUAGE: text\nCODE:\n```\n__(?P<op>eq|ne)__:\n    def __\\op__(self, arg, /) -> bool : ...\n```\n\n----------------------------------------\n\nTITLE: Including Chrono Headers for Timestamp and Duration Conversions\nDESCRIPTION: Include directive needed to use nanobind's bidirectional conversions between Python's datetime objects and C++ std::chrono types.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_extra.rst#2025-04-17_snippet_21\n\nLANGUAGE: cpp\nCODE:\n```\n#include <nanobind/stl/chrono.h>\n```\n\n----------------------------------------\n\nTITLE: Configuring 32-bit FPU Options for x86\nDESCRIPTION: Sets specific floating-point math options for 32-bit x86 builds to ensure consistent test results by using SSE2 instead of the legacy x87 FPU.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/tests/CMakeLists.txt#2025-04-17_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nif (UNIX AND (CMAKE_SIZEOF_VOID_P EQUAL 4) AND (CMAKE_SYSTEM_PROCESSOR STREQUAL i686))\n  # Don't use the legacy 387 math coprocessor in 32 bit builds, this causes tests to fail\n  add_compile_options(-mfpmath=sse -msse2)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Installing nanobind extension as editable install with pip\nDESCRIPTION: This command uses pip to install the nanobind extension as an editable install, which is useful for development.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/meson.rst#2025-04-17_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\npython -m pip install -e .\n```\n\n----------------------------------------\n\nTITLE: Installing Sphinx Documentation Dependencies for nanobind\nDESCRIPTION: This requirements file lists all Python packages needed to build nanobind's documentation. It includes Sphinx 6.1.3 as the core documentation generator, along with several extensions: furo (theme), sphinx-copybutton for code copying, sphinxcontrib-moderncmakedomain for CMake support, and sphinxcontrib-svg2pdfconverter for SVG conversion.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/requirements.txt#2025-04-17_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nfuro\nsphinx==6.1.3\nsphinx-copybutton==0.5.1\nsphinxcontrib-moderncmakedomain==3.25.0\nsphinxcontrib-svg2pdfconverter==1.2.2\n```\n\n----------------------------------------\n\nTITLE: Getting Instance Type Name in nanobind\nDESCRIPTION: Function to retrieve the full module-qualified name of an instance's type as a Python string.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_48\n\nLANGUAGE: cpp\nCODE:\n```\nstr inst_name(handle h)\n```\n\n----------------------------------------\n\nTITLE: Example Reference Leak Warning Output\nDESCRIPTION: Sample output of warning messages displayed when nanobind detects reference leaks during Python interpreter shutdown. These messages indicate that instances, types, or functions were not properly cleaned up.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/refleaks.rst#2025-04-17_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nnanobind: leaked 1 instances!\n - leaked instance 0x102123728 of type \"my_ext.MyClass\"\nnanobind: leaked 1 types!\n - leaked type \"my_ext.MyClass\"\nnanobind: leaked 1 functions!\n - leaked function \"__init__\"\n\nnanobind: this is likely caused by a reference counting issue in the binding code.\nSee https://nanobind.readthedocs.io/en/latest/refleaks.html\n```\n\n----------------------------------------\n\nTITLE: Checking Leak Warnings Status in nanobind\nDESCRIPTION: Function to check if nanobind is configured to warn about instances, types, or functions that are still alive when the Python interpreter shuts down.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_49\n\nLANGUAGE: cpp\nCODE:\n```\nbool leak_warnings() noexcept\n```\n\n----------------------------------------\n\nTITLE: Pattern File Example - Function Replacement\nDESCRIPTION: Example of a DSL pattern file for stubgen showing how to replace a simple function stub with a more specific typed overload implementation with docstrings.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/typing.rst#2025-04-17_snippet_12\n\nLANGUAGE: text\nCODE:\n```\nmy_ext.MyClass.my_function:\n    @overload\n    def my_function(arg: int) -> int:\n        \"\"\"A helpful docstring\"\"\"\n\n    @overload\n    def my_function(arg: str) -> str: ...\n```\n\n----------------------------------------\n\nTITLE: Installation Configuration\nDESCRIPTION: Sets up installation paths and rules for nanobind files including headers, sources, and CMake configuration files.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/CMakeLists.txt#2025-04-17_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nif(NB_CREATE_INSTALL_RULES AND NOT CMAKE_SKIP_INSTALL_RULES)\n  set(CMAKE_INSTALL_LIBDIR \"\")\n  include(GNUInstallDirs)\n  set(NB_INSTALL_DATADIR \"nanobind\"\n    CACHE PATH \"Installation path for read-only architecture-independent nanobind data files\")\n\n  set(NB_INSTALL_INC_DIR \"${NB_INSTALL_DATADIR}/include\")\n  set(NB_INSTALL_SRC_DIR \"${NB_INSTALL_DATADIR}/src\")\n  set(NB_INSTALL_EXT_DIR \"${NB_INSTALL_DATADIR}/ext\")\n  set(NB_INSTALL_MODULE_DIR \"${NB_INSTALL_DATADIR}\")\n  set(NB_INSTALL_CMAKE_DIR \"${NB_INSTALL_DATADIR}/cmake\")\n```\n\n----------------------------------------\n\nTITLE: Configuring nanobind CMake Module with ABI Domain Isolation\nDESCRIPTION: CMake configuration that isolates an extension's ABI domain, ensuring that global settings like leak warnings don't affect other nanobind extensions in the same process.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/refleaks.rst#2025-04-17_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nnanobind_add_module(\n  my_module\n  NB_DOMAIN my_abi_domain\n  extension_file.cpp)\n```\n\n----------------------------------------\n\nTITLE: Default Argument Reference Leak Example in C++\nDESCRIPTION: C++ code demonstrating how default arguments in constructors can create reference cycles between type objects and instances, leading to uncollectable memory.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/refleaks.rst#2025-04-17_snippet_9\n\nLANGUAGE: cpp\nCODE:\n```\nstruct Wrapper { nb::object value; };\n\nNB_MODULE(my_ext, m) {\n    nb::class_<Wrapper>(m, \"Wrapper\")\n        .def(nb::init<Wrapper>() = Wrapper());\n}\n```\n\n----------------------------------------\n\nTITLE: Citation Template for Nanobind Project in BibTeX\nDESCRIPTION: BibTeX template for citing the nanobind project in academic and scientific contexts. Includes author, year, project URL and title information.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/faq.rst#2025-04-17_snippet_11\n\nLANGUAGE: bibtex\nCODE:\n```\n@misc{nanobind,\n       author = {Wenzel Jakob},\n       year = {2022},\n       note = {https://github.com/wjakob/nanobind},\n       title = {nanobind: tiny and efficient C++/Python bindings}\n    }\n```\n\n----------------------------------------\n\nTITLE: Minimal Python Stub Format\nDESCRIPTION: Shows the most compact stub format that preserves only type annotations using ellipsis.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/typing.rst#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndef square(x: int) -> int: ...\n```\n\n----------------------------------------\n\nTITLE: Master Project Detection\nDESCRIPTION: Determines if nanobind is being built as the top-level project and sets build options accordingly.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/CMakeLists.txt#2025-04-17_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nif (CMAKE_PROJECT_NAME STREQUAL PROJECT_NAME)\n  set(NB_MASTER_PROJECT ON)\nelse()\n  set(NB_MASTER_PROJECT OFF)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Python Dependencies Configuration\nDESCRIPTION: Configures Python interpreter and development library dependencies with version requirements.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/CMakeLists.txt#2025-04-17_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nif (NOT TARGET Python::Module OR NOT TARGET Python::Interpreter)\n  set(Python_FIND_FRAMEWORK LAST)\n\n  if (CMAKE_VERSION VERSION_LESS 3.18)\n    set(NB_PYTHON_DEV_MODULE Development)\n  else()\n    set(NB_PYTHON_DEV_MODULE Development.Module)\n  endif()\n\n  find_package(Python 3.8\n    REQUIRED COMPONENTS Interpreter ${NB_PYTHON_DEV_MODULE}\n    OPTIONAL_COMPONENTS Development.SABIModule)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Converting factory functions to constructors in nanobind\nDESCRIPTION: Demonstrates how to turn an existing factory function into a constructor by combining placement new with the factory function.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/porting.rst#2025-04-17_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\nnb::class_<MyType>(m, \"MyType\")\n    .def(\"__init__\", [](MyType *t) { new (t) MyType(MyType::create()); });\n```\n\n----------------------------------------\n\nTITLE: Build and Deploy Commands\nDESCRIPTION: Commands for building and uploading the release package\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/release.rst#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npipx run build\n```\n\nLANGUAGE: bash\nCODE:\n```\ntwine upload --repository nanobind <filename>\n```\n\n----------------------------------------\n\nTITLE: Citation Format for Nanobind Project\nDESCRIPTION: BibTeX entry for citing the nanobind project in academic or scientific context. Includes author, year, project URL and title information.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/index.rst#2025-04-17_snippet_0\n\nLANGUAGE: bibtex\nCODE:\n```\n@misc{nanobind,\n       author = {Wenzel Jakob},\n       year = {2022},\n       note = {https://github.com/wjakob/nanobind},\n       title = {nanobind: tiny and efficient C++/Python bindings}\n    }\n```\n\n----------------------------------------\n\nTITLE: Installing Meson wrap packages for nanobind and robin-map\nDESCRIPTION: These shell commands create a subprojects directory and install the necessary wrap packages for nanobind and robin-map using Meson.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/meson.rst#2025-04-17_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nmkdir -p subprojects\nmeson wrap install robin-map\nmeson wrap install nanobind\n```\n\n----------------------------------------\n\nTITLE: Enabling CUDA Compiler for CUDA Tests\nDESCRIPTION: Conditionally enables CUDA language support when NB_TEST_CUDA is set, configuring the CUDA compiler to use C++17 standard.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/tests/CMakeLists.txt#2025-04-17_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nif (NB_TEST_CUDA)\n  enable_language(CUDA)\n  set(CMAKE_CUDA_STANDARD 17)\n  set(CMAKE_CUDA_STANDARD_REQUIRED ON)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Git Release Commands\nDESCRIPTION: Git commands for committing, tagging, and pushing a new release\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/release.rst#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit commit -am \"vX.Y.Z release\"\n```\n\nLANGUAGE: bash\nCODE:\n```\ngit tag -a vX.Y.Z -m \"vX.Y.Z release\"\n```\n\nLANGUAGE: bash\nCODE:\n```\ngit push && git push --tags\n```\n\n----------------------------------------\n\nTITLE: Defining nanobind Test Module Names\nDESCRIPTION: Creates a list of test module names for different nanobind features that will be compiled and tested.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/tests/CMakeLists.txt#2025-04-17_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nset(TEST_NAMES\n  functions\n  callbacks\n  classes\n  holders\n  stl\n  stl_bind_map\n  stl_bind_vector\n  chrono\n  enum\n  eval\n  ndarray\n  jax\n  tensorflow\n  exception\n  make_iterator\n  typing\n  issue\n  intrusive\n  thread\n)\n```\n\n----------------------------------------\n\nTITLE: Version Detection from Header File\nDESCRIPTION: Extracts the version number components from nanobind.h header file using regex patterns.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nfile(STRINGS \"include/nanobind/nanobind.h\" _nanobind_h_version REGEX \"^#define NB_VERSION_.*$\")\nstring(REGEX MATCH \"#define NB_VERSION_MAJOR ([0-9]+)\" _ \"${_nanobind_h_version}\")\nset(_major ${CMAKE_MATCH_1})\nstring(REGEX MATCH \"#define NB_VERSION_MINOR ([0-9]+)\" _ \"${_nanobind_h_version}\")\nset(_minor ${CMAKE_MATCH_1})\nstring(REGEX MATCH \"#define NB_VERSION_PATCH ([0-9]+)\" _ \"${_nanobind_h_version}\")\nset(_patch ${CMAKE_MATCH_1})\n```\n\n----------------------------------------\n\nTITLE: Defining a Class with Private Constructor\nDESCRIPTION: Example of a C++ class with a private constructor and static factory method, demonstrating a case where custom object creation is needed.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/classes.rst#2025-04-17_snippet_27\n\nLANGUAGE: cpp\nCODE:\n```\nclass Pet {\n  private:\n    Pet(/* ... */);\n  public:\n    static std::unique_ptr<Pet> make(std::string name, int age);\n    void speak();\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Test Files to be Copied to Output Directory\nDESCRIPTION: Creates a list of Python test files and reference stub files that need to be copied to the output directory for testing.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/tests/CMakeLists.txt#2025-04-17_snippet_14\n\nLANGUAGE: CMake\nCODE:\n```\nset(TEST_FILES\n  common.py\n  conftest.py\n  test_callbacks.py\n  test_classes.py\n  test_eigen.py\n  test_enum.py\n  test_eval.py\n  test_exception.py\n  test_functions.py\n  test_holders.py\n  test_inter_module.py\n  test_intrusive.py\n  test_make_iterator.py\n  test_stl.py\n  test_stl_bind_map.py\n  test_stl_bind_vector.py\n  test_chrono.py\n  test_ndarray.py\n  test_jax.py\n  test_tensorflow.py\n  test_stubs.py\n  test_typing.py\n  test_thread.py\n\n  # Stub reference files\n  test_classes_ext.pyi.ref\n  test_functions_ext.pyi.ref\n  test_make_iterator_ext.pyi.ref\n  test_ndarray_ext.pyi.ref\n  test_jax_ext.pyi.ref\n  test_tensorflow_ext.pyi.ref\n  test_stl_ext.pyi.ref\n  test_enum_ext.pyi.ref\n  test_typing_ext.pyi.ref\n  py_stub_test.py\n  py_stub_test.pyi.ref\n)\n```\n\n----------------------------------------\n\nTITLE: Extending Parameterized Generic Types in nanobind C++\nDESCRIPTION: Shows how to extend parameterized forms of generic types by creating a subclass with a specific type parameter.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/typing.rst#2025-04-17_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\nnb::class_<Subclass>(m, \"Subclass\", wrapper[nb::type<Foo>()]);\n```\n\n----------------------------------------\n\nTITLE: Creating a generic wrapper class in Python\nDESCRIPTION: Shows a Python example of creating a generic parameterized type using typing.Generic and TypeVar to enable static type checking.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/typing.rst#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport typing\n\n# 1. Instantiate a placeholder type (\"type variable\") used below\nT = typing.TypeVar(\"T\")\n\n# 2. Create a generic type by inheriting from typing.Generic\nclass Wrapper(typing.Generic[T]):\n    # The constructor references the placeholder type\n    def __init__(self, value: T):\n        self.value = value\n\n    # .. this type is then preserved in the getter\n    def get(self) -> T:\n        return self.value\n\n# Based on the typed constructor, MyPy knows that 'x' has type 'Wrapper[int]'\nx = Wrapper(3)\n\n# Based on the typed 'Wrapped.get' method, 'y' is inferred to have type 'int'\ny = x.get()\n```\n\n----------------------------------------\n\nTITLE: Creating Uninitialized C++ Object Instances in Nanobind\nDESCRIPTION: Demonstrates how to allocate an uninitialized Python object that will hold a C++ instance using nb::inst_alloc().\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/lowlevel.rst#2025-04-17_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\nnb::object py_inst = nb::inst_alloc(py_type);\n```\n\n----------------------------------------\n\nTITLE: Printing Python Object in nanobind\nDESCRIPTION: Function to invoke Python's print() function to print an object, with optional line ending and file handle parameters.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_55\n\nLANGUAGE: cpp\nCODE:\n```\nvoid print(handle value, handle end = handle(), handle file = handle())\n```\n\n----------------------------------------\n\nTITLE: Getting Python Globals in nanobind\nDESCRIPTION: Function to retrieve the Python globals() dictionary.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_core.rst#2025-04-17_snippet_60\n\nLANGUAGE: cpp\nCODE:\n```\ndict globals()\n```\n\n----------------------------------------\n\nTITLE: Fixed Example Using Reference Return Value Policy\nDESCRIPTION: Corrects the problematic example by explicitly specifying a reference return value policy to prevent Python from taking ownership of the C++ instance.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/ownership.rst#2025-04-17_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nm.def(\"get_data\", &get_data, nb::rv_policy::reference);\n```\n\n----------------------------------------\n\nTITLE: Destructing Instance Objects in Nanobind\nDESCRIPTION: Shows how to destruct a C++ instance and convert it back to non-ready status using nb::inst_destruct().\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/lowlevel.rst#2025-04-17_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\nnb::inst_destruct(py_inst);\nassert(!nb::inst_ready(py_inst));\n```\n\n----------------------------------------\n\nTITLE: Copying Test Files to Output Directory\nDESCRIPTION: Sets up commands to copy test files to the output directory when the source and build directories are different or when using MSVC.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/tests/CMakeLists.txt#2025-04-17_snippet_15\n\nLANGUAGE: CMake\nCODE:\n```\nset (PY_STUB_TEST py_stub_test.py)\nif (NOT (CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_CURRENT_BINARY_DIR) OR MSVC)\n  foreach(TEST_FILE IN LISTS TEST_FILES)\n    set(IN_FILE ${CMAKE_CURRENT_SOURCE_DIR}/${TEST_FILE})\n    set(OUT_FILE ${OUT_DIR}/${TEST_FILE})\n    set(TEST_FILES_OUT ${TEST_FILES_OUT} ${OUT_FILE})\n    add_custom_command(\n      DEPENDS ${IN_FILE} OUTPUT ${OUT_FILE}\n      COMMAND ${CMAKE_COMMAND} -E copy_if_different ${IN_FILE} ${OUT_DIR})\n  endforeach()\n\n  add_custom_target(copy-tests ALL DEPENDS ${TEST_FILES_OUT})\n  set(PY_STUB_TEST ${OUT_DIR}/py_stub_test.py)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Casting ndarray to Python object in C++\nDESCRIPTION: This snippet demonstrates how to safely cast a Vector3f ndarray to a Python object using nb::cast(). However, this method results in a non-informative docstring.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/ndarray.rst#2025-04-17_snippet_10\n\nLANGUAGE: C++\nCODE:\n```\nusing Vector3f = nb::ndarray<float, nb::numpy, nb::shape<3>>;\nm.def(\"return_vec3\", []{\n    float data[] { 1, 2, 3 };\n    // OK.\n    return nb::cast(Vector3f(data));\n});\n```\n\n----------------------------------------\n\nTITLE: Creating nanobind C++ Library\nDESCRIPTION: Declares a Bazel target for a C++ library with nanobind dependencies. Wraps Bazel's cc_library rule with nanobind-specific configurations.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_bazel.rst#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef nanobind_library(\n    name,\n    copts = [],\n    deps = [],\n    **kwargs):\n```\n\n----------------------------------------\n\nTITLE: Configuring Sanitizer Options for Testing\nDESCRIPTION: Sets up various sanitizer options (address, undefined behavior, thread) for enhanced testing and debugging of memory issues.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/tests/CMakeLists.txt#2025-04-17_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nset(NB_TEST_SANITIZER \"\")\n\nif (NB_TEST_SANITIZERS_ASAN)\n  list(APPEND NB_TEST_SANITIZERS address)\nendif()\n\nif (NB_TEST_SANITIZERS_UBSAN)\n  list(APPEND NB_TEST_SANITIZERS undefined)\nendif()\n\nif (NB_TEST_SANITIZERS_TSAN)\n  list(APPEND NB_TEST_SANITIZERS thread)\nendif()\n\n\nif (NB_TEST_SANITIZERS)\n  string(REPLACE \";\" \",\" NB_TEST_SANITIZERS \"${NB_TEST_SANITIZERS}\")\n  add_compile_options(-fsanitize=${NB_TEST_SANITIZERS})\n  add_link_options(-fsanitize=${NB_TEST_SANITIZERS})\nendif()\n```\n\n----------------------------------------\n\nTITLE: Building nanobind Shared Library\nDESCRIPTION: Creates a Bazel target for a C++ shared library with nanobind dependencies. Wraps Bazel's cc_shared_library rule with nanobind-specific settings.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_bazel.rst#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef nanobind_shared_library(\n    name,\n    deps = [],\n    **kwargs):\n```\n\n----------------------------------------\n\nTITLE: Multi-file nanobind Project Structure - Extension File 2\nDESCRIPTION: Another example of a separate implementation file for nanobind bindings that can be compiled independently.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/faq.rst#2025-04-17_snippet_9\n\nLANGUAGE: cpp\nCODE:\n```\nvoid init_ex2(nb::module_ &m) {\n    m.def(\"sub\", [](int a, int b) { return a - b; });\n}\n```\n\n----------------------------------------\n\nTITLE: Reference Not Updated Example in nanobind\nDESCRIPTION: C++ code example showing a function with a reference argument that won't propagate updates when bound to Python.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/faq.rst#2025-04-17_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\nvoid increment(int &i) {\n    i++;\n}\n```\n\n----------------------------------------\n\nTITLE: Conflicting Type Binding Example with nanobind\nDESCRIPTION: C++ code example showing a compilation error scenario where type casters and bindings conflict for the same type.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/faq.rst#2025-04-17_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\n#include <nanobind/stl/vector.h>\n#include <nanobind/stl/bind_vector.h>\n\nnamespace nb = nanobind;\n\nNB_MODULE(my_ext, m) {\n    // The following line cannot be compiled\n    nb::bind_vector<std::vector<int>>(m, \"VectorInt\");\n\n    // This doesn't work either\n    nb::class_<std::vector<int>>(m, \"VectorInt\");\n}\n```\n\n----------------------------------------\n\nTITLE: Setting rpath for nanobind Extension in CMake\nDESCRIPTION: CMake commands to adjust the build and install rpath of a nanobind extension to ensure it can find required shared libraries.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/faq.rst#2025-04-17_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nset_property(TARGET my_ext APPEND PROPERTY BUILD_RPATH \"$<TARGET_FILE_DIR:nanobind>\")\nset_property(TARGET my_ext APPEND PROPERTY INSTALL_RPATH \".. ?? ..\")\n```\n\n----------------------------------------\n\nTITLE: Function Closure Reference Leak Example\nDESCRIPTION: Python code showing how function closures can create uncollectable reference cycles when used with C++ classes exposed through nanobind.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/refleaks.rst#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> def f():\n...     w = my_ext.Wrapper()\n...     def g():\n...         return w\n...     w.value = g\n...\n>>> f()\n```\n\n----------------------------------------\n\nTITLE: Visualizing Performance Benchmark Results with Matplotlib\nDESCRIPTION: Creates bar charts to visualize the performance comparison between different libraries. The code saves the visualization as both PNG and SVG files and also displays it on screen.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/microbenchmark.ipynb#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfig, ax = bars(rtimes, ylim_scale=.188, figsize_scale=1.25, width_scale=1, debug_shift=.1)\nax.set_ylabel('Time (seconds)')\nax.set_title('Runtime performance')\nax.set_xlim(-0.45,3.45)\nax.legend()\nfig.tight_layout()\nplt.savefig('perf.png', facecolor='white', dpi=200, bbox_inches='tight', pad_inches = 0)\nplt.savefig('perf.svg', facecolor='white', bbox_inches='tight', pad_inches = 0)\nplt.show()\n```\n\n----------------------------------------\n\nTITLE: Class Test Generator\nDESCRIPTION: Generates test classes with different numeric type combinations for member variables. Creates class definitions with constructors and sum methods for each binding library.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/microbenchmark.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\ndef gen_class(f, lib):\n    types = [ 'uint16_t', 'int32_t', 'uint32_t', 'int64_t', 'uint64_t', 'float' ]\n    for i, t in enumerate(itertools.permutations(types)):\n        # ... implementation for generating class definitions\n```\n\n----------------------------------------\n\nTITLE: Function Test Generator\nDESCRIPTION: Generates test functions with different numeric type combinations for each binding library. Creates function definitions with 6 parameters of varying numeric types.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/microbenchmark.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\ndef gen_func(f, lib):\n    types = [ 'uint16_t', 'int32_t', 'uint32_t', 'int64_t', 'uint64_t', 'float' ]\n    if lib == 'boost':\n        prefix = 'py::'\n    else:\n        prefix = 'm.'\n    for i, t in enumerate(itertools.permutations(types)):\n        args = f'{t[0]} a, {t[1]} b, {t[2]} c, {t[3]} d, {t[4]} e, {t[5]} f'\n        # ... rest of implementation\n```\n\n----------------------------------------\n\nTITLE: Setting Python extension suffix with nanobind\nDESCRIPTION: Shows how to assign the appropriate Python extension suffix to a compiled binding.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/api_cmake.rst#2025-04-17_snippet_9\n\nLANGUAGE: cmake\nCODE:\n```\nnanobind_extension(my_target)\n```\n\n----------------------------------------\n\nTITLE: Implementing custom constructors in pybind11\nDESCRIPTION: Demonstrates the pybind11 approach to defining custom constructors using lambda functions that return instances.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/porting.rst#2025-04-17_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\npy::class_<MyType>(m, \"MyType\")\n    .def(py::init([](int) { return MyType(...); }));\n```\n\n----------------------------------------\n\nTITLE: Debugging Missing nanobind Shared Library Error\nDESCRIPTION: Example showing the import error that occurs when Python can't find the required nanobind shared library component.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/faq.rst#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> import my_ext\nImportError: dlopen(my_ext.cpython-311-darwin.so, 0x0002):\nLibrary not loaded: '@rpath/libnanobind.dylib'\n```\n\n----------------------------------------\n\nTITLE: Using nanobind_add_module with Warning Suppression in CMake\nDESCRIPTION: Example parameter for nanobind_add_module that marks nanobind and Python include directories as SYSTEM to suppress warnings, useful for projects with strict warning flags.\nSOURCE: https://github.com/wjakob/nanobind/blob/master/docs/changelog.rst#2025-04-17_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nNB_SUPPRESS_WARNINGS\n```"
  }
]