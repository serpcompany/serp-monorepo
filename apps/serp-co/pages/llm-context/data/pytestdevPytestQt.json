[
  {
    "owner": "pytest-dev",
    "repo": "pytest-qt",
    "content": "TITLE: Basic Search Test with pytest-qt\nDESCRIPTION: This test function demonstrates how to use the qtbot fixture to interact with a PyQt widget and verify its behavior. It creates temporary files, interacts with the widget, and asserts that the results match the expectations.  It relies on the 'qtbot' fixture provided by the pytest-qt plugin, and the 'tmp_path' fixture from pytest.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/tutorial.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef test_basic_search(qtbot, tmp_path):\n    \"\"\"\n    test to ensure basic find files functionality is working.\n    \"\"\"\n    tmp_path.joinpath(\"video1.avi\").touch()\n    tmp_path.joinpath(\"video1.srt\").touch()\n\n    tmp_path.joinpath(\"video2.avi\").touch()\n    tmp_path.joinpath(\"video2.srt\").touch()\n```\n\n----------------------------------------\n\nTITLE: Accessing Signal Arguments\nDESCRIPTION: This snippet shows how to access the arguments emitted with a signal using the `args` attribute of the blocker object returned by `qtbot.waitSignal`. If no arguments are emitted with the signal, `args` will be an empty list. If a timeout occurs, `args` will be None.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/signals.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef test_signal(qtbot):\n    ...\n    with qtbot.waitSignal(app.got_cmd) as blocker:\n        app.listen()\n    assert blocker.args == [\"test\"]\n```\n\n----------------------------------------\n\nTITLE: Using waitUntil with Assertion Callback\nDESCRIPTION: This snippet demonstrates how to use `qtbot.waitUntil` with a callback function containing the assertion. The test waits until the assertion passes or a timeout is reached, preventing flaky tests due to asynchronous Qt events. It relies on the `pytestqt` plugin to provide the `qtbot` fixture.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/wait_until.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef test_validate(qtbot):\n    window = MyWindow()\n    window.edit.setText(\"not a number\")\n    # after focusing, should update status label\n    window.edit.setFocus()\n\n    def check_label():\n        assert window.status.text() == \"Please input a number\"\n\n    qtbot.waitUntil(check_label)\n```\n\n----------------------------------------\n\nTITLE: Waiting for a Signal with Timeout\nDESCRIPTION: This snippet demonstrates how to use `qtbot.waitSignal` to wait for a signal to be emitted, with a timeout to prevent indefinite blocking. It connects to the signal and starts the worker, blocking until the signal is emitted or the timeout is reached.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/signals.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef test_long_computation(qtbot):\n    app = Application()\n\n    # Watch for the app.worker.finished signal, then start the worker.\n    with qtbot.waitSignal(app.worker.finished, timeout=10000) as blocker:\n        blocker.connect(app.worker.failed)  # Can add other signals to blocker\n        app.worker.start()\n        # Test will block at this point until either the \"finished\" or the\n        # \"failed\" signal is emitted. If 10 seconds passed without a signal,\n        # qtbot.TimeoutError will be raised.\n\n    assert_application_results(app)\n```\n\n----------------------------------------\n\nTITLE: Interacting with QComboBox Widgets\nDESCRIPTION: This snippet shows how to interact with QComboBox widgets using the setCurrentText method. It clears the combo box and sets the current text to simulate user interaction. Preferring widget methods like setCurrentText ensures appropriate signals are emitted for realistic testing.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/tutorial.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nwindow.fileComboBox.clear()\nwindow.fileComboBox.setCurrentText(\"*.avi\")\n\nwindow.directoryComboBox.clear()\nwindow.directoryComboBox.setCurrentText(str(tmp_path))\n```\n\n----------------------------------------\n\nTITLE: Configuring default raising behavior\nDESCRIPTION: This snippet shows how to configure the default raising behavior of `qtbot.waitSignal` by using the `qt_default_raising` ini option in the pytest configuration file.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/signals.rst#_snippet_2\n\nLANGUAGE: ini\nCODE:\n```\n[pytest]\nqt_default_raising = false\n```\n\n----------------------------------------\n\nTITLE: Asserting Callback Arguments with assert_called_with() in pytest-qt\nDESCRIPTION: This snippet shows how to use `cb.assert_called_with()` to verify that a callback was called with specific arguments, providing a concise way to test callback behavior in Qt applications.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/wait_callback.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ncb.assert_called_with(2)\n```\n\n----------------------------------------\n\nTITLE: Taking a Widget Screenshot with pytest-qt in Python\nDESCRIPTION: This code snippet demonstrates how to take a screenshot of a Qt widget using the pytest-qt plugin. It creates a QPushButton, adds it to the qtbot fixture, takes a screenshot, and then asserts false to show the screenshot path and fail the test, revealing the location of the generated screenshot file.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/debugging.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pytestqt.qt_compat import qt_api\n\n\n    def test_screenshot(qtbot):\n        button = qt_api.QtWidgets.QPushButton()\n        button.setText(\"Hello World!\")\n        qtbot.add_widget(button)\n        path = qtbot.screenshot(button)\n        assert False, path  # show the path and fail the test\n```\n\n----------------------------------------\n\nTITLE: Ensuring a Signal is Not Emitted\nDESCRIPTION: This code snippet demonstrates how to use `qtbot.assertNotEmitted` to assert that a particular signal is not emitted within a given block of code. It also shows how to use the `wait` parameter to wait for a specified duration for the signal not to be emitted, useful for asynchronous operations.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/signals.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef test_no_error(qtbot):\n    ...\n    with qtbot.assertNotEmitted(app.worker.error):\n        app.worker.start()\n\n\ndef test_no_error(qtbot):\n    ...\n    with qtbot.assertNotEmitted(page.loadFinished, wait=100):\n        page.runJavaScript(\"document.getElementById('not-a-link').click()\")\n```\n\n----------------------------------------\n\nTITLE: Monkeypatching QApplication.exit() in pytest-qt (Python)\nDESCRIPTION: This snippet demonstrates how to monkeypatch QApplication.exit() to prevent it from actually exiting the application during testing. This is useful when testing code that calls QApplication.exit() but should not terminate the test.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/qapplication.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef test_exit_button(qtbot, monkeypatch):\n    exit_calls = []\n    monkeypatch.setattr(QApplication, \"exit\", lambda: exit_calls.append(1))\n    button = get_app_exit_button()\n    button.click()\n    assert exit_calls == [1]\n```\n\n----------------------------------------\n\nTITLE: Simulating Button Click in Qt\nDESCRIPTION: This code snippet simulates a user clicking a button using the click() method of the QPushButton widget. This triggers the associated action within the application, allowing the test to verify the application's response.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/tutorial.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nwindow.findButton.click()\n```\n\n----------------------------------------\n\nTITLE: Testing Qt Widget Interaction with qtbot in pytest\nDESCRIPTION: This code snippet demonstrates how to use the `qtbot` fixture in pytest-qt to simulate a mouse click on a Qt widget button and assert that the widget's label text changes accordingly.  It requires a `HelloWidget` class with a button (`button_greet`) and a label (`greet_label`).\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/README.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\ndef test_hello(qtbot):\n    widget = HelloWidget()\n    qtbot.addWidget(widget)\n\n    # click in the Greet button and make sure it updates the appropriate label\n    qtbot.mouseClick(widget.button_greet, qt_api.QtCore.Qt.MouseButton.LeftButton)\n\n    assert widget.greet_label.text() == \"Hello!\"\n```\n\n----------------------------------------\n\nTITLE: Testing JavaScript Callback with QWebEnginePage in pytest-qt\nDESCRIPTION: This snippet shows how to use `qtbot.waitCallback` to test a callback executed by `QWebEnginePage.runJavaScript`.  It waits for the callback to be called within a timeout, and then asserts that it was called with the expected result.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/wait_callback.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef test_js(qtbot):\n    page = QWebEnginePage()\n    with qtbot.waitCallback() as cb:\n        page.runJavaScript(\"1 + 1\", cb)\n    cb.assert_called_with(2)  # result of the last js statement\n```\n\n----------------------------------------\n\nTITLE: Registering and Showing a Qt Window\nDESCRIPTION: This code snippet creates a PyQt window, shows it, and registers it with the qtbot fixture. Registering the widget ensures that it will be properly closed after the test is complete.  The qtbot.addWidget() function is used to register the widget.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/tutorial.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nwindow = Window()\nwindow.show()\nqtbot.addWidget(window)\n```\n\n----------------------------------------\n\nTITLE: Mocking QMessageBox.question with monkeypatch in Pytest\nDESCRIPTION: This snippet demonstrates how to use the monkeypatch fixture in pytest to mock the QMessageBox.question function.  It sets the function to always return QMessageBox.Yes, allowing for controlled testing of the `query` function in a simple Qt widget. The `qtbot` fixture is used to interact with the Qt widget.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/note_dialogs.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef test_Qt(qtbot, monkeypatch):\n    simple = Simple()\n    qtbot.addWidget(simple)\n\n    monkeypatch.setattr(QMessageBox, \"question\", lambda *args: QMessageBox.Yes)\n    simple.query()\n    assert simple.answer\n```\n\n----------------------------------------\n\nTITLE: Checking Signal Parameters with Callable\nDESCRIPTION: This example demonstrates how to use the `check_params_cb` parameter of `qtbot.waitSignal` to verify that a signal is emitted with expected parameters. It uses a callable function to compare the signal parameters with the expected values.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/signals.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef test_status_100(status):\n    \"\"\"Return true if status has reached 100%.\"\"\"\n    return status == 100\n\n\ndef test_status_complete(qtbot):\n    app = Application()\n\n    # the following raises if the worker's status signal (which has an int parameter) wasn't raised\n    # with value=100 within the default timeout\n    with qtbot.waitSignal(\n        app.worker.status, raising=True, check_params_cb=test_status_100\n    ) as blocker:\n        app.worker.start()\n```\n\n----------------------------------------\n\nTITLE: Capturing Qt Warning Messages in Python\nDESCRIPTION: This example demonstrates how pytest-qt automatically captures Qt warning messages emitted using qt_api.qWarning during a test and displays them when the test fails.  The example shows a test function `test_foo` that calls `do_something`, which emits a warning, and then asserts a failing condition to trigger the display of the captured log message.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/logging.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pytestqt.qt_compat import qt_api\n\n\ndef do_something():\n    qt_api.qWarning(\"this is a WARNING message\")\n\n\ndef test_foo():\n    do_something()\n    assert 0\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom QApplication Class (Python)\nDESCRIPTION: This snippet demonstrates how to define a custom QApplication class in Python, inheriting from qt_api.QtWidgets.QApplication and adding custom attributes and functions.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/qapplication.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom pytestqt.qt_compat import qt_api\n\n\nclass CustomQApplication(qt_api.QtWidgets.QApplication):\n    def __init__(self, *argv):\n        super().__init__(*argv)\n        self.custom_attr = \"xxx\"\n\n    def custom_function(self):\n        pass\n```\n\n----------------------------------------\n\nTITLE: Configuring Qt Log Level Fail in pytest.ini\nDESCRIPTION: This ini configuration demonstrates how to configure pytest-qt to automatically fail tests based on the level of Qt log messages emitted. Setting `qt_log_level_fail` to `CRITICAL` will cause tests to fail if any CRITICAL messages are emitted.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/logging.rst#_snippet_9\n\nLANGUAGE: ini\nCODE:\n```\n[pytest]\nqt_log_level_fail = CRITICAL\n```\n\n----------------------------------------\n\nTITLE: Testing QStandardItemModel with qtmodeltester in Python\nDESCRIPTION: This snippet demonstrates how to use the `qtmodeltester` fixture to test a `QStandardItemModel`.  It creates a `QStandardItemModel`, populates it with items, and then calls `qtmodeltester.check` to verify the model's integrity. The `qtmodeltester` fixture is assumed to be provided by `pytest-qt`.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/modeltester.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef test_standard_item_model(qtmodeltester):\n    model = QStandardItemModel()\n    items = [QStandardItem(str(i)) for i in range(4)]\n    model.setItem(0, 0, items[0])\n    model.setItem(0, 1, items[1])\n    model.setItem(1, 0, items[2])\n    model.setItem(1, 1, items[3])\n    qtmodeltester.check(model)\n```\n\n----------------------------------------\n\nTITLE: Waiting for Multiple Signals\nDESCRIPTION: This example demonstrates the usage of `qtbot.waitSignals` for waiting until all signals in a list are triggered. Like `waitSignal`, it supports the `raising` parameter. It shows waiting for a list of worker threads to finish.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/signals.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef test_workers(qtbot):\n    workers = spawn_workers()\n    with qtbot.waitSignals([w.finished for w in workers]):\n        for w in workers:\n            w.start()\n\n    # this will be reached after all workers emit their \"finished\"\n    # signal or a qtbot.TimeoutError will be raised\n    assert_application_results(app)\n```\n\n----------------------------------------\n\nTITLE: Asserting Results in a Qt Table Widget\nDESCRIPTION: This code snippet demonstrates how to assert the contents of a QTableWidget after an action has been performed. It checks the number of rows and the text of specific items within the table to ensure the expected results are present.  The rowCount() and item(row, column).text() methods are used.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/tutorial.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nassert window.filesTable.rowCount() == 2\nassert window.filesTable.item(0, 0).text() == \"video1.avi\"\nassert window.filesTable.item(1, 0).text() == \"video2.avi\"\n```\n\n----------------------------------------\n\nTITLE: Asserting Callback Arguments with pytest-qt\nDESCRIPTION: This snippet demonstrates how to access the arguments and keyword arguments passed to a callback after it has been called using `.args` and `.kwargs` respectively. It shows how to assert that the callback was called with the expected arguments.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/wait_callback.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nassert cb.args == [2]\nassert cb.kwargs == {}\n```\n\n----------------------------------------\n\nTITLE: Overriding the qapp_cls Fixture (Python)\nDESCRIPTION: This snippet shows how to override the `qapp_cls` fixture in `conftest.py` to use a custom QApplication class instead of the default QApplication. This allows tests to access custom application-level functions.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/qapplication.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n@pytest.fixture(scope=\"session\")\ndef qapp_cls():\n    return CustomQApplication\n```\n\n----------------------------------------\n\nTITLE: Custom Qt Dialog with static ask Method\nDESCRIPTION: This code defines a custom Qt dialog (AskNameAndAgeDialog) with a static `ask` method. The `ask` method creates an instance of the dialog, sets the text, executes the dialog, and returns the name and age if the dialog is accepted, otherwise returns None, None. This pattern simplifies the usage and testing of the dialog.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/note_dialogs.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass AskNameAndAgeDialog(QDialog):\n    @classmethod\n    def ask(cls, text, parent):\n        dialog = cls(parent)\n        dialog.text.setText(text)\n        if dialog.exec_() == QDialog.Accepted:\n            return dialog.getName(), dialog.getAge()\n        else:\n            return None, None\n```\n\n----------------------------------------\n\nTITLE: Handling Timeout Errors\nDESCRIPTION: This code snippet shows how to use the `raising` parameter in `qtbot.waitSignal` to prevent a `qtbot.TimeoutError` from being raised when a timeout occurs before a signal is triggered. It also shows how to check if the signal was triggered manually.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/signals.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef test_long_computation(qtbot):\n    ...\n    with qtbot.waitSignal(app.worker.finished, raising=False) as blocker:\n        app.worker.start()\n\n    assert_application_results(app)\n\n    # qtbot.TimeoutError is not raised, but you can still manually\n    # check whether the signal was triggered:\n    assert blocker.signal_triggered, \"process timed-out\"\n```\n\n----------------------------------------\n\nTITLE: Checking Parameters for Multiple Signals\nDESCRIPTION: This snippet shows how to use the `check_params_cbs` parameter with `qtbot.waitSignals` to check the parameters of multiple signals using a list of callable functions. Each callable corresponds to a signal in the `signals` list and is used to validate the signal's parameters.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/signals.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef test_status_100(status):\n    \"\"\"Return true if status has reached 100%.\"\"\"\n    return status == 100\n\n\ndef test_status_50(status):\n    \"\"\"Return true if status has reached 50%.\"\"\"\n    return status == 50\n\n\ndef test_status_complete(qtbot):\n    app = Application()\n\n    signals = [app.worker.status, app.worker.status, app.worker.finished]\n    callbacks = [test_status_50, test_status_100, None]\n    with qtbot.waitSignals(\n        signals, raising=True, check_params_cbs=callbacks\n    ) as blocker:\n        app.worker.start()\n```\n\n----------------------------------------\n\nTITLE: Overriding Qt Virtual Method in Python\nDESCRIPTION: This snippet demonstrates how to override a Qt virtual method, `mouseReleaseEvent`, in a Python class inheriting from `QWidget`.  It prints the mouse position when the mouse button is released.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/virtual_methods.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass MyWidget(QWidget):\n    # mouseReleaseEvent\n    def mouseReleaseEvent(self, ev):\n        print(f\"mouse released at: {ev.pos()}\")\n```\n\n----------------------------------------\n\nTITLE: Initial Assertion Example (Flaky)\nDESCRIPTION: This snippet showcases a test that might be flaky due to the asynchronous nature of Qt. The assertion might fail if the UI update triggered by `window.edit.setFocus()` hasn't completed when the assertion is made.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/wait_until.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef test_validate(qtbot):\n    window = MyWindow()\n    window.edit.setText(\"not a number\")\n    # after focusing, should update status label\n    window.edit.setFocus()\n    assert window.status.text() == \"Please input a number\"\n```\n\n----------------------------------------\n\nTITLE: Failing Tests on Critical Qt Messages in Python\nDESCRIPTION: This python code shows how to emit a critical Qt message using `qCritical`.  When `qt_log_level_fail` is set to `CRITICAL` or above, tests emitting such messages will automatically fail.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/logging.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom pytestqt.qt_compat import qCritical\n\n\ndef do_something():\n    qCritical(\"WM_PAINT failed\")\n\n\ndef test_foo(qtlog):\n    do_something()\n```\n\n----------------------------------------\n\nTITLE: Ignoring Specific Qt Log Messages in pytest.ini\nDESCRIPTION: This ini configuration demonstrates how to ignore specific Qt log messages using regular expressions defined in the `qt_log_ignore` option.  Messages matching these patterns will not cause tests to fail, even if the `qt_log_level_fail` option is configured to a level that would normally trigger a failure.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/logging.rst#_snippet_10\n\nLANGUAGE: ini\nCODE:\n```\n[pytest]\nqt_log_level_fail = CRITICAL\nqt_log_ignore =\n    WM_DESTROY.*sent\n    WM_PAINT failed\n```\n\n----------------------------------------\n\nTITLE: Exception in Qt Virtual Method Example\nDESCRIPTION: This snippet demonstrates an exception being raised within a Qt virtual method. Without pytest-qt's exception hook, this would only print a stack trace and not fail the test. `QTest` is used to simulate a mouse click on the widget.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/virtual_methods.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass MyWidget(QWidget):\n    def mouseReleaseEvent(self, ev):\n        raise RuntimeError(\"unexpected error\")\n\n\nw = MyWidget()\nQTest.mouseClick(w, QtCore.Qt.LeftButton)\n```\n\n----------------------------------------\n\nTITLE: Disabling Qt Logging with pytest.mark.no_qt_log\nDESCRIPTION: This python code demonstrates how to disable Qt logging capture for an entire test function using the `pytest.mark.no_qt_log` decorator.  When this mark is applied, any Qt logging messages emitted during the test will not be captured.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/logging.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n@pytest.mark.no_qt_log\ndef test_bar():\n    # logging is disabled for the entire test\n    do_something()\n```\n\n----------------------------------------\n\nTITLE: Usage of custom Qt dialog ask Method\nDESCRIPTION: This example shows how to use the custom dialog's static `ask` method.  It calls the method, passing a text prompt and a parent widget.  The returned name and age are then checked for being not None before further usage.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/note_dialogs.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nname, age = AskNameAndAgeDialog.ask(\"Enter name and age because of bananas:\", parent)\nif name is not None:\n    # use name and age for bananas\n    ...\n```\n\n----------------------------------------\n\nTITLE: Overriding qt_log_level_fail and qt_log_ignore using Marks\nDESCRIPTION: This python code demonstrates how to override the `qt_log_level_fail` setting and extend `qt_log_ignore` patterns for a specific test using the `pytest.mark.qt_log_level_fail` and `pytest.mark.qt_log_ignore` marks. This allows for fine-grained control over log-based test failures on a per-test basis.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/logging.rst#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\ndef do_something():\n    qCritical(\"WM_PAINT not handled\")\n    qCritical(\"QObject: widget destroyed in another thread\")\n\n\n@pytest.mark.qt_log_level_fail(\"CRITICAL\")\n@pytest.mark.qt_log_ignore(\"WM_DESTROY.*sent\", \"WM_PAINT failed\")\ndef test_foo(qtlog):\n    do_something()\n```\n\n----------------------------------------\n\nTITLE: Setting a QApplication Name in pytest.ini (INI)\nDESCRIPTION: This snippet demonstrates how to set a custom QApplication name using the `qt_qapp_name` option in the `pytest.ini` configuration file.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/qapplication.rst#_snippet_4\n\nLANGUAGE: ini\nCODE:\n```\n[pytest]\nqt_qapp_name = frobnicate-tests\n```\n\n----------------------------------------\n\nTITLE: Mocking QApplication.exit() in pytest-qt (Python)\nDESCRIPTION: This snippet demonstrates how to mock QApplication.exit() using the mock package to verify that it's called a certain number of times during a test, without actually exiting the application.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/qapplication.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef test_exit_button(qtbot):\n    with mock.patch.object(QApplication, \"exit\"):\n        button = get_app_exit_button()\n        button.click()\n        assert QApplication.exit.call_count == 1\n```\n\n----------------------------------------\n\nTITLE: Configuring Qt API in pytest.ini\nDESCRIPTION: This configuration snippet shows how to specify the desired Qt API (PySide6, PyQt6, or PyQt5) to be used by pytest-qt within the `pytest.ini` file. This configuration ensures the specified Qt binding is used for the tests.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/README.rst#_snippet_1\n\nLANGUAGE: INI\nCODE:\n```\n[pytest]\nqt_api=pyqt6\n```\n\n----------------------------------------\n\nTITLE: Disabling Exception Capture for a Specific Test\nDESCRIPTION: This snippet shows how to disable the automatic exception capture provided by pytest-qt for a single test function using the `qt_no_exception_capture` marker.  The marker is applied using `@pytest.mark.qt_no_exception_capture`.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/virtual_methods.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@pytest.mark.qt_no_exception_capture\ndef test_buttons(qtbot):\n    ...\n```\n\n----------------------------------------\n\nTITLE: Configuring Qt Log Format in pytest.ini\nDESCRIPTION: This ini configuration shows how to set the default Qt log format using the `qt_log_format` option within the `[pytest]` section of a `pytest.ini` file. This makes the custom format persistent across test runs.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/logging.rst#_snippet_6\n\nLANGUAGE: ini\nCODE:\n```\n[pytest]\nqt_log_format = {rec.when} {rec.type_name}: {rec.message}\n```\n\n----------------------------------------\n\nTITLE: Using qtlog.disabled() context manager\nDESCRIPTION: This python code demonstrates how to disable Qt logging capture within a specific block of code using the `qtlog.disabled()` context manager. Any Qt logging messages emitted within the `with` block will not be captured by pytest-qt.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/logging.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef test_foo(qtlog):\n    with qtlog.disabled():\n        # logging is disabled within the context manager\n        do_something()\n```\n\n----------------------------------------\n\nTITLE: Installing pre-commit\nDESCRIPTION: These shell commands install the `pre-commit` tool and configure it for the project.  `pre-commit` is used to run checks (like linting and formatting) on staged files before committing them, improving code quality.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/README.rst#_snippet_5\n\nLANGUAGE: Shell\nCODE:\n```\n$ pip install pre-commit\n$ pre-commit install\n```\n\n----------------------------------------\n\nTITLE: Overriding qt_log_ignore and not extending the list\nDESCRIPTION: This python code uses the mark `pytest.mark.qt_log_ignore` to override, instead of extending the list of ignored patterns. This is done by passing the argument `extend=False`.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/logging.rst#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n@pytest.mark.qt_log_ignore(\"WM_DESTROY.*sent\", extend=False)\ndef test_foo(qtlog):\n    do_something()\n```\n\n----------------------------------------\n\nTITLE: Running tests with tox\nDESCRIPTION: This shell command demonstrates how to run tests using `tox` against specific Python and Qt API combinations. This allows ensuring the package functions as intended across various supported configurations.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/README.rst#_snippet_4\n\nLANGUAGE: Shell\nCODE:\n```\n$ tox -e py-pyside6,py-pyqt5\n```\n\n----------------------------------------\n\nTITLE: Using qtbot.waitSignal in pytest tests\nDESCRIPTION: This snippet showcases the usage of `qtbot.waitSignal` to wait for a signal emitted by a worker thread. The `with` statement ensures proper handling of the signal, and the blocker provides access to the signal's information. The `timeout` parameter specifies the maximum time to wait in milliseconds. This example also illustrates how to connect other signals to the blocker to monitor for failures.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/CHANGELOG.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef test_long_computation(qtbot):\n    app = Application()\n\n    # Watch for the app.worker.finished signal, then start the worker.\n    with qtbot.waitSignal(app.worker.finished, timeout=10000) as blocker:\n        blocker.connect(app.worker.failed)  # Can add other signals to blocker\n        app.worker.start()\n        # Test will wait here until either signal is emitted, or 10 seconds has elapsed\n\n    assert blocker.signal_triggered  # Assuming the work took less than 10 seconds\n    assert_application_results(app)\n```\n\n----------------------------------------\n\nTITLE: Customizing Qt Log Format with pytest\nDESCRIPTION: This bash command shows how to customize the output format of Qt log messages using the `--qt-log-format` option. The format string allows attribute interpolation of the record objects, such as `rec.when`, `rec.type_name`, and `rec.message`.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/logging.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ pytest test.py --qt-log-format=\"{rec.when} {rec.type_name}: {rec.message}\"\n```\n\n----------------------------------------\n\nTITLE: Emitting Multiple Qt Critical Messages in Python\nDESCRIPTION: This python code emits two critical Qt messages using `qCritical`. The first message matches a pattern that is ignored, while the second does not. Thus, the test should fail.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/logging.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ndef do_something():\n    qCritical(\"WM_PAINT not handled\")\n    qCritical(\"QObject: widget destroyed in another thread\")\n\n\ndef test_foo(qtlog):\n    do_something()\n```\n\n----------------------------------------\n\nTITLE: Mocking custom Dialog ask Method in Pytest\nDESCRIPTION: This snippet shows how to mock the `ask` method of the custom dialog using monkeypatch for testing. It sets the `ask` method to return a fixed tuple ('John', 30), allowing the test to bypass the actual dialog interaction. The classmethod is required so that the mocked function gets the class as the first parameter.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/note_dialogs.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef test_form_registration(qtbot, monkeypatch):\n    user = User.empty_user()\n    form = RegistrationForm(user)\n\n    monkeypatch.setattr(\n        AskNameAndAgeDialog, \"ask\", classmethod(lambda *args: (\"John\", 30))\n    )\n    # Clicking on the button will call AskNameAndAgeDialog.ask in its slot.\n    form.enter_info_button.click()\n\n    assert user.name == \"John\"\n    assert user.age == 30\n```\n\n----------------------------------------\n\nTITLE: Disabling Exception Capture Project-Wide\nDESCRIPTION: This snippet shows how to disable the automatic exception capture provided by pytest-qt for an entire project by adding the `qt_no_exception_capture` option to the `pytest.ini` file.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/virtual_methods.rst#_snippet_3\n\nLANGUAGE: ini\nCODE:\n```\n[pytest]\nqt_no_exception_capture = 1\n```\n\n----------------------------------------\n\nTITLE: Disabling Qt Logging Capture with pytest\nDESCRIPTION: This bash command demonstrates how to disable Qt logging capture using the `--no-qt-log` option. When disabled, Qt messages are printed directly to stderr instead of being captured and displayed with test failures.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/logging.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npytest test.py -q --no-qt-log\nF\n================================== FAILURES ===================================\n_________________________________ test_types __________________________________\n\n    def test_foo():\n        do_something()\n>       assert 0\nE       assert 0\n\ntest.py:8: AssertionError\n---------------------------- Captured stderr call -----------------------------\nthis is a WARNING message\n```\n\n----------------------------------------\n\nTITLE: Configuring tox.ini for DISPLAY and XAUTHORITY\nDESCRIPTION: This configuration allows the DISPLAY and XAUTHORITY environment variables to be passed to the underlying pytest invocation within a tox environment, which is necessary for running GUI tests. This only works in environments with a GUI.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/troubleshooting.rst#_snippet_0\n\nLANGUAGE: ini\nCODE:\n```\n[testenv]\npassenv = DISPLAY XAUTHORITY\n```\n\n----------------------------------------\n\nTITLE: Installing pre-commit hooks\nDESCRIPTION: This shell command installs `pre-commit` hooks for linting and formatting checks before commits. This ensures code quality and consistency across the project.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/README.rst#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\n$ pre-commit install\n```\n\n----------------------------------------\n\nTITLE: Running pytest with Qt Logging Capture\nDESCRIPTION: This bash command shows how to run pytest and see the captured Qt messages in the output when a test fails. It uses the `-q` option for a quiet output and expects the failure to display the captured Qt messages.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/logging.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ pytest test.py -q\nF\n================================== FAILURES ===================================\n_________________________________ test_types __________________________________\n\n    def test_foo():\n        do_something()\n>       assert 0\nE       assert 0\n\ntest.py:8: AssertionError\n---------------------------- Captured Qt messages -----------------------------\nQtWarningMsg: this is a WARNING message\n1 failed in 0.01 seconds\n```\n\n----------------------------------------\n\nTITLE: Ignoring Specific Qt Log Messages with pytest\nDESCRIPTION: This bash command demonstrates that with the ignore patterns set in the pytest.ini the tests pass, as the critical messages are ignored.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/logging.rst#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\npytest test.py --color=no -q\n.\n1 passed in 0.01 seconds\n```\n\n----------------------------------------\n\nTITLE: Failing Tests on Unignored Qt Messages\nDESCRIPTION: This bash command shows how a test fails when a critical Qt message is emitted and not ignored by the `qt_log_ignore` option. It highlights that the ignore patterns filter out only specific messages, while others still cause failures as expected.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/logging.rst#_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\npytest test.py --color=no -q\nF\n================================== FAILURES ===================================\n__________________________________ test_foo ___________________________________\ntest.py:6: Failure: Qt messages with level CRITICAL or above emitted\n---------------------------- Captured Qt messages -----------------------------\nQtCriticalMsg: WM_PAINT not handled  (IGNORED)\nQtCriticalMsg: QObject: widget destroyed in another thread\n```\n\n----------------------------------------\n\nTITLE: Configuring qt_wait_signal_raising in pytest.ini\nDESCRIPTION: This snippet shows how to configure the `qt_wait_signal_raising` option in the `pytest.ini` file. This option is used to override the default value of the `raising` parameter in `qtbot.waitSignal` and `qtbot.waitSignals` functions. Setting it to `true` will cause a `SignalTimeoutError` to be raised when a timeout is reached.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/CHANGELOG.rst#_snippet_0\n\nLANGUAGE: ini\nCODE:\n```\n[pytest]\nqt_wait_signal_raising = true\n```\n\n----------------------------------------\n\nTITLE: Failing Tests Based on Qt Log Level\nDESCRIPTION: This bash command shows the result of running pytest when a Qt critical message is emitted and the `qt_log_level_fail` option is configured to fail tests on CRITICAL messages or above.  It demonstrates how a test can fail even without explicit assertion failures.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/logging.rst#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n>pytest test.py --color=no -q\nF\n================================== FAILURES ===================================\n__________________________________ test_foo ___________________________________\ntest.py:5: Failure: Qt messages with level CRITICAL or above emitted\n---------------------------- Captured Qt messages -----------------------------\nQtCriticalMsg: WM_PAINT failed\n```\n\n----------------------------------------\n\nTITLE: Travis CI Configuration for xvfb\nDESCRIPTION: This Travis CI configuration installs and configures xvfb and a window manager, herbstluftwm, to enable UI events during testing. This setup is required when running GUI tests in a headless environment.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/troubleshooting.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nsudo: required\n\nbefore_install:\n  - sudo apt-get update\n  - sudo apt-get install -y xvfb herbstluftwm\n\ninstall:\n  - \"export DISPLAY=:99.0\"\n  - \"/sbin/start-stop-daemon --start --quiet --pidfile /tmp/custom_xvfb_99.pid --make-pidfile --background --exec /usr/bin/Xvfb -- :99 -screen 0 1920x1200x24 -ac +extension GLX +render -noreset\"\n  - sleep 3\n\nbefore_script:\n  - \"herbstluftwm &\"\n  - sleep 1\n```\n\n----------------------------------------\n\nTITLE: GitHub Actions Configuration for Qt\nDESCRIPTION: This GitHub Actions workflow configures the environment for running Qt-based GUI tests. It installs necessary dependencies, sets the DISPLAY variable, and starts Xvfb.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/troubleshooting.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nname: my qt ci in github actions\non: [push, pull_request]\njobs:\n  Linux:\n    runs-on: ${{ matrix.os }}\n    strategy:\n      matrix:\n        os : [ubuntu-latest]\n        python: [\"3.10\"]\n    env:\n      DISPLAY: ':99.0'\n    steps:\n    - name: get repo\n      uses: actions/checkout@v3\n    - name: Set up Python\n      uses: actions/setup-python@v4\n      with:\n        python-version: ${{ matrix.python }}\n    - name: setup ${{ matrix.os }}\n      run: |\n        sudo apt install libxkbcommon-x11-0 libxcb-icccm4 libxcb-image0 libxcb-keysyms1 libxcb-randr0 libxcb-render-util0 libxcb-xinerama0 libxcb-xfixes0 x11-utils\n        /sbin/start-stop-daemon --start --quiet --pidfile /tmp/custom_xvfb_99.pid --make-pidfile --background --exec /usr/bin/Xvfb -- :99 -screen 0 1920x1200x24 -ac +extension GLX\n```\n\n----------------------------------------\n\nTITLE: GitLab CI/CD Configuration for Qt6\nDESCRIPTION: This GitLab CI/CD configuration sets up the environment for running Qt6-based GUI tests.  It installs necessary dependencies including xcb libraries, sets the DISPLAY variable, starts Xvfb, installs pyqt6 and pytest-qt, then executes the tests.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/troubleshooting.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\nvariables:\n  DISPLAY: ':99.0'\n\ntest:\n  stage: test\n  image: python:3.11\n  script:\n    - apt update\n    - apt install -y libgl1 libegl1 libdbus-1-3 libxcb-cursor0 libxkbcommon-x11-0 libxcb-icccm4 libxcb-image0 libxcb-keysyms1 libxcb-randr0 libxcb-render-util0 libxcb-xinerama0 libxcb-xfixes0 x11-utils xvfb\n    - /sbin/start-stop-daemon --start --quiet --pidfile /tmp/custom_xvfb_99.pid --make-pidfile --background --exec /usr/bin/Xvfb -- :99 -screen 0 1920x1200x24 -ac +extension GLX\n    - python -m pip install pyqt6 pytest-qt\n\n    - python -m pytest test.py\n```\n\n----------------------------------------\n\nTITLE: Installing pytest-qt with Development Dependencies\nDESCRIPTION: This shell command shows how to install pytest-qt in editable mode with development dependencies, useful for contributing to the project.  It installs the package and its development requirements, allowing for live changes during development.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/README.rst#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\n$ pip install --editable .[dev]\n```\n\n----------------------------------------\n\nTITLE: Exceptions raised in virtual methods in pytest tests\nDESCRIPTION: This snippet shows how exceptions raised in virtual methods are handled in pytest tests. If an exception is raised, the test will fail, and exceptions that happened inside virtual calls will be printed. The snippet shows an example output if there's an exception.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/CHANGELOG.rst#_snippet_2\n\nLANGUAGE: none\nCODE:\n```\nE           Failed: Qt exceptions in virtual methods:\nE           ________________________________________________________________________________\nE             File \"x:\\pytest-qt\\pytestqt\\_tests\\test_exceptions.py\", line 14, in event\nE               raise ValueError('mistakes were made')\nE\n```\n\n----------------------------------------\n\nTITLE: Configuring Qt API in pytest.ini\nDESCRIPTION: This code snippet shows how to configure the Qt API to be used by pytest-qt in the `pytest.ini` file. By setting the `qt_api` configuration variable to `pyqt5`, the tests will specifically use the PyQt5 API, regardless of which Qt bindings are installed on the system. This provides control over the Qt API used during testing.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/intro.rst#_snippet_1\n\nLANGUAGE: INI\nCODE:\n```\n[pytest]\nqt_api=pyqt5\n```\n\n----------------------------------------\n\nTITLE: Using waitUntil with Condition Callback\nDESCRIPTION: This snippet shows how to use `qtbot.waitUntil` with a lambda function that returns `True` when the desired condition is met and `False` otherwise.  While terser, failure messages will be generic, unlike the version with an assertion callback.  It depends on the `pytestqt` plugin and the Qt framework.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/wait_until.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef test_validate(qtbot):\n    window = MyWindow()\n    window.edit.setText(\"not a number\")\n    # after focusing, should update status label\n    window.edit.setFocus()\n    qtbot.waitUntil(lambda: window.edit.hasFocus())\n    assert window.status.text() == \"Please input a number\"\n```\n\n----------------------------------------\n\nTITLE: Testing Qt Widgets with pytest-qt in Python\nDESCRIPTION: This code snippet demonstrates how to use the `qtbot` fixture provided by pytest-qt to test a Qt widget. It creates an instance of a `HelloWidget`, adds it to `qtbot`, simulates a button click, and asserts that the label text is updated as expected. This shows how to interact with and verify the behavior of Qt widgets within pytest.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/intro.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\ndef test_hello(qtbot):\n    widget = HelloWidget()\n    qtbot.addWidget(widget)\n\n    # Click the greet button and make sure the appropriate label is updated.\n    widget.button_greet.click()\n\n    assert widget.greet_label.text() == \"Hello!\"\n```\n\n----------------------------------------\n\nTITLE: Azure Pipelines Configuration for Qt6 on Ubuntu\nDESCRIPTION: This Azure Pipelines configuration installs and starts Xvfb along with other required dependencies for running Qt6 GUI tests on the ubuntu-latest image. It also sets environment variables to avoid crashes during testing.\nSOURCE: https://github.com/pytest-dev/pytest-qt/blob/master/docs/troubleshooting.rst#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\n# Set these environment variables for the job that runs tests\n\nvariables:\n  DISPLAY: ':99.0'  # This is needed for pytest-qt not to crash as mentioned above\n  # Python fault handler is enabled in case UI tests crash without meaningful error messages\n  PYTHONFAULTHANDLER: 'enabled'  # https://docs.python.org/3/library/faulthandler.html\n\n# Add this step to your CI pipeline before running your pytest-qt-based Qt6 tests with pytest\n\n    # this was tested with ``ubuntu-latest`` image\n    - script: |\n        sudo apt update\n        sudo apt-get install -y xvfb libxkbcommon-x11-0 libxcb-icccm4 libxcb-image0 libxcb-keysyms1 libxcb-randr0 libxcb-render-util0 libxcb-xinerama0 libxcb-xinput0 libxcb-xfixes0 libxcb-shape0 libglib2.0-0 libgl1-mesa-dev\n        sudo apt-get install -y '^libxcb.*-dev' libx11-xcb-dev libglu1-mesa-dev libxrender-dev libxi-dev libxkbcommon-dev libxkbcommon-x11-dev\n        sudo apt-get install -y x11-utils\n        /sbin/start-stop-daemon --start --quiet --pidfile /tmp/custom_xvfb_99.pid --make-pidfile --background --exec /usr/bin/Xvfb -- :99 -screen 0 1920x1200x24 -ac +extension GLX\n      displayName: 'Install and start xvfb and other dependencies on Linux for Qt GUI tests'\n      condition: and(succeededOrFailed(), eq(variables['Agent.OS'], 'Linux'))\n```"
  }
]