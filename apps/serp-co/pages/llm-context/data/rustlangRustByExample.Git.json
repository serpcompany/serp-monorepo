[
  {
    "owner": "rust-lang",
    "repo": "rust-by-example.git",
    "content": "TITLE: Implementing Traits for Structs in Rust\nDESCRIPTION: This code snippet demonstrates the definition of a trait 'Animal' and its implementation for a 'Sheep' struct. It shows how to define associated functions, method signatures, provide default implementations, and override trait methods. The example also includes struct-specific methods and showcases trait usage in the main function.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/trait.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Sheep { naked: bool, name: &'static str }\n\ntrait Animal {\n    // Associated function signature; `Self` refers to the implementor type.\n    fn new(name: &'static str) -> Self;\n\n    // Method signatures; these will return a string.\n    fn name(&self) -> &'static str;\n    fn noise(&self) -> &'static str;\n\n    // Traits can provide default method definitions.\n    fn talk(&self) {\n        println!(\"{} says {}\", self.name(), self.noise());\n    }\n}\n\nimpl Sheep {\n    fn is_naked(&self) -> bool {\n        self.naked\n    }\n\n    fn shear(&mut self) {\n        if self.is_naked() {\n            // Implementor methods can use the implementor's trait methods.\n            println!(\"{} is already naked...\", self.name());\n        } else {\n            println!(\"{} gets a haircut!\", self.name);\n\n            self.naked = true;\n        }\n    }\n}\n\n// Implement the `Animal` trait for `Sheep`.\nimpl Animal for Sheep {\n    // `Self` is the implementor type: `Sheep`.\n    fn new(name: &'static str) -> Sheep {\n        Sheep { name: name, naked: false }\n    }\n\n    fn name(&self) -> &'static str {\n        self.name\n    }\n\n    fn noise(&self) -> &'static str {\n        if self.is_naked() {\n            \"baaaaah?\"\n        } else {\n            \"baaaaah!\"\n        }\n    }\n    \n    // Default trait methods can be overridden.\n    fn talk(&self) {\n        // For example, we can add some quiet contemplation.\n        println!(\"{} pauses briefly... {}\", self.name, self.noise());\n    }\n}\n\nfn main() {\n    // Type annotation is necessary in this case.\n    let mut dolly: Sheep = Animal::new(\"Dolly\");\n    // TODO ^ Try removing the type annotations.\n\n    dolly.talk();\n    dolly.shear();\n    dolly.talk();\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Ownership and Move Semantics in Rust\nDESCRIPTION: This code demonstrates Rust's ownership rules, including the differences between stack and heap allocations, copying vs. moving values, and how ownership transfers affect variable accessibility. It also shows how Rust prevents use-after-free errors through compile-time checks.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/scope/move.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// This function takes ownership of the heap allocated memory\nfn destroy_box(c: Box<i32>) {\n    println!(\"Destroying a box that contains {}\", c);\n\n    // `c` is destroyed and the memory freed\n}\n\nfn main() {\n    // _Stack_ allocated integer\n    let x = 5u32;\n\n    // *Copy* `x` into `y` - no resources are moved\n    let y = x;\n\n    // Both values can be independently used\n    println!(\"x is {}, and y is {}\", x, y);\n\n    // `a` is a pointer to a _heap_ allocated integer\n    let a = Box::new(5i32);\n\n    println!(\"a contains: {}\", a);\n\n    // *Move* `a` into `b`\n    let b = a;\n    // The pointer address of `a` is copied (not the data) into `b`.\n    // Both are now pointers to the same heap allocated data, but\n    // `b` now owns it.\n    \n    // Error! `a` can no longer access the data, because it no longer owns the\n    // heap memory\n    //println!(\"a contains: {}\", a);\n    // TODO ^ Try uncommenting this line\n\n    // This function takes ownership of the heap allocated memory from `b`\n    destroy_box(b);\n\n    // Since the heap memory has been freed at this point, this action would\n    // result in dereferencing freed memory, but it's forbidden by the compiler\n    // Error! Same reason as the previous Error\n    //println!(\"b contains: {}\", b);\n    // TODO ^ Try uncommenting this line\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Boxing in Rust\nDESCRIPTION: This snippet demonstrates how to use Box<dyn error::Error> for error handling in Rust. It defines a custom error type (EmptyVec), implements the Error trait, and shows how to convert errors into boxed trait objects using the into() method. The example processes vectors of strings, attempting to parse and double the first item.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/error/multiple_error_types/boxing_errors.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::error;\nuse std::fmt;\n\n// Change the alias to use `Box<dyn error::Error>`.\ntype Result<T> = std::result::Result<T, Box<dyn error::Error>>;\n\n#[derive(Debug, Clone)]\nstruct EmptyVec;\n\nimpl fmt::Display for EmptyVec {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"invalid first item to double\")\n    }\n}\n\nimpl error::Error for EmptyVec {}\n\nfn double_first(vec: Vec<&str>) -> Result<i32> {\n    vec.first()\n        .ok_or_else(|| EmptyVec.into()) // Converts to Box\n        .and_then(|s| {\n            s.parse::<i32>()\n                .map_err(|e| e.into()) // Converts to Box\n                .map(|i| 2 * i)\n        })\n}\n\nfn print(result: Result<i32>) {\n    match result {\n        Ok(n) => println!(\"The first doubled is {}\", n),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n\nfn main() {\n    let numbers = vec![\"42\", \"93\", \"18\"];\n    let empty = vec![];\n    let strings = vec![\"tofu\", \"93\", \"18\"];\n\n    print(double_first(numbers));\n    print(double_first(empty));\n    print(double_first(strings));\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing String Parsing with Result and Unwrap in Rust\nDESCRIPTION: Demonstrates basic usage of Result type with string parsing and unwrap(). Shows both successful and failing cases of parsing strings to integers, highlighting potential panic scenarios.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/error/result.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn multiply(first_number_str: &str, second_number_str: &str) -> i32 {\n    // Let's try using `unwrap()` to get the number out. Will it bite us?\n    let first_number = first_number_str.parse::<i32>().unwrap();\n    let second_number = second_number_str.parse::<i32>().unwrap();\n    first_number * second_number\n}\n\nfn main() {\n    let twenty = multiply(\"10\", \"2\");\n    println!(\"double is {}\", twenty);\n\n    let tt = multiply(\"t\", \"2\");\n    println!(\"double is {}\", tt);\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Borrowing and Ownership in Rust\nDESCRIPTION: This example shows how Rust's borrowing system works, including taking ownership, borrowing references, and how the borrow checker prevents use-after-free errors. It demonstrates how objects cannot be destroyed while references to them exist and how ownership can be transferred once all borrows are complete.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/scope/borrow.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// This function takes ownership of a box and destroys it\nfn eat_box_i32(boxed_i32: Box<i32>) {\n    println!(\"Destroying box that contains {}\", boxed_i32);\n}\n\n// This function borrows an i32\nfn borrow_i32(borrowed_i32: &i32) {\n    println!(\"This int is: {}\", borrowed_i32);\n}\n\nfn main() {\n    // Create a boxed i32 in the heap, and a i32 on the stack\n    // Remember: numbers can have arbitrary underscores added for readability\n    // 5_i32 is the same as 5i32\n    let boxed_i32 = Box::new(5_i32);\n    let stacked_i32 = 6_i32;\n\n    // Borrow the contents of the box. Ownership is not taken,\n    // so the contents can be borrowed again.\n    borrow_i32(&boxed_i32);\n    borrow_i32(&stacked_i32);\n\n    {\n        // Take a reference to the data contained inside the box\n        let _ref_to_i32: &i32 = &boxed_i32;\n\n        // Error!\n        // Can't destroy `boxed_i32` while the inner value is borrowed later in scope.\n        eat_box_i32(boxed_i32);\n        // FIXME ^ Comment out this line\n\n        // Attempt to borrow `_ref_to_i32` after inner value is destroyed\n        borrow_i32(_ref_to_i32);\n        // `_ref_to_i32` goes out of scope and is no longer borrowed.\n    }\n\n    // `boxed_i32` can now give up ownership to `eat_box_i32` and be destroyed\n    eat_box_i32(boxed_i32);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Early Returns for Error Handling in Rust\nDESCRIPTION: This code snippet demonstrates how to use early returns with match statements to handle errors when parsing string inputs to integers and performing multiplication. It includes a multiply function that returns a Result type, and a print function to display the result or error.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/error/result/early_returns.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::num::ParseIntError;\n\nfn multiply(first_number_str: &str, second_number_str: &str) -> Result<i32, ParseIntError> {\n    let first_number = match first_number_str.parse::<i32>() {\n        Ok(first_number)  => first_number,\n        Err(e) => return Err(e),\n    };\n\n    let second_number = match second_number_str.parse::<i32>() {\n        Ok(second_number)  => second_number,\n        Err(e) => return Err(e),\n    };\n\n    Ok(first_number * second_number)\n}\n\nfn print(result: Result<i32, ParseIntError>) {\n    match result {\n        Ok(n)  => println!(\"n is {}\", n),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n\nfn main() {\n    print(multiply(\"10\", \"2\"));\n    print(multiply(\"t\", \"2\"));\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Error Handling with Result Enum in Rust\nDESCRIPTION: This comprehensive example demonstrates creating a custom mathematics module with proper error handling using Rust's Result enum. It defines a custom MathError type for different mathematical errors, implements safe versions of division, square root, and natural logarithm functions, and shows how to chain operations with match expressions.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/std/result.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nmod checked {\n    // Mathematical \"errors\" we want to catch\n    #[derive(Debug)]\n    pub enum MathError {\n        DivisionByZero,\n        NonPositiveLogarithm,\n        NegativeSquareRoot,\n    }\n\n    pub type MathResult = Result<f64, MathError>;\n\n    pub fn div(x: f64, y: f64) -> MathResult {\n        if y == 0.0 {\n            // This operation would `fail`, instead let's return the reason of\n            // the failure wrapped in `Err`\n            Err(MathError::DivisionByZero)\n        } else {\n            // This operation is valid, return the result wrapped in `Ok`\n            Ok(x / y)\n        }\n    }\n\n    pub fn sqrt(x: f64) -> MathResult {\n        if x < 0.0 {\n            Err(MathError::NegativeSquareRoot)\n        } else {\n            Ok(x.sqrt())\n        }\n    }\n\n    pub fn ln(x: f64) -> MathResult {\n        if x <= 0.0 {\n            Err(MathError::NonPositiveLogarithm)\n        } else {\n            Ok(x.ln())\n        }\n    }\n}\n\n// `op(x, y)` === `sqrt(ln(x / y))`\nfn op(x: f64, y: f64) -> f64 {\n    // This is a three level match pyramid!\n    match checked::div(x, y) {\n        Err(why) => panic!(\"{:?}\", why),\n        Ok(ratio) => match checked::ln(ratio) {\n            Err(why) => panic!(\"{:?}\", why),\n            Ok(ln) => match checked::sqrt(ln) {\n                Err(why) => panic!(\"{:?}\", why),\n                Ok(sqrt) => sqrt,\n            },\n        },\n    }\n}\n\nfn main() {\n    // Will this fail?\n    println!(\"{}\", op(1.0, 10.0));\n}\n```\n\n----------------------------------------\n\nTITLE: Simple Option Unpacking with ? Operator in Rust\nDESCRIPTION: Demonstrates basic usage of the ? operator to handle an Option<u8> and return an Option<String>. The function adds 1 to the age if present, or returns None if the input is None.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/error/option_unwrap/question_mark.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn next_birthday(current_age: Option<u8>) -> Option<String> {\n    // If `current_age` is `None`, this returns `None`.\n    // If `current_age` is `Some`, the inner `u8` value + 1\n    // gets assigned to `next_age`\n    let next_age: u8 = current_age? + 1;\n    Some(format!(\"Next year I will be {}\", next_age))\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Mutable and Immutable References with Rust Book Struct\nDESCRIPTION: Demonstrates Rust's borrowing rules and mutability concepts using a Book struct example. Shows how to create and use both mutable and immutable references, including function parameters that borrow data. Includes examples of valid and invalid borrowing patterns.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/scope/borrow/mut.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[allow(dead_code)]\n#[derive(Clone, Copy)]\nstruct Book {\n    // `&'static str` is a reference to a string allocated in read only memory\n    author: &'static str,\n    title: &'static str,\n    year: u32,\n}\n\n// This function takes a reference to a book\nfn borrow_book(book: &Book) {\n    println!(\"I immutably borrowed {} - {} edition\", book.title, book.year);\n}\n\n// This function takes a reference to a mutable book and changes `year` to 2014\nfn new_edition(book: &mut Book) {\n    book.year = 2014;\n    println!(\"I mutably borrowed {} - {} edition\", book.title, book.year);\n}\n\nfn main() {\n    // Create an immutable Book named `immutabook`\n    let immutabook = Book {\n        // string literals have type `&'static str`\n        author: \"Douglas Hofstadter\",\n        title: \"Gödel, Escher, Bach\",\n        year: 1979,\n    };\n\n    // Create a mutable copy of `immutabook` and call it `mutabook`\n    let mut mutabook = immutabook;\n    \n    // Immutably borrow an immutable object\n    borrow_book(&immutabook);\n\n    // Immutably borrow a mutable object\n    borrow_book(&mutabook);\n    \n    // Borrow a mutable object as mutable\n    new_edition(&mut mutabook);\n    \n    // Error! Cannot borrow an immutable object as mutable\n    new_edition(&mut immutabook);\n    // FIXME ^ Comment out this line\n}\n```\n\n----------------------------------------\n\nTITLE: Introducing Flow Control Structures in Rust\nDESCRIPTION: This snippet demonstrates basic flow control keywords in Rust, specifically 'if'/'else' and 'for'. These are fundamental structures for modifying program execution flow in Rust.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/flow_control.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nif/else, for\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Rust Type System and Variable Declaration\nDESCRIPTION: Example showing various aspects of Rust's type system including type annotation, inference, mutability, and compound types. Demonstrates primitive scalar types, arrays, tuples, and variable shadowing concepts.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/primitives.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    // Variables can be type annotated.\n    let logical: bool = true;\n\n    let a_float: f64 = 1.0;  // Regular annotation\n    let an_integer   = 5i32; // Suffix annotation\n\n    // Or a default will be used.\n    let default_float   = 3.0; // `f64`\n    let default_integer = 7;   // `i32`\n\n    // A type can also be inferred from context.\n    let mut inferred_type = 12; // Type i64 is inferred from another line.\n    inferred_type = 4294967296i64;\n\n    // A mutable variable's value can be changed.\n    let mut mutable = 12; // Mutable `i32`\n    mutable = 21;\n\n    // Error! The type of a variable can't be changed.\n    mutable = true;\n\n    // Variables can be overwritten with shadowing.\n    let mutable = true;\n\n    /* Compound types - Array and Tuple */\n\n    // Array signature consists of Type T and length as [T; length].\n    let my_array: [i32; 5] = [1, 2, 3, 4, 5];\n\n    // Tuple is a collection of values of different types \n    // and is constructed using parentheses ().\n    let my_tuple = (5u32, 1u8, true, -5.04f32);\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Variable Capture Methods in Rust Closures\nDESCRIPTION: Shows different ways closures can capture variables including immutable references, mutable references, and value ownership. Demonstrates borrowing rules and mutation restrictions with practical examples using String, counter, and Box types.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/fn/closures/capture.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    use std::mem;\n    \n    let color = String::from(\"green\");\n\n    let print = || println!(\"`color`: {}\", color);\n\n    print();\n\n    let _reborrow = &color;\n    print();\n\n    let _color_moved = color;\n\n\n    let mut count = 0;\n    let mut inc = || {\n        count += 1;\n        println!(\"`count`: {}\", count);\n    };\n\n    inc();\n\n    inc();\n\n    let _count_reborrowed = &mut count; \n\n    \n    let movable = Box::new(3);\n\n    let consume = || {\n        println!(\"`movable`: {:?}\", movable);\n        mem::drop(movable);\n    };\n\n    consume();\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying Option In-Place with get_or_insert() in Rust\nDESCRIPTION: This snippet shows how to use get_or_insert() to modify an Option in place with a fallback value. It demonstrates eager evaluation and its effect on variable movement.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/error/option_unwrap/defaults.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Debug)]\nenum Fruit { Apple, Orange, Banana, Kiwi, Lemon }\n\nfn main() {\n    let mut my_fruit: Option<Fruit> = None;\n    let apple = Fruit::Apple;\n    let first_available_fruit = my_fruit.get_or_insert(apple);\n    println!(\"first_available_fruit is: {:?}\", first_available_fruit);\n    println!(\"my_fruit is: {:?}\", my_fruit);\n    // first_available_fruit is: Apple\n    // my_fruit is: Some(Apple)\n    //println!(\"Variable named `apple` is moved: {:?}\", apple);\n    // TODO: uncomment the line above to see the compiler error\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Higher Order Functions in Rust\nDESCRIPTION: This code demonstrates two approaches to calculate the sum of odd square numbers below 1000: an imperative approach using a traditional for loop, and a functional approach using HOFs like map, take_while, filter, and sum. The example showcases how HOFs can make code more concise and declarative while maintaining readability.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/fn/hof.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn is_odd(n: u32) -> bool {\n    n % 2 == 1\n}\n\nfn main() {\n    println!(\"Find the sum of all the numbers with odd squares under 1000\");\n    let upper = 1000;\n\n    // Imperative approach\n    // Declare accumulator variable\n    let mut acc = 0;\n    // Iterate: 0, 1, 2, ... to infinity\n    for n in 0.. {\n        // Square the number\n        let n_squared = n * n;\n\n        if n_squared >= upper {\n            // Break loop if exceeded the upper limit\n            break;\n        } else if is_odd(n_squared) {\n            // Accumulate value, if it's odd\n            acc += n_squared;\n        }\n    }\n    println!(\"imperative style: {}\", acc);\n\n    // Functional approach\n    let sum_of_squared_odd_numbers: u32 =\n        (0..).map(|n| n * n)                             // All natural numbers squared\n             .take_while(|&n_squared| n_squared < upper) // Below upper limit\n             .filter(|&n_squared| is_odd(n_squared))     // That are odd\n             .sum();                                     // Sum them\n    println!(\"functional style: {}\", sum_of_squared_odd_numbers);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Associated Functions and Methods in Rust Structs\nDESCRIPTION: This comprehensive example demonstrates the implementation of associated functions and methods for Rust structs. It shows how to define constructors as associated functions, implement methods with different receiver types (&self, &mut self, self), and how to call them. The example covers struct definition, implementation blocks, method invocation, and ownership concepts.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/fn/methods.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Point {\n    x: f64,\n    y: f64,\n}\n\n// Implementation block, all `Point` associated functions & methods go in here\nimpl Point {\n    // This is an \"associated function\" because this function is associated with\n    // a particular type, that is, Point.\n    //\n    // Associated functions don't need to be called with an instance.\n    // These functions are generally used like constructors.\n    fn origin() -> Point {\n        Point { x: 0.0, y: 0.0 }\n    }\n\n    // Another associated function, taking two arguments:\n    fn new(x: f64, y: f64) -> Point {\n        Point { x: x, y: y }\n    }\n}\n\nstruct Rectangle {\n    p1: Point,\n    p2: Point,\n}\n\nimpl Rectangle {\n    // This is a method\n    // `&self` is sugar for `self: &Self`, where `Self` is the type of the\n    // caller object. In this case `Self` = `Rectangle`\n    fn area(&self) -> f64 {\n        // `self` gives access to the struct fields via the dot operator\n        let Point { x: x1, y: y1 } = self.p1;\n        let Point { x: x2, y: y2 } = self.p2;\n\n        // `abs` is a `f64` method that returns the absolute value of the\n        // caller\n        ((x1 - x2) * (y1 - y2)).abs()\n    }\n\n    fn perimeter(&self) -> f64 {\n        let Point { x: x1, y: y1 } = self.p1;\n        let Point { x: x2, y: y2 } = self.p2;\n\n        2.0 * ((x1 - x2).abs() + (y1 - y2).abs())\n    }\n\n    // This method requires the caller object to be mutable\n    // `&mut self` desugars to `self: &mut Self`\n    fn translate(&mut self, x: f64, y: f64) {\n        self.p1.x += x;\n        self.p2.x += x;\n\n        self.p1.y += y;\n        self.p2.y += y;\n    }\n}\n\n// `Pair` owns resources: two heap allocated integers\nstruct Pair(Box<i32>, Box<i32>);\n\nimpl Pair {\n    // This method \"consumes\" the resources of the caller object\n    // `self` desugars to `self: Self`\n    fn destroy(self) {\n        // Destructure `self`\n        let Pair(first, second) = self;\n\n        println!(\"Destroying Pair({}, {})\", first, second);\n\n        // `first` and `second` go out of scope and get freed\n    }\n}\n\nfn main() {\n    let rectangle = Rectangle {\n        // Associated functions are called using double colons\n        p1: Point::origin(),\n        p2: Point::new(3.0, 4.0),\n    };\n\n    // Methods are called using the dot operator\n    // Note that the first argument `&self` is implicitly passed, i.e.\n    // `rectangle.perimeter()` === `Rectangle::perimeter(&rectangle)`\n    println!(\"Rectangle perimeter: {}\", rectangle.perimeter());\n    println!(\"Rectangle area: {}\", rectangle.area());\n\n    let mut square = Rectangle {\n        p1: Point::origin(),\n        p2: Point::new(1.0, 1.0),\n    };\n\n    // Error! `rectangle` is immutable, but this method requires a mutable\n    // object\n    //rectangle.translate(1.0, 0.0);\n    // TODO ^ Try uncommenting this line\n\n    // Okay! Mutable objects can call mutable methods\n    square.translate(1.0, 1.0);\n\n    let pair = Pair(Box::new(1), Box::new(2));\n\n    pair.destroy();\n\n    // Error! Previous `destroy` call \"consumed\" `pair`\n    //pair.destroy();\n    // TODO ^ Try uncommenting this line\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing and Using Trait Bounds with Generics in Rust\nDESCRIPTION: A complete example demonstrating how trait bounds allow generic instances to access methods of the specified traits. It shows custom traits, implementations, and generic functions that operate on bounded types.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/generics/bounds.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n// A trait which implements the print marker: `{:?}`.\nuse std::fmt::Debug;\n\ntrait HasArea {\n    fn area(&self) -> f64;\n}\n\nimpl HasArea for Rectangle {\n    fn area(&self) -> f64 { self.length * self.height }\n}\n\n#[derive(Debug)]\nstruct Rectangle { length: f64, height: f64 }\n#[allow(dead_code)]\nstruct Triangle  { length: f64, height: f64 }\n\n// The generic `T` must implement `Debug`. Regardless\n// of the type, this will work properly.\nfn print_debug<T: Debug>(t: &T) {\n    println!(\"{:?}\", t);\n}\n\n// `T` must implement `HasArea`. Any type which meets\n// the bound can access `HasArea`'s function `area`.\nfn area<T: HasArea>(t: &T) -> f64 { t.area() }\n\nfn main() {\n    let rectangle = Rectangle { length: 3.0, height: 4.0 };\n    let _triangle = Triangle  { length: 3.0, height: 4.0 };\n\n    print_debug(&rectangle);\n    println!(\"Area: {}\", area(&rectangle));\n\n    //print_debug(&_triangle);\n    //println!(\"Area: {}\", area(&_triangle));\n    // ^ TODO: Try uncommenting these.\n    // | Error: Does not implement either `Debug` or `HasArea`. \n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Rust Structures with Examples\nDESCRIPTION: This example demonstrates how to define and use the three types of Rust structures: classic structs with named fields, tuple structs, and unit structs. It shows field initialization, struct update syntax, field access, and destructuring patterns.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/custom_types/structs.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// An attribute to hide warnings for unused code.\n#![allow(dead_code)]\n\n#[derive(Debug)]\nstruct Person {\n    name: String,\n    age: u8,\n}\n\n// A unit struct\nstruct Unit;\n\n// A tuple struct\nstruct Pair(i32, f32);\n\n// A struct with two fields\nstruct Point {\n    x: f32,\n    y: f32,\n}\n\n// Structs can be reused as fields of another struct\nstruct Rectangle {\n    // A rectangle can be specified by where the top left and bottom right\n    // corners are in space.\n    top_left: Point,\n    bottom_right: Point,\n}\n\nfn main() {\n    // Create struct with field init shorthand\n    let name = String::from(\"Peter\");\n    let age = 27;\n    let peter = Person { name, age };\n\n    // Print debug struct\n    println!(\"{:?}\", peter);\n\n    // Instantiate a `Point`\n    let point: Point = Point { x: 5.2, y: 0.4 };\n    let another_point: Point = Point { x: 10.3, y: 0.2 };\n\n    // Access the fields of the point\n    println!(\"point coordinates: ({}, {})\", point.x, point.y);\n\n    // Make a new point by using struct update syntax to use the fields of our\n    // other one\n    let bottom_right = Point { x: 10.3, ..another_point };\n\n    // `bottom_right.y` will be the same as `another_point.y` because we used that field\n    // from `another_point`\n    println!(\"second point: ({}, {})\", bottom_right.x, bottom_right.y);\n\n    // Destructure the point using a `let` binding\n    let Point { x: left_edge, y: top_edge } = point;\n\n    let _rectangle = Rectangle {\n        // struct instantiation is an expression too\n        top_left: Point { x: left_edge, y: top_edge },\n        bottom_right: bottom_right,\n    };\n\n    // Instantiate a unit struct\n    let _unit = Unit;\n\n    // Instantiate a tuple struct\n    let pair = Pair(1, 0.1);\n\n    // Access the fields of a tuple struct\n    println!(\"pair contains {:?} and {:?}\", pair.0, pair.1);\n\n    // Destructure a tuple struct\n    let Pair(integer, decimal) = pair;\n\n    println!(\"pair contains {:?} and {:?}\", integer, decimal);\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Optional Values in Rust with Option<T> and unwrap\nDESCRIPTION: This code demonstrates two approaches to handle optional values in Rust: explicit handling with match patterns and implicit handling with unwrap. It illustrates how match provides more controlled error handling while unwrap causes a panic when a None value is encountered.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/error/option_unwrap.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// The adult has seen it all, and can handle any drink well.\n// All drinks are handled explicitly using `match`.\nfn give_adult(drink: Option<&str>) {\n    // Specify a course of action for each case.\n    match drink {\n        Some(\"lemonade\") => println!(\"Yuck! Too sugary.\"),\n        Some(inner)   => println!(\"{inner}? How nice.\"),\n        None          => println!(\"No drink? Oh well.\"),\n    }\n}\n\n// Others will `panic` before drinking sugary drinks.\n// All drinks are handled implicitly using `unwrap`.\nfn drink(drink: Option<&str>) {\n    // `unwrap` returns a `panic` when it receives a `None`.\n    let inside = drink.unwrap();\n    if inside == \"lemonade\" { panic!(\"AAAaaaaa!!!!\"); }\n\n    println!(\"I love {}s!!!!!\", inside);\n}\n\nfn main() {\n    let water  = Some(\"water\");\n    let lemonade = Some(\"lemonade\");\n    let void  = None;\n\n    give_adult(water);\n    give_adult(lemonade);\n    give_adult(void);\n\n    let coffee = Some(\"coffee\");\n    let nothing = None;\n\n    drink(coffee);\n    drink(nothing);\n}\n```\n\n----------------------------------------\n\nTITLE: Chained Option Unpacking with Nested Structs in Rust\nDESCRIPTION: Shows how to use chained ? operators to access deeply nested Option values within structs. Includes struct definitions for Person, Job, and PhoneNumber, with a method to retrieve an area code through multiple layers of Options.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/error/option_unwrap/question_mark.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct Person {\n    job: Option<Job>,\n}\n\n#[derive(Clone, Copy)]\nstruct Job {\n    phone_number: Option<PhoneNumber>,\n}\n\n#[derive(Clone, Copy)]\nstruct PhoneNumber {\n    area_code: Option<u8>,\n    number: u32,\n}\n\nimpl Person {\n    // Gets the area code of the phone number of the person's job, if it exists.\n    fn work_phone_area_code(&self) -> Option<u8> {\n        // This would need many nested `match` statements without the `?` operator.\n        // It would take a lot more code - try writing it yourself and see which\n        // is easier.\n        self.job?.phone_number?.area_code\n    }\n}\n\nfn main() {\n    let p = Person {\n        job: Some(Job {\n            phone_number: Some(PhoneNumber {\n                area_code: Some(61),\n                number: 439222222,\n            }),\n        }),\n    };\n\n    assert_eq!(p.work_phone_area_code(), Some(61));\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Linked List in Rust with Enums and Box Pointers\nDESCRIPTION: This code demonstrates how to implement a singly linked list in Rust using enums, Box pointers, and methods. It defines a List enum with Cons and Nil variants, and implements methods for creating, prepending to, measuring, and displaying the list. The example shows Rust's pattern matching, ownership system, and recursive operations.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/custom_types/enum/testcase_linked_list.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse crate::List::*;\n\nenum List {\n    // Cons: Tuple struct that wraps an element and a pointer to the next node\n    Cons(u32, Box<List>),\n    // Nil: A node that signifies the end of the linked list\n    Nil,\n}\n\n// Methods can be attached to an enum\nimpl List {\n    // Create an empty list\n    fn new() -> List {\n        // `Nil` has type `List`\n        Nil\n    }\n\n    // Consume a list, and return the same list with a new element at its front\n    fn prepend(self, elem: u32) -> List {\n        // `Cons` also has type List\n        Cons(elem, Box::new(self))\n    }\n\n    // Return the length of the list\n    fn len(&self) -> u32 {\n        // `self` has to be matched, because the behavior of this method\n        // depends on the variant of `self`\n        // `self` has type `&List`, and `*self` has type `List`, matching on a\n        // concrete type `T` is preferred over a match on a reference `&T`\n        // after Rust 2018 you can use self here and tail (with no ref) below as well,\n        // rust will infer &s and ref tail. \n        // See https://doc.rust-lang.org/edition-guide/rust-2018/ownership-and-lifetimes/default-match-bindings.html\n        match *self {\n            // Can't take ownership of the tail, because `self` is borrowed;\n            // instead take a reference to the tail\n            Cons(_, ref tail) => 1 + tail.len(),\n            // Base Case: An empty list has zero length\n            Nil => 0\n        }\n    }\n\n    // Return representation of the list as a (heap allocated) string\n    fn stringify(&self) -> String {\n        match *self {\n            Cons(head, ref tail) => {\n                // `format!` is similar to `print!`, but returns a heap\n                // allocated string instead of printing to the console\n                format!(\"{}, {}\", head, tail.stringify())\n            },\n            Nil => {\n                format!(\"Nil\")\n            },\n        }\n    }\n}\n\nfn main() {\n    // Create an empty linked list\n    let mut list = List::new();\n\n    // Prepend some elements\n    list = list.prepend(1);\n    list = list.prepend(2);\n    list = list.prepend(3);\n\n    // Show the final state of the list\n    println!(\"linked list has length: {}\", list.len());\n    println!(\"{}\", list.stringify());\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Rust's Formatted Print Capabilities\nDESCRIPTION: This example showcases Rust's formatted print functionality using println! macro with various formatting options including positional arguments, named arguments, number base conversion, text alignment, and padding. It also demonstrates compile-time format checking and struct display limitations.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/hello/print.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    // In general, the `{}` will be automatically replaced with any\n    // arguments. These will be stringified.\n    println!(\"{} days\", 31);\n\n    // Positional arguments can be used. Specifying an integer inside `{}`\n    // determines which additional argument will be replaced. Arguments start\n    // at 0 immediately after the format string.\n    println!(\"{0}, this is {1}. {1}, this is {0}\", \"Alice\", \"Bob\");\n\n    // As can named arguments.\n    println!(\"{subject} {verb} {object}\",\n             object=\"the lazy dog\",\n             subject=\"the quick brown fox\",\n             verb=\"jumps over\");\n\n    // Different formatting can be invoked by specifying the format character\n    // after a `:`.\n    println!(\"Base 10:               {}\",   69420); // 69420\n    println!(\"Base 2 (binary):       {:b}\", 69420); // 10000111100101100\n    println!(\"Base 8 (octal):        {:o}\", 69420); // 207454\n    println!(\"Base 16 (hexadecimal): {:x}\", 69420); // 10f2c\n\n    // You can right-justify text with a specified width. This will\n    // output \"    1\". (Four white spaces and a \"1\", for a total width of 5.)\n    println!(\"{number:>5}\", number=1);\n\n    // You can pad numbers with extra zeroes,\n    println!(\"{number:0>5}\", number=1); // 00001\n    // and left-adjust by flipping the sign. This will output \"10000\".\n    println!(\"{number:0<5}\", number=1); // 10000\n\n    // You can use named arguments in the format specifier by appending a `$`.\n    println!(\"{number:0>width$}\", number=1, width=5);\n\n    // Rust even checks to make sure the correct number of arguments are used.\n    println!(\"My name is {0}, {1} {0}\", \"Bond\");\n    // FIXME ^ Add the missing argument: \"James\"\n\n    // Only types that implement fmt::Display can be formatted with `{}`. User-\n    // defined types do not implement fmt::Display by default.\n\n    #[allow(dead_code)] // disable `dead_code` which warn against unused module\n    struct Structure(i32);\n\n    // This will not compile because `Structure` does not implement\n    // fmt::Display.\n    // println!(\"This struct `{}` won't print...\", Structure(3));\n    // TODO ^ Try uncommenting this line\n\n    // For Rust 1.58 and above, you can directly capture the argument from a\n    // surrounding variable. Just like the above, this will output\n    // \"    1\", 4 white spaces and a \"1\".\n    let number: f64 = 1.0;\n    let width: usize = 5;\n    println!(\"{number:>width$}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Vector Operations in Rust\nDESCRIPTION: Demonstrates common vector operations including initialization using collect() and vec! macro, pushing elements, popping elements, accessing elements by index, and different iteration methods. Also shows error cases like pushing to immutable vectors and out-of-bounds access.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/std/vec.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    // Iterators can be collected into vectors\n    let collected_iterator: Vec<i32> = (0..10).collect();\n    println!(\"Collected (0..10) into: {:?}\", collected_iterator);\n\n    // The `vec!` macro can be used to initialize a vector\n    let mut xs = vec![1i32, 2, 3];\n    println!(\"Initial vector: {:?}\", xs);\n\n    // Insert new element at the end of the vector\n    println!(\"Push 4 into the vector\");\n    xs.push(4);\n    println!(\"Vector: {:?}\", xs);\n\n    // Error! Immutable vectors can't grow\n    collected_iterator.push(0);\n    // FIXME ^ Comment out this line\n\n    // The `len` method yields the number of elements currently stored in a vector\n    println!(\"Vector length: {}\", xs.len());\n\n    // Indexing is done using the square brackets (indexing starts at 0)\n    println!(\"Second element: {}\", xs[1]);\n\n    // `pop` removes the last element from the vector and returns it\n    println!(\"Pop last element: {:?}\", xs.pop());\n\n    // Out of bounds indexing yields a panic\n    println!(\"Fourth element: {}\", xs[3]);\n    // FIXME ^ Comment out this line\n\n    // `Vector`s can be easily iterated over\n    println!(\"Contents of xs:\");\n    for x in xs.iter() {\n        println!(\"> {}\", x);\n    }\n\n    // A `Vector` can also be iterated over while the iteration\n    // count is enumerated in a separate variable (`i`)\n    for (i, x) in xs.iter().enumerate() {\n        println!(\"In position {} we have value {}\", i, x);\n    }\n\n    // Thanks to `iter_mut`, mutable `Vector`s can also be iterated\n    // over in a way that allows modifying each value\n    for x in xs.iter_mut() {\n        *x *= 3;\n    }\n    println!(\"Updated vector: {:?}\", xs);\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Rust Standard Library Types in Markdown\nDESCRIPTION: This snippet showcases examples of custom types provided by Rust's standard library, including growable strings, vectors, optional types, error handling types, and heap-allocated pointers.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/std.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n* growable `String`s like: `\"hello world\"`\n* growable vectors: `[1, 2, 3]`\n* optional types: `Option<i32>`\n* error handling types: `Result<i32, i32>`\n* heap allocated pointers: `Box<i32>`\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Rust's Borrowing Rules with Point Structure\nDESCRIPTION: This code demonstrates Rust's borrowing rules using a Point struct. It shows how multiple immutable borrows can coexist, but mutable borrows have strict constraints - they cannot exist alongside immutable borrows, and only one mutable borrow can exist at a time. The example highlights compile-time enforcement of these rules.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/scope/borrow/alias.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Point { x: i32, y: i32, z: i32 }\n\nfn main() {\n    let mut point = Point { x: 0, y: 0, z: 0 };\n\n    let borrowed_point = &point;\n    let another_borrow = &point;\n\n    // Data can be accessed via the references and the original owner\n    println!(\"Point has coordinates: ({}, {}, {})\",\n                borrowed_point.x, another_borrow.y, point.z);\n\n    // Error! Can't borrow `point` as mutable because it's currently\n    // borrowed as immutable.\n    // let mutable_borrow = &mut point;\n    // TODO ^ Try uncommenting this line\n\n    // The borrowed values are used again here\n    println!(\"Point has coordinates: ({}, {}, {})\",\n                borrowed_point.x, another_borrow.y, point.z);\n\n    // The immutable references are no longer used for the rest of the code so\n    // it is possible to reborrow with a mutable reference.\n    let mutable_borrow = &mut point;\n\n    // Change data via mutable reference\n    mutable_borrow.x = 5;\n    mutable_borrow.y = 2;\n    mutable_borrow.z = 1;\n\n    // Error! Can't borrow `point` as immutable because it's currently\n    // borrowed as mutable.\n    // let y = &point.y;\n    // TODO ^ Try uncommenting this line\n\n    // Error! Can't print because `println!` takes an immutable reference.\n    // println!(\"Point Z coordinate is {}\", point.z);\n    // TODO ^ Try uncommenting this line\n\n    // Ok! Mutable references can be passed as immutable to `println!`\n    println!(\"Point has coordinates: ({}, {}, {})\",\n                mutable_borrow.x, mutable_borrow.y, mutable_borrow.z);\n\n    // The mutable reference is no longer used for the rest of the code so it\n    // is possible to reborrow\n    let new_borrowed_point = &point;\n    println!(\"Point now has coordinates: ({}, {}, {})\",\n             new_borrowed_point.x, new_borrowed_point.y, new_borrowed_point.z);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Array and Slice Operations in Rust\nDESCRIPTION: Comprehensive example showing array initialization, slice manipulation, memory allocation, and safe indexing patterns in Rust. Demonstrates fixed-size arrays, slice borrowing, array-to-slice conversion, and safe access using .get() method with Option handling.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/primitives/array.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::mem;\n\n// This function borrows a slice.\nfn analyze_slice(slice: &[i32]) {\n    println!(\"First element of the slice: {}\", slice[0]);\n    println!(\"The slice has {} elements\", slice.len());\n}\n\nfn main() {\n    // Fixed-size array (type signature is superfluous).\n    let xs: [i32; 5] = [1, 2, 3, 4, 5];\n\n    // All elements can be initialized to the same value.\n    let ys: [i32; 500] = [0; 500];\n\n    // Indexing starts at 0.\n    println!(\"First element of the array: {}\", xs[0]);\n    println!(\"Second element of the array: {}\", xs[1]);\n\n    // `len` returns the count of elements in the array.\n    println!(\"Number of elements in array: {}\", xs.len());\n\n    // Arrays are stack allocated.\n    println!(\"Array occupies {} bytes\", mem::size_of_val(&xs));\n\n    // Arrays can be automatically borrowed as slices.\n    println!(\"Borrow the whole array as a slice.\");\n    analyze_slice(&xs);\n\n    // Slices can point to a section of an array.\n    // They are of the form [starting_index..ending_index].\n    // `starting_index` is the first position in the slice.\n    // `ending_index` is one more than the last position in the slice.\n    println!(\"Borrow a section of the array as a slice.\");\n    analyze_slice(&ys[1 .. 4]);\n\n    // Example of empty slice `&[]`:\n    let empty_array: [u32; 0] = [];\n    assert_eq!(&empty_array, &[]);\n    assert_eq!(&empty_array, &[][..]); // Same but more verbose\n\n    // Arrays can be safely accessed using `.get`, which returns an\n    // `Option`. This can be matched as shown below, or used with\n    // `.expect()` if you would like the program to exit with a nice\n    // message instead of happily continue.\n    for i in 0..xs.len() + 1 { // Oops, one element too far!\n        match xs.get(i) {\n            Some(xval) => println!(\"{}: {}\", i, xval),\n            None => println!(\"Slow down! {} is too far!\", i),\n        }\n    }\n\n    // Out of bound indexing on array with constant value causes compile time error.\n    //println!(\"{}\", xs[5]);\n    // Out of bound indexing on slice causes runtime error.\n    //println!(\"{}\", xs[..][5]);\n}\n```\n\n----------------------------------------\n\nTITLE: Simplifying Error Handling with Result Combinators in Rust\nDESCRIPTION: This snippet uses Result combinators (and_then() and map()) to simplify error handling for string parsing. It achieves the same functionality as the previous example but with more concise code and better readability.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/error/result/result_map.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::num::ParseIntError;\n\n// As with `Option`, we can use combinators such as `map()`.\n// This function is otherwise identical to the one above and reads:\n// Multiply if both values can be parsed from str, otherwise pass on the error.\nfn multiply(first_number_str: &str, second_number_str: &str) -> Result<i32, ParseIntError> {\n    first_number_str.parse::<i32>().and_then(|first_number| {\n        second_number_str.parse::<i32>().map(|second_number| first_number * second_number)\n    })\n}\n\nfn print(result: Result<i32, ParseIntError>) {\n    match result {\n        Ok(n)  => println!(\"n is {}\", n),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n\nfn main() {\n    // This still presents a reasonable answer.\n    let twenty = multiply(\"10\", \"2\");\n    print(twenty);\n\n    // The following now provides a much more helpful error message.\n    let tt = multiply(\"t\", \"2\");\n    print(tt);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Error Type and Error Handling in Rust\nDESCRIPTION: This code snippet defines a custom error type 'DoubleError', implements the Display trait for it, and uses it in a function 'double_first' that attempts to double the first item of a vector. It demonstrates error propagation, conversion, and handling in Rust.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/error/multiple_error_types/define_error_type.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::fmt;\n\ntype Result<T> = std::result::Result<T, DoubleError>;\n\n// Define our error types. These may be customized for our error handling cases.\n// Now we will be able to write our own errors, defer to an underlying error\n// implementation, or do something in between.\n#[derive(Debug, Clone)]\nstruct DoubleError;\n\n// Generation of an error is completely separate from how it is displayed.\n// There's no need to be concerned about cluttering complex logic with the display style.\n//\n// Note that we don't store any extra info about the errors. This means we can't state\n// which string failed to parse without modifying our types to carry that information.\nimpl fmt::Display for DoubleError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"invalid first item to double\")\n    }\n}\n\nfn double_first(vec: Vec<&str>) -> Result<i32> {\n    vec.first()\n        // Change the error to our new type.\n        .ok_or(DoubleError)\n        .and_then(|s| {\n            s.parse::<i32>()\n                // Update to the new error type here also.\n                .map_err(|_| DoubleError)\n                .map(|i| 2 * i)\n        })\n}\n\nfn print(result: Result<i32>) {\n    match result {\n        Ok(n) => println!(\"The first doubled is {}\", n),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n\nfn main() {\n    let numbers = vec![\"42\", \"93\", \"18\"];\n    let empty = vec![];\n    let strings = vec![\"tofu\", \"93\", \"18\"];\n\n    print(double_first(numbers));\n    print(double_first(empty));\n    print(double_first(strings));\n}\n```\n\n----------------------------------------\n\nTITLE: Iterating and modifying a vector using iter_mut() in Rust\nDESCRIPTION: This snippet demonstrates how to use iter_mut() to iterate over and modify a vector in Rust. It mutably borrows each element, allowing in-place modification of the collection. The example shows how to change vector elements based on a match condition.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/flow_control/for.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let mut names = vec![\"Bob\", \"Frank\", \"Ferris\"];\n\n    for name in names.iter_mut() {\n        *name = match name {\n            &mut \"Ferris\" => \"There is a rustacean among us!\",\n            _ => \"Hello\",\n        }\n    }\n\n    println!(\"names: {:?}\", names);\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Multiple Error Types in Rust\nDESCRIPTION: This code snippet shows a function 'double_first' that can generate two different types of errors. It uses Vec::first which returns an Option, and parse::<i32> which returns a Result<i32, ParseIntError>. The main function demonstrates three scenarios: successful execution, an empty vector error, and a parsing error.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/error/multiple_error_types.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn double_first(vec: Vec<&str>) -> i32 {\n    let first = vec.first().unwrap(); // Generate error 1\n    2 * first.parse::<i32>().unwrap() // Generate error 2\n}\n\nfn main() {\n    let numbers = vec![\"42\", \"93\", \"18\"];\n    let empty = vec![];\n    let strings = vec![\"tofu\", \"93\", \"18\"];\n\n    println!(\"The first doubled is {}\", double_first(numbers));\n\n    println!(\"The first doubled is {}\", double_first(empty));\n    // Error 1: the input vector is empty\n\n    println!(\"The first doubled is {}\", double_first(strings));\n    // Error 2: the element doesn't parse to a number\n}\n```\n\n----------------------------------------\n\nTITLE: Error Handling with the ? Operator in Rust\nDESCRIPTION: This example demonstrates using the ? operator to handle potential errors when parsing strings to integers. The ? operator automatically returns errors to the caller, simplifying error propagation compared to manual unwrap() or match approaches.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/error/result/enter_question_mark.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::num::ParseIntError;\n\nfn multiply(first_number_str: &str, second_number_str: &str) -> Result<i32, ParseIntError> {\n    let first_number = first_number_str.parse::<i32>()?;\n    let second_number = second_number_str.parse::<i32>()?;\n\n    Ok(first_number * second_number)\n}\n\nfn print(result: Result<i32, ParseIntError>) {\n    match result {\n        Ok(n)  => println!(\"n is {}\", n),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n\nfn main() {\n    print(multiply(\"10\", \"2\"));\n    print(multiply(\"t\", \"2\"));\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Constants Usage in Rust\nDESCRIPTION: This code snippet shows how to declare and use both 'const' and 'static' constants in Rust. It demonstrates global declaration, access within functions, and the immutability of 'const' values. The example also includes an intentional error to highlight that 'const' values cannot be modified.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/custom_types/constants.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// Globals are declared outside all other scopes.\nstatic LANGUAGE: &str = \"Rust\";\nconst THRESHOLD: i32 = 10;\n\nfn is_big(n: i32) -> bool {\n    // Access constant in some function\n    n > THRESHOLD\n}\n\nfn main() {\n    let n = 16;\n\n    // Access constant in the main thread\n    println!(\"This is {}\", LANGUAGE);\n    println!(\"The threshold is {}\", THRESHOLD);\n    println!(\"{} is {}\", n, if is_big(n) { \"big\" } else { \"small\" });\n\n    // Error! Cannot modify a `const`.\n    THRESHOLD = 5;\n    // FIXME ^ Comment out this line\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing FizzBuzz with Rust Functions\nDESCRIPTION: A complete example showing different aspects of Rust functions, including function declaration, return values, early returns, and the unit type. The implementation demonstrates function order independence, boolean return values, and handling the unit type in function signatures.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/fn.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// Unlike C/C++, there's no restriction on the order of function definitions\nfn main() {\n    // We can use this function here, and define it somewhere later\n    fizzbuzz_to(100);\n}\n\n// Function that returns a boolean value\nfn is_divisible_by(lhs: u32, rhs: u32) -> bool {\n    // Corner case, early return\n    if rhs == 0 {\n        return false;\n    }\n\n    // This is an expression, the `return` keyword is not necessary here\n    lhs % rhs == 0\n}\n\n// Functions that \"don't\" return a value, actually return the unit type `()`\nfn fizzbuzz(n: u32) -> () {\n    if is_divisible_by(n, 15) {\n        println!(\"fizzbuzz\");\n    } else if is_divisible_by(n, 3) {\n        println!(\"fizz\");\n    } else if is_divisible_by(n, 5) {\n        println!(\"buzz\");\n    } else {\n        println!(\"{}\", n);\n    }\n}\n\n// When a function returns `()`, the return type can be omitted from the\n// signature\nfn fizzbuzz_to(n: u32) {\n    for n in 1..=n {\n        fizzbuzz(n);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Handling with Rust Option Enum\nDESCRIPTION: Shows how to implement safe integer division using Option<T> enum to handle division by zero cases. Demonstrates pattern matching on Option values, unwrapping Some variants, and handling None cases. Includes examples of type annotation for None values and unwrap operations that may panic.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/std/option.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// An integer division that doesn't `panic!`\nfn checked_division(dividend: i32, divisor: i32) -> Option<i32> {\n    if divisor == 0 {\n        // Failure is represented as the `None` variant\n        None\n    } else {\n        // Result is wrapped in a `Some` variant\n        Some(dividend / divisor)\n    }\n}\n\n// This function handles a division that may not succeed\nfn try_division(dividend: i32, divisor: i32) {\n    // `Option` values can be pattern matched, just like other enums\n    match checked_division(dividend, divisor) {\n        None => println!(\"{} / {} failed!\", dividend, divisor),\n        Some(quotient) => {\n            println!(\"{} / {} = {}\", dividend, divisor, quotient)\n        },\n    }\n}\n\nfn main() {\n    try_division(4, 2);\n    try_division(1, 0);\n\n    // Binding `None` to a variable needs to be type annotated\n    let none: Option<i32> = None;\n    let _equivalent_none = None::<i32>;\n\n    let optional_float = Some(0f32);\n\n    // Unwrapping a `Some` variant will extract the value wrapped.\n    println!(\"{:?} unwraps to {:?}\", optional_float, optional_float.unwrap());\n\n    // Unwrapping a `None` variant will `panic!`\n    println!(\"{:?} unwraps to {:?}\", none, none.unwrap());\n}\n```\n\n----------------------------------------\n\nTITLE: Using File struct for I/O operations in Rust\nDESCRIPTION: The File struct in Rust represents an opened file, providing read and/or write access. All File methods return io::Result<T>, an alias for Result<T, io::Error>, making I/O operation failures explicit and encouraging proper error handling.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/std_misc/file.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nFile struct\n```\n\nLANGUAGE: Rust\nCODE:\n```\nio::Result<T>\n```\n\nLANGUAGE: Rust\nCODE:\n```\nResult<T, io::Error>\n```\n\n----------------------------------------\n\nTITLE: Implementing Reference Patterns in Rust\nDESCRIPTION: Demonstrates various uses of the ref keyword in Rust including struct destructuring, mutable references, and tuple manipulation. Shows how ref on the left side of an assignment is equivalent to & on the right side, and how ref can be combined with mut for mutable references.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/scope/borrow/ref.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Clone, Copy)]\nstruct Point { x: i32, y: i32 }\n\nfn main() {\n    let c = 'Q';\n\n    // A `ref` borrow on the left side of an assignment is equivalent to\n    // an `&` borrow on the right side.\n    let ref ref_c1 = c;\n    let ref_c2 = &c;\n\n    println!(\"ref_c1 equals ref_c2: {}\", *ref_c1 == *ref_c2);\n\n    let point = Point { x: 0, y: 0 };\n\n    // `ref` is also valid when destructuring a struct.\n    let _copy_of_x = {\n        // `ref_to_x` is a reference to the `x` field of `point`.\n        let Point { x: ref ref_to_x, y: _ } = point;\n\n        // Return a copy of the `x` field of `point`.\n        *ref_to_x\n    };\n\n    // A mutable copy of `point`\n    let mut mutable_point = point;\n\n    {\n        // `ref` can be paired with `mut` to take mutable references.\n        let Point { x: _, y: ref mut mut_ref_to_y } = mutable_point;\n\n        // Mutate the `y` field of `mutable_point` via a mutable reference.\n        *mut_ref_to_y = 1;\n    }\n\n    println!(\"point is ({}, {})\", point.x, point.y);\n    println!(\"mutable_point is ({}, {})\", mutable_point.x, mutable_point.y);\n\n    // A mutable tuple that includes a pointer\n    let mut mutable_tuple = (Box::new(5u32), 3u32);\n    \n    {\n        // Destructure `mutable_tuple` to change the value of `last`.\n        let (_, ref mut last) = mutable_tuple;\n        *last = 2u32;\n    }\n    \n    println!(\"tuple is {:?}\", mutable_tuple);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Functions with Lifetime Annotations in Rust\nDESCRIPTION: This code demonstrates various ways to use lifetime annotations in Rust functions, including single reference parameters, mutable references, multiple lifetime parameters, and return values. It shows proper lifetime management and includes examples of both valid and invalid lifetime usage patterns.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/scope/lifetime/fn.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// One input reference with lifetime `'a` which must live\n// at least as long as the function.\nfn print_one<'a>(x: &'a i32) {\n    println!(\"`print_one`: x is {}\", x);\n}\n\n// Mutable references are possible with lifetimes as well.\nfn add_one<'a>(x: &'a mut i32) {\n    *x += 1;\n}\n\n// Multiple elements with different lifetimes. In this case, it\n// would be fine for both to have the same lifetime `'a`, but\n// in more complex cases, different lifetimes may be required.\nfn print_multi<'a, 'b>(x: &'a i32, y: &'b i32) {\n    println!(\"`print_multi`: x is {}, y is {}\", x, y);\n}\n\n// Returning references that have been passed in is acceptable.\n// However, the correct lifetime must be returned.\nfn pass_x<'a, 'b>(x: &'a i32, _: &'b i32) -> &'a i32 { x }\n\n//fn invalid_output<'a>() -> &'a String { &String::from(\"foo\") }\n// The above is invalid: `'a` must live longer than the function.\n// Here, `&String::from(\"foo\")` would create a `String`, followed by a\n// reference. Then the data is dropped upon exiting the scope, leaving\n// a reference to invalid data to be returned.\n\nfn main() {\n    let x = 7;\n    let y = 9;\n    \n    print_one(&x);\n    print_multi(&x, &y);\n    \n    let z = pass_x(&x, &y);\n    print_one(z);\n\n    let mut t = 3;\n    add_one(&mut t);\n    print_one(&t);\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating String and &str Operations in Rust\nDESCRIPTION: This example shows various operations on strings in Rust, including string slicing, iteration, character manipulation, and string transformations. It demonstrates the differences between stack-allocated string slices and heap-allocated String objects.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/std/str.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    // (all the type annotations are superfluous)\n    // A reference to a string allocated in read only memory\n    let pangram: &'static str = \"the quick brown fox jumps over the lazy dog\";\n    println!(\"Pangram: {}\", pangram);\n\n    // Iterate over words in reverse, no new string is allocated\n    println!(\"Words in reverse\");\n    for word in pangram.split_whitespace().rev() {\n        println!(\"> {}\", word);\n    }\n\n    // Copy chars into a vector, sort and remove duplicates\n    let mut chars: Vec<char> = pangram.chars().collect();\n    chars.sort();\n    chars.dedup();\n\n    // Create an empty and growable `String`\n    let mut string = String::new();\n    for c in chars {\n        // Insert a char at the end of string\n        string.push(c);\n        // Insert a string at the end of string\n        string.push_str(\", \");\n    }\n\n    // The trimmed string is a slice to the original string, hence no new\n    // allocation is performed\n    let chars_to_trim: &[char] = &[' ', ','];\n    let trimmed_str: &str = string.trim_matches(chars_to_trim);\n    println!(\"Used characters: {}\", trimmed_str);\n\n    // Heap allocate a string\n    let alice = String::from(\"I like dogs\");\n    // Allocate new memory and store the modified string there\n    let bob: String = alice.replace(\"dog\", \"cat\");\n\n    println!(\"Alice says: {}\", alice);\n    println!(\"Bob says: {}\", bob);\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Lifetimes and Scopes in Rust\nDESCRIPTION: This example illustrates how variable lifetimes and reference borrowing work in Rust. It shows a variable 'i' being created in the main function with two separate borrows in distinct scopes, with comments indicating the start and end points of each lifetime. The example demonstrates how the lifetime of 'i' encompasses both borrows.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/scope/lifetime.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// Lifetimes are annotated below with lines denoting the creation\n// and destruction of each variable.\n// `i` has the longest lifetime because its scope entirely encloses \n// both `borrow1` and `borrow2`. The duration of `borrow1` compared \n// to `borrow2` is irrelevant since they are disjoint.\nfn main() {\n    let i = 3; // Lifetime for `i` starts. ────────────────┐\n    //                                                     │\n    { //                                                   │\n        let borrow1 = &i; // `borrow1` lifetime starts. ──┐│\n        //                                                ││\n        println!(\"borrow1: {}\", borrow1); //              ││\n    } // `borrow1` ends. ─────────────────────────────────┘│\n    //                                                     │\n    //                                                     │\n    { //                                                   │\n        let borrow2 = &i; // `borrow2` lifetime starts. ──┐│\n        //                                                ││\n        println!(\"borrow2: {}\", borrow2); //              ││\n    } // `borrow2` ends. ─────────────────────────────────┘│\n    //                                                     │\n}   // Lifetime ends. ─────────────────────────────────────┘\n```\n\n----------------------------------------\n\nTITLE: Implementing Addition Operator Overloading Using Add Trait in Rust\nDESCRIPTION: Demonstrates how to implement the Add trait to overload the + operator for custom struct types Foo and Bar. Shows implementation of non-commutative addition where Foo + Bar produces FooBar and Bar + Foo produces BarFoo. Uses the std::ops::Add trait to define custom addition behavior.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/trait/ops.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::ops;\n\nstruct Foo;\nstruct Bar;\n\n#[derive(Debug)]\nstruct FooBar;\n\n#[derive(Debug)]\nstruct BarFoo;\n\n// The `std::ops::Add` trait is used to specify the functionality of `+`.\n// Here, we make `Add<Bar>` - the trait for addition with a RHS of type `Bar`.\n// The following block implements the operation: Foo + Bar = FooBar\nimpl ops::Add<Bar> for Foo {\n    type Output = FooBar;\n\n    fn add(self, _rhs: Bar) -> FooBar {\n        println!(\"> Foo.add(Bar) was called\");\n\n        FooBar\n    }\n}\n\n// By reversing the types, we end up implementing non-commutative addition.\n// Here, we make `Add<Foo>` - the trait for addition with a RHS of type `Foo`.\n// This block implements the operation: Bar + Foo = BarFoo\nimpl ops::Add<Foo> for Bar {\n    type Output = BarFoo;\n\n    fn add(self, _rhs: Foo) -> BarFoo {\n        println!(\"> Bar.add(Foo) was called\");\n\n        BarFoo\n    }\n}\n\nfn main() {\n    println!(\"Foo + Bar = {:?}\", Foo + Bar);\n    println!(\"Bar + Foo = {:?}\", Bar + Foo);\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Variable Declaration and Initialization in Rust\nDESCRIPTION: This code snippet illustrates the declaration of variables, their initialization, and the consequences of using uninitialized variables in Rust. It shows how to declare a variable first and initialize it later, as well as the error that occurs when attempting to use an uninitialized variable.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/variable_bindings/declare.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    // Declare a variable binding\n    let a_binding;\n\n    {\n        let x = 2;\n\n        // Initialize the binding\n        a_binding = x * x;\n    }\n\n    println!(\"a binding: {}\", a_binding);\n\n    let another_binding;\n\n    // Error! Use of uninitialized binding\n    println!(\"another binding: {}\", another_binding);\n    // FIXME ^ Comment out this line\n\n    another_binding = 1;\n\n    println!(\"another binding: {}\", another_binding);\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Destructuring and Dereferencing in Rust\nDESCRIPTION: This code snippet illustrates various ways of working with references in Rust, including destructuring, dereferencing, and creating references using `ref` and `ref mut`. It shows pattern matching with references and how to modify values through mutable references.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/flow_control/match/destructuring/destructure_pointers.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    // Assign a reference of type `i32`. The `&` signifies there\n    // is a reference being assigned.\n    let reference = &4;\n\n    match reference {\n        // If `reference` is pattern matched against `&val`, it results\n        // in a comparison like:\n        // `&i32`\n        // `&val`\n        // ^ We see that if the matching `&`s are dropped, then the `i32`\n        // should be assigned to `val`.\n        &val => println!(\"Got a value via destructuring: {:?}\", val),\n    }\n\n    // To avoid the `&`, you dereference before matching.\n    match *reference {\n        val => println!(\"Got a value via dereferencing: {:?}\", val),\n    }\n\n    // What if you don't start with a reference? `reference` was a `&`\n    // because the right side was already a reference. This is not\n    // a reference because the right side is not one.\n    let _not_a_reference = 3;\n\n    // Rust provides `ref` for exactly this purpose. It modifies the\n    // assignment so that a reference is created for the element; this\n    // reference is assigned.\n    let ref _is_a_reference = 3;\n\n    // Accordingly, by defining 2 values without references, references\n    // can be retrieved via `ref` and `ref mut`.\n    let value = 5;\n    let mut mut_value = 6;\n\n    // Use `ref` keyword to create a reference.\n    match value {\n        ref r => println!(\"Got a reference to a value: {:?}\", r),\n    }\n\n    // Use `ref mut` similarly.\n    match mut_value {\n        ref mut m => {\n            // Got a reference. Gotta dereference it before we can\n            // add anything to it.\n            *m += 10;\n            println!(\"We added 10. `mut_value`: {:?}\", m);\n        },\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Contact List with HashMap in Rust\nDESCRIPTION: This example demonstrates the basics of using a HashMap in Rust by implementing a simple contact list. It shows how to create a HashMap, insert key-value pairs, retrieve values, update entries, remove items, and iterate through all entries. It also includes a function that simulates calling phone numbers.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/std/hash.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::collections::HashMap;\n\nfn call(number: &str) -> &str {\n    match number {\n        \"798-1364\" => \"We're sorry, the call cannot be completed as dialed. \n            Please hang up and try again.\",\n        \"645-7689\" => \"Hello, this is Mr. Awesome's Pizza. My name is Fred.\n            What can I get for you today?\",\n        _ => \"Hi! Who is this again?\"\n    }\n}\n\nfn main() { \n    let mut contacts = HashMap::new();\n\n    contacts.insert(\"Daniel\", \"798-1364\");\n    contacts.insert(\"Ashley\", \"645-7689\");\n    contacts.insert(\"Katie\", \"435-8291\");\n    contacts.insert(\"Robert\", \"956-1745\");\n\n    // Takes a reference and returns Option<&V>\n    match contacts.get(&\"Daniel\") {\n        Some(&number) => println!(\"Calling Daniel: {}\", call(number)),\n        _ => println!(\"Don't have Daniel's number.\"),\n    }\n\n    // `HashMap::insert()` returns `None`\n    // if the inserted value is new, `Some(value)` otherwise\n    contacts.insert(\"Daniel\", \"164-6743\");\n\n    match contacts.get(&\"Ashley\") {\n        Some(&number) => println!(\"Calling Ashley: {}\", call(number)),\n        _ => println!(\"Don't have Ashley's number.\"),\n    }\n\n    contacts.remove(&\"Ashley\"); \n\n    // `HashMap::iter()` returns an iterator that yields \n    // (&'a key, &'a value) pairs in arbitrary order.\n    for (contact, &number) in contacts.iter() {\n        println!(\"Calling {}: {}\", contact, call(number)); \n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Module Visibility Controls in Rust\nDESCRIPTION: Comprehensive example showing different visibility modifiers in Rust modules. Demonstrates public and private functions, nested modules, and restricted visibility using pub(crate), pub(in path), pub(self), and pub(super). Includes examples of visibility inheritance and access attempts from different scope levels.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/mod/visibility.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// A module named `my_mod`\nmod my_mod {\n    // Items in modules default to private visibility.\n    fn private_function() {\n        println!(\"called `my_mod::private_function()`\");\n    }\n\n    // Use the `pub` modifier to override default visibility.\n    pub fn function() {\n        println!(\"called `my_mod::function()`\");\n    }\n\n    // Items can access other items in the same module,\n    // even when private.\n    pub fn indirect_access() {\n        print!(\"called `my_mod::indirect_access()`, that\\n> \");\n        private_function();\n    }\n\n    // Modules can also be nested\n    pub mod nested {\n        pub fn function() {\n            println!(\"called `my_mod::nested::function()`\");\n        }\n\n        #[allow(dead_code)]\n        fn private_function() {\n            println!(\"called `my_mod::nested::private_function()`\");\n        }\n\n        // Functions declared using `pub(in path)` syntax are only visible\n        // within the given path. `path` must be a parent or ancestor module\n        pub(in crate::my_mod) fn public_function_in_my_mod() {\n            print!(\"called `my_mod::nested::public_function_in_my_mod()`, that\\n> \");\n            public_function_in_nested();\n        }\n\n        // Functions declared using `pub(self)` syntax are only visible within\n        // the current module, which is the same as leaving them private\n        pub(self) fn public_function_in_nested() {\n            println!(\"called `my_mod::nested::public_function_in_nested()`\");\n        }\n\n        // Functions declared using `pub(super)` syntax are only visible within\n        // the parent module\n        pub(super) fn public_function_in_super_mod() {\n            println!(\"called `my_mod::nested::public_function_in_super_mod()`\");\n        }\n    }\n\n    pub fn call_public_function_in_my_mod() {\n        print!(\"called `my_mod::call_public_function_in_my_mod()`, that\\n> \");\n        nested::public_function_in_my_mod();\n        print!(\"> \");\n        nested::public_function_in_super_mod();\n    }\n\n    // pub(crate) makes functions visible only within the current crate\n    pub(crate) fn public_function_in_crate() {\n        println!(\"called `my_mod::public_function_in_crate()`\");\n    }\n\n    // Nested modules follow the same rules for visibility\n    mod private_nested {\n        #[allow(dead_code)]\n        pub fn function() {\n            println!(\"called `my_mod::private_nested::function()`\");\n        }\n\n        // Private parent items will still restrict the visibility of a child item,\n        // even if it is declared as visible within a bigger scope.\n        #[allow(dead_code)]\n        pub(crate) fn restricted_function() {\n            println!(\"called `my_mod::private_nested::restricted_function()`\");\n        }\n    }\n}\n\nfn function() {\n    println!(\"called `function()`\");\n}\n\nfn main() {\n    // Modules allow disambiguation between items that have the same name.\n    function();\n    my_mod::function();\n\n    // Public items, including those inside nested modules, can be\n    // accessed from outside the parent module.\n    my_mod::indirect_access();\n    my_mod::nested::function();\n    my_mod::call_public_function_in_my_mod();\n\n    // pub(crate) items can be called from anywhere in the same crate\n    my_mod::public_function_in_crate();\n\n    // pub(in path) items can only be called from within the module specified\n    // Error! function `public_function_in_my_mod` is private\n    //my_mod::nested::public_function_in_my_mod();\n    // TODO ^ Try uncommenting this line\n\n    // Private items of a module cannot be directly accessed, even if\n    // nested in a public module:\n\n    // Error! `private_function` is private\n    //my_mod::private_function();\n    // TODO ^ Try uncommenting this line\n\n    // Error! `private_function` is private\n    //my_mod::nested::private_function();\n    // TODO ^ Try uncommenting this line\n\n    // Error! `private_nested` is a private module\n    //my_mod::private_nested::function();\n    // TODO ^ Try uncommenting this line\n\n    // Error! `private_nested` is a private module\n    //my_mod::private_nested::restricted_function();\n    // TODO ^ Try uncommenting this line\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing and Returning Trait Objects with Box<dyn Animal> in Rust\nDESCRIPTION: This code snippet defines an Animal trait, implements it for Sheep and Cow structs, and demonstrates how to return a Box<dyn Animal> from a function. It showcases the use of trait objects and dynamic dispatch in Rust.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/trait/dyn.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Sheep {}\nstruct Cow {}\n\ntrait Animal {\n    // Instance method signature\n    fn noise(&self) -> &'static str;\n}\n\n// Implement the `Animal` trait for `Sheep`.\nimpl Animal for Sheep {\n    fn noise(&self) -> &'static str {\n        \"baaaaah!\"\n    }\n}\n\n// Implement the `Animal` trait for `Cow`.\nimpl Animal for Cow {\n    fn noise(&self) -> &'static str {\n        \"moooooo!\"\n    }\n}\n\n// Returns some struct that implements Animal, but we don't know which one at compile time.\nfn random_animal(random_number: f64) -> Box<dyn Animal> {\n    if random_number < 0.5 {\n        Box::new(Sheep {})\n    } else {\n        Box::new(Cow {})\n    }\n}\n\nfn main() {\n    let random_number = 0.234;\n    let animal = random_animal(random_number);\n    println!(\"You've randomly chosen an animal, and it says {}\", animal.noise());\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing FizzBuzz using for loop with range in Rust\nDESCRIPTION: This snippet demonstrates how to use a for loop with a range (1..101) to implement the FizzBuzz problem in Rust. It iterates from 1 to 100, printing 'fizzbuzz', 'fizz', 'buzz', or the number based on divisibility rules.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/flow_control/for.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    // `n` will take the values: 1, 2, ..., 100 in each iteration\n    for n in 1..101 {\n        if n % 15 == 0 {\n            println!(\"fizzbuzz\");\n        } else if n % 3 == 0 {\n            println!(\"fizz\");\n        } else if n % 5 == 0 {\n            println!(\"buzz\");\n        } else {\n            println!(\"{}\", n);\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Tuple Usage in Rust\nDESCRIPTION: This code snippet demonstrates various operations with tuples in Rust, including creation, indexing, nesting, and destructuring. It also shows how tuples can be used as function parameters and return values.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/primitives/tuples.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// Tuples can be used as function arguments and as return values.\nfn reverse(pair: (i32, bool)) -> (bool, i32) {\n    // `let` can be used to bind the members of a tuple to variables.\n    let (int_param, bool_param) = pair;\n\n    (bool_param, int_param)\n}\n\n// The following struct is for the activity.\n#[derive(Debug)]\nstruct Matrix(f32, f32, f32, f32);\n\nfn main() {\n    // A tuple with a bunch of different types.\n    let long_tuple = (1u8, 2u16, 3u32, 4u64,\n                      -1i8, -2i16, -3i32, -4i64,\n                      0.1f32, 0.2f64,\n                      'a', true);\n\n    // Values can be extracted from the tuple using tuple indexing.\n    println!(\"Long tuple first value: {}\", long_tuple.0);\n    println!(\"Long tuple second value: {}\", long_tuple.1);\n\n    // Tuples can be tuple members.\n    let tuple_of_tuples = ((1u8, 2u16, 2u32), (4u64, -1i8), -2i16);\n\n    // Tuples are printable.\n    println!(\"tuple of tuples: {:?}\", tuple_of_tuples);\n\n    // But long Tuples (more than 12 elements) cannot be printed.\n    //let too_long_tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13);\n    //println!(\"Too long tuple: {:?}\", too_long_tuple);\n    // TODO ^ Uncomment the above 2 lines to see the compiler error\n\n    let pair = (1, true);\n    println!(\"Pair is {:?}\", pair);\n\n    println!(\"The reversed pair is {:?}\", reverse(pair));\n\n    // To create one element tuples, the comma is required to tell them apart\n    // from a literal surrounded by parentheses.\n    println!(\"One element tuple: {:?}\", (5u32,));\n    println!(\"Just an integer: {:?}\", (5u32));\n\n    // Tuples can be destructured to create bindings.\n    let tuple = (1, \"hello\", 4.5, true);\n\n    let (a, b, c, d) = tuple;\n    println!(\"{:?}, {:?}, {:?}, {:?}\", a, b, c, d);\n\n    let matrix = Matrix(1.1, 1.2, 2.1, 2.2);\n    println!(\"{:?}\", matrix);\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Struct Destructuring in Rust\nDESCRIPTION: This code snippet shows different methods of destructuring structs in Rust. It includes examples of pattern matching with various patterns, direct destructuring assignment, and handling nested structs. The code demonstrates how to access and rename struct fields during destructuring.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/flow_control/match/destructuring/destructure_structures.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    struct Foo {\n        x: (u32, u32),\n        y: u32,\n    }\n\n    // Try changing the values in the struct to see what happens\n    let foo = Foo { x: (1, 2), y: 3 };\n\n    match foo {\n        Foo { x: (1, b), y } => println!(\"First of x is 1, b = {},  y = {} \", b, y),\n\n        // you can destructure structs and rename the variables,\n        // the order is not important\n        Foo { y: 2, x: i } => println!(\"y is 2, i = {:?}\", i),\n\n        // and you can also ignore some variables:\n        Foo { y, .. } => println!(\"y = {}, we don't care about x\", y),\n        // this will give an error: pattern does not mention field `x`\n        //Foo { y } => println!(\"y = {}\", y),\n    }\n\n    let faa = Foo { x: (1, 2), y: 3 };\n\n    // You do not need a match block to destructure structs:\n    let Foo { x : x0, y: y0 } = faa;\n    println!(\"Outside: x0 = {x0:?}, y0 = {y0}\");\n\n    // Destructuring works with nested structs as well:\n    struct Bar {\n        foo: Foo,\n    }\n\n    let bar = Bar { foo: faa };\n    let Bar { foo: Foo { x: nested_x, y: nested_y } } = bar;\n    println!(\"Nested: nested_x = {nested_x:?}, nested_y = {nested_y:?}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Fibonacci Iterator and Iterator Usage Examples in Rust\nDESCRIPTION: Demonstrates implementing a custom Fibonacci sequence iterator and showcases various iterator operations including next(), take(), skip(), and iter(). The example includes a custom Fibonacci struct implementing the Iterator trait, along with examples of range-based iteration and array iteration.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/trait/iter.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Fibonacci {\n    curr: u32,\n    next: u32,\n}\n\n// Implement `Iterator` for `Fibonacci`.\n// The `Iterator` trait only requires a method to be defined for the `next` element,\n// and an `associated type` to declare the return type of the iterator.\nimpl Iterator for Fibonacci {\n    // We can refer to this type using Self::Item\n    type Item = u32;\n\n    // Here, we define the sequence using `.curr` and `.next`.\n    // The return type is `Option<T>`:\n    //     * When the `Iterator` is finished, `None` is returned.\n    //     * Otherwise, the next value is wrapped in `Some` and returned.\n    // We use Self::Item in the return type, so we can change\n    // the type without having to update the function signatures.\n    fn next(&mut self) -> Option<Self::Item> {\n        let current = self.curr;\n\n        self.curr = self.next;\n        self.next = current + self.next;\n\n        // Since there's no endpoint to a Fibonacci sequence, the `Iterator` \n        // will never return `None`, and `Some` is always returned.\n        Some(current)\n    }\n}\n\n// Returns a Fibonacci sequence generator\nfn fibonacci() -> Fibonacci {\n    Fibonacci { curr: 0, next: 1 }\n}\n\nfn main() {\n    // `0..3` is an `Iterator` that generates: 0, 1, and 2.\n    let mut sequence = 0..3;\n\n    println!(\"Four consecutive `next` calls on 0..3\");\n    println!(\"> {:?}\", sequence.next());\n    println!(\"> {:?}\", sequence.next());\n    println!(\"> {:?}\", sequence.next());\n    println!(\"> {:?}\", sequence.next());\n\n    // `for` works through an `Iterator` until it returns `None`.\n    // Each `Some` value is unwrapped and bound to a variable (here, `i`).\n    println!(\"Iterate through 0..3 using `for`\");\n    for i in 0..3 {\n        println!(\"> {}\", i);\n    }\n\n    // The `take(n)` method reduces an `Iterator` to its first `n` terms.\n    println!(\"The first four terms of the Fibonacci sequence are: \");\n    for i in fibonacci().take(4) {\n        println!(\"> {}\", i);\n    }\n\n    // The `skip(n)` method shortens an `Iterator` by dropping its first `n` terms.\n    println!(\"The next four terms of the Fibonacci sequence are: \");\n    for i in fibonacci().skip(4).take(4) {\n        println!(\"> {}\", i);\n    }\n\n    let array = [1u32, 3, 3, 7];\n\n    // The `iter` method produces an `Iterator` over an array/slice.\n    println!(\"Iterate the following array {:?}\", &array);\n    for i in array.iter() {\n        println!(\"> {}\", i);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Lifetimes in Rust Structs and Enums\nDESCRIPTION: This code demonstrates how to annotate lifetimes in Rust structs and enums. It shows examples of a tuple struct with a reference, a named struct with multiple references, and an enum that can contain either a value or a reference. The main function demonstrates creating and using instances of these types.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/scope/lifetime/struct.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// A type `Borrowed` which houses a reference to an\n// `i32`. The reference to `i32` must outlive `Borrowed`.\n#[derive(Debug)]\nstruct Borrowed<'a>(&'a i32);\n\n// Similarly, both references here must outlive this structure.\n#[derive(Debug)]\nstruct NamedBorrowed<'a> {\n    x: &'a i32,\n    y: &'a i32,\n}\n\n// An enum which is either an `i32` or a reference to one.\n#[derive(Debug)]\nenum Either<'a> {\n    Num(i32),\n    Ref(&'a i32),\n}\n\nfn main() {\n    let x = 18;\n    let y = 15;\n\n    let single = Borrowed(&x);\n    let double = NamedBorrowed { x: &x, y: &y };\n    let reference = Either::Ref(&x);\n    let number    = Either::Num(y);\n\n    println!(\"x is borrowed in {:?}\", single);\n    println!(\"x and y are borrowed in {:?}\", double);\n    println!(\"x is borrowed in {:?}\", reference);\n    println!(\"y is *not* borrowed in {:?}\", number);\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Stack and Heap Memory Allocation in Rust using Box<T>\nDESCRIPTION: This example demonstrates the difference between stack and heap allocation in Rust. It creates Point and Rectangle structs, shows how to allocate them on both stack and heap using Box<T>, compares their memory usage, and demonstrates dereferencing boxed values with the * operator.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/std/box.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::mem;\n\n#[allow(dead_code)]\n#[derive(Debug, Clone, Copy)]\nstruct Point {\n    x: f64,\n    y: f64,\n}\n\n// A Rectangle can be specified by where its top left and bottom right \n// corners are in space\n#[allow(dead_code)]\nstruct Rectangle {\n    top_left: Point,\n    bottom_right: Point,\n}\n\nfn origin() -> Point {\n    Point { x: 0.0, y: 0.0 }\n}\n\nfn boxed_origin() -> Box<Point> {\n    // Allocate this point on the heap, and return a pointer to it\n    Box::new(Point { x: 0.0, y: 0.0 })\n}\n\nfn main() {\n    // (all the type annotations are superfluous)\n    // Stack allocated variables\n    let point: Point = origin();\n    let rectangle: Rectangle = Rectangle {\n        top_left: origin(),\n        bottom_right: Point { x: 3.0, y: -4.0 }\n    };\n\n    // Heap allocated rectangle\n    let boxed_rectangle: Box<Rectangle> = Box::new(Rectangle {\n        top_left: origin(),\n        bottom_right: Point { x: 3.0, y: -4.0 },\n    });\n\n    // The output of functions can be boxed\n    let boxed_point: Box<Point> = Box::new(origin());\n\n    // Double indirection\n    let box_in_a_box: Box<Box<Point>> = Box::new(boxed_origin());\n\n    println!(\"Point occupies {} bytes on the stack\",\n             mem::size_of_val(&point));\n    println!(\"Rectangle occupies {} bytes on the stack\",\n             mem::size_of_val(&rectangle));\n\n    // box size == pointer size\n    println!(\"Boxed point occupies {} bytes on the stack\",\n             mem::size_of_val(&boxed_point));\n    println!(\"Boxed rectangle occupies {} bytes on the stack\",\n             mem::size_of_val(&boxed_rectangle));\n    println!(\"Boxed box occupies {} bytes on the stack\",\n             mem::size_of_val(&box_in_a_box));\n\n    // Copy the data contained in `boxed_point` into `unboxed_point`\n    let unboxed_point: Point = *boxed_point;\n    println!(\"Unboxed point occupies {} bytes on the stack\",\n             mem::size_of_val(&unboxed_point));\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Methods for Generic and Concrete Types in Rust\nDESCRIPTION: Demonstrates the syntax for implementing methods on both generic and concrete types. Shows how to specify type parameters for generic implementations and how to maintain genericity with the `<T>` notation.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/generics/impl.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct S; // Concrete type `S`\nstruct GenericVal<T>(T); // Generic type `GenericVal`\n\n// impl of GenericVal where we explicitly specify type parameters:\nimpl GenericVal<f32> {} // Specify `f32`\nimpl GenericVal<S> {} // Specify `S` as defined above\n\n// `<T>` Must precede the type to remain generic\nimpl<T> GenericVal<T> {}\n```\n\n----------------------------------------\n\nTITLE: Implementing Methods with Lifetime Annotations in Rust\nDESCRIPTION: Shows how to implement methods on a struct Owner with lifetime annotations. Includes examples of both mutable method (add_one) and immutable method (print), demonstrating proper lifetime annotation syntax using 'a parameter.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/scope/lifetime/methods.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Owner(i32);\n\nimpl Owner {\n    // Annotate lifetimes as in a standalone function.\n    fn add_one<'a>(&'a mut self) { self.0 += 1; }\n    fn print<'a>(&'a self) {\n        println!(\"`print`: {}\", self.0);\n    }\n}\n\nfn main() {\n    let mut owner = Owner(18);\n\n    owner.add_one();\n    owner.print();\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Rust Literals and Operators\nDESCRIPTION: A complete example showing different types of literal values and operators in Rust, including integer arithmetic, boolean logic, bitwise operations, and scientific notation. The code demonstrates type suffixes, numeric separators, and various number formats (binary, hexadecimal).\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/primitives/literals.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    // Integer addition\n    println!(\"1 + 2 = {}\", 1u32 + 2);\n\n    // Integer subtraction\n    println!(\"1 - 2 = {}\", 1i32 - 2);\n    // TODO ^ Try changing `1i32` to `1u32` to see why the type is important\n\n    // Scientific notation\n    println!(\"1e4 is {}, -2.5e-3 is {}\", 1e4, -2.5e-3);\n\n    // Short-circuiting boolean logic\n    println!(\"true AND false is {}\", true && false);\n    println!(\"true OR false is {}\", true || false);\n    println!(\"NOT true is {}\", !true);\n\n    // Bitwise operations\n    println!(\"0011 AND 0101 is {:04b}\", 0b0011u32 & 0b0101);\n    println!(\"0011 OR 0101 is {:04b}\", 0b0011u32 | 0b0101);\n    println!(\"0011 XOR 0101 is {:04b}\", 0b0011u32 ^ 0b0101);\n    println!(\"1 << 5 is {}\", 1u32 << 5);\n    println!(\"0x80 >> 2 is 0x{:x}\", 0x80u32 >> 2);\n\n    // Use underscores to improve readability!\n    println!(\"One million is written as {}\", 1_000_000u32);\n}\n```\n\n----------------------------------------\n\nTITLE: Destructuring Rust Enum Using Pattern Matching\nDESCRIPTION: This snippet demonstrates how to define a Color enum with various color model variants and destructure it using pattern matching. It shows both simple named variants (Red, Blue, Green) and tuple variants that contain associated data (RGB, HSV, HSL, CMY, CMYK).\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/flow_control/match/destructuring/destructure_enum.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// `allow` required to silence warnings because only\n// one variant is used.\n#[allow(dead_code)]\nenum Color {\n    // These 3 are specified solely by their name.\n    Red,\n    Blue,\n    Green,\n    // These likewise tie `u32` tuples to different names: color models.\n    RGB(u32, u32, u32),\n    HSV(u32, u32, u32),\n    HSL(u32, u32, u32),\n    CMY(u32, u32, u32),\n    CMYK(u32, u32, u32, u32),\n}\n\nfn main() {\n    let color = Color::RGB(122, 17, 40);\n    // TODO ^ Try different variants for `color`\n\n    println!(\"What color is it?\");\n    // An `enum` can be destructured using a `match`.\n    match color {\n        Color::Red   => println!(\"The color is Red!\"),\n        Color::Blue  => println!(\"The color is Blue!\"),\n        Color::Green => println!(\"The color is Green!\"),\n        Color::RGB(r, g, b) =>\n            println!(\"Red: {}, green: {}, and blue: {}!\", r, g, b),\n        Color::HSV(h, s, v) =>\n            println!(\"Hue: {}, saturation: {}, value: {}!\", h, s, v),\n        Color::HSL(h, s, l) =>\n            println!(\"Hue: {}, saturation: {}, lightness: {}!\", h, s, l),\n        Color::CMY(c, m, y) =>\n            println!(\"Cyan: {}, magenta: {}, yellow: {}!\", c, m, y),\n        Color::CMYK(c, m, y, k) =>\n            println!(\"Cyan: {}, magenta: {}, yellow: {}, key (black): {}!\",\n                c, m, y, k),\n        // Don't need another arm because all variants have been examined\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Error Type with Error Wrapping in Rust\nDESCRIPTION: Demonstrates creating a custom DoubleError type that wraps ParseIntError and implements necessary error handling traits. Shows error propagation using the ? operator and proper error source tracking. The example attempts to parse and double the first number in a vector of strings.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/error/multiple_error_types/wrap_error.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::error;\nuse std::error::Error;\nuse std::num::ParseIntError;\nuse std::fmt;\n\ntype Result<T> = std::result::Result<T, DoubleError>;\n\n#[derive(Debug)]\nenum DoubleError {\n    EmptyVec,\n    // We will defer to the parse error implementation for their error.\n    // Supplying extra info requires adding more data to the type.\n    Parse(ParseIntError),\n}\n\nimpl fmt::Display for DoubleError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match *self {\n            DoubleError::EmptyVec =>\n                write!(f, \"please use a vector with at least one element\"),\n            // The wrapped error contains additional information and is available\n            // via the source() method.\n            DoubleError::Parse(..) =>\n                write!(f, \"the provided string could not be parsed as int\"),\n        }\n    }\n}\n\nimpl error::Error for DoubleError {\n    fn source(&self) -> Option<&(dyn error::Error + 'static)> {\n        match *self {\n            DoubleError::EmptyVec => None,\n            // The cause is the underlying implementation error type. Is implicitly\n            // cast to the trait object `&error::Error`. This works because the\n            // underlying type already implements the `Error` trait.\n            DoubleError::Parse(ref e) => Some(e),\n        }\n    }\n}\n\n// Implement the conversion from `ParseIntError` to `DoubleError`.\n// This will be automatically called by `?` if a `ParseIntError`\n// needs to be converted into a `DoubleError`.\nimpl From<ParseIntError> for DoubleError {\n    fn from(err: ParseIntError) -> DoubleError {\n        DoubleError::Parse(err)\n    }\n}\n\nfn double_first(vec: Vec<&str>) -> Result<i32> {\n    let first = vec.first().ok_or(DoubleError::EmptyVec)?;\n    // Here we implicitly use the `ParseIntError` implementation of `From` (which\n    // we defined above) in order to create a `DoubleError`.\n    let parsed = first.parse::<i32>()?;\n\n    Ok(2 * parsed)\n}\n\nfn print(result: Result<i32>) {\n    match result {\n        Ok(n)  => println!(\"The first doubled is {}\", n),\n        Err(e) => {\n            println!(\"Error: {}\", e);\n            if let Some(source) = e.source() {\n                println!(\"  Caused by: {}\", source);\n            }\n        },\n    }\n}\n\nfn main() {\n    let numbers = vec![\"42\", \"93\", \"18\"];\n    let empty = vec![];\n    let strings = vec![\"tofu\", \"93\", \"18\"];\n\n    print(double_first(numbers));\n    print(double_first(empty));\n    print(double_first(strings));\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Enum Variants in Rust\nDESCRIPTION: Demonstrates how to create an enum with different variant types (unit-like, tuple structs, and C-like structures), and how to match against these variants. The example uses a WebEvent enum to classify different web events and shows pattern matching with destructuring.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/custom_types/enum.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// Create an `enum` to classify a web event. Note how both\n// names and type information together specify the variant:\n// `PageLoad != PageUnload` and `KeyPress(char) != Paste(String)`.\n// Each is different and independent.\nenum WebEvent {\n    // An `enum` variant may either be `unit-like`,\n    PageLoad,\n    PageUnload,\n    // like tuple structs,\n    KeyPress(char),\n    Paste(String),\n    // or c-like structures.\n    Click { x: i64, y: i64 },\n}\n\n// A function which takes a `WebEvent` enum as an argument and\n// returns nothing.\nfn inspect(event: WebEvent) {\n    match event {\n        WebEvent::PageLoad => println!(\"page loaded\"),\n        WebEvent::PageUnload => println!(\"page unloaded\"),\n        // Destructure `c` from inside the `enum` variant.\n        WebEvent::KeyPress(c) => println!(\"pressed '{}'.\", c),\n        WebEvent::Paste(s) => println!(\"pasted \\\"{}\\\".\", s),\n        // Destructure `Click` into `x` and `y`.\n        WebEvent::Click { x, y } => {\n            println!(\"clicked at x={}, y={}.\", x, y);\n        },\n    }\n}\n\nfn main() {\n    let pressed = WebEvent::KeyPress('x');\n    // `to_owned()` creates an owned `String` from a string slice.\n    let pasted  = WebEvent::Paste(\"my text\".to_owned());\n    let click   = WebEvent::Click { x: 20, y: 80 };\n    let load    = WebEvent::PageLoad;\n    let unload  = WebEvent::PageUnload;\n\n    inspect(pressed);\n    inspect(pasted);\n    inspect(click);\n    inspect(load);\n    inspect(unload);\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Rc Reference Counting in Rust\nDESCRIPTION: This example demonstrates how to use the `Rc` (Reference Counting) type in Rust to create multiple owners of a value. It shows how reference counts are tracked as `Rc` values are created, cloned, and dropped out of scope. The example also illustrates that `Rc` enables method calls directly on the contained value.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/std/rc.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::rc::Rc;\n\nfn main() {\n    let rc_examples = \"Rc examples\".to_string();\n    {\n        println!(\"--- rc_a is created ---\");\n        \n        let rc_a: Rc<String> = Rc::new(rc_examples);\n        println!(\"Reference Count of rc_a: {}\", Rc::strong_count(&rc_a));\n        \n        {\n            println!(\"--- rc_a is cloned to rc_b ---\");\n            \n            let rc_b: Rc<String> = Rc::clone(&rc_a);\n            println!(\"Reference Count of rc_b: {}\", Rc::strong_count(&rc_b));\n            println!(\"Reference Count of rc_a: {}\", Rc::strong_count(&rc_a));\n            \n            // Two `Rc`s are equal if their inner values are equal\n            println!(\"rc_a and rc_b are equal: {}\", rc_a.eq(&rc_b));\n            \n            // We can use methods of a value directly\n            println!(\"Length of the value inside rc_a: {}\", rc_a.len());\n            println!(\"Value of rc_b: {}\", rc_b);\n            \n            println!(\"--- rc_b is dropped out of scope ---\");\n        }\n        \n        println!(\"Reference Count of rc_a: {}\", Rc::strong_count(&rc_a));\n        \n        println!(\"--- rc_a is dropped out of scope ---\");\n    }\n    \n    // Error! `rc_examples` already moved into `rc_a`\n    // And when `rc_a` is dropped, `rc_examples` is dropped together\n    // println!(\"rc_examples: {}\", rc_examples);\n    // TODO ^ Try uncommenting this line\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Filesystem Operations in Rust\nDESCRIPTION: This code snippet demonstrates various filesystem operations using the std::fs module in Rust. It includes functions for reading file contents, writing to files, creating empty files, and a main function that showcases directory creation, file manipulation, and symbolic link creation.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/std_misc/fs.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::fs;\nuse std::fs::{File, OpenOptions};\nuse std::io;\nuse std::io::prelude::*;\n#[cfg(target_family = \"unix\")]\nuse std::os::unix;\n#[cfg(target_family = \"windows\")]\nuse std::os::windows;\nuse std::path::Path;\n\n// A simple implementation of `% cat path`\nfn cat(path: &Path) -> io::Result<String> {\n    let mut f = File::open(path)?;\n    let mut s = String::new();\n    match f.read_to_string(&mut s) {\n        Ok(_) => Ok(s),\n        Err(e) => Err(e),\n    }\n}\n\n// A simple implementation of `% echo s > path`\nfn echo(s: &str, path: &Path) -> io::Result<()> {\n    let mut f = File::create(path)?;\n\n    f.write_all(s.as_bytes())\n}\n\n// A simple implementation of `% touch path` (ignores existing files)\nfn touch(path: &Path) -> io::Result<()> {\n    match OpenOptions::new().create(true).write(true).open(path) {\n        Ok(_) => Ok(()),\n        Err(e) => Err(e),\n    }\n}\n\nfn main() {\n    println!(\"`mkdir a`\");\n    // Create a directory, returns `io::Result<()>`\n    match fs::create_dir(\"a\") {\n        Err(why) => println!(\"! {:?}\", why.kind()),\n        Ok(_) => {},\n    }\n\n    println!(\"`echo hello > a/b.txt`\");\n    // The previous match can be simplified using the `unwrap_or_else` method\n    echo(\"hello\", &Path::new(\"a/b.txt\")).unwrap_or_else(|why| {\n        println!(\"! {:?}\", why.kind());\n    });\n\n    println!(\"`mkdir -p a/c/d`\");\n    // Recursively create a directory, returns `io::Result<()>`\n    fs::create_dir_all(\"a/c/d\").unwrap_or_else(|why| {\n        println!(\"! {:?}\", why.kind());\n    });\n\n    println!(\"`touch a/c/e.txt`\");\n    touch(&Path::new(\"a/c/e.txt\")).unwrap_or_else(|why| {\n        println!(\"! {:?}\", why.kind());\n    });\n\n    println!(\"`ln -s ../b.txt a/c/b.txt`\");\n    // Create a symbolic link, returns `io::Result<()>`\n    #[cfg(target_family = \"unix\")] {\n        unix::fs::symlink(\"../b.txt\", \"a/c/b.txt\").unwrap_or_else(|why| {\n            println!(\"! {:?}\", why.kind());\n        });\n    }\n    #[cfg(target_family = \"windows\")] {\n        windows::fs::symlink_file(\"../b.txt\", \"a/c/b.txt\").unwrap_or_else(|why| {\n            println!(\"! {:?}\", why.to_string());\n        });\n    }\n\n    println!(\"`cat a/c/b.txt`\");\n    match cat(&Path::new(\"a/c/b.txt\")) {\n        Err(why) => println!(\"! {:?}\", why.kind()),\n        Ok(s) => println!(\"> {}\", s),\n    }\n\n    println!(\"`ls a`\");\n    // Read the contents of a directory, returns `io::Result<Vec<Path>>`\n    match fs::read_dir(\"a\") {\n        Err(why) => println!(\"! {:?}\", why.kind()),\n        Ok(paths) => for path in paths {\n            println!(\"> {:?}\", path.unwrap().path());\n        },\n    }\n\n    println!(\"`rm a/c/e.txt`\");\n    // Remove a file, returns `io::Result<()>`\n    fs::remove_file(\"a/c/e.txt\").unwrap_or_else(|why| {\n        println!(\"! {:?}\", why.kind());\n    });\n\n    println!(\"`rmdir a/c/d`\");\n    // Remove an empty directory, returns `io::Result<()>`\n    fs::remove_dir(\"a/c/d\").unwrap_or_else(|why| {\n        println!(\"! {:?}\", why.kind());\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Partial Moves with Struct Destructuring in Rust\nDESCRIPTION: Shows how to partially move fields from a struct using destructuring patterns. The example creates a Person struct with name and age fields, then demonstrates moving the name field while only referencing the age field. Also illustrates limitations with Drop trait implementation.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/scope/move/partial_move.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    #[derive(Debug)]\n    struct Person {\n        name: String,\n        age: Box<u8>,\n    }\n\n    // Error! cannot move out of a type which implements the `Drop` trait\n    //impl Drop for Person {\n    //    fn drop(&mut self) {\n    //        println!(\"Dropping the person struct {:?}\", self)\n    //    }\n    //}\n    // TODO ^ Try uncommenting these lines\n\n    let person = Person {\n        name: String::from(\"Alice\"),\n        age: Box::new(20),\n    };\n\n    // `name` is moved out of person, but `age` is referenced\n    let Person { name, ref age } = person;\n\n    println!(\"The person's age is {}\", age);\n\n    println!(\"The person's name is {}\", name);\n\n    // Error! borrow of partially moved value: `person` partial move occurs\n    //println!(\"The person struct is {:?}\", person);\n\n    // `person` cannot be used but `person.age` can be used as it is not moved\n    println!(\"The person's age from person struct is {}\", person.age);\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Closure Syntax in Rust\nDESCRIPTION: Demonstrates the basic syntax of a closure in Rust that captures a variable from its enclosing environment.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/fn/closures.md#2025-04-21_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n|val| val + x\n```\n\n----------------------------------------\n\nTITLE: Error Handling with Result in Rust\nDESCRIPTION: The Result type is used when operations might fail and the caller needs to handle the error. Unwrap and expect can be used, but should be avoided in production code.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/error.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nlet result: Result<i32, String> = Ok(42);\nlet unwrapped = result.unwrap();\nlet expected = result.expect(\"Operation should succeed\");\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom HashMap Keys with User Authentication in Rust\nDESCRIPTION: Demonstrates a simple user authentication system using custom struct types as HashMap keys. Shows how to derive Eq and Hash traits for custom types and implement a basic login verification system using HashMap lookups.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/std/hash/alt_key_types.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::collections::HashMap;\n\n// Eq requires that you derive PartialEq on the type.\n#[derive(PartialEq, Eq, Hash)]\nstruct Account<'a>{\n    username: &'a str,\n    password: &'a str,\n}\n\nstruct AccountInfo<'a>{\n    name: &'a str,\n    email: &'a str,\n}\n\ntype Accounts<'a> = HashMap<Account<'a>, AccountInfo<'a>>;\n\nfn try_logon<'a>(accounts: &Accounts<'a>,\n        username: &'a str, password: &'a str){\n    println!(\"Username: {}\", username);\n    println!(\"Password: {}\", password);\n    println!(\"Attempting logon...\");\n\n    let logon = Account {\n        username,\n        password,\n    };\n\n    match accounts.get(&logon) {\n        Some(account_info) => {\n            println!(\"Successful logon!\");\n            println!(\"Name: {}\", account_info.name);\n            println!(\"Email: {}\", account_info.email);\n        },\n        _ => println!(\"Login failed!\"),\n    }\n}\n\nfn main(){\n    let mut accounts: Accounts = HashMap::new();\n\n    let account = Account {\n        username: \"j.everyman\",\n        password: \"password123\",\n    };\n\n    let account_info = AccountInfo {\n        name: \"John Everyman\",\n        email: \"j.everyman@email.com\",\n    };\n\n    accounts.insert(account, account_info);\n\n    try_logon(&accounts, \"j.everyman\", \"psasword123\");\n\n    try_logon(&accounts, \"j.everyman\", \"password123\");\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Argument Parsing with Pattern Matching in Rust\nDESCRIPTION: This Rust program demonstrates argument parsing using pattern matching. It handles different cases based on the number of arguments provided and performs actions like checking for a specific number, increasing or decreasing a number, and displaying help information.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/std_misc/arg/matching.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::env;\n\nfn increase(number: i32) {\n    println!(\"{}\", number + 1);\n}\n\nfn decrease(number: i32) {\n    println!(\"{}\", number - 1);\n}\n\nfn help() {\n    println!(\"usage:\nmatch_args <string>\n    Check whether given string is the answer.\nmatch_args {{increase|decrease}} <integer>\n    Increase or decrease given integer by one.\");\n}\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n\n    match args.len() {\n        // no arguments passed\n        1 => {\n            println!(\"My name is 'match_args'. Try passing some arguments!\");\n        },\n        // one argument passed\n        2 => {\n            match args[1].parse() {\n                Ok(42) => println!(\"This is the answer!\"),\n                _ => println!(\"This is not the answer.\"),\n            }\n        },\n        // one command and one argument passed\n        3 => {\n            let cmd = &args[1];\n            let num = &args[2];\n            // parse the number\n            let number: i32 = match num.parse() {\n                Ok(n) => {\n                    n\n                },\n                Err(_) => {\n                    eprintln!(\"error: second argument not an integer\");\n                    help();\n                    return;\n                },\n            };\n            // parse the command\n            match &cmd[..] {\n                \"increase\" => increase(number),\n                \"decrease\" => decrease(number),\n                _ => {\n                    eprintln!(\"error: invalid command\");\n                    help();\n                },\n            }\n        },\n        // all the other cases\n        _ => {\n            // show a help message\n            help();\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Mutable and Immutable Variables in Rust\nDESCRIPTION: Shows the difference between mutable and immutable variable bindings in Rust. The example creates both types of variables and demonstrates how mutable variables can be modified while attempting to modify immutable variables results in compilation errors.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/variable_bindings/mut.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let _immutable_binding = 1;\n    let mut mutable_binding = 1;\n\n    println!(\"Before mutation: {}\", mutable_binding);\n\n    // Ok\n    mutable_binding += 1;\n\n    println!(\"After mutation: {}\", mutable_binding);\n\n    // Error! Cannot assign a new value to an immutable variable\n    _immutable_binding += 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Generic Functions with Trait Bounds in Rust\nDESCRIPTION: Demonstrates how to define a generic function that requires its type parameter to implement the Display trait. This constraint ensures that the generic type can be formatted as a string for printing.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/generics/bounds.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// Define a function `printer` that takes a generic type `T` which\n// must implement trait `Display`.\nfn printer<T: Display>(t: T) {\n    println!(\"{}\", t);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Functions with Closure Parameters in Rust\nDESCRIPTION: This code demonstrates how to define functions that accept closures as parameters and how different closure traits (FnOnce, Fn, FnMut) affect variable capture. It includes examples of variable capture by reference, mutable reference, and value, showing how closure behavior determines which trait bound is required.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/fn/closures/input_parameters.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// A function which takes a closure as an argument and calls it.\n// <F> denotes that F is a \"Generic type parameter\"\nfn apply<F>(f: F) where\n    // The closure takes no input and returns nothing.\n    F: FnOnce() {\n    // ^ TODO: Try changing this to `Fn` or `FnMut`.\n\n    f();\n}\n\n// A function which takes a closure and returns an `i32`.\nfn apply_to_3<F>(f: F) -> i32 where\n    // The closure takes an `i32` and returns an `i32`.\n    F: Fn(i32) -> i32 {\n\n    f(3)\n}\n\nfn main() {\n    use std::mem;\n\n    let greeting = \"hello\";\n    // A non-copy type.\n    // `to_owned` creates owned data from borrowed one\n    let mut farewell = \"goodbye\".to_owned();\n\n    // Capture 2 variables: `greeting` by reference and\n    // `farewell` by value.\n    let diary = || {\n        // `greeting` is by reference: requires `Fn`.\n        println!(\"I said {}.\", greeting);\n\n        // Mutation forces `farewell` to be captured by\n        // mutable reference. Now requires `FnMut`.\n        farewell.push_str(\"!!!\");\n        println!(\"Then I screamed {}.\", farewell);\n        println!(\"Now I can sleep. zzzzz\");\n\n        // Manually calling drop forces `farewell` to\n        // be captured by value. Now requires `FnOnce`.\n        mem::drop(farewell);\n    };\n\n    // Call the function which applies the closure.\n    apply(diary);\n\n    // `double` satisfies `apply_to_3`'s trait bound\n    let double = |x| 2 * x;\n\n    println!(\"3 doubled: {}\", apply_to_3(double));\n}\n```\n\n----------------------------------------\n\nTITLE: Efficient Implementation of read_lines Function using BufReader in Rust\nDESCRIPTION: An efficient approach to reading lines from a file using BufReader. It returns an iterator over the lines of the file, reducing memory usage. The main function demonstrates how to use this implementation.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/std_misc/file/read_lines.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse std::fs::File;\nuse std::io::{self, BufRead};\nuse std::path::Path;\n\nfn main() {\n    // File hosts.txt must exist in the current path\n    if let Ok(lines) = read_lines(\"./hosts.txt\") {\n        // Consumes the iterator, returns an (Optional) String\n        for line in lines.map_while(Result::ok) {\n            println!(\"{}\", line);\n        }\n    }\n}\n\n// The output is wrapped in a Result to allow matching on errors.\n// Returns an Iterator to the Reader of the lines of the file.\nfn read_lines<P>(filename: P) -> io::Result<io::Lines<io::BufReader<File>>>\nwhere P: AsRef<Path>, {\n    let file = File::open(filename)?;\n    Ok(io::BufReader::new(file).lines())\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic and Non-Generic Functions in Rust\nDESCRIPTION: This example demonstrates the differences between generic and non-generic functions in Rust. It shows how to define concrete types, generic types, and functions that work with them. The code illustrates when a function is truly generic based on its type parameter declarations and how to call functions with explicit and implicit type parameters.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/generics/gen_fn.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct A;          // Concrete type `A`.\nstruct S(A);       // Concrete type `S`.\nstruct SGen<T>(T); // Generic type `SGen`.\n\n// The following functions all take ownership of the variable passed into\n// them and immediately go out of scope, freeing the variable.\n\n// Define a function `reg_fn` that takes an argument `_s` of type `S`.\n// This has no `<T>` so this is not a generic function.\nfn reg_fn(_s: S) {}\n\n// Define a function `gen_spec_t` that takes an argument `_s` of type `SGen<T>`.\n// It has been explicitly given the type parameter `A`, but because `A` has not \n// been specified as a generic type parameter for `gen_spec_t`, it is not generic.\nfn gen_spec_t(_s: SGen<A>) {}\n\n// Define a function `gen_spec_i32` that takes an argument `_s` of type `SGen<i32>`.\n// It has been explicitly given the type parameter `i32`, which is a specific type.\n// Because `i32` is not a generic type, this function is also not generic.\nfn gen_spec_i32(_s: SGen<i32>) {}\n\n// Define a function `generic` that takes an argument `_s` of type `SGen<T>`.\n// Because `SGen<T>` is preceded by `<T>`, this function is generic over `T`.\nfn generic<T>(_s: SGen<T>) {}\n\nfn main() {\n    // Using the non-generic functions\n    reg_fn(S(A));          // Concrete type.\n    gen_spec_t(SGen(A));   // Implicitly specified type parameter `A`.\n    gen_spec_i32(SGen(6)); // Implicitly specified type parameter `i32`.\n\n    // Explicitly specified type parameter `char` to `generic()`.\n    generic::<char>(SGen('a'));\n\n    // Implicitly specified type parameter `char` to `generic()`.\n    generic(SGen('c'));\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Unit Testing in Rust\nDESCRIPTION: Demonstrates basic unit testing in Rust, including test function structure, assertion macros, and running tests with cargo test.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/testing/unit_testing.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub fn add(a: i32, b: i32) -> i32 {\n    a + b\n}\n\n// This is a really bad adding function, its purpose is to fail in this\n// example.\n#[allow(dead_code)]\nfn bad_add(a: i32, b: i32) -> i32 {\n    a - b\n}\n\n#[cfg(test)]\nmod tests {\n    // Note this useful idiom: importing names from outer (for mod tests) scope.\n    use super::*;\n\n    #[test]\n    fn test_add() {\n        assert_eq!(add(1, 2), 3);\n    }\n\n    #[test]\n    fn test_bad_add() {\n        // This assert would fire and test will fail.\n        // Please note, that private functions can be tested too!\n        assert_eq!(bad_add(1, 2), 3);\n    }\n}\n```\n\nLANGUAGE: shell\nCODE:\n```\n$ cargo test\n\nrunning 2 tests\ntest tests::test_bad_add ... FAILED\ntest tests::test_add ... ok\n\nfailures:\n\n---- tests::test_bad_add stdout ----\n        thread 'tests::test_bad_add' panicked at 'assertion failed: `(left == right)`\n  left: `-1`,\n right: `3`', src/lib.rs:21:8\nnote: Run with `RUST_BACKTRACE=1` for a backtrace.\n\n\nfailures:\n    tests::test_bad_add\n\ntest result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out\n```\n\n----------------------------------------\n\nTITLE: Implementing Map-Reduce Pattern with Rust Threads\nDESCRIPTION: Implementation of a parallel digit sum calculator using Rust's threading primitives. The program splits input data into chunks, processes each chunk in a separate thread to calculate partial sums (map phase), and then combines the results into a final sum (reduce phase). It demonstrates thread spawning, closure usage, and safe concurrent data access.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/std_misc/threads/testcase_mapreduce.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::thread;\n\n// This is the `main` thread\nfn main() {\n\n    // This is our data to process.\n    // We will calculate the sum of all digits via a threaded map-reduce algorithm.\n    // Each whitespace separated chunk will be handled in a different thread.\n    //\n    // TODO: see what happens to the output if you insert spaces!\n    let data = \"86967897737416471853297327050364959\n11861322575564723963297542624962850\n70856234701860851907960690014725639\n38397966707106094172783238747669219\n52380795257888236525459303330302837\n58495327135744041048897885734297812\n69920216438980873548808413720956532\n16278424637452589860345374828574668\";\n\n    // Make a vector to hold the child-threads which we will spawn.\n    let mut children = vec![];\n\n    /*************************************************************************\n     * \"Map\" phase\n     *\n     * Divide our data into segments, and apply initial processing\n     ************************************************************************/\n\n    // split our data into segments for individual calculation\n    // each chunk will be a reference (&str) into the actual data\n    let chunked_data = data.split_whitespace();\n\n    // Iterate over the data segments.\n    // .enumerate() adds the current loop index to whatever is iterated\n    // the resulting tuple \"(index, element)\" is then immediately\n    // \"destructured\" into two variables, \"i\" and \"data_segment\" with a\n    // \"destructuring assignment\"\n    for (i, data_segment) in chunked_data.enumerate() {\n        println!(\"data segment {} is \\\"{}\\\"\", i, data_segment);\n\n        // Process each data segment in a separate thread\n        //\n        // spawn() returns a handle to the new thread,\n        // which we MUST keep to access the returned value\n        //\n        // 'move || -> u32' is syntax for a closure that:\n        // * takes no arguments ('||')\n        // * takes ownership of its captured variables ('move') and\n        // * returns an unsigned 32-bit integer ('-> u32')\n        //\n        // Rust is smart enough to infer the '-> u32' from\n        // the closure itself so we could have left that out.\n        //\n        // TODO: try removing the 'move' and see what happens\n        children.push(thread::spawn(move || -> u32 {\n            // Calculate the intermediate sum of this segment:\n            let result = data_segment\n                        // iterate over the characters of our segment..\n                        .chars()\n                        // .. convert text-characters to their number value..\n                        .map(|c| c.to_digit(10).expect(\"should be a digit\"))\n                        // .. and sum the resulting iterator of numbers\n                        .sum();\n\n            // println! locks stdout, so no text-interleaving occurs\n            println!(\"processed segment {}, result={}\", i, result);\n\n            // \"return\" not needed, because Rust is an \"expression language\", the\n            // last evaluated expression in each block is automatically its value.\n            result\n\n        }));\n    }\n\n\n    /*************************************************************************\n     * \"Reduce\" phase\n     *\n     * Collect our intermediate results, and combine them into a final result\n     ************************************************************************/\n\n    // combine each thread's intermediate results into a single final sum.\n    //\n    // we use the \"turbofish\" ::<> to provide sum() with a type hint.\n    //\n    // TODO: try without the turbofish, by instead explicitly\n    // specifying the type of final_result\n    let final_result = children.into_iter().map(|c| c.join().unwrap()).sum::<u32>();\n\n    println!(\"Final sum result: {}\", final_result);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing and Using and_then Combinator in Rust\nDESCRIPTION: This code snippet demonstrates the use of and_then combinator in Rust. It defines enums for Food and Day, functions for checking ingredients and recipes, and different versions of a cookable function. The example shows how and_then simplifies handling of nested Option types compared to map and manual matching.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/error/option_unwrap/and_then.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![allow(dead_code)]\n\n#[derive(Debug)] enum Food { CordonBleu, Steak, Sushi }\n#[derive(Debug)] enum Day { Monday, Tuesday, Wednesday }\n\n// We don't have the ingredients to make Sushi.\nfn have_ingredients(food: Food) -> Option<Food> {\n    match food {\n        Food::Sushi => None,\n        _           => Some(food),\n    }\n}\n\n// We have the recipe for everything except Cordon Bleu.\nfn have_recipe(food: Food) -> Option<Food> {\n    match food {\n        Food::CordonBleu => None,\n        _                => Some(food),\n    }\n}\n\n// To make a dish, we need both the recipe and the ingredients.\n// We can represent the logic with a chain of `match`es:\nfn cookable_v1(food: Food) -> Option<Food> {\n    match have_recipe(food) {\n        None       => None,\n        Some(food) => have_ingredients(food),\n    }\n}\n\n// This can conveniently be rewritten more compactly with `and_then()`:\nfn cookable_v3(food: Food) -> Option<Food> {\n    have_recipe(food).and_then(have_ingredients)\n}\n\n// Otherwise we'd need to `flatten()` an `Option<Option<Food>>`\n// to get an `Option<Food>`:\nfn cookable_v2(food: Food) -> Option<Food> {\n    have_recipe(food).map(have_ingredients).flatten()\n}\n\nfn eat(food: Food, day: Day) {\n    match cookable_v3(food) {\n        Some(food) => println!(\"Yay! On {:?} we get to eat {:?}.\", day, food),\n        None       => println!(\"Oh no. We don't get to eat on {:?}?\", day),\n    }\n}\n\nfn main() {\n    let (cordon_bleu, steak, sushi) = (Food::CordonBleu, Food::Steak, Food::Sushi);\n\n    eat(cordon_bleu, Day::Monday);\n    eat(steak, Day::Tuesday);\n    eat(sushi, Day::Wednesday);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom Destructor with Drop Trait in Rust\nDESCRIPTION: This example demonstrates how to implement a custom destructor in Rust using the Drop trait, which is called automatically when an object goes out of scope.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/scope/raii.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nstruct ToDrop;\n\nimpl Drop for ToDrop {\n    fn drop(&mut self) {\n        println!(\"ToDrop is being dropped\");\n    }\n}\n\nfn main() {\n    let x = ToDrop;\n    println!(\"Made a ToDrop!\");\n}\n```\n\n----------------------------------------\n\nTITLE: Spawning Multiple OS Threads in Rust\nDESCRIPTION: Creates 10 OS threads using thread::spawn, each printing its thread number. The main thread waits for all child threads to complete using join(). Uses a moving closure to capture the loop variable.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/std_misc/threads.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::thread;\n\nconst NTHREADS: u32 = 10;\n\n// This is the `main` thread\nfn main() {\n    // Make a vector to hold the children which are spawned.\n    let mut children = vec![];\n\n    for i in 0..NTHREADS {\n        // Spin up another thread\n        children.push(thread::spawn(move || {\n            println!(\"this is thread number {}\", i);\n        }));\n    }\n\n    for child in children {\n        // Wait for the thread to finish. Returns a result.\n        let _ = child.join();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TryFrom and Using TryInto for Fallible Type Conversions in Rust\nDESCRIPTION: This code demonstrates implementing the TryFrom trait for a custom EvenNumber struct that only accepts even integers. It shows both direct usage of TryFrom and the TryInto trait which works through type inference. Both traits return Result types to handle conversion failures.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/conversion/try_from_try_into.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::convert::TryFrom;\nuse std::convert::TryInto;\n\n#[derive(Debug, PartialEq)]\nstruct EvenNumber(i32);\n\nimpl TryFrom<i32> for EvenNumber {\n    type Error = ();\n\n    fn try_from(value: i32) -> Result<Self, Self::Error> {\n        if value % 2 == 0 {\n            Ok(EvenNumber(value))\n        } else {\n            Err(())\n        }\n    }\n}\n\nfn main() {\n    // TryFrom\n\n    assert_eq!(EvenNumber::try_from(8), Ok(EvenNumber(8)));\n    assert_eq!(EvenNumber::try_from(5), Err(()));\n\n    // TryInto\n\n    let result: Result<EvenNumber, ()> = 8i32.try_into();\n    assert_eq!(result, Ok(EvenNumber(8)));\n    let result: Result<EvenNumber, ()> = 5i32.try_into();\n    assert_eq!(result, Err(()));\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating RAII and Memory Management in Rust\nDESCRIPTION: This snippet showcases Rust's RAII principle by allocating memory on the heap using Box<T> and demonstrating automatic memory deallocation when variables go out of scope.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/scope/raii.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn create_box() {\n    // Allocate an integer on the heap\n    let _box1 = Box::new(3i32);\n\n    // `_box1` is destroyed here, and memory gets freed\n}\n\nfn main() {\n    // Allocate an integer on the heap\n    let _box2 = Box::new(5i32);\n\n    // A nested scope:\n    {\n        // Allocate an integer on the heap\n        let _box3 = Box::new(4i32);\n\n        // `_box3` is destroyed here, and memory gets freed\n    }\n\n    // Creating lots of boxes just for fun\n    // There's no need to manually free memory!\n    for _ in 0u32..1_000 {\n        create_box();\n    }\n\n    // `_box2` is destroyed here, and memory gets freed\n}\n```\n\n----------------------------------------\n\nTITLE: Manipulating File Paths using Path and PathBuf in Rust\nDESCRIPTION: This code snippet demonstrates how to create, manipulate, and convert file paths using the Path and PathBuf structs in Rust. It shows operations like joining paths, pushing new components, setting file names, and converting paths to strings.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/std_misc/path.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::path::Path;\n\nfn main() {\n    // Create a `Path` from an `&'static str`\n    let path = Path::new(\".\");\n\n    // The `display` method returns a `Display`able structure\n    let _display = path.display();\n\n    // `join` merges a path with a byte container using the OS specific\n    // separator, and returns a `PathBuf`\n    let mut new_path = path.join(\"a\").join(\"b\");\n\n    // `push` extends the `PathBuf` with a `&Path`\n    new_path.push(\"c\");\n    new_path.push(\"myfile.tar.gz\");\n\n    // `set_file_name` updates the file name of the `PathBuf`\n    new_path.set_file_name(\"package.tgz\");\n\n    // Convert the `PathBuf` into a string slice\n    match new_path.to_str() {\n        None => panic!(\"new path is not a valid UTF-8 sequence\"),\n        Some(s) => println!(\"new path is {}\", s),\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Iterating over a vector using iter() in Rust\nDESCRIPTION: This snippet demonstrates how to use iter() to iterate over a vector in Rust. It borrows each element, allowing the collection to be reused after the loop. The example matches against the borrowed values.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/flow_control/for.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let names = vec![\"Bob\", \"Frank\", \"Ferris\"];\n\n    for name in names.iter() {\n        match name {\n            &\"Ferris\" => println!(\"There is a rustacean among us!\"),\n            // TODO ^ Try deleting the & and matching just \"Ferris\"\n            _ => println!(\"Hello {}\", name),\n        }\n    }\n    \n    println!(\"names: {:?}\", names);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Result Return Type in Main Function\nDESCRIPTION: Demonstrates how to use Result as a return type in the main function, including proper error handling for string parsing with match expression.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/error/result.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse std::num::ParseIntError;\n\nfn main() -> Result<(), ParseIntError> {\n    let number_str = \"10\";\n    let number = match number_str.parse::<i32>() {\n        Ok(number)  => number,\n        Err(e) => return Err(e),\n    };\n    println!(\"{}\", number);\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Passing Functions and Closures as Arguments in Rust\nDESCRIPTION: This example demonstrates how both functions and closures that satisfy the Fn trait bound can be passed as arguments to the same function. It defines a generic function that takes any argument satisfying the Fn trait, then shows how to call it with both a closure and a regular function.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/fn/closures/input_functions.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// Define a function which takes a generic `F` argument\n// bounded by `Fn`, and calls it\nfn call_me<F: Fn()>(f: F) {\n    f();\n}\n\n// Define a wrapper function satisfying the `Fn` bound\nfn function() {\n    println!(\"I'm a function!\");\n}\n\nfn main() {\n    // Define a closure satisfying the `Fn` bound\n    let closure = || println!(\"I'm a closure!\");\n\n    call_me(closure);\n    call_me(function);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Thread Communication Using Rust Channels\nDESCRIPTION: Demonstrates the usage of mpsc (multiple producer, single consumer) channels in Rust for thread communication. Creates multiple threads that send their IDs through a channel to a main receiver, showing both blocking and non-blocking operations. Uses the std::sync::mpsc module for channel creation and thread spawning.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/std_misc/channels.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::sync::mpsc::{Sender, Receiver};\nuse std::sync::mpsc;\nuse std::thread;\n\nstatic NTHREADS: i32 = 3;\n\nfn main() {\n    // Channels have two endpoints: the `Sender<T>` and the `Receiver<T>`,\n    // where `T` is the type of the message to be transferred\n    // (type annotation is superfluous)\n    let (tx, rx): (Sender<i32>, Receiver<i32>) = mpsc::channel();\n    let mut children = Vec::new();\n\n    for id in 0..NTHREADS {\n        // The sender endpoint can be copied\n        let thread_tx = tx.clone();\n\n        // Each thread will send its id via the channel\n        let child = thread::spawn(move || {\n            // The thread takes ownership over `thread_tx`\n            // Each thread queues a message in the channel\n            thread_tx.send(id).unwrap();\n\n            // Sending is a non-blocking operation, the thread will continue\n            // immediately after sending its message\n            println!(\"thread {} finished\", id);\n        });\n\n        children.push(child);\n    }\n\n    // Here, all the messages are collected\n    let mut ids = Vec::with_capacity(NTHREADS as usize);\n    for _ in 0..NTHREADS {\n        // The `recv` method picks a message from the channel\n        // `recv` will block the current thread if there are no messages available\n        ids.push(rx.recv());\n    }\n    \n    // Wait for the threads to complete any remaining work\n    for child in children {\n        child.join().expect(\"oops! the child thread panicked\");\n    }\n\n    // Show the order in which the messages were sent\n    println!(\"{:?}\", ids);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing From trait for a custom type in Rust\nDESCRIPTION: This example demonstrates how to implement the From trait for a custom Number struct, allowing conversion from i32 to Number type. It shows the creation of a new Number instance from an i32 value.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/conversion/from_into.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::convert::From;\n\n#[derive(Debug)]\nstruct Number {\n    value: i32,\n}\n\nimpl From<i32> for Number {\n    fn from(item: i32) -> Self {\n        Number { value: item }\n    }\n}\n\nfn main() {\n    let num = Number::from(30);\n    println!(\"My number is {:?}\", num);\n}\n```\n\n----------------------------------------\n\nTITLE: Converting str to String using From trait in Rust\nDESCRIPTION: A simple example showing how to convert a string literal (str) to a String object using the From trait's implementation in the standard library.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/conversion/from_into.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet my_str = \"hello\";\nlet my_string = String::from(my_str);\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Type Aliases for Result in Rust\nDESCRIPTION: This example demonstrates how to define a generic alias for a Result type with a specific error type (ParseIntError) and then use it in functions to improve code readability. The example includes functions for multiplying parsed integers and printing the results, showing how the alias simplifies error handling.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/error/result/result_alias.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::num::ParseIntError;\n\n// Define a generic alias for a `Result` with the error type `ParseIntError`.\ntype AliasedResult<T> = Result<T, ParseIntError>;\n\n// Use the above alias to refer to our specific `Result` type.\nfn multiply(first_number_str: &str, second_number_str: &str) -> AliasedResult<i32> {\n    first_number_str.parse::<i32>().and_then(|first_number| {\n        second_number_str.parse::<i32>().map(|second_number| first_number * second_number)\n    })\n}\n\n// Here, the alias again allows us to save some space.\nfn print(result: AliasedResult<i32>) {\n    match result {\n        Ok(n)  => println!(\"n is {}\", n),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n\nfn main() {\n    print(multiply(\"10\", \"2\"));\n    print(multiply(\"t\", \"2\"));\n}\n```\n\n----------------------------------------\n\nTITLE: Type-Safe Unit Conversion Implementation in Rust\nDESCRIPTION: Complete implementation of a type-safe unit conversion system using phantom types. Demonstrates creation of unit types, Length struct with phantom parameters, and Add trait implementation with compile-time unit checking.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/generics/phantom/testcase_units.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::ops::Add;\nuse std::marker::PhantomData;\n\n/// Create void enumerations to define unit types.\n#[derive(Debug, Clone, Copy)]\nenum Inch {}\n#[derive(Debug, Clone, Copy)]\nenum Mm {}\n\n/// `Length` is a type with phantom type parameter `Unit`,\n/// and is not generic over the length type (that is `f64`).\n///\n/// `f64` already implements the `Clone` and `Copy` traits.\n#[derive(Debug, Clone, Copy)]\nstruct Length<Unit>(f64, PhantomData<Unit>);\n\n/// The `Add` trait defines the behavior of the `+` operator.\nimpl<Unit> Add for Length<Unit> {\n    type Output = Length<Unit>;\n\n    // add() returns a new `Length` struct containing the sum.\n    fn add(self, rhs: Length<Unit>) -> Length<Unit> {\n        // `+` calls the `Add` implementation for `f64`.\n        Length(self.0 + rhs.0, PhantomData)\n    }\n}\n\nfn main() {\n    // Specifies `one_foot` to have phantom type parameter `Inch`.\n    let one_foot:  Length<Inch> = Length(12.0, PhantomData);\n    // `one_meter` has phantom type parameter `Mm`.\n    let one_meter: Length<Mm>   = Length(1000.0, PhantomData);\n\n    // `+` calls the `add()` method we implemented for `Length<Unit>`.\n    //\n    // Since `Length` implements `Copy`, `add()` does not consume\n    // `one_foot` and `one_meter` but copies them into `self` and `rhs`.\n    let two_feet = one_foot + one_foot;\n    let two_meters = one_meter + one_meter;\n\n    // Addition works.\n    println!(\"one foot + one_foot = {:?} in\", two_feet.0);\n    println!(\"one meter + one_meter = {:?} mm\", two_meters.0);\n\n    // Nonsensical operations fail as they should:\n    // Compile-time Error: type mismatch.\n    //let one_feter = one_foot + one_meter;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Food Processing with Option and map() in Rust\nDESCRIPTION: This code snippet demonstrates the use of Option and the map() combinator in Rust for a food processing scenario. It shows how to chain multiple map() calls to simplify code and handle optional values efficiently.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/error/option_unwrap/map.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![allow(dead_code)]\n\n#[derive(Debug)] enum Food { Apple, Carrot, Potato }\n\n#[derive(Debug)] struct Peeled(Food);\n#[derive(Debug)] struct Chopped(Food);\n#[derive(Debug)] struct Cooked(Food);\n\n// Peeling food. If there isn't any, then return `None`.\n// Otherwise, return the peeled food.\nfn peel(food: Option<Food>) -> Option<Peeled> {\n    match food {\n        Some(food) => Some(Peeled(food)),\n        None       => None,\n    }\n}\n\n// Chopping food. If there isn't any, then return `None`.\n// Otherwise, return the chopped food.\nfn chop(peeled: Option<Peeled>) -> Option<Chopped> {\n    match peeled {\n        Some(Peeled(food)) => Some(Chopped(food)),\n        None               => None,\n    }\n}\n\n// Cooking food. Here, we showcase `map()` instead of `match` for case handling.\nfn cook(chopped: Option<Chopped>) -> Option<Cooked> {\n    chopped.map(|Chopped(food)| Cooked(food))\n}\n\n// A function to peel, chop, and cook food all in sequence.\n// We chain multiple uses of `map()` to simplify the code.\nfn process(food: Option<Food>) -> Option<Cooked> {\n    food.map(|f| Peeled(f))\n        .map(|Peeled(f)| Chopped(f))\n        .map(|Chopped(f)| Cooked(f))\n}\n\n// Check whether there's food or not before trying to eat it!\nfn eat(food: Option<Cooked>) {\n    match food {\n        Some(food) => println!(\"Mmm. I love {:?}\", food),\n        None       => println!(\"Oh no! It wasn't edible.\"),\n    }\n}\n\nfn main() {\n    let apple = Some(Food::Apple);\n    let carrot = Some(Food::Carrot);\n    let potato = None;\n\n    let cooked_apple = cook(chop(peel(apple)));\n    let cooked_carrot = cook(chop(peel(carrot)));\n    // Let's try the simpler looking `process()` now.\n    let cooked_potato = process(potato);\n\n    eat(cooked_apple);\n    eat(cooked_carrot);\n    eat(cooked_potato);\n}\n```\n\n----------------------------------------\n\nTITLE: Iterating over a vector using into_iter() in Rust\nDESCRIPTION: This snippet shows how to use into_iter() to iterate over a vector in Rust. It consumes the collection, moving the values into the loop. The example demonstrates matching against the moved values and the inability to use the collection after the loop.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/flow_control/for.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let names = vec![\"Bob\", \"Frank\", \"Ferris\"];\n\n    for name in names.into_iter() {\n        match name {\n            \"Ferris\" => println!(\"There is a rustacean among us!\"),\n            _ => println!(\"Hello {}\", name),\n        }\n    }\n    \n    println!(\"names: {:?}\", names);\n    // FIXME ^ Comment out this line\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Derived Traits for Tuple Structs in Rust\nDESCRIPTION: Example showing how to use #[derive] attribute to implement common traits like PartialEq, PartialOrd, and Debug for tuple structs. Demonstrates comparison operations, debug printing, and unit conversion between inches and centimeters.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/trait/derive.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// `Centimeters`, a tuple struct that can be compared\n#[derive(PartialEq, PartialOrd)]\nstruct Centimeters(f64);\n\n// `Inches`, a tuple struct that can be printed\n#[derive(Debug)]\nstruct Inches(i32);\n\nimpl Inches {\n    fn to_centimeters(&self) -> Centimeters {\n        let &Inches(inches) = self;\n\n        Centimeters(inches as f64 * 2.54)\n    }\n}\n\n// `Seconds`, a tuple struct with no additional attributes\nstruct Seconds(i32);\n\nfn main() {\n    let _one_second = Seconds(1);\n\n    // Error: `Seconds` can't be printed; it doesn't implement the `Debug` trait\n    //println!(\"One second looks like: {:?}\", _one_second);\n    // TODO ^ Try uncommenting this line\n\n    // Error: `Seconds` can't be compared; it doesn't implement the `PartialEq` trait\n    //let _this_is_true = (_one_second == _one_second);\n    // TODO ^ Try uncommenting this line\n\n    let foot = Inches(12);\n\n    println!(\"One foot equals {:?}\", foot);\n\n    let meter = Centimeters(100.0);\n\n    let cmp =\n        if foot.to_centimeters() < meter {\n            \"smaller\"\n        } else {\n            \"bigger\"\n        };\n\n    println!(\"One foot is {} than one meter.\", cmp);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing and Documenting Functions with Examples in Rust\nDESCRIPTION: Demonstrates how to write documentation comments for Rust functions, including summaries, detailed explanations, and example code blocks that serve as documentation tests.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/testing/doc_testing.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n/// First line is a short summary describing function.\n///\n/// The next lines present detailed documentation. Code blocks start with\n/// triple backquotes and have implicit `fn main()` inside\n/// and `extern crate <cratename>`. Assume we're testing `doccomments` crate:\n///\n/// ```\n/// let result = doccomments::add(2, 3);\n/// assert_eq!(result, 5);\n/// ```\npub fn add(a: i32, b: i32) -> i32 {\n    a + b\n}\n\n/// Usually doc comments may include sections \"Examples\", \"Panics\" and \"Failures\".\n///\n/// The next function divides two numbers.\n///\n/// # Examples\n///\n/// ```\n/// let result = doccomments::div(10, 2);\n/// assert_eq!(result, 5);\n/// ```\n///\n/// # Panics\n///\n/// The function panics if the second argument is zero.\n///\n/// ```rust,should_panic\n/// // panics on division by zero\n/// doccomments::div(10, 0);\n/// ```\npub fn div(a: i32, b: i32) -> i32 {\n    if b == 0 {\n        panic!(\"Divide-by-zero error\");\n    }\n\n    a / b\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Command Line Arguments with std::env in Rust\nDESCRIPTION: Demonstrates how to access command line arguments using Rust's standard library std::env::args(). The program collects arguments into a vector, where the first argument is the program path and subsequent elements are command line parameters.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/std_misc/arg.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::env;\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n\n    // The first argument is the path that was used to call the program.\n    println!(\"My path is {}.\", args[0]);\n\n    // The rest of the arguments are the passed command line parameters.\n    // Call the program like this:\n    //   $ ./args arg1 arg2\n    println!(\"I got {:?} arguments: {:?}.\", args.len() - 1, &args[1..]);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing the same logic with while let in Rust\nDESCRIPTION: This example shows how to use the while let pattern to simplify the previous code. It provides the same functionality with less nesting and more readable code, automatically handling the None case by breaking the loop.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/flow_control/while_let.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    // Make `optional` of type `Option<i32>`\n    let mut optional = Some(0);\n    \n    // This reads: \"while `let` destructures `optional` into\n    // `Some(i)`, evaluate the block (`{}`). Else `break`.\n    while let Some(i) = optional {\n        if i > 9 {\n            println!(\"Greater than 9, quit!\");\n            optional = None;\n        } else {\n            println!(\"`i` is `{:?}`. Try again.\", i);\n            optional = Some(i + 1);\n        }\n        // ^ Less rightward drift and doesn't require\n        // explicitly handling the failing case.\n    }\n    // ^ `if let` had additional optional `else`/`else if`\n    // clauses. `while let` does not have these.\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing HashSet Operations in Rust\nDESCRIPTION: Demonstrates core HashSet operations including insertion, containment checking, and set operations (union, difference, intersection, symmetric_difference). Shows how to create HashSets from vectors and perform various set operations while handling duplicates automatically.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/std/hash/hashset.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::collections::HashSet;\n\nfn main() {\n    let mut a: HashSet<i32> = vec![1i32, 2, 3].into_iter().collect();\n    let mut b: HashSet<i32> = vec![2i32, 3, 4].into_iter().collect();\n\n    assert!(a.insert(4));\n    assert!(a.contains(&4));\n\n    // `HashSet::insert()` returns false if\n    // there was a value already present.\n    assert!(b.insert(4), \"Value 4 is already in set B!\");\n    // FIXME ^ Comment out this line\n\n    b.insert(5);\n\n    // If a collection's element type implements `Debug`,\n    // then the collection implements `Debug`.\n    // It usually prints its elements in the format `[elem1, elem2, ...]`\n    println!(\"A: {:?}\", a);\n    println!(\"B: {:?}\", b);\n\n    // Print [1, 2, 3, 4, 5] in arbitrary order\n    println!(\"Union: {:?}\", a.union(&b).collect::<Vec<&i32>>());\n\n    // This should print [1]\n    println!(\"Difference: {:?}\", a.difference(&b).collect::<Vec<&i32>>());\n\n    // Print [2, 3, 4] in arbitrary order.\n    println!(\"Intersection: {:?}\", a.intersection(&b).collect::<Vec<&i32>>());\n\n    // Print [1, 5]\n    println!(\"Symmetric Difference: {:?}\",\n             a.symmetric_difference(&b).collect::<Vec<&i32>>());\n}\n```\n\n----------------------------------------\n\nTITLE: Practical Drop Trait Implementation for Temporary File Management\nDESCRIPTION: Shows a practical implementation of the Drop trait for automatic cleanup of temporary files. Demonstrates how to create a TempFile struct that automatically deletes its file when dropped, either through scope exit or manual dropping.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/trait/drop.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::fs::File;\nuse std::path::PathBuf;\n\nstruct TempFile {\n    file: File,\n    path: PathBuf,\n}\n\nimpl TempFile {\n    fn new(path: PathBuf) -> std::io::Result<Self> {\n        // Note: File::create() will overwrite existing files\n        let file = File::create(&path)?;\n        \n        Ok(Self { file, path })\n    }\n}\n\n// When TempFile is dropped:\n// 1. First, the File will be automatically closed (Drop for File)\n// 2. Then our drop implementation will remove the file\nimpl Drop for TempFile {\n    fn drop(&mut self) {\n        // Note: File is already closed at this point\n        if let Err(e) = std::fs::remove_file(&self.path) {\n            eprintln!(\"Failed to remove temporary file: {}\", e);\n        }\n        println!(\"> Dropped temporary file: {:?}\", self.path);\n    }\n}\n\nfn main() -> std::io::Result<()> {\n    // Create a new scope to demonstrate drop behavior\n    {\n        let temp = TempFile::new(\"test.txt\".into())?;\n        println!(\"Temporary file created\");\n        // File will be automatically cleaned up when temp goes out of scope\n    }\n    println!(\"End of scope - file should be cleaned up\");\n\n    // We can also manually drop if needed\n    let temp2 = TempFile::new(\"another_test.txt\".into())?;\n    drop(temp2); // Explicitly drop the file\n    println!(\"Manually dropped file\");\n    \n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Phantom Type Parameters with PhantomData in Rust\nDESCRIPTION: This code demonstrates how to use std::marker::PhantomData to implement phantom type parameters in Rust. It creates two types (PhantomTuple and PhantomStruct) that use phantom types to enable compile-time type checking based on hidden type parameters that don't require storage allocation.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/generics/phantom.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::marker::PhantomData;\n\n// A phantom tuple struct which is generic over `A` with hidden parameter `B`.\n#[derive(PartialEq)] // Allow equality test for this type.\nstruct PhantomTuple<A, B>(A, PhantomData<B>);\n\n// A phantom type struct which is generic over `A` with hidden parameter `B`.\n#[derive(PartialEq)] // Allow equality test for this type.\nstruct PhantomStruct<A, B> { first: A, phantom: PhantomData<B> }\n\n// Note: Storage is allocated for generic type `A`, but not for `B`.\n//       Therefore, `B` cannot be used in computations.\n\nfn main() {\n    // Here, `f32` and `f64` are the hidden parameters.\n    // PhantomTuple type specified as `<char, f32>`.\n    let _tuple1: PhantomTuple<char, f32> = PhantomTuple('Q', PhantomData);\n    // PhantomTuple type specified as `<char, f64>`.\n    let _tuple2: PhantomTuple<char, f64> = PhantomTuple('Q', PhantomData);\n\n    // Type specified as `<char, f32>`.\n    let _struct1: PhantomStruct<char, f32> = PhantomStruct {\n        first: 'Q',\n        phantom: PhantomData,\n    };\n    // Type specified as `<char, f64>`.\n    let _struct2: PhantomStruct<char, f64> = PhantomStruct {\n        first: 'Q',\n        phantom: PhantomData,\n    };\n\n    // Compile-time Error! Type mismatch so these cannot be compared:\n    // println!(\"_tuple1 == _tuple2 yields: {}\",\n    //           _tuple1 == _tuple2);\n\n    // Compile-time Error! Type mismatch so these cannot be compared:\n    // println!(\"_struct1 == _struct2 yields: {}\",\n    //           _struct1 == _struct2);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic DoubleDrop Trait in Rust\nDESCRIPTION: Creates a generic trait DoubleDrop<T> that implements a method to deallocate both the caller and an additional parameter. The example demonstrates trait generics, ownership concepts, and custom deallocation behavior using non-copyable types Empty and Null.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/generics/gen_trait.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// Non-copyable types.\nstruct Empty;\nstruct Null;\n\n// A trait generic over `T`.\ntrait DoubleDrop<T> {\n    // Define a method on the caller type which takes an\n    // additional single parameter `T` and does nothing with it.\n    fn double_drop(self, _: T);\n}\n\n// Implement `DoubleDrop<T>` for any generic parameter `T` and\n// caller `U`.\nimpl<T, U> DoubleDrop<T> for U {\n    // This method takes ownership of both passed arguments,\n    // deallocating both.\n    fn double_drop(self, _: T) {}\n}\n\nfn main() {\n    let empty = Empty;\n    let null  = Null;\n\n    // Deallocate `empty` and `null`.\n    empty.double_drop(null);\n\n    //empty;\n    //null;\n    // ^ TODO: Try uncommenting these lines.\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Type Inference with Vectors in Rust\nDESCRIPTION: Shows how Rust's compiler infers types for vectors and elements. The example creates a vector without explicit type annotation and demonstrates how pushing an element allows the compiler to deduce the vector's type as Vec<u8>.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/types/inference.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    // Because of the annotation, the compiler knows that `elem` has type u8.\n    let elem = 5u8;\n\n    // Create an empty vector (a growable array).\n    let mut vec = Vec::new();\n    // At this point the compiler doesn't know the exact type of `vec`, it\n    // just knows that it's a vector of something (`Vec<_>`).    \n\n    // Insert `elem` in the vector.\n    vec.push(elem);\n    // Aha! Now the compiler knows that `vec` is a vector of `u8`s (`Vec<u8>`)\n    // TODO ^ Try commenting out the `vec.push(elem)` line\n\n    println!(\"{:?}\", vec);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Rust Macro Using macro_rules!\nDESCRIPTION: Demonstrates how to create a simple macro named say_hello that takes no arguments and prints 'Hello!'. The example shows macro definition syntax and how to call the macro from the main function.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/macros.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// This is a simple macro named `say_hello`.\nmacro_rules! say_hello {\n    // `()` indicates that the macro takes no argument.\n    () => {\n        // The macro will expand into the contents of this block.\n        println!(\"Hello!\")\n    };\n}\n\nfn main() {\n    // This call will expand into `println!(\"Hello!\")`\n    say_hello!()\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Multiple Trait Bounds in Rust Generic Functions\nDESCRIPTION: Demonstrates two approaches to using multiple trait bounds: combining multiple bounds for a single type parameter using + and specifying bounds for different type parameters using commas. Shows practical usage with Debug and Display traits on string and collection types.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/generics/multi_bounds.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::fmt::{Debug, Display};\n\nfn compare_prints<T: Debug + Display>(t: &T) {\n    println!(\"Debug: `{:?}`\", t);\n    println!(\"Display: `{}`\", t);\n}\n\nfn compare_types<T: Debug, U: Debug>(t: &T, u: &U) {\n    println!(\"t: `{:?}`\", t);\n    println!(\"u: `{:?}`\", u);\n}\n\nfn main() {\n    let string = \"words\";\n    let array = [1, 2, 3];\n    let vec = vec![1, 2, 3];\n\n    compare_prints(&string);\n    //compare_prints(&array);\n    // TODO ^ Try uncommenting this.\n\n    compare_types(&array, &vec);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Match Guards with Temperature Enum in Rust\nDESCRIPTION: This snippet defines a Temperature enum and uses match guards to compare Celsius and Fahrenheit temperatures. It demonstrates how to add conditional checks to match arms for more precise pattern matching.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/flow_control/match/guard.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[allow(dead_code)]\nenum Temperature {\n    Celsius(i32),\n    Fahrenheit(i32),\n}\n\nfn main() {\n    let temperature = Temperature::Celsius(35);\n    // ^ TODO try different values for `temperature`\n\n    match temperature {\n        Temperature::Celsius(t) if t > 30 => println!(\"{C is above 30 Celsius\", t),\n        // The `if condition` part ^ is a guard\n        Temperature::Celsius(t) => println!(\"{C is equal to or below 30 Celsius\", t),\n\n        Temperature::Fahrenheit(t) if t > 86 => println!(\"{F is above 86 Fahrenheit\", t),\n        Temperature::Fahrenheit(t) => println!(\"{F is equal to or below 86 Fahrenheit\", t),\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Pattern Matching in Rust with match Statement\nDESCRIPTION: Example showing different pattern matching scenarios using Rust's match keyword. Demonstrates matching single values, multiple values using the | operator, inclusive ranges with ..=, and a catch-all case with _. Also shows how match can be used as an expression to assign values.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/flow_control/match.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let number = 13;\n    // TODO ^ Try different values for `number`\n\n    println!(\"Tell me about {}\", number);\n    match number {\n        // Match a single value\n        1 => println!(\"One!\"),\n        // Match several values\n        2 | 3 | 5 | 7 | 11 => println!(\"This is a prime\"),\n        // TODO ^ Try adding 13 to the list of prime values\n        // Match an inclusive range\n        13..=19 => println!(\"A teen\"),\n        // Handle the rest of cases\n        _ => println!(\"Ain't special\"),\n        // TODO ^ Try commenting out this catch-all arm\n    }\n\n    let boolean = true;\n    // Match is an expression too\n    let binary = match boolean {\n        // The arms of a match must cover all the possible values\n        false => 0,\n        true => 1,\n        // TODO ^ Try commenting out one of these arms\n    };\n\n    println!(\"{} -> {}\", boolean, binary);\n}\n```\n\n----------------------------------------\n\nTITLE: Using Result<()> in Rust Unit Tests\nDESCRIPTION: Shows how to use Result<()> as the return type in Rust unit tests, allowing the use of the ? operator for more concise error handling.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/testing/unit_testing.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn sqrt(number: f64) -> Result<f64, String> {\n    if number >= 0.0 {\n        Ok(number.powf(0.5))\n    } else {\n        Err(\"negative floats don't have square roots\".to_owned())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_sqrt() -> Result<(), String> {\n        let x = 4.0;\n        assert_eq!(sqrt(x)?.powf(2.0), x);\n        Ok(())\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: CSV Document Parsing with impl Trait\nDESCRIPTION: Simplified version of the CSV parser using impl Trait syntax instead of generic type parameter. This version provides cleaner syntax while maintaining the same functionality.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/trait/impl_trait.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn parse_csv_document(src: impl std::io::BufRead) -> std::io::Result<Vec<Vec<String>>> {\n    src.lines()\n        .map(|line| {\n            // For each line in the source\n            line.map(|line| {\n                // If the line was read successfully, process it, if not, return the error\n                line.split(',') // Split the line separated by commas\n                    .map(|entry| String::from(entry.trim())) // Remove leading and trailing whitespace\n                    .collect() // Collect all strings in a row into a Vec<String>\n            })\n        })\n        .collect() // Collect all lines into a Vec<Vec<String>>\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing Standard Bounds with Where Clauses in Rust\nDESCRIPTION: This example shows how using a where clause can improve readability by separating generic type declarations from their bounds. The snippet demonstrates the same implementation written both ways for comparison.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/generics/where.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nimpl <A: TraitB + TraitC, D: TraitE + TraitF> MyTrait<A, D> for YourType {}\n\n// Expressing bounds with a `where` clause\nimpl <A, D> MyTrait<A, D> for YourType where\n    A: TraitB + TraitC,\n    D: TraitE + TraitF {}\n```\n\n----------------------------------------\n\nTITLE: Parsing Strings to Numbers in Rust\nDESCRIPTION: This example shows two ways to parse strings into numbers using Rust's parse function: explicit type annotation and the turbofish syntax. Both methods convert string literals to i32 integers.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/conversion/string.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let parsed: i32 = \"5\".parse().unwrap();\n    let turbo_parsed = \"10\".parse::<i32>().unwrap();\n\n    let sum = parsed + turbo_parsed;\n    println!(\"Sum: {:?}\", sum);\n}\n```\n\n----------------------------------------\n\nTITLE: Converting to String using Display Trait Implementation in Rust\nDESCRIPTION: This code demonstrates how to implement the fmt::Display trait for a custom Circle struct to enable string conversion. The implementation allows the struct to be converted to a string with to_string() method, automatically provided by the ToString trait.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/conversion/string.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::fmt;\n\nstruct Circle {\n    radius: i32\n}\n\nimpl fmt::Display for Circle {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"Circle of radius {}\", self.radius)\n    }\n}\n\nfn main() {\n    let circle = Circle { radius: 6 };\n    println!(\"{}\", circle.to_string());\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Rust Library Structure\nDESCRIPTION: Demonstrates creating a Rust library with public and private functions. Shows how to use public functions for external access and private functions for internal implementation details.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/crates/lib.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub fn public_function() {\n    println!(\"called rary's `public_function()`\");\n}\n\nfn private_function() {\n    println!(\"called rary's `private_function()`\");\n}\n\npub fn indirect_access() {\n    print!(\"called rary's `indirect_access()`, that\\n> \");\n\n    private_function();\n}\n```\n\n----------------------------------------\n\nTITLE: Comprehensive Closure Examples in Rust\nDESCRIPTION: Illustrates various aspects of closures in Rust, including annotation, type inference, capturing outer variables, and different syntax forms. It also demonstrates closure invocation and type restrictions.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/fn/closures.md#2025-04-21_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nfn main() {\n    let outer_var = 42;\n    \n    // A regular function can't refer to variables in the enclosing environment\n    //fn function(i: i32) -> i32 { i + outer_var }\n    // TODO: uncomment the line above and see the compiler error. The compiler\n    // suggests that we define a closure instead.\n\n    // Closures are anonymous, here we are binding them to references.\n    // Annotation is identical to function annotation but is optional\n    // as are the `{}` wrapping the body. These nameless functions\n    // are assigned to appropriately named variables.\n    let closure_annotated = |i: i32| -> i32 { i + outer_var };\n    let closure_inferred  = |i     |          i + outer_var  ;\n\n    // Call the closures.\n    println!(\"closure_annotated: {}\", closure_annotated(1));\n    println!(\"closure_inferred: {}\", closure_inferred(1));\n    // Once closure's type has been inferred, it cannot be inferred again with another type.\n    //println!(\"cannot reuse closure_inferred with another type: {}\", closure_inferred(42i64));\n    // TODO: uncomment the line above and see the compiler error.\n\n    // A closure taking no arguments which returns an `i32`.\n    // The return type is inferred.\n    let one = || 1;\n    println!(\"closure returning one: {}\", one());\n\n}\n```\n\n----------------------------------------\n\nTITLE: Explicit Lifetime Annotation Examples in Rust\nDESCRIPTION: A comprehensive example demonstrating explicit lifetime annotation usage. Includes a function that takes references with different lifetimes, a function showing lifetime constraint failures, and a main function showing proper borrowing patterns.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/scope/lifetime/explicit.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n// `print_refs` takes two references to `i32` which have different\n// lifetimes `'a` and `'b`. These two lifetimes must both be at\n// least as long as the function `print_refs`.\nfn print_refs<'a, 'b>(x: &'a i32, y: &'b i32) {\n    println!(\"x is {} and y is {}\", x, y);\n}\n\n// A function which takes no arguments, but has a lifetime parameter `'a`.\nfn failed_borrow<'a>() {\n    let _x = 12;\n\n    // ERROR: `_x` does not live long enough\n    let _y: &'a i32 = &_x;\n    // Attempting to use the lifetime `'a` as an explicit type annotation \n    // inside the function will fail because the lifetime of `&_x` is shorter\n    // than that of `_y`. A short lifetime cannot be coerced into a longer one.\n}\n\nfn main() {\n    // Create variables to be borrowed below.\n    let (four, nine) = (4, 9);\n    \n    // Borrows (`&`) of both variables are passed into the function.\n    print_refs(&four, &nine);\n    // Any input which is borrowed must outlive the borrower. \n    // In other words, the lifetime of `four` and `nine` must \n    // be longer than that of `print_refs`.\n    \n    failed_borrow();\n    // `failed_borrow` contains no references to force `'a` to be \n    // longer than the lifetime of the function, but `'a` is longer.\n    // Because the lifetime is never constrained, it defaults to `'static`.\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Struct Visibility in Rust\nDESCRIPTION: This code snippet illustrates the concepts of struct visibility in Rust. It defines public structs with both public and private fields, shows how to construct and access them, and demonstrates the use of a public constructor for a struct with private fields.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/mod/struct_visibility.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nmod my {\n    // A public struct with a public field of generic type `T`\n    pub struct OpenBox<T> {\n        pub contents: T,\n    }\n\n    // A public struct with a private field of generic type `T`\n    pub struct ClosedBox<T> {\n        contents: T,\n    }\n\n    impl<T> ClosedBox<T> {\n        // A public constructor method\n        pub fn new(contents: T) -> ClosedBox<T> {\n            ClosedBox {\n                contents: contents,\n            }\n        }\n    }\n}\n\nfn main() {\n    // Public structs with public fields can be constructed as usual\n    let open_box = my::OpenBox { contents: \"public information\" };\n\n    // and their fields can be normally accessed.\n    println!(\"The open box contains: {}\", open_box.contents);\n\n    // Public structs with private fields cannot be constructed using field names.\n    // Error! `ClosedBox` has private fields\n    //let closed_box = my::ClosedBox { contents: \"classified information\" };\n    // TODO ^ Try uncommenting this line\n\n    // However, structs with private fields can be created using\n    // public constructors\n    let _closed_box = my::ClosedBox::new(\"classified information\");\n\n    // and the private fields of a public struct cannot be accessed.\n    // Error! The `contents` field is private\n    //println!(\"The closed box contains: {}\", _closed_box.contents);\n    // TODO ^ Try uncommenting this line\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing FromStr Trait for Custom Types in Rust\nDESCRIPTION: This code shows how to implement the FromStr trait for a custom Circle struct, enabling parsing strings into Circle instances. The implementation handles parsing the radius from a string, including error handling and trimming whitespace.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/conversion/string.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse std::num::ParseIntError;\nuse std::str::FromStr;\n\n#[derive(Debug)]\nstruct Circle {\n    radius: i32,\n}\n\nimpl FromStr for Circle {\n    type Err = ParseIntError;\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        match s.trim().parse() {\n            Ok(num) => Ok(Circle{ radius: num }),\n            Err(e) => Err(e),\n        }\n    }\n}\n\nfn main() {\n    let radius = \"    3 \";\n    let circle: Circle = radius.parse().unwrap();\n    println!(\"{:?}\", circle);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing panic-based Error Handling in Rust\nDESCRIPTION: This code snippet demonstrates the use of panic for error handling in a drink function. It shows how panic is triggered when a specific condition is met, causing the program to terminate and preventing further execution.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/error/panic.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn drink(beverage: &str) {\n    // You shouldn't drink too many sugary beverages.\n    if beverage == \"lemonade\" { panic!(\"AAAaaaaa!!!!\"); }\n\n    println!(\"Some refreshing {} is all I need.\", beverage);\n}\n\nfn main() {\n    drink(\"water\");\n    drink(\"lemonade\");\n    drink(\"still water\");\n}\n```\n\n----------------------------------------\n\nTITLE: String Literals and Escape Sequences in Rust\nDESCRIPTION: This code demonstrates various ways to use escape sequences in Rust string literals, including hexadecimal byte escapes, Unicode code points, and multi-line strings with escaped line breaks and indentation.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/std/str.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    // You can use escapes to write bytes by their hexadecimal values...\n    let byte_escape = \"I'm writing \\x52\\x75\\x73\\x74!\";\n    println!(\"What are you doing\\x3F (\\\\x3F means ?) {}\", byte_escape);\n\n    // ...or Unicode code points.\n    let unicode_codepoint = \"\\u{211D}\";\n    let character_name = \"\\\"DOUBLE-STRUCK CAPITAL R\\\"\";\n\n    println!(\"Unicode character {} (U+211D) is called {}\",\n                unicode_codepoint, character_name );\n\n\n    let long_string = \"String literals\n                        can span multiple lines.\n                        The linebreak and indentation here ->\\                        <- can be escaped too!\";\n    println!(\"{}\", long_string);\n}\n```\n\n----------------------------------------\n\nTITLE: Regular Function with Unit Return Type in Rust\nDESCRIPTION: An example showing a regular Rust function that returns the unit type (). This is contrasted with diverging functions to show that it returns control to the caller.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/fn/diverging.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn some_fn() {\n    ()\n}\n\nfn main() {\n    let _a: () = some_fn();\n    println!(\"This function returns and you can see this line.\");\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Trait Inheritance with Rust Supertraits\nDESCRIPTION: Shows how to create a hierarchy of traits using supertraits. Demonstrates how to define traits that inherit from multiple parent traits, including Person as a supertrait of Student, and CompSciStudent inheriting from both Programmer and Student traits.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/trait/supertraits.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait Person {\n    fn name(&self) -> String;\n}\n\n// Person is a supertrait of Student.\n// Implementing Student requires you to also impl Person.\ntrait Student: Person {\n    fn university(&self) -> String;\n}\n\ntrait Programmer {\n    fn fav_language(&self) -> String;\n}\n\n// CompSciStudent (computer science student) is a subtrait of both Programmer \n// and Student. Implementing CompSciStudent requires you to impl both supertraits.\ntrait CompSciStudent: Programmer + Student {\n    fn git_username(&self) -> String;\n}\n\nfn comp_sci_student_greeting(student: &dyn CompSciStudent) -> String {\n    format!(\n        \"My name is {} and I attend {}. My favorite language is {}. My Git username is {}\",\n        student.name(),\n        student.university(),\n        student.fav_language(),\n        student.git_username()\n    )\n}\n\nfn main() {}\n```\n\n----------------------------------------\n\nTITLE: Defining a Trait with Associated Types in Rust\nDESCRIPTION: This snippet demonstrates how to define a trait using associated types. It shows the syntax for declaring associated types within a trait and how to use them in trait methods.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/generics/assoc_items/types.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait Contains {\n    type A;\n    type B;\n\n    fn contains(&self, _: &Self::A, _: &Self::B) -> bool;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing and Disambiguating Overlapping Traits in Rust\nDESCRIPTION: This code snippet demonstrates how to implement multiple traits with the same method name for a single struct, and how to disambiguate between these methods using Fully Qualified Syntax. It defines UsernameWidget and AgeWidget traits, both with a 'get' method, and implements them for a Form struct.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/trait/disambiguating.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait UsernameWidget {\n    // Get the selected username out of this widget\n    fn get(&self) -> String;\n}\n\ntrait AgeWidget {\n    // Get the selected age out of this widget\n    fn get(&self) -> u8;\n}\n\n// A form with both a UsernameWidget and an AgeWidget\nstruct Form {\n    username: String,\n    age: u8,\n}\n\nimpl UsernameWidget for Form {\n    fn get(&self) -> String {\n        self.username.clone()\n    }\n}\n\nimpl AgeWidget for Form {\n    fn get(&self) -> u8 {\n        self.age\n    }\n}\n\nfn main() {\n    let form = Form {\n        username: \"rustacean\".to_owned(),\n        age: 28,\n    };\n\n    // If you uncomment this line, you'll get an error saying\n    // \"multiple `get` found\". Because, after all, there are multiple methods\n    // named `get`.\n    // println!(\"{}\", form.get());\n\n    let username = <Form as UsernameWidget>::get(&form);\n    assert_eq!(\"rustacean\".to_owned(), username);\n    let age = <Form as AgeWidget>::get(&form);\n    assert_eq!(28, age);\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Example of Generic and Non-Generic Implementations in Rust\nDESCRIPTION: A practical example showing how to implement methods for both generic and non-generic structs. Demonstrates how to access values from these structs using the implemented methods and how to use them in a main function.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/generics/impl.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct Val {\n    val: f64,\n}\n\nstruct GenVal<T> {\n    gen_val: T,\n}\n\n// impl of Val\nimpl Val {\n    fn value(&self) -> &f64 {\n        &self.val\n    }\n}\n\n// impl of GenVal for a generic type `T`\nimpl<T> GenVal<T> {\n    fn value(&self) -> &T {\n        &self.gen_val\n    }\n}\n\nfn main() {\n    let x = Val { val: 3.0 };\n    let y = GenVal { gen_val: 3i32 };\n\n    println!(\"{}, {}\", x.value(), y.value());\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Newtype Pattern for Age Verification in Rust\nDESCRIPTION: This snippet demonstrates how to use the newtype idiom to create type-safe age representations with Years and Days types. It includes conversion methods between types and shows compile-time enforcement of type checking for an age verification function.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/generics/new_types.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Years(i64);\n\nstruct Days(i64);\n\nimpl Years {\n    pub fn to_days(&self) -> Days {\n        Days(self.0 * 365)\n    }\n}\n\nimpl Days {\n    /// truncates partial years\n    pub fn to_years(&self) -> Years {\n        Years(self.0 / 365)\n    }\n}\n\nfn is_adult(age: &Years) -> bool {\n    age.0 >= 18\n}\n\nfn main() {\n    let age = Years(25);\n    let age_days = age.to_days();\n    println!(\"Is an adult? {}\", is_adult(&age));\n    println!(\"Is an adult? {}\", is_adult(&age_days.to_years()));\n    // println!(\"Is an adult? {}\", is_adult(&age_days));\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Rust Macros with Different Designators\nDESCRIPTION: Demonstrates two macro implementations: create_function! which generates functions using the ident designator, and print_result! which evaluates expressions using the expr designator. Shows how to use stringify! macro and handle different types of macro arguments.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/macros/designators.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nmacro_rules! create_function {\n    // This macro takes an argument of designator `ident` and\n    // creates a function named `$func_name`.\n    // The `ident` designator is used for variable/function names.\n    ($func_name:ident) => {\n        fn $func_name() {\n            // The `stringify!` macro converts an `ident` into a string.\n            println!(\"You called {:?}()\",\n                     stringify!($func_name));\n        }\n    };\n}\n\n// Create functions named `foo` and `bar` with the above macro.\ncreate_function!(foo);\ncreate_function!(bar);\n\nmacro_rules! print_result {\n    // This macro takes an expression of type `expr` and prints\n    // it as a string along with its result.\n    // The `expr` designator is used for expressions.\n    ($expression:expr) => {\n        // `stringify!` will convert the expression *as it is* into a string.\n        println!(\"{:?} = {:?}\",\n                 stringify!($expression),\n                 $expression);\n    };\n}\n\nfn main() {\n    foo();\n    bar();\n\n    print_result!(1u32 + 1);\n\n    // Recall that blocks are expressions too!\n    print_result!({\n        let x = 1u32;\n\n        x * x + 2 * x - 1\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying Different Types of Dependencies in Cargo.toml\nDESCRIPTION: This snippet demonstrates how to specify different types of dependencies in a Cargo.toml file, including crates from crates.io, Git repositories, and local filesystem paths.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/cargo/deps.md#2025-04-21_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\n[package]\nname = \"foo\"\nversion = \"0.1.0\"\nauthors = [\"mark\"]\n\n[dependencies]\nclap = \"2.27.1\" # from crates.io\nrand = { git = \"https://github.com/rust-lang-nursery/rand\" } # from online repo\nbar = { path = \"../bar\" } # from a path in the local filesystem\n```\n\n----------------------------------------\n\nTITLE: Implementing FizzBuzz using a while loop in Rust\nDESCRIPTION: This example implements the FizzBuzz problem using a while loop in Rust. It iterates from 1 to 100, printing 'fizz' for multiples of 3, 'buzz' for multiples of 5, 'fizzbuzz' for multiples of both, and the number itself otherwise.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/flow_control/while.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    // A counter variable\n    let mut n = 1;\n\n    // Loop while `n` is less than 101\n    while n < 101 {\n        if n % 15 == 0 {\n            println!(\"fizzbuzz\");\n        } else if n % 3 == 0 {\n            println!(\"fizz\");\n        } else if n % 5 == 0 {\n            println!(\"buzz\");\n        } else {\n            println!(\"{}\", n);\n        }\n\n        // Increment counter\n        n += 1;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Debug Trait for Custom Structures in Rust\nDESCRIPTION: This snippet demonstrates how to make custom structures printable using the fmt::Debug trait. It shows an unprintable structure and a printable one using the #[derive(Debug)] attribute.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/hello/print/print_debug.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// This structure cannot be printed either with `fmt::Display` or\n// with `fmt::Debug`.\nstruct UnPrintable(i32);\n\n// The `derive` attribute automatically creates the implementation\n// required to make this `struct` printable with `fmt::Debug`.\n#[derive(Debug)]\nstruct DebugPrintable(i32);\n```\n\n----------------------------------------\n\nTITLE: Using Fn Trait Bound with Closures that Capture Environment in Rust\nDESCRIPTION: A complete example showing how to create, capture variables, and use closures with generic functions. It demonstrates capturing a variable 'x' into a closure, then passing that closure to a function that requires the Fn trait.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/fn/closures/anonymity.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// `F` must implement `Fn` for a closure which takes no\n// inputs and returns nothing - exactly what is required\n// for `print`.\nfn apply<F>(f: F) where\n    F: Fn() {\n    f();\n}\n\nfn main() {\n    let x = 7;\n\n    // Capture `x` into an anonymous type and implement\n    // `Fn` for it. Store it in `print`.\n    let print = || println!(\"{}\", x);\n\n    apply(print);\n}\n```\n\n----------------------------------------\n\nTITLE: Using Process Pipes in Rust with Command Execution\nDESCRIPTION: Demonstrates how to spawn a child process (wc/powershell), write data to its stdin, and read the response from stdout. The example uses a pangram as input text and handles both Unix and Windows environments. It showcases proper pipe handling including important cleanup considerations.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/std_misc/process/pipe.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::io::prelude::*;\nuse std::process::{Command, Stdio};\n\nstatic PANGRAM: &'static str =\n\"the quick brown fox jumps over the lazy dog\\n\";\n\nfn main() {\n    // Spawn the `wc` command\n    let mut cmd = if cfg!(target_family = \"windows\") {\n        let mut cmd = Command::new(\"powershell\");\n        cmd.arg(\"-Command\").arg(\"$input | Measure-Object -Line -Word -Character\");\n        cmd\n    } else {\n        Command::new(\"wc\")\n    };\n    let process = match cmd\n                                .stdin(Stdio::piped())\n                                .stdout(Stdio::piped())\n                                .spawn() {\n        Err(why) => panic!(\"couldn't spawn wc: {}\", why),\n        Ok(process) => process,\n    };\n\n    // Write a string to the `stdin` of `wc`.\n    //\n    // `stdin` has type `Option<ChildStdin>`, but since we know this instance\n    // must have one, we can directly `unwrap` it.\n    match process.stdin.unwrap().write_all(PANGRAM.as_bytes()) {\n        Err(why) => panic!(\"couldn't write to wc stdin: {}\", why),\n        Ok(_) => println!(\"sent pangram to wc\"),\n    }\n\n    // Because `stdin` does not live after the above calls, it is `drop`ed,\n    // and the pipe is closed.\n    //\n    // This is very important, otherwise `wc` wouldn't start processing the\n    // input we just sent.\n\n    // The `stdout` field also has type `Option<ChildStdout>` so must be unwrapped.\n    let mut s = String::new();\n    match process.stdout.unwrap().read_to_string(&mut s) {\n        Err(why) => panic!(\"couldn't read wc stdout: {}\", why),\n        Ok(_) => print!(\"wc responded with:\\n{}\", s),\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Writing to a File in Rust\nDESCRIPTION: This snippet demonstrates how to create a new file, write a predefined string to it, and handle potential errors. It uses the std::fs::File and std::io::prelude::* modules for file operations.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/std_misc/file/create.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstatic LOREM_IPSUM: &str =\n    \"Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod\ntempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,\nquis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo\nconsequat. Duis aute irure dolor in reprehenderit in voluptate velit esse\ncillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non\nproident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n\";\n\nuse std::fs::File;\nuse std::io::prelude::*;\nuse std::path::Path;\n\nfn main() {\n    let path = Path::new(\"lorem_ipsum.txt\");\n    let display = path.display();\n\n    // Open a file in write-only mode, returns `io::Result<File>`\n    let mut file = match File::create(&path) {\n        Err(why) => panic!(\"couldn't create {}: {}\", display, why),\n        Ok(file) => file,\n    };\n\n    // Write the `LOREM_IPSUM` string to `file`, returns `io::Result<()>`\n    match file.write_all(LOREM_IPSUM.as_bytes()) {\n        Err(why) => panic!(\"couldn't write to {}: {}\", display, why),\n        Ok(_) => println!(\"successfully wrote to {}\", display),\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Failing the Entire Operation with collect in Rust\nDESCRIPTION: Uses collect to convert a vector of Results into a Result containing a vector, which fails the entire operation if any parsing error occurs.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/error/iter_result.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let strings = vec![\"tofu\", \"93\", \"18\"];\n    let numbers: Result<Vec<_>, _> = strings\n        .into_iter()\n        .map(|s| s.parse::<i32>())\n        .collect();\n    println!(\"Results: {:?}\", numbers);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Type Aliases in Rust\nDESCRIPTION: This code snippet demonstrates how to create type aliases for u64 and use them in a function. It also highlights that type aliases don't provide extra type safety as they are not new types.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/types/alias.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// `NanoSecond`, `Inch`, and `U64` are new names for `u64`.\ntype NanoSecond = u64;\ntype Inch = u64;\ntype U64 = u64;\n\nfn main() {\n    // `NanoSecond` = `Inch` = `U64` = `u64`.\n    let nanoseconds: NanoSecond = 5 as u64;\n    let inches: Inch = 2 as U64;\n\n    // Note that type aliases *don't* provide any extra type safety, because\n    // aliases are *not* new types\n    println!(\"{} nanoseconds + {} inches = {} unit?\",\n             nanoseconds,\n             inches,\n             nanoseconds + inches);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Hello World Program in Rust\nDESCRIPTION: A basic Rust program that demonstrates the main function and println! macro usage. The code shows how to output text to the console using the println! macro within the main function.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/hello.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// This is a comment, and is ignored by the compiler.\n// You can test this code by clicking the \"Run\" button over there ->\n// or if you prefer to use your keyboard, you can use the \"Ctrl + Enter\"\n// shortcut.\n\n// This code is editable, feel free to hack it!\n// You can always return to the original code by clicking the \"Reset\" button ->\n\n// This is the main function.\nfn main() {\n    // Statements here are executed when the compiled binary is called.\n\n    // Print text to the console.\n    println!(\"Hello World!\");\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Type Casting in Rust\nDESCRIPTION: This code snippet illustrates various type casting scenarios in Rust, including conversions between integer types, floating-point to integer conversions, and handling of overflow cases. It also demonstrates saturating casts introduced in Rust 1.45 and unsafe methods for unchecked conversions.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/types/cast.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// Suppress all warnings from casts which overflow.\n#![allow(overflowing_literals)]\n\nfn main() {\n    let decimal = 65.4321_f32;\n\n    // Error! No implicit conversion\n    let integer: u8 = decimal;\n    // FIXME ^ Comment out this line\n\n    // Explicit conversion\n    let integer = decimal as u8;\n    let character = integer as char;\n\n    // Error! There are limitations in conversion rules.\n    // A float cannot be directly converted to a char.\n    let character = decimal as char;\n    // FIXME ^ Comment out this line\n\n    println!(\"Casting: {} -> {} -> {}\", decimal, integer, character);\n\n    // when casting any value to an unsigned type, T,\n    // T::MAX + 1 is added or subtracted until the value\n    // fits into the new type\n\n    // 1000 already fits in a u16\n    println!(\"1000 as a u16 is: {}\", 1000 as u16);\n\n    // 1000 - 256 - 256 - 256 = 232\n    // Under the hood, the first 8 least significant bits (LSB) are kept,\n    // while the rest towards the most significant bit (MSB) get truncated.\n    println!(\"1000 as a u8 is : {}\", 1000 as u8);\n    // -1 + 256 = 255\n    println!(\"  -1 as a u8 is : {}\", (-1i8) as u8);\n\n    // For positive numbers, this is the same as the modulus\n    println!(\"1000 mod 256 is : {}\", 1000 % 256);\n\n    // When casting to a signed type, the (bitwise) result is the same as\n    // first casting to the corresponding unsigned type. If the most significant\n    // bit of that value is 1, then the value is negative.\n\n    // Unless it already fits, of course.\n    println!(\" 128 as a i16 is: {}\", 128 as i16);\n\n    // In boundary case 128 value in 8-bit two's complement representation is -128\n    println!(\" 128 as a i8 is : {}\", 128 as i8);\n\n    // repeating the example above\n    // 1000 as u8 -> 232\n    println!(\"1000 as a u8 is : {}\", 1000 as u8);\n    // and the value of 232 in 8-bit two's complement representation is -24\n    println!(\" 232 as a i8 is : {}\", 232 as i8);\n\n    // Since Rust 1.45, the `as` keyword performs a *saturating cast*\n    // when casting from float to int. If the floating point value exceeds\n    // the upper bound or is less than the lower bound, the returned value\n    // will be equal to the bound crossed.\n\n    // 300.0 as u8 is 255\n    println!(\" 300.0 as u8 is : {}\", 300.0_f32 as u8);\n    // -100.0 as u8 is 0\n    println!(\"-100.0 as u8 is : {}\", -100.0_f32 as u8);\n    // nan as u8 is 0\n    println!(\"   nan as u8 is : {}\", f32::NAN as u8);\n\n    // This behavior incurs a small runtime cost and can be avoided\n    // with unsafe methods, however the results might overflow and\n    // return **unsound values**. Use these methods wisely:\n    unsafe {\n        // 300.0 as u8 is 44\n        println!(\" 300.0 as u8 is : {}\", 300.0_f32.to_int_unchecked::<u8>());\n        // -100.0 as u8 is 156\n        println!(\"-100.0 as u8 is : {}\", (-100.0_f32).to_int_unchecked::<u8>());\n        // nan as u8 is 0\n        println!(\"   nan as u8 is : {}\", f32::NAN.to_int_unchecked::<u8>());\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing find_min! Macro with Repetition in Rust\nDESCRIPTION: This macro demonstrates the use of repetition operators in Rust macros. It implements a find_min! macro that recursively determines the minimum value from a variable number of arguments. The macro uses base case pattern matching for a single argument and repetition syntax for multiple arguments.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/macros/repeat.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// `find_min!` will calculate the minimum of any number of arguments.\nmacro_rules! find_min {\n    // Base case:\n    ($x:expr) => ($x);\n    // `$x` followed by at least one `$y,`\n    ($x:expr, $($y:expr),+) => (\n        // Call `find_min!` on the tail `$y`\n        std::cmp::min($x, find_min!($($y),+))\n    )\n}\n\nfn main() {\n    println!(\"{}\", find_min!(1));\n    println!(\"{}\", find_min!(1 + 2, 2));\n    println!(\"{}\", find_min!(5, 2 * 3, 4));\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating or() Method for Option Unpacking in Rust\nDESCRIPTION: This snippet shows how to use the or() method to chain fallback options. It demonstrates eager evaluation and how it affects variable movement.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/error/option_unwrap/defaults.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Debug)] \nenum Fruit { Apple, Orange, Banana, Kiwi, Lemon }\n\nfn main() {\n    let apple = Some(Fruit::Apple);\n    let orange = Some(Fruit::Orange);\n    let no_fruit: Option<Fruit> = None;\n\n    let first_available_fruit = no_fruit.or(orange).or(apple);\n    println!(\"first_available_fruit: {:?}\", first_available_fruit);\n    // first_available_fruit: Some(Orange)\n\n    // `or` moves its argument.\n    // In the example above, `or(orange)` returned a `Some`, so `or(apple)` was not invoked.\n    // But the variable named `apple` has been moved regardless, and cannot be used anymore.\n    // println!(\"Variable apple was moved, so this line won't compile: {:?}\", apple);\n    // TODO: uncomment the line above to see the compiler error\n }\n```\n\n----------------------------------------\n\nTITLE: Opening and Reading Files in Rust\nDESCRIPTION: Shows how to open a file in read-only mode, read its contents into a string, and handle potential errors using match expressions. The example demonstrates proper resource management with automatic file closing through Rust's Drop trait.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/std_misc/file/open.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::fs::File;\nuse std::io::prelude::*;\nuse std::path::Path;\n\nfn main() {\n    // Create a path to the desired file\n    let path = Path::new(\"hello.txt\");\n    let display = path.display();\n\n    // Open the path in read-only mode, returns `io::Result<File>`\n    let mut file = match File::open(&path) {\n        Err(why) => panic!(\"couldn't open {}: {}\", display, why),\n        Ok(file) => file,\n    };\n\n    // Read the file contents into a string, returns `io::Result<usize>`\n    let mut s = String::new();\n    match file.read_to_string(&mut s) {\n        Err(why) => panic!(\"couldn't read {}: {}\", display, why),\n        Ok(_) => print!(\"{} contains:\\n{}\", display, s),\n    }\n\n    // `file` goes out of scope, and the \"hello.txt\" file gets closed\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Simple Calculator DSL with Rust Macros\nDESCRIPTION: A macro that defines a small calculator DSL to evaluate expressions and print results. The macro forces the types to be unsigned integers and uses stringify to display the original expression alongside the result.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/macros/dsl.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nmacro_rules! calculate {\n    (eval $e:expr) => {\n        {\n            let val: usize = $e; // Force types to be unsigned integers\n            println!(\"{} = {}\", stringify!{$e}, val);\n        }\n    };\n}\n\nfn main() {\n    calculate! {\n        eval 1 + 2 // hehehe `eval` is _not_ a Rust keyword!\n    }\n\n    calculate! {\n        eval (1 + 2) * (3 / 4)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Labeled Break Statements in Nested Rust Loops\nDESCRIPTION: Example showing how to break out of nested loops using labeled break statements. The code demonstrates breaking from an inner loop to exit a specific outer loop using the 'label syntax. Contains commented alternatives showing different break behaviors.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/flow_control/loop/nested.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![allow(unreachable_code, unused_labels)]\n\nfn main() {\n    'outer: loop {\n        println!(\"Entered the outer loop\");\n\n        'inner: loop {\n            println!(\"Entered the inner loop\");\n\n            // This would break only the inner loop\n            //break;\n\n            // This breaks the outer loop\n            break 'outer;\n        }\n\n        println!(\"This point will never be reached\");\n    }\n\n    println!(\"Exited the outer loop\");\n}\n```\n\n----------------------------------------\n\nTITLE: CSV Document Parsing with Generic Type\nDESCRIPTION: Implementation of a CSV parser using generic type parameter with BufRead trait bound. This version explicitly shows the generic type parameter in the function signature.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/trait/impl_trait.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn parse_csv_document<R: std::io::BufRead>(src: R) -> std::io::Result<Vec<Vec<String>>> {\n    src.lines()\n        .map(|line| {\n            // For each line in the source\n            line.map(|line| {\n                // If the line was read successfully, process it, if not, return the error\n                line.split(',') // Split the line separated by commas\n                    .map(|entry| String::from(entry.trim())) // Remove leading and trailing whitespace\n                    .collect() // Collect all strings in a row into a Vec<String>\n            })\n        })\n        .collect() // Collect all lines into a Vec<Vec<String>>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing If-Else Conditional Logic in Rust\nDESCRIPTION: Shows how to use if-else statements in Rust, demonstrating both basic conditional branching and using if-else as an expression to assign values. The example includes number comparison and mathematical operations with proper type handling.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/flow_control/if_else.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let n = 5;\n\n    if n < 0 {\n        print!(\"{} is negative\", n);\n    } else if n > 0 {\n        print!(\"{} is positive\", n);\n    } else {\n        print!(\"{} is zero\", n);\n    }\n\n    let big_n =\n        if n < 10 && n > -10 {\n            println!(\", and is a small number, increase ten-fold\");\n\n            // This expression returns an `i32`.\n            10 * n\n        } else {\n            println!(\", and is a big number, halve the number\");\n\n            // This expression must return an `i32` as well.\n            n / 2\n            // TODO ^ Try suppressing this expression with a semicolon.\n        };\n    //   ^ Don't forget to put a semicolon here! All `let` bindings need it.\n\n    println!(\"{} -> {}\", n, big_n);\n}\n```\n\n----------------------------------------\n\nTITLE: Destructuring Arrays and Slices with Pattern Matching in Rust\nDESCRIPTION: This example demonstrates various pattern matching techniques for arrays and slices in Rust. It showcases binding specific elements to variables, ignoring elements with _ placeholder, capturing remaining elements with .. rest pattern, binding slices to variables using @ syntax, and combining these approaches in complex patterns.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/flow_control/match/destructuring/destructure_slice.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    // Try changing the values in the array, or make it a slice!\n    let array = [1, -2, 6];\n\n    match array {\n        // Binds the second and the third elements to the respective variables\n        [0, second, third] =>\n            println!(\"array[0] = 0, array[1] = {}, array[2] = {}\", second, third),\n\n        // Single values can be ignored with _\n        [1, _, third] => println!(\n            \"array[0] = 1, array[2] = {} and array[1] was ignored\",\n            third\n        ),\n\n        // You can also bind some and ignore the rest\n        [-1, second, ..] => println!(\n            \"array[0] = -1, array[1] = {} and all the other ones were ignored\",\n            second\n        ),\n        // The code below would not compile\n        // [-1, second] => ...\n\n        // Or store them in another array/slice (the type depends on\n        // that of the value that is being matched against)\n        [3, second, tail @ ..] => println!(\n            \"array[0] = 3, array[1] = {} and the other elements were {:?}\",\n            second, tail\n        ),\n\n        // Combining these patterns, we can, for example, bind the first and\n        // last values, and store the rest of them in a single array\n        [first, middle @ .., last] => println!(\n            \"array[0] = {}, middle = {:?}, array[2] = {}\",\n            first, middle, last\n        ),\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using get_or_insert_with() for Lazy Evaluation and In-Place Modification in Rust\nDESCRIPTION: This example demonstrates the use of get_or_insert_with() to modify an Option in place using a closure. It shows lazy evaluation and how it affects the original value only when necessary.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/error/option_unwrap/defaults.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Debug)] \nenum Fruit { Apple, Orange, Banana, Kiwi, Lemon }\n\nfn main() {\n    let mut my_fruit: Option<Fruit> = None;\n    let get_lemon_as_fallback = || {\n        println!(\"Providing lemon as fallback\");\n        Fruit::Lemon\n    };\n    let first_available_fruit = my_fruit\n        .get_or_insert_with(get_lemon_as_fallback);\n    println!(\"first_available_fruit is: {:?}\", first_available_fruit);\n    println!(\"my_fruit is: {:?}\", my_fruit);\n    // Providing lemon as fallback\n    // first_available_fruit is: Lemon\n    // my_fruit is: Some(Lemon)\n\n    // If the Option has a value, it is left unchanged, and the closure is not invoked\n    let mut my_apple = Some(Fruit::Apple);\n    let should_be_apple = my_apple.get_or_insert_with(get_lemon_as_fallback);\n    println!(\"should_be_apple is: {:?}\", should_be_apple);\n    println!(\"my_apple is unchanged: {:?}\", my_apple);\n    // The output is a follows. Note that the closure `get_lemon_as_fallback` is not invoked\n    // should_be_apple is: Apple\n    // my_apple is unchanged: Some(Apple)\n}\n```\n\n----------------------------------------\n\nTITLE: Using @ Binding for Age Classification in Rust\nDESCRIPTION: This example demonstrates using the @ sigil to bind values in a match expression while also applying range conditions. The function returns an age value that is matched against different ranges, with the @ operator binding the value to 'n' so it can be used in the expression body.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/flow_control/match/binding.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// A function `age` which returns a `u32`.\nfn age() -> u32 {\n    15\n}\n\nfn main() {\n    println!(\"Tell me what type of person you are\");\n\n    match age() {\n        0             => println!(\"I haven't celebrated my first birthday yet\"),\n        // Could `match` 1 ..= 12 directly but then what age\n        // would the child be? Instead, bind to `n` for the\n        // sequence of 1 ..= 12. Now the age can be reported.\n        n @ 1  ..= 12 => println!(\"I'm a child of age {:?}\", n),\n        n @ 13 ..= 19 => println!(\"I'm a teen of age {:?}\", n),\n        // Nothing bound. Return the result.\n        n             => println!(\"I'm an old person of age {:?}\", n),\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Type Aliases for Long Enum Names in Rust\nDESCRIPTION: Shows how to create a type alias for an enum with a long name to make it more convenient to use. This example creates an alias 'Operations' for a verbose enum name, allowing more concise code when referencing enum variants.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/custom_types/enum.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nenum VeryVerboseEnumOfThingsToDoWithNumbers {\n    Add,\n    Subtract,\n}\n\n// Creates a type alias\ntype Operations = VeryVerboseEnumOfThingsToDoWithNumbers;\n\nfn main() {\n    // We can refer to each variant via its alias, not its long and inconvenient\n    // name.\n    let x = Operations::Add;\n}\n```\n\n----------------------------------------\n\nTITLE: Iterator::any Trait Implementation in Rust\nDESCRIPTION: The Iterator::any trait method definition in Rust. It shows the function signature that takes a predicate function and returns a boolean if any element in the iterator satisfies the predicate. The trait includes documentation explaining the semantics of the method.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/fn/closures/closure_examples/iter_any.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub trait Iterator {\n    // The type being iterated over.\n    type Item;\n\n    // `any` takes `&mut self` meaning the caller may be borrowed\n    // and modified, but not consumed.\n    fn any<F>(&mut self, f: F) -> bool where\n        // `FnMut` meaning any captured variable may at most be\n        // modified, not consumed. `Self::Item` states it takes\n        // arguments to the closure by value.\n        F: FnMut(Self::Item) -> bool;\n}\n```\n\n----------------------------------------\n\nTITLE: If Let Pattern Matching with Custom Enums in Rust\nDESCRIPTION: Demonstrates if let pattern matching with custom enum types, including value binding and non-parameterized variants.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/flow_control/if_let.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nenum Foo {\n    Bar,\n    Baz,\n    Qux(u32)\n}\n\nfn main() {\n    // Create example variables\n    let a = Foo::Bar;\n    let b = Foo::Baz;\n    let c = Foo::Qux(100);\n    \n    // Variable a matches Foo::Bar\n    if let Foo::Bar = a {\n        println!(\"a is foobar\");\n    }\n    \n    // Variable b does not match Foo::Bar\n    // So this will print nothing\n    if let Foo::Bar = b {\n        println!(\"b is foobar\");\n    }\n    \n    // Variable c matches Foo::Qux which has a value\n    // Similar to Some() in the previous example\n    if let Foo::Qux(value) = c {\n        println!(\"c is {}\", value);\n    }\n\n    // Binding also works with `if let`\n    if let Foo::Qux(value @ 100) = c {\n        println!(\"c is one hundred\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Associated Types with a Container Struct in Rust\nDESCRIPTION: This comprehensive example demonstrates the full implementation of associated types. It includes a Container struct, a Contains trait with associated types, and functions that utilize the trait.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/generics/assoc_items/types.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nstruct Container(i32, i32);\n\ntrait Contains {\n    type A;\n    type B;\n\n    fn contains(&self, _: &Self::A, _: &Self::B) -> bool;\n    fn first(&self) -> i32;\n    fn last(&self) -> i32;\n}\n\nimpl Contains for Container {\n    type A = i32;\n    type B = i32;\n\n    fn contains(&self, number_1: &i32, number_2: &i32) -> bool {\n        (&self.0 == number_1) && (&self.1 == number_2)\n    }\n    fn first(&self) -> i32 { self.0 }\n    fn last(&self) -> i32 { self.1 }\n}\n\nfn difference<C: Contains>(container: &C) -> i32 {\n    container.last() - container.first()\n}\n\nfn main() {\n    let number_1 = 3;\n    let number_2 = 10;\n\n    let container = Container(number_1, number_2);\n\n    println!(\"Does container contain {} and {}: {}\",\n        &number_1, &number_2,\n        container.contains(&number_1, &number_2));\n    println!(\"First number: {}\", container.first());\n    println!(\"Last number: {}\", container.last());\n    \n    println!(\"The difference is: {}\", difference(&container));\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Clone Trait for Resource Management in Rust\nDESCRIPTION: Demonstrates the usage of Clone trait in Rust for resource management, showing the difference between copying Unit structs and cloning Pair structs with boxed resources. The example illustrates ownership transfer, cloning of resources, and handling of dropped values.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/trait/clone.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// A unit struct without resources\n#[derive(Debug, Clone, Copy)]\nstruct Unit;\n\n// A tuple struct with resources that implements the `Clone` trait\n#[derive(Clone, Debug)]\nstruct Pair(Box<i32>, Box<i32>);\n\nfn main() {\n    // Instantiate `Unit`\n    let unit = Unit;\n    // Copy `Unit`, there are no resources to move\n    let copied_unit = unit;\n\n    // Both `Unit`s can be used independently\n    println!(\"original: {:?}\", unit);\n    println!(\"copy: {:?}\", copied_unit);\n\n    // Instantiate `Pair`\n    let pair = Pair(Box::new(1), Box::new(2));\n    println!(\"original: {:?}\", pair);\n\n    // Move `pair` into `moved_pair`, moves resources\n    let moved_pair = pair;\n    println!(\"moved: {:?}\", moved_pair);\n\n    // Error! `pair` has lost its resources\n    //println!(\"original: {:?}\", pair);\n    // TODO ^ Try uncommenting this line\n\n    // Clone `moved_pair` into `cloned_pair` (resources are included)\n    let cloned_pair = moved_pair.clone();\n    // Drop the moved original pair using std::mem::drop\n    drop(moved_pair);\n\n    // Error! `moved_pair` has been dropped\n    //println!(\"moved and dropped: {:?}\", moved_pair);\n    // TODO ^ Try uncommenting this line\n\n    // The result from .clone() can still be used!\n    println!(\"clone: {:?}\", cloned_pair);\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Cargo.toml Configuration for Rust Projects\nDESCRIPTION: This snippet shows the basic structure of a Cargo.toml file, which is the configuration file for Cargo in Rust projects. It includes package metadata and a section for dependencies.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/cargo/deps.md#2025-04-21_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[package]\nname = \"foo\"\nversion = \"0.1.0\"\nauthors = [\"mark\"]\n\n[dependencies]\n```\n\n----------------------------------------\n\nTITLE: Basic Drop Trait Implementation in Rust\nDESCRIPTION: Demonstrates the basic usage of Drop trait with a simple Droppable struct that prints a message when its instances are dropped. Shows both automatic scope-based dropping and manual dropping using the drop() function.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/trait/drop.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Droppable {\n    name: &'static str,\n}\n\n// This trivial implementation of `drop` adds a print to console.\nimpl Drop for Droppable {\n    fn drop(&mut self) {\n        println!(\"> Dropping {}\", self.name);\n    }\n}\n\nfn main() {\n    let _a = Droppable { name: \"a\" };\n\n    // block A\n    {\n        let _b = Droppable { name: \"b\" };\n\n        // block B\n        {\n            let _c = Droppable { name: \"c\" };\n            let _d = Droppable { name: \"d\" };\n\n            println!(\"Exiting block B\");\n        }\n        println!(\"Just exited block B\");\n\n        println!(\"Exiting block A\");\n    }\n    println!(\"Just exited block A\");\n\n    // Variable can be manually dropped using the `drop` function\n    drop(_a);\n    // TODO ^ Try commenting this line\n\n    println!(\"end of the main function\");\n}\n```\n\n----------------------------------------\n\nTITLE: Using Self Alias in Enum Implementation Blocks in Rust\nDESCRIPTION: Demonstrates using the 'Self' alias within an implementation block for an enum. This pattern is common in Rust to avoid repeating the full enum name when referring to variants inside its own implementation.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/custom_types/enum.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nenum VeryVerboseEnumOfThingsToDoWithNumbers {\n    Add,\n    Subtract,\n}\n\nimpl VeryVerboseEnumOfThingsToDoWithNumbers {\n    fn run(&self, x: i32, y: i32) -> i32 {\n        match self {\n            Self::Add => x + y,\n            Self::Subtract => x - y,\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Empty Trait Bounds in Rust\nDESCRIPTION: This example demonstrates how empty traits can be used as type constraints in Rust functions. It creates empty traits Red and Blue, implements them for different types, and shows how functions can be restricted to only accept types implementing specific traits, regardless of whether those traits contain functionality.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/generics/bounds/testcase_empty.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Cardinal;\nstruct BlueJay;\nstruct Turkey;\n\ntrait Red {}\ntrait Blue {}\n\nimpl Red for Cardinal {}\nimpl Blue for BlueJay {}\n\n// These functions are only valid for types which implement these\n// traits. The fact that the traits are empty is irrelevant.\nfn red<T: Red>(_: &T)   -> &'static str { \"red\" }\nfn blue<T: Blue>(_: &T) -> &'static str { \"blue\" }\n\nfn main() {\n    let cardinal = Cardinal;\n    let blue_jay = BlueJay;\n    let _turkey   = Turkey;\n\n    // `red()` won't work on a blue jay nor vice versa\n    // because of the bounds.\n    println!(\"A cardinal is {}\", red(&cardinal));\n    println!(\"A blue jay is {}\", blue(&blue_jay));\n    //println!(\"A turkey is {}\", red(&_turkey));\n    // ^ TODO: Try uncommenting this line.\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Shared Ownership Between Threads Using Arc in Rust\nDESCRIPTION: This example demonstrates how to use Arc to share a string value across multiple threads. It creates an Arc-wrapped string, spawns 10 threads that each clone the Arc reference, and prints the shared value from each thread. The program uses thread::sleep to ensure all spawned threads complete before the main thread exits.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/std/arc.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::time::Duration;\nuse std::sync::Arc;\nuse std::thread;\n\nfn main() {\n    // This variable declaration is where its value is specified.\n    let apple = Arc::new(\"the same apple\");\n\n    for _ in 0..10 {\n        // Here there is no value specification as it is a pointer to a\n        // reference in the memory heap.\n        let apple = Arc::clone(&apple);\n\n        thread::spawn(move || {\n            // As Arc was used, threads can be spawned using the value allocated\n            // in the Arc variable pointer's location.\n            println!(\"{:?}\", apple);\n        });\n    }\n\n    // Make sure all Arc instances are printed from spawned threads.\n    thread::sleep(Duration::from_secs(1));\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Into trait for a custom type in Rust\nDESCRIPTION: This example shows how to implement the Into trait for i32 to convert it into a custom Number struct. Note that the type annotation is required when calling into() as the compiler often cannot infer the target type.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/conversion/from_into.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse std::convert::Into;\n\n#[derive(Debug)]\nstruct Number {\n    value: i32,\n}\n\nimpl Into<Number> for i32 {\n    fn into(self) -> Number {\n        Number { value: self }\n    }\n}\n\nfn main() {\n    let int = 5;\n    // Try removing the type annotation\n    let num: Number = int.into();\n    println!(\"My number is {:?}\", num);\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Optional Values with Option in Rust\nDESCRIPTION: The Option type is used for optional values or when lack of a value is not an error. Unwrap can be used for prototyping, but expect is preferred as it allows specifying an error message.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/error.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet value: Option<i32> = Some(42);\nlet unwrapped = value.unwrap();\nlet expected = value.expect(\"Value should be present\");\n```\n\n----------------------------------------\n\nTITLE: Using Dev Dependencies in Rust Tests\nDESCRIPTION: Implementation example showing how to use the pretty_assertions dev dependency in test code. Demonstrates importing the dependency with cfg(test) attribute and using it to enhance assert_eq! functionality in tests.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/testing/dev_dependencies.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\npub fn add(a: i32, b: i32) -> i32 {\n    a + b\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use pretty_assertions::assert_eq; // crate for test-only use. Cannot be used in non-test code.\n\n    #[test]\n    fn test_add() {\n        assert_eq!(add(2, 3), 5);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Byte Strings and UTF-8 Conversion in Rust\nDESCRIPTION: This code illustrates byte strings in Rust (arrays of bytes rather than Unicode text), showing how to create them with the b prefix and how to attempt conversion to UTF-8 strings. It also demonstrates handling non-UTF-8 encoded text like SHIFT-JIS.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/std/str.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse std::str;\n\nfn main() {\n    // Note that this is not actually a `&str`\n    let bytestring: &[u8; 21] = b\"this is a byte string\";\n\n    // Byte arrays don't have the `Display` trait, so printing them is a bit limited\n    println!(\"A byte string: {:?}\", bytestring);\n\n    // Byte strings can have byte escapes...\n    let escaped = b\"\\x52\\x75\\x73\\x74 as bytes\";\n    // ...but no unicode escapes\n    // let escaped = b\"\\u{211D} is not allowed\";\n    println!(\"Some escaped bytes: {:?}\", escaped);\n\n\n    // Raw byte strings work just like raw strings\n    let raw_bytestring = br\"\\u{211D} is not escaped here\";\n    println!(\"{:?}\", raw_bytestring);\n\n    // Converting a byte array to `str` can fail\n    if let Ok(my_str) = str::from_utf8(raw_bytestring) {\n        println!(\"And the same as text: '{}'\", my_str);\n    }\n\n    let _quotes = br#\"You can also use \"fancier\" formatting, \\\n                    like with normal raw strings\"#;\n\n    // Byte strings don't have to be UTF-8\n    let shift_jis = b\"\\x82\\xe6\\x82\\xa8\\x82\\xb1\\x82\\xbb\"; // \"ようこそ\" in SHIFT-JIS\n\n    // But then they can't always be converted to `str`\n    match str::from_utf8(shift_jis) {\n        Ok(my_str) => println!(\"Conversion successful: '{}'\", my_str),\n        Err(e) => println!(\"Conversion failed: {:?}\", e),\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Using Where Clauses for Complex Type Relationships in Rust\nDESCRIPTION: This example demonstrates using a where clause to express a bound on Option<T> rather than T itself. This implementation requires a where clause because the bound is on a type constructed from the generic parameter, not directly on the parameter.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/generics/where.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::fmt::Debug;\n\ntrait PrintInOption {\n    fn print_in_option(self);\n}\n\n// Because we would otherwise have to express this as `T: Debug` or \n// use another method of indirect approach, this requires a `where` clause:\nimpl<T> PrintInOption for T where\n    Option<T>: Debug {\n    // We want `Option<T>: Debug` as our bound because that is what's\n    // being printed. Doing otherwise would be using the wrong bound.\n    fn print_in_option(self) {\n        println!(\"{:?}\", Some(self));\n    }\n}\n\nfn main() {\n    let vec = vec![1, 2, 3];\n\n    vec.print_in_option();\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Lifetime Parameter Syntax in Rust\nDESCRIPTION: Demonstrates the basic syntax for declaring a lifetime parameter on a function or type. The apostrophe character is used to denote lifetimes, followed by an identifier.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/scope/lifetime/explicit.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfoo<'a>\n// `foo` has a lifetime parameter `'a`\n```\n\n----------------------------------------\n\nTITLE: If Let Pattern Matching with Option Types in Rust\nDESCRIPTION: Shows how to use if let for cleaner Option type handling, including various failure scenarios and else conditions.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/flow_control/if_let.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    // All have type `Option<i32>`\n    let number = Some(7);\n    let letter: Option<i32> = None;\n    let emoticon: Option<i32> = None;\n\n    // The `if let` construct reads: \"if `let` destructures `number` into\n    // `Some(i)`, evaluate the block (`{}`).\n    if let Some(i) = number {\n        println!(\"Matched {:?}!\", i);\n    }\n\n    // If you need to specify a failure, use an else:\n    if let Some(i) = letter {\n        println!(\"Matched {:?}!\", i);\n    } else {\n        // Destructure failed. Change to the failure case.\n        println!(\"Didn't match a number. Let's go with a letter!\");\n    }\n\n    // Provide an altered failing condition.\n    let i_like_letters = false;\n\n    if let Some(i) = emoticon {\n        println!(\"Matched {:?}!\", i);\n    // Destructure failed. Evaluate an `else if` condition to see if the\n    // alternate failure branch should be taken:\n    } else if i_like_letters {\n        println!(\"Didn't match a number. Let's go with a letter!\");\n    } else {\n        // The condition evaluated false. This branch is the default:\n        println!(\"I don't like letters. Let's go with an emoticon :)!\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Mutability Transfer in Rust\nDESCRIPTION: This code snippet shows how mutability can change when ownership is transferred. It creates an immutable box, attempts to modify it (which is commented out due to an error), then moves the box to a mutable variable where it can be modified.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/scope/move/mut.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let immutable_box = Box::new(5u32);\n\n    println!(\"immutable_box contains {}\", immutable_box);\n\n    // Mutability error\n    //*immutable_box = 4;\n\n    // *Move* the box, changing the ownership (and mutability)\n    let mut mutable_box = immutable_box;\n\n    println!(\"mutable_box contains {}\", mutable_box);\n\n    // Modify the contents of the box\n    *mutable_box = 4;\n\n    println!(\"mutable_box now contains {}\", mutable_box);\n}\n```\n\n----------------------------------------\n\nTITLE: Using Into with a From implementation in Rust\nDESCRIPTION: This example demonstrates how implementing From for a type automatically provides the Into implementation. It shows how to convert an i32 to a Number using into() despite only implementing From<i32> for Number.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/conversion/from_into.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse std::convert::From;\n\n#[derive(Debug)]\nstruct Number {\n    value: i32,\n}\n\n// Define `From`\nimpl From<i32> for Number {\n    fn from(item: i32) -> Self {\n        Number { value: item }\n    }\n}\n\nfn main() {\n    let int = 5;\n    // use `Into`\n    let num: Number = int.into();\n    println!(\"My number is {:?}\", num);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic and Concrete Types in Rust\nDESCRIPTION: This example demonstrates the syntax and usage of generic and concrete types in Rust. It defines concrete and generic structs, and shows how to create instances of these types with explicit and implicit type specifications.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/generics.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// A concrete type `A`.\nstruct A;\n\n// In defining the type `Single`, the first use of `A` is not preceded by `<A>`.\n// Therefore, `Single` is a concrete type, and `A` is defined as above.\nstruct Single(A);\n//            ^ Here is `Single`s first use of the type `A`.\n\n// Here, `<T>` precedes the first use of `T`, so `SingleGen` is a generic type.\n// Because the type parameter `T` is generic, it could be anything, including\n// the concrete type `A` defined at the top.\nstruct SingleGen<T>(T);\n\nfn main() {\n    // `Single` is concrete and explicitly takes `A`.\n    let _s = Single(A);\n    \n    // Create a variable `_char` of type `SingleGen<char>`\n    // and give it the value `SingleGen('a')`.\n    // Here, `SingleGen` has a type parameter explicitly specified.\n    let _char: SingleGen<char> = SingleGen('a');\n\n    // `SingleGen` can also have a type parameter implicitly specified:\n    let _t    = SingleGen(A); // Uses `A` defined at the top.\n    let _i32  = SingleGen(6); // Uses `i32`.\n    let _char = SingleGen('a'); // Uses `char`.\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing C-like Enums with Implicit and Explicit Discriminators in Rust\nDESCRIPTION: This example demonstrates how to define and use C-like enums in Rust. It shows both implicit discriminators (which start at 0 and increment automatically) and explicit discriminators (custom values like hexadecimal color codes). The example also demonstrates how enum variants can be cast to integers.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/custom_types/enum/c_like.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// An attribute to hide warnings for unused code.\n#![allow(dead_code)]\n\n// enum with implicit discriminator (starts at 0)\nenum Number {\n    Zero,\n    One,\n    Two,\n}\n\n// enum with explicit discriminator\nenum Color {\n    Red = 0xff0000,\n    Green = 0x00ff00,\n    Blue = 0x0000ff,\n}\n\nfn main() {\n    // `enums` can be cast as integers.\n    println!(\"zero is {}\", Number::Zero as i32);\n    println!(\"one is {}\", Number::One as i32);\n\n    println!(\"roses are #{:06x}\", Color::Red as i32);\n    println!(\"violets are #{:06x}\", Color::Blue as i32);\n}\n```\n\n----------------------------------------\n\nTITLE: Basic fmt::Display Implementation for Structure\nDESCRIPTION: Demonstrates the basic implementation of fmt::Display trait for a simple tuple struct containing an i32. Shows the required fmt method signature and basic formatting using write! macro.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/hello/print/print_display.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::fmt;\n\nstruct Structure(i32);\n\nimpl fmt::Display for Structure {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Multiple Lifetime Parameters Syntax in Rust\nDESCRIPTION: Shows how to declare multiple lifetime parameters on a function or type. Each lifetime is specified separately within the angle brackets.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/scope/lifetime/explicit.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfoo<'a, 'b>\n// `foo` has lifetime parameters `'a` and `'b`\n```\n\n----------------------------------------\n\nTITLE: Basic Match Expression with Option Type in Rust\nDESCRIPTION: Demonstrates a verbose match expression for handling an Option type, showing why if let might be preferred.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/flow_control/if_let.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet optional = Some(7);\n\nmatch optional {\n    Some(i) => println!(\"This is a really long string and `{:?}`\", i),\n    _ => {},\n    // ^ Required because `match` is exhaustive. Doesn't it seem\n    // like wasted space?\n};\n```\n\n----------------------------------------\n\nTITLE: Basic Path Binding with Use Declaration in Rust\nDESCRIPTION: Demonstrates how to bind deeply nested module paths using the 'use' declaration for easier access to functions and types.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/mod/use.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse crate::deeply::nested::{\n    my_first_function,\n    my_second_function,\n    AndATraitType\n};\n\nfn main() {\n    my_first_function();\n}\n```\n\n----------------------------------------\n\nTITLE: Using Enum Variants Without Manual Scoping in Rust\nDESCRIPTION: This example demonstrates two ways to bring enum variants into scope using the `use` declaration: explicitly naming specific variants and using the wildcard syntax. This allows referencing the variants directly without prefixing them with the enum name.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/custom_types/enum/enum_use.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// An attribute to hide warnings for unused code.\n#![allow(dead_code)]\n\nenum Stage {\n    Beginner,\n    Advanced,\n}\n\nenum Role {\n    Student,\n    Teacher,\n}\n\nfn main() {\n    // Explicitly `use` each name so they are available without\n    // manual scoping.\n    use crate::Stage::{Beginner, Advanced};\n    // Automatically `use` each name inside `Role`.\n    use crate::Role::*;\n\n    // Equivalent to `Stage::Beginner`.\n    let stage = Beginner;\n    // Equivalent to `Role::Student`.\n    let role = Student;\n\n    match stage {\n        // Note the lack of scoping because of the explicit `use` above.\n        Beginner => println!(\"Beginners are starting their learning journey!\"),\n        Advanced => println!(\"Advanced learners are mastering their subjects...\"),\n    }\n\n    match role {\n        // Note again the lack of scoping.\n        Student => println!(\"Students are acquiring knowledge!\"),\n        Teacher => println!(\"Teachers are spreading knowledge!\"),\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating cfg Attribute and cfg! Macro in Rust\nDESCRIPTION: This code snippet illustrates the use of #[cfg] for conditional compilation and cfg! for runtime checks based on the target operating system. It defines two versions of a function that prints different messages depending on whether the target OS is Linux or not.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/attribute/cfg.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// This function only gets compiled if the target OS is linux\n#[cfg(target_os = \"linux\")]\nfn are_you_on_linux() {\n    println!(\"You are running linux!\");\n}\n\n// And this function only gets compiled if the target OS is *not* linux\n#[cfg(not(target_os = \"linux\"))]\nfn are_you_on_linux() {\n    println!(\"You are *not* running linux!\");\n}\n\nfn main() {\n    are_you_on_linux();\n\n    println!(\"Are you sure?\");\n    if cfg!(target_os = \"linux\") {\n        println!(\"Yes. It's definitely linux!\");\n    } else {\n        println!(\"Yes. It's definitely *not* linux!\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating `super` and `self` Usage in Rust Module Paths\nDESCRIPTION: This code snippet illustrates the use of `super` and `self` keywords in Rust for resolving module paths. It defines multiple nested modules with functions named 'function' and shows how to access them from different scopes using `self`, `super`, and absolute paths.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/mod/super.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn function() {\n    println!(\"called `function()`\");\n}\n\nmod cool {\n    pub fn function() {\n        println!(\"called `cool::function()`\");\n    }\n}\n\nmod my {\n    fn function() {\n        println!(\"called `my::function()`\");\n    }\n    \n    mod cool {\n        pub fn function() {\n            println!(\"called `my::cool::function()`\");\n        }\n    }\n    \n    pub fn indirect_call() {\n        // Let's access all the functions named `function` from this scope!\n        print!(\"called `my::indirect_call()`, that\\n> \");\n        \n        // The `self` keyword refers to the current module scope - in this case `my`.\n        // Calling `self::function()` and calling `function()` directly both give\n        // the same result, because they refer to the same function.\n        self::function();\n        function();\n        \n        // We can also use `self` to access another module inside `my`:\n        self::cool::function();\n        \n        // The `super` keyword refers to the parent scope (outside the `my` module).\n        super::function();\n        \n        // This will bind to the `cool::function` in the *crate* scope.\n        // In this case the crate scope is the outermost scope.\n        {\n            use crate::cool::function as root_function;\n            root_function();\n        }\n    }\n}\n\nfn main() {\n    my::indirect_call();\n}\n```\n\n----------------------------------------\n\nTITLE: Main Rust File with Module Declarations\nDESCRIPTION: Contains the main function and demonstrates how to declare and use modules from other files.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/mod/split.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// This declaration will look for a file named `my.rs` and will\n// insert its contents inside a module named `my` under this scope\nmod my;\n\nfn function() {\n    println!(\"called `function()`\");\n}\n\nfn main() {\n    my::function();\n\n    function();\n\n    my::indirect_access();\n\n    my::nested::function();\n}\n```\n\n----------------------------------------\n\nTITLE: Waiting for Child Process Completion in Rust\nDESCRIPTION: This Rust code snippet demonstrates how to spawn a child process using Command::new, wait for it to finish using Child::wait, and then continue execution. It uses the 'sleep' command as an example of a long-running process.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/std_misc/process/wait.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::process::Command;\n\nfn main() {\n    let mut child = Command::new(\"sleep\").arg(\"5\").spawn().unwrap();\n    let _result = child.wait().unwrap();\n\n    println!(\"reached end of main\");\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Default Trait with Lifetime Annotations in Rust\nDESCRIPTION: This code snippet demonstrates how to use lifetime annotations in a struct definition and its implementation of the Default trait. It creates a Borrowed struct with a reference field and implements the Default trait for it.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/scope/lifetime/trait.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// A struct with annotation of lifetimes.\n#[derive(Debug)]\nstruct Borrowed<'a> {\n    x: &'a i32,\n}\n\n// Annotate lifetimes to impl.\nimpl<'a> Default for Borrowed<'a> {\n    fn default() -> Self {\n        Self {\n            x: &10,\n        }\n    }\n}\n\nfn main() {\n    let b: Borrowed = Default::default();\n    println!(\"b is {:?}\", b);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating New Rust Projects with Cargo\nDESCRIPTION: This snippet demonstrates how to use Cargo to create new Rust projects, both binary and library types. It shows the command-line instructions for initializing new projects.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/cargo/deps.md#2025-04-21_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n# A binary\ncargo new foo\n\n# A library\ncargo new --lib bar\n```\n\n----------------------------------------\n\nTITLE: Implementing Division with panic! for Error Handling in Rust\nDESCRIPTION: This code demonstrates how to use the panic! macro when implementing integer division to handle division by zero errors. The example shows resource allocation through Box and demonstrates how Rust properly frees memory even during panic unwinding.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/std/panic.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// Re-implementation of integer division (/)\nfn division(dividend: i32, divisor: i32) -> i32 {\n    if divisor == 0 {\n        // Division by zero triggers a panic\n        panic!(\"division by zero\");\n    } else {\n        dividend / divisor\n    }\n}\n\n// The `main` task\nfn main() {\n    // Heap allocated integer\n    let _x = Box::new(0i32);\n\n    // This operation will trigger a task failure\n    division(3, 0);\n\n    println!(\"This point won't be reached!\");\n\n    // `_x` should get destroyed at this point\n}\n```\n\n----------------------------------------\n\nTITLE: Destructuring Tuples with Match in Rust\nDESCRIPTION: This code snippet demonstrates how to use pattern matching to destructure tuples in Rust. It shows different matching patterns including exact values, partial matches, and wildcards. The example uses a triple (3-element tuple) and prints different messages based on the matched pattern.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/flow_control/match/destructuring/destructure_tuple.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let triple = (0, -2, 3);\n    // TODO ^ Try different values for `triple`\n\n    println!(\"Tell me about {:?}\", triple);\n    // Match can be used to destructure a tuple\n    match triple {\n        // Destructure the second and third elements\n        (0, y, z) => println!(\"First is `0`, `y` is {:?}, and `z` is {:?}\", y, z),\n        (1, ..)  => println!(\"First is `1` and the rest doesn't matter\"),\n        (.., 2)  => println!(\"last is `2` and the rest doesn't matter\"),\n        (3, .., 4)  => println!(\"First is `3`, last is `4`, and the rest doesn't matter\"),\n        // `..` can be used to ignore the rest of the tuple\n        _      => println!(\"It doesn't matter what they are\"),\n        // `_` means don't bind the value to a variable\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Practical Use of Never Type in Match Expressions\nDESCRIPTION: An example showing how the never type can be used in match expressions. It demonstrates how continue can be used in a branch that requires a specific return type, as continue never returns a value.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/fn/diverging.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    fn sum_odd_numbers(up_to: u32) -> u32 {\n        let mut acc = 0;\n        for i in 0..up_to {\n            // Notice that the return type of this match expression must be u32\n            // because of the type of the \"addition\" variable.\n            let addition: u32 = match i%2 == 1 {\n                // The \"i\" variable is of type u32, which is perfectly fine.\n                true => i,\n                // On the other hand, the \"continue\" expression does not return\n                // u32, but it is still fine, because it never returns and therefore\n                // does not violate the type requirements of the match expression.\n                false => continue,\n            };\n            acc += addition;\n        }\n        acc\n    }\n    println!(\"Sum of odd numbers up to 9 (excluding): {}\", sum_odd_numbers(9));\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Build Script in Cargo.toml\nDESCRIPTION: This snippet shows how to specify a custom build script in the Cargo.toml file of a Rust project. The build property points to the build script file that will be executed before the main package compilation.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/cargo/build_scripts.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[package]\n...\nbuild = \"build.rs\"\n```\n\n----------------------------------------\n\nTITLE: Using move Keyword with Rust Closures\nDESCRIPTION: Demonstrates how to force ownership transfer of captured variables using the 'move' keyword in closures. Shows the impact on variable accessibility after closure creation and borrow checker behavior.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/fn/closures/capture.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let haystack = vec![1, 2, 3];\n\n    let contains = move |needle| haystack.contains(needle);\n\n    println!(\"{}\", contains(&1));\n    println!(\"{}\", contains(&4));\n}\n```\n\n----------------------------------------\n\nTITLE: Static Reference Lifetime Examples in Rust\nDESCRIPTION: Illustrates different ways to work with static lifetimes including constants, string literals, and lifetime coercion. Shows how static data remains in read-only memory and how lifetime coercion works.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/scope/lifetime/static_lifetime.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// Make a constant with `'static` lifetime.\nstatic NUM: i32 = 18;\n\n// Returns a reference to `NUM` where its `'static`\n// lifetime is coerced to that of the input argument.\nfn coerce_static<'a>(_: &'a i32) -> &'a i32 {\n    &NUM\n}\n\nfn main() {\n    {\n        // Make a `string` literal and print it:\n        let static_string = \"I'm in read-only memory\";\n        println!(\"static_string: {}\", static_string);\n\n        // When `static_string` goes out of scope, the reference\n        // can no longer be used, but the data remains in the binary.\n    }\n\n    {\n        // Make an integer to use for `coerce_static`:\n        let lifetime_num = 9;\n\n        // Coerce `NUM` to lifetime of `lifetime_num`:\n        let coerced_static = coerce_static(&lifetime_num);\n\n        println!(\"coerced_static: {}\", coerced_static);\n    }\n\n    println!(\"NUM: {} stays accessible!\", NUM);\n}\n```\n\n----------------------------------------\n\nTITLE: Using a Function Named After a Keyword Without Raw Identifiers (Error Example)\nDESCRIPTION: This snippet demonstrates the problem that occurs when attempting to use a function from a crate that has the same name as a Rust keyword. In this case, the function 'try' from the 'foo' crate can't be called normally because 'try' is a keyword in newer editions of Rust.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/compatibility/raw_identifiers.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nextern crate foo;\n\nfn main() {\n    foo::try();\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Iterator::find with different collection types in Rust\nDESCRIPTION: Example using Iterator::find to search for values in vectors and arrays, illustrating the differences between iter() and into_iter() methods and showing how to handle reference destructuring.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/fn/closures/closure_examples/iter_find.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let vec1 = vec![1, 2, 3];\n    let vec2 = vec![4, 5, 6];\n\n    // `iter()` for vecs yields `&i32`.\n    let mut iter = vec1.iter();\n    // `into_iter()` for vecs yields `i32`.\n    let mut into_iter = vec2.into_iter();\n\n    // `iter()` for vecs yields `&i32`, and we want to reference one of its\n    // items, so we have to destructure `&&i32` to `i32`\n    println!(\"Find 2 in vec1: {:?}\", iter     .find(|&&x| x == 2));\n    // `into_iter()` for vecs yields `i32`, and we want to reference one of\n    // its items, so we have to destructure `&i32` to `i32`\n    println!(\"Find 2 in vec2: {:?}\", into_iter.find(| &x| x == 2));\n\n    let array1 = [1, 2, 3];\n    let array2 = [4, 5, 6];\n\n    // `iter()` for arrays yields `&&i32`\n    println!(\"Find 2 in array1: {:?}\", array1.iter()     .find(|&&x| x == 2));\n    // `into_iter()` for arrays yields `&i32`\n    println!(\"Find 2 in array2: {:?}\", array2.into_iter().find(|&x| x == 2));\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing an Infinite Loop with Break and Continue in Rust\nDESCRIPTION: A Rust example demonstrating an infinite loop that counts upward, using `continue` to skip printing at count 3 and `break` to exit the loop at count 5. The code shows how to control loop execution flow with conditional statements.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/flow_control/loop.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let mut count = 0u32;\n\n    println!(\"Let's count until infinity!\");\n\n    // Infinite loop\n    loop {\n        count += 1;\n\n        if count == 3 {\n            println!(\"three\");\n\n            // Skip the rest of this iteration\n            continue;\n        }\n\n        println!(\"{}\", count);\n\n        if count == 5 {\n            println!(\"OK, that's enough\");\n\n            // Exit this loop\n            break;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Debug Trait for Printing in Rust\nDESCRIPTION: This example shows how to use the {:?} format specifier to print structures that implement the Debug trait. It demonstrates printing of primitive types, custom structures, and nested structures.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/hello/print/print_debug.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// Derive the `fmt::Debug` implementation for `Structure`. `Structure`\n// is a structure which contains a single `i32`.\n#[derive(Debug)]\nstruct Structure(i32);\n\n// Put a `Structure` inside of the structure `Deep`. Make it printable\n// also.\n#[derive(Debug)]\nstruct Deep(Structure);\n\nfn main() {\n    // Printing with `{:?}` is similar to with `{}`.\n    println!(\"{:?} months in a year.\", 12);\n    println!(\"{1:?} {0:?} is the {actor:?} name.\",\n             \"Slater\",\n             \"Christian\",\n             actor=\"actor's\");\n\n    // `Structure` is printable!\n    println!(\"Now {:?} will print!\", Structure(3));\n\n    // The problem with `derive` is there is no control over how\n    // the results look. What if I want this to just show a `7`?\n    println!(\"Now {:?} will print!\", Deep(Structure(7)));\n}\n```\n\n----------------------------------------\n\nTITLE: Iterator Transformation with impl Trait\nDESCRIPTION: Implementation of a function that filters positive numbers and doubles them using iterator combinators. Shows how impl Trait simplifies return types when using closure-based iterator operations.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/trait/impl_trait.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nfn double_positives<'a>(numbers: &'a Vec<i32>) -> impl Iterator<Item = i32> + 'a {\n    numbers\n        .iter()\n        .filter(|x| x > &&0)\n        .map(|x| x * 2)\n}\n\nfn main() {\n    let singles = vec![-3, -2, 2, 3];\n    let doubles = double_positives(&singles);\n    assert_eq!(doubles.collect::<Vec<i32>>(), vec![4, 6]);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DRY Principle with Macros in Rust\nDESCRIPTION: This code snippet demonstrates the use of macros to implement and test arithmetic operations on vectors. It defines macros for asserting equal length, generating operator functions, and creating test cases. The code implements `add_assign`, `mul_assign`, and `sub_assign` functions for vectors.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/macros/dry.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::ops::{Add, Mul, Sub};\n\nmacro_rules! assert_equal_len {\n    // The `tt` (token tree) designator is used for\n    // operators and tokens.\n    ($a:expr, $b:expr, $func:ident, $op:tt) => {\n        assert!($a.len() == $b.len(),\n                \"{:?}: dimension mismatch: {:?} {:?} {:?}\",\n                stringify!($func),\n                ($a.len(),),\n                stringify!($op),\n                ($b.len(),));\n    };\n}\n\nmacro_rules! op {\n    ($func:ident, $bound:ident, $op:tt, $method:ident) => {\n        fn $func<T: $bound<T, Output=T> + Copy>(xs: &mut Vec<T>, ys: &Vec<T>) {\n            assert_equal_len!(xs, ys, $func, $op);\n\n            for (x, y) in xs.iter_mut().zip(ys.iter()) {\n                *x = $bound::$method(*x, *y);\n                // *x = x.$method(*y);\n            }\n        }\n    };\n}\n\n// Implement `add_assign`, `mul_assign`, and `sub_assign` functions.\nop!(add_assign, Add, +=, add);\nop!(mul_assign, Mul, *=, mul);\nop!(sub_assign, Sub, -=, sub);\n\nmod test {\n    use std::iter;\n    macro_rules! test {\n        ($func:ident, $x:expr, $y:expr, $z:expr) => {\n            #[test]\n            fn $func() {\n                for size in 0usize..10 {\n                    let mut x: Vec<_> = iter::repeat($x).take(size).collect();\n                    let y: Vec<_> = iter::repeat($y).take(size).collect();\n                    let z: Vec<_> = iter::repeat($z).take(size).collect();\n\n                    super::$func(&mut x, &y);\n\n                    assert_eq!(x, z);\n                }\n            }\n        };\n    }\n\n    // Test `add_assign`, `mul_assign`, and `sub_assign`.\n    test!(add_assign, 1u32, 2u32, 3u32);\n    test!(mul_assign, 2u32, 3u32, 6u32);\n    test!(sub_assign, 3u32, 2u32, 1u32);\n}\n```\n\n----------------------------------------\n\nTITLE: Dynamic Static References with Box::leak in Rust\nDESCRIPTION: Shows how to create 'static references during program execution using Box::leak. Creates random vectors with static lifetime that exist from the point of creation onward.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/scope/lifetime/static_lifetime.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nextern crate rand;\nuse rand::Fill;\n\nfn random_vec() -> &'static [usize; 100] {\n    let mut rng = rand::thread_rng();\n    let mut boxed = Box::new([0; 100]);\n    boxed.try_fill(&mut rng).unwrap();\n    Box::leak(boxed)\n}\n\nfn main() {\n    let first: &'static [usize; 100] = random_vec();\n    let second: &'static [usize; 100] = random_vec();\n    assert_ne!(first, second)\n}\n```\n\n----------------------------------------\n\nTITLE: Concise Implementation of read_lines Function using Iterator Methods in Rust\nDESCRIPTION: A more concise version of the read_lines function using iterator methods. It reads the file, splits it into lines, maps each line to a String, and collects the results into a vector.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/std_misc/file/read_lines.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::fs::read_to_string;\n\nfn read_lines(filename: &str) -> Vec<String> {\n    read_to_string(filename) \n        .unwrap()  // panic on possible file-reading errors\n        .lines()  // split the string into an iterator of string slices\n        .map(String::from)  // make each slice into a string\n        .collect()  // gather them together into a vector\n}\n```\n\n----------------------------------------\n\nTITLE: Embedding Results in Options for Error Handling in Rust\nDESCRIPTION: This snippet demonstrates how to handle mixed error types by embedding Result within Option. It defines a function double_first that attempts to parse and double the first element of a vector of strings, returning Option<Result<i32, ParseIntError>>.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/error/multiple_error_types/option_result.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::num::ParseIntError;\n\nfn double_first(vec: Vec<&str>) -> Option<Result<i32, ParseIntError>> {\n    vec.first().map(|first| {\n        first.parse::<i32>().map(|n| 2 * n)\n    })\n}\n\nfn main() {\n    let numbers = vec![\"42\", \"93\", \"18\"];\n    let empty = vec![];\n    let strings = vec![\"tofu\", \"93\", \"18\"];\n\n    println!(\"The first doubled is {:?}\", double_first(numbers));\n\n    println!(\"The first doubled is {:?}\", double_first(empty));\n    // Error 1: the input vector is empty\n\n    println!(\"The first doubled is {:?}\", double_first(strings));\n    // Error 2: the element doesn't parse to a number\n}\n```\n\n----------------------------------------\n\nTITLE: Alternative Approach Using match and if-let in Rust\nDESCRIPTION: Shows how to achieve similar functionality to let-else using traditional match and if-let patterns. This approach requires more code repetition and creates an outer scope for variable bindings, demonstrating why let-else is more concise.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/flow_control/let_else.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# use std::str::FromStr;\n# \n# fn get_count_item(s: &str) -> (u64, &str) {\n#     let mut it = s.split(' ');\n    let (count_str, item) = match (it.next(), it.next()) {\n        (Some(count_str), Some(item)) => (count_str, item),\n        _ => panic!(\"Can't segment count item pair: '{s}'\"),\n    };\n    let count = if let Ok(count) = u64::from_str(count_str) {\n        count\n    } else {\n        panic!(\"Can't parse integer: '{count_str}'\");\n    };\n#     (count, item)\n# }\n# \n# assert_eq!(get_count_item(\"3 chairs\"), (3, \"chairs\"));\n```\n\n----------------------------------------\n\nTITLE: Implementing Lifetime Bounds with Debug Trait in Rust\nDESCRIPTION: Demonstrates the use of lifetime bounds in Rust through a generic struct Ref and two printing functions. Shows how to specify lifetime constraints on generic types and references, while also implementing the Debug trait. The example includes both direct and reference-based generic function implementations.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/scope/lifetime/lifetime_bounds.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::fmt::Debug; // Trait to bound with.\n\n#[derive(Debug)]\nstruct Ref<'a, T: 'a>(&'a T);\n// `Ref` contains a reference to a generic type `T` that has\n// some lifetime `'a` unknown by `Ref`. `T` is bounded such that any\n// *references* in `T` must outlive `'a`. Additionally, the lifetime\n// of `Ref` may not exceed `'a`.\n\n// A generic function which prints using the `Debug` trait.\nfn print<T>(t: T) where\n    T: Debug {\n    println!(\"`print`: t is {:?}\", t);\n}\n\n// Here a reference to `T` is taken where `T` implements\n// `Debug` and all *references* in `T` outlive `'a`. In\n// addition, `'a` must outlive the function.\nfn print_ref<'a, T>(t: &'a T) where\n    T: Debug + 'a {\n    println!(\"`print_ref`: t is {:?}\", t);\n}\n\nfn main() {\n    let x = 7;\n    let ref_x = Ref(&x);\n\n    print_ref(&ref_x);\n    print(ref_x);\n}\n```\n\n----------------------------------------\n\nTITLE: Pretty Printing with Debug Trait in Rust\nDESCRIPTION: This snippet demonstrates the use of the {:#?} format specifier for pretty printing of structures that implement the Debug trait. It shows a more readable, multi-line output format.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/hello/print/print_debug.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Debug)]\nstruct Person<'a> {\n    name: &'a str,\n    age: u8\n}\n\nfn main() {\n    let name = \"Peter\";\n    let age = 27;\n    let peter = Person { name, age };\n\n    // Pretty print\n    println!(\"{:#?}\", peter);\n}\n```\n\n----------------------------------------\n\nTITLE: Returning Values from Loop Expressions in Rust\nDESCRIPTION: This example demonstrates how to return a value from a loop expression in Rust. The loop increments a counter until it reaches 10, then breaks out of the loop and returns the counter multiplied by 2. The result is then verified using an assertion.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/flow_control/loop/return.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let mut counter = 0;\n\n    let result = loop {\n        counter += 1;\n\n        if counter == 10 {\n            break counter * 2;\n        }\n    };\n\n    assert_eq!(result, 20);\n}\n```\n\n----------------------------------------\n\nTITLE: Ignoring Tests in Rust\nDESCRIPTION: Demonstrates how to mark tests with the #[ignore] attribute to exclude them from normal test runs, and how to run only ignored tests.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/testing/unit_testing.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\npub fn add(a: i32, b: i32) -> i32 {\n    a + b\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_add() {\n        assert_eq!(add(2, 2), 4);\n    }\n\n    #[test]\n    fn test_add_hundred() {\n        assert_eq!(add(100, 2), 102);\n        assert_eq!(add(2, 100), 102);\n    }\n\n    #[test]\n    #[ignore]\n    fn ignored_test() {\n        assert_eq!(add(0, 0), 0);\n    }\n}\n```\n\nLANGUAGE: shell\nCODE:\n```\n$ cargo test\nrunning 3 tests\ntest tests::ignored_test ... ignored\ntest tests::test_add ... ok\ntest tests::test_add_hundred ... ok\n\ntest result: ok. 2 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out\n\n   Doc-tests tmp-ignore\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\n$ cargo test -- --ignored\nrunning 1 test\ntest tests::ignored_test ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\n   Doc-tests tmp-ignore\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n```\n\n----------------------------------------\n\nTITLE: Unwrapping Partitioned Results in Rust\nDESCRIPTION: Extends the partition approach by unwrapping both successful and failed Results to get clean collections of values and errors.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/error/iter_result.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let strings = vec![\"tofu\", \"93\", \"18\"];\n    let (numbers, errors): (Vec<_>, Vec<_>) = strings\n        .into_iter()\n        .map(|s| s.parse::<i32>())\n        .partition(Result::is_ok);\n    let numbers: Vec<_> = numbers.into_iter().map(Result::unwrap).collect();\n    let errors: Vec<_> = errors.into_iter().map(Result::unwrap_err).collect();\n    println!(\"Numbers: {:?}\", numbers);\n    println!(\"Errors: {:?}\", errors);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing FFI with C Libraries in Rust\nDESCRIPTION: This code snippet demonstrates how to use Rust's Foreign Function Interface to link with C libraries, declare foreign functions, and create safe wrappers. It includes platform-specific configurations and a custom Complex number implementation.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/std_misc/ffi.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::fmt;\n\n// this extern block links to the libm library\n#[cfg(target_family = \"windows\")]\n#[link(name = \"msvcrt\")]\nextern {\n    // this is a foreign function\n    // that computes the square root of a single precision complex number\n    fn csqrtf(z: Complex) -> Complex;\n\n    fn ccosf(z: Complex) -> Complex;\n}\n#[cfg(target_family = \"unix\")]\n#[link(name = \"m\")]\nextern {\n    // this is a foreign function\n    // that computes the square root of a single precision complex number\n    fn csqrtf(z: Complex) -> Complex;\n\n    fn ccosf(z: Complex) -> Complex;\n}\n\n// Since calling foreign functions is considered unsafe,\n// it's common to write safe wrappers around them.\nfn cos(z: Complex) -> Complex {\n    unsafe { ccosf(z) }\n}\n\nfn main() {\n    // z = -1 + 0i\n    let z = Complex { re: -1., im: 0. };\n\n    // calling a foreign function is an unsafe operation\n    let z_sqrt = unsafe { csqrtf(z) };\n\n    println!(\"the square root of {:?} is {:?}\", z, z_sqrt);\n\n    // calling safe API wrapped around unsafe operation\n    println!(\"cos({:?}) = {:?}\", z, cos(z));\n}\n\n// Minimal implementation of single precision complex numbers\n#[repr(C)]\n#[derive(Clone, Copy)]\nstruct Complex {\n    re: f32,\n    im: f32,\n}\n\nimpl fmt::Debug for Complex {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        if self.im < 0. {\n            write!(f, \"{}-{}i\", self.re, -self.im)\n        } else {\n            write!(f, \"{}+{}i\", self.re, self.im)\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Iterator::any Function with Vectors and Arrays in Rust\nDESCRIPTION: A complete example demonstrating the usage of the any() method on different collections in Rust. It shows the difference between iter() (borrowing) and into_iter() (consuming) methods when used with vectors and arrays, highlighting how they affect ownership of the collection and its elements.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/fn/closures/closure_examples/iter_any.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let vec1 = vec![1, 2, 3];\n    let vec2 = vec![4, 5, 6];\n\n    // `iter()` for vecs yields `&i32`. Destructure to `i32`.\n    println!(\"2 in vec1: {}\", vec1.iter()     .any(|&x| x == 2));\n    // `into_iter()` for vecs yields `i32`. No destructuring required.\n    println!(\"2 in vec2: {}\", vec2.into_iter().any(|x| x == 2));\n\n    // `iter()` only borrows `vec1` and its elements, so they can be used again\n    println!(\"vec1 len: {}\", vec1.len());\n    println!(\"First element of vec1 is: {}\", vec1[0]);\n    // `into_iter()` does move `vec2` and its elements, so they cannot be used again\n    // println!(\"First element of vec2 is: {}\", vec2[0]);\n    // println!(\"vec2 len: {}\", vec2.len());\n    // TODO: uncomment two lines above and see compiler errors.\n\n    let array1 = [1, 2, 3];\n    let array2 = [4, 5, 6];\n\n    // `iter()` for arrays yields `&i32`.\n    println!(\"2 in array1: {}\", array1.iter()     .any(|&x| x == 2));\n    // `into_iter()` for arrays yields `i32`.\n    println!(\"2 in array2: {}\", array2.into_iter().any(|x| x == 2));\n}\n```\n\n----------------------------------------\n\nTITLE: Using panic for Unrecoverable Errors in Rust\nDESCRIPTION: The panic macro is used for unrecoverable errors, mainly in tests or prototyping. It's recommended to use the more descriptive unimplemented macro for functions not yet implemented.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/error.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npanic!(\"This is an unrecoverable error\");\n```\n\n----------------------------------------\n\nTITLE: Implementing fmt::Display for a List Structure in Rust\nDESCRIPTION: This code snippet demonstrates how to implement the fmt::Display trait for a List structure containing a Vec<i32> in Rust. It uses the ? operator for error handling and iterates over the vector to format its contents.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/hello/print/print_display/testcase_list.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::fmt; // Import the `fmt` module.\n\n// Define a structure named `List` containing a `Vec`.\nstruct List(Vec<i32>);\n\nimpl fmt::Display for List {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        // Extract the value using tuple indexing,\n        // and create a reference to `vec`.\n        let vec = &self.0;\n\n        write!(f, \"[\")?;\n\n        // Iterate over `v` in `vec` while enumerating the iteration\n        // index in `index`.\n        for (index, v) in vec.iter().enumerate() {\n            // For every element except the first, add a comma.\n            // Use the ? operator to return on errors.\n            if index != 0 { write!(f, \", \")? }\n            write!(f, \"{}\", v)?\n        }\n\n        // Close the opened bracket and return a fmt::Result value.\n        write!(f, \"]\")\n    }\n}\n\nfn main() {\n    let v = List(vec![1, 2, 3]);\n    println!(\"{}\", v);\n}\n```\n\n----------------------------------------\n\nTITLE: Shared Test Setup Module\nDESCRIPTION: Implements a common setup function that can be shared across multiple integration tests.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/testing/integration_testing.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\npub fn setup() {\n    // some setup code, like creating required files/directories, starting\n    // servers, etc.\n}\n```\n\n----------------------------------------\n\nTITLE: Collecting Valid and Invalid Results with partition in Rust\nDESCRIPTION: Uses partition to separate successful and failed parsing results into two different collections, both still wrapped in Result.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/error/iter_result.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let strings = vec![\"tofu\", \"93\", \"18\"];\n    let (numbers, errors): (Vec<_>, Vec<_>) = strings\n        .into_iter()\n        .map(|s| s.parse::<i32>())\n        .partition(Result::is_ok);\n    println!(\"Numbers: {:?}\", numbers);\n    println!(\"Errors: {:?}\", errors);\n}\n```\n\n----------------------------------------\n\nTITLE: Running Specific Tests in Rust\nDESCRIPTION: Shows how to run specific tests or groups of tests using cargo test with test name patterns.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/testing/unit_testing.md#2025-04-21_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ cargo test test_any_panic\nrunning 1 test\ntest tests::test_any_panic ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out\n\n   Doc-tests tmp-test-should-panic\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n```\n\nLANGUAGE: shell\nCODE:\n```\n$ cargo test panic\nrunning 2 tests\ntest tests::test_any_panic ... ok\ntest tests::test_specific_panic ... ok\n\ntest result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out\n\n   Doc-tests tmp-test-should-panic\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n```\n\n----------------------------------------\n\nTITLE: Defining a Rust Library Crate with Public and Private Functions\nDESCRIPTION: This snippet demonstrates how to define a library crate using the `crate_type` and `crate_name` attributes. It includes examples of public functions (accessible outside the crate) and private functions (only accessible within the crate), as well as an indirect access function that calls a private function from a public context.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/attribute/crate.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// This crate is a library\n#![crate_type = \"lib\"]\n// The library is named \"rary\"\n#![crate_name = \"rary\"]\n\npub fn public_function() {\n    println!(\"called rary's `public_function()`\");\n}\n\nfn private_function() {\n    println!(\"called rary's `private_function()`\");\n}\n\npub fn indirect_access() {\n    print!(\"called rary's `indirect_access()`, that\\n> \");\n\n    private_function();\n}\n```\n\n----------------------------------------\n\nTITLE: Closure Return with impl Trait\nDESCRIPTION: Example of returning a closure using impl Trait, which allows for static allocation instead of heap allocation. Creates an adder function that adds a fixed value to its input.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/trait/impl_trait.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nfn make_adder_function(y: i32) -> impl Fn(i32) -> i32 {\n    let closure = move |x: i32| { x + y };\n    closure\n}\n\nfn main() {\n    let plus_one = make_adder_function(1);\n    assert_eq!(plus_one(2), 3);\n}\n```\n\n----------------------------------------\n\nTITLE: Suppressing Dead Code Warnings with Attributes in Rust\nDESCRIPTION: This code demonstrates how to manage unused functions in Rust using the #[allow(dead_code)] attribute to suppress compiler warnings. It includes examples of a used function, an unused function with the warning suppressed, and another unused function that will trigger a warning.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/attribute/unused.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn used_function() {}\n\n// `#[allow(dead_code)]` is an attribute that disables the `dead_code` lint\n#[allow(dead_code)]\nfn unused_function() {}\n\nfn noisy_unused_function() {}\n// FIXME ^ Add an attribute to suppress the warning\n\nfn main() {\n    used_function();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Conditional Panic Handling in Rust\nDESCRIPTION: Example showing how to use cfg! macro to check panic strategy and execute different code paths. The function checks the beverage type and responds differently based on the configured panic strategy.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/error/abort_unwind.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn drink(beverage: &str) {\n    // You shouldn't drink too much sugary beverages.\n    if beverage == \"lemonade\" {\n        if cfg!(panic = \"abort\") {\n            println!(\"This is not your party. Run!!!!\");\n        } else {\n            println!(\"Spit it out!!!!\");\n        }\n    } else {\n        println!(\"Some refreshing {} is all I need.\", beverage);\n    }\n}\n\nfn main() {\n    drink(\"water\");\n    drink(\"lemonade\");\n}\n```\n\n----------------------------------------\n\nTITLE: Running Documentation Tests with Cargo in Rust\nDESCRIPTION: Shows how to run documentation tests using the 'cargo test' command, which automatically tests code blocks in documentation comments.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/testing/doc_testing.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ cargo test\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\n   Doc-tests doccomments\n\nrunning 3 tests\ntest src/lib.rs - add (line 7) ... ok\ntest src/lib.rs - div (line 21) ... ok\ntest src/lib.rs - div (line 31) ... ok\n\ntest result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n```\n\n----------------------------------------\n\nTITLE: Using or_else() for Lazy Evaluation in Option Unpacking in Rust\nDESCRIPTION: This example demonstrates the use of or_else() method for chaining fallback options with lazy evaluation. It shows how closures are used to provide fallback values.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/error/option_unwrap/defaults.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Debug)] \nenum Fruit { Apple, Orange, Banana, Kiwi, Lemon }\n\nfn main() {\n    let no_fruit: Option<Fruit> = None;\n    let get_kiwi_as_fallback = || {\n        println!(\"Providing kiwi as fallback\");\n        Some(Fruit::Kiwi)\n    };\n    let get_lemon_as_fallback = || {\n        println!(\"Providing lemon as fallback\");\n        Some(Fruit::Lemon)\n    };\n\n    let first_available_fruit = no_fruit\n        .or_else(get_kiwi_as_fallback)\n        .or_else(get_lemon_as_fallback);\n    println!(\"first_available_fruit: {:?}\", first_available_fruit);\n    // Providing kiwi as fallback\n    // first_available_fruit: Some(Kiwi)\n}\n```\n\n----------------------------------------\n\nTITLE: Using Match Guards with Numbers in Rust\nDESCRIPTION: This example shows how to use match guards with a u8 number. It demonstrates that the compiler doesn't consider guard conditions when checking pattern coverage, requiring an additional catch-all arm for compilation.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/flow_control/match/guard.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let number: u8 = 4;\n\n    match number {\n        i if i == 0 => println!(\"Zero\"),\n        i if i > 0 => println!(\"Greater than zero\"),\n        // _ => unreachable!(\"Should never happen.\"),\n        // TODO ^ uncomment to fix compilation\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Numeric Literals and Memory Sizes in Rust\nDESCRIPTION: Shows how to use suffixed and unsuffixed numeric literals in Rust, and demonstrates checking their memory sizes using std::mem::size_of_val. The example includes integers and floating-point numbers with explicit and implicit type annotations.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/types/literals.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    // Suffixed literals, their types are known at initialization\n    let x = 1u8;\n    let y = 2u32;\n    let z = 3f32;\n\n    // Unsuffixed literals, their types depend on how they are used\n    let i = 1;\n    let f = 1.0;\n\n    // `size_of_val` returns the size of a variable in bytes\n    println!(\"size of `x` in bytes: {}\", std::mem::size_of_val(&x));\n    println!(\"size of `y` in bytes: {}\", std::mem::size_of_val(&y));\n    println!(\"size of `z` in bytes: {}\", std::mem::size_of_val(&z));\n    println!(\"size of `i` in bytes: {}\", std::mem::size_of_val(&i));\n    println!(\"size of `f` in bytes: {}\", std::mem::size_of_val(&f));\n}\n```\n\n----------------------------------------\n\nTITLE: Using transpose for Result and Option Swapping in Rust\nDESCRIPTION: This snippet shows how to use the transpose function to swap Result and Option, allowing for more flexible error handling. It modifies the double_first function to return Result<Option<i32>, ParseIntError>, enabling easier error propagation.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/error/multiple_error_types/option_result.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::num::ParseIntError;\n\nfn double_first(vec: Vec<&str>) -> Result<Option<i32>, ParseIntError> {\n    let opt = vec.first().map(|first| {\n        first.parse::<i32>().map(|n| 2 * n)\n    });\n\n    opt.transpose()\n}\n\nfn main() {\n    let numbers = vec![\"42\", \"93\", \"18\"];\n    let empty = vec![];\n    let strings = vec![\"tofu\", \"93\", \"18\"];\n\n    println!(\"The first doubled is {:?}\", double_first(numbers));\n    println!(\"The first doubled is {:?}\", double_first(empty));\n    println!(\"The first doubled is {:?}\", double_first(strings));\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Command and Handling Output in Rust\nDESCRIPTION: Shows how to execute the 'rustc' command with arguments using Command::new(), capture its output, and handle both success and error cases. The example demonstrates proper error handling and UTF-8 string conversion from command output.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/std_misc/process.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::process::Command;\n\nfn main() {\n    let output = Command::new(\"rustc\")\n        .arg(\"--version\")\n        .output().unwrap_or_else(|e| {\n            panic!(\"failed to execute process: {}\", e)\n    });\n\n    if output.status.success() {\n        let s = String::from_utf8_lossy(&output.stdout);\n\n        print!(\"rustc succeeded and stdout was:\\n{}\", s);\n    } else {\n        let s = String::from_utf8_lossy(&output.stderr);\n\n        print!(\"rustc failed and stderr was:\\n{}\", s);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Handling in Documentation Tests for Rust\nDESCRIPTION: Demonstrates how to handle errors in documentation tests by using a hidden 'try_main' function that returns a Result, allowing the use of the '?' operator in examples.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/testing/doc_testing.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n/// Using hidden `try_main` in doc tests.\n///\n/// ```\n/// # // hidden lines start with `#` symbol, but they're still compilable!\n/// # fn try_main() -> Result<(), String> { // line that wraps the body shown in doc\n/// let res = doccomments::try_div(10, 2)?;\n/// # Ok(()) // returning from try_main\n/// # }\n/// # fn main() { // starting main that'll unwrap()\n/// #    try_main().unwrap(); // calling try_main and unwrapping\n/// #                         // so that test will panic in case of error\n/// # }\n/// ```\npub fn try_div(a: i32, b: i32) -> Result<i32, String> {\n    if b == 0 {\n        Err(String::from(\"Divide-by-zero\"))\n    } else {\n        Ok(a / b)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Rust Program Structure with Statements\nDESCRIPTION: Shows the fundamental structure of a Rust program consisting of a series of statements inside the main function.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/expression.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    // statement\n    // statement\n    // statement\n}\n```\n\n----------------------------------------\n\nTITLE: Calling Unsafe Functions in Rust\nDESCRIPTION: Shows how to use unsafe functions in Rust, specifically demonstrating the std::slice::from_raw_parts function. Creates a slice from a vector's raw pointer and length, highlighting the programmer's responsibility for memory safety.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/unsafe.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::slice;\n\nfn main() {\n    let some_vector = vec![1, 2, 3, 4];\n\n    let pointer = some_vector.as_ptr();\n    let length = some_vector.len();\n\n    unsafe {\n        let my_slice: &[u32] = slice::from_raw_parts(pointer, length);\n\n        assert_eq!(some_vector.as_slice(), my_slice);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Input/Output Assembly Operations in Rust\nDESCRIPTION: Shows how to write a value to a variable using inline assembly with output operands.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/unsafe/asm.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::arch::asm;\n\nlet x: u64;\nunsafe {\n    asm!(\"mov {}, 5\", out(reg) x);\n}\nassert_eq!(x, 5);\n```\n\n----------------------------------------\n\nTITLE: Initializing Basic Variable Bindings in Rust\nDESCRIPTION: Shows various ways to create variable bindings in Rust, including integers, booleans, and unit types. Demonstrates variable copying and handling of unused variables using underscore prefix.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/variable_bindings.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let an_integer = 1u32;\n    let a_boolean = true;\n    let unit = ();\n\n    // copy `an_integer` into `copied_integer`\n    let copied_integer = an_integer;\n\n    println!(\"An integer: {:?}\", copied_integer);\n    println!(\"A boolean: {:?}\", a_boolean);\n    println!(\"Meet the unit value: {:?}\", unit);\n\n    // The compiler warns about unused variable bindings; these warnings can\n    // be silenced by prefixing the variable name with an underscore\n    let _unused_variable = 3u32;\n\n    let noisy_unused_variable = 2u32;\n    // FIXME ^ Prefix with an underscore to suppress the warning\n    // Please note that warnings may not be shown in a browser\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Result Collection in Rust\nDESCRIPTION: Demonstrates the basic attempt to parse strings into integers using map and collect, showing how Results are handled in a collection.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/error/iter_result.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let strings = vec![\"tofu\", \"93\", \"18\"];\n    let numbers: Vec<_> = strings\n        .into_iter()\n        .map(|s| s.parse::<i32>())\n        .collect();\n    println!(\"Results: {:?}\", numbers);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Handling with Match Statements in Rust\nDESCRIPTION: This snippet demonstrates error handling for string parsing by using nested match statements to handle potential parsing errors. It includes a multiply function that returns Result<i32, ParseIntError> and a helper function to print the result.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/error/result/result_map.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::num::ParseIntError;\n\n// With the return type rewritten, we use pattern matching without `unwrap()`.\nfn multiply(first_number_str: &str, second_number_str: &str) -> Result<i32, ParseIntError> {\n    match first_number_str.parse::<i32>() {\n        Ok(first_number)  => {\n            match second_number_str.parse::<i32>() {\n                Ok(second_number)  => {\n                    Ok(first_number * second_number)\n                },\n                Err(e) => Err(e),\n            }\n        },\n        Err(e) => Err(e),\n    }\n}\n\nfn print(result: Result<i32, ParseIntError>) {\n    match result {\n        Ok(n)  => println!(\"n is {}\", n),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n\nfn main() {\n    // This still presents a reasonable answer.\n    let twenty = multiply(\"10\", \"2\");\n    print(twenty);\n\n    // The following now provides a much more helpful error message.\n    let tt = multiply(\"t\", \"2\");\n    print(tt);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing FizzBuzz using inclusive range in Rust\nDESCRIPTION: This snippet shows an alternative implementation of FizzBuzz using an inclusive range (1..=100) in Rust. It demonstrates the use of the ..= operator to include both start and end values in the range.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/flow_control/for.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    // `n` will take the values: 1, 2, ..., 100 in each iteration\n    for n in 1..=100 {\n        if n % 15 == 0 {\n            println!(\"fizzbuzz\");\n        } else if n % 3 == 0 {\n            println!(\"fizz\");\n        } else if n % 5 == 0 {\n            println!(\"buzz\");\n        } else {\n            println!(\"{}\", n);\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using @ Binding with Option Enum in Rust\nDESCRIPTION: This example shows how to use binding to destructure enum variants, specifically an Option type. The @ operator is used to bind the inner value of Some variant while simultaneously checking if it equals 42.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/flow_control/match/binding.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn some_number() -> Option<u32> {\n    Some(42)\n}\n\nfn main() {\n    match some_number() {\n        // Got `Some` variant, match if its value, bound to `n`,\n        // is equal to 42.\n        Some(n @ 42) => println!(\"The Answer: {}!\", n),\n        // Match any other number.\n        Some(n)      => println!(\"Not interesting... {}\", n),\n        // Match anything else (`None` variant).\n        _            => (),\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Reading CPU Manufacturer ID Using CPUID in Rust\nDESCRIPTION: Demonstrates using the CPUID instruction to read the CPU manufacturer ID. Handles register preservation (especially ebx) and proper memory management through unsafe blocks.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/unsafe/asm.md#2025-04-21_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n#[cfg(target_arch = \"x86_64\")]\nfn main() {\n    let mut name_buf = [0_u8; 12];\n    unsafe {\n        asm!(\n            \"push rbx\",\n            \"cpuid\",\n            \"mov [rdi], ebx\",\n            \"mov [rdi + 4], edx\",\n            \"mov [rdi + 8], ecx\",\n            \"pop rbx\",\n            in(\"rdi\") name_buf.as_mut_ptr(),\n            inout(\"eax\") 0 => _,\n            out(\"ecx\") _,\n            out(\"edx\") _,\n        );\n    }\n    let name = core::str::from_utf8(&name_buf).unwrap();\n    println!(\"CPU Manufacturer ID: {}\", name);\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Variable Scope in Rust\nDESCRIPTION: This snippet shows how variable bindings have different scopes in Rust. It illustrates a long-lived binding in the main function and a short-lived binding within a nested block. The code also demonstrates that variables are not accessible outside their scope.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/variable_bindings/scope.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    // This binding lives in the main function\n    let long_lived_binding = 1;\n\n    // This is a block, and has a smaller scope than the main function\n    {\n        // This binding only exists in this block\n        let short_lived_binding = 2;\n\n        println!(\"inner short: {}\", short_lived_binding);\n    }\n    // End of the block\n\n    // Error! `short_lived_binding` doesn't exist in this scope\n    println!(\"outer short: {}\", short_lived_binding);\n    // FIXME ^ Comment out this line\n\n    println!(\"outer long: {}\", long_lived_binding);\n}\n```\n\n----------------------------------------\n\nTITLE: Using ? Operator with write! Macro in Rust\nDESCRIPTION: This snippet demonstrates how to use the ? operator with the write! macro for error handling in Rust. It shows how to write a value to a formatter and propagate any errors that occur.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/hello/print/print_display/testcase_list.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// Try `write!` to see if it errors. If it errors, return\n// the error. Otherwise continue.\nwrite!(f, \"{}\", value)?\n```\n\n----------------------------------------\n\nTITLE: Defining a Diverging Function in Rust\nDESCRIPTION: A simple example of a diverging function in Rust that never returns. It uses the panic! macro to terminate execution and is marked with the ! return type.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/fn/diverging.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn foo() -> ! {\n    panic!(\"This call never returns.\");\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a loop with match pattern matching in Rust\nDESCRIPTION: This example demonstrates using a match statement within a loop to handle an Option<i32>. It increments a value until it exceeds 9, showing the verbose syntax required for pattern matching in a loop.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/flow_control/while_let.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// Make `optional` of type `Option<i32>`\nlet mut optional = Some(0);\n\n// Repeatedly try this test.\nloop {\n    match optional {\n        // If `optional` destructures, evaluate the block.\n        Some(i) => {\n            if i > 9 {\n                println!(\"Greater than 9, quit!\");\n                optional = None;\n            } else {\n                println!(\"`i` is `{:?}`. Try again.\", i);\n                optional = Some(i + 1);\n            }\n            // ^ Requires 3 indentations!\n        },\n        // Quit the loop when the destructure fails:\n        _ => { break; }\n        // ^ Why should this be required? There must be a better way!\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Inline Assembly Usage in Rust\nDESCRIPTION: Demonstrates the simplest possible inline assembly example using the asm! macro to insert a NOP instruction.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/unsafe/asm.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::arch::asm;\n\nunsafe {\n    asm!(\"nop\");\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Overloaded Macro for Logical Operations in Rust\nDESCRIPTION: Creates a test macro that accepts two different patterns of arguments to perform logical AND and OR operations. The macro uses stringify! to print the expressions as strings and evaluates the logical operations between the provided expressions.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/macros/overload.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// `test!` will compare `$left` and `$right`\n// in different ways depending on how you invoke it:\nmacro_rules! test {\n    // Arguments don't need to be separated by a comma.\n    // Any template can be used!\n    ($left:expr; and $right:expr) => {\n        println!(\"{:?} and {:?} is {:?}\",\n                 stringify!($left),\n                 stringify!($right),\n                 $left && $right)\n    };\n    // ^ each arm must end with a semicolon.\n    ($left:expr; or $right:expr) => {\n        println!(\"{:?} or {:?} is {:?}\",\n                 stringify!($left),\n                 stringify!($right),\n                 $left || $right)\n    };\n}\n\nfn main() {\n    test!(1i32 + 1 == 2i32; and 2i32 * 2 == 4i32);\n    test!(true; or false);\n}\n```\n\n----------------------------------------\n\nTITLE: Explicit Register Assembly Operations\nDESCRIPTION: Shows how to use explicit register constraints for instructions that require specific registers.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/unsafe/asm.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nuse std::arch::asm;\n\nlet cmd = 0xd1;\nunsafe {\n    asm!(\"out 0x64, eax\", in(\"eax\") cmd);\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Lifetime Coercion in Rust\nDESCRIPTION: This example illustrates how Rust handles lifetime coercion. It shows two functions: 'multiply' where Rust infers a common lifetime, and 'choose_first' which explicitly declares a relationship between lifetimes. The main function demonstrates these concepts with variables of different scopes.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/scope/lifetime/lifetime_coercion.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// Here, Rust infers a lifetime that is as short as possible.\n// The two references are then coerced to that lifetime.\nfn multiply<'a>(first: &'a i32, second: &'a i32) -> i32 {\n    first * second\n}\n\n// `<'a: 'b, 'b>` reads as lifetime `'a` is at least as long as `'b`.\n// Here, we take in an `&'a i32` and return a `&'b i32` as a result of coercion.\nfn choose_first<'a: 'b, 'b>(first: &'a i32, _: &'b i32) -> &'b i32 {\n    first\n}\n\nfn main() {\n    let first = 2; // Longer lifetime\n    \n    {\n        let second = 3; // Shorter lifetime\n        \n        println!(\"The product is {}\", multiply(&first, &second));\n        println!(\"{} is the first\", choose_first(&first, &second));\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Error Handling with the try! Macro in Rust (Pre-2018 Edition)\nDESCRIPTION: This example shows the older try! macro approach for error handling, which was the predecessor to the ? operator. It performs the same function of propagating errors up the call stack when encountering Result::Err values.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/error/result/enter_question_mark.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// To compile and run this example without errors, while using Cargo, change the value \n// of the `edition` field, in the `[package]` section of the `Cargo.toml` file, to \"2015\".\n\nuse std::num::ParseIntError;\n\nfn multiply(first_number_str: &str, second_number_str: &str) -> Result<i32, ParseIntError> {\n    let first_number = try!(first_number_str.parse::<i32>());\n    let second_number = try!(second_number_str.parse::<i32>());\n\n    Ok(first_number * second_number)\n}\n\nfn print(result: Result<i32, ParseIntError>) {\n    match result {\n        Ok(n)  => println!(\"n is {}\", n),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n\nfn main() {\n    print(multiply(\"10\", \"2\"));\n    print(multiply(\"t\", \"2\"));\n}\n```\n\n----------------------------------------\n\nTITLE: Expected Output of Rust Filesystem Operations\nDESCRIPTION: This shell snippet shows the expected successful output when running the Rust program that performs various filesystem operations. It demonstrates the creation of directories, files, and symbolic links, as well as reading and listing contents.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/std_misc/fs.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ rustc fs.rs && ./fs\n`mkdir a`\n`echo hello > a/b.txt`\n`mkdir -p a/c/d`\n`touch a/c/e.txt`\n`ln -s ../b.txt a/c/b.txt`\n`cat a/c/b.txt`\n> hello\n`ls a`\n> \"a/b.txt\"\n> \"a/c\"\n`rm a/c/e.txt`\n`rmdir a/c/d`\n```\n\n----------------------------------------\n\nTITLE: Using let-else for Pattern Matching in Rust\nDESCRIPTION: Demonstrates the let-else pattern for extracting and validating data from a string. The function splits a string into a count and item, performing validation with divergent else paths using panic! when patterns don't match or parsing fails.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/flow_control/let_else.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::str::FromStr;\n\nfn get_count_item(s: &str) -> (u64, &str) {\n    let mut it = s.split(' ');\n    let (Some(count_str), Some(item)) = (it.next(), it.next()) else {\n        panic!(\"Can't segment count item pair: '{s}'\");\n    };\n    let Ok(count) = u64::from_str(count_str) else {\n        panic!(\"Can't parse integer: '{count_str}'\");\n    };\n    (count, item)\n}\n\nfn main() {\n    assert_eq!(get_count_item(\"3 chairs\"), (3, \"chairs\"));\n}\n```\n\n----------------------------------------\n\nTITLE: Function Calling with ABI Clobbers\nDESCRIPTION: Example showing how to call a C function from inline assembly with proper ABI clobber handling. Demonstrates register allocation for arguments and return values.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/unsafe/asm.md#2025-04-21_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nextern \"C\" fn foo(arg: i32) -> i32 {\n    println!(\"arg = {}\", arg);\n    arg * 2\n}\n\nfn call_foo(arg: i32) -> i32 {\n    unsafe {\n        let result;\n        asm!(\n            \"call {}\",\n            in(reg) foo,\n            in(\"rdi\") arg,\n            out(\"rax\") result,\n            clobber_abi(\"C\"),\n        );\n        result\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic Trait Contains for Container Type in Rust\nDESCRIPTION: Demonstrates implementation of a generic Contains trait for a Container struct, showing how generic type parameters must be explicitly specified. The example includes a Container struct storing two i32 values, a Contains trait with generic types A and B, and implementation of trait methods for checking containment and accessing values.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/generics/assoc_items/the_problem.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Container(i32, i32);\n\n// A trait which checks if 2 items are stored inside of container.\n// Also retrieves first or last value.\ntrait Contains<A, B> {\n    fn contains(&self, _: &A, _: &B) -> bool; // Explicitly requires `A` and `B`.\n    fn first(&self) -> i32; // Doesn't explicitly require `A` or `B`.\n    fn last(&self) -> i32;  // Doesn't explicitly require `A` or `B`.\n}\n\nimpl Contains<i32, i32> for Container {\n    // True if the numbers stored are equal.\n    fn contains(&self, number_1: &i32, number_2: &i32) -> bool {\n        (&self.0 == number_1) && (&self.1 == number_2)\n    }\n\n    // Grab the first number.\n    fn first(&self) -> i32 { self.0 }\n\n    // Grab the last number.\n    fn last(&self) -> i32 { self.1 }\n}\n\n// `C` contains `A` and `B`. In light of that, having to express `A` and\n// `B` again is a nuisance.\nfn difference<A, B, C>(container: &C) -> i32 where\n    C: Contains<A, B> {\n    container.last() - container.first()\n}\n\nfn main() {\n    let number_1 = 3;\n    let number_2 = 10;\n\n    let container = Container(number_1, number_2);\n\n    println!(\"Does container contain {} and {}: {}\",\n        &number_1, &number_2,\n        container.contains(&number_1, &number_2));\n    println!(\"First number: {}\", container.first());\n    println!(\"Last number: {}\", container.last());\n\n    println!(\"The difference is: {}\", difference(&container));\n}\n```\n\n----------------------------------------\n\nTITLE: Complex Display and Debug Implementation Example\nDESCRIPTION: Shows a more comprehensive example implementing fmt::Display for multiple struct types (MinMax and Point2D). Demonstrates comparison between Debug and Display outputs, and includes various formatting examples in the main function.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/hello/print/print_display.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::fmt;\n\n#[derive(Debug)]\nstruct MinMax(i64, i64);\n\nimpl fmt::Display for MinMax {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"({}, {})\", self.0, self.1)\n    }\n}\n\n#[derive(Debug)]\nstruct Point2D {\n    x: f64,\n    y: f64,\n}\n\nimpl fmt::Display for Point2D {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"x: {}, y: {}\", self.x, self.y)\n    }\n}\n\nfn main() {\n    let minmax = MinMax(0, 14);\n\n    println!(\"Compare structures:\");\n    println!(\"Display: {}\", minmax);\n    println!(\"Debug: {:?}\", minmax);\n\n    let big_range =   MinMax(-300, 300);\n    let small_range = MinMax(-3, 3);\n\n    println!(\"The big range is {big} and the small is {small}\",\n             small = small_range,\n             big = big_range);\n\n    let point = Point2D { x: 3.3, y: 7.2 };\n\n    println!(\"Compare points:\");\n    println!(\"Display: {}\", point);\n    println!(\"Debug: {:?}\", point);\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Implementation of read_lines Function in Rust\nDESCRIPTION: A naive approach to reading lines from a file using read_to_string. It reads the entire file into memory and then iterates over the lines, pushing each line into a vector.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/std_misc/file/read_lines.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::fs::read_to_string;\n\nfn read_lines(filename: &str) -> Vec<String> {\n    let mut result = Vec::new();\n\n    for line in read_to_string(filename).unwrap().lines() {\n        result.push(line.to_string())\n    }\n\n    result\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Generic Function with FnOnce Bound for Closures in Rust\nDESCRIPTION: A basic example showing how to define a generic function that accepts closures. The function uses an 'F' type parameter bounded by FnOnce trait, allowing it to accept any closure that can be called once.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/fn/closures/anonymity.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// `F` must be generic.\nfn apply<F>(f: F) where\n    F: FnOnce() {\n    f();\n}\n```\n\n----------------------------------------\n\nTITLE: Complex Register Usage in Assembly\nDESCRIPTION: Demonstrates complex use of explicit registers for 128-bit multiplication using mul instruction.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/unsafe/asm.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nuse std::arch::asm;\n\nfn mul(a: u64, b: u64) -> u128 {\n    let lo: u64;\n    let hi: u64;\n\n    unsafe {\n        asm!(\n            \"mul {}\",\n            in(reg) a,\n            inlateout(\"rax\") b => lo,\n            lateout(\"rdx\") hi\n        );\n    }\n\n    ((hi as u128) << 64) + lo as u128\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Display Trait for City and Color Structs in Rust\nDESCRIPTION: Demonstrates custom string formatting by implementing the Display trait for a City struct that formats geographic coordinates, and includes a Color struct setup for RGB values. Shows iteration over arrays of structs and different printing formats.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/hello/print/fmt.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::fmt::{self, Formatter, Display};\n\nstruct City {\n    name: &'static str,\n    // Latitude\n    lat: f32,\n    // Longitude\n    lon: f32,\n}\n\nimpl Display for City {\n    // `f` is a buffer, and this method must write the formatted string into it.\n    fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n        let lat_c = if self.lat >= 0.0 { 'N' } else { 'S' };\n        let lon_c = if self.lon >= 0.0 { 'E' } else { 'W' };\n\n        // `write!` is like `format!`, but it will write the formatted string\n        // into a buffer (the first argument).\n        write!(f, \"{}: {:.3}°{} {:.3}°{}\",\n               self.name, self.lat.abs(), lat_c, self.lon.abs(), lon_c)\n    }\n}\n\n#[derive(Debug)]\nstruct Color {\n    red: u8,\n    green: u8,\n    blue: u8,\n}\n\nfn main() {\n    for city in [\n        City { name: \"Dublin\", lat: 53.347778, lon: -6.259722 },\n        City { name: \"Oslo\", lat: 59.95, lon: 10.75 },\n        City { name: \"Vancouver\", lat: 49.25, lon: -123.1 },\n    ] {\n        println!(\"{}\", city);\n    }\n    for color in [\n        Color { red: 128, green: 255, blue: 90 },\n        Color { red: 0, green: 3, blue: 254 },\n        Color { red: 0, green: 0, blue: 0 },\n    ] {\n        // Switch this to use {} once you've added an implementation\n        // for fmt::Display.\n        println!(\"{:?}\", color);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Blocks as Expressions in Rust Assignments\nDESCRIPTION: Illustrates how code blocks can serve as expressions whose values can be assigned to variables. The last expression in a block becomes its return value, unless it ends with a semicolon, in which case the block returns the unit value ().\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/expression.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let x = 5u32;\n\n    let y = {\n        let x_squared = x * x;\n        let x_cube = x_squared * x;\n\n        // This expression will be assigned to `y`\n        x_cube + x_squared + x\n    };\n\n    let z = {\n        // The semicolon suppresses this expression and `()` is assigned to `z`\n        2 * x;\n    };\n\n    println!(\"x is {:?}\", x);\n    println!(\"y is {:?}\", y);\n    println!(\"z is {:?}\", z);\n}\n```\n\n----------------------------------------\n\nTITLE: Advanced Use Declaration with Aliases in Rust\nDESCRIPTION: Shows how to use the 'as' keyword to create aliases for imported items and demonstrates scope shadowing within blocks using the 'use' declaration.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/mod/use.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// Bind the `deeply::nested::function` path to `other_function`.\nuse deeply::nested::function as other_function;\n\nfn function() {\n    println!(\"called `function()`\");\n}\n\nmod deeply {\n    pub mod nested {\n        pub fn function() {\n            println!(\"called `deeply::nested::function()`\");\n        }\n    }\n}\n\nfn main() {\n    // Easier access to `deeply::nested::function`\n    other_function();\n\n    println!(\"Entering block\");\n    {\n        // This is equivalent to `use deeply::nested::function as function`.\n        // This `function()` will shadow the outer one.\n        use crate::deeply::nested::function;\n\n        // `use` bindings have a local scope. In this case, the\n        // shadowing of `function()` is only in this block.\n        function();\n\n        println!(\"Leaving block\");\n    }\n\n    function();\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Dev Dependencies in Cargo.toml\nDESCRIPTION: Example of adding a development dependency (pretty_assertions) to a Rust project's Cargo.toml file. Dev dependencies are only used for tests, examples, or benchmarks and aren't propagated to dependent packages.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/testing/dev_dependencies.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n# standard crate data is left out\n[dev-dependencies]\npretty_assertions = \"1\"\n```\n\n----------------------------------------\n\nTITLE: Basic Static Reference Examples in Rust\nDESCRIPTION: Demonstrates two common uses of 'static lifetime: reference lifetime and trait bound. Shows basic syntax for static string references and generic function with static bound.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/scope/lifetime/static_lifetime.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// A reference with 'static lifetime:\nlet s: &'static str = \"hello world\";\n\n// 'static as part of a trait bound:\nfn generic<T>(x: T) where T: 'static {}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Lifetime Elision in Rust Functions\nDESCRIPTION: This code snippet illustrates lifetime elision in Rust by comparing functions with explicit lifetime annotations to those without. It shows how the compiler can infer lifetimes for function parameters and return values in common patterns.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/scope/lifetime/elision.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// `elided_input` and `annotated_input` essentially have identical signatures\n// because the lifetime of `elided_input` is inferred by the compiler:\nfn elided_input(x: &i32) {\n    println!(\"`elided_input`: {}\", x);\n}\n\nfn annotated_input<'a>(x: &'a i32) {\n    println!(\"`annotated_input`: {}\", x);\n}\n\n// Similarly, `elided_pass` and `annotated_pass` have identical signatures\n// because the lifetime is added implicitly to `elided_pass`:\nfn elided_pass(x: &i32) -> &i32 { x }\n\nfn annotated_pass<'a>(x: &'a i32) -> &'a i32 { x }\n\nfn main() {\n    let x = 3;\n\n    elided_input(&x);\n    annotated_input(&x);\n\n    println!(\"`elided_pass`: {}\", elided_pass(&x));\n    println!(\"`annotated_pass`: {}\", annotated_pass(&x));\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Add Trait Structure in Rust\nDESCRIPTION: Definition of the Add trait showing the basic structure for implementing addition operations in Rust. Shows the trait's generic parameter RHS and associated Output type.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/generics/phantom/testcase_units.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub trait Add<RHS = Self> {\n    type Output;\n\n    fn add(self, rhs: RHS) -> Self::Output;\n}\n\n// `Output` must be `T<U>` so that `T<U> + T<U> = T<U>`.\nimpl<U> Add for T<U> {\n    type Output = T<U>;\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Struct with an Outer Attribute in Rust\nDESCRIPTION: Example of using the outer attribute #[derive(Debug)] to implement the Debug trait for a Rectangle struct. The attribute is placed before the struct definition and applies only to that struct.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/attribute.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n```\n\n----------------------------------------\n\nTITLE: Raw String Literals in Rust\nDESCRIPTION: This example shows how to use raw string literals in Rust to avoid escaping characters. It demonstrates basic raw strings with the r prefix and how to include quote characters using hash delimiters of varying levels.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/std/str.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let raw_str = r\"Escapes don't work here: \\x3F \\u{211D}\";\n    println!(\"{}\", raw_str);\n\n    // If you need quotes in a raw string, add a pair of #s\n    let quotes = r#\"And then I said: \"There is no escape!\"\"#;\n    println!(\"{}\", quotes);\n\n    // If you need \"# in your string, just use more #s in the delimiter.\n    // You can use up to 255 #s.\n    let longer_delimiter = r###\"A string with \"# in it. And even \"##!\"###;\n    println!(\"{}\", longer_delimiter);\n}\n```\n\n----------------------------------------\n\nTITLE: Shell Commands for Testing File Operations\nDESCRIPTION: Demonstrates the shell commands to create a test file and run the Rust program, showing the expected output when reading the file contents.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/std_misc/file/open.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ echo \"Hello World!\" > hello.txt\n$ rustc open.rs && ./open\nhello.txt contains:\nHello World!\n```\n\n----------------------------------------\n\nTITLE: Static Trait Bounds in Rust\nDESCRIPTION: Demonstrates how 'static trait bounds work with owned data versus references. Shows that owned data satisfies 'static bound but references typically don't.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/scope/lifetime/static_lifetime.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse std::fmt::Debug;\n\nfn print_it( input: impl Debug + 'static ) {\n    println!( \"'static value passed in is: {:?}\", input );\n}\n\nfn main() {\n    // i is owned and contains no references, thus it's 'static:\n    let i = 5;\n    print_it(i);\n\n    // oops, &i only has the lifetime defined by the scope of\n    // main(), so it's not 'static:\n    print_it(&i);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Conditionally Compiled Functions in Rust\nDESCRIPTION: This code demonstrates how to create a function that will only be compiled when a specific condition is met. The condition 'some_condition' is a custom flag that must be explicitly passed to the Rust compiler.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/attribute/cfg/custom.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[cfg(some_condition)]\nfn conditional_function() {\n    println!(\"condition met!\");\n}\n\nfn main() {\n    conditional_function();\n}\n```\n\n----------------------------------------\n\nTITLE: Using Raw Pointers in Rust\nDESCRIPTION: Demonstrates how to work with raw pointers in Rust using unsafe blocks. Shows the creation of a raw pointer from a reference and safely dereferencing it within an unsafe block.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/unsafe.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let raw_p: *const u32 = &10;\n\n    unsafe {\n        assert!(*raw_p == 10);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using cfg Attributes for Panic Strategy Selection\nDESCRIPTION: Alternative implementation using cfg attributes to conditionally compile functions based on panic strategy. Demonstrates how to create separate function implementations for different panic configurations.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/error/abort_unwind.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[cfg(panic = \"unwind\")]\nfn ah() {\n    println!(\"Spit it out!!!!\");\n}\n\n#[cfg(not(panic = \"unwind\"))]\nfn ah() {\n    println!(\"This is not your party. Run!!!!\");\n}\n\nfn drink(beverage: &str) {\n    if beverage == \"lemonade\" {\n        ah();\n    } else {\n        println!(\"Some refreshing {} is all I need.\", beverage);\n    }\n}\n\nfn main() {\n    drink(\"water\");\n    drink(\"lemonade\");\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Generic Function in Rust\nDESCRIPTION: This snippet demonstrates how to define a generic function named 'foo' that takes an argument of any type T. It illustrates the basic syntax for declaring generic type parameters.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/generics.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn foo<T>(arg: T) { ... }\n```\n\n----------------------------------------\n\nTITLE: Vector Combination with Iterator Return Types\nDESCRIPTION: Demonstrates two implementations of vector combination functions - one with explicit return type and another using impl Trait. Shows how impl Trait can simplify complex iterator type signatures.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/trait/impl_trait.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse std::iter;\nuse std::vec::IntoIter;\n\nfn combine_vecs_explicit_return_type(\n    v: Vec<i32>,\n    u: Vec<i32>,\n) -> iter::Cycle<iter::Chain<IntoIter<i32>, IntoIter<i32>>> {\n    v.into_iter().chain(u.into_iter()).cycle()\n}\n\nfn combine_vecs(\n    v: Vec<i32>,\n    u: Vec<i32>,\n) -> impl Iterator<Item=i32> {\n    v.into_iter().chain(u.into_iter()).cycle()\n}\n\nfn main() {\n    let v1 = vec![1, 2, 3];\n    let v2 = vec![4, 5];\n    let mut v3 = combine_vecs(v1, v2);\n    assert_eq!(Some(1), v3.next());\n    assert_eq!(Some(2), v3.next());\n    assert_eq!(Some(3), v3.next());\n    assert_eq!(Some(4), v3.next());\n    assert_eq!(Some(5), v3.next());\n    println!(\"all done\");\n}\n```\n\n----------------------------------------\n\nTITLE: Shell Commands for Testing read_lines Implementation in Rust\nDESCRIPTION: Shell commands to create a test file and run the Rust program that reads lines from the file. It demonstrates how to compile and execute the Rust code.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/std_misc/file/read_lines.md#2025-04-21_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ echo -e \"127.0.0.1\\n192.168.0.1\\n\" > hosts.txt\n$ rustc read_lines.rs && ./read_lines\n```\n\n----------------------------------------\n\nTITLE: Implementing Documented Person Struct in Rust\nDESCRIPTION: Demonstrates documentation comments usage in Rust with a Person struct implementation. Shows proper documentation formatting, including examples and markdown support in doc comments.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/meta/doc.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![crate_name = \"doc\"]\n\n/// A human being is represented here\npub struct Person {\n    /// A person must have a name, no matter how much Juliet may hate it\n    name: String,\n}\n\nimpl Person {\n    /// Creates a person with the given name.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// // You can have rust code between fences inside the comments\n    /// // If you pass --test to `rustdoc`, it will even test it for you!\n    /// use doc::Person;\n    /// let person = Person::new(\"name\");\n    /// ```\n    pub fn new(name: &str) -> Person {\n        Person {\n            name: name.to_string(),\n        }\n    }\n\n    /// Gives a friendly hello!\n    ///\n    /// Says \"Hello, [name](Person::name)\" to the `Person` it is called on.\n    pub fn hello(&self) {\n        println!(\"Hello, {}!\", self.name);\n    }\n}\n\nfn main() {\n    let john = Person::new(\"John\");\n\n    john.hello();\n}\n```\n\n----------------------------------------\n\nTITLE: Using Raw Identifiers to Access a Function Named After a Keyword\nDESCRIPTION: This snippet demonstrates the proper way to use a raw identifier with the 'r#' prefix to access a function that has the same name as a Rust keyword. This allows calling the 'try' function from the 'foo' crate despite 'try' being a keyword in newer Rust editions.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/compatibility/raw_identifiers.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nextern crate foo;\n\nfn main() {\n    foo::r#try();\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Newtype Inner Values in Rust\nDESCRIPTION: This snippet shows how to access the underlying primitive value from a newtype using two different approaches: tuple index notation and destructuring pattern matching.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/generics/new_types.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct Years(i64);\n\nfn main() {\n    let years = Years(42);\n    let years_as_primitive_1: i64 = years.0; // Tuple\n    let Years(years_as_primitive_2) = years; // Destructuring\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Panics in Rust\nDESCRIPTION: Demonstrates how to test functions that should panic under certain conditions using the #[should_panic] attribute, including checking for specific panic messages.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/testing/unit_testing.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\npub fn divide_non_zero_result(a: u32, b: u32) -> u32 {\n    if b == 0 {\n        panic!(\"Divide-by-zero error\");\n    } else if a < b {\n        panic!(\"Divide result is zero\");\n    }\n    a / b\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_divide() {\n        assert_eq!(divide_non_zero_result(10, 2), 5);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_any_panic() {\n        divide_non_zero_result(1, 0);\n    }\n\n    #[test]\n    #[should_panic(expected = \"Divide result is zero\")]\n    fn test_specific_panic() {\n        divide_non_zero_result(1, 10);\n    }\n}\n```\n\nLANGUAGE: shell\nCODE:\n```\n$ cargo test\n\nrunning 3 tests\ntest tests::test_any_panic ... ok\ntest tests::test_divide ... ok\ntest tests::test_specific_panic ... ok\n\ntest result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\n   Doc-tests tmp-test-should-panic\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Rust Module Component Types\nDESCRIPTION: Shows the different types of components that can be included within a Rust module, including functions, structs, traits, impl blocks, and other modules.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/mod.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nimpl\n```\n\n----------------------------------------\n\nTITLE: Using Iterator::position to find indices in Rust\nDESCRIPTION: Demonstrates how to use Iterator::position to find the index of the first element that matches a condition, contrasting with find which returns the element itself. Shows how to handle references with both iter() and into_iter().\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/fn/closures/closure_examples/iter_find.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let vec = vec![1, 9, 3, 3, 13, 2];\n\n    // `iter()` for vecs yields `&i32` and `position()` does not take a reference, so\n    // we have to destructure `&i32` to `i32`\n    let index_of_first_even_number = vec.iter().position(|&x| x % 2 == 0);\n    assert_eq!(index_of_first_even_number, Some(5));\n    \n    // `into_iter()` for vecs yields `i32` and `position()` does not take a reference, so\n    // we do not have to destructure    \n    let index_of_first_negative_number = vec.into_iter().position(|x| x < 0);\n    assert_eq!(index_of_first_negative_number, None);\n}\n```\n\n----------------------------------------\n\nTITLE: Actual File Output With Concurrent Test Execution\nDESCRIPTION: The actual interleaved file content when tests run concurrently, demonstrating how race conditions can affect test output.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/cargo/test.md#2025-04-21_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\n$ cargo test test_file && cat ferris.txt\nCorro\nFerris\nCorro\nFerris\nCorro\nFerris\nCorro\nFerris\nCorro\nFerris\n```\n\n----------------------------------------\n\nTITLE: Executing and Verifying File Creation in Shell\nDESCRIPTION: This shell snippet shows how to compile and run the Rust program, and then verify the contents of the created file using the cat command.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/std_misc/file/create.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ rustc create.rs && ./create\nsuccessfully wrote to lorem_ipsum.txt\n\n$ cat lorem_ipsum.txt\nLorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod\ntempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,\nquis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo\nconsequat. Duis aute irure dolor in reprehenderit in voluptate velit esse\ncillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non\nproident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n```\n\n----------------------------------------\n\nTITLE: Challenge: Converting Enum Comparison to If Let in Rust\nDESCRIPTION: Exercise showing a case where if let is necessary because the enum doesn't implement PartialEq.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/flow_control/if_let.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nenum Foo {Bar}\n\nfn main() {\n    let a = Foo::Bar;\n\n    // Variable a matches Foo::Bar\n    if Foo::Bar == a {\n    // ^-- this causes a compile-time error. Use `if let` instead.\n        println!(\"a is foobar\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Calculate Macro Output Example\nDESCRIPTION: Example output showing the results of evaluating multiple expressions using the calculate macro. Shows both the original expressions and their computed values.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/macros/variadics.md#2025-04-21_snippet_1\n\nLANGUAGE: txt\nCODE:\n```\n1 + 2 = 3\n3 + 4 = 7\n(2 * 3) + 1 = 7\n```\n\n----------------------------------------\n\nTITLE: Compiling a Rust file as a crate\nDESCRIPTION: Example of how to compile a Rust file as a crate using the rustc compiler. The file becomes the crate file in this compilation process.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/crates.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nrustc some_file.rs\n```\n\n----------------------------------------\n\nTITLE: Collecting Failed Items with map_err and filter_map in Rust\nDESCRIPTION: Uses map_err and filter_map to separate successful parsing results from errors, storing errors in a separate collection for later processing.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/error/iter_result.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let strings = vec![\"42\", \"tofu\", \"93\", \"999\", \"18\"];\n    let mut errors = vec![];\n    let numbers: Vec<_> = strings\n        .into_iter()\n        .map(|s| s.parse::<u8>())\n        .filter_map(|r| r.map_err(|e| errors.push(e)).ok())\n        .collect();\n    println!(\"Numbers: {:?}\", numbers);\n    println!(\"Errors: {:?}\", errors);\n}\n```\n\n----------------------------------------\n\nTITLE: Compiling a Rust Library Crate\nDESCRIPTION: This shell command demonstrates how to compile a Rust library file and verify the resulting library file. When the `crate_type` attribute is used in the source, the `--crate-type` flag is not needed with the `rustc` command.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/attribute/crate.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ rustc lib.rs\n$ ls lib*\nlibrary.rlib\n```\n\n----------------------------------------\n\nTITLE: Illustrating Variable Shadowing in Rust\nDESCRIPTION: This code snippet demonstrates variable shadowing in Rust. It shows how a variable can be redeclared with the same name, effectively shadowing the previous declaration. The example includes shadowing within nested blocks and in the outer scope.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/variable_bindings/scope.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let shadowed_binding = 1;\n\n    {\n        println!(\"before being shadowed: {}\", shadowed_binding);\n\n        // This binding *shadows* the outer one\n        let shadowed_binding = \"abc\";\n\n        println!(\"shadowed in inner block: {}\", shadowed_binding);\n    }\n    println!(\"outside inner block: {}\", shadowed_binding);\n\n    // This binding *shadows* the previous binding\n    let shadowed_binding = 2;\n    println!(\"shadowed in outer block: {}\", shadowed_binding);\n}\n```\n\n----------------------------------------\n\nTITLE: Filtering Out Failed Results with filter_map in Rust\nDESCRIPTION: Uses filter_map to process only successful parsing results, discarding any errors that occur during parsing.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/error/iter_result.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let strings = vec![\"tofu\", \"93\", \"18\"];\n    let numbers: Vec<_> = strings\n        .into_iter()\n        .filter_map(|s| s.parse::<i32>().ok())\n        .collect();\n    println!(\"Results: {:?}\", numbers);\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Comment Types in Rust\nDESCRIPTION: This example shows how to use line comments, block comments (including nested ones), and how comments can affect code execution. It demonstrates comment styles, temporarily disabling code with comments, and using comments within expressions.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/hello/comment.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    // This is an example of a line comment.\n    // There are two slashes at the beginning of the line.\n    // And nothing written after these will be read by the compiler.\n\n    // println!(\"Hello, world!\");\n\n    // Run it. See? Now try deleting the two slashes, and run it again.\n\n    /*\n     * This is another type of comment, a block comment. In general,\n     * line comments are the recommended comment style. But block comments\n     * are extremely useful for temporarily disabling chunks of code.\n     * /* Block comments can be /* nested, */ */ so it takes only a few\n     * keystrokes to comment out everything in this main() function.\n     * /*/*/* Try it yourself! */*/*/\n     */\n\n    /*\n    Note: The previous column of `*` was entirely for style. There's\n    no actual need for it.\n    */\n\n    // You can manipulate expressions more easily with block comments\n    // than with line comments. Try deleting the comment delimiters\n    // to change the result:\n    let x = 5 + /* 90 + */ 5;\n    println!(\"Is `x` 10 or 100? x = {}\", x);\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Integration Test Implementation\nDESCRIPTION: Creates a basic integration test that verifies the add function from the adder crate.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/testing/integration_testing.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[test]\nfn test_add() {\n    assert_eq!(adder::add(3, 2), 5);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Variadic Calculate Macro in Rust\nDESCRIPTION: Implementation of a variadic macro that can evaluate multiple arithmetic expressions. The macro uses pattern matching to handle both single and multiple evaluations, forcing integer types and printing both the expression and its result.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/macros/variadics.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nmacro_rules! calculate {\n    // The pattern for a single `eval`\n    (eval $e:expr) => {\n        {\n            let val: usize = $e; // Force types to be integers\n            println!(\"{} = {}\", stringify!{$e}, val);\n        }\n    };\n\n    // Decompose multiple `eval`s recursively\n    (eval $e:expr, $(eval $es:expr),+) => {{\n        calculate! { eval $e }\n        calculate! { $(eval $es),+ }\n    }};\n}\n\nfn main() {\n    calculate! { // Look ma! Variadic `calculate!`!\n        eval 1 + 2,\n        eval 3 + 4,\n        eval (2 * 3) + 1\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Compiling Rust Code with Custom Configuration Flags\nDESCRIPTION: This shell command demonstrates how to compile a Rust file with a custom configuration flag. The --cfg option enables the 'some_condition' flag that was used in the conditional function.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/attribute/cfg/custom.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ rustc --cfg some_condition custom.rs && ./custom\ncondition met!\n```\n\n----------------------------------------\n\nTITLE: Common Types of Rust Statements\nDESCRIPTION: Demonstrates the two most common types of statements in Rust: variable binding statements and expression statements that end with a semicolon.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/expression.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    // variable binding\n    let x = 5;\n\n    // expression;\n    x;\n    x + 1;\n    15;\n}\n```\n\n----------------------------------------\n\nTITLE: Cargo Test Output Example\nDESCRIPTION: Example output from running cargo test showing test results including passed, failed, ignored, and measured tests.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/cargo/test.md#2025-04-21_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ cargo test\n   Compiling blah v0.1.0 (file:///nobackup/blah)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.89 secs\n     Running target/debug/deps/blah-d3b32b97275ec472\n\nrunning 4 tests\ntest test_bar ... ok\ntest test_baz ... ok\ntest test_foo_bar ... ok\ntest test_foo ... ok\n\ntest result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n```\n\n----------------------------------------\n\nTITLE: Alternative Implementation of 'cat' Function in Rust\nDESCRIPTION: This code snippet shows an alternative way to define the 'cat' function in Rust using the '?' notation. It reads the contents of a file and returns the result as a String, using a more concise error handling approach.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/std_misc/fs.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nfn cat(path: &Path) -> io::Result<String> {\n    let mut f = File::open(path)?;\n    let mut s = String::new();\n    f.read_to_string(&mut s)?;\n    Ok(s)\n}\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running the Rust Module Example\nDESCRIPTION: Demonstrates how to compile and run the Rust module example, showing the output of the program.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/mod/split.md#2025-04-21_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n$ rustc split.rs && ./split\ncalled `my::function()`\ncalled `function()`\ncalled `my::indirect_access()`, that\n> called `my::private_function()`\ncalled `my::nested::function()`\n```\n\n----------------------------------------\n\nTITLE: Basic Rust Project Directory Structure\nDESCRIPTION: Shows the basic directory structure for a Rust project managed by Cargo, including the Cargo.toml file and the src directory with main.rs.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/cargo/conventions.md#2025-04-21_snippet_0\n\nLANGUAGE: txt\nCODE:\n```\nfoo\n├── Cargo.toml\n└── src\n    └── main.rs\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Freezing Behavior in Rust\nDESCRIPTION: This code snippet illustrates how data becomes frozen when bound immutably and cannot be modified until the immutable binding goes out of scope. It shows an error when trying to modify frozen data and demonstrates that the data can be modified again once the immutable binding is no longer in scope.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/variable_bindings/freeze.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let mut _mutable_integer = 7i32;\n\n    {\n        // Shadowing by immutable `_mutable_integer`\n        let _mutable_integer = _mutable_integer;\n\n        // Error! `_mutable_integer` is frozen in this scope\n        _mutable_integer = 50;\n        // FIXME ^ Comment out this line\n\n        // `_mutable_integer` goes out of scope\n    }\n\n    // Ok! `_mutable_integer` is not frozen in this scope\n    _mutable_integer = 3;\n}\n```\n\n----------------------------------------\n\nTITLE: Running Compiled Rust Program\nDESCRIPTION: Command to execute the compiled Rust binary and its output. Shows how to run the generated executable and displays the expected console output.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/hello.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ ./hello\nHello World!\n```\n\n----------------------------------------\n\nTITLE: Rust Test Module with Concurrent File Access\nDESCRIPTION: Example Rust test module demonstrating potential concurrency issues when multiple tests try to write to the same file simultaneously. Tests open files in append mode and write different content to illustrate race conditions.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/cargo/test.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n#[cfg(test)]\nmod tests {\n    // Import the necessary modules\n    use std::fs::OpenOptions;\n    use std::io::Write;\n\n    // This test writes to a file\n    #[test]\n    fn test_file() {\n        // Opens the file ferris.txt or creates one if it doesn't exist.\n        let mut file = OpenOptions::new()\n            .append(true)\n            .create(true)\n            .open(\"ferris.txt\")\n            .expect(\"Failed to open ferris.txt\");\n\n        // Print \"Ferris\" 5 times.\n        for _ in 0..5 {\n            file.write_all(\"Ferris\\n\".as_bytes())\n                .expect(\"Could not write to ferris.txt\");\n        }\n    }\n\n    // This test tries to write to the same file\n    #[test]\n    fn test_file_also() {\n        // Opens the file ferris.txt or creates one if it doesn't exist.\n        let mut file = OpenOptions::new()\n            .append(true)\n            .create(true)\n            .open(\"ferris.txt\")\n            .expect(\"Failed to open ferris.txt\");\n\n        // Print \"Corro\" 5 times.\n        for _ in 0..5 {\n            file.write_all(\"Corro\\n\".as_bytes())\n                .expect(\"Could not write to ferris.txt\");\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Standard Rust Project Structure for Testing\nDESCRIPTION: Shows the typical directory structure for a Rust project with testing capabilities, including source files and a tests directory for integration tests.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/cargo/test.md#2025-04-21_snippet_0\n\nLANGUAGE: txt\nCODE:\n```\nfoo\n├── Cargo.toml\n├── src\n│   └── main.rs\n│   └── lib.rs\n└── tests\n    ├── my_test.rs\n    └── my_other_test.rs\n```\n\n----------------------------------------\n\nTITLE: Comparing Function Signatures With and Without Associated Types in Rust\nDESCRIPTION: This snippet compares two function signatures, one using generic types explicitly and another using associated types. It illustrates how associated types can simplify function declarations.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/generics/assoc_items/types.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// Without using associated types\nfn difference<A, B, C>(container: &C) -> i32 where\n    C: Contains<A, B> { ... }\n\n// Using associated types\nfn difference<C: Contains>(container: &C) -> i32 { ... }\n```\n\n----------------------------------------\n\nTITLE: Executing Argument Parsing Program in Shell\nDESCRIPTION: This shell script demonstrates how to compile and run the Rust program for argument parsing. It shows various command-line inputs and their corresponding outputs, illustrating different scenarios handled by the program.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/std_misc/arg/matching.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ ./match_args Rust\nThis is not the answer.\n$ ./match_args 42\nThis is the answer!\n$ ./match_args do something\nerror: second argument not an integer\nusage:\nmatch_args <string>\n    Check whether given string is the answer.\nmatch_args {increase|decrease} <integer>\n    Increase or decrease given integer by one.\n$ ./match_args do 42\nerror: invalid command\nusage:\nmatch_args <string>\n    Check whether given string is the answer.\nmatch_args {increase|decrease} <integer>\n    Increase or decrease given integer by one.\n$ ./match_args increase 42\n43\n```\n\n----------------------------------------\n\nTITLE: Defining Rust Custom Type Keywords\nDESCRIPTION: Lists the main keywords used to define custom data types in Rust: struct for defining structures, enum for defining enumerations, and const/static for creating constants.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/custom_types.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n* `struct`: define a structure\n* `enum`: define an enumeration\n\nConstants can also be created via the `const` and `static` keywords.\n```\n\n----------------------------------------\n\nTITLE: Running All Tests with Cargo\nDESCRIPTION: Command to run all tests in a Rust project using Cargo's test subcommand.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/cargo/test.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ cargo test\n```\n\n----------------------------------------\n\nTITLE: Using the Never Type with panic! in Rust\nDESCRIPTION: A demonstration of the never type (!) in action, showing that code after a panic! is unreachable. Requires the never_type feature and is meant for illustration only.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/fn/diverging.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#![feature(never_type)]\n\nfn main() {\n    let x: ! = panic!(\"This call never returns.\");\n    println!(\"You will never see this line!\");\n}\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running Rust Wait Example\nDESCRIPTION: This bash command compiles the Rust program and executes it. The program will run for 5 seconds before printing the final message, demonstrating the waiting behavior.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/std_misc/process/wait.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ rustc wait.rs && ./wait\n# `wait` keeps running for 5 seconds until the `sleep 5` command finishes\nreached end of main\n```\n\n----------------------------------------\n\nTITLE: Basic Error Mapping with and_then\nDESCRIPTION: Shows the traditional approach of mapping parse errors using and_then and map_err.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/error/multiple_error_types/reenter_question_mark.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n.and_then(|s| s.parse::<i32>())\n    .map_err(|e| e.into())\n```\n\n----------------------------------------\n\nTITLE: Displaying File Hierarchy with Tree Command\nDESCRIPTION: Shows the file structure of the Rust module example using the tree command.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/mod/split.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ tree .\n.\n├── my\n│   ├── inaccessible.rs\n│   └── nested.rs\n├── my.rs\n└── split.rs\n```\n\n----------------------------------------\n\nTITLE: Compiling and Testing Rust Documentation\nDESCRIPTION: Shell commands for building code as a library and running documentation tests using rustdoc.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/meta/doc.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ rustc doc.rs --crate-type lib\n$ rustdoc --test --extern doc=\"libdoc.rlib\" doc.rs\n```\n\n----------------------------------------\n\nTITLE: Expected Color Struct Output Format\nDESCRIPTION: Shows the expected output format for the Color struct implementation, displaying RGB values in both decimal and hexadecimal formats.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/hello/print/fmt.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nRGB (128, 255, 90) 0x80FF5A\nRGB (0, 3, 254) 0x0003FE\nRGB (0, 0, 0) 0x000000\n```\n\n----------------------------------------\n\nTITLE: Compiling Rust Library\nDESCRIPTION: Shell commands showing how to compile a Rust source file into a library file (.rlib) using rustc with the --crate-type=lib option.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/crates/lib.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ rustc --crate-type=lib rary.rs\n$ ls lib*\nlibrary.rlib\n```\n\n----------------------------------------\n\nTITLE: Verifying Memory Management with Valgrind in Rust\nDESCRIPTION: This shell command compiles a Rust program and uses Valgrind to check for memory errors, demonstrating that Rust's RAII prevents memory leaks.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/scope/raii.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ rustc raii.rs && valgrind ./raii\n==26873== Memcheck, a memory error detector\n==26873== Copyright (C) 2002-2013, and GNU GPL'd, by Julian Seward et al.\n==26873== Using Valgrind-3.9.0 and LibVEX; rerun with -h for copyright info\n==26873== Command: ./raii\n==26873==\n==26873==\n==26873== HEAP SUMMARY:\n==26873==     in use at exit: 0 bytes in 0 blocks\n==26873==   total heap usage: 1,013 allocs, 1,013 frees, 8,696 bytes allocated\n==26873==\n==26873== All heap blocks were freed -- no leaks are possible\n==26873==\n==26873== For counts of detected and suppressed errors, rerun with: -v\n==26873== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 2 from 2)\n```\n\n----------------------------------------\n\nTITLE: Final Directory Structure After Rust Filesystem Operations\nDESCRIPTION: This shell snippet shows the final state of the 'a' directory after executing the Rust program. It displays the directory structure using the 'tree' command, revealing the created files and symbolic links.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/std_misc/fs.md#2025-04-21_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ tree a\na\n|-- b.txt\n`-- c\n    `-- b.txt -> ../b.txt\n\n1 directory, 2 files\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Handling with the ? Operator in Rust\nDESCRIPTION: This example demonstrates a mathematical operations module with proper error handling using Rust's ? operator. It defines custom error types for various mathematical errors and shows how the ? operator can simplify error propagation in a chain of operations.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/std/result/question_mark.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nmod checked {\n    #[derive(Debug)]\n    enum MathError {\n        DivisionByZero,\n        NonPositiveLogarithm,\n        NegativeSquareRoot,\n    }\n\n    type MathResult = Result<f64, MathError>;\n\n    fn div(x: f64, y: f64) -> MathResult {\n        if y == 0.0 {\n            Err(MathError::DivisionByZero)\n        } else {\n            Ok(x / y)\n        }\n    }\n\n    fn sqrt(x: f64) -> MathResult {\n        if x < 0.0 {\n            Err(MathError::NegativeSquareRoot)\n        } else {\n            Ok(x.sqrt())\n        }\n    }\n\n    fn ln(x: f64) -> MathResult {\n        if x <= 0.0 {\n            Err(MathError::NonPositiveLogarithm)\n        } else {\n            Ok(x.ln())\n        }\n    }\n\n    // Intermediate function\n    fn op_(x: f64, y: f64) -> MathResult {\n        // if `div` \"fails\", then `DivisionByZero` will be `return`ed\n        let ratio = div(x, y)?;\n\n        // if `ln` \"fails\", then `NonPositiveLogarithm` will be `return`ed\n        let ln = ln(ratio)?;\n\n        sqrt(ln)\n    }\n\n    pub fn op(x: f64, y: f64) {\n        match op_(x, y) {\n            Err(why) => panic!(\"{}\", match why {\n                MathError::NonPositiveLogarithm\n                    => \"logarithm of non-positive number\",\n                MathError::DivisionByZero\n                    => \"division by zero\",\n                MathError::NegativeSquareRoot\n                    => \"square root of negative number\",\n            }),\n            Ok(value) => println!(\"{}\", value),\n        }\n    }\n}\n\nfn main() {\n    checked::op(1.0, 10.0);\n}\n```\n\n----------------------------------------\n\nTITLE: Running Tests with Pattern Matching\nDESCRIPTION: Command to run only tests whose names match a specific pattern using Cargo's filtering capabilities.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/cargo/test.md#2025-04-21_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ cargo test test_foo\n```\n\n----------------------------------------\n\nTITLE: Setting Panic Strategy via Command Line\nDESCRIPTION: Command line example showing how to compile Rust code with a specific panic strategy using the rustc compiler.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/error/abort_unwind.md#2025-04-21_snippet_2\n\nLANGUAGE: console\nCODE:\n```\nrustc  lemonade.rs -C panic=abort\n```\n\n----------------------------------------\n\nTITLE: Running Rust Tests in Shell\nDESCRIPTION: This shell command compiles the Rust file with tests and runs the compiled binary. It showcases the execution of the tests implemented in the Rust code.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/macros/dry.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ rustc --test dry.rs && ./dry\nrunning 3 tests\ntest test::mul_assign ... ok\ntest test::add_assign ... ok\ntest test::sub_assign ... ok\n\ntest result: ok. 3 passed; 0 failed; 0 ignored; 0 measured\n```\n\n----------------------------------------\n\nTITLE: Basic Rust Playground Example\nDESCRIPTION: A simple Hello World example demonstrating editable code in mdbook\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/meta/playground.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    println!(\"Hello World!\");\n}\n```\n\n----------------------------------------\n\nTITLE: Verifying Memory Management during panic! with Valgrind in Rust\nDESCRIPTION: This shell output demonstrates using Valgrind to verify that Rust properly frees all allocated memory during a panic. The heap summary confirms that all 18 allocations were properly freed, showing that panic! doesn't leak memory.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/std/panic.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ rustc panic.rs && valgrind ./panic\n==4401== Memcheck, a memory error detector\n==4401== Copyright (C) 2002-2013, and GNU GPL'd, by Julian Seward et al.\n==4401== Using Valgrind-3.10.0.SVN and LibVEX; rerun with -h for copyright info\n==4401== Command: ./panic\n==4401== \nthread '<main>' panicked at 'division by zero', panic.rs:5\n==4401== \n==4401== HEAP SUMMARY:\n==4401==     in use at exit: 0 bytes in 0 blocks\n==4401==   total heap usage: 18 allocs, 18 frees, 1,648 bytes allocated\n==4401== \n==4401== All heap blocks were freed -- no leaks are possible\n==4401== \n==4401== For counts of detected and suppressed errors, rerun with: -v\n==4401== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)\n```\n\n----------------------------------------\n\nTITLE: Playground URL Configuration\nDESCRIPTION: Shows how to configure the Rust Playground URL in documentation using the html_playground_url attribute\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/meta/playground.md#2025-04-21_snippet_3\n\nLANGUAGE: text\nCODE:\n```\n#![doc(html_playground_url = \"https://play.rust-lang.org/\")]\n//! ```\n//! println!(\"Hello World\");\n//! ```\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running Rust Program with External Library\nDESCRIPTION: Shows the command line instructions for compiling a Rust program with an external library using rustc's --extern flag and running the resulting executable.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/crates/using_lib.md#2025-04-21_snippet_1\n\nLANGUAGE: txt\nCODE:\n```\n# Where library.rlib is the path to the compiled library, assumed that it's\n# in the same directory here:\n$ rustc executable.rs --extern rary=library.rlib && ./executable \ncalled rary's `public_function()`\ncalled rary's `indirect_access()`, that\n> called rary's `private_function()`\n```\n\n----------------------------------------\n\nTITLE: Command Line Arguments Example Output\nDESCRIPTION: Shows the output of running the program with command line arguments. Demonstrates how arguments are captured and displayed.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/std_misc/arg.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ ./args 1 2 3\nMy path is ./args.\nI got 3 arguments: [\"1\", \"2\", \"3\"].\n```\n\n----------------------------------------\n\nTITLE: Generating Markdown Table of Contents for Rust by Example\nDESCRIPTION: This markdown snippet outlines the structure of the Rust by Example guide, including main sections and subsections. It uses markdown heading syntax and nested lists to create a hierarchical table of contents.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/SUMMARY.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Summary\n\n[Introduction](index.md)\n\n- [Hello World](hello.md)\n    - [Comments](hello/comment.md)\n    - [Formatted print](hello/print.md)\n        - [Debug](hello/print/print_debug.md)\n        - [Display](hello/print/print_display.md)\n            - [Testcase: List](hello/print/print_display/testcase_list.md)\n        - [Formatting](hello/print/fmt.md)\n\n- [Primitives](primitives.md)\n    - [Literals and operators](primitives/literals.md)\n    - [Tuples](primitives/tuples.md)\n    - [Arrays and Slices](primitives/array.md)\n\n# ... (truncated for brevity)\n\n- [Meta](meta.md)\n    - [Documentation](meta/doc.md)\n    - [Playground](meta/playground.md)\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Addition Function in Rust\nDESCRIPTION: Defines a simple public function 'add' in the adder crate that adds two i32 integers.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/testing/integration_testing.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// Define this in a crate called `adder`.\npub fn add(a: i32, b: i32) -> i32 {\n    a + b\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Language Selector to HTML Template\nDESCRIPTION: HTML markup for the language selection menu in the documentation template\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/TRANSLATING.md#2025-04-21_snippet_5\n\nLANGUAGE: html\nCODE:\n```\n<ul id=\"language-list\" class=\"theme-popup\" aria-label=\"Languages\" role=\"menu\">\n  <li role=\"none\"><button role=\"menuitem\" class=\"theme\">\n      <a id=\"en\">English</a>\n  </button></li>\n  <li role=\"none\"><button role=\"menuitem\" class=\"theme\">\n      <a id=\"xx\">XX language</a>\n  </button></li>\n  <li role=\"none\"><button role=\"menuitem\" class=\"theme\">\n      <a id=\"yy\">YY language</a>\n  </button></li>\n  <li role=\"none\"><button role=\"menuitem\" class=\"theme\">\n      <a id=\"zz\">ZZ language</a>\n  </button></li>\n</ul>\n```\n\n----------------------------------------\n\nTITLE: Importing and Using External Library Functions in Rust\nDESCRIPTION: Demonstrates how to import and use functions from an external library named 'rary'. Shows access to public functions and attempted access to private functions, along with indirect access patterns.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/crates/using_lib.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// extern crate rary; // May be required for Rust 2015 edition or earlier\n\nfn main() {\n    rary::public_function();\n\n    // Error! `private_function` is private\n    //rary::private_function();\n\n    rary::indirect_access();\n}\n```\n\n----------------------------------------\n\nTITLE: Ignored Editable Code Block Syntax\nDESCRIPTION: Demonstrates how to create an editable code block that will be skipped during mdbook build and testing\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/meta/playground.md#2025-04-21_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n```rust,editable,ignore\n//...place your code here\n```\n```\n\n----------------------------------------\n\nTITLE: Local Labels in Inline Assembly\nDESCRIPTION: Demonstrates the use of local numeric labels in inline assembly for control flow. Shows proper usage of forward and backward label references.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/unsafe/asm.md#2025-04-21_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\nlet mut a = 0;\nunsafe {\n    asm!(\n        \"mov {0}, 10\",\n        \"2:\",\n        \"sub {0}, 1\",\n        \"cmp {0}, 3\",\n        \"jle 2f\",\n        \"jmp 2b\",\n        \"2:\",\n        \"add {0}, 2\",\n        out(reg) a\n    );\n}\nassert_eq!(a, 5);\n```\n\n----------------------------------------\n\nTITLE: Inout with Separate Variables in Rust Assembly\nDESCRIPTION: Demonstrates using inout operands with different input and output variables.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/unsafe/asm.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse std::arch::asm;\n\nlet x: u64 = 3;\nlet y: u64;\nunsafe {\n    asm!(\"add {0}, 5\", inout(reg) x => y);\n}\nassert_eq!(y, 8);\n```\n\n----------------------------------------\n\nTITLE: Configuring Languages in GitHub Workflow YAML\nDESCRIPTION: YAML configuration for supported languages in GitHub Actions workflow file\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/TRANSLATING.md#2025-04-21_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\nenv:\n  # Update the language picker in index.hbs to link new languages.\n  LANGUAGES: xx yy zz\n```\n\n----------------------------------------\n\nTITLE: Project File Structure for Cargo-managed Rust Projects\nDESCRIPTION: This snippet illustrates the file hierarchy created by Cargo when initializing new Rust projects. It shows the structure for both binary and library projects.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/cargo/deps.md#2025-04-21_snippet_1\n\nLANGUAGE: txt\nCODE:\n```\n.\n├── bar\n│   ├── Cargo.toml\n│   └── src\n│       └── lib.rs\n└── foo\n    ├── Cargo.toml\n    └── src\n        └── main.rs\n```\n\n----------------------------------------\n\nTITLE: Editable Code Block Syntax in Markdown\nDESCRIPTION: Shows how to create an editable code block in markdown using the editable flag\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/meta/playground.md#2025-04-21_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n```rust,editable\n//...place your code here\n```\n```\n\n----------------------------------------\n\nTITLE: Rust Doc No_Inline Attribute Example\nDESCRIPTION: Shows usage of #[doc(no_inline)] attribute to prevent documentation linking.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/meta/doc.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[doc(no_inline)]\npub use crate::mem::drop;\n```\n\n----------------------------------------\n\nTITLE: Multiply Using Shifts and Adds in Inline Assembly\nDESCRIPTION: Shows how to multiply a number by 6 using bitwise shifts and addition in assembly. Demonstrates usage of temporary registers and register class constraints.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/unsafe/asm.md#2025-04-21_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nuse std::arch::asm;\n\nlet mut x: u64 = 4;\nunsafe {\n    asm!(\n        \"mov {tmp}, {x}\",\n        \"shl {tmp}, 1\",\n        \"shl {x}, 2\",\n        \"add {x}, {tmp}\",\n        x = inout(reg) x,\n        tmp = out(reg) _,\n    );\n}\nassert_eq!(x, 4 * 6);\n```\n\n----------------------------------------\n\nTITLE: Building Translated Version with Mdbook\nDESCRIPTION: Commands to build and serve a translated version of Rust By Example using the MDBOOK_BOOK__LANGUAGE environment variable.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/README.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/rust-lang/rust-by-example\ncd rust-by-example\ncargo install mdbook\nMDBOOK_BOOK__LANGUAGE=ja mdbook build\nMDBOOK_BOOK__LANGUAGE=ja mdbook serve\n```\n\n----------------------------------------\n\nTITLE: Cargo Test Output Example\nDESCRIPTION: Shows the expected output when running integration tests with cargo test command.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/testing/integration_testing.md#2025-04-21_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ cargo test\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\n     Running target/debug/deps/integration_test-bcd60824f5fbfe19\n\nrunning 1 test\ntest test_add ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\n   Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n```\n\n----------------------------------------\n\nTITLE: Generating Message Template in Bash\nDESCRIPTION: Command to generate the initial message template file messages.pot required for translations using mdbook\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/TRANSLATING.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nMDBOOK_OUTPUT='{\"xgettext\": {\"pot-file\": \"messages.pot\"}}' \\\n  mdbook build -d po\n```\n\n----------------------------------------\n\nTITLE: Rust Project Directory Structure with Multiple Binaries\nDESCRIPTION: Demonstrates how to structure a Rust project with multiple binaries by adding a bin directory inside src for additional binary files.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/cargo/conventions.md#2025-04-21_snippet_1\n\nLANGUAGE: txt\nCODE:\n```\nfoo\n├── Cargo.toml\n└── src\n    ├── main.rs\n    └── bin\n        └── my_other_bin.rs\n```\n\n----------------------------------------\n\nTITLE: Rust Doc Inline Attribute Example\nDESCRIPTION: Demonstrates the use of #[doc(inline)] attribute to inline documentation instead of linking to a separate page.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/meta/doc.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[doc(inline)]\npub use bar::Bar;\n\n/// bar docs\npub mod bar {\n    /// the docs for Bar\n    pub struct Bar;\n}\n```\n\n----------------------------------------\n\nTITLE: Markdown Documentation for Rust Compatibility\nDESCRIPTION: Markdown documentation explaining Rust's compatibility considerations and providing navigation to detailed topics like raw identifiers.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/compatibility.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Compatibility\n\nThe Rust language is evolving rapidly, and because of this certain compatibility\nissues can arise, despite efforts to ensure forwards-compatibility wherever\npossible.\n\n* [Raw identifiers](compatibility/raw_identifiers.md)\n```\n\n----------------------------------------\n\nTITLE: Register Template Modifiers Usage\nDESCRIPTION: Demonstrates how to use register template modifiers to access specific parts of registers. Shows manipulation of high and low bytes of a register.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/unsafe/asm.md#2025-04-21_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\nlet mut x: u16 = 0xab;\n\nunsafe {\n    asm!(\"mov {0:h}, {0:l}\", inout(reg_abcd) x);\n}\n\nassert_eq!(x, 0xabab);\n```\n\n----------------------------------------\n\nTITLE: Mdbook Warning Messages\nDESCRIPTION: Common warning messages that can be safely ignored when building the documentation with mdbook.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/README.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n[WARN] (mdbook::preprocess::cmd): The command wasn't found, is the \"gettext\" preprocessor installed?\n[WARN] (mdbook::preprocess::cmd):   Command: mdbook-gettext\n```\n\n----------------------------------------\n\nTITLE: Running Tests for Rust by Example\nDESCRIPTION: Command for running the tests for Rust by Example using mdbook. This validates that all code examples in the documentation compile and work correctly.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/CONTRIBUTING.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ mdbook test\n```\n\n----------------------------------------\n\nTITLE: Integration Test with Shared Setup\nDESCRIPTION: Demonstrates how to use shared test utilities by importing and using the common module in an integration test.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/testing/integration_testing.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n// importing common module.\nmod common;\n\n#[test]\nfn test_add() {\n    // using common code.\n    common::setup();\n    assert_eq!(adder::add(3, 2), 5);\n}\n```\n\n----------------------------------------\n\nTITLE: Using an Inner Attribute for Crate-Wide Lint Suppression in Rust\nDESCRIPTION: Example showing how to use the inner attribute #![allow(unused_variables)] to suppress unused variable warnings for the entire crate. The attribute is placed at the top of the file and affects all code in the enclosing scope.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/attribute.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#![allow(unused_variables)]\n\nfn main() {\n    let x = 3; // This would normally warn about an unused variable.\n}\n```\n\n----------------------------------------\n\nTITLE: Setting up Rust By Example Local Environment\nDESCRIPTION: Commands to clone the repository and set up a local instance of Rust By Example using mdbook. Requires Rust installation and internet connection to run examples.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/README.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/rust-lang/rust-by-example\ncd rust-by-example\ncargo install mdbook\nmdbook build\nmdbook serve\n```\n\n----------------------------------------\n\nTITLE: Assembly Options Example\nDESCRIPTION: Shows how to use assembly options like pure, nomem, and nostack to provide optimization hints to the compiler.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/unsafe/asm.md#2025-04-21_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\nlet mut a: u64 = 4;\nlet b: u64 = 4;\nunsafe {\n    asm!(\n        \"add {0}, {1}\",\n        inlateout(reg) a, in(reg) b,\n        options(pure, nomem, nostack),\n    );\n}\nassert_eq!(a, 8);\n```\n\n----------------------------------------\n\nTITLE: Creating New Translation Resource in Bash\nDESCRIPTION: Command to initialize a new translation file for a specific language using msginit\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/TRANSLATING.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmsginit -i po/messages.pot -l xx -o po/xx.po\n```\n\n----------------------------------------\n\nTITLE: Attribute Syntax with Multiple Values in Rust\nDESCRIPTION: Demonstration of attribute syntax with multiple values, showing how attributes can be formatted across multiple lines. This illustrates the flexible formatting options available when using attributes with several parameters.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/attribute.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[attribute(value, value2)]\n\n\n#[attribute(value, value2, value3,\n            value4, value5)]\n```\n\n----------------------------------------\n\nTITLE: Compiling Rust Program\nDESCRIPTION: Command to compile a Rust source file using the rustc compiler. This command generates an executable binary from the Rust source code.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/hello.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ rustc hello.rs\n```\n\n----------------------------------------\n\nTITLE: Expected File Output Without Concurrency\nDESCRIPTION: The expected file content if tests were run sequentially, showing all Ferris entries followed by all Corro entries.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/cargo/test.md#2025-04-21_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\n$ cat ferris.txt\nFerris\nFerris\nFerris\nFerris\nFerris\nCorro\nCorro\nCorro\nCorro\nCorro\n```\n\n----------------------------------------\n\nTITLE: Configuring Languages in Rust Build System\nDESCRIPTION: Rust code snippet for configuring supported languages in the documentation build system\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/TRANSLATING.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nRustByExample, \"src/doc/rust-by-example\", \"rust-by-example\", &[\"xx\", \"yy\", \"zz\"], submodule;\n```\n\n----------------------------------------\n\nTITLE: Basic Example of Inline Assembly Comment\nDESCRIPTION: Demonstrates the simple closing brace syntax that appears to be part of a larger assembly code example.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/unsafe/asm.md#2025-04-21_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\n# }\n```\n\n----------------------------------------\n\nTITLE: Linking to Meta Topic Documentation in Markdown\nDESCRIPTION: Defines markdown links to documentation pages for meta topics in Rust, including documentation generation and playground integration.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/meta.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n[doc]: meta/doc.md\n[playground]: meta/playground.md\n```\n\n----------------------------------------\n\nTITLE: Defining the Iterator::find method in Rust\nDESCRIPTION: Shows the trait definition for Iterator's find method, which searches for the first value satisfying a condition and returns Option<Item>. The method takes a closure predicate that returns bool when it finds a match.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/fn/closures/closure_examples/iter_find.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub trait Iterator {\n    // The type being iterated over.\n    type Item;\n\n    // `find` takes `&mut self` meaning the caller may be borrowed\n    // and modified, but not consumed.\n    fn find<P>(&mut self, predicate: P) -> Option<Self::Item> where\n        // `FnMut` meaning any captured variable may at most be\n        // modified, not consumed. `&Self::Item` states it takes\n        // arguments to the closure by reference.\n        P: FnMut(&Self::Item) -> bool;\n}\n```\n\n----------------------------------------\n\nTITLE: Nested Module Definition in my/nested.rs\nDESCRIPTION: Defines the 'nested' module within 'my', including public and private functions.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/mod/split.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\npub fn function() {\n    println!(\"called `my::nested::function()`\");\n}\n\n#[allow(dead_code)]\nfn private_function() {\n    println!(\"called `my::nested::private_function()`\");\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching Test Output Example\nDESCRIPTION: Example output from running cargo test with a pattern filter showing that only matching tests are executed.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/cargo/test.md#2025-04-21_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n$ cargo test test_foo\n   Compiling blah v0.1.0 (file:///nobackup/blah)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.35 secs\n     Running target/debug/deps/blah-d3b32b97275ec472\n\nrunning 2 tests\ntest test_foo ... ok\ntest test_foo_bar ... ok\n\ntest result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out\n```\n\n----------------------------------------\n\nTITLE: Bounding Generic Types in Struct Definitions in Rust\nDESCRIPTION: Shows how trait bounds restrict what types can be used with generic structs. This example demonstrates a compile-time error when trying to use a type that doesn't satisfy the required bound.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/generics/bounds.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct S<T: Display>(T);\n\n// Error! `Vec<T>` does not implement `Display`. This\n// specialization will fail.\nlet s = S(vec![1]);\n```\n\n----------------------------------------\n\nTITLE: Rust Doc Hidden Attribute Example\nDESCRIPTION: Demonstrates using #[doc(hidden)] attribute to exclude items from documentation generation.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/meta/doc.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n#[doc(hidden)]\npub use self::async_await::*;\n```\n\n----------------------------------------\n\nTITLE: Expected Output Format\nDESCRIPTION: The expected output format for the activity where users need to add a second println! macro. Shows the target console output format.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/hello.md#2025-04-21_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nHello World!\nI'm a Rustacean!\n```\n\n----------------------------------------\n\nTITLE: Rust Code Reference Identifiers\nDESCRIPTION: Reference to Rust standard library types and custom data structures mentioned in documentation\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/index.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct\n```\n\nLANGUAGE: rust\nCODE:\n```\nenum\n```\n\nLANGUAGE: rust\nCODE:\n```\nif/else\n```\n\nLANGUAGE: rust\nCODE:\n```\nfor\n```\n\nLANGUAGE: rust\nCODE:\n```\nSelf\n```\n\n----------------------------------------\n\nTITLE: Basic Main Function in Rust\nDESCRIPTION: Shows the typical structure of a Rust main function with a simple println statement.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/error/result.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    println!(\"Hello World!\");\n}\n```\n\n----------------------------------------\n\nTITLE: Inout Assembly Operations in Rust\nDESCRIPTION: Shows how to use inout operands for modifying a value in place using inline assembly.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/unsafe/asm.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse std::arch::asm;\n\nlet mut x: u64 = 3;\nunsafe {\n    asm!(\"add {0}, 5\", inout(reg) x);\n}\nassert_eq!(x, 8);\n```\n\n----------------------------------------\n\nTITLE: Module Definition in my.rs\nDESCRIPTION: Defines the 'my' module, including public and private functions, and nested module declarations.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/mod/split.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n// Similarly `mod inaccessible` and `mod nested` will locate the `nested.rs`\n// and `inaccessible.rs` files and insert them here under their respective\n// modules\nmod inaccessible;\npub mod nested;\n\npub fn function() {\n    println!(\"called `my::function()`\");\n}\n\nfn private_function() {\n    println!(\"called `my::private_function()`\");\n}\n\npub fn indirect_access() {\n    print!(\"called `my::indirect_access()`, that\\n> \");\n\n    private_function();\n}\n```\n\n----------------------------------------\n\nTITLE: Compiling a Rust crate as a library\nDESCRIPTION: Command showing how to override the default binary output and compile a Rust crate as a library using the --crate-type flag.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/crates.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n--crate-type\n```\n\n----------------------------------------\n\nTITLE: Multiple Assembly Instructions with Input/Output\nDESCRIPTION: Demonstrates using multiple assembly instructions with both input and output operands to perform addition.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/unsafe/asm.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse std::arch::asm;\n\nlet i: u64 = 3;\nlet o: u64;\nunsafe {\n    asm!(\n        \"mov {0}, {1}\",\n        \"add {0}, 5\",\n        out(reg) o,\n        in(reg) i,\n    );\n}\nassert_eq!(o, 8);\n```\n\n----------------------------------------\n\nTITLE: Listing Standard Library Features in Markdown\nDESCRIPTION: Markdown documentation listing key features provided by Rust's standard library including threads, channels, and file I/O operations. The content includes links to related documentation for primitives and the standard library.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/std_misc.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Std misc\n\nMany other types are provided by the std library to support\nthings such as:\n\n* Threads\n* Channels\n* File I/O\n\nThese expand beyond what the [primitives] provide.\n\n### See also:\n\n[primitives] and [the std library][std]\n\n[primitives]: primitives.md\n[std]: https://doc.rust-lang.org/std/\n```\n\n----------------------------------------\n\nTITLE: Memory Operands in x86 Assembly\nDESCRIPTION: Shows how to use memory operands in x86 assembly, specifically loading a floating-point control word using the fldcw instruction.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/unsafe/asm.md#2025-04-21_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\nfn load_fpu_control_word(control: u16) {\n    unsafe {\n        asm!(\"fldcw [{}]\", in(reg) &control, options(nostack));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Handling with ? Operator\nDESCRIPTION: Demonstrates a complete example of error handling using the ? operator, custom error types, and Result type alias. The code processes a vector of strings, attempting to parse and double the first number.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/error/multiple_error_types/reenter_question_mark.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::error;\nuse std::fmt;\n\n// Change the alias to use `Box<dyn error::Error>`.\ntype Result<T> = std::result::Result<T, Box<dyn error::Error>>;\n\n#[derive(Debug)]\nstruct EmptyVec;\n\nimpl fmt::Display for EmptyVec {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"invalid first item to double\")\n    }\n}\n\nimpl error::Error for EmptyVec {}\n\n// The same structure as before but rather than chain all `Results`\n// and `Options` along, we `?` to get the inner value out immediately.\nfn double_first(vec: Vec<&str>) -> Result<i32> {\n    let first = vec.first().ok_or(EmptyVec)?;\n    let parsed = first.parse::<i32>()?;\n    Ok(2 * parsed)\n}\n\nfn print(result: Result<i32>) {\n    match result {\n        Ok(n)  => println!(\"The first doubled is {}\", n),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n\nfn main() {\n    let numbers = vec![\"42\", \"93\", \"18\"];\n    let empty = vec![];\n    let strings = vec![\"tofu\", \"93\", \"18\"];\n\n    print(double_first(numbers));\n    print(double_first(empty));\n    print(double_first(strings));\n}\n```\n\n----------------------------------------\n\nTITLE: Referencing Cargo in Markdown\nDESCRIPTION: Shows how to reference the Cargo command in Markdown. Cargo is the official Rust package management tool that handles dependencies and integrates with crates.io.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/cargo.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n`cargo`\n```\n\n----------------------------------------\n\nTITLE: Error Message When Using a Keyword as an Identifier\nDESCRIPTION: This shows the error message produced when attempting to use a Rust keyword ('try') as an identifier. The compiler expects an identifier but found a keyword instead.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/compatibility/raw_identifiers.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nerror: expected identifier, found keyword `try`\n --> src/main.rs:4:4\n  |\n4 | foo::try();\n  |      ^^^ expected identifier, found keyword\n```\n\n----------------------------------------\n\nTITLE: Building Translated Book in Bash\nDESCRIPTION: Commands to build and serve the translated book for a specific language using mdbook\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/TRANSLATING.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nMDBOOK_BOOK__LANGUAGE=xx mdbook build\nMDBOOK_BOOK__LANGUAGE=xx mdbook serve\n```\n\n----------------------------------------\n\nTITLE: Updating Translation Resource in Bash\nDESCRIPTION: Command to update existing translation file with new messages from template\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/TRANSLATING.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nmsgmerge --update po/xx.po po/messages.pot\n```\n\n----------------------------------------\n\nTITLE: Inaccessible Module Definition in my/inaccessible.rs\nDESCRIPTION: Defines the 'inaccessible' module within 'my', containing a public function that is not accessible due to module privacy.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/mod/split.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n#[allow(dead_code)]\npub fn public_function() {\n    println!(\"called `my::inaccessible::public_function()`\");\n}\n```\n\n----------------------------------------\n\nTITLE: Returning Closures as Function Output Parameters in Rust\nDESCRIPTION: This example demonstrates how to return closures from functions using the impl Trait syntax. It shows how to create and return closures implementing Fn, FnMut, and FnOnce traits, with the 'move' keyword ensuring all captured values are owned by the closure.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/fn/closures/output_parameters.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn create_fn() -> impl Fn() {\n    let text = \"Fn\".to_owned();\n\n    move || println!(\"This is a: {}\", text)\n}\n\nfn create_fnmut() -> impl FnMut() {\n    let text = \"FnMut\".to_owned();\n\n    move || println!(\"This is a: {}\", text)\n}\n\nfn create_fnonce() -> impl FnOnce() {\n    let text = \"FnOnce\".to_owned();\n\n    move || println!(\"This is a: {}\", text)\n}\n\nfn main() {\n    let fn_plain = create_fn();\n    let mut fn_mut = create_fnmut();\n    let fn_once = create_fnonce();\n\n    fn_plain();\n    fn_mut();\n    fn_once();\n}\n```\n\n----------------------------------------\n\nTITLE: Multiple Input Register Assembly Operations\nDESCRIPTION: Shows a case where inlateout cannot be safely used due to register allocation in optimized builds.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/unsafe/asm.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse std::arch::asm;\n\nlet mut a: u64 = 4;\nlet b: u64 = 4;\nlet c: u64 = 4;\nunsafe {\n    asm!(\n        \"add {0}, {1}\",\n        \"add {0}, {2}\",\n        inout(reg) a,\n        in(reg) b,\n        in(reg) c,\n    );\n}\nassert_eq!(a, 12);\n```\n\n----------------------------------------\n\nTITLE: Safe Inlateout Usage in Assembly\nDESCRIPTION: Demonstrates a safe use of inlateout where the output is modified only after all inputs are read.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/src/unsafe/asm.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse std::arch::asm;\n\nlet mut a: u64 = 4;\nlet b: u64 = 4;\nunsafe {\n    asm!(\"add {0}, {1}\", inlateout(reg) a, in(reg) b);\n}\nassert_eq!(a, 8);\n```\n\n----------------------------------------\n\nTITLE: Building Rust by Example with mdbook\nDESCRIPTION: Instructions for cloning the repository, installing dependencies, and building the Rust by Example documentation. This requires Rust to be installed on the system and uses mdbook to generate the static site documentation.\nSOURCE: https://github.com/rust-lang/rust-by-example.git/blob/master/CONTRIBUTING.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ git clone https://github.com/rust-lang/rust-by-example\n$ cd rust-by-example\n$ cargo install mdbook\n$ mdbook build\n```"
  }
]