[
  {
    "owner": "tiramisulabs",
    "repo": "seyfert-docs",
    "content": "TITLE: String Option with Choices and Autocomplete in Seyfert (TS)\nDESCRIPTION: Demonstrates creating a string option with fixed choices, autocomplete functionality, and character limits using the Seyfert library. It shows how to use `createStringOption` with the `choices` and `autocomplete` properties to define available options and provide suggestions based on user input.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/commands/options.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// @exactOptionalPropertyTypes: false\nimport { Options, createStringOption, Command } from 'seyfert';\n\n@Options({\n    normal: createStringOption({\n        description: '',\n    }),\n\n    /// Fixed choices\n    choices: createStringOption({\n        description: '',\n        choices: [\n            { name: 'The best library', value: 'seyfert' },\n            { name: 'An odd stuff', value: 'meowdb' },\n        ] as const,\n    }),\n\n    /// Autocomplete\n    autocomplete: createStringOption({\n        description: '',\n        autocomplete: (interaction) => {\n            // logic here\n\n            const select = ['bugs', 'actions', 'random'];\n            const focus = interaction.getInput();\n            return interaction.respond(\n                select\n                    .filter((ch) => ch.includes(focus))\n                    .map((ch) => ({ name: ch, value: ch }))\n            );\n        },\n    }),\n\n    /// Character limits\n    limitLength: createStringOption({\n        description: '',\n        max_length: 500,\n        min_length: 200,\n    }),\n})\nclass Ping extends Command {}\n```\n\n----------------------------------------\n\nTITLE: Transforming Option Values with Seyfert\nDESCRIPTION: This code demonstrates how to transform the value of an option in Seyfert using the `value` method. It shows an example of validating a string option to ensure it's a valid URL. If the input is a valid URL, it transforms the string into a `URL` object using the `ok` function. Otherwise, it uses the `fail` function to return an error. The transformed value is then accessible via `ctx.options.url` with the correct type.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/commands/options.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n// @exactOptionalPropertyTypes: false\nfunction isUrl(url: string): boolean { return true; }\n// ---cut---\nimport { Options, createStringOption, Command } from 'seyfert';\nimport type { OKFunction, CommandContext } from 'seyfert';\n\nconst options = {\n    url: createStringOption({\n        description: 'how to be a gamer',\n\n        value(data, ok: OKFunction<URL>, fail) {\n            if (isUrl(data.value)) return ok(new URL(data.value));\n            fail('expected a valid url');\n        }\n    })\n}\n\n@Options(options)\nclass Ping extends Command {\n    run(ctx: CommandContext<typeof options>) {\n        ctx.options.url;\n                  // ^?\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Passing Middleware Data to Command in Typescript\nDESCRIPTION: This snippet modifies the logger middleware to pass data to the command. An interface `LoggerData` is defined to specify the type of data being passed. The `middle.next()` method is called with an object containing the current timestamp, which will be available to the command through the `ctx.metadata` property. The generic type `<LoggerData>` is used to define the type of data the middleware will pass.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/commands/middlewares.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createMiddleware } from \"seyfert\";\n\n// This interface is used to let the middleware know what type of data to pass to the command\ninterface LoggerData {\n    time: number;\n}\n\nexport const loggerMiddleware = createMiddleware<LoggerData>((middle) => {\n    // Log the command\n    console.log(`${middle.context.author.username} (${middle.context.author.id}) ran /${middle.context.resolver.fullCommandName}`);\n\n    // Pass the data to the command\n    middle.next({ time: Date.now() });\n});\n```\n\n----------------------------------------\n\nTITLE: Integer Option with Choices and Autocomplete in Seyfert (TS)\nDESCRIPTION: Shows how to create integer options with fixed choices, autocomplete, and value limits using the Seyfert library.  The `autocomplete` property in `createIntegerOption` is used to provide suggestions to the user, converting the selected string into an integer. Value limits restrict the range of acceptable inputs.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/commands/options.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// @exactOptionalPropertyTypes: false\nimport { Options, createIntegerOption, Command } from 'seyfert';\n\n@Options({\n    normal: createIntegerOption({\n        description: '',\n    }),\n    \n    /// Fixed choices\n    choices: createIntegerOption({\n        description: '',\n        choices: [\n            { name: 'seyfert', value: 1 },\n            { name: 'potocuit', value: 2 },\n            { name: 'biscuit', value: 3 }\n        ]\n    }),\n\n    /// Autocomplete\n    autocomplete: createIntegerOption({\n        description: '',\n        autocomplete: (interaction) => {\n            const select = ['1651611', '4616165156549', '15616416515616'];\n\n            const focus = interaction.getInput();\n\n            return interaction.respond(\n                select\n                    .filter((ch) => ch.includes(focus))\n                    .map((ch) => ({ name: ch, value: parseInt(ch) }))\n            );\n        }\n    }),\n\n    /// Value limits\n    limitValue: createIntegerOption({\n        description: '',\n        max_value: 500,\n        min_value: 200\n    })\n})\nclass Ping extends Command {}\n```\n\n----------------------------------------\n\nTITLE: Creating a Ping Command in Seyfert (TypeScript)\nDESCRIPTION: This code snippet demonstrates creating a basic 'ping' command using Seyfert. It imports necessary modules, declares the command with its name and description, and implements the `run` method to calculate and send the bot's latency to the user. The command utilizes the `@Declare` decorator and extends the `Command` class from the 'seyfert' library. The `CommandContext` provides access to the Discord client's gateway latency.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/getting-started/first-command.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { ParseClient, Client } from 'seyfert';\ndeclare module 'seyfert' {\n  interface UsingClient extends ParseClient<Client<true>> {}\n}\n// ---cut---\nimport { Declare, Command, type CommandContext } from 'seyfert';\n\n@Declare({\n  name: 'ping',\n  description: 'Show latency with Discord'\n})\nexport default class PingCommand extends Command {\n  async run(ctx: CommandContext) {\n    // Average latency between existing connections\n    const ping = ctx.client.gateway.latency;\n\n    await ctx.write({\n      content: `The latency is \\`${ping}\\``\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up Global Middlewares in Typescript\nDESCRIPTION: This code snippet demonstrates how to register global middlewares in a Seyfert client. Global middlewares are applied to all commands. The `globalMiddlewares` array specifies the names of the global middlewares to be used.  The client is initialized with this array. The `setServices` method combines global middlewares and regular middlewares.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/commands/middlewares.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  Client,\n  type ParseMiddlewares,\n  type ParseClient,\n  type ParseGlobalMiddlewares\n} from 'seyfert';\nimport { middlewares } from \"./path/to/middlewares\";\nimport { global } from \"./path/to/globals\";\n\nconst globalMiddlewares: (keyof typeof global)[] = ['logger']\n\n// Register middleware\nconst client = new Client({\n  globalMiddlewares\n});\n\nclient.setServices({\n  middlewares: { ...global, ...middlewares },\n});\n\ndeclare module 'seyfert' {\n  interface RegisteredMiddlewares\n    extends ParseMiddlewares<typeof middlewares & typeof global> {}\n  interface GlobalMetadata\n    extends ParseGlobalMiddlewares<typeof global> {}\n}\n```\n\n----------------------------------------\n\nTITLE: Number Option in Seyfert (TS)\nDESCRIPTION: Illustrates creating a number option using the Seyfert library.  This option type allows for decimal values, similar to integers but without the restriction to whole numbers.  The example demonstrates using `createNumberOption` within the `@Options` decorator.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/commands/options.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// @exactOptionalPropertyTypes: false\nimport { Options, createNumberOption, Command } from 'seyfert';\n\n@Options({\n    normal: createNumberOption({\n        description: '',\n    }),\n   \n    // Same logic as integers but applies to all numbers, including decimals\n})\nclass Ping extends Command {}\n```\n\n----------------------------------------\n\nTITLE: Creating String Options with Seyfert\nDESCRIPTION: This code demonstrates how to create different string options for a Discord command using the Seyfert library. It includes examples for normal string options, options with fixed choices, options with autocomplete functionality, and options with character limits. The `createStringOption` function is used to define each option, and the `@Options` decorator associates these options with the `Ping` command class.  The autocomplete function uses `interaction.respond` to return suggested values.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/commands/options.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// @exactOptionalPropertyTypes: false\nimport { Options, createStringOption, Command } from 'seyfert';\n\n@Options({\n    normal: createStringOption({\n        description: '',\n    }),\n\n\n    /// Opciones fijas\n    choices: createStringOption({\n        description: '',\n        choices: [\n            { name: 'The best library', value: 'seyfert' },\n            { name: 'An odd stuff', value: 'meowdb' },\n        ] as const,\n    }),\n\n    /// Autocompletado\n    autocomplete: createStringOption({\n        description: '',\n        autocomplete: (interaction) => {\n            // aquí la lógica\n\n            const select = ['bugs', 'actions', 'random'];\n            const focus = interaction.getInput();\n            return interaction.respond(\n                select\n                    .filter((ch) => ch.includes(focus))\n                    .map((ch) => ({ name: ch, value: ch }))\n            );\n        },\n    }),\n\n    /// Límites de carácteres\n    limitLength: createStringOption({\n        description: '',\n        max_length: 500,\n        min_length: 200,\n    }),\n})\nclass Ping extends Command {}\n```\n\n----------------------------------------\n\nTITLE: TypeScript autocomplete example for Seyfert options\nDESCRIPTION: Illustrates TypeScript autocomplete integration for Seyfert command options. It demonstrates how defining options with `createStringOption` and the `@Options` decorator enables type checking and autocomplete suggestions for the option values within the command's `run` method using `CommandContext`.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/commands/options.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// @exactOptionalPropertyTypes: false\nimport { Options, createStringOption, Command, CommandContext } from 'seyfert';\n\nconst options = {\n    /// Fixed choices\n    best: createStringOption({\n        description: '',\n        choices: [\n            { name: 'The best library', value: 'seyfert' },\n            { name: 'An odd stuff', value: 'meowdb' },\n        ] as const,\n    }),\n};\n\n@Options(options)\nclass Ping extends Command {\n    async run(ctx: CommandContext<typeof options>) {\n        ctx.options.best;\n        //          ^?\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up Client with Middlewares in Typescript\nDESCRIPTION: This snippet showcases how to initialize a Seyfert client, register the previously defined middlewares, and augment the Seyfert types to include the registered middlewares. The client's `setServices` method is used to register the middlewares, and declaration merging is used to extend the `RegisteredMiddlewares` interface.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/commands/middlewares.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Client, type ParseMiddlewares, type ParseClient } from \"seyfert\";\nimport { middlewares } from \"./path/to/middlewares\";\n\nconst client = new Client();\n\n// Register the middlewares\nclient.setServices({\n  middlewares: middlewares\n});\n\ndeclare module \"seyfert\" {\n  interface UsingClient extends ParseClient<Client<true>> {}\n\n  // Register the middlewares on seyfert types\n  interface RegisteredMiddlewares\n    extends ParseMiddlewares<typeof middlewares> {}\n}\n```\n\n----------------------------------------\n\nTITLE: seyfert.config.mjs (HTTP Bot)\nDESCRIPTION: This snippet configures Seyfert for an HTTP-based bot using the `config.http` function.  It sets the bot token, application ID, public key, file locations for commands, and port. All required environment variables must be set for the application to work. `locations.base` indicates the root directory, and `locations.commands` where the bot command files are.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/getting-started/setup-project.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// This is not shown, prevents errors.\nprocess.env.BOT_APP_ID = '';\nprocess.env.BOT_PUBLIC_KEY = '';\nprocess.env.BOT_TOKEN = '';\n// ---cut---\nimport { config } from \"seyfert\";\n\nconst  {\n    BOT_TOKEN, BOT_APP_ID, BOT_PUBLIC_KEY\n} = process.env;\n\nexport default config.http({\n    token: BOT_TOKEN,\n    locations: {\n        base: \"dist\", // replace with \"src\" if using bun\n        commands: \"commands\"\n    },\n    applicationId: BOT_APP_ID,\n    port: 3000, // default is 8080\n    publicKey: BOT_PUBLIC_KEY\n});\n```\n\n----------------------------------------\n\nTITLE: Handling Command Execution Errors in Seyfert (TypeScript)\nDESCRIPTION: This snippet demonstrates how to handle errors that occur during the `run` method of a Seyfert command using the `onRunError` method. It logs the error and sends a message to the user.  It requires the `Command` and `CommandContext` types from the `seyfert` library.  The input is a `CommandContext` and an `error` object. The output is a message to the user with the error message.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/commands/handling-errors.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Command, type CommandContext } from \"seyfert\";\n\nexport class HandlingErrors extends Command {\n  async run(context: CommandContext) {\n    throw new Error(\"Error, ehm, lol player detected\");\n  }\n\n// @log: This responds with the previous error message: \"Error, ehm, lol player detected\"\n  async onRunError(context: CommandContext, error: unknown) {\n    context.client.logger.fatal(error);\n    await context.editOrReply({\n      content: error instanceof Error ? error.message : `Error: ${error}`\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Proxy for Direct API Access\nDESCRIPTION: This code demonstrates how to use the proxy object to directly interact with the Discord API. It creates a thread in a channel using `client.proxy.channels(channel.id).threads.post`. This is useful for accessing features not yet supported by Seyfert's higher-level abstractions, and gives developers complete control over their discord bot functionalities.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/api-access.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent } from 'seyfert';\n\nexport default createEvent({\n\tdata: { name: 'channelCreate' },\n\trun: async (channel, client) => {\n\t\tif (!channel.isThreadOnly()) return; \n\n\t\t// assuming that channel.thread method does not exist\n\t\t// the \"object\" will follow the same structure as the discord endpoints have\n\t\tawait client.proxy.channels(channel.id).threads.post({ // highlighted line\n\t\t\tbody: { // highlighted line\n\t\t\t\tname: 'First thread!', // highlighted line\n\t\t\t\tmessage: { // highlighted line\n\t\t\t\t\tcontent: 'Seyfert >', // highlighted line\n\t\t\t\t}, // highlighted line\n\t\t\t}, // highlighted line\n\t\t\treason: \"I'm always the first\", // highlighted line\n\t\t}); // highlighted line\n\t},\n});\n```\n\n----------------------------------------\n\nTITLE: Receiving Middleware Data in a Command in Typescript\nDESCRIPTION: This snippet shows how to receive data passed by a middleware in a Seyfert command.  The `CommandContext` is parameterized with `<never, \"logger\">` to indicate that the command expects data from the `logger` middleware. The data is accessed via `ctx.metadata.logger`, and the `time` property is extracted and used in the command's reply.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/commands/middlewares.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Middlewares, Declare, Command, type CommandContext } from \"seyfert\";\n\n@Declare({\n    name: \"ping\",\n    description: \"Ping the bot\"\n})\n@Middlewares([\"logger\"])\nexport default class PingCommand extends Command {\n    async run(ctx: CommandContext<never, \"logger\">) {\n        const time = ctx.metadata.logger.time;\n        console.log(time);\n        await ctx.reply({\n            content: `Pong! Time: ${time}`,\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Extending Seyfert Client with Middlewares (TypeScript)\nDESCRIPTION: This code snippet extends the Seyfert `Client` to register the created middlewares and update the type definitions. It uses `client.setServices` to register the middlewares. It also declares module augmentations to register the middlewares in the Seyfert type system via interfaces `UsingClient` and `RegisteredMiddlewares`.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/commands/middlewares.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Client, type ParseMiddlewares, type ParseClient } from \"seyfert\";\nimport { middlewares } from \"./path/to/middlewares\";\n\nconst client = new Client();\n\n// Registrar los middlewares\nclient.setServices({\n  middlewares: middlewares\n});\n\ndeclare module \"seyfert\" {\n  interface UsingClient extends ParseClient<Client<true>> {}\n\n  // Registrar los middlewares en los tipos de Seyfert\n  interface RegisteredMiddlewares\n    extends ParseMiddlewares<typeof middlewares> {}\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Language File (English)\nDESCRIPTION: This code snippet illustrates the creation of a language file (`languages/en.ts`) that exports a default object containing translations for the English language. The object consists of key-value pairs where the keys represent translation keys and the values are the corresponding translations. The values can be strings or functions that return strings, allowing for dynamic translations.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/i18n/languages.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport default {\n  hello: \"Each key value pair will be the translation for the key\",\n  foo: {\n    bar: \"You may nest objects to create a more complex language file\",\n    baz: () => `You may also use functions to pass variables to the translation and add some logic`,\n    ping: ({ ping }: { ping: number }) => `The ping is ${ping}`\n  },\n  qux: [\n    \"You may also use arrays to create a list of translations\",\n    \"This is the second item in the list\"\n  ].join(\"\\n\")\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Parent Command with Subcommands in Seyfert (TypeScript)\nDESCRIPTION: This code defines a parent command (`AccountCommand`) and registers two subcommands (`CreateCommand` and `DeleteCommand`) using the `@Options` decorator.  The `@Declare` decorator sets the command's name and description. This example assumes the subcommands are located in the same directory and exported by default for `@Autoload()` to work. The `Command` class from 'seyfert' is extended to create the command.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/commands/subcommands.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Declare, Command, Options } from \"seyfert\";\nimport { CreateCommand } from \"./create.command\";\nimport { DeleteCommand } from \"./delete.command\";\n\n@Declare({\n\tname: \"account\",\n\tdescription: \"account command\"\n})\n// Being in the same folder with @AutoLoad() you can save this step\n@Options([CreateCommand, DeleteCommand])\nexport default class AccountCommand extends Command {}\n```\n\n----------------------------------------\n\nTITLE: Sending Messages with Components using Seyfert (TypeScript)\nDESCRIPTION: This snippet demonstrates sending messages with attached components, specifically a button and a select menu. It uses the `ActionRow`, `Button`, and `StringSelectMenu` builders from Seyfert. It creates a button and a select menu, adds them to separate action rows, and then sends the message with both action rows attached.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/sending-messages.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  ActionRow,\n  Button,\n  StringSelectMenu,\n  StringSelectOption,\n  Command,\n  type CommandContext\n} from 'seyfert';\nimport { ButtonStyle } from 'seyfert/lib/types'\n\nexport default class HelloWorldCommand extends Command {\n  async run(ctx: CommandContext) {\n   \n   \n    const button = new Button()\n      .setCustomId('helloworld')\n      .setLabel('Hello World')\n      .setStyle(ButtonStyle.Primary);\n\n    const buttonRow = new ActionRow<Button>().addComponents(button);\n\n\n\n    const menu = new StringSelectMenu()\n      .setCustomId('select-helloworld')\n      .addOption(\n        new StringSelectOption().setLabel('Hello').setValue('option_1')\n      );\n\n    const menuRow = new ActionRow<StringSelectMenu>().addComponents(menu);\n\n    await ctx.write({ content: 'Hello world 👋', components: [buttonRow, menuRow] });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: User Option in Seyfert (TS)\nDESCRIPTION: Demonstrates creating a user option that allows users to specify a Discord user in a command using the Seyfert library. The `required` property is set to true, so the user must specify a user when using the command.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/commands/options.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n// @exactOptionalPropertyTypes: false\nimport { Options, createUserOption, Command } from 'seyfert';\n\n@Options({\n    user: createUserOption({\n        description: 'This is a user option',\n        required: true\n    })\n})\nclass Ping extends Command {}\n```\n\n----------------------------------------\n\nTITLE: Sending an Embed with Seyfert (TypeScript)\nDESCRIPTION: This snippet illustrates how to send an embedded message using the `Embed` builder from Seyfert. It creates an `Embed` instance, sets the title and description, and then sends it using `CommandContext.write()` with the `embeds` property.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/sending-messages.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Embed, Command, type CommandContext } from 'seyfert';\n\nexport default class HelloWorldCommand extends Command {\n  async run(ctx: CommandContext) {\n    \n    \n    const embed = new Embed()\n      .setTitle('My Amazing Embed')\n      .setDescription('Hello world 👋');\n\n    await ctx.write({ embeds: [embed] });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Stopping Middleware Execution in Typescript\nDESCRIPTION: This snippet expands on the logger middleware to include a check for the channel type. If the command is executed in a DM (Direct Message), the middleware stops the execution of the command using `middle.stop()` and returns an error message. Otherwise, it proceeds to the next middleware or the command itself. This prevents the command from running in unintended contexts.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/commands/middlewares.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createMiddleware } from \"seyfert\";\nimport { ChannelType } from 'seyfert/lib/types';\n\nexport const loggerMiddleware = createMiddleware<void>((middle) => {\n  // Log the command\n  console.log(\n    `${middle.context.author.username} (${middle.context.author.id}) ran /(${middle.context.resolver.fullCommandName}`\n  );\n\n  // Check if the command is being executed in a guild\n  if (middle.context.interaction.channel?.type === ChannelType.DM) {\n    return middle.stop(\"This command can only be used in a guild.\");\n  }\n\n  // Pass to the next middleware if the command is being executed in a guild\n  middle.next();\n});\n```\n\n----------------------------------------\n\nTITLE: src/index.ts (Gateway Bot)\nDESCRIPTION: This snippet initializes and starts a Seyfert Gateway bot. It creates a new `Client` instance and calls the `start` method to connect to the Discord gateway and load commands, events, components, and language files. The entry point to start the bot.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/getting-started/setup-project.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Client } from \"seyfert\";\n\nconst client = new Client();\n\n// This will start the connection with the Discord gateway and load commands, events, components, and language (i18n)\nclient.start();\n```\n\n----------------------------------------\n\nTITLE: Creating Select Menus and ActionRows in Seyfert\nDESCRIPTION: This snippet demonstrates how to create different types of select menu components, including StringSelectMenu, UserSelectMenu, RoleSelectMenu, ChannelSelectMenu, and MentionableSelectMenu, and add each of them to their corresponding ActionRows using the Seyfert library. It showcases the customization of each select menu with different properties and options. It requires the 'seyfert' package.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/components/building-components.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  ActionRow,\n  StringSelectMenu,\n  StringSelectOption,\n  UserSelectMenu,\n  RoleSelectMenu,\n  ChannelSelectMenu,\n  MentionableSelectMenu\n} from 'seyfert';\n\nconst stringMenu = new StringSelectMenu()\n  .setCustomId('string-menu')\n  .setPlaceholder('Select an string option')\n  .addOption(\n    new StringSelectOption().setLabel('Option 1').setValue('1'),\n    new StringSelectOption().setLabel('Option 2').setValue('2')\n  );\n\nconst stringRow = new ActionRow<StringSelectMenu>().setComponents([stringMenu]);\n\nconst userMenu = new UserSelectMenu()\n  .setCustomId('user-menu')\n  .setPlaceholder('Select an user')\n  //user id's\n  .setDefaultUsers('123456789', '987654321');\n\nconst userRow = new ActionRow<UserSelectMenu>().setComponents([userMenu]);\n\nconst roleMenu = new RoleSelectMenu()\n  .setCustomId('role-menu')\n  .setPlaceholder('Select a role')\n  //role id's\n  .setDefaultRoles('123456789', '987654321');\n\nconst roleRow = new ActionRow<RoleSelectMenu>().setComponents([roleMenu]);\n\nconst channelMenu = new ChannelSelectMenu()\n  .setCustomId('channel-menu')\n  .setPlaceholder('Select a channel')\n  //channel id's\n  .setDefaultChannels('123456789', '987654321');\n\nconst channelRow = new ActionRow<ChannelSelectMenu>().setComponents([\n  channelMenu\n]);\n\nconst mentionableMenu = new MentionableSelectMenu()\n  .setCustomId('mentionable-menu')\n  .setPlaceholder('Select a mentionable')\n  //mentionable id's (role or user)\n  .setDefaultMentionables(\n    { type: 'User', id: '123456789' },\n    { type: 'Role', id: '987654321' }\n  );\n\nconst mentionableRow = new ActionRow<MentionableSelectMenu>().setComponents([\n  mentionableMenu\n]);\n\n```\n\n----------------------------------------\n\nTITLE: Creating a Subcommand in Seyfert (TypeScript)\nDESCRIPTION: This code snippet shows how to create a subcommand using the `SubCommand` class from 'seyfert'.  The `@Declare` decorator sets the subcommand's name and description. The `run` method is implemented to define the subcommand's logic, taking a `CommandContext` object as input and returning a `ctx.write` promise.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/commands/subcommands.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { type CommandContext, Declare, SubCommand } from \"seyfert\";\n\n@Declare({\n\tname: \"create\",\n\tdescription: \"create a new something\"\n})\nexport class CreateCommand extends SubCommand {\n\trun(ctx: CommandContext) {\n\t\t// some logic here\n\n\t\treturn ctx.write({\n\t\t\tcontent: \"create command executed\"\n\t\t});\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Transforming Option Value in Seyfert (TS)\nDESCRIPTION: Explains how to transform the value of a Seyfert command option using the `value` method. This example validates a URL string and converts it to a `URL` object if valid, or throws an error if it's invalid.  It demonstrates using `OKFunction` and a fail callback for handling validation.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/commands/options.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n// @exactOptionalPropertyTypes: false\nfunction isUrl(url: string): boolean { return true; }\n// ---cut---\nimport { Options, createStringOption, Command } from 'seyfert';\nimport type { OKFunction, CommandContext } from 'seyfert';\n\nconst options = {\n    url: createStringOption({\n        description: 'how to be a gamer',\n\n        value(data, ok: OKFunction<URL>, fail) {\n            if (isUrl(data.value)) return ok(new URL(data.value));\n            fail('expected a valid url');\n        }\n    })\n}\n\n@Options(options)\nclass Ping extends Command {\n    run(ctx: CommandContext<typeof options>) {\n        ctx.options.url;\n                  // ^?\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Account Command Definition with Subcommands\nDESCRIPTION: This code defines the parent `AccountCommand` and declares it as a command using the `@Declare` decorator. It also uses the `@Options` decorator to register `CreateCommand` and `DeleteCommand` as subcommands.  If all files are in the same folder, you can use `@AutoLoad` instead of `@Options`.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/commands/subcommands.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Declare, Command, Options } from \"seyfert\";\nimport { CreateCommand } from \"./create.command\";\nimport { DeleteCommand } from \"./delete.command\";\n\n@Declare({\n\tname: \"account\",\n\tdescription: \"account command\"\n})\n// Si están en la misma carpeta, puedes usar @AutoLoad y ahorrarte esto.\n@Options([CreateCommand, DeleteCommand])\nexport default class AccountCommand extends Command {}\n```\n\n----------------------------------------\n\nTITLE: Using Translations in a Command\nDESCRIPTION: This code snippet demonstrates how to use translations within a Seyfert command. It adds a `language` option to the command, allowing users to specify the desired language for the response. The `ctx.t.get(lang)` method is used to retrieve the translations for the specified language, and the `t.foo.ping({ ping })` syntax accesses specific translations based on the language.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/i18n/languages.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// @exactOptionalPropertyTypes: false\nimport type { ParseClient, Client, ParseLocales } from 'seyfert';\nconst English = {\n  foo: {\n    ping(data: { ping: number }) {\n      return `Pong: ${data.ping}` as const\n    }\n  }\n};\ndeclare module 'seyfert' {\n  interface UsingClient extends ParseClient<Client<true>> {}\n\n  interface DefaultLocale extends ParseLocales<typeof English> {}\n}\n// ---cut---\nimport {\n  Command,\n  Declare,\n  Options,\n  createBooleanOption,\n  createStringOption,\n  type CommandContext\n} from 'seyfert';\nimport { MessageFlags } from 'seyfert/lib/types';\n\nconst options = {\n  hide: createBooleanOption({\n    description: \"Hide command output\",\n  }),\n  language: createStringOption({\n    description: \"Language to respond in\",\n    choices: [\n      { name: \"English\", value: \"en\" },\n      { name: \"Spanish\", value: \"es\" }\n    ]\n  })\n}\n\n@Declare({\n  name: 'ping',\n  description: 'Show the ping with discord'\n})\n@Options(options)\nexport default class PingCommand extends Command {\n\n  async run(ctx: CommandContext<typeof options>) {\n    const flags = ctx.options.hide ? MessageFlags.Ephemeral : undefined;\n    const lang = ctx.options.language;\n\n    // Get the translations for the language\n    const t = ctx.t.get(lang);\n\n    // average latency between shards\n    const ping = ctx.client.gateway.latency;\n\n    await ctx.write({\n      content: t.foo.ping({ ping }),\n      flags,\n    });\n  }\n\n}\n```\n\n----------------------------------------\n\nTITLE: Building a Component Collector in Seyfert\nDESCRIPTION: This snippet demonstrates how to build a simple component collector after sending a message with an attached button. It utilizes the `createComponentCollector` method on a message object.  The message is sent with a button using `ctx.write` and `fetchReply` is set to true to retrieve the sent message.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/components/collectors.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  Button,\n  ActionRow,\n  Command,\n  Declare,\n  type CommandContext,\n} from 'seyfert';\n\nimport { ButtonStyle } from 'seyfert/lib/types';\n\n@Declare({\n  name: 'hello',\n  description: 'I will send you a hello world message',\n})\nexport default class HelloWorldCommand extends Command {\n  async run(ctx: CommandContext) {\n    const button = new Button()\n      .setCustomId('hello')\n      .setLabel('Hello')\n      .setStyle(ButtonStyle.Primary);\n\n    const row = new ActionRow<Button>().setComponents([button]);\n\n    // To get the message with the attached button, you can set the fetchReply to \"true\".\n    const message = await ctx.write(\n      {\n        content: 'Do you want a hello world? Click the button below.',\n        components: [row],\n      },\n      true\n    );\n\n    const collector = message.createComponentCollector();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Mentionable Option in Seyfert (TS)\nDESCRIPTION: Shows how to create a mentionable option in a Seyfert command, allowing users to mention either a user or a role.  The `required` property is set to true, so the user must specify a mentionable value when using the command.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/commands/options.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n// @exactOptionalPropertyTypes: false\nimport { Options, createMentionableOption, Command } from 'seyfert';\n\n@Options({\n    mentionable: createMentionableOption({\n        description: 'This is a mentionable option',\n        required: true\n    })\n})\nclass Ping extends Command {}\n```\n\n----------------------------------------\n\nTITLE: Declaring a Command with Decorator\nDESCRIPTION: This code snippet demonstrates how to declare a command in Seyfert using the `@Declare` decorator. It showcases various properties that can be configured, such as name, description, permissions (both member and bot), guild ID, NSFW status, aliases, integration types, contexts, and ignore settings.  It extends the base `Command` class.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/commands/intro.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Declare, Command, IgnoreCommand } from 'seyfert';\n\n@Declare({\n    name: 'your-command',\n    description: 'A description for this command',\n    // Properties to pass as metadata\n    props: {},\n\n    // List of permissions required by the member\n    defaultMemberPermissions: ['Administrator'],\n\n    // List of permissions required by the bot\n    botPermissions: ['ManageGuild'],\n\n    // List of server IDs to register the command\n    guildId: ['100000'],\n\n    // Determines if the command is NSFW\n    nsfw: false,\n\n    // List of alternate names for the command (text commands)\n    aliases: ['an-alias'],\n\n    // Identifies the installation types the command supports,\n    //   default is server-only\n    integrationTypes: ['GuildInstall', 'UserInstall'],\n\n    // Specifies where a command can be used\n    contexts: ['BotDM', 'Guild', 'PrivateChannel'],\n\n    // Defines whether to ignore the execution of the command in slash\n    //   or text-message versions\n    ignore: IgnoreCommand.Slash,\n    //                    ^|\n\n    // Sets the type of command:\n    /// type: ApplicationCommandType.User\n})\nclass MyCommand extends Command {}\n```\n\n----------------------------------------\n\nTITLE: Creating a Spanish Translation File (TypeScript)\nDESCRIPTION: This code snippet demonstrates creating a Spanish translation file (`languages/es.ts`) and uses a TypeScript utility type `satisfies typeof English` to ensure that the structure of the Spanish translation object matches the structure of the English translation object, thus preventing errors.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/i18n/languages.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport type English from \"./en\";\n\nexport default {\n  hello: \"Hola, mundo!\",\n  foo: {\n    bar: \"Puedes anidar objetos para crear un archivo de idioma más complejo\",\n    baz: () => `Puedes usar funciones para pasar variables a la traducción y agregar lógica`,\n    ping: ({ ping }) => `El ping es ${ping}`\n  },\n  qux: [\n    \"También puedes usar arrays para crear una lista de traducciones\",\n    \"Este es el segundo elemento de la lista\"\n  ].join(\"\\n\")\n} satisfies typeof English; // Este es un type de utilidad para asegurar que el objeto es el mismo en todos los idiomas\n```\n\n----------------------------------------\n\nTITLE: Channel Option in Seyfert (TS)\nDESCRIPTION: Demonstrates how to create a channel option, allowing users to specify a Discord channel in a command using the Seyfert library. The example includes the option to restrict the channel type using the `channel_types` property and `ChannelType` enum.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/commands/options.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// @exactOptionalPropertyTypes: false\nimport { Options, createChannelOption, Command } from 'seyfert';\nimport { ChannelType } from 'seyfert/lib/types';\n\n@Options({\n    channel: createChannelOption({\n        description: '',\n    }),\n\n    /// Specific channel type\n    channelTypes: createChannelOption({\n        description: 'This is a limited channel option',\n        channel_types: [ChannelType.GuildVoice]\n    })\n})\nclass Ping extends Command {}\n```\n\n----------------------------------------\n\nTITLE: Implementing Premium Command with Seyfert\nDESCRIPTION: This snippet demonstrates how to create a premium command using Seyfert, which checks user entitlements to determine if they have access to premium features. If the user is not a premium subscriber, the command displays a button that allows them to subscribe. If they are a subscriber, the code proceeds with the premium functionality.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/monetization.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Declare, Command, type CommandContext, ActionRow, Button } from 'seyfert';\nimport { ButtonStyle } from 'seyfert/lib/types';\n\n@Declare({\n  name: 'premium',\n  description: 'Premium command',\n})\nexport class PremiumCommand extends Command  {\n  run(ctx: CommandContext) {\n    const isPremium = ctx.interaction.entitlements.length;\n\n    const row = new ActionRow()\n    .setComponents([\n        new Button()\n        .setSKUId('STORE_ITEM_SKU_ID')\n        .setStyle(ButtonStyle.Premium)\n    ]);\n\n    if (!isPremium) return ctx.editOrReply({ \n        content: 'Click to subscribe and get access to the command!',\n        components: [row] \n    });\n\n    // Premium code\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Sending ActionRow with Button in Seyfert Command\nDESCRIPTION: This snippet shows how to create a Seyfert command that sends a message with an ActionRow containing a button. The button's label dynamically displays the ping. It requires the 'seyfert' package, ButtonStyle enum from 'seyfert/lib/types', and the command decorator.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/components/building-components.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { ParseClient, Client } from 'seyfert';\ndeclare module 'seyfert' {\n  interface UsingClient extends ParseClient<Client<true>> {}\n}\n// ---cut---\nimport { Declare, Command, type CommandContext, ActionRow, Button } from 'seyfert';\nimport { ButtonStyle } from 'seyfert/lib/types';\n\n@Declare({\n  name: 'ping',\n  description: 'Show the ping with discord'\n})\nexport default class PingCommand extends Command {\n\n\tasync run(ctx: CommandContext) {\n\t\t// average latency between shards\n    const ping = ctx.client.gateway.latency;\n\n    const row = new ActionRow()\n      .setComponents([\n        new Button().setCustomId('pingbtn').setLabel(`Ping: ${ping}`).setStyle(ButtonStyle.Primary)\n      ])\n\n    await ctx.write({\n      content: `The ping is \\`${ping}\\``,\n      components: [row]\n    });\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating Prefix Command with Options\nDESCRIPTION: This code snippet demonstrates how to create a Seyfert command with options for prefix commands. It defines a `crosspost` command that accepts a message ID as an option. The `Options` decorator is used to specify the available options for the command, created using `createStringOption`. The `run` method then accesses the option value from the `CommandContext` to crosspost the specified message.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/commands/prefix-commands.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n    Command,\n    CommandContext,\n    Declare,\n    Options,\n    createStringOption\n} from 'seyfert';\n\nconst options = {\n    id: createStringOption({\n        description: 'The ID of the message we are going to crosspost',\n        required: true\n    })\n};\n\n@Declare({\n    name: 'crosspost',\n    description: 'Crosspost an announcement message.'\n})\n@Options(options)\nexport default class CrosspostCommand extends Command {\n    async run(ctx: CommandContext<typeof options>){\n        await ctx.client.messages.crosspost(ctx.options.id, ctx.channelId);\n        return ctx.write({ content: 'I have crossposted your announcement.'});\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Registering Middlewares in Typescript\nDESCRIPTION: This code snippet shows how to register created middlewares in a separate file and export them to be used in other parts of the application.  It imports the `loggerMiddleware` and exports it as part of the `middlewares` object, where the key represents the name to be used when referencing the middleware.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/commands/middlewares.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { loggerMiddleware } from \"./path/to/logger.middleware\";\n\nexport const middlewares = {\n    // The key is the name of the middleware which will be used to reference it on the command\n    logger: loggerMiddleware\n}\n```\n\n----------------------------------------\n\nTITLE: Create Start Poll Subcommand in Seyfert\nDESCRIPTION: This TypeScript code snippet defines a subcommand named `start` for creating a new poll. It uses the `Declare` and `Options` decorators to define the command's metadata and options. The `run` method handles the command's logic, including retrieving the question and answers from the options, creating a new poll using the `PollBuilder`, and sending the poll to the channel.  It uses `createStringOption` and `createNumberOption` to define the expected options.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/components/polls.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// @exactOptionalPropertyTypes: false\nimport {\n    type CommandContext,\n    Declare,\n    type OKFunction,\n    Options,\n    PollBuilder,\n    SubCommand,\n    createStringOption,\n    createNumberOption,\n} from 'seyfert';\nimport { MessageFlags } from 'seyfert/lib/types';\n\nconst options = {\n    question: createStringOption({\n        description: 'Poll question.',\n        required: true,\n    }),\n    answers: createStringOption({\n        description: 'Poll answers separated by commas.',\n        required: true,\n        // Esto se puede mejorar, pero es un ejemplo rápido\n        value: ({ value }, ok: OKFunction<string[] | null>) => {\n            // Esto es para tener más opciones en la encuesta\n            // Ejemplo: ganyu, supremacía\n            const answers = value.split(', ');\n            if (!answers.length) return ok(null);\n            \n            return ok(answers);\n        },\n    }),\n    // La duración de la encuesta en horas.\n    // Ejemplo: 1, 2, 5...\n    hours: createNumberOption({\n        description: 'The duration of the poll.'\n    }),\n};\n\n@Declare({\n    name: 'start',\n    description: 'Create a new poll.',\n})\n@Options(options)\nexport default class StartPoll extends SubCommand {\n    async run(ctx: CommandContext<typeof options>) {\n        const { options } = ctx;\n        const { question, answers } = options;\n\n        const channel = await ctx.channel('rest');\n\n        if (!channel.isTextGuild()) return;\n        if (!answers)\n            return ctx.editOrReply({\n                flags: MessageFlags.Ephemeral,\n                content: 'Answers needs to be separed by commas!',\n            });\n\n        const hours = options.hours ?? 1;\n\n        // Tenemos un nuevo constructor para las encuestas.\n        // PollBuilder hace que sea más fácil crear encuestas.\n        const newPoll = new PollBuilder()\n            .allowMultiselect(true)\n            .setQuestion({ text: question })\n            .setAnswers(\n                // Las respuestas tienen un máximo de 10              \n                answers.map((text) => ({ \n                    text,\n                    // También puedes añadir emojis\n                    emoji: '🐐'\n                }))\n            )\n            .setDuration(hours);\n\n        await channel.messages.write({\n            content: 'New poll started.',\n            poll: newPoll\n        });\n\n        await ctx.editOrReply({\n            content: `Poll started in the channel: ${channel.toString()}`,\n            flags: MessageFlags.Ephemeral,\n        });\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Logger Middleware in Typescript\nDESCRIPTION: This code snippet demonstrates the creation of a basic logger middleware using Seyfert's `createMiddleware` function. It logs the command being executed along with the author's username and ID. The middleware then calls `middle.next()` to pass control to the next middleware or the command itself. The generic type `<void>` indicates that the middleware does not pass any data to the command.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/commands/middlewares.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createMiddleware } from \"seyfert\";\n\n// The generic type tells the middleware what information it'll pass to the command\nexport const loggerMiddleware = createMiddleware<void>(\n  (middle) => {\n    // Log the command\n    console.log(\n      `${middle.context.author.username} (${middle.context.author.id}) ran /(${middle.context.resolver.fullCommandName}`\n    );\n\n    // Pass to the next middleware\n    middle.next();\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: Creating a Seyfert Subcommand to Start a Poll\nDESCRIPTION: This code snippet demonstrates how to create a subcommand named 'start' within the 'poll' command in Seyfert. It defines options for the poll question, answers (separated by commas), and duration in hours.  It uses `PollBuilder` to construct the poll and sends it to the channel. It includes validation for the answers and defaults the duration to 1 hour if not provided.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/components/polls.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// @exactOptionalPropertyTypes: false\nimport {\n    type CommandContext,\n    Declare,\n    type OKFunction,\n    Options,\n    PollBuilder,\n    SubCommand,\n    createStringOption,\n    createNumberOption,\n} from 'seyfert';\nimport { MessageFlags } from 'seyfert/lib/types';\n\nconst options = {\n    question: createStringOption({\n        description: 'Poll question.',\n        required: true,\n    }),\n    answers: createStringOption({\n        description: 'Poll answers separated by commas.',\n        required: true,\n        // This can be improved, but it’s a quick example\n        value: ({ value }, ok: OKFunction<string[] | null>) => {\n            // This is for more poll options\n            // Example: ganyu, supremacy\n            const answers = value.split(', ');\n            if (!answers.length) return ok(null);\n            \n            return ok(answers);\n        },\n    }),\n    // Poll duration in hours.\n    // Example: 1, 2, 5...\n    hours: createNumberOption({\n        description: 'The duration of the poll.'\n    }),\n};\n\n@Declare({\n    name: 'start',\n    description: 'Create a new poll.',\n})\n@Options(options)\nexport default class StartPoll extends SubCommand {\n    async run(ctx: CommandContext<typeof options>) {\n        const { options } = ctx;\n        const { question, answers } = options;\n\n        const channel = await ctx.channel('rest');\n\n        if (!channel.isTextGuild()) return;\n        if (!answers)\n            return ctx.editOrReply({\n                flags: MessageFlags.Ephemeral,\n                content: 'Answers need to be separated by commas!',\n            });\n\n        const hours = options.hours ?? 1;\n\n        // We have a new poll builder.\n        // PollBuilder makes it easier to create polls.\n        const newPoll = new PollBuilder()\n            .allowMultiselect(true)\n            .setQuestion({ text: question })\n            .setAnswers(\n                // Answers have a limit of 10              \n                answers.map((text) => ({ \n                    text,\n                    // You can also add emojis\n                    emoji: '🐐'\n                }))\n            )\n            .setDuration(hours);\n\n        await channel.messages.write({\n            content: 'New poll started.',\n            poll: newPoll\n        });\n\n        await ctx.editOrReply({\n            content: `Poll started in the channel: ${channel.toString()}`,\n            flags: MessageFlags.Ephemeral,\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing the 'play' Command (play.ts)\nDESCRIPTION: This TypeScript snippet shows the implementation of a 'play' command using Seyfert's command structure and the Kazagumo library. It retrieves user voice channel information, searches for the provided query, and adds the result to the Kazagumo player queue, initiating playback if it's not already running.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/music.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n\tCommand,\n\tDeclare,\n\tOptions,\n\ttype CommandContext,\n\tcreateStringOption\n} from \"seyfert\";\nimport { MessageFlags } from \"seyfert/lib/types\";\n\nconst options = {\n\tquery: createStringOption({\n\t\tdescription: \"Enter a song name or url.\",\n\t\trequired: true\n\t})\n};\n\n@Declare({\n\tname: \"play\",\n\tdescription: \"Play music.\"\n})\n@Options(options)\nexport default class PlayCommand extends Command {\n\tasync run(ctx: CommandContext<typeof options>) {\n\t\tconst { options, client, guildId, channelId, member, author } = ctx;\n\t\tconst { query } = options;\n\n\t\tif (!guildId || !member) return;\n\n\t\tconst voice = await member.voice();\n\t\tif (!voice)\n\t\t\treturn ctx.write({\n\t\t\t\tcontent: \"You must be in a voice channel to play music.\",\n\t\t\t\tflags: MessageFlags.Ephemeral\n\t\t\t});\n\n\t\tconst botVoice = await ctx.me()?.voice();\n\t\tif (botVoice && botVoice.channelId !== voice.channelId)\n\t\t\treturn ctx.write({\n\t\t\t\tcontent: \"You must be in the same voice channel as me.\",\n\t\t\t\tflags: MessageFlags.Ephemeral\n\t\t\t});\n\n\t\tconst player = await client.kazagumo.createPlayer({\n\t\t\tguildId: guildId,\n\t\t\ttextId: channelId,\n\t\t\tvoiceId: voice.channelId,\n\t\t\tvolume: 100\n\t\t});\n\n\t\tconst result = await client.kazagumo.search(query, { requester: author });\n\t\tif (!result.tracks.length)\n\t\t\treturn ctx.write({ content: \"No results found!\" });\n\n\t\tif (result.type === \"PLAYLIST\") player.queue.add(result.tracks);\n\t\telse player.queue.add(result.tracks[0]);\n\n\t\tif (!player.playing && !player.paused) player.play();\n\n\t\treturn ctx.write({\n\t\t\tcontent:\n\t\t\t\tresult.type === \"PLAYLIST\"\n\t\t\t\t\t? `Queued ${result.tracks.length} from ${result.playlistName}`\n\t\t\t\t\t: `Queued ${result.tracks[0].title}`\n\t\t});\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Ping Command with Seyfert (TypeScript)\nDESCRIPTION: This code snippet demonstrates creating a basic 'ping' command using the Seyfert framework. It defines a class that extends the `Command` class and uses the `@Declare` decorator to specify the command's name and description. The `run` method calculates the gateway latency and sends a message to the channel with the latency value. It requires the `seyfert` package.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/getting-started/first-command.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { ParseClient, Client } from 'seyfert';\ndeclare module 'seyfert' {\n  interface UsingClient extends ParseClient<Client<true>> {}\n}\n// ---cut---\nimport { Declare, Command, type CommandContext } from 'seyfert';\n\n@Declare({\n  name: 'ping',\n  description: 'Mostrar la latencia con Discord'\n})\nexport default class PingCommand extends Command {\n  async run(ctx: CommandContext) {\n    // Latencia media entre las conexiones existentes\n    const ping = ctx.client.gateway.latency;\n\n    await ctx.write({\n      content: `La latencia es \\`${ping}\\``\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Extending Seyfert Contexts (TypeScript)\nDESCRIPTION: This snippet shows how to extend the Seyfert context to add custom properties or methods. It uses `extendContext` to add a new property to the context and then uses `declare module` to merge a new interface named `ExtendContext` into the `seyfert` module. This interface extends `ReturnType<typeof context>`, ensuring that the added properties are correctly typed.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/getting-started/declare-module.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { extendContext } from 'seyfert';\n\nconst context = extendContext((ctx) => ({ otter: 'cute' }));\n\ndeclare module 'seyfert' {\n    interface ExtendContext extends ReturnType<typeof context> {}\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Seyfert Subcommand to End a Poll\nDESCRIPTION: This code snippet demonstrates how to create a subcommand named 'end' within the 'poll' command in Seyfert. It defines an option for the message ID of the poll to be ended. The command uses the `client.messages.endPoll` method to terminate the poll and provides a confirmation message.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/components/polls.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n// @exactOptionalPropertyTypes: false\nimport {\n    type CommandContext,\n    Declare,\n    Options,\n    SubCommand,\n    createStringOption\n} from 'seyfert';\nimport { MessageFlags } from 'seyfert/lib/types';\n\nconst options = {\n    message: createStringOption({\n        description: 'The message id of the poll',\n        required: true,\n    }),\n};\n\n@Declare({\n    name: 'end',\n    description: 'End a poll.',\n})\n@Options(options)\nexport default class EndPoll extends SubCommand {\n    async run(ctx: CommandContext<typeof options>) {\n        const { options, client } = ctx;\n        const { message: messageId } = options;\n\n        await client.messages.endPoll(ctx.channelId, messageId);\n        await ctx.editOrReply({\n            flags: MessageFlags.Ephemeral,\n            content: 'Poll ended.',\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Centralized Caching with WorkerAdapter in Seyfert\nDESCRIPTION: This code snippet demonstrates how to implement centralized caching in Seyfert using the WorkerAdapter. It initializes the WorkerClient, sets the cache adapter to a new WorkerAdapter instance, and starts the client. The `client.workerData` is passed to `WorkerAdapter` for communication.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/sharding.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { WorkerClient, WorkerAdapter } from 'seyfert';\n\nconst client = new WorkerClient();\n\nclient.setServices({\n\tcache: {\n\t\tadapter: new WorkerAdapter(client.workerData)\n\t}\n});\n\nawait client.start();\n```\n\n----------------------------------------\n\nTITLE: Registering Commands with Discord using Seyfert (TypeScript)\nDESCRIPTION: This snippet shows how to register the commands defined in the 'commands' directory with Discord using the Seyfert client. It imports the `Client` class from 'seyfert', instantiates a new client, starts the client, and then calls the `uploadCommands` method with a specified cache path (`./commands.json`). The `uploadCommands` method uploads the command definitions to Discord and caches them to prevent unnecessary re-uploads.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/getting-started/first-command.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Client } from 'seyfert';\n\nconst client = new Client();\n\nclient.start()\n  .then(() => client.uploadCommands({ cachePath: './commands.json' }));\n```\n\n----------------------------------------\n\nTITLE: Handling Option Validation Errors in Seyfert (TypeScript)\nDESCRIPTION: This snippet shows how to handle errors that occur during option validation using the `onOptionsError` method. It uses the `createStringOption` function to create an option with a custom validation function. The input is a `CommandContext` and an `OnOptionsReturnObject` containing the validation results. The output is a message to the user with details about the failed options.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/commands/handling-errors.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// @exactOptionalPropertyTypes: false\nimport {\n  Command,\n  createStringOption,\n  Options,\n  type CommandContext,\n  type OnOptionsReturnObject,\n  type OKFunction\n} from \"seyfert\";\nconst isURL: ((url: string) => boolean) = () => false;\n// ---cut---\nconst options = {\n  url: createStringOption({\n    description: 'how to be a gamer',\n    value(data, ok: OKFunction<URL>, fail) {\n        if (isURL(data.value)) return ok(new URL(data.value));\n\n// @annotate: This will trigger the onOptionsError method\n        fail('expected a valid URL');\n    },\n  })\n};\n\n@Options(options)\nexport class HandlingErrors extends Command {\n    async onOptionsError(\n        context: CommandContext,\n        metadata: OnOptionsReturnObject\n    ) {\n// @log: url: expected a valid URL\n    await context.editOrReply({\n      content: Object.entries(metadata)\n        .filter((_) => _[1].failed)\n        .map((error) => `${error[0]}: ${error[1].value}`)\n        .join(\"\\n\")\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Options to a Command with Seyfert (TypeScript)\nDESCRIPTION: This code snippet demonstrates adding options to a command using the Seyfert framework. It uses the `@Options` decorator to define a 'hide' option of type boolean, which allows the user to make the command's response ephemeral (invisible to other users). The `run` method checks the value of the 'hide' option and sets the `MessageFlags.Ephemeral` flag accordingly. It requires the `seyfert` package.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/getting-started/first-command.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// @exactOptionalPropertyTypes: false\nimport type { ParseClient, Client } from 'seyfert';\ndeclare module 'seyfert' {\n  interface UsingClient extends ParseClient<Client<true>> {}\n}\n// ---cut---\nimport {\n  Command,\n  Declare,\n  Options,\n  createBooleanOption,\n  type CommandContext\n} from 'seyfert';\nimport { MessageFlags } from 'seyfert/lib/types';\n\nconst options = {\n  hide: createBooleanOption({\n    description: \"Ocultar la respuesta del comando\",\n  }),\n};\n\n@Declare({\n  name: 'ping',\n  description: 'Mostrar la latencia con Discord'\n})\n@Options(options)\nexport default class PingCommand extends Command {\n\n  async run(ctx: CommandContext<typeof options>) {\n    const flags = ctx.options.hide ? MessageFlags.Ephemeral : undefined;\n    \n    // Latencia media entre las conexiones existentes\n    const ping = ctx.client.gateway.latency;\n\n    await ctx.write({\n      content: `La latencia es \\`${ping}\\``,\n      flags,\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Passing Data from Middleware to Command in Seyfert (TypeScript)\nDESCRIPTION: This code snippet illustrates how to pass data from a middleware to a command. It defines an interface `LoggerData` to specify the data type, then passes an object containing the current timestamp to `middle.next()`.  It shows defining the middleware's generic type and using `middle.next` to pass data.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/commands/middlewares.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createMiddleware } from \"seyfert\";\n\n// Esta interfaz se usará para que el middleware sepa qué tipo de datos pasará al comando\ninterface LoggerData {\n    time: number;\n}\n\nexport const loggerMiddleware = createMiddleware<LoggerData>((middle) => {\n    // Registrar el comando\n    console.log(`${middle.context.author.username} (${middle.context.author.id}) ejecutó /(${middle.context.resolver.fullCommandName}`);\n\n    // Pasar los datos al comando\n    middle.next({ time: Date.now() });\n});\n```\n\n----------------------------------------\n\nTITLE: Declaring Custom Event Types in Seyfert (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to declare custom event types in Seyfert using module augmentation.  It extends the `CustomEvents` interface to include a new event called `ourEvent` which takes a string as input and returns void. This is necessary for TypeScript to recognize the custom event. The module augmentation is used to add to the existing 'seyfert' module.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/custom-events.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare module \"seyfert\" {\n\tinterface CustomEvents {\n\t\tourEvent: (text: string) => void;\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Modal with Text Inputs in Seyfert\nDESCRIPTION: This snippet demonstrates how to create a modal using the Seyfert library with two text input fields for 'Name' and 'Age'. It utilizes the `Modal`, `TextInput`, and `ActionRow` classes to construct the modal and its components. The `TextInputStyle` enum is used to set the style of the text inputs to short.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/components/modals.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Modal, TextInput, ActionRow } from 'seyfert';\n\nimport { TextInputStyle } from 'seyfert/lib/types';\n\nconst nameInput = new TextInput()\n  .setCustomId('name')\n  .setStyle(TextInputStyle.Short)\n  .setLabel('Name');\n\nconst row1 = new ActionRow<TextInput>().setComponents([nameInput]);\n\nconst ageInput = new TextInput()\n  .setCustomId('age')\n  .setStyle(TextInputStyle.Short)\n  .setLabel('Age');\n\nconst row2 = new ActionRow<TextInput>().setComponents([ageInput]);\n\nconst modal = new Modal()\n  .setCustomId('mymodal')\n  .setTitle('My Modal')\n  .setComponents([row1, row2]);\n\n```\n\n----------------------------------------\n\nTITLE: Handling Modals using ModalCommand in Seyfert\nDESCRIPTION: This code snippet demonstrates how to handle modal submissions using the ModalCommand class in Seyfert. It defines a MyModal class that extends ModalCommand. The filter method checks if the customId of the modal matches 'mymodal'. The run method retrieves the values of the text input fields using the `getInputValue` method and then sends a response to the interaction with the extracted values.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/components/modals.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ModalCommand, type ModalContext } from 'seyfert';\n\nexport default class MyModal extends ModalCommand {\n  filter(context: ModalContext) {\n    return context.customId === 'mymodal';\n  }\n\n  async run(context: ModalContext) {\n    const interaction = context.interaction;\n\n    // estamos obteniendo los valores de los campos de texto pasando sus ID personalizados en el método `getInputValue`.\n\n    const name = interaction.getInputValue('name', true);\n\n    const age = interaction.getInputValue('age', true);\n\n    return context.write({\n      content: `You are ${name} and have ${age} years`\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Client with Prefix Command Configuration in Seyfert (TS)\nDESCRIPTION: This snippet demonstrates how to configure prefix commands within the Seyfert client. It defines a callback function that returns an array of possible prefixes ('!', '?', '.') that will trigger commands. This callback function receives the Message object and allows for dynamic prefix determination based on message data.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/commands/prefix-commands.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Client } from 'seyfert';\n\nconst client = new Client({\n    commands: {\n        prefix: (msg) => {\n            // aquí puedes manejar los prefijos que quieras considerar dependiendo de los datos del mensaje.\n            return ['!', '?', '.']\n        }\n    }\n});\n```\n\n----------------------------------------\n\nTITLE: Using a Middleware in a Command in Typescript\nDESCRIPTION: This snippet demonstrates how to apply a registered middleware to a Seyfert command using the `@Middlewares` decorator. The `name` property in the `@Declare` decorator defines the command's name, and the `description` provides a brief explanation. The `run` method contains the command's logic, which in this case, replies with \"Pong!\".\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/commands/middlewares.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Middlewares, Declare, Command, type CommandContext } from \"seyfert\";\n\n@Declare({\n\tname: \"ping\",\n\tdescription: \"Ping the bot\"\n})\n// Note we are using the name \"logger\" to reference the middleware\n@Middlewares([\"logger\"])\nexport default class PingCommand extends Command {\n    async run(ctx: CommandContext) {\n        await ctx.reply(\"Pong!\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Editing or Replying to a Command with Seyfert (TypeScript)\nDESCRIPTION: This snippet shows how to use the `CommandContext.editOrReply()` function to either reply to a command or edit the existing reply if one has already been sent. The example first uses `ctx.deferReply()` to acknowledge the command. Then, after a simulated delay, it edits the reply with new content.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/sending-messages.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Command, type CommandContext } from 'seyfert';\n\nexport default class HelloWorldCommand extends Command {\n  async run(ctx: CommandContext) {\n    await ctx.deferReply();\n\n    // do something that takes time and is boring\n\n    await ctx.editOrReply({ content: 'I did some stuff' });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Utilizando middlewares con @Middlewares in Seyfert (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to use middlewares in Seyfert with the `@Middlewares` decorator.  It defines two middleware functions using `createMiddleware` and registers them in the `RegisteredMiddlewares` interface via module augmentation.  The `@Middlewares` decorator then applies these middlewares to a command class.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/commands/intro.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createMiddleware, type ParseMiddlewares } from 'seyfert';\nconst middle = createMiddleware(() => ({}));\nconst middlewares = {\n    'mi-middleware': middle,\n    'siguiente-middleware': middle,\n};\n\ndeclare module 'seyfert' {\n    interface RegisteredMiddlewares\n        extends ParseMiddlewares<typeof middlewares> {}\n}\n// ---cut---\nimport { Command, Middlewares } from 'seyfert';\n\n@Middlewares(['mi-middleware', 'siguiente-middleware'])\nclass MiComando extends Command {}\n\n```\n\n----------------------------------------\n\nTITLE: Setting up Kazagumo with Seyfert Client (index.ts)\nDESCRIPTION: This TypeScript snippet demonstrates how to initialize and configure Kazagumo with a Seyfert client. It sets up the connection to Lavalink nodes, defines event listeners, and adds a Kazagumo property to the Seyfert client interface, allowing you to access and control audio playback within your bot.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/music.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Client } from \"seyfert\";\nimport { Kazagumo } from \"kazagumo\";\nimport { type NodeOption, Connectors } from \"shoukaku\";\n\nconst client = new Client();\nconst nodes: NodeOption[] = [\n\t{\n\t\tname: \"Node\",\n\t\turl: \"localhost:2333\",\n\t\tauth: \"youshallnotpass\",\n\t\tsecure: false\n\t}\n];\n\n//Basic configuration, perfect for this case\nclient.kazagumo = new Kazagumo(\n\t{\n\t\tdefaultSearchEngine: \"youtube\",\n\t\tsend: (guildId, payload) =>\n\t\t\tclient.gateway.send(client.gateway.calculateShardId(guildId), payload)\n\t},\n\tnew Connectors.Seyfert(client),\n\tnodes\n);\n\n//To see whether the node is connected\nclient.kazagumo.shoukaku.on(\"ready\", (name) =>\n\tconsole.log(`Lavalink ${name}: Ready!`)\n);\n\ndeclare module \"seyfert\" {\n\tinterface Client {\n\t\tkazagumo: Kazagumo;\n\t}\n}\n\nclient.start().then(() => client.uploadCommands());\n```\n\n----------------------------------------\n\nTITLE: Sending Components with Seyfert (TypeScript)\nDESCRIPTION: This code snippet shows how to create a command using Seyfert and send an ActionRow with a Button as a response.  It defines a command class `PingCommand` that, when executed, calculates the gateway latency, creates a button with the latency as its label, and includes the button in an ActionRow.  The command then sends a message containing the ping and the created ActionRow.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/components/building-components.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { ParseClient, Client } from 'seyfert';\ndeclare module 'seyfert' {\n  interface UsingClient extends ParseClient<Client<true>> {}\n}\n// ---cut---\nimport { Declare, Command, type CommandContext, ActionRow, Button } from 'seyfert';\nimport { ButtonStyle } from 'seyfert/lib/types';\n\n@Declare({\n  name: 'ping',\n  description': 'Muestra el ping con Discord'\n})\nexport default class PingCommand extends Command {\n\n\tasync run(ctx: CommandContext) {\n\t\t// latencia promedio entre fragmentos\n    const ping = ctx.client.gateway.latency;\n\n    const row = new ActionRow()\n      .setComponents([ \n        new Button().setCustomId('pingbtn').setLabel(`Ping: ${ping}`).setStyle(ButtonStyle.Primary)\n      ])\n\n    await ctx.write({\n      content: `El ping es \\`${ping}\\``,\n      components: [row]\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Middleware Errors in Seyfert Commands (TypeScript)\nDESCRIPTION: This snippet showcases how to use the `onMiddlewaresError` method to handle errors that are returned by middlewares.  It imports `Command`, `Middlewares`, and `CommandContext` from `seyfert`. It expects a middleware named `OnlyDev` to be registered.  The `onMiddlewaresError` method takes a `CommandContext` and an `error` string as input, then edits or replies to the context with the provided error message.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/commands/handling-errors.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createMiddleware, type ParseMiddlewares } from 'seyfert';\nconst middleware = { OnlyDev: createMiddleware(() => {}) };\ndeclare module 'seyfert' {\n    interface RegisteredMiddlewares extends ParseMiddlewares<typeof middleware> {}\n}\n// ---cut---\nimport { Command, Middlewares, type CommandContext } from \"seyfert\";\n\n@Middlewares([\"OnlyDev\"])\nexport class HandlingErrors extends Command {\n    async onMiddlewaresError(context: CommandContext, error: string) {\n        await context.editOrReply({\n// @log: User is not a developer\n            content: error\n        });\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Finished Seyfert Bot Config with Extension\nDESCRIPTION: Demonstrates a complete Seyfert bot configuration file with the added 'music' location and 'prefix' property. It combines the base configuration with the extended properties.  Requires 'seyfert' package and process.env.TOKEN to be set.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/extending-config.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { config } from \"seyfert\";\n\nexport default config.bot({\n\tlocations: {\n\t\tbase: \"dist\",\n\t\tcommands: \"commands\",\n\t\tmusic: \"lavalink\", // dist/lavalink\n\t},\n\ttoken: process.env.TOKEN!,\n\tprefix: \"s!\",\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Options to a Command in Seyfert (TypeScript)\nDESCRIPTION: This code demonstrates how to add options to a command, specifically a boolean option named 'hide' to make the response ephemeral. It uses the `@Options` decorator and the `createBooleanOption` function to define the option. The `CommandContext` is extended with a generic type to infer the type of the options. The `run` method retrieves the value of the 'hide' option from the context and sets the appropriate message flags to make the response ephemeral if 'hide' is true.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/getting-started/first-command.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// @exactOptionalPropertyTypes: false\nimport type { ParseClient, Client } from 'seyfert';\ndeclare module 'seyfert' {\n  interface UsingClient extends ParseClient<Client<true>> {}\n}\n// ---cut---\nimport {\n  Command,\n  Declare,\n  Options,\n  createBooleanOption,\n  type CommandContext\n} from 'seyfert';\nimport { MessageFlags } from 'seyfert/lib/types';\n\nconst options = {\n  hide: createBooleanOption({\n    description: \"Hide the command's response\",\n  }),\n};\n\n@Declare({\n  name: 'ping',\n  description: 'Show latency with Discord'\n})\n@Options(options)\nexport default class PingCommand extends Command {\n\n  async run(ctx: CommandContext<typeof options>) {\n    const flags = ctx.options.hide ? MessageFlags.Ephemeral : undefined;\n    \n    // Average latency between existing connections\n    const ping = ctx.client.gateway.latency;\n\n    await ctx.write({\n      content: `The latency is \\`${ping}\\``,\n      flags,\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Filtering Interactions in Seyfert Collector\nDESCRIPTION: This snippet shows how to filter interactions received by the component collector. A `filter` option is provided when creating the collector. The filter function takes an interaction as input and returns a boolean to determine if the interaction should be processed. This example filters interactions to only include button interactions from the user who executed the command.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/components/collectors.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  Button,\n  ActionRow,\n  Command,\n  Declare,\n  type CommandContext,\n} from 'seyfert';\n\nimport { ButtonStyle } from 'seyfert/lib/types';\n\n@Declare({\n  name: 'hello',\n  description: 'I will send you a hello world message',\n})\nexport default class HelloWorldCommand extends Command {\n  async run(ctx: CommandContext) {\n    const button = new Button()\n      .setCustomId('hello')\n      .setLabel('Hello')\n      .setStyle(ButtonStyle.Primary);\n\n    const row = new ActionRow<Button>().setComponents([button]);\n\n    const message = await ctx.write(\n      {\n        content: 'Do you want a hello world? Click the button below.',\n        components: [row],\n      },\n      true\n    );\n\n    const collector = message.createComponentCollector({\n      filter: (i) => i.user.id === ctx.author.id && i.isButton(),\n    });\n\n    collector.run('hello', async (i) => {\n      return i.write({ content: 'Hello World 👋' });\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: seyfert.config.mjs (Gateway Bot)\nDESCRIPTION: This snippet configures Seyfert for a Gateway bot using the `config.bot` function.  It sets the bot token, file locations for commands, and Discord intents.  It optionally allows for HTTP interaction by specifying `publicKey` and `port`. The token should come from environment variables. The `locations.base` property specifies the root directory for the project files, and `locations.commands` specifies where the command files are located. The `intents` array specifies the Discord gateway intents that the bot needs.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/getting-started/setup-project.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { config } from \"seyfert\";\n\nexport default config.bot({\n    token: process.env.BOT_TOKEN ?? \"\",\n    locations: {\n        base: \"dist\", // replace with \"src\" if using bun\n        commands: \"commands\"\n    },\n    intents: [\"Guilds\"],\n    // This configuration is optional, in case you want to receive interactions via HTTP\n    // This allows you to use both the gateway and the HTTP webhook\n    publicKey: \"...\", // replace with your public key\n    port: 4444 // replace with your application's port \n});\n```\n\n----------------------------------------\n\nTITLE: Extending Seyfert Context Type\nDESCRIPTION: This code snippet demonstrates how to extend the Seyfert context with custom properties or methods by extending the 'seyfert' module with the `ExtendContext` interface. It utilizes `extendContext` to infer the return type and add it to the context.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/getting-started/declare-module.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { extendContext } from 'seyfert';\n\nconst context = extendContext((ctx) => ({ nutria: 'tierna' }));\n\ndeclare module 'seyfert' {\n    interface ExtendContext extends ReturnType<typeof context> {}\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom User Transformer in Seyfert\nDESCRIPTION: This code snippet demonstrates how to define a custom user transformer in Seyfert using the Transformers object. It transforms the default user data into a custom MyUser interface that includes additional properties like isAdmin and a raw() method, showing how to modify the standard Seyfert data structures.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/transformers.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { APIUser } from 'seyfert/lib/types';\n\ninterface MyUser {\n    username: string;\n    isAdmin: boolean;\n    raw(): Promise<APIUser>;\n}\n//---cut---\nimport { Transformers } from 'seyfert';\n\nTransformers.User = (client, data) => {\n    return {\n        username: data.username,\n        isAdmin: Math.random() > 0.5,\n        raw() {\n            return client.users.raw(data.id);\n        },\n    };\n};\n\n/*\nAt this point, you should have a `declare module \"seyfert\"` in your project, \nif not, add it.\n*/\ndeclare module \"seyfert\" {\n// Declaring the type this way will reflect in the typing throughout the entire project.\n    interface CustomStructures {\n        User: MyUser;\n    }\n// You can add as many transformers as you like with any type.\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Seyfert Locations for Components (JavaScript)\nDESCRIPTION: This JavaScript snippet shows how to configure the locations of different bot elements like commands, events, and components within the Seyfert project structure. The configuration specifies the base directory and subdirectories for each element. It uses the `config.bot` method provided by the 'seyfert' package.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/components/handling-components.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @ts-check\nimport { config } from \"seyfert\";\n\nexport default config.bot({\n  token: process.env.BOT_TOKEN ?? \"\",\n  intents: [\"Guilds\"],\n  locations: {\n    base: \"dist\",\n    commands: \"commands\",\n    events: \"events\",\n    components: 'components'\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Create Subcommand Definition\nDESCRIPTION: This code defines the `CreateCommand` as a subcommand, extending the `SubCommand` class. The `@Declare` decorator sets the name and description. The `run` method contains the logic for the subcommand and returns a `CommandContext` with the result.  The `ctx.write` method is used to send a response to the user.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/commands/subcommands.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { type CommandContext, Declare, SubCommand } from \"seyfert\";\n\n@Declare({\n\tname: \"create\",\n\tdescription: \"create a new something\"\n})\nexport class CreateCommand extends SubCommand {\n\trun(ctx: CommandContext) {\n\t\t// some logic there\n\n\t\treturn ctx.write({\n\t\t\tcontent: \"create command executed\"\n\t\t});\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Subcommand within a Group in Seyfert (TypeScript)\nDESCRIPTION: This code defines a subcommand (`GroupMySubCommand`) that belongs to the 'my-group' subcommand group using the `@Group` decorator.  The `run` method defines the logic to be executed when the subcommand is invoked, returning a message via `ctx.write`. This ensures that the subcommand is properly associated with its designated group.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/commands/subcommands.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { SubCommand, Declare, CommandContext, Group } from 'seyfert';\n\n@Declare({\n    name: 'subcommand',\n    description: 'One of my subcommands within the my-group group',\n})\n@Group('my-group')\nexport default class GroupMySubCommand extends SubCommand {\n    run(ctx: CommandContext) {\n        return ctx.write({\n            content: 'Hello from the subcommand!',\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Extended Property\nDESCRIPTION: Shows how to access the newly added 'prefix' property from the Seyfert runtime configuration.  It retrieves the configuration using `client.getRC()` and then logs the value of the `prefix` property. This assumes the Seyfert client has been initialized.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/extending-config.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst rc = await client.getRC();\n\nconsole.log(rc.prefix);\n```\n\n----------------------------------------\n\nTITLE: Creating a Component Command\nDESCRIPTION: This code snippet demonstrates how to create a basic component command in Seyfert. It imports the `ComponentCommand` class from the 'seyfert' library and extends it with a custom class, `HelloWorldButton`.  The `componentType` property is set to 'Button', indicating that this command handles button interactions.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/components/handling-components.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ComponentCommand } from 'seyfert';\n\nexport default class HelloWorldButton extends ComponentCommand {\n    componentType = 'Button' as const;\n}\n```\n\n----------------------------------------\n\nTITLE: Running a Custom Event (TypeScript)\nDESCRIPTION: This snippet shows how to run a custom event using the Seyfert client. After starting the client, the `runCustom` method is called on the `client.events` object, passing the event name ('ourEvent') and the data to be passed to the event's `run` function ('¡Hola, mundo!'). This will execute the previously defined 'ourEvent' with the given text.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/custom-events.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Client } from \"seyfert\";\n\nconst client = new Client();\n\n(async () => {\n\tawait client.start();\n\tclient.events?.runCustom('ourEvent', '¡Hola, mundo!');\n})();\n```\n\n----------------------------------------\n\nTITLE: Initializing Seyfert Client with Prefix Commands\nDESCRIPTION: This code snippet demonstrates how to initialize a Seyfert client with prefix command support. It configures the `prefix` option within the `commands` section of the client options. The `prefix` option takes a callback function that receives a `Message` object and returns an array of possible prefixes for the command. This allows you to define different prefixes based on the message data.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/commands/prefix-commands.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Client } from 'seyfert';\n\nconst client = new Client({\n    commands: {\n        prefix: (msg) => {\n            // here you can handle whatever prefixes you want depending on the message data.\n            return ['!', '?', '.']\n        }\n    }\n});\n```\n\n----------------------------------------\n\nTITLE: Extending Seyfert Internal Options\nDESCRIPTION: This code snippet demonstrates how to extend Seyfert's internal options by extending the 'seyfert' module with the `InternalOptions` interface. This allows customizing Seyfert's behavior based on your implementation.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/getting-started/declare-module.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport 'seyfert';\n// ---cut---\ndeclare module 'seyfert' {\n    interface InternalOptions {\n        withPrefix: true; // o false\n        asyncCache: false; // o true\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Prefix Command in Seyfert\nDESCRIPTION: This code snippet illustrates how to create a simple prefix command in Seyfert. It defines a `crosspost` command that crossposts the message in the announcement channel. The `Declare` decorator sets the name and description of the command. The `run` method accesses the `message` property from the `CommandContext` (enabled by the module declaration) and crossposts the message. It then sends a confirmation message.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/commands/prefix-commands.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n    Command,\n    CommandContext,\n    Declare\n} from 'seyfert';\n\n@Declare({\n    name: 'crosspost',\n    description: 'Crosspost an announcement message.'\n})\nexport default class CrosspostCommand extends Command {\n    async run(ctx: CommandContext){\n        if(ctx.message) await ctx.message.crosspost();\n        return ctx.write({ content: 'I have crossposted your announcement.'});\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Handling Modal Submissions with ModalCommand in Seyfert\nDESCRIPTION: This snippet demonstrates how to handle modal submissions using the `ModalCommand` class in Seyfert.  It defines a `MyModal` class that extends `ModalCommand` and implements the `filter` and `run` methods. The `filter` method checks if the modal's customId matches 'mymodal', and the `run` method retrieves the values from the 'name' and 'age' text inputs and responds with a message.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/components/modals.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ModalCommand, type ModalContext } from 'seyfert';\n\nexport default class MyModal extends ModalCommand {\n  filter(context: ModalContext) {\n    return context.customId === 'mymodal';\n  }\n\n  async run(context: ModalContext) {\n    const interaction = context.interaction;\n    \n    //we are getting the textinput values by passing their custom ids in the getInputValue method.\n\n    const name = interaction.getInputValue('name', true);\n\n    const age = interaction.getInputValue('age', true);\n\n    return context.write({\n      content: `You are ${name} and you have ${age} years`\n    });\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Initializing a Seyfert Command\nDESCRIPTION: This snippet demonstrates the basic structure for defining a command in Seyfert, including importing necessary modules and using the `@Declare` decorator to set the command's name and description. The `CommandContext` is typed, ensuring proper usage of command-related functionalities.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/sending-messages.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Command, Declare, type CommandContext } from 'seyfert';\n\n@Declare({\n  name: 'helloworld',\n  description: 'Envía un mensaje básico de hola mundo.',\n})\nexport default class HelloWorldCommand extends Command {\n  async run(ctx: CommandContext) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Cooldown Middleware - TypeScript\nDESCRIPTION: This TypeScript code creates a middleware to check if a user is in cooldown before executing a command. It uses the `CooldownManager` to determine the remaining cooldown time and, if in cooldown, stops the command execution and sends an error message using `Formatter.timestamp` to display the remaining time in a relative format.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/cooldown.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { CooldownManager } from \"@slipher/cooldown\";\n\ndeclare module \"seyfert\" {\n\tinterface UsingClient {\n\t\tcooldown: CooldownManager;\n\t}\n}\n// ---cut---\nimport { createMiddleware, Formatter } from 'seyfert';\nimport { TimestampStyle } from 'seyfert/lib/common';\n\nexport default createMiddleware<void>(async ({ context, next, stop }) => {\n\tconst inCooldown = context.client.cooldown.context(context);\n\n\ttypeof inCooldown === 'number'\n\t\t? stop(\n\t\t\t\t`You're in cooldown, try again ${Formatter.timestamp(new Date(Date.now() + inCooldown), TimestampStyle.RelativeTime)}`,\n\t\t\t)\n\t\t: next();\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Data Retrieval in a Custom Seyfert Adapter\nDESCRIPTION: This code demonstrates implementing `get` and `bulkGet` methods for a custom Seyfert adapter. The `get` method retrieves a value by its key from the storage. The `bulkGet` method retrieves values for multiple keys and filters out any null values from the results.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/cache.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\ninterface SeyfertDotDev {\n    get(key: string): Promise<any>;\n}\n// @noErrors\n// ---cut---\nimport { Adapter } from 'seyfert';\n\nclass MyAdapter implements Adapter {\n    // ---cut-start---\n    storage: SeyfertDotDev;\n    // ---cut-end---\n    async get(key: string) {\n        return this.storage.get(key);\n    }\n\n    async bulkGet(keys: string[]) {\n        const values: Promise<any>[] = [];\n        for (let key of keys) {\n            values.push(this.get(key));\n        }\n\n        return (await Promise.all(values))\n            // Do not return null values\n            .filter(value => value)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Cache Resource in Seyfert (TypeScript)\nDESCRIPTION: This code defines a custom cache resource called `CooldownResource` that extends `BaseResource` from `seyfert/lib/cache`. It overrides the `set` method to apply specific typing and formatting to the cached data. The `namespace` property defines the base for the resource.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/cache.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { BaseResource } from 'seyfert/lib/cache';\n\nexport class CooldownResource extends BaseResource<CooldownData> {\n    // El namespace es la base que separa cada recurso\n    namespace = 'cooldowns';\n\n    // Sobrescribimos set para aplicar el tipado y formato que queremos\n    override set(id: string, data: MakePartial<CooldownData, 'lastDrip'>) {\n        return super.set(id, { ...data, lastDrip: data.lastDrip ?? Date.now() });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Sending Messages with Components in Seyfert\nDESCRIPTION: This snippet showcases how to send interactive components, such as buttons and select menus, along with a message in Seyfert.  It demonstrates creating a button and a string select menu, adding them to action rows, and including these rows in the `components` array of the message options.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/sending-messages.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  ActionRow,\n  Button,\n  StringSelectMenu,\n  StringSelectOption,\n  Command,\n  type CommandContext\n} from 'seyfert';\nimport { ButtonStyle } from 'seyfert/lib/types'\n\nexport default class HelloWorldCommand extends Command {\n  async run(ctx: CommandContext) {\n\n\n    const button = new Button()\n      .setCustomId('helloworld')\n      .setLabel('Hola mundo')\n      .setStyle(ButtonStyle.Primary);\n\n    const buttonRow = new ActionRow<Button>().addComponents(button);\n\n\n\n    const menu = new StringSelectMenu()\n      .setCustomId('select-helloworld')\n      .addOption(\n        new StringSelectOption().setLabel('Hello').setValue('option_1')\n      );\n\n    const menuRow = new ActionRow<StringSelectMenu>().addComponents(menu);\n\n    await ctx.write({ content: 'Hola mundo 👋', components: [buttonRow, menuRow] });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Reply Behavior for Prefix Commands\nDESCRIPTION: This snippet shows how to configure the `reply` option in the `commands` section of the client options. The `reply` option is a callback that receives the `CommandContext` as a parameter and returns a boolean value. If the callback returns `true`, the command will reply to the message that triggered the command; otherwise, it will send a new message to the channel.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/commands/prefix-commands.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Client } from 'seyfert';\n\nconst client = new Client({\n    commands: {\n        prefix: (msg) => {\n            // here you can handle whatever prefixes you want depending on the message data.\n            return ['!', '?', '.']\n        },\n        reply: (ctx) => true\n    }\n});\n```\n\n----------------------------------------\n\nTITLE: Añadiendo opciones a un comando con @Options en Seyfert (TypeScript)\nDESCRIPTION: This code snippet shows how to add options to a Seyfert command using the `@Options` decorator. It utilizes `createStringOption` to define a string-based option for the command. The `CommandContext` type is used to provide type safety when accessing the options within the `run` method.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/commands/intro.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// @exactOptionalPropertyTypes: false\nimport {\n    Options,\n    Command,\n    createStringOption,\n    type CommandContext,\n} from 'seyfert';\n\nconst options = {\n    message: createStringOption({\n        description: 'Mi opción de texto',\n    }),\n};\n\n@Options(options)\nclass MiComando extends Command {\n    run(ctx: CommandContext<typeof options>) {\n        ctx.options.message;\n        //           ^?       \n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: String Options with Autocomplete and CommandContext\nDESCRIPTION: This code demonstrates the use of string options, including fixed choices, along with the `CommandContext` in a Seyfert command. It shows how to define a `best` string option with predefined choices and how to access and use this option within the `run` method of a `Command` class using the `CommandContext`. The type of `ctx.options.best` is inferred, providing type safety.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/commands/options.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// @exactOptionalPropertyTypes: false\nimport { Options, createStringOption, Command, CommandContext } from 'seyfert';\n\nconst options = {\n    /// Opciones fijas\n    best: createStringOption({\n        description: '',\n        choices: [\n            { name: 'The best library', value: 'seyfert' },\n            { name: 'An odd stuff', value: 'meowdb' },\n        ] as const,\n    }),\n};\n\n@Options(options)\nclass Ping extends Command {\n    async run(ctx: CommandContext<typeof options>) {\n        ctx.options.best;\n        //          ^?\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Declarando un comando con @Declare en Seyfert (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to declare a command in Seyfert using the `@Declare` decorator.  It showcases various properties that can be configured, such as `name`, `description`, `props`, `defaultMemberPermissions`, `botPermissions`, `guildId`, `nsfw`, `aliases`, `integrationTypes`, `contexts`, and `ignore`.  The `Command` class is extended to create a new command.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/commands/intro.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Declare, Command, IgnoreCommand } from 'seyfert';\n\n@Declare({\n    name: 'tu-comando',\n    description: 'Una descripción para este comando',\n    // Propiedades para pasar en el comando como metadata\n    props: {},\n\n    // Lista de permisos que necesita el miembro\n    defaultMemberPermissions: ['Administrator'],\n\n    // Lista de permisos que necesita el bot\n    botPermissions: ['ManageGuild'],\n\n    // Lista de IDs de servidores para registrar el comando\n    guildId: ['100000'],\n\n    // Determina si el comando es NSFW\n    nsfw: false,\n\n    // Lista de nombres alternos para el comando (en comandos de texto)\n    aliases: ['un-comando'],\n\n    // Identifica los tipos de instalaciones que soporta el comando,\n    //   por defecto solo en el servidor\n    integrationTypes: ['GuildInstall', 'UserInstall'],\n\n    // Determina dónde se puede usar un comando\n    contexts: ['BotDM', 'Guild', 'PrivateChannel'],\n\n    // Establece si ignorar la ejecución del comando en slash\n    //   o en su versión mensaje de texto\n    ignore: IgnoreCommand.Slash,\n    //                    ^|\n\n    // Establece el tipo de comando:\n    /// type: ApplicationCommandType.User\n})\nclass MiComando extends Command {}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing `set` and `bulkSet` Methods in Custom Cache Adapter (TypeScript)\nDESCRIPTION: This code implements the `set` and `bulkSet` methods for a custom cache adapter. The `set` method stores a value with a given key, and the `bulkSet` method iterates through an array of key-value pairs to store multiple values.  Requires the `seyfert` package. Assumes an interface `SeyfertDotDev` is available.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/cache.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\ninterface SeyfertDotDev {\n    set(key: string, value: any): Promise<void>;\n}\n// @noErrors\n// ---cut---\nimport { Adapter } from 'seyfert';\n\nclass MiAdaptador implements Adapter {\n    // ---cut-start---\n    almacenamiento: SeyfertDotDev;\n    // ---cut-end---\n    async set(key: string, value: any | any[]) {\n        await this.almacenamiento.set(key, { value });\n    }\n\n    async bulkSet(keys: [string, any][]) {\n        for (let [key, value] of keys) {\n            await this.set(key, value);\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering a Custom Cache Resource in Seyfert\nDESCRIPTION: This code snippet shows how to register a custom cache resource (`CooldownResource`) with the Seyfert client. It instantiates the `CooldownResource` and assigns it to `client.cache.cooldown`, and then declares the new cache interface for TypeScript support.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/cache.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Client } from 'seyfert';\nimport { CooldownResource } from './resource'\n\nconst client = new Client();\n\nclient.cache.cooldown = new CooldownResource(client.cache);\n\ndeclare module \"seyfert\" {\n    interface Cache {\n        cooldown: CooldownResource;\n    }\n    interface UsingClient extends ParseClient<Client> {}\n}\n```\n\n----------------------------------------\n\nTITLE: Extending Seyfert Configuration\nDESCRIPTION: This code snippet illustrates how to add more properties to the `seyfert.config.mjs` configuration file by extending the 'seyfert' module with the `ExtendedRC` interface.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/getting-started/declare-module.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport 'seyfert';\n// ---cut---\ndeclare module 'seyfert' {\n    interface ExtendedRC {\n        developers: string[];\n        // más propiedades aquí...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Receiving Data from Middleware in Seyfert Command (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to receive data passed from a middleware in a Seyfert command.  It specifies the middleware data type in the `CommandContext` generic type (`CommandContext<never, \"logger\">`).  Then, it accesses the data via `ctx.middleware.metadata.logger.time`.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/commands/middlewares.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Middlewares, Declare, Command, type CommandContext } from \"seyfert\";\n\n@Declare({\n    name: \"ping\",\n    description: \"Haz ping al bot\"\n})\n@Middlewares([\"logger\"])\nexport default class PingCommand extends Command {\n    async run(ctx: CommandContext<never, \"logger\">) {\n        const time = ctx.middleware.metadata.logger.time;\n        console.log(time);\n        await ctx.reply({\n            content: `Pong! Time: ${time}`,\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Seyfert Config\nDESCRIPTION: This code snippet demonstrates how to update the Seyfert configuration file to specify the location of components within the project.  The `components` property within the `locations` object is set to 'components', indicating the directory where component files are located. This configuration enables Seyfert to discover and handle component interactions.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/components/handling-components.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// @ts-check\nimport { config } from \"seyfert\";\n\nexport default config.bot({\n  token: process.env.BOT_TOKEN ?? \"\",\n  intents: [\"Guilds\"],\n  locations: {\n    base: \"dist\",\n    commands: \"commands\",\n    events: \"events\",\n    components: 'components'\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Updating Module Declaration for Localization (TypeScript)\nDESCRIPTION: This code snippet illustrates updating the module declaration in `src/index.ts` to include interfaces for the `UsingClient` and `DefaultLocale` types.  This allows you to use strongly-typed translations throughout your bot. The `DefaultLocale` interface is parameterized with the English translation file's type.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/i18n/languages.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport type English from './languages/en';\nimport { Client, type ParseClient, type ParseLocales } from \"seyfert\";\n\nconst client = new Client();\n\nclient.start();\n\ndeclare module 'seyfert' {\n  interface UsingClient extends ParseClient<Client<true>> { }\n  // interface UsingClient extends ParseClient<HttpClient> { } // Si utiliza la API Rest\n\n  interface DefaultLocale extends ParseLocales<typeof English> { }\n}\n```\n\n----------------------------------------\n\nTITLE: Extending Seyfert with Languages (TypeScript)\nDESCRIPTION: This snippet shows how to configure types for languages within Seyfert, focusing on establishing a base language for easier updates. It imports the base language and uses interface merging to add a `DefaultLocale` interface to the 'seyfert' module, which inherits from `ParseLocales` parameterized by the imported base language. This ensures that all other language types derive from this base.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/getting-started/declare-module.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// Assuming your base language is located in './langs/en';\nimport type * as defaultLang from './langs/en';\n\ndeclare module 'seyfert' {\n    interface DefaultLocale extends ParseLocales<typeof defaultLang> {}\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Crosspost Command with Prefix Support in Seyfert (TS)\nDESCRIPTION: This example creates a Seyfert command named 'crosspost' that republishes an announcement message. It checks for the presence of the `message` property in the `CommandContext` (enabled via module declaration with `withPrefix: true`) and then crossposts the message if it exists.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/commands/prefix-commands.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n    Command,\n    CommandContext,\n    Declare\n} from 'seyfert';\n\n@Declare({\n    name: 'crosspost',\n    description: 'Republicar un mensaje de anuncio.'\n})\nexport default class CrosspostCommand extends Command {\n    async run(ctx: CommandContext){\n        if(ctx.message) await ctx.message.crosspost();\n        return ctx.write({ content: 'He republicado tu anuncio.'});\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Defining another Subcommand in Seyfert (TypeScript)\nDESCRIPTION: This code demonstrates creating another subcommand (`DeleteCommand`) using the `SubCommand` class. It includes the `@Declare` decorator for setting the name and description. The `run` method contains the logic to be executed when the subcommand is invoked, outputting a message through `ctx.write`.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/commands/subcommands.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { type CommandContext, Declare, SubCommand } from \"seyfert\";\n\n@Declare({\n\tname: \"delete\",\n\tdescription: \"delete something\"\n})\nexport class DeleteCommand extends SubCommand {\n\trun(ctx: CommandContext) {\n\t\t// some logic here\n\n\t\treturn ctx.write({\n\t\t\tcontent: \"delete command executed\"\n\t\t});\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Option Validation Errors in Seyfert (TypeScript)\nDESCRIPTION: This snippet illustrates how to handle option validation errors in Seyfert. It uses the `@Options` decorator to define a string option with custom validation logic. The `onOptionsError` method is overridden to display validation error messages to the user. Dependencies include `Command`, `createStringOption`, `Options`, `CommandContext`, `OnOptionsReturnObject`, and `OKFunction` from \"seyfert\".\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/commands/command-class.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  Command,\n  createStringOption,\n  Options,\n  type CommandContext,\n  type OnOptionsReturnObject,\n  type OKFunction\n} from \"seyfert\";\n\n@Options({\n  url: createStringOption({\n    description: 'cómo ser un gamer',\n    value(data, ok: OKFunction<URL>, fail) {\n        if (isUrl(data.value)) return ok(new URL(data.value));\n        fail('se esperaba una URL válida');\n    }\n  })\n})\nexport class HandlingErrors extends Command {\n  // url: se esperaba una URL válida\n  async onOptionsError(\n    context: CommandContext,\n    metadata: OnOptionsReturnObject\n  ) {\n    await context.editOrReply({\n      content: Object.entries(metadata)\n        .filter((_) => _[1].failed)\n        .map((error) => `${error[0]}: ${error[1].value}`)\n        .join(\"\\n\")\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using the Custom User Transformer in a Command\nDESCRIPTION: This code snippet demonstrates how to use the custom user transformer defined earlier within a Seyfert command. It retrieves the author from the command context and calls the raw() method on the transformed user object to get the raw API user data.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/transformers.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { APIUser } from 'seyfert/lib/types';\n\ninterface MyUser {\n    username: string;\n    isAdmin: boolean;\n    raw(): Promise<APIUser>;\n}\n\ndeclare module \"seyfert\" {\n    interface CustomStructures {\n        User: MyUser;\n    }\n}\n//---cut---\nimport { type CommandContext, Command, Declare } from 'seyfert';\n\n@Declare({\n    name: 'ping',\n    description: 'Ping!',\n})\nclass Ping extends Command {\n    async run(ctx: CommandContext) {\n        const result = await ctx.author.raw();\n                                     // ^|\n        console.log(result.id, result.username);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Stopping Middleware Execution in Seyfert (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to stop the execution of a command from within a middleware. It checks if the command is being executed in a DM and, if so, calls `middle.stop()` to prevent further execution and send an error message.  It imports `ChannelType` from Seyfert.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/commands/middlewares.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createMiddleware } from \"seyfert\";\nimport { ChannelType } from \"seyfert/lib/types\";\n\nexport const loggerMiddleware = createMiddleware<void>((middle) => {\n  // Registrar el comando\n  console.log(\n    `${middle.context.author.username} (${middle.context.author.id}) ejecutó /(${middle.context.resolver.fullCommandName}`\n  );\n\n  // Verificar si el comando se está ejecutando en un servidor\n  if (middle.context.interaction.channel?.type === ChannelType.DM) {\n    return middle.stop(\"Este comando solo se puede usar en un servidor.\");\n  }\n\n  // Pasar al siguiente middleware si el comando se está ejecutando en un servidor\n  middle.next();\n});\n```\n\n----------------------------------------\n\nTITLE: Deferring Reply in a Crosspost Command with Options in Seyfert (TS)\nDESCRIPTION: This code snippet illustrates how to defer the reply in a prefix command that has options using Seyfert. The `ctx.deferReply()` function is called before processing the command, allowing for a longer execution time before sending the final response.  The options allow the user to specify an ID.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/commands/prefix-commands.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n    Command,\n    CommandContext,\n    Declare,\n    Options,\n    createStringOption\n} from 'seyfert';\n\nconst options = {\n    id: createStringOption({\n        description: 'El id del mensaje que vamos a republicar',\n        required: true\n    })\n};\n\n@Declare({\n    name: 'crosspost',\n    description: 'Republicar un mensaje de anuncio.'\n})\n@Options(options)\nexport default class CrosspostCommand extends Command {\n    async run(ctx: CommandContext<typeof options>){\n        await ctx.deferReply();\n        await ctx.client.messages.crosspost(ctx.options.id, ctx.channelId);\n        return ctx.write({ content: 'He republicado tu anuncio.'});\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing the `patch` Method in a Custom Seyfert Adapter\nDESCRIPTION: This code shows how to implement the `patch` and `bulkPatch` methods for a custom Seyfert adapter.  The `patch` method retrieves the old data, merges it with the provided value, and stores the updated value.  The `bulkPatch` applies the `patch` method to each key-value pair.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/cache.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\ninterface SeyfertDotDev {\n    set(key: string, value: any): Promise<void>;\n    get(key: string): Promise<any>;\n}\n// @noErrors\n// ---cut---\nimport { Adapter } from 'seyfert';\n\nclass MyAdapter implements Adapter {\n    // ---cut-start---\n    storage: SeyfertDotDev;\n    // ---cut-end---\n    async patch(key: string, value: any | any[]) {\n        const oldData = await this.storage.get(key) ?? {};\n        const newValue = Array.isArray(value)\n            ? value\n            : ({ ...oldData, ...value });\n\n        await this.storage.set(key, { value: newValue });\n    }\n\n    async bulkPatch(keys: [string, any][]) {\n        for (let [key, value] of keys) {\n            await this.patch(key, value);\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Cooldown Decorator to Command - TypeScript\nDESCRIPTION: This code demonstrates how to use the `@Cooldown` decorator from `@slipher/cooldown` to apply cooldown settings to a Seyfert command. The decorator takes `type`, `interval`, and `uses` properties to configure the cooldown behavior for the command.  The `type` specifies the cooldown scope (User, Guild, or Channel), `interval` is the cooldown duration in milliseconds, and `uses` configures usage limits.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/cooldown.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Declare, Command, type CommandContext } from \"seyfert\";\nimport { CooldownType, Cooldown } from \"@slipher/cooldown\";\n\n@Declare({\n\tname: 'cool',\n\tdescription: 'Reference command'\n})\n@Cooldown({\n\ttype: CooldownType.User,\n\tinterval: 1000 * 60,\n\tuses: {\n\t\tdefault: 2\n\t},\n})\nexport default class Cool extends Command {\n  async run(ctx: CommandContext) {\n    await ctx.write({\n      content: `A cool command`\n    });\n  }\n\n  onMiddlewaresError(context: CommandContext, error: string) {\n    context.editOrReply({ content: error })\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Seyfert Bot Config\nDESCRIPTION: Initializes the Seyfert bot configuration with base and commands locations, and the bot token.  It exports the default configuration object for Seyfert to use. Requires 'seyfert' package and process.env.TOKEN to be set.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/extending-config.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { config } from \"seyfert\";\n\nexport default config.bot({\n\tlocations: {\n\t\tbase: \"dist\",\n\t\tcommands: \"commands\",\n\t},\n\ttoken: process.env.TOKEN!,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Deferred Response for Prefix Commands\nDESCRIPTION: This snippet shows how to customize the deferred response for prefix commands in Seyfert. It configures the `deferReplyResponse` option in the `commands` section of the client options. The `deferReplyResponse` option is a callback that receives the `CommandContext` and returns the content to send while deferring the response.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/commands/prefix-commands.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Client } from 'seyfert';\n\nconst client = new Client({\n    commands: {\n        prefix: (msg) => {\n            // here you can handle whatever prefixes you want depending on the message data.\n            return ['!', '?', '.']\n        },\n        reply: (ctx) => true,\n        deferReplyResponse: (ctx) => ({ content: 'Please wait, processing your request...' })\n    }\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Middleware to Stop Command Execution (TypeScript)\nDESCRIPTION: This code shows how to create a middleware in Seyfert that can stop command execution based on certain conditions. In this case, it checks if the user is a developer and stops the command if they are not.  It uses the `createMiddleware` function from \"seyfert\".\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/commands/command-class.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport default createMiddleware(({ context, next, stop, pass }) => {\n  if (!Devs.includes(context.author.id)) return stop(\"El usuario no es desarrollador\");\n  next();\n});\n```\n\n----------------------------------------\n\nTITLE: Handling Entitlement Creation Event in Seyfert\nDESCRIPTION: This snippet demonstrates how to create an event handler in Seyfert for the `entitlementCreate` event. It fetches the user information based on the entitlement's userId and logs a message to a specified channel when a user subscribes to a product (SKU).\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/monetization.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent } from 'seyfert';\n//---cut---\nexport default createEvent({\n    data: { name: 'entitlementCreate' },\n    async run(entitlement, client) {\n        if (!entitlement.userId) return;\n        const subscribedUser = await client.users.fetch(entitlement.userId);\n        client.messages.write('LOG_CHANNEL_ID', {\n            content: `${subscribedUser.globalName} (${subscribedUser.id}) has been subscribed to ${entitlement.skuId}`,\n        });\n    },\n});\n```\n\n----------------------------------------\n\nTITLE: Handling Modals with Seyfert Collectors\nDESCRIPTION: This snippet demonstrates how to handle modals using the `run` method within the modal constructor. The `run` method expects a callback function that will handle the modal submit interaction. The interaction is then written to using `i.write`. Requires `ModalSubmitInteraction` type.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/components/collectors.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  Modal,\n  Command,\n  Declare,\n  type ModalSubmitInteraction,\n  type CommandContext,\n} from 'seyfert';\n\n@Declare({\n  name: 'hello',\n  description: 'I will send you a hello world message',\n})\nexport default class HelloWorldCommand extends Command {\n  async run(ctx: CommandContext) {\n    const modal = new Modal()\n      .setCustomId('hello')\n      .setTitle('Hello')\n      .run(this.handleModal);\n\n    await ctx.interaction.modal(modal);\n  }\n\n  async handleModal(i: ModalSubmitInteraction) {\n    return i.write({ content: 'Hello World 👋' });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Relationships with Seyfert Adapter in TypeScript\nDESCRIPTION: This snippet showcases the `getToRelationship` method implementation for a Seyfert adapter. It fetches the IDs of a relationship based on a given key (`to`) using the `setGet` method of the underlying storage. If no relationships are found, it returns an empty array.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/cache.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\ninterface SeyfertDotDev {\n    setGet(key: string): Promise<string[] | undefined>;\n}\n// @noErrors\n// ---cut---\nimport { Adapter } from 'seyfert';\n\nclass MyAdapter implements Adapter {\n    // ---cut-start---\n    storage: SeyfertDotDev;\n    // ---cut-end---\n    async getToRelationship(to: string) {\n        return await this.storage.setGet(to) ?? []\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Listening to the botReady Event (TypeScript)\nDESCRIPTION: This code defines an event handler for the 'botReady' event in Seyfert. The `createEvent` function is used to create the event, specifying that it should only run once (`once: true`). The `run` function logs a message to the console indicating that the bot is ready, using the client's logger.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/getting-started/listening-events.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent } from 'seyfert';\n\nexport default createEvent({\n// botReady se ejecuta cuando todos los shards y servidores están listos.\n// `once` sirve para que el evento se ejecute una sola vez.\n  data: { once: true, name: 'botReady' },\n  run(user, client) {\n\n// @log: Podemos utilizar client.logger para mostrar mensajes en la consola.\n    client.logger.info(`${user.username} está listo`);\n\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Seyfert for Cloudflare Workers\nDESCRIPTION: This code snippet demonstrates how to configure Seyfert for use with Cloudflare Workers, including importing the Seyfert configuration, creating an HttpClient instance, using the GenericAdapter, and manually loading commands. It defines a 'fetch' function to handle requests.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/cloudflare-workers.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport '../seyfert.config.mjs'; // sí, importando nuestro seyfert.config.mjs\nimport { HttpClient } from 'seyfert';\nimport { GenericAdapter } from '@slipher/generic-adapter';\n\nimport Ping from './commands/ping.js';\n\nconst client = new HttpClient();\nconst adapter = new GenericAdapter(client);\n\nclient.start()\n  .then(async () => {\n    // necesitamos cargar los comandos manualmente\n    await client.commands!.set('', client, [Ping]);\n  });\n\nadapter.start();\n\nexport default {\n  fetch(req: Request) {\n    return adapter.fetch(req);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Boolean Option in Seyfert (TS)\nDESCRIPTION: Shows how to create a boolean option using the Seyfert library.  This allows a command to accept a true/false value.  The `required` property is set to true, meaning the user must specify the boolean value when using the command.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/commands/options.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// @exactOptionalPropertyTypes: false\nimport { Options, createBooleanOption, Command } from 'seyfert';\n\n@Options({\n    bool: createBooleanOption({\n        description: 'This is a boolean option',\n        required: true\n    })\n})\nclass Ping extends Command {}\n```\n\n----------------------------------------\n\nTITLE: Using Translations in a Command (TypeScript)\nDESCRIPTION: This code snippet shows how to use translations within a command (`src/commands/ping.ts`). It adds a `language` option to the command and uses the `ctx.t.get(lang)` method to retrieve the appropriate translation based on the selected language. It then uses the retrieved translation in the command's response.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/i18n/languages.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// @exactOptionalPropertyTypes: false\nimport type { ParseClient, Client, ParseLocales } from 'seyfert';\nconst English = {\n  foo: {\n    ping(data: { ping: number }) {\n      return `Pong: ${data.ping}` as const\n    }\n  }\n};\ndeclare module 'seyfert' {\n  interface UsingClient extends ParseClient<Client<true>> {}\n\n  interface DefaultLocale extends ParseLocales<typeof English> {}\n}\n// ---cut---\nimport {\n  Command,\n  Declare,\n  Options,\n  createBooleanOption,\n  createStringOption,\n  type CommandContext\n} from 'seyfert';\nimport { MessageFlags } from 'seyfert/lib/types';\n\nconst options = {\n  hide: createBooleanOption({\n    description: \"Hide command output\",\n  }),\n  language: createStringOption({\n    description: \"Language to respond in\",\n    choices: [\n      { name: \"English\", value: \"en\" },\n      { name: \"Spanish\", value: \"es\" }\n    ]\n  })\n}\n\n@Declare({\n  name: 'ping',\n  description: 'Show the ping with discord'\n})\n@Options(options)\nexport default class PingCommand extends Command {\n\n  async run(ctx: CommandContext<typeof options>) {\n    const flags = ctx.options.hide ? MessageFlags.Ephemeral : undefined;\n    const lang = ctx.options.language;\n\n    // Obtener las traducciones del idioma\n    const t = ctx.t.get(lang);\n\n    // latencia promedio entre shards\n    const ping = ctx.client.gateway.latency;\n\n    await ctx.write({\n      content: t.foo.ping({ ping }),\n      flags,\n    });\n  }\n\n}\n```\n\n----------------------------------------\n\nTITLE: Extending Seyfert with Client Types (TypeScript)\nDESCRIPTION: This snippet shows how to extend the 'seyfert' module to specify the client type being used (Gateway, HTTP, or Worker).  It uses interface merging to add a `UsingClient` interface to the 'seyfert' module, which inherits from `ParseClient` parameterized by the desired client type. Only one of the three implementations should be chosen.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/getting-started/declare-module.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { ParseClient, Client, HttpClient, WorkerClient } from 'seyfert';\n\ndeclare module 'seyfert' {\n\n    interface UsingClient extends ParseClient<Client<true>> { }\n  \n  \n    interface UsingClient extends ParseClient<HttpClient> { }\n  \n  \n    interface UsingClient extends ParseClient<WorkerClient<true>> { }\n}\n```\n\n----------------------------------------\n\nTITLE: Extending Client with CooldownManager - TypeScript\nDESCRIPTION: This code snippet extends the Seyfert `Client` interface with a `cooldown` property of type `CooldownManager` from the `@slipher/cooldown` package. This allows access to cooldown management functionalities within the client instance. It initializes the `CooldownManager` after the client has started.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/cooldown.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Client, type UsingClient } from \"seyfert\";\nimport { CooldownManager } from \"@slipher/cooldown\";\n\nconst client = new Client() as UsingClient & Client;\n\nclient.start().then(() => {\n\tclient.cooldown = new CooldownManager(client);\n})\n\ndeclare module \"seyfert\" {\n\tinterface UsingClient {\n\t\tcooldown: CooldownManager;\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Example Uptime Command - TypeScript\nDESCRIPTION: This snippet provides an example command to display the bot's ready time using the formatted `readyAt` property. It uses the `Formatter.timestamp` method to format the date and then sends a message to the user. It depends on the Seyfert library and requires the `UsingClient` interface to have a `readyAt` property.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/tips-misc/uptime.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { ParseClient, Client } from 'seyfert';\ndeclare module 'seyfert' {\n  interface UsingClient extends ParseClient<Client<true>> {\n    readyAt: Date\n  }\n}\n// ---cut---\nimport { Declare, type CommandContext, Command, Formatter } from \"seyfert\";\n\n@Declare({\n    name: 'uptime',\n    description: 'Show the bot’s ready time',\n})\nexport default class ReadyAtCommand extends Command {\n    async run(ctx: CommandContext) {\n        const readyAtFormatted = Formatter.timestamp(ctx.client.readyAt);\n        await ctx.editOrReply({ content: `The bot became ready on ${readyAtFormatted}.` });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Filtering Component Interactions by customId (TypeScript)\nDESCRIPTION: This TypeScript snippet shows how to filter component interactions based on the `customId` property. The `filter` method is implemented to check if the `customId` of the interaction matches 'hello-world'.  Only interactions with this specific `customId` will be processed by the handler.  It receives a `ComponentContext` which gives access to information about the component interaction.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/components/handling-components.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ComponentCommand, type ComponentContext } from 'seyfert';\n\nexport default class HelloWorldButton extends ComponentCommand {\n  componentType = 'Button' as const;\n\n  filter(ctx: ComponentContext<typeof this.componentType>) {\n    // estamos verificando si el customId de la interacción es el mismo que el establecido en el botón.\n\n    return ctx.customId === 'hello-world';\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Errors in Command Execution with onRunError (TypeScript)\nDESCRIPTION: This snippet demonstrates how to handle errors that occur during the execution of a Seyfert command's `run` method.  It shows how to use the `onRunError` method to catch errors, log them, and send an error message to the user. The `onRunError` method receives the `CommandContext` and the error itself as parameters.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/commands/handling-errors.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Command, type CommandContext } from \"seyfert\";\n\nexport class HandlingErrors extends Command {\n  async run(context: CommandContext) {\n    throw new Error(\"Error, ehm, se detectó un jugador de lol\");\n  }\n\n// @log: Esto responde con el mensaje de error anterior: \"Error, ehm, se detectó un jugador de lol\"\n  async onRunError(context: CommandContext, error: unknown) {\n    context.client.logger.fatal(error);\n    await context.editOrReply({\n      content: error instanceof Error ? error.message : `Error: ${error}`\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Role Options with Seyfert\nDESCRIPTION: This snippet demonstrates how to create a role option for a Discord command using the Seyfert library. It uses `createRoleOption` to define a role option with a description and sets it as required. The `@Options` decorator is used to associate the option with the `Ping` command class.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/commands/options.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n// @exactOptionalPropertyTypes: false\nimport { Options, createRoleOption, Command } from 'seyfert';\n\n@Options({\n    role: createRoleOption({\n        description: 'This is a role option',\n        required: true\n    })\n})\nclass Ping extends Command {}\n```\n\n----------------------------------------\n\nTITLE: Creating Channel Options with Seyfert\nDESCRIPTION: This code demonstrates creating channel options for a Discord command using Seyfert. It shows how to create a generic channel option and a channel option that is limited to specific channel types (GuildVoice). The `createChannelOption` function is used, and `ChannelType` is imported from 'seyfert/lib/types'.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/commands/options.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// @exactOptionalPropertyTypes: false\nimport { Options, createChannelOption, Command } from 'seyfert';\nimport { ChannelType } from 'seyfert/lib/types';\n\n@Options({\n    channel: createChannelOption({\n        description: '',\n    }),\n\n    /// Tipo específico de canal\n    channelTypes: createChannelOption({\n        description: 'This is a limited channel option',\n        channel_types: [ChannelType.GuildVoice]\n    })\n})\nclass Ping extends Command {}\n```\n\n----------------------------------------\n\nTITLE: Locales Property Usage in Seyfert Command Options\nDESCRIPTION: Shows how to utilize the `locales` property within command options to add localized names and descriptions. This property allows specifying translation keys for the `name` and `description` of a command option. Removing the property will prevent localization for that option.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/i18n/usage.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStringOption } from 'seyfert';\n\nconst options = {\n    supremacy: createStringOption({\n        description: \"Enter a supremacy name.\",\n        required: true,\n        // If you don't want to add a command localized name or description!\n        // Just remove the property from the object\n        locales: {\n            name: \"hello\",\n            description: \"foo.bar\",\n        }\n    })\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Kazagumo in index.ts (TypeScript)\nDESCRIPTION: This snippet demonstrates how to configure Kazagumo within the main index.ts file of a Seyfert project. It initializes Kazagumo with connection details to a Lavalink node and defines a custom Client interface for extending the Seyfert client with Kazagumo functionality.  It also registers an event listener to indicate when the Lavalink node is ready.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/music.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Client } from \"seyfert\";\nimport { Kazagumo } from \"kazagumo\";\nimport { type NodeOption, Connectors } from \"shoukaku\";\n\nconst client = new Client();\nconst nodes: NodeOption[] = [\n\t{\n\t\tname: \"Node\",\n\t\turl: \"localhost:2333\",\n\t\tauth: \"youshallnotpass\",\n\t\tsecure: false\n\t}\n];\n\n// Configuración básica, perfecta para este caso\nclient.kazagumo = new Kazagumo(\n\t{\n\t\tdefaultSearchEngine: \"youtube\",\n\t\tsend: (guildId, payload) =>\n\t\t\tclient.gateway.send(client.gateway.calculeShardId(guildId), payload)\n\t},\n\tnew Connectors.Seyfert(client),\n\tnodes\n);\n\n// Para ver si el nodo está conectado\nclient.kazagumo.shoukaku.on(\"ready\", (name) =>\n\tconsole.log(`Lavalink ${name}: Ready!`)\n);\n\ndeclare module \"seyfert\" {\n\tinterface Client {\n\t\tkazagumo: Kazagumo;\n\t}\n}\n\nclient.start().then(() => client.uploadCommands());\n```\n\n----------------------------------------\n\nTITLE: Parent Command with Subcommand Group in Seyfert (TypeScript)\nDESCRIPTION: This code shows how to create a parent command (`ParentCommand`) with a subcommand group named 'my-group' using the `@Groups` decorator. It also includes a single subcommand (`MySubCommand`) registered with `@Options`. The `defaultDescription` field in the `@Groups` decorator provides a description for the group.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/commands/subcommands.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// @noErrors\nimport { Command, Declare, Options, Groups } from 'seyfert';\nimport MySubCommand from './sub';\n\n@Declare({\n    name: 'parent',\n    description: 'My main command',\n})\n@Options([MySubCommand])\n@Groups({\n    'my-group': {\n        defaultDescription: 'A subcommand group',\n    }\n})\nexport default class ParentCommand extends Command {}\n```\n\n----------------------------------------\n\nTITLE: Handling Entitlement Creation Event with Seyfert\nDESCRIPTION: This code snippet demonstrates how to handle the `entitlementCreate` event using the Seyfert library. It creates an event that triggers when a user subscribes, fetching the user's information and logging the subscription to a specified channel.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/monetization.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent } from 'seyfert';\n//---cut---\nexport default createEvent({\n    data: { name: 'entitlementCreate' },\n    async run(entitlement, client) {\n        if (!entitlement.userId) return;\n        const subscribedUser = await client.users.fetch(entitlement.userId);\n        client.messages.write('LOG_CHANNEL_ID', {\n            content: `${subscribedUser.globalName} (${subscribedUser.id}) se ha suscrito a ${entitlement.skuId}`,\n        });\n    },\n});\n```\n\n----------------------------------------\n\nTITLE: Running the Component Handler\nDESCRIPTION: This code snippet demonstrates how to implement the `run` method in a component handler. The `run` method is executed when the filter function returns `true`.  In this example, it responds to the interaction with a message containing 'Hello World 👋' and sets the `MessageFlags.Ephemeral` flag, making the message visible only to the user who triggered the interaction.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/components/handling-components.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ComponentCommand, type ComponentContext } from 'seyfert';\n\nimport { MessageFlags } from 'seyfert/lib/types';\n\nexport default class HelloWorldButton extends ComponentCommand {\n  componentType = 'Button' as const;\n\n  //this can be a promise too.\n\n  filter(ctx: ComponentContext<typeof this.componentType>) {\n    return ctx.customId === 'hello-world';\n  }\n\n  async run(ctx: ComponentContext<typeof this.componentType>) {\n    return ctx.write({\n      content: 'Hello World 👋',\n      flags: MessageFlags.Ephemeral\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Event in Seyfert (TypeScript)\nDESCRIPTION: This code snippet shows how to create a custom event using the `createEvent` function from Seyfert. The event is named `ourEvent`, and its `run` function simply logs the provided text to the console. The `data` object specifies the event's name and whether it should only run once. The `createEvent` function likely handles registration and management within the Seyfert framework.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/custom-events.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent } from 'seyfert';\n\nexport default createEvent({\n\tdata: { name: \"ourEvent\", once: false },\n\trun: (text) => {\n\t\tconsole.log(text);\n\t}\n});\n```\n\n----------------------------------------\n\nTITLE: Loading Commands, Languages, and Components\nDESCRIPTION: This code snippet showcases the manual loading of commands, languages, and components when using Seyfert with Cloudflare Workers. It imports the necessary modules, initializes the HttpClient, and uses the 'set' method to load each component individually.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/cloudflare-workers.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport '../seyfert.config.mjs'; // sí, importando nuestro seyfert.config.mjs\nimport { HttpClient } from 'seyfert';\n\n// comandos\nimport Ping from './commands/ping.js';\n\n// idiomas\nimport EnLang from './languages/en.js';\n\n// componentes\nimport ButtonC from './components/buttonHandle.js';\n\nconst client = new HttpClient();\n\nclient.start()\n  .then(async () => {\n    // necesitamos cargar los comandos manualmente\n    await client.commands!.set('', client, [Ping]);\n\n    // cargar idiomas\n    await client.langs!.set('', [{ name: 'en', file: EnLang }]);\n\n    // cargar componentes\n    await client.components!.set('', client, [ButtonC]);\n  });\n\nadapter.start();\n\nexport default {\n  fetch(req: Request) {\n    return adapter.fetch(req);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Seyfert User Transformer (Typescript)\nDESCRIPTION: This snippet defines a custom transformer for the User object in Seyfert. It takes the Seyfert client and raw user data as input and returns a custom MyUser object with additional properties like `esAdmin` and a `raw()` method. It requires a type definition for MyUser and a module declaration to extend Seyfert's CustomStructures interface.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/transformers.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { APIUser } from 'seyfert/lib/types';\n\ninterface MyUser {\n    username: string;\n    esAdmin: boolean;\n    raw(): Promise<APIUser>;\n}\n//---cut---\nimport { Transformers } from 'seyfert';\n\nTransformers.User = (client, data) => {\n    return {\n        username: data.username,\n        esAdmin: Math.random() > 0.5,\n        raw() {\n            return client.users.raw(data.id);\n        },\n    };\n};\n\n/*\nYa llegado a este punto,\ndeberias tener un `declare module \"seyfert\"` en tu proyecto,\nsi no, añadelo.\n*/\ndeclare module \"seyfert\" {\n// Declarando el tipo de esta manera, \n// se reflejará en el tipado de todo el proyecto.\n    interface CustomStructures {\n        User: MyUser;\n// Puedes añadir tantos transformers como quieras, con cualquier tipo\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Delete Subcommand Definition\nDESCRIPTION: This code defines the `DeleteCommand` as a subcommand, extending the `SubCommand` class.  The `@Declare` decorator sets the name and description. The `run` method contains the logic for the subcommand and returns a `CommandContext` with the result.  The `ctx.write` method is used to send a response to the user.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/commands/subcommands.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { type CommandContext, Declare, SubCommand } from \"seyfert\";\n\n@Declare({\n\tname: \"delete\",\n\tdescription: \"delete something\"\n})\nexport class DeleteCommand extends SubCommand {\n\trun(ctx: CommandContext) {\n\t\t// some logic here\n\n\t\treturn ctx.write({\n\t\t\tcontent: \"delete command executed\"\n\t\t});\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Logger Middleware in Seyfert (TypeScript)\nDESCRIPTION: This code snippet creates a basic middleware that logs the command being executed. It uses the `createMiddleware` function from Seyfert and accesses the context to log the username, ID, and command name.  It then calls `middle.next()` to pass control to the next middleware.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/commands/middlewares.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createMiddleware } from \"seyfert\";\n\n// El tipo genérico le dice al middleware qué información pasará al comando\nexport const loggerMiddleware = createMiddleware<void>(\n  (middle) => {\n    // Registrar el comando\n    console.log(\n      `${middle.context.author.username} (${middle.context.author.id}) ejecutó /(${middle.context.resolver.fullCommandName}`\n    );\n\n    // Pasar al siguiente middleware\n    middle.next();\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: Implementing getToRelationship Method in Seyfert Adapter (TypeScript)\nDESCRIPTION: This snippet shows how to implement the `getToRelationship` method in a Seyfert adapter. It retrieves the relationships associated with a given 'to' value using the `setGet` method of the `almacenamiento` (SeyfertDotDev) interface. If no relationships are found, it returns an empty array. The method is asynchronous and returns a promise resolving to an array of strings.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/cache.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\ninterface SeyfertDotDev {\n    setGet(key: string): Promise<string[] | undefined>;\n}\n\nimport { Adapter } from 'seyfert';\n\nclass MiAdaptador implements Adapter {\n    almacenamiento: SeyfertDotDev;\n    async getToRelationship(to: string) {\n        return await this.almacenamiento.setGet(to) ?? []\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring a Seyfert Parent Command\nDESCRIPTION: This code snippet demonstrates how to declare a parent command named 'poll' in Seyfert. It utilizes the `@Declare` decorator to define the command's name and description. The `@AutoLoad` decorator automatically loads this command. This parent command serves as a container for subcommands related to poll management.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/components/polls.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { AutoLoad, Declare, Command } from 'seyfert';\n\n@Declare({\n    name: 'poll',\n    description: 'Poll command!',\n})\n@AutoLoad()\nexport default class PollCommand extends Command {}\n```\n\n----------------------------------------\n\nTITLE: Sending an Embed Message with Seyfert\nDESCRIPTION: This snippet demonstrates how to create and send an embed message using the `Embed` builder in Seyfert. The embed's title and description are set using the builder methods, and the embed is then included in the `embeds` array passed to `ctx.write()`.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/sending-messages.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Embed, Command, type CommandContext } from 'seyfert';\n\nexport default class HelloWorldCommand extends Command {\n  async run(ctx: CommandContext) {\n\n\n    const embed = new Embed()\n      .setTitle('Mi Embed Asombroso')\n      .setDescription('Hola mundo 👋');\n\n    await ctx.write({ embeds: [embed] });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing an Asynchronous Adapter in Seyfert\nDESCRIPTION: This code snippet shows how to implement an asynchronous adapter in Seyfert. The adapter class `MyAdapter` implements the `Adapter` interface and sets `isAsync` to `true`. The `start` method can be used for asynchronous initialization logic.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/cache.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// @noErrors\nimport { Adapter } from 'seyfert';\n\nclass MyAdapter implements Adapter {\n    isAsync = true;\n\n    async start() {\n        // This function will run before starting the bot\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Stopping Middleware Execution with Errors in Seyfert (TypeScript)\nDESCRIPTION: This snippet demonstrates how to create a middleware that stops command execution and returns an error message. It uses the `createMiddleware` function to define the middleware. The `stop` function halts further processing and returns a message. The input is a context object. The output depends on the evaluation of `Devs.includes(context.author.id)`; it either continues processing with `next()` or stops with an error message using `stop()`.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/commands/handling-errors.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst Devs = [''];\n// ---cut---\nimport { createMiddleware } from \"seyfert\";\n\nexport default createMiddleware<void>(({ context, next, stop, pass }) => {\n    if (!Devs.includes(context.author.id)) {\n        return stop(\"User is not a developer\");\n    }\n    next();\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing a Basic Seyfert Command (TypeScript)\nDESCRIPTION: This snippet demonstrates how to create a basic Seyfert command with a name and description, using the `@Declare` decorator. It imports necessary modules from 'seyfert' and defines a class that extends the `Command` class. The `run` method is left empty as a placeholder for future implementation.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/sending-messages.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Command, Declare, type CommandContext } from 'seyfert';\n\n@Declare({\n  name: 'helloworld',\n  description: 'Sends a basic hello world message.',\n})\nexport default class HelloWorldCommand extends Command {\n  async run(ctx: CommandContext) {}\n}\n```\n\n----------------------------------------\n\nTITLE: tsconfig.json Configuration (Minimal)\nDESCRIPTION: This snippet shows the minimum configuration needed in `tsconfig.json` to enable decorator support for Seyfert.  It adds `emitDecoratorMetadata` and `experimentalDecorators` compiler options, which are essential for decorator-based features of Seyfert to work correctly.  No specific input is required as it is a configuration file. Output is the properly configured tsconfig.json file.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/getting-started/setup-project.mdx#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"compilerOptions\": {\n\n        \"emitDecoratorMetadata\": true,\n        \"experimentalDecorators\": true\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Añadiendo subcomandos en Seyfert (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to add subcommands to a parent command in Seyfert using the `@Options` decorator. It shows two files: `parent.ts` which defines the parent command and imports the subcommand, and `sub.ts` which defines the subcommand itself.  The `SubCommand` class is extended to create the subcommand.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/commands/intro.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// @noErrors\nimport { Command, Declare, Options } from 'seyfert';\nimport MiSubComando from './sub';\n\n@Declare({\n    name: 'padre',\n    description: 'Mi comando principal',\n})\n@Options([MiSubComando])\nexport default class PadreCommand extends Command { }\n\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { SubCommand, Declare, CommandContext } from 'seyfert';\n\n@Declare({\n    name: 'subcomando',\n    description: 'Uno de mi subcomandos',\n})\nexport default class MiSubCommand extends SubCommand {\n    run(ctx: CommandContext) {\n        return ctx.write({\n            content: '¡Hola desde el subcomando!',\n        });\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Handling Interactions in Seyfert Collector\nDESCRIPTION: This snippet illustrates how to handle button interactions within a component collector using the `run` function. The `run` function takes the custom ID of the button as the first parameter and a callback function as the second.  The callback function handles the button interaction, in this case, sending a 'Hello World 👋' message.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/components/collectors.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  Button,\n  ActionRow,\n  Command,\n  Declare,\n  type CommandContext,\n} from 'seyfert';\n\nimport { ButtonStyle } from 'seyfert/lib/types';\n\n@Declare({\n  name: 'hello',\n  description: 'I will send you a hello world message',\n})\nexport default class HelloWorldCommand extends Command {\n  async run(ctx: CommandContext) {\n    const button = new Button()\n      .setCustomId('hello')\n      .setLabel('Hello')\n      .setStyle(ButtonStyle.Primary);\n\n    const row = new ActionRow<Button>().setComponents([button]);\n\n    const message = await ctx.write(\n      {\n        content: 'Do you want a hello world? Click the button below.',\n        components: [row],\n      },\n      true\n    );\n\n    const collector = message.createComponentCollector();\n\n    // we are passing the custom ID set on the button as the first parameter of the function.\n    collector.run('hello', async (i) => {\n      if (i.isButton()) return i.write({ content: 'Hello World 👋' });\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Select Menus and ActionRows with Seyfert (TypeScript)\nDESCRIPTION: This code demonstrates how to create different types of Select Menu components (String, User, Role, Channel, and Mentionable) and their corresponding ActionRows using Seyfert.  Each select menu is configured with a custom ID and placeholder text. The StringSelectMenu is populated with options, and the other select menus are configured with default values. Each menu is then placed into its own ActionRow. This example showcases the different types of select menus available and how to create an action row for each.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/components/building-components.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  ActionRow,\n  StringSelectMenu,\n  StringSelectOption,\n  UserSelectMenu,\n  RoleSelectMenu,\n  ChannelSelectMenu,\n  MentionableSelectMenu\n} from 'seyfert';\n\nconst stringMenu = new StringSelectMenu()\n  .setCustomId('menu-de-cadenas')\n  .setPlaceholder('Selecciona una opción de cadena')\n  .addOption(\n    new StringSelectOption().setLabel('Opción 1').setValue('1'),\n    new StringSelectOption().setLabel('Opción 2').setValue('2')\n  );\n\nconst stringRow = new ActionRow<StringSelectMenu>().setComponents([stringMenu]);\n\nconst userMenu = new UserSelectMenu()\n  .setCustomId('menu-de-usuarios')\n  .setPlaceholder('Selecciona un usuario')\n  //id de usuarios\n  .setDefaultUsers('123456789', '987654321');\n\nconst userRow = new ActionRow<UserSelectMenu>().setComponents([userMenu]);\n\nconst roleMenu = new RoleSelectMenu()\n  .setCustomId('menu-de-roles')\n  .setPlaceholder('Selecciona un rol')\n  //id de roles\n  .setDefaultRoles('123456789', '987654321');\n\nconst roleRow = new ActionRow<RoleSelectMenu>().setComponents([roleMenu]);\n\nconst channelMenu = new ChannelSelectMenu()\n  .setCustomId('menu-de-canales')\n  .setPlaceholder('Selecciona un canal')\n  //id de canales\n  .setDefaultChannels('123456789', '987654321');\n\nconst channelRow = new ActionRow<ChannelSelectMenu>().setComponents([channelMenu]);\n\nconst mentionableMenu = new MentionableSelectMenu()\n  .setCustomId('menu-de-mencionables')\n  .setPlaceholder('Selecciona un mencionable')\n  //id de mencionables (rol o usuario)\n  .setDefaultMentionables(\n    { type: 'User', id: '123456789' },\n    { type: 'Role', id: '987654321' }\n  );\n\nconst mentionableRow = new ActionRow<MentionableSelectMenu>().setComponents([mentionableMenu]);\n```\n\n----------------------------------------\n\nTITLE: Decorating a Command with Cooldown (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to use the `@Cooldown` decorator from `@slipher/cooldown` to apply a cooldown to a Seyfert command. It specifies the cooldown type (User), interval (1 minute), and number of uses (2 per minute). The `onMiddlewaresError` function handles cooldown errors.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/cooldown.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Declare, Command, type CommandContext } from \"seyfert\";\nimport { CooldownType, Cooldown } from \"@slipher/cooldown\";\n\n@Declare({\n\tname: 'cool',\n\tdescription: 'Comando de referencia'\n})\n@Cooldown({\n\ttype: CooldownType.User,\n\tinterval: 1000 * 60, // 1 minuto\n\tuses: {\n\t\tdefault: 2 // 2 usos por minuto\n\t},\n})\nexport default class Genial extends Command {\n  async run(ctx: CommandContext) {\n    await ctx.write({\n      content: `Un comando genial`\n    });\n  }\n\n  onMiddlewaresError(context: CommandContext, error: string) {\n    context.editOrReply({ content: error })\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Integer Options with Seyfert\nDESCRIPTION: This snippet illustrates how to create integer options for a Discord command using the Seyfert library. It provides examples for normal integer options, options with predefined choices, options with autocomplete functionality, and options with value limits. The `createIntegerOption` function is used to define each option, and the `@Options` decorator associates these options with the `Ping` command class.  The autocomplete function converts the selected string value to an integer before responding to the interaction.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/commands/options.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// @exactOptionalPropertyTypes: false\nimport { Options, createIntegerOption, Command } from 'seyfert';\n\n@Options({\n    normal: createIntegerOption({\n        description: '',\n    }),\n    \n    /// Opciones fijas\n    choices: createIntegerOption({\n        description: '',\n        choices: [\n            { name: 'seyfert', value: 1 },\n            { name: 'potocuit', value: 2 },\n            { name: 'biscuit', value: 3 }\n        ]\n    }),\n\n    /// Autocompletado\n    autocomplete: createIntegerOption({\n        description: '',\n        autocomplete: (interaction) => {\n            const select = ['1651611', '4616165156549', '15616416515616'];\n\n            const focus = interaction.getInput();\n\n            return interaction.respond(\n                select\n                    .filter((ch) => ch.includes(focus))\n                    .map((ch) => ({ name: ch, value: parseInt(ch) }))\n            );\n        }\n    }),\n\n    /// Límites de valores\n    limitValue: createIntegerOption({\n        description: '',\n        max_value: 500,\n        min_value: 200\n    })\n})\nclass Ping extends Command {}\n```\n\n----------------------------------------\n\nTITLE: Disabling the Entire Cache in Seyfert\nDESCRIPTION: This code snippet shows how to completely disable the cache functionality in Seyfert. Setting `disabledCache` to `true` within the `setServices` method removes the entire cache functionality.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/cache.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Client } from 'seyfert';\n\nconst client = new Client();\n// ---cut---\nclient.setServices({ cache: { disabledCache: true } })\n```\n\n----------------------------------------\n\nTITLE: Handling Command Execution Errors in Seyfert (TypeScript)\nDESCRIPTION: This snippet demonstrates how to handle execution errors that occur within a Seyfert command's `run` method. It overrides the `onRunError` method to log the error and send an error message to the user. It depends on the `Command` and `CommandContext` types from the \"seyfert\" package.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/commands/command-class.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Command, type CommandContext } from \"seyfert\";\n\nexport class HandlingErrors extends Command {\n  async run(context: CommandContext) {\n    throw new Error(\"Error, ehm, jugador de lol detectado\");\n  }\n\n  // Esto responderá con el mensaje de error anterior \"Error, ehm, jugador de lol detectado\"\n  async onRunError(context: CommandContext, error: unknown) {\n    context.client.logger.fatal(error);\n    await context.editOrReply({\n      content: error instanceof Error ? error.message : `Error: ${error}`\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Gateway Intents in Seyfert\nDESCRIPTION: This code snippet demonstrates how to configure the necessary gateway intents in the `seyfert.config.mjs` file to enable the bot to receive poll events. The `GuildMessagePolls` and `DirectMessagePolls` intents are required for the bot to listen to poll-related activities in guilds and direct messages, respectively.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/components/polls.mdx#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nexport default config.bot({\n   //... other options\n   intents: ['GuildMessagePolls', 'DirectMessagePolls'],\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Premium Button with Seyfert\nDESCRIPTION: This snippet demonstrates how to create a premium button using the Seyfert library. The button is configured with a SKU ID and the `Premium` button style, which redirects users to a store item when clicked. No CustomID or Label needed for this button type.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/monetization.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Button } from 'seyfert';\nimport { ButtonStyle } from 'seyfert/lib/types';\n\nnew Button()\n.setSKUId('STORE_ITEM_SKU_ID')\n.setStyle(ButtonStyle.Premium)\n```\n\n----------------------------------------\n\nTITLE: Loading Commands, Languages, and Components\nDESCRIPTION: This code snippet shows how to load commands, languages, and components manually in a Cloudflare Workers environment due to the lack of file system support.  It imports the necessary modules, creates a HttpClient instance, and loads commands, languages, and components into their respective stores.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/cloudflare-workers.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport '../seyfert.config.mjs'; // ye, importing our seyfert.config.mjs\nimport { HttpClient } from 'seyfert';\n\n// commands\nimport Ping from './commands/ping.js';\n\n// langs\nimport EnLang from './languages/en.js';\n\n// components\nimport ButtonC from './components/buttonHandle.js';\n\nconst client = new HttpClient();\n\nclient.start()\n  .then(async () => {\n    // we need to load commands manually\n    await client.commands!.set('', client, [Ping]);\n\n    // load languages\n    await client.langs!.set('', [{ name: 'en', file: EnLang}]);\n\n    // load components\n    await client.components!.set('', client, [ButtonC]);\n  });\n\nadapter.start();\n\nexport default {\n  fetch(req: Request) {\n    return adapter.fetch(req);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Play Command (TypeScript)\nDESCRIPTION: This code snippet defines a `PlayCommand` that allows users to play music in a voice channel using Kazagumo.  It checks if the user is in a voice channel, searches for the requested song, adds it to the queue, and starts playing.  The command leverages Seyfert's command structure with options, decorators, and context.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/music.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n\tCommand,\n\tDeclare,\n\tOptions,\n\ttype CommandContext,\n\tcreateStringOption\n} from \"seyfert\";\nimport { MessageFlags } from \"seyfert/lib/common\";\n\nconst options = {\n\tquery: createStringOption({\n\t\tdescription: \"Enter a song name or url.\",\n\t\trequired: true\n\t})\n};\n\n@Declare({\n\tname: \"play\",\n\tdescription: \"Play music.\"\n})\n@Options(options)\nexport default class PlayCommand extends Command {\n\tasync run(ctx: CommandContext<typeof options>) {\n\t\tconst { options, client, guildId, channelId, member, author } = ctx;\n\t\tconst { query } = options;\n\n\t\tif (!guildId || !member) return;\n\n\t\tconst voice = member.voice();\n\t\tif (!voice)\n\t\t\treturn ctx.write({\n\t\t\t\tcontent: \"You need to be in a voice channel to play music.\",\n\t\t\t\tflags: MessageFlags.Ephemeral\n\t\t\t});\n\n\t\tconst botVoice = ctx.me()?.voice();\n\t\tif (botVoice && botVoice.channelId !== voice.channelId)\n\t\t\treturn ctx.write({\n\t\t\t\tcontent: \"You need to be in the same voice channel as me.\",\n\t\t\t\tflags: MessageFlags.Ephemeral\n\t\t\t});\n\n\t\tconst player = await client.kazagumo.createPlayer({\n\t\t\tguildId: guildId,\n\t\t\ttextId: channelId,\n\t\t\tvoiceId: voice.channelId,\n\t\t\tvolume: 100\n\t\t});\n\n\t\tconst result = await client.kazagumo.search(query, { requester: author });\n\t\tif (!result.tracks.length)\n\t\t\treturn ctx.write({ content: \"No results found!\" });\n\n\t\tif (result.type === \"PLAYLIST\") player.queue.add(result.tracks);\n\t\telse player.queue.add(result.tracks[0]);\n\n\t\tif (!player.playing && !player.paused) player.play();\n\t\treturn ctx.write({\n\t\t\tcontent:\n\t\t\t\tresult.type === \"PLAYLIST\"\n\t\t\t\t\t? `Queued ${result.tracks.length} from ${result.playlistName}`\n\t\t\t\t\t: `Queued ${result.tracks[0].title}`\n\t\t});\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Inter-Worker Communication in Seyfert\nDESCRIPTION: This code snippet shows how to facilitate communication between workers in Seyfert using the `tellWorker` method. It initializes the WorkerClient and then uses `tellWorker` to send a message to a specific worker, executing a function in that worker's context.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/sharding.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { WorkerClient } from 'seyfert';\nconst client = new WorkerClient();\n//---cut---\nclient.tellWorker(\n\t1,\n\t(worker, vars) => console.log(`Hii worker #${worker.workerId} from ${vars.workerId}`),\n\t{ workerId: client.workerId }\n);\n```\n\n----------------------------------------\n\nTITLE: Extending Seyfert Types\nDESCRIPTION: This snippet demonstrates how to extend Seyfert's type definitions using declaration merging. It defines the `UsingClient` interface to associate a specific client type (Client, HttpClient, or WorkerClient) with the `ParseClient` type. This allows you to customize the client type used within Seyfert's type system.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/getting-started/setup-project.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { ParseClient, Client, HttpClient, WorkerClient } from 'seyfert';\n\ndeclare module 'seyfert' {\n\n    interface UsingClient extends ParseClient<Client<true>> { }\n  \n  \n    interface UsingClient extends ParseClient<HttpClient> { }\n  \n  \n    interface UsingClient extends ParseClient<WorkerClient<true>> { }\n}\n```\n\n----------------------------------------\n\nTITLE: LocalesT Decorator Usage in Seyfert\nDESCRIPTION: Demonstrates how to use the `@LocalesT` decorator to automatically translate command content, such as name and description, based on defined locales. It requires defining a `DefaultLocale` interface in the `seyfert` module and specifying the translation keys for the command.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/i18n/usage.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { ParseLocales } from 'seyfert';\nconst lang = {\n    'my-command': {\n        name: '',\n        description: '',\n    },\n};\ndeclare module 'seyfert' {\n    interface DefaultLocale extends ParseLocales<typeof lang> {}\n}\n// ---cut---\nimport { Command, LocalesT } from 'seyfert';\n\n@LocalesT('my-command.name', 'my-command.description')\n//                   ^|\nclass MyCommand extends Command {}\n```\n\n----------------------------------------\n\nTITLE: Extending RC Interface in Seyfert\nDESCRIPTION: This code snippet demonstrates how to extend the `ExtendedRC` interface in the `seyfert` module to add a custom `prefix` property.  This allows for custom configurations that are not included in the base package. Required: `seyfert` package.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/extending-config.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare module 'seyfert' {\n    interface ExtendedRC {\n        prefix: string;\n        // incluso más propiedades\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Extending Seyfert CommandContext in TypeScript\nDESCRIPTION: This code snippet demonstrates how to extend the CommandContext in Seyfert to include a custom property `myCoolProp`. It uses the `extendContext` function to add the property to the context based on the interaction and then passes the extended context during the Seyfert client initialization.  It requires importing `Client` and `extendContext` from the 'seyfert' library.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/commands/extend-commandcontext.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Client, extendContext } from 'seyfert';\n\nconst context = extendContext((interaction) => {\n  // Aquí puedes añadir\n\n  return {\n    myCoolProp: 'seyfert>>'\n  };\n});\n\nconst client = new Client({ context });\n```\n\n----------------------------------------\n\nTITLE: Extending Seyfert Client Types (Gateway)\nDESCRIPTION: This code snippet demonstrates how to inform TypeScript about the specific client type being used in your Seyfert project when using the Gateway client. It extends the 'seyfert' module with an interface that defines the client type.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/getting-started/declare-module.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { ParseClient, Client, HttpClient, WorkerClient } from 'seyfert';\n\ndeclare module 'seyfert' {\n\n    interface UsingClient extends ParseClient<Client<true>> { }\n  \n}\n```\n\n----------------------------------------\n\nTITLE: Fetching Guild Data with Seyfert\nDESCRIPTION: This code shows how to fetch guild data using Seyfert within a `guildMemberAdd` event. It retrieves the guild object using `member.guild()` which is a fetch request to the cache and then uses the guild name in the welcome message. The example uses Shorters for accessing the messages.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/api-access.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent } from 'seyfert';\n\nconst db = new Map<string, string>();\n\nexport default createEvent({\n  data: { name: 'guildMemberAdd' },\n  run: async (member, client) => {\n    const channelId = db.get(member.guildId);\n    if (!channelId) return;\n\n    // this is a fetch request to cache (force if you want direct api fetch)\n    const guild = await member.guild();\n\n    await client.messages.write(channelId, {\n      content: `Welcome ${member} to ${guild.name} :wave:`, // guild.name is used\n    });\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Filtering Channel Cache in Seyfert (TypeScript)\nDESCRIPTION: This code demonstrates how to filter the channel cache to exclude DM and GroupDM channels.  It filters based on `channel.type`. Requires the `seyfert` package and imports `APIChannel` and `ChannelType`.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/cache.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Client } from \"seyfert\";\nimport { type APIChannel, ChannelType } from \"seyfert/lib/types\";\nconst client = new Client();\n\nclient.cache.channels!.filter = (\n    channel,\n    id,\n    guildId,\n) => {\n    return ![\n        ChannelType.DM,\n        ChannelType.GroupDM\n    ].includes(channel.type);\n};\n```\n\n----------------------------------------\n\nTITLE: Setting Default Language\nDESCRIPTION: This code snippet demonstrates how to set a default language for the bot using `client.setServices`. This helps prevent undefined values if a specific language isn't specified. It sets 'en-US' as the default language.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/i18n/languages.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Client } from \"seyfert\";\nconst client = new Client();\n// ---cut--- snoopy\nclient.setServices({ langs: { default: 'en-US' } });\n```\n\n----------------------------------------\n\nTITLE: Listening to the guildDelete Event (Typescript)\nDESCRIPTION: This code snippet demonstrates how to listen to the `guildDelete` event, which is emitted when the bot is removed from a server or the server is deleted. It uses the `createEvent` function to define the event data and provides a `run` function that logs the ID of the server from which the bot was removed. It also includes a check to handle unavailable servers.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/getting-started/listening-events.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent } from 'seyfert';\n\nexport default createEvent({\n  data: { name: 'guildDelete' },\n  run(unguild, client) {\n    // unguild is the server from which the bot was removed or deleted.\n    // It is also possible that the server was simply deleted.\n    if (unguild.unavailable) return;\n\n    client.logger.info(`I was removed from: ${unguild.id}`);\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Executing Custom Event in Seyfert (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to execute a custom event using the Seyfert client.  It initializes a new Seyfert client, starts it, and then runs the custom event `ourEvent` with the argument 'Hello, world!'.  The `client.events?.runCustom` function is used to trigger the custom event.  This snippet also redeclares the CustomEvents interface, which is likely unnecessary.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/custom-events.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Client } from \"seyfert\";\n\nconst client = new Client();\n\n(async () => {\n\tawait client.start();\n\tclient.events?.runCustom('ourEvent', 'Hello, world!');\n})();\n\ndeclare module \"seyfert\" {\n\tinterface CustomEvents {\n\t\tourEvent: (text: string) => void;\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Using Shorters in Seyfert\nDESCRIPTION: This code snippet demonstrates how to use shorters to send a welcome message to a channel. It retrieves the channel ID from a database and uses the `client.messages.write` method to send the message. This approach avoids unnecessary data fetching from the cache.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/api-access.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent } from 'seyfert';\n\nconst db = new Map<string, string>();\n\nexport default createEvent({\n\tdata: { name: 'guildMemberAdd' },\n\trun: async (member, client) => {\n\t\tconst channelId = db.get(member.guildId);\n\t\tif (!channelId) { return; }\n\n\t\tawait client.messages.write(channelId, {\n\t\t\tcontent: `Welcome ${member} :wave:`, // highlighted line\n\t\t}); // highlighted line\n\t}, // highlighted line\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Key/Value Operations in Seyfert Adapter in TypeScript\nDESCRIPTION: This snippet presents the implementation of `keys`, `values`, `count`, and `contains` methods for a Seyfert adapter. It demonstrates how to retrieve keys and values associated with a given relationship, count the number of related items, and check if a specific key exists within the relationship.  It relies on `setGet` to retrieve keys and a `get` method to retrieve values.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/cache.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\ninterface SeyfertDotDev {\n    setGet(key: string): Promise<string[] | undefined>;\n}\n// @noErrors\n// ---cut---\nimport { Adapter } from 'seyfert';\n\nclass MyAdapter implements Adapter {\n    // ---cut-start---\n    storage: SeyfertDotDev;\n    get(key: string): Promise<any>\n    // ---cut-end---\n    async getToRelationship(to: string) {\n        return await this.storage.setGet(to) ?? []\n    }\n\n    async keys(to: string) {\n        const keys = await this.storage.setGet(to) ?? [];\n        return keys.map(key => `${to}.${key}`);\n    }\n\n    async values(to: string) {\n        const array: any[] = [];\n        const keys = await this.keys(to);\n\n        for (const key of keys) {\n            const content = await this.get(key);\n\n            if (content) {\n                array.push(content);\n            }\n        }\n\n        return array;\n    }\n\n    async count(to: string) {\n        return (await this.getToRelationship(to)).length;\n    }\n\n    async contains(to: string, key: string) {\n        return (await this.getToRelationship(to)).includes(key);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Extending Seyfert Global Middlewares Type\nDESCRIPTION: This code snippet demonstrates how to inform TypeScript about the structure of global middlewares by extending the 'seyfert' module with the `GlobalMetadata` interface.  It assumes all global middlewares are exported from a specific file.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/getting-started/declare-module.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// Suponiendo que exportaste todos los middlewares de './globalMiddlewares';\nimport type * as globalMiddlewares from './globalMiddlewares';\n\ndeclare module 'seyfert' {\n    interface GlobalMetadata extends ParseMiddlewares<typeof globalMiddlewares> {}\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Relationship Storage in a Custom Seyfert Adapter\nDESCRIPTION: This code demonstrates how to implement the `addToRelationship` and `bulkAddToRelationShip` methods in a custom Seyfert adapter to store relationships between cache entries. It uses a `setAdd` operation to maintain unique relationships. `bulkAddToRelationShip` iterates over the provided data to add multiple relationships at once.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/cache.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\ninterface SeyfertDotDev {\n    setAdd(key: string, key: string): Promise<void>;\n}\n// @noErrors\n// ---cut---\nimport { Adapter } from 'seyfert';\n\nclass MyAdapter implements Adapter {\n    // ---cut-start---\n    storage: SeyfertDotDev;\n    // ---cut-end---\n    async addToRelationship(id: string, keys: string | string[]) {\n        for (const key of Array.isArray(keys) ? keys : [keys]) {\n            // Add to a \"Set\", IDs must be unique\n            await this.storage.setAdd(id, key);\n        }\n    }\n\n    async bulkAddToRelationShip(data: Record<string, string[]>) {\n        for (const i in data) {\n            await this.addToRelationship(i, data[i]);\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: GroupsT Decorator Usage in Seyfert\nDESCRIPTION: Illustrates how to use the `@GroupsT` decorator for localizing command group names and descriptions. The decorator takes an object where each key represents a group name, and each value is an object containing `defaultDescription` and `name` properties for the default and localized descriptions, respectively.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/i18n/usage.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Command, LocalesT } from 'seyfert';\n\n@GroupsT({\n    supremacy: {\n        defaultDescription: \"Ganyu Supremacy.\",\n        name: \"foo.bar\",\n    }\n})\nexport default class SupremacyCommand extends Command { }\n```\n\n----------------------------------------\n\nTITLE: Scanning Data with Seyfert Adapter in TypeScript\nDESCRIPTION: This snippet demonstrates the `scan` method implementation for a Seyfert adapter. It retrieves data based on a query string and returns either the keys or values of the matching entries from the storage. The storage is an object conforming to `SeyfertDotDev` interface which provides an `entries` method.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/cache.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\ninterface SeyfertDotDev {\n    entries(): Promise<[string, unknown][]>; \n}\n// @noErrors\n// ---cut---\nimport { Adapter } from 'seyfert';\n\nclass MyAdapter implements Adapter {\n    // ---cut-start---\n    storage: SeyfertDotDev;\n    // ---cut-end---\n    async scan(query: string, keys?: false): any[]; \n    async scan(query: string, keys: true): string[]; \n    async scan(query: string, keys = false) {\n        const values: (string | unknown)[] = [];\n        const sq = query.split('.');\n        // Your client will likely have a more optimized way to do this.\n        // Like our Redis adapter.\n        for (const [key, value] of await this.storage.entries()) {\n            const match = key.split('.')\n                .every((value, i) => (sq[i] === '*' ? !!value : sq[i] === value));\n            if (match) {\n                values.push(keys ? key : value);\n            }\n        }\n\n        return values;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Final Extended Seyfert Bot Configuration\nDESCRIPTION: This is the final extended configuration example for the Seyfert bot, showing both the custom `prefix` property and the custom `music` location.  It showcases how to use the extended configurations in the bot's initialization.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/extending-config.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { config } from \"seyfert\";\n\nexport default config.bot({\n\tlocations: {\n\t\tbase: \"dist\",\n\t\tcommands: \"commands\",\n\t\tmusic: \"lavalink\", // dist/lavalink\n\t},\n\ttoken: process.env.TOKEN!,\n\tprefix: \"s!\",\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Reply Behavior for Prefix Commands in Seyfert (TS)\nDESCRIPTION: This code shows how to configure the `reply` behavior for prefix commands in Seyfert. Setting the `reply` sub-option within the `commands` option to a function that returns `true` will make the bot reply to the message that triggered the command.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/commands/prefix-commands.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Client } from 'seyfert';\n\nconst client = new Client({\n    commands: {\n        prefix: (msg) => {\n            // aquí puedes manejar los prefijos que quieras considerar dependiendo de los datos del mensaje.\n            return ['!', '?', '.']\n        },\n        reply: (ctx) => true\n    }\n});\n```\n\n----------------------------------------\n\nTITLE: Extending Seyfert Middlewares Type\nDESCRIPTION: This code snippet shows how to inform TypeScript about the structure and composition of your middlewares by extending the 'seyfert' module with the `RegisteredMiddlewares` interface.  It assumes that all middlewares are exported from a specific file.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/getting-started/declare-module.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// Suponiendo que exportaste todos los middlewares de './middlewares';\nimport type * as allMiddlewares from './middlewares';\n\ndeclare module 'seyfert' {\n    interface RegisteredMiddlewares extends ParseMiddlewares<typeof allMiddlewares> {}\n}\n```\n\n----------------------------------------\n\nTITLE: Seyfert Gateway Bot Configuration\nDESCRIPTION: This code shows how to configure a Seyfert Gateway bot using `seyfert.config.mjs`.  It sets the bot token, command locations, and gateway intents. Optionally, a public key and port can be specified to receive HTTP interactions in addition to the gateway.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/getting-started/setup-project.mdx#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { config } from \"seyfert\";\n\nexport default config.bot({\n    token: process.env.BOT_TOKEN ?? \"\",\n    locations: {\n        base: \"dist\", // reemplazar por \"src\" en caso de usar bun\n        commands: \"commands\"\n    },\n    intents: [\"Guilds\"],\n    // Esta configuración es opcional, por si desea recibir las interacciones por HTTP\n    // Así se puede usar tanto la gateway como el HTTP webhook\n    publicKey: \"...\", // reemplazar por tu clave pública\n    port: 4444, // reemplazar por el puerto de tu aplicación \n});\n```\n\n----------------------------------------\n\nTITLE: Handle Poll End Event in Seyfert\nDESCRIPTION: This TypeScript code snippet demonstrates how to handle the `messageUpdate` event to detect when a poll ends. It checks if the `isFinalized` property of the poll results is true and logs a message indicating that the poll has ended. It accesses the `newMessage` which contains the poll results.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/components/polls.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent } from 'seyfert';\n\nexport default createEvent({\n    data: { name: 'messageUpdate' },\n    // Esto es [newMessage, oldMessage]\n    // Pero en este ejemplo sólo necesitamos newMessage\n    run: ([newMessage]) => {\n        if (newMessage.poll?.results?.isFinalized) {\n            console.log(`The poll with the id: ${newMessage.id} is ended`)\n        }\n    },\n});\n```\n\n----------------------------------------\n\nTITLE: Listening to the botReady Event (Typescript)\nDESCRIPTION: This code snippet demonstrates how to listen to the `botReady` event using the `createEvent` function. It imports `createEvent` from 'seyfert', defines the event data (specifying that it should run only once), and provides a `run` function that logs a message when the event is triggered. The `botReady` event is triggered when all shards and servers are ready.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/getting-started/listening-events.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent } from 'seyfert';\n\nexport default createEvent({\n// botReady is triggered when all shards and servers are ready.\n// `once` ensures the event runs only once.\n  data: { once: true, name: 'botReady' },\n  run(user, client) {\n\n// @log: We can use client.logger to display messages in the console.\n    client.logger.info(`${user.username} is ready`);\n\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Creating a Component Command Class (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates how to create a class that extends `ComponentCommand` from the 'seyfert' library.  It sets the `componentType` property to 'Button', indicating that this component will handle button interactions. This example provides the basic structure for a component handler.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/components/handling-components.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ComponentCommand } from 'seyfert';\n\nexport default class HelloWorldButton extends ComponentCommand {\n    componentType = 'Button' as const;\n}\n```\n\n----------------------------------------\n\nTITLE: Autocomplete Usage Example for GuildMember Transformer\nDESCRIPTION: This code snippet demonstrates how to use the autocomplete feature in your editor to explore available transformers in the Seyfert library.  Specifically, it shows how to start typing `Transformers.GuildMember` to see the available options and types associated with the GuildMember transformer.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/transformers.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Transformers } from 'seyfert';\n\nTransformers.GuildMember\n              // ^|\n```\n\n----------------------------------------\n\nTITLE: Accessing Guild Object with Seyfert\nDESCRIPTION: This snippet illustrates how to access the guild object using the `member.guild()` method. It shows that methods representing Discord objects are an extra layer over the shorters, providing easy access without default caching. Awaits the guild object and inserts the guild name into the message.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/api-access.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent } from 'seyfert';\n\nconst db = new Map<string, string>();\n\nexport default createEvent({\n\tdata: { name: 'guildMemberAdd' },\n\trun: async (member, client) => {\n\t\tconst channelId = db.get(member.guildId);\n\t\tif (!channelId) return;\n\n\t\t// this is a fetch request to cache (force it if you want a direct api fetch)\n\t\tconst guild = await member.guild(); // highlighted line\n\n\t\tawait client.messages.write(channelId, {\n\t\t\tcontent: `Welcome ${member} to ${guild.name} :wave:`, // highlighted line\n\t\t});\n\t},\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing WorkerClient for Sharded Environment\nDESCRIPTION: This code snippet shows how to initialize the WorkerClient in Seyfert for a sharded environment. It creates a new instance of `WorkerClient` and then starts the client. It also includes a module declaration to extend the `seyfert` module with the `UsingClient` interface, which provides type safety for the client within the Seyfert framework.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/sharding.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ParseClient, WorkerClient } from \"seyfert\";\n\nconst client = new WorkerClient();\n\nclient.start();\n\ndeclare module 'seyfert' {\n\tinterface UsingClient extends ParseClient<WorkerClient> {}\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Cache Resource in Seyfert (TypeScript)\nDESCRIPTION: This code snippet shows how to instantiate and integrate a custom cache resource, `CooldownResource`, into the Seyfert client's cache. It declares a module augmentation to extend the `Cache` interface with the custom resource, and extends `UsingClient` interface.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/cache.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Client } from 'seyfert';\nimport { CooldownResource } from './resource'\n\nconst client = new Client();\n\nclient.cache.cooldown = new CooldownResource(client.cache);\n\ndeclare module \"seyfert\" {\n    interface Cache {\n        cooldown: CooldownResource;\n    }\n    interface UsingClient extends ParseClient<Client> {}\n}\n```\n\n----------------------------------------\n\nTITLE: Using Defer Reply in a Prefix Command\nDESCRIPTION: This code shows how to use `ctx.deferReply()` in a prefix command. Coupled with the above configuration, the command's response will be deferred, and the specified message will be shown while the command is being processed. After the processing (crossposting), a final confirmation message is sent.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/commands/prefix-commands.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n    Command,\n    CommandContext,\n    Declare,\n    Options,\n    createStringOption\n} from 'seyfert';\n\nconst options = {\n    id: createStringOption({\n        description: 'The ID of the message we are going to crosspost',\n        required: true\n    })\n};\n\n@Declare({\n    name: 'crosspost',\n    description: 'Crosspost an announcement message.'\n})\n@Options(options)\nexport default class CrosspostCommand extends Command {\n    async run(ctx: CommandContext<typeof options>){\n        await ctx.deferReply();\n        await ctx.client.messages.crosspost(ctx.options.id, ctx.channelId);\n        return ctx.write({ content: 'I have crossposted your announcement.'});\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Dockerfile with Multi-Stage Builds for Seyfert\nDESCRIPTION: This Dockerfile utilizes multi-stage builds to optimize the image size and improve security. It separates the build process into multiple stages, including base setup, OS package installation, dependency management, TypeScript compilation, and production-ready image creation. It uses `npm ci` for clean installs, prunes unnecessary dev dependencies, and sets user permissions for enhanced security.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/using-docker.mdx#_snippet_1\n\nLANGUAGE: Docker\nCODE:\n```\n# [ base ] #\nFROM node:<VERSION_TAG>-alpine AS base\n\nENV DIR /bot\nWORKDIR $DIR\n\n# [ OS packages ] #\nFROM base AS pkg\n\nRUN apk update && apk add --no-cache dumb-init\n\n# [ project builder ] #\nFROM base AS build\n\nCOPY package*.json ./\n\n## Ref: https://docs.npmjs.com/cli/v10/commands/npm-ci\nRUN npm ci\n## Ref: https://docs.npmjs.com/cli/v10/commands/npm-prune\nRUN npm prune --production\n\nRUN npm i -g typescript\n\nCOPY tsconfig.json seyfert.config.mjs ./\nCOPY /src ./src\n\n## Build typescript\nRUN tsc --project tsconfig.json\n\n# [ production ready ] #\nFROM base AS production\n\n# Joining stages\n## Packages\nCOPY --from=pkg /usr/bin/dumb-init /usr/bin/dumb-init\n## Dependencies\nCOPY --from=build $DIR/node_modules ./node_modules\n## Builder\nCOPY --from=build $DIR/dist ./dist\nCOPY --from=build $DIR/package.json ./\nCOPY --from=build $DIR/seyfert.config.js ./\n\n# Environment permissions\nENV NODE_ENV production\n## Remove if your project needs root permissions\nENV USER node\nUSER $USER\n\n# Run the application\nENTRYPOINT [\"dumb-init\", \"node\", \"dist/index.js\"]\n```\n\n----------------------------------------\n\nTITLE: Implementing the `set` method for a custom Seyfert Adapter\nDESCRIPTION: This code snippet demonstrates how to implement the `set` and `bulkSet` methods for a custom Seyfert adapter. The `set` method stores a key-value pair in the adapter's storage, and the `bulkSet` method iterates over an array of key-value pairs and calls `set` for each pair.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/cache.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\ninterface SeyfertDotDev {\n    set(key: string, value: any): Promise<void>;\n}\n// @noErrors\n// ---cut---\nimport { Adapter } from 'seyfert';\n\nclass MyAdapter implements Adapter {\n    // ---cut-start---\n    storage: SeyfertDotDev;\n    // ---cut-end---\n    async set(key: string, value: any | any[]) {\n        await this.storage.set(key, { value });\n    }\n\n    async bulkSet(keys: [string, any][]) {\n        for (let [key, value] of keys) {\n            await this.set(key, value);\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Language File (Spanish)\nDESCRIPTION: This code snippet illustrates the creation of a language file (`languages/es.ts`) that exports a default object containing translations for the Spanish language. It utilizes the `satisfies typeof English` utility type to ensure type safety across languages. The structure mirrors the English language file for consistency.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/i18n/languages.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport type English from \"./en\";\n\nexport default {\n  hello: \"Hola, mundo!\",\n  foo: {\n    bar: \"Puedes anidar objetos para crear un archivo de idioma más complejo\",\n    baz: () => `Puedes usar funciones para pasar variables a la traducción y agregar lógica`,\n    ping: ({ ping }) => `El ping es ${ping}`\n  },\n  qux: [\n    \"También puedes usar arrays para crear una lista de traducciones\",\n    \"Este es el segundo elemento de la lista\"\n  ].join(\"\\n\")\n} satisfies typeof English; // This is a utility type to ensure that object is the same across languages\n```\n\n----------------------------------------\n\nTITLE: Handling Option Validation Errors with onOptionsError (TypeScript)\nDESCRIPTION: This snippet shows how to handle errors that occur during option validation in a Seyfert command. The `value` method of an option can `fail` which triggers `onOptionsError`. It utilizes the `onOptionsError` method to catch these errors, format them, and display them to the user. `onOptionsError` recieves both the `CommandContext` and option metadata, which allows access to which options failed.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/commands/handling-errors.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// @exactOptionalPropertyTypes: false\nimport {\n  Command,\n  createStringOption,\n  Options,\n  type CommandContext,\n  type OnOptionsReturnObject,\n  type OKFunction\n} from \"seyfert\";\nconst isURL: ((url: string) => boolean) = () => false;\n// ---cut---\nconst options = {\n  url: createStringOption({\n    description: 'cómo ser un gamer',\n    value(data, ok: OKFunction<URL>, fail) {\n        if (isURL(data.value)) return ok(new URL(data.value));\n\n// @annotate: Esto activará el método onOptionsError\n        fail('se esperaba una URL válida');\n    },\n  })\n};\n\n@Options(options)\nexport class HandlingErrors extends Command {\n    async onOptionsError(\n        context: CommandContext,\n        metadata: OnOptionsReturnObject\n    ) {\n// @log: url: se esperaba una URL válida\n    await context.editOrReply({\n      content: Object.entries(metadata)\n        .filter((_) => _[1].failed)\n        .map((error) => `${error[0]}: ${error[1].value}`)\n        .join(\"\\n\")\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating an English Translation File (TypeScript)\nDESCRIPTION: This code snippet shows how to create a translation file (`languages/en.ts`) with an object containing key-value pairs representing translations. It demonstrates nesting objects and using functions to pass variables to translations.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/i18n/languages.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport default {\n  hello: \"Each key value pair will be the translation for the key\",\n  foo: {\n    bar: \"You may nest objects to create a more complex language file\",\n    baz: () => `You may also use functions to pass variables to the translation and add some logic`,\n    ping: ({ ping }: { ping: number }) => `The ping is ${ping}`\n  },\n  qux: [\n    \"You may also use arrays to create a list of translations\",\n    \"This is the second item in the list\"\n  ].join(\"\\n\")\n}\n```\n\n----------------------------------------\n\nTITLE: Extending CommandContext with extendContext in Seyfert (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to extend the `CommandContext` in Seyfert using the `extendContext` function. It defines a custom property `myCoolProp` that will be added to the context. Dependencies: Requires Seyfert library. Input: interaction object. Output: An object containing the custom data to be added to the context.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/commands/extend-commandcontext.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Client, extendContext } from 'seyfert';\n\nconst context = extendContext((interaction) => {\n  // Here you can add\n\n  return {\n    myCoolProp: 'seyfert>>'\n  };\n});\n\nconst client = new Client({ context });\n```\n\n----------------------------------------\n\nTITLE: Registering Global Middlewares in Seyfert (TypeScript)\nDESCRIPTION: This code shows how to declare and register global middlewares in Seyfert. Global middlewares are applied to all commands. The code initializes the client with `globalMiddlewares` option, registers middleware services and updates type definitions to reflect the global middlewares.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/commands/middlewares.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  Client,\n  type ParseMiddlewares,\n  type ParseClient,\n  type ParseGlobalMiddlewares\n} from 'seyfert';\nimport { middlewares } from \"./path/to/middlewares\";\nimport { global } from \"./path/to/globals\";\n\nconst globalMiddlewares: (keyof typeof global)[] = ['logger']\n\n// Register middleware\nconst client = new Client({\n  globalMiddlewares\n});\n\nclient.setServices({\n  middlewares: { ...global, ...middlewares },\n});\n\ndeclare module 'seyfert' {\n  interface RegisteredMiddlewares\n    extends ParseMiddlewares<typeof middlewares & typeof global> {}\n  interface GlobalMetadata\n    extends ParseGlobalMiddlewares<typeof global> {}\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Event Locations in seyfert.config.mjs (Typescript)\nDESCRIPTION: This code snippet demonstrates how to configure the event locations in the `seyfert.config.mjs` file. It imports the `config` function from the 'seyfert' package and uses it to define the bot's configuration, including the token, intents, and locations for commands and events.  The `events` property specifies the directory where event files are located.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/getting-started/listening-events.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { config } from 'seyfert';\n\nexport default config.bot({\n    token: process.env.BOT_TOKEN ?? '',\n    intents: ['Guilds'],\n    locations: {\n        base: 'dist',\n        commands: 'commands',\n        events: 'events' // - src/events will be our folder for events\n    }\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing keys, values, count, contains Methods (TypeScript)\nDESCRIPTION: This snippet demonstrates how to implement `keys`, `values`, `count`, and `contains` methods in a Seyfert adapter. The `keys` method retrieves keys related to a specified 'to' value, appending the 'to' value to each key. The `values` method retrieves content associated with those keys.  The `count` method gets the length of relationships associated with the provided 'to' value. The `contains` method checks if the 'to' value includes a specific key.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/cache.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\ninterface SeyfertDotDev {\n    setGet(key: string): Promise<string[] | undefined>;\n}\n\nimport { Adapter } from 'seyfert';\n\nclass MiAdaptador implements Adapter {\n    almacenamiento: SeyfertDotDev;\n    get(key: string): Promise<any>\n    async getToRelationship(to: string) {\n        return await this.almacenamiento.setGet(to) ?? []\n    }\n\n    async keys(to: string) {\n        const keys = await this.almacenamiento.setGet(to) ?? [];\n        return keys.map(key => `${to}.${key}`);\n    }\n\n    async values(to: string) {\n        const array: any[] = [];\n        const keys = await this.keys(to);\n\n        for (const key of keys) {\n            const content = await this.get(key);\n\n            if (content) {\n                array.push(content);\n            }\n        }\n\n        return array;\n    }\n\n    async count(to: string) {\n        return (await this.getToRelationship(to)).length;\n    }\n\n    async contains(to: string, key: string) {\n        return (await this.getToRelationship(to)).includes(key);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing WorkerManager for Thread-Based Sharding\nDESCRIPTION: This code snippet demonstrates how to initialize the WorkerManager in Seyfert to utilize threads for sharding. It sets the `mode` to `threads`, specifies the path to the client file, and initiates the worker management process. This configuration enables the spawning of clients within the processor's threads for parallel execution.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/sharding.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { WorkerManager } from 'seyfert';\n\nconst manager = new WorkerManager({\n\tmode: \"threads\",\n\t// ./src/client.ts para bun y deno (?\n\tpath: \"./dist/client.js\",\n\t// puedes sobrescribir muchas opciones, como el número de workers y la cantidad de shards en cada worker\n});\n\nmanager.start();\n```\n\n----------------------------------------\n\nTITLE: Declare Module for Prefix Command Handling in Seyfert (TS)\nDESCRIPTION: This code snippet demonstrates how to declare a module augmentation to enable prefix command handling in Seyfert.  It sets the `withPrefix` property within `InternalOptions` to `true`. This allows the `Message` property to be populated within the `CommandContext` when a prefix command is executed.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/commands/prefix-commands.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare module 'seyfert' {\n    interface InternalOptions {\n        withPrefix: true;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Extending Seyfert RC Interface\nDESCRIPTION: Extends the 'seyfert' module's 'ExtendedRC' interface to add a custom 'prefix' property of type string. This allows adding custom configuration properties to the Seyfert configuration object. It uses declaration merging to add the new property.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/extending-config.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare module 'seyfert' {\n    interface ExtendedRC {\n        prefix: string;\n        // even more properties\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Transformers Implementation (TypeScript)\nDESCRIPTION: Demonstrates how to use Transformers in Seyfert to modify Discord data. This involves defining a custom class (e.g., `MyPoll`), and assigning it to the corresponding transformer (e.g., `Transformers.Poll`).  Also, a module augmentation is done to allow custom structures.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/changelog.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Transformers } from 'seyfert';\nconst storage = new Map();\nclass MyPoll extends Poll {\n    storage() {\n        return storage.set(this.id, this);\n    }\n}\n\nTransformers.Poll = (...args: ConstructorParameters<typeof MyPoll>) => new MyPoll(...args);\n\ndeclare module 'seyfert' {\n    interface CustomStructures {\n        Poll: MyPoll;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Extending Client Interface with readyAt - TypeScript\nDESCRIPTION: This code snippet demonstrates how to extend the `UsingClient` interface in a Seyfert bot to include a `readyAt` property of type `Date`. This allows tracking when the bot became ready and ensures type-checking across the project. It requires the `seyfert` module.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/tips-misc/uptime.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { ParseClient, Client } from 'seyfert';\n// ---cut---\ndeclare module \"seyfert\" {\n  interface UsingClient extends ParseClient<Client<true>> {\n    // Other custom properties...\n    readyAt?: Date; // Tracks when the bot became ready (uptime)\n  }\n\n  // Other declarations...\n}\n```\n\n----------------------------------------\n\nTITLE: Extending Seyfert Client Types (HTTP)\nDESCRIPTION: This code snippet demonstrates how to inform TypeScript about the specific client type being used in your Seyfert project when using the HTTP client. It extends the 'seyfert' module with an interface that defines the client type.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/getting-started/declare-module.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { ParseClient, Client, HttpClient, WorkerClient } from 'seyfert';\n\ndeclare module 'seyfert' {\n\n    interface UsingClient extends ParseClient<HttpClient> { }\n  \n}\n```\n\n----------------------------------------\n\nTITLE: src/index.ts (HTTP Bot)\nDESCRIPTION: This snippet initializes and starts a Seyfert HTTP bot. It creates a new `HttpClient` instance, an adapter (UwsAdapter in this case), and calls the `start` method on both the client and adapter to start listening for HTTP interactions. UwsAdapter must be installed as a dependency.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/getting-started/setup-project.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// @exactOptionalPropertyTypes: false\n// @errors: 2379 2345\nimport { HttpClient } from \"seyfert\";\nimport { UwsAdapter } from \"@slipher/uws-adapter\";\n// import { GenericAdapter } from \"@slipher/generic-adapter\";\n\nconst client = new HttpClient();\n\nconst adapter = new UwsAdapter(client); // You can also pass a `Client` or `WorkerClient`.\n\n// This will start listening at `https://yourweb.xyz/interactions` and load commands, components, and language (i18n)\nclient.start();\nadapter.start();\n```\n\n----------------------------------------\n\nTITLE: Updating Module Declaration for Language Support\nDESCRIPTION: This code snippet shows how to update the `declare module` in the `src/index.ts` file to enable language support. It imports the English language type and defines `UsingClient` and `DefaultLocale` interfaces that extend `ParseClient` and `ParseLocales`, respectively, from the 'seyfert' module.  These interfaces provide type checking and autocompletion when working with translations.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/i18n/languages.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport type English from './languages/en';\nimport { Client, type ParseClient, type ParseLocales } from \"seyfert\";\n\nconst client = new Client();\n\nclient.start();\n\ndeclare module 'seyfert' {\n  interface UsingClient extends ParseClient<Client<true>> { }\n  // interface UsingClient extends ParseClient<HttpClient> { } // If you are using the rest api\n\n  interface DefaultLocale extends ParseLocales<typeof English> { }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Entitlement Update Event in Seyfert\nDESCRIPTION: This code snippet illustrates how to handle the `entitlementUpdate` event using Seyfert. It fetches user information upon subscription renewal and logs a message to a specific channel, indicating which user renewed their subscription to a particular product (SKU).\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/monetization.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent } from 'seyfert';\n//---cut---\nexport default createEvent({\n    data: { name: 'entitlementUpdate' },\n    run: async (entitlement, client) => {\n        if (!entitlement.userId) return;\n        const subscribedUser = await client.users.fetch(entitlement.userId);\n        client.messages.write('LOG_CHANNEL_ID', {\n            content: `Subscription (${entitlement.skuId}) renewed by ${subscribedUser.globalName}`,\n        });\n    },\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing readyAt in Ready Event - TypeScript\nDESCRIPTION: This snippet shows how to initialize the `readyAt` property on the client when the bot is ready within the `botReady` event handler. It sets `client.readyAt` to the current date and time using `new Date()`. This provides the exact moment the bot becomes ready. It assumes the `UsingClient` interface has already been extended.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/tips-misc/uptime.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { ParseClient, Client } from 'seyfert';\ndeclare module 'seyfert' {\n  interface UsingClient extends ParseClient<Client<true>> {\n    readyAt?: Date\n  }\n}\n// ---cut---\nimport { createEvent } from \"seyfert\";\n\nexport default createEvent({\n  data: { once: true, name: \"botReady\" },\n  run(user, client) {\n    // Set the readyAt to the current date and time\n    client.readyAt = new Date();\n\n    // Other startup logic...\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Handling the onStop Event in Seyfert Collector\nDESCRIPTION: This snippet demonstrates how to handle the `onStop` event of a component collector. The `onStop` option is passed when creating the collector, and it expects a function that takes a `reason` (string) and a `refresh` (function) as parameters.  The example uses an `idle` timeout and refreshes the collector if the reason for stopping is 'idle'.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/components/collectors.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  Button,\n  ActionRow,\n  Command,\n  Declare,\n  type CommandContext,\n} from 'seyfert';\n\nimport { ButtonStyle } from 'seyfert/lib/types';\n\n@Declare({\n  name: 'hello',\n  description: 'I will send you a hello world message',\n})\nexport default class HelloWorldCommand extends Command {\n  async run(ctx: CommandContext) {\n    const button = new Button()\n      .setCustomId('hello')\n      .setLabel('Hello')\n      .setStyle(ButtonStyle.Primary);\n\n    const row = new ActionRow<Button>().setComponents([button]);\n\n    const message = await ctx.write(\n      {\n        content: 'Do you want a hello world? Click the button below.',\n        components: [row],\n      },\n      true\n    );\n\n    const collector = message.createComponentCollector({\n      filter: (i) => i.user.id === ctx.author.id && i.isButton(),\n      onStop(reason, refresh) {\n        //this will refresh the collector everytime it stops by timeout\n        if (reason === 'idle') return refresh();\n      },\n      idle: 1e3, //1000ms\n    });\n\n    collector.run('hello', async (i) => {\n      return i.write({ content: 'Hello World 👋' });\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Extending Seyfert Locations\nDESCRIPTION: This code snippet demonstrates how to extend the object of locations (folders) in Seyfert by extending the 'seyfert' module with the `ExtendedRCLocations` interface.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/getting-started/declare-module.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport 'seyfert';\n// ---cut---\ndeclare module 'seyfert' {\n    interface ExtendedRCLocations {\n        models: string;\n        // más propiedades aquí...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Relationship Removal Methods (TypeScript)\nDESCRIPTION: This snippet presents the implementation of `removeToRelationship` and `removeRelationship` methods for managing relationships in a Seyfert adapter. `removeToRelationship` removes an entire 'to' relationship set. `removeRelationship` removes specific IDs from a 'to' relationship set, handling both single and multiple IDs.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/cache.md#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\ninterface SeyfertDotDev {\n    setRemove(key: string): Promise<void>;\n    setPull(to: string, key: string[]): Promise<void>\n}\n\nimport { Adapter } from 'seyfert';\n\nclass MiAdaptador implements Adapter {\n    almacenamiento: SeyfertDotDev;\n    async removeToRelationship(to: string) {\n        // Eliminar el \"Set\" completamente\n        await this.almacenamiento.setRemove(to);\n    }\n\n    async removeRelationship(to: string, key: string | string[]) {\n        // Eliminar el/los ID(s) del \"Set\"\n        const keys = Array.isArray(key) ? key : [key];\n        await this.almacenamiento.setPull(to, keys);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Client with Presence - Typescript\nDESCRIPTION: This code demonstrates how to initialize a Seyfert client with a custom presence. It sets the bot's status to 'idle' and defines an activity of 'Watching your servers'. It imports necessary modules from the 'seyfert' library to define the activity type and status.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/tips-misc/presence.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Client } from \"seyfert\";\nimport { ActivityType, PresenceUpdateStatus } from 'seyfert/lib/types';\n\nconst client = new Client({\n    presence: (shardId) => ({\n        status: PresenceUpdateStatus.Idle,\n        activities: [{\n            name: \"your servers\",\n            type: ActivityType.Watching,\n        }],\n        since: Date.now(),\n        afk: false,\n    })\n});\n```\n\n----------------------------------------\n\nTITLE: Dynamically Updating Presence - Typescript\nDESCRIPTION: This code defines a Seyfert command that allows users to dynamically update the bot's presence. The command, named 'presence', uses the 'setPresence' method to change the bot's activity to 'Playing with Seyfert' and its status to 'Online'. The command then sends a confirmation message to the user.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/tips-misc/presence.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { ParseClient, Client } from 'seyfert';\ndeclare module 'seyfert' {\n  interface UsingClient extends ParseClient<Client<true>> {}\n}\n// ---cut---\nimport { Command, Declare, GuildCommandContext } from \"seyfert\";\nimport { ActivityType, PresenceUpdateStatus } from 'seyfert/lib/types';\n\n@Declare({\n    name: 'presence',\n    description: 'Change bot presence'\n})\nexport default class PresenceCommand extends Command {\n    async run(ctx: GuildCommandContext) {\n        ctx.client.gateway.setPresence({\n            activities: [{\n                name: \"with Seyfert\",\n                type: ActivityType.Playing,\n            }],\n            status: PresenceUpdateStatus.Online,\n            since: Date.now(),\n            afk: false\n        });\n\n        await ctx.editOrReply({ content: 'Switched Presence' });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Shorters for Message Sending in Seyfert\nDESCRIPTION: This code demonstrates how to use Shorters to send a welcome message to a channel using its ID, avoiding the need to fetch the channel object and saving resources. It fetches the channel ID from a database and uses the `client.messages.write` method to send the message.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/api-access.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent } from 'seyfert';\n\nconst db = new Map<string, string>();\n\nexport default createEvent({\n  data: { name: 'guildMemberAdd' },\n  run: async (member, client) => {\n    const channelId = db.get(member.guildId);\n    if (!channelId) {\n      return;\n    }\n\n    await client.messages.write(channelId, {\n      content: `Welcome ${member} :wave:`, // This line is inserted\n    });\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Ignoring Slash Command for Prefix Command in Seyfert (TS)\nDESCRIPTION: This snippet illustrates how to configure a Seyfert command to ignore slash command execution, ensuring it only responds to prefix commands.  The `ignore` property is set to `IgnoreCommand.Slash` in the `@Declare` decorator.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/commands/prefix-commands.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n    Command,\n    CommandContext,\n    Declare,\n    IgnoreCommand\n} from 'seyfert';\n\n@Declare({\n    name: 'crosspost',\n    description: 'Republicar un mensaje de anuncio.',\n    ignore: IgnoreCommand.Slash\n})\nexport default class CrosspostCommand extends Command {\n    async run(ctx: CommandContext){\n        if(ctx.message) await ctx.message.crosspost();\n        return ctx.write({ content: 'He republicado tu anuncio.'});\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing HTTP Client in src/index.ts\nDESCRIPTION: This code snippet demonstrates how to initialize and start a Seyfert HTTP client in the `src/index.ts` file.  It creates a new `HttpClient` instance, uses a UwsAdapter, and then calls `start()` on both the client and the adapter to start listening for interactions.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/getting-started/setup-project.mdx#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\n// @exactOptionalPropertyTypes: false\n// @errors: 2345\nimport { HttpClient } from \"seyfert\";\nimport { UwsAdapter } from \"@slipher/uws-adapter\";\n// import { GenericAdapter } from \"@slipher/generic-adapter\";\n\nconst client = new HttpClient();\n\nconst adapter = new UwsAdapter(client); // También puedes pasar un `Client` o `WorkerClient`.\n\n// Esto empezará a escuchar `https://yourweb.xyz/interactions` y cargará comandos, componentes e idioma (i18n)\nclient.start();\nadapter.start();\n```\n\n----------------------------------------\n\nTITLE: Implementing Scan Method in Seyfert Adapter (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to implement the `scan` method in a Seyfert adapter. The `scan` method searches the storage for keys that match a given query pattern, using '*' as a wildcard. It iterates through the storage entries, splits the key into segments, and checks if each segment matches the corresponding segment in the query. The function returns an array of values or keys based on the `keys` parameter.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/cache.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\ninterface SeyfertDotDev {\n    entries(): Promise<[string, unknown][]>;\n}\n\nimport { Adapter } from 'seyfert';\n\nclass MiAdaptador implements Adapter {\n    almacenamiento: SeyfertDotDev;\n    async scan(query: string, keys?: false): any[];\n    async scan(query: string, keys: true): string[];\n    async scan(query: string, keys = false) {\n        const values: (string | unknown)[] = [];\n        const sq = query.split('.');\n        // Tu cliente probablemente tendrá una forma más optimizada de hacer esto.\n        // Como nuestro adaptador de Redis.\n        for (const [key, value] of await this.almacenamiento.entries()) {\n            const match = key.split('.')\n                .every((value, i) => (sq[i] === '*' ? !!value : sq[i] === value));\n            if (match) {\n                values.push(keys ? key : value);\n            }\n        }\n\n        return values;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Bot as \"Mobile\" - Typescript\nDESCRIPTION: This snippet shows how to configure the Seyfert client's gateway properties to emulate a mobile device, causing the bot to appear with a mobile icon. It sets the 'os', 'browser', and 'device' properties within the 'gateway.properties' configuration to 'android' or 'Discord Android'. The code also defines a custom presence.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/tips-misc/presence.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Client } from \"seyfert\";\nimport { ActivityType, GatewayPresenceUpdateData, PresenceUpdateStatus } from 'seyfert/lib/types';\n// ---cut---\nconst client = new Client({\n    gateway: {\n        properties: {\n            os: 'android',\n            browser: 'Discord Android',\n            device: 'android'\n        }\n    },\n    presence: (shardId) => ({\n        status: PresenceUpdateStatus.Idle,\n        activities: [{\n            name: \"your servers\",\n            type: ActivityType.Watching,\n        }],\n        since: Date.now(),\n        afk: false,\n    })\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Event with createEvent (TypeScript)\nDESCRIPTION: This snippet creates a custom event named 'ourEvent' using the `createEvent` function from Seyfert.  It configures the event's metadata (name and whether it's a one-time event) and defines the `run` function, which logs the received text to the console.  The event data specifies `name: \"ourEvent\"` and `once: false`.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/custom-events.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent } from 'seyfert';\n\nexport default createEvent({\n\tdata: { name: \"ourEvent\", once: false },\n\trun: (text) => {\n\t\tconsole.log(text);\n\t}\n});\n```\n\n----------------------------------------\n\nTITLE: Using the Custom Seyfert User Transformer in a Command (Typescript)\nDESCRIPTION: This code demonstrates how to use the custom User transformer within a Seyfert command.  The `ctx.author` is implicitly transformed into your `MyUser` type. The example shows how to access the `raw()` method defined in the transformer and log the user's ID and username.  Requires the custom User transformer to be defined as shown in the first code snippet.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/transformers.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { APIUser } from 'seyfert/lib/types';\n\ninterface MyUser {\n    username: string;\n    esAdmin: boolean;\n    raw(): Promise<APIUser>;\n}\n\ndeclare module \"seyfert\" {\n    interface CustomStructures {\n        User: MyUser;\n    }\n}\n//---cut---\nimport { type CommandContext, Command, Declare } from 'seyfert';\n\n@Declare({\n    name: 'ping',\n    description: 'Ping!',\n})\nclass Ping extends Command {\n    async run(ctx: CommandContext) {\n        const result = await ctx.author.raw();\n                                     // ^|\n        console.log(result.id, result.username);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Create Event Handler for Poll Vote Add in Seyfert\nDESCRIPTION: This TypeScript code snippet creates an event handler for the `messagePollVoteAdd` event. It uses the `createEvent` function from the `seyfert` library to define an event that logs a message when a user adds a vote to a poll.  The `data` property specifies the event name, and the `run` property defines the function to execute when the event is triggered. The function receives an object `data` containing the `userId` and `messageId`.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/components/polls.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent } from 'seyfert';\n\nexport default createEvent({\n    data: { name: 'messagePollVoteAdd' },\n    run: (data) => {\n        // Puedes hacer lo que quieras con los datos\n        console.log(`The user: ${data.userId} added a vote to the poll: ${data.messageId}`);\n    },\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Default Locale (TypeScript)\nDESCRIPTION: This code demonstrates setting a default locale for the bot. This prevents `undefined` values when retrieving translations if a specific locale is not provided. The `setServices` method is used to configure the `langs` service with a `default` locale.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/i18n/languages.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Client } from \"seyfert\";\nconst client = new Client();\n// ---cut--- snoopy\nclient.setServices({ langs: { default: 'en-US' } });\n```\n\n----------------------------------------\n\nTITLE: Creating Number Options with Seyfert\nDESCRIPTION: This code snippet demonstrates how to create a number option for a Discord command using the Seyfert library. It shows a basic example of using `createNumberOption` for defining a numeric option that accepts decimal values. The `@Options` decorator is used to associate the option with the `Ping` command class.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/commands/options.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// @exactOptionalPropertyTypes: false\nimport { Options, createNumberOption, Command } from 'seyfert';\n\n@Options({\n    normal: createNumberOption({\n        description: '',\n    }),\n   \n    // Aplica lo mismo que el anterior (integer/enteros), pero para todos los números incluyendo decimales\n})\nclass Ping extends Command {}\n```\n\n----------------------------------------\n\nTITLE: Extending Seyfert Command Properties\nDESCRIPTION: This code snippet shows how to add extra properties to Seyfert commands by extending the 'seyfert' module with the `ExtraProps` interface. This enables categorizing commands or adding identifiers.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/getting-started/declare-module.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n// @errors: 2741 2322\nimport { Client, Declare, Command } from 'seyfert';\n// ---cut---\nconst client = new Client({\n    commands: {\n        defaults: {\n            props: {\n                categoria: 'none'\n            }\n        }\n    }\n});\n\n@Declare({\n    name: 'test',\n    description: 'comando de prueba',\n    props: {}\n})\nclass Test extends Command {}\n\ndeclare module 'seyfert' {\n    interface ExtraProps {\n        soloParaAdmins: boolean;\n        deshabilitado?: true;\n        categoria?: string\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Dockerfile for TypeScript Project\nDESCRIPTION: This Dockerfile sets up a basic container for a TypeScript Seyfert project. It copies the necessary files, installs dependencies, compiles the TypeScript code, and sets the entry point to run the application in production mode.  It uses a specific Node.js version defined by `<VERSION_TAG>` which needs to be replaced with an actual version tag, and installs dependencies in production mode to reduce image size.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/using-docker.mdx#_snippet_0\n\nLANGUAGE: Docker\nCODE:\n```\nFROM node:<VERSION_TAG>\n\nWORKDIR /bot\n\nCOPY package*.json ./\n\nRUN npm install --production\n\nRUN npm i -g typescript\n\nCOPY tsconfig.json seyfert.config.mjs ./\nCOPY /src ./src\n\n# Build typescript files\nRUN tsc --project tsconfig.json\n\nENV NODE_ENV=production\n\nENTRYPOINT [\"node\", \"dist/index.js\"]\n```\n\n----------------------------------------\n\nTITLE: Traducción de comandos con @LocalesT en Seyfert (TypeScript)\nDESCRIPTION: This code demonstrates how to use the `@LocalesT` decorator in Seyfert for command localization. It defines a locale object and extends the `DefaultLocale` interface through module augmentation.  The `@LocalesT` decorator then specifies which locale keys to use for the command's name and description.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/commands/intro.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { ParseLocales } from 'seyfert';\nconst lang = {\n    'mi-comando': {\n        nombre: '',\n        description: '',\n    },\n};\ndeclare module 'seyfert' {\n    interface DefaultLocale extends ParseLocales<typeof lang> {}\n}\n// ---cut---\nimport { Command, LocalesT } from 'seyfert';\n\n@LocalesT('mi-comando.nombre', 'mi-comando.description')\n//                   ^|\nclass MiComando extends Command {}\n\n```\n\n----------------------------------------\n\nTITLE: Initializing WorkerClient for Sharding in Seyfert\nDESCRIPTION: This code snippet shows how to initialize the WorkerClient in Seyfert. It creates a new WorkerClient instance and calls the `start()` method to start the client. It also declares a module augmentation for the `UsingClient` interface.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/sharding.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ParseClient, WorkerClient } from \"seyfert\";\n\nconst client = new WorkerClient();\n\nclient.start();\n\ndeclare module 'seyfert' {\n\tinterface UsingClient extends ParseClient<WorkerClient> {}\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Component Collector in Seyfert\nDESCRIPTION: This code snippet demonstrates how to create a component collector after sending a message with a button attached. It sets up a button, adds it to an action row, sends the message, and then creates the collector using `createComponentCollector`.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/components/collectors.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  Button,\n  ActionRow,\n  Command,\n  Declare,\n  type CommandContext,\n} from 'seyfert';\n\nimport { ButtonStyle } from 'seyfert/lib/types';\n\n@Declare({\n  name: 'hello',\n  description: 'I will send you a hello world message',\n})\nexport default class HelloWorldCommand extends Command {\n  async run(ctx: CommandContext) {\n    const button = new Button()\n      .setCustomId('hello')\n      .setLabel('Hello')\n      .setStyle(ButtonStyle.Primary);\n\n    const row = new ActionRow<Button>().setComponents([button]);\n\n    // Para obtener el mensaje al que se le adjunta un botón, puedes configurar la fetchReply en \"true\".\n    const message = await ctx.write(\n      {\n        content: 'Do you want a hello world? Click the button below.',\n        components: [row],\n      },\n      true\n    );\n\n    const collector = message.createComponentCollector();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Thread via Proxy in Seyfert\nDESCRIPTION: This snippet demonstrates using the Seyfert Proxy to create a new thread directly via the Discord API. It assumes the `channel.thread` method does not exist and constructs the API call using the `client.proxy` object. The code posts a new thread with a name and initial message, providing a reason for the action.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/api-access.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent } from 'seyfert';\n\nexport default createEvent({\n  data: { name: 'channelCreate' },\n  run: async (channel, client) => {\n    if (!channel.isThreadOnly()) return;\n\n    // assuming that channel.thread method does not exist\n    // the \"object\" will follow the same structure as the discord endpoints have\n    await client.proxy.channels(channel.id).threads.post({\n      body: {\n        name: 'First thread!',\n        message: {\n          content: 'Seyfert >',\n        },\n      },\n      reason: \"I'm always the first\",\n    });\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Extending Seyfert Configuration (TypeScript)\nDESCRIPTION: This snippet demonstrates how to add more properties to the `seyfert.config.mjs` configuration file using `ExtendedRC`. It declares an `ExtendedRC` interface within the `seyfert` module, allowing you to define custom properties for the configuration, regardless of whether using HTTP or bot configurations.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/getting-started/declare-module.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport 'seyfert';\n//---cut---\ndeclare module 'seyfert' {\n    interface ExtendedRC {\n        developers: string[];\n        // more properties here...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Extending Seyfert with Middlewares (TypeScript)\nDESCRIPTION: This snippet demonstrates how to inform TypeScript about the structure and composition of your middlewares. It imports all middlewares from a specified file and uses interface merging to add a `RegisteredMiddlewares` interface to the 'seyfert' module, which inherits from `ParseMiddlewares` parameterized by the imported middlewares. This allows the middlewares to be used throughout the project with proper type checking.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/getting-started/declare-module.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Assuming you exported all middlewares from './middlewares';\nimport type * as allMiddlewares from './middlewares';\n\ndeclare module 'seyfert' {\n    interface RegisteredMiddlewares extends ParseMiddlewares<typeof allMiddlewares> {}\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Handle Command Service (TypeScript)\nDESCRIPTION: Shows how to override the default `HandleCommand` service in Seyfert to use a custom arguments parser. This involves extending the `HandleCommand` class and setting a custom `argsParser` property within the `setServices` method of the client.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/changelog.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { HandleCommand } from 'seyfert'\n\nclient.setServices({ handleCommand: class extends HandleCommand { argsParser = yourParser() } })\n```\n\n----------------------------------------\n\nTITLE: Role Option in Seyfert (TS)\nDESCRIPTION: Illustrates creating a role option using the Seyfert library. This allows users to specify a Discord role in a command. The `required` property is set to true, so the user must specify a role when using the command.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/commands/options.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n// @exactOptionalPropertyTypes: false\nimport { Options, createRoleOption, Command } from 'seyfert';\n\n@Options({\n    role: createRoleOption({\n        description: 'This is a role option',\n        required: true\n    })\n})\nclass Ping extends Command {}\n```\n\n----------------------------------------\n\nTITLE: Seyfert Bot Configuration\nDESCRIPTION: This code shows the base configuration of the Seyfert bot, setting the locations for base and commands, and the bot token. It utilizes the `config.bot` method from the `seyfert` package and retrieves the token from environment variables.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/extending-config.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { config } from \"seyfert\";\n\nexport default config.bot({\n\tlocations: {\n\t\tbase: \"dist\",\n\t\tcommands: \"commands\",\n\t},\n\ttoken: process.env.TOKEN!,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Seyfert Event for Removing Votes\nDESCRIPTION: This code snippet demonstrates how to create an event in Seyfert that listens for `messagePollVoteRemove` events. When a user removes a vote from a poll, this event is triggered, and the provided example logs the user ID and message ID to the console. It mirrors the vote addition event structure but handles vote removal.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/components/polls.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent } from 'seyfert';\n\nexport default createEvent({\n    data: { name: 'messagePollVoteRemove' },\n    run: (data) => {\n        // You can do whatever you want with the data\n        console.log(`The user: ${data.userId} removed a vote from the poll: ${data.messageId}`);\n    },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Mentionable Options with Seyfert\nDESCRIPTION: This code demonstrates creating a mentionable option for a Discord command using Seyfert.  It shows how to define a mentionable option using `createMentionableOption`, specifying a description and setting it as required.  The `@Options` decorator is used to link this option to the `Ping` command class.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/commands/options.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n// @exactOptionalPropertyTypes: false\nimport { Options, createMentionableOption, Command } from 'seyfert';\n\n@Options({\n    mentionable: createMentionableOption({\n        description: 'This is a mentionable option',\n        required: true\n    })\n})\nclass Ping extends Command {}\n```\n\n----------------------------------------\n\nTITLE: Creating Cooldown Middleware (TypeScript)\nDESCRIPTION: This TypeScript code creates a middleware to check if a user is in cooldown. It uses the `CooldownManager` to determine if a cooldown is active for the command context. If the user is in cooldown, it stops the command execution and sends an error message with the remaining cooldown time.  The middleware uses declaration merging to define the client's cooldown property.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/cooldown.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { CooldownManager } from \"@slipher/cooldown\";\n\ndeclare module \"seyfert\" {\n\tinterface UsingClient {\n\t\tcooldown: CooldownManager;\n\t}\n}\n// ---cut---\nimport { createMiddleware, Formatter } from 'seyfert';\nimport { TimestampStyle } from 'seyfert/lib/common';\n\nexport default createMiddleware<void>(async ({ context, next, stop }) => {\n\tconst inCooldown = context.client.cooldown.context(context);\n\n\ttypeof inCooldown === 'number'\n\t\t? stop(\n\t\t\t\t`Estás en tiempo de reutilización, inténtalo de nuevo ${Formatter.timestamp(new Date(Date.now() + inCooldown), TimestampStyle.RelativeTime)}`,\n\t\t\t)\n\t\t: next();\n});\n```\n\n----------------------------------------\n\nTITLE: Configure Gateway Intents for Polls in Seyfert\nDESCRIPTION: This code snippet demonstrates how to configure the gateway intents in your `seyfert.config.mjs` file to receive poll-related events.  It adds `GuildMessagePolls` and `DirectMessagePolls` to the `intents` array to enable the bot to receive poll events.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/components/polls.mdx#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nexport default config.bot({\n   //... otras opciones\n   intents: ['GuildMessagePolls', 'DirectMessagePolls'],\n});\n```\n\n----------------------------------------\n\nTITLE: Attachment Option in Seyfert (TS)\nDESCRIPTION: Demonstrates creating an attachment option for a Seyfert command, enabling users to upload files. The `required` property is set to true, so the user must include an attachment when using the command.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/commands/options.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n// @exactOptionalPropertyTypes: false\nimport { Options, createAttachmentOption, Command } from 'seyfert';\n\n@Options({\n    attachment: createAttachmentOption({\n        description: 'This is an attachment option',\n        required: true\n    })\n})\nclass Ping extends Command {}\n```\n\n----------------------------------------\n\nTITLE: Extending Seyfert Default Locale Type\nDESCRIPTION: This code snippet illustrates how to configure types for languages in Seyfert by extending the 'seyfert' module with the `DefaultLocale` interface. It assumes you have a base language file and that all types will be derived from this.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/getting-started/declare-module.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// Suponiendo que tu lenguaje base (principal) está en './langs/en';\nimport type * as defaultLang from './langs/en';\n\ndeclare module 'seyfert' {\n    interface DefaultLocale extends ParseLocales<typeof defaultLang> {}\n}\n```\n\n----------------------------------------\n\nTITLE: Ignoring a Command Type in Seyfert\nDESCRIPTION: This code demonstrates how to ignore a specific type of command (e.g., slash command) for a given command. The `IgnoreCommand.Slash` value is used within the `Declare` decorator to indicate that this command should not be registered as a slash command, but it can still be triggered as a prefix command.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/commands/prefix-commands.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n    Command,\n    CommandContext,\n    Declare,\n    IgnoreCommand\n} from 'seyfert';\n\n@Declare({\n    name: 'crosspost',\n    description: 'Crosspost an announcement message.',\n    ignore: IgnoreCommand.Slash\n})\nexport default class CrosspostCommand extends Command {\n    async run(ctx: CommandContext){\n        if(ctx.message) await ctx.message.crosspost();\n        return ctx.write({ content: 'I have crossposted your announcement.'});\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Extending Seyfert RC Locations Interface\nDESCRIPTION: Extends the 'seyfert' module's 'ExtendedRCLocations' interface to add a custom 'music' location of type string. This demonstrates how to extend the locations configuration within the Seyfert configuration object.  It uses declaration merging to add the new location.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/extending-config.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare module 'seyfert' {\n    interface ExtendedRCLocations {\n        music: string;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing `patch` and `bulkPatch` Methods in Custom Cache Adapter (TypeScript)\nDESCRIPTION: This code implements the `patch` and `bulkPatch` methods for a custom cache adapter. The `patch` method updates an existing value with new properties, and the `bulkPatch` method iterates through an array of key-value pairs to update multiple values. Requires the `seyfert` package.  Assumes an interface `SeyfertDotDev` is available.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/cache.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\ninterface SeyfertDotDev {\n    set(key: string, value: any): Promise<void>;\n    get(key: string): Promise<any>;\n}\n// @noErrors\n// ---cut---\nimport { Adapter } from 'seyfert';\n\nclass MiAdaptador implements Adapter {\n    // ---cut-start---\n    almacenamiento: SeyfertDotDev;\n    // ---cut-end---\n    async patch(key: string, value: any | any[]) {\n        const oldData = await this.almacenamiento.get(key) ?? {};\n        const newValue = Array.isArray(value)\n            ? value\n            : ({ ...oldData, ...value });\n\n        await this.almacenamiento.set(key, { value: newValue });\n    }\n\n    async bulkPatch(keys: [string, any][]) {\n        for (let [key, value] of keys) {\n            await this.patch(key, value);\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Cache Resource in Seyfert\nDESCRIPTION: This code demonstrates creating a custom cache resource called `CooldownResource` in Seyfert. It extends `BaseResource` and overrides the `set` method to apply specific typing and formatting, including setting a default `lastDrip` value.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/cache.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { BaseResource } from 'seyfert/lib/cache';\n\nexport class CooldownResource extends BaseResource<CooldownData> {\n    // The namespace is the base that separates each resource\n    namespace = 'cooldowns';\n\n    // We override set to apply the typing and format we want\n    override set(id: string, data: MakePartial<CooldownData, 'lastDrip'>) {\n        return super.set(id, { ...data, lastDrip: data.lastDrip ?? Date.now() });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Extending Seyfert with Global Middlewares (TypeScript)\nDESCRIPTION: Similar to extending with regular middlewares, this snippet shows how to define global middlewares.  It imports all global middlewares from a specified file and merges an interface named `GlobalMetadata` to the `seyfert` module. This interface extends `ParseMiddlewares`, providing type information about the global middlewares.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/getting-started/declare-module.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// Assuming you exported all global middlewares from './globalMiddlewares';\nimport type * as globalMiddlewares from './globalMiddlewares';\n\ndeclare module 'seyfert' {\n    interface GlobalMetadata extends ParseMiddlewares<typeof globalMiddlewares> {}\n}\n```\n\n----------------------------------------\n\nTITLE: Sending a Message to a Channel with Seyfert\nDESCRIPTION: This snippet demonstrates how to send a message to a specific channel using `ctx.client.messages.write()`, without directly replying to a command. The channel ID is accessed via `ctx.channelId`, and the message content is specified in the options object.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/sending-messages.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Command, type CommandContext } from 'seyfert';\n\nexport default class HelloWorldCommand extends Command {\n  async run(ctx: CommandContext) {\n    return ctx.client.messages.write(ctx.channelId, { content: 'Hola mundo 👋' });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Install Generic Adapter for Seyfert\nDESCRIPTION: This command installs the '@slipher/generic-adapter' package, which is required for using Seyfert with Cloudflare Workers.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/cloudflare-workers.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm add @slipher/generic-adapter\n```\n\n----------------------------------------\n\nTITLE: Extending Seyfert Command Properties (TypeScript)\nDESCRIPTION: This snippet demonstrates how to extend Seyfert's command properties using `ExtraProps`.  It defines a custom interface `ExtraProps` within the `seyfert` module, declaring the types of additional properties that can be attached to commands. This allows for categorizing commands or assigning identifiers.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/getting-started/declare-module.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// @errors: 2741 2322\nimport { Client, Declare, Command } from 'seyfert';\n// ---cut---\nconst client = new Client({\n    commands: {\n        defaults: {\n            props: {\n                category: 'none'\n            }\n        }\n    }\n});\n\n@Declare({\n    name: 'test',\n    description: 'test command',\n    props: {}\n})\nclass Test extends Command {}\n\ndeclare module 'seyfert' {\n    interface ExtraProps {\n        onlyForAdmins: boolean;\n        disabled?: true;\n        category?: string\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Kazagumo and Shoukaku\nDESCRIPTION: This command installs the kazagumo and shoukaku libraries, which are necessary for integrating music playback functionality into the Seyfert framework.  These libraries provide the core functionality for interacting with Lavalink.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/music.mdx#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npnpm add kazagumo shoukaku\n```\n\n----------------------------------------\n\nTITLE: Edit or Reply to a Seyfert Command\nDESCRIPTION: This snippet shows how to use `CommandContext.editOrReply()` to either reply to a command or edit an existing reply. It first defers the reply using `ctx.deferReply()` to acknowledge the command, and then, after some (assumed) processing, edits or replies with the final message.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/sending-messages.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Command, type CommandContext } from 'seyfert';\n\nexport default class HelloWorldCommand extends Command {\n  async run(ctx: CommandContext) {\n    await ctx.deferReply();\n\n    // hacer algo que toma tiempo y es aburrido\n\n    await ctx.editOrReply({ content: 'Hice cosas' });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Sending a Basic Text Message with Seyfert (TypeScript)\nDESCRIPTION: This snippet builds upon the basic command and adds functionality to send a simple \"Hello world\" message as a response to the command. It utilizes the `CommandContext.write()` function to send the message, with the `content` property specifying the text to be sent. This function is part of the Seyfert framework and provides a convenient way to reply to commands.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/sending-messages.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Command, Declare, type CommandContext } from 'seyfert';\n\n@Declare({\n  name: 'helloworld',\n  description: 'Sends a basic hello world message.',\n})\nexport default class HelloWorldCommand extends Command {\n  async run(ctx: CommandContext) {\n    return ctx.write({ content: 'Hello world 👋' });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Initialize Seyfert with Generic Adapter\nDESCRIPTION: This code snippet demonstrates how to initialize Seyfert with the GenericAdapter for use within a Cloudflare Worker. It imports the necessary modules, creates a HttpClient instance, and manually loads a command.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/cloudflare-workers.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport '../seyfert.config.mjs'; // ye, importing our seyfert.config.mjs\nimport { HttpClient } from 'seyfert';\nimport { GenericAdapter } from '@slipher/generic-adapter';\n\nimport Ping from './commands/ping.js';\n\nconst client = new HttpClient();\nconst adapter = new GenericAdapter(client);\n\nclient.start()\n  .then(async () => {\n    // we need to load commands manually\n    await client.commands!.set('', client, [Ping]);\n  });\n\nadapter.start();\n\nexport default {\n  fetch(req: Request) {\n    return adapter.fetch(req);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using the Seyfert GuildMember Transformer (Typescript)\nDESCRIPTION: This code snippet demonstrates accessing the `Transformers.GuildMember` property in Seyfert. The `// ^|` comment indicates where to inspect the available properties or types associated with the GuildMember transformer.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/transformers.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Transformers } from 'seyfert';\n\nTransformers.GuildMember\n              // ^|\n```\n\n----------------------------------------\n\nTITLE: Localizing Command Options in Seyfert\nDESCRIPTION: Shows how to add localization to command options using the `locales` property within the option definition in Seyfert. The snippet creates a string option with localized name and description, linking them to keys in the translation files.  If a localized name or description is not needed, the corresponding property can be omitted.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/i18n/usage.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStringOption } from 'seyfert';\n\nconst options = {\n    supremacy: createStringOption({\n        description: \"Enter a supremacy name.\",\n        required: true,\n        // ¡Si no quieres añadir un nombre o descripción localizada del comando!\n        // Simplemente elimine la propiedad del objeto\n        locales: {\n            name: \"hello\",\n            description: \"foo.bar\",\n        }\n    })\n}\n```\n\n----------------------------------------\n\nTITLE: Filtering Channel Data in Seyfert Cache\nDESCRIPTION: This snippet filters which channel data is stored in Seyfert's cache, specifically excluding DM and GroupDM channels. It utilizes the `filter` property on the `channels` cache resource and checks the `channel.type` against `ChannelType.DM` and `ChannelType.GroupDM`.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/cache.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Client } from \"seyfert\";\nimport { type APIChannel, ChannelType } from \"seyfert/lib/types\";\nconst client = new Client();\n\nclient.cache.channels!.filter = (\n    channel,\n    id,\n    guildId,\n) => {\n    return ![\n        ChannelType.DM,\n        ChannelType.GroupDM\n    ].includes(channel.type);\n};\n```\n\n----------------------------------------\n\nTITLE: Creating a Modal with Text Inputs in Seyfert\nDESCRIPTION: This code snippet demonstrates how to create a modal with two text input fields in Seyfert. It imports the necessary classes (Modal, TextInput, ActionRow) and types (TextInputStyle) from the 'seyfert' library. It then creates two TextInput components, wraps them in ActionRow components, and finally creates a Modal component with the ActionRows as components.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/components/modals.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Modal, TextInput, ActionRow } from 'seyfert';\n\nimport { TextInputStyle } from 'seyfert/lib/types';\n\nconst nameInput = new TextInput()\n  .setCustomId('name')\n  .setStyle(TextInputStyle.Short)\n  .setLabel('Name');\n\nconst row1 = new ActionRow<TextInput>().setComponents([nameInput]);\n\nconst ageInput = new TextInput()\n  .setCustomId('age')\n  .setStyle(TextInputStyle.Short)\n  .setLabel('Age');\n\nconst row2 = new ActionRow<TextInput>().setComponents([ageInput]);\n\nconst modal = new Modal()\n  .setCustomId('mymodal')\n  .setTitle('My Modal')\n  .setComponents([row1, row2]);\n```\n\n----------------------------------------\n\nTITLE: Declare Poll Command Parent in Seyfert\nDESCRIPTION: This TypeScript code snippet declares a parent command named `poll` using the `Declare` decorator. The `AutoLoad` decorator indicates that this command should be automatically loaded by the Seyfert framework. The `PollCommand` class extends the base `Command` class from Seyfert.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/components/polls.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { AutoLoad, Declare, Command } from 'seyfert';\n\n@Declare({\n    name: 'poll',\n    description: 'Poll command!',\n})\n@AutoLoad()\nexport default class PollCommand extends Command {}\n\n```\n\n----------------------------------------\n\nTITLE: Installing Seyfert with PNPM\nDESCRIPTION: This code snippet demonstrates how to install the Seyfert package using the PNPM package manager. It assumes that Node.js (version 18 or higher) and PNPM are already installed on the system. PNPM is used due to its efficiency in managing dependencies.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\npnpm add seyfert\n```\n\n----------------------------------------\n\nTITLE: Installing Kazagumo and Shoukaku Dependencies\nDESCRIPTION: This shell command installs the kazagumo and shoukaku libraries, which are necessary dependencies for audio playback functionality. Kazagumo is a Lavalink client, and Shoukaku handles the WebSocket connections to Lavalink nodes. This command uses pnpm as the package manager.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/music.mdx#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npnpm add kazagumo shoukaku\n```\n\n----------------------------------------\n\nTITLE: Deleting Relationships in Seyfert Adapter in TypeScript\nDESCRIPTION: This snippet demonstrates the `removeToRelationship` and `removeRelationship` methods for a Seyfert adapter. `removeToRelationship` removes an entire relationship set, while `removeRelationship` removes specific IDs from a relationship set. Both methods utilize the `setRemove` and `setPull` methods of the underlying storage.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/cache.md#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\ninterface SeyfertDotDev {\n    setRemove(key: string): Promise<void>;\n    setPull(to: string, key: string[]): Promise<void>\n}\n// @noErrors\n// ---cut---\nimport { Adapter } from 'seyfert';\n\nclass MyAdapter implements Adapter {\n    // ---cut-start---\n    storage: SeyfertDotDev;\n    // ---cut-end---\n    async removeToRelationship(to: string) {\n        // Remove the \"Set\" completely\n        await this.storage.setRemove(to);\n    }\n\n    async removeRelationship(to: string, key: string | string[]) {\n        // Remove the ID(s) from the \"Set\"\n        const keys = Array.isArray(key) ? key : [key];\n        await this.storage.setPull(to, keys);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Transforming Discord Data with Transformers TypeScript\nDESCRIPTION: This code snippet showcases how to transform Discord data using Seyfert's `Transformers`. It demonstrates creating a custom `Poll` class and registering it with `Transformers`, allowing for custom handling of poll-related data throughout the library. This involves declaring a custom module interface to let TypeScript know about new structure.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/changelog.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Transformers } from 'seyfert';\nconst storage = new Map();\nclass MyPoll extends Poll {\n    storage() {\n        return storage.set(this.id, this);\n    }\n}\n\nTransformers.Poll = (...args: ConstructorParameters<typeof MyPoll>) => new MyPoll(...args);\n\ndeclare module 'seyfert' {\n    interface CustomStructures {\n        Poll: MyPoll;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: WorkerClient Event Handling (TypeScript)\nDESCRIPTION: Illustrates how to enable sending all events from the `WorkerClient` to the parent (WorkerManager) in version 2.1.0. This is achieved by setting the `sendPayloadToParent` option to `true` in the `WorkerClient` constructor.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/changelog.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nnew WorkerClient({\n    sendPayloadToParent: true\n});\n```\n\n----------------------------------------\n\nTITLE: Skeleton for Custom Async Cache Adapter in Seyfert (TypeScript)\nDESCRIPTION: This code provides a skeleton for creating a custom asynchronous cache adapter in Seyfert. It implements the `Adapter` interface and sets `isAsync` to `true`. The `start` method is executed before the bot starts. Requires the `seyfert` package.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/cache.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// @noErrors\nimport { Adapter } from 'seyfert';\n\nclass MiAdaptador implements Adapter {\n    isAsync = true;\n\n    async start() {\n        // Esta función se ejecutará antes de iniciar el bot\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Modals with Seyfert Collectors\nDESCRIPTION: This code illustrates how to handle modal submissions using the `run` method within the modal constructor in Seyfert.  It shows creating a modal, setting a custom ID and title, and then defines a `handleModal` method to process the modal submission interaction.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/components/collectors.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  Modal,\n  Command,\n  Declare,\n  type ModalSubmitInteraction,\n  type CommandContext,\n} from 'seyfert';\n\n@Declare({\n  name: 'hello',\n  description: 'I will send you a hello world message',\n})\nexport default class HelloWorldCommand extends Command {\n  async run(ctx: CommandContext) {\n    const modal = new Modal()\n      .setCustomId('hello')\n      .setTitle('Hello')\n      .run(this.handleModal);\n\n    await ctx.interaction.modal(modal);\n  }\n\n  async handleModal(i: ModalSubmitInteraction) {\n    return i.write({ content: 'Hello World 👋' });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Carga automática de subcomandos con @AutoLoad en Seyfert (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to automatically load subcommands from a directory using the `@AutoLoad` decorator in Seyfert. By applying this decorator to the parent command, Seyfert automatically discovers and registers subcommands within the same directory.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/commands/intro.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Command, Declare, AutoLoad } from 'seyfert';\n\n@Declare({\n    name: 'padre',\n    description: 'Mi comando principal',\n})\n@AutoLoad()\nexport default class PadreCommand extends Command { }\n\n```\n\n----------------------------------------\n\nTITLE: AttachmentData Interface Update TypeScript\nDESCRIPTION: This code snippet shows the change in the `AttachmentData` interface, specifically the renaming of the `name` property to `filename`. This change affects how attachment data is handled within the Seyfert library, requiring updates in any code that relies on this interface.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/changelog.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface AttachmentData {\n  name: string;\n  filename: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Dockerfile for TypeScript Seyfert Project\nDESCRIPTION: This Dockerfile sets up an environment for a Seyfert bot written in TypeScript. It copies the necessary project files, installs dependencies, compiles the TypeScript code, and defines the entry point to run the bot in production mode. The `<VERSION_TAG>` needs to be replaced with the specific Node.js version.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/using-docker.mdx#_snippet_0\n\nLANGUAGE: Docker\nCODE:\n```\nFROM node:<VERSION_TAG>\n\nWORKDIR /bot\n\nCOPY package*.json ./\n\nRUN npm install --production\n\nRUN npm i -g typescript\n\nCOPY tsconfig.json seyfert.config.mjs ./\nCOPY /src ./src\n\n# Build typescript files\nRUN tsc --project tsconfig.json\n\nENV NODE_ENV=production\n\nENTRYPOINT [\"node\", \"dist/index.js\"]\n```\n\n----------------------------------------\n\nTITLE: Dockerfile with Multi-Stage Builds\nDESCRIPTION: This Dockerfile uses multi-stage builds to create a more optimized and smaller Docker image for production. It separates the build process into multiple stages: base, pkg (OS packages), build (project builder), and production. This allows for only necessary dependencies and compiled code to be included in the final production image. It also includes `dumb-init` for proper signal handling and sets a non-root user for enhanced security.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/using-docker.mdx#_snippet_1\n\nLANGUAGE: Docker\nCODE:\n```\n# [ base ] #\nFROM node:<VERSION_TAG>-alpine AS base\n\nENV DIR /bot\nWORKDIR $DIR\n\n# [ OS packages ] #\nFROM base AS pkg\n\nRUN apk update && apk add --no-cache dumb-init\n\n# [ project builder ] #\nFROM base AS build\n\nCOPY package*.json ./\n\n## Ref: https://docs.npmjs.com/cli/v10/commands/npm-ci\nRUN npm ci\n## Ref: https://docs.npmjs.com/cli/v10/commands/npm-prune\nRUN npm prune --production\n\nRUN npm i -g typescript\n\nCOPY tsconfig.json seyfert.config.mjs ./\nCOPY /src ./src\n\n## Build typescript\nRUN tsc --project tsconfig.json\n\n# [ production ready ] #\nFROM base AS production\n\n# Joining stages\n## Packages\nCOPY --from=pkg /usr/bin/dumb-init /usr/bin/dumb-init\n## Dependencies\nCOPY --from=build $DIR/node_modules ./node_modules\n## Builder\nCOPY --from=build $DIR/dist ./dist\nCOPY --from=build $DIR/package.json ./package.json\nCOPY --from=build $DIR/seyfert.config.js ./seyfert.config.js\n\n# Environment permissions\nENV NODE_ENV production\n## Remove if your project needs root permissions\nENV USER node\nUSER $USER\n\n# Run the application\nENTRYPOINT [\"dumb-init\", \"node\", \"dist/index.js\"]\n```\n\n----------------------------------------\n\nTITLE: Command Translation with @LocalesT in Seyfert\nDESCRIPTION: Demonstrates translating a command using the `@LocalesT` decorator in Seyfert.  The example shows how to define a command with a name and description and then apply the decorator to link them to translation keys.  It includes the option to pass `undefined` if only one of the name or description needs localization.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/i18n/usage.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Command, Declare, LocalesT } from 'seyfert';\n\n@Declare({\n\tname: 'supremacy',\n\tdescription: 'Ganyu Supremacy.'\n})\n// También puedes pasar 'undefined'\n// Si no quieres añadir un nombre o descripción localizada del comando.\n// Así: @LocalesT(undefined, 'algun.comando.descripcion')\n@LocalesT('hello', 'foo.bar')\nexport default class SupremacyCommand extends Command { }\n```\n\n----------------------------------------\n\nTITLE: Creating a Premium Button with Seyfert\nDESCRIPTION: This code snippet demonstrates how to create a premium button using the Seyfert library.  The button is linked to a specific store item (SKU) and styled as a premium button. Requires a valid SKU ID.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/monetization.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Button } from 'seyfert';\nimport { ButtonStyle } from 'seyfert/lib/types';\n\nnew Button()\n.setSKUId('STORE_ITEM_SKU_ID')\n.setStyle(ButtonStyle.Premium)\n```\n\n----------------------------------------\n\nTITLE: Disabling Bans Cache in Seyfert\nDESCRIPTION: This code snippet demonstrates how to disable the bans cache in Seyfert using the `setServices` method. By setting `disabledCache.bans` to `true`, the bans resource will not be available at runtime.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/cache.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Client } from 'seyfert';\n\nconst client = new Client();\n\nclient.setServices({ cache: { disabledCache: { bans: true } } })\n```\n\n----------------------------------------\n\nTITLE: Creating Attachment Options with Seyfert\nDESCRIPTION: This code demonstrates how to create an attachment option for a Discord command using the Seyfert library. It shows the use of `createAttachmentOption` to define an attachment option with a description and sets it as required. The `@Options` decorator associates the option with the `Ping` command class.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/commands/options.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n// @exactOptionalPropertyTypes: false\nimport { Options, createAttachmentOption, Command } from 'seyfert';\n\n@Options({\n    attachment: createAttachmentOption({\n        description: 'This is a attachment option',\n        required: true\n    })\n})\nclass Ping extends Command {}\n```\n\n----------------------------------------\n\nTITLE: Testing Seyfert Adapter Implementation in TypeScript\nDESCRIPTION: This snippet illustrates how to test a Seyfert adapter using the `testAdapter` method. It creates a new Seyfert client, sets the adapter, and then calls `testAdapter` to verify the adapter's functionality.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/cache.md#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\n// @errors: 2304\n// @noErrors\nimport { Client } from 'seyfert';\n\nconst client = new Client();\n\nclient.setServices({\n    cache: {\n        adapter: new MyAdapter()\n    }\n})\n\nawait client.cache.testAdapter();\n```\n\n----------------------------------------\n\nTITLE: Configuring Defer Reply Response for Prefix Commands in Seyfert (TS)\nDESCRIPTION: This example showcases how to customize the deferred reply response for prefix commands in Seyfert. It defines a `deferReplyResponse` callback within the client options to send a custom message while the command is processing.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/commands/prefix-commands.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Client } from 'seyfert';\n\nconst client = new Client({\n    commands: {\n        prefix: (msg) => {\n            // aquí puedes manejar los prefijos que quieras considerar dependiendo de los datos del mensaje.\n            return ['!', '?', '.']\n        },\n        reply: (ctx) => true,\n        deferReplyResponse: (ctx) => ({ content: 'Por favor espera, procesando tu solicitud...' })\n    }\n});\n```\n\n----------------------------------------\n\nTITLE: Install Generic Adapter for Seyfert\nDESCRIPTION: This command installs the @slipher/generic-adapter package, which is required to use Seyfert with Cloudflare Workers.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/cloudflare-workers.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm add @slipher/generic-adapter\n```\n\n----------------------------------------\n\nTITLE: Disabling Cache Resource in Seyfert (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to disable a specific cache resource (in this case, 'bans') in Seyfert. By setting `disabledCache.bans` to `true`, the banning cache resource is disabled at runtime. Requires the `seyfert` package.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/cache.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Client } from 'seyfert';\n\nconst client = new Client();\n\nclient.setServices({ cache: { disabledCache: { bans: true } } })\n```\n\n----------------------------------------\n\nTITLE: Initializing ActionRow with Seyfert (TypeScript)\nDESCRIPTION: This snippet demonstrates how to create a basic ActionRow using the Seyfert library. An ActionRow is a container for interactive components like buttons and select menus in a Discord message. The example initializes an ActionRow, sets its components to an empty array and attempts to add components via `addComponents()`\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/components/building-components.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ActionRow } from 'seyfert';\n\nconst row = new ActionRow()\n\n  .setComponents([])\n\n  .addComponents();\n```\n\n----------------------------------------\n\nTITLE: Installing Seyfert with NPM\nDESCRIPTION: This command installs the Seyfert library using NPM, the Node Package Manager. It adds Seyfert as a dependency to the project. Requires NodeJS and NPM to be installed.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/index.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm add seyfert\n```\n\n----------------------------------------\n\nTITLE: Installing Seyfert with NPM\nDESCRIPTION: This command installs the Seyfert library using NPM. It adds Seyfert as a dependency to the project's `package.json` file, allowing developers to use Seyfert's features in their Discord bot applications. It assumes that NodeJS and NPM are already installed and configured.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/index.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm add seyfert\n```\n\n----------------------------------------\n\nTITLE: Installing Seyfert Dev Version with NPM\nDESCRIPTION: This command installs the development version of the Seyfert library from the GitHub mirror using NPM. It provides access to the latest changes. Requires NodeJS and NPM to be installed.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/index.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm add seyfert@dev\n```\n\n----------------------------------------\n\nTITLE: Disabling the Entire Cache in Seyfert (TypeScript)\nDESCRIPTION: This example shows how to completely disable the Seyfert cache functionality. By setting `disabledCache` to `true`, the entire cache system is disabled. Requires the `seyfert` package.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/cache.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Client } from 'seyfert';\n\nconst client = new Client();\n// ---cut---\nclient.setServices({ cache: { disabledCache: true } })\n```\n\n----------------------------------------\n\nTITLE: Implementing Relationship Storage Methods in Custom Cache Adapter (TypeScript)\nDESCRIPTION: This code implements the `addToRelationship` and `bulkAddToRelationShip` methods for a custom cache adapter. These methods are used to store relationships between cached entities, maintaining associations between different data points. Requires the `seyfert` package. Assumes an interface `SeyfertDotDev` is available.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/cache.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\ninterface SeyfertDotDev {\n    setAdd(key: string, key: string): Promise<void>;\n}\n// @noErrors\n// ---cut---\nimport { Adapter } from 'seyfert';\n\nclass MiAdaptador implements Adapter {\n    // ---cut-start---\n    almacenamiento: SeyfertDotDev;\n    // ---cut-end---\n    async addToRelationship(id: string, keys: string | string[]) {\n        for (const key of Array.isArray(keys) ? keys : [keys]) {\n            // Agregar a un \"Set\", los IDs deben ser únicos\n            await this.almacenamiento.setAdd(id, key);\n        }\n    }\n\n    async bulkAddToRelationShip(data: Record<string, string[]>) {\n        for (const i in data) {\n            await this.addToRelationship(i, data[i]);\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Create End Poll Subcommand in Seyfert\nDESCRIPTION: This TypeScript code snippet defines a subcommand named `end` for ending a poll. It uses the `Declare` and `Options` decorators to define the command's metadata and options. The `run` method handles the command's logic, including retrieving the message ID of the poll from the options and calling the `endPoll` method on the client to end the poll.  It uses `createStringOption` to define the message ID option.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/components/polls.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n// @exactOptionalPropertyTypes: false\nimport {\n    type CommandContext,\n    Declare,\n    Options,\n    SubCommand,\n    createStringOption\n} from 'seyfert';\nimport { MessageFlags } from 'seyfert/lib/types';\n\nconst options = {\n    message: createStringOption({\n        description: 'The message id of the poll',\n        required: true,\n    }),\n};\n\n@Declare({\n    name: 'end',\n    description: 'End a poll.',\n})\n@Options(options)\nexport default class EndPoll extends SubCommand {\n    async run(ctx: CommandContext<typeof options>) {\n        const { options, client } = ctx;\n        const { message: messageId } = options;\n\n        await client.messages.endPoll(ctx.channelId, messageId);\n        await ctx.editOrReply({\n            flags: MessageFlags.Ephemeral,\n            content: 'Poll ended.',\n        });\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Handling Interactions within a Seyfert Collector\nDESCRIPTION: This example shows how to handle button interactions using the `run` function of the component collector. It creates a button, sends a message with the button, creates the collector, and then sets up a handler for interactions with the custom ID 'hello'.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/components/collectors.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  Button,\n  ActionRow,\n  Command,\n  Declare,\n  type CommandContext,\n} from 'seyfert';\n\nimport { ButtonStyle } from 'seyfert/lib/types';\n\n@Declare({\n  name: 'hello',\n  description: 'I will send you a hello world message',\n})\nexport default class HelloWorldCommand extends Command {\n  async run(ctx: CommandContext) {\n    const button = new Button()\n      .setCustomId('hello')\n      .setLabel('Hello')\n      .setStyle(ButtonStyle.Primary);\n\n    const row = new ActionRow<Button>().setComponents([button]);\n\n    const message = await ctx.write(\n      {\n        content: 'Do you want a hello world? Click the button below.',\n        components: [row],\n      },\n      true\n    );\n\n    const collector = message.createComponentCollector();\n\n    // estamos colocando el ID personalizado que hemos establecido en el botón como primer parámetro de la función.\n    collector.run('hello', async (i) => {\n      if (i.isButton()) return i.write({ content: 'Hello World 👋' });\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Seyfert GitHub Mirror with NPM\nDESCRIPTION: This command installs the development version of Seyfert from the GitHub mirror using NPM. It allows developers to access the latest changes and bug fixes that may not be available in the stable release. It assumes that NodeJS and NPM are already installed and configured and the user wants to test the latest unreleased changes.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/index.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm add seyfert@dev\n```\n\n----------------------------------------\n\nTITLE: Extending Seyfert Client Types (Worker)\nDESCRIPTION: This code snippet demonstrates how to inform TypeScript about the specific client type being used in your Seyfert project when using the Worker client. It extends the 'seyfert' module with an interface that defines the client type.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/getting-started/declare-module.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { ParseClient, Client, HttpClient, WorkerClient } from 'seyfert';\n\ndeclare module 'seyfert' {\n\n    interface UsingClient extends ParseClient<WorkerClient<true>> { }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring TypeScript with Decorators in tsconfig.json\nDESCRIPTION: This code snippet shows how to configure `tsconfig.json` to enable decorator support by adding `emitDecoratorMetadata` and `experimentalDecorators` compiler options. This is required for Seyfert to function correctly.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/getting-started/setup-project.mdx#_snippet_0\n\nLANGUAGE: JSON\nCODE:\n```\n{\n    \"compilerOptions\": {\n\n        \"emitDecoratorMetadata\": true,\n        \"experimentalDecorators\": true\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: AttachmentData Interface Change (TypeScript)\nDESCRIPTION: Demonstrates the breaking change in the `AttachmentData` interface from version 2.1.0, specifically the renaming of the `name` property to `filename`.  Developers need to update their code to reflect this change.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/changelog.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface AttachmentData {\n  name: string;\n  filename: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating User Options with Seyfert\nDESCRIPTION: This code demonstrates how to create a user option for a Discord command using the Seyfert library. It shows the use of `createUserOption` to define a user option, setting a description and making it required. The `@Options` decorator is used to associate the option with the `Ping` command class.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/commands/options.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n// @exactOptionalPropertyTypes: false\nimport { Options, createUserOption, Command } from 'seyfert';\n\n@Options({\n    user: createUserOption({\n        description: 'This is a user option',\n        required: true\n    })\n})\nclass Ping extends Command {}\n```\n\n----------------------------------------\n\nTITLE: Update Seyfert Config for Language Files (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to update the `seyfert.config.mjs` file to specify the location of the language files directory. It defines the `langs` property within the `locations` object to point to the `languages` directory.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/i18n/languages.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// @ts-check\nimport { config } from \"seyfert\";\n\nexport default config.bot({\n  token: process.env.BOT_TOKEN ?? \"\",\n  intents: [\"Guilds\"],\n  locations: {\n    base: \"dist\",\n    commands: \"commands\",\n    events: \"events\",\n    langs: \"languages\" // - src/languages será nuestro directorio de idiomas\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: tsconfig.json Configuration (Recommended)\nDESCRIPTION: This snippet presents a recommended `tsconfig.json` configuration for Seyfert projects. It includes common compiler options for TypeScript projects, such as module resolution, target ES version, strict mode, and output directory settings. It provides a solid base configuration for developing a robust Seyfert application. No specific input is required as it is a configuration file. Output is the properly configured tsconfig.json file.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/getting-started/setup-project.mdx#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"compilerOptions\": {\n        \"module\": \"CommonJS\",\n        \"target\": \"ESNext\",\n        \"moduleResolution\": \"node\",\n        \"strict\": true,\n        \"esModuleInterop\": true,\n        \"experimentalDecorators\": true,\n        \"emitDecoratorMetadata\": true,\n        \"preserveConstEnums\": true,\n        \"noImplicitAny\": true,\n        \"strictNullChecks\": true,\n        \"strictFunctionTypes\": true,\n        \"noImplicitThis\": true,\n        \"noUnusedLocals\": true,\n        \"noUnusedParameters\": true,\n        \"noImplicitReturns\": true,\n        \"skipLibCheck\": true,\n        \"noErrorTruncation\": true,\n        \"outDir\": \"./dist\",\n        \"rootDir\": \"./src\",\n        \"baseUrl\": \".\",\n        \"stripInternal\": true\n    },\n    \"exclude\": [\"node_modules\"],\n    \"include\": [\"src/**/*\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Data Retrieval Methods in Custom Cache Adapter (TypeScript)\nDESCRIPTION: This code implements the `get` and `bulkGet` methods for retrieving data in a custom cache adapter. The `get` method retrieves a value by its key, and the `bulkGet` method retrieves multiple values by their keys. Requires the `seyfert` package. Assumes an interface `SeyfertDotDev` is available.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/cache.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\ninterface SeyfertDotDev {\n    get(key: string): Promise<any>;\n}\n// @noErrors\n// ---cut---\nimport { Adapter } from 'seyfert';\n\nclass MiAdaptador implements Adapter {\n    // ---cut-start---\n    almacenamiento: SeyfertDotDev;\n    // ---cut-end---\n    async get(key: string) {\n        return this.almacenamiento.get(key);\n    }\n\n    async bulkGet(keys: string[]) {\n        const values: Promise<any>[] = [];\n        for (let key of keys) {\n            values.push(this.get(key));\n        }\n\n        return (await Promise.all(values))\n            // No devolver valores nulos\n            .filter(value => value)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Sending a Basic Message with Seyfert\nDESCRIPTION: This snippet illustrates how to send a simple text message as a response to a command using `CommandContext.write()`. It shows how to return a message containing text when a command is executed within the Seyfert framework. The `content` property specifies the message to be sent.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/sending-messages.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Command, Declare, type CommandContext } from 'seyfert';\n\n@Declare({\n  name: 'helloworld',\n  description: 'Envía un mensaje básico de hola mundo.',\n})\nexport default class HelloWorldCommand extends Command {\n  async run(ctx: CommandContext) {\n    return ctx.write({ content: 'Hola mundo 👋' });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Create Event Handler for Poll Vote Remove in Seyfert\nDESCRIPTION: This TypeScript code snippet creates an event handler for the `messagePollVoteRemove` event. It uses the `createEvent` function from the `seyfert` library to define an event that logs a message when a user removes a vote from a poll. The `data` property specifies the event name, and the `run` property defines the function to execute when the event is triggered. The function receives an object `data` containing the `userId` and `messageId`.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/components/polls.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent } from 'seyfert';\n\nexport default createEvent({\n    data: { name: 'messagePollVoteRemove' },\n    run: (data) => {\n        // Puedes hacer lo que quieras con los datos\n        console.log(`The user: ${data.userId} removed a vote to the poll: ${data.messageId}`);\n    },\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing remove, bulkRemove, flush Methods (TypeScript)\nDESCRIPTION: This snippet shows the implementation of `remove`, `bulkRemove`, and `flush` methods for a Seyfert adapter. The `remove` method removes a specific key. The `bulkRemove` method removes multiple keys iteratively. The `flush` method removes both values and relationships using the `flush` and `setFlush` methods of the underlying storage.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/cache.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\ninterface SeyfertDotDev {\n    remove(key: string): Promise<void>;\n    flush(): Promise<void>;\n    setFlush(): Promise<void>;\n}\n\nimport { Adapter } from 'seyfert';\n\nclass MiAdaptador implements Adapter {\n    almacenamiento: SeyfertDotDev;\n    async remove(key: string) {\n        await this.almacenamiento.remove(key);\n    }\n\n    async bulkRemove(keys: string[]) {\n        for (const key of keys) {\n            await this.remove(key);\n        }\n    }\n\n    async flush() {\n        await this.almacenamiento.flush(); // Eliminar valores\n        await this.almacenamiento.setFlush(); // Eliminar relaciones\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Executing the Component Handler with a run Function (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates how to execute the component handler by implementing the `run` function. The `run` function receives a `ComponentContext` and uses it to write a response.  In this case, it sends a 'Hello World 👋' message as an ephemeral message (visible only to the user who triggered the interaction).\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/components/handling-components.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ComponentCommand, type ComponentContext } from 'seyfert';\n\nimport { MessageFlags } from 'seyfert/lib/types';\n\nexport default class HelloWorldButton extends ComponentCommand {\n  componentType = 'Button' as const;\n\n  // esto también puede ser una promesa.\n\n  filter(ctx: ComponentContext<typeof this.componentType>) {\n    return ctx.customId === 'hello-world';\n  }\n\n  async run(ctx: ComponentContext<typeof this.componentType>) {\n    return ctx.write({\n      content: 'Hello World 👋',\n      flags: MessageFlags.Ephemeral\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Seyfert Event to Detect Poll End\nDESCRIPTION: This code snippet demonstrates how to create an event in Seyfert that listens for `messageUpdate` events. It checks if a poll has ended by examining the `isFinalized` property within the `newMessage.poll.results` object. If a poll is finalized, the example logs the message ID to the console. This allows actions to be performed when a poll concludes.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/components/polls.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent } from 'seyfert';\n\nexport default createEvent({\n    data: { name: 'messageUpdate' },\n    // This is [newMessage, oldMessage]\n    // But in this example, we only need newMessage\n    run: ([newMessage]) => {\n        if (newMessage.poll?.results?.isFinalized) {\n            console.log(`The poll with the id: ${newMessage.id} has ended`)\n        }\n    },\n});\n```\n\n----------------------------------------\n\nTITLE: Formatting readyAt as Timestamp - TypeScript\nDESCRIPTION: This snippet demonstrates how to format the `readyAt` property using the `Formatter.timestamp` method from the Seyfert library. This returns a formatted timestamp suitable for displaying in messages or logs. It requires the `Formatter` class from the `seyfert` module.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/tips-misc/uptime.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nFormatter.timestamp(client.readyAt);\n```\n\n----------------------------------------\n\nTITLE: Filtering Interactions in a Seyfert Collector\nDESCRIPTION: This snippet demonstrates how to filter interactions in a Seyfert component collector. It shows how to create a collector with a filter that limits interactions to the user who executed the command and only accepts button interactions.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/components/collectors.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  Button,\n  ActionRow,\n  Command,\n  Declare,\n  type CommandContext,\n} from 'seyfert';\n\nimport { ButtonStyle } from 'seyfert/lib/types';\n\n@Declare({\n  name: 'hello',\n  description: 'I will send you a hello world message',\n})\nexport default class HelloWorldCommand extends Command {\n  async run(ctx: CommandContext) {\n    const button = new Button()\n      .setCustomId('hello')\n      .setLabel('Hello')\n      .setStyle(ButtonStyle.Primary);\n\n    const row = new ActionRow<Button>().setComponents([button]);\n\n    const message = await ctx.write(\n      {\n        content: 'Do you want a hello world? Click the button below.',\n        components: [row],\n      },\n      true\n    );\n\n    const collector = message.createComponentCollector({\n      filter: (i) => i.user.id === ctx.author.id && i.isButton(),\n    });\n\n    collector.run('hello', async (i) => {\n      return i.write({ content: 'Hello World 👋' });\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Premium Command with Seyfert\nDESCRIPTION: This code snippet demonstrates how to implement a premium command using Seyfert. It checks if the user has a premium entitlement and displays a button to subscribe if they don't. Requires Seyfert's command declaration and interaction handling.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/monetization.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Declare, Command, type CommandContext, ActionRow, Button } from 'seyfert';\nimport { ButtonStyle } from 'seyfert/lib/types';\n\n@Declare({\n  name: 'premium',\n  description: 'Comando premium',\n})\nexport class PremiumCommand extends Command  {\n  run(ctx: CommandContext) {\n    const allEntitlements = ctx.interaction.entitlements;\n    const isPremium = allEntitlements.some(ent => ent.userId === ctx.author.id);\n\n    const row = new ActionRow()\n    .setComponents([\n        new Button()\n        .setSKUId('STORE_ITEM_SKU_ID')\n        .setStyle(ButtonStyle.Premium)\n    ]);\n\n    if (!isPremium) return ctx.editOrReply({ \n        content: '¡Haz clic en este botón para suscribirte y obtener acceso al comando!',\n        components: [row] \n    });\n\n    // Premium code\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Entitlement Deletion Event in Seyfert\nDESCRIPTION: This snippet shows how to handle the `entitlementDelete` event using Seyfert. It logs a message to a specified channel indicating a refund or subscription deletion, including the SKU ID and entitlement type. This event is triggered when Discord issues a refund or deletes an entitlement manually.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/monetization.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent } from 'seyfert';\n//---cut---\nexport default createEvent({\n    data: { name: 'entitlementDelete' },\n    run(entitlement, client) {\n        client.messages.write('LOG_CHANNEL_ID', {\n            content: `Refund or subscription deleted (${entitlement.skuId}) [${entitlement.type}]`,\n        });\n    },\n});\n```\n\n----------------------------------------\n\nTITLE: Handling Middleware Errors with onMiddlewaresError (TypeScript)\nDESCRIPTION: This example demonstrates how to handle errors generated by middlewares when a `stop` signal is returned. It shows how to use the `onMiddlewaresError` method in a Seyfert command to catch and handle these errors. The `onMiddlewaresError` method receives the `CommandContext` and the error message (a string) as parameters.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/commands/handling-errors.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createMiddleware, type ParseMiddlewares } from 'seyfert';\nconst middleware = { OnlyDev: createMiddleware(() => {}) };\ndeclare module 'seyfert' {\n    interface RegisteredMiddlewares extends ParseMiddlewares<typeof middleware> {}\n}\n// ---cut---\nimport { Command, Middlewares, type CommandContext } from \"seyfert\";\n\n@Middlewares([\"OnlyDev\"])\nexport class HandlingErrors extends Command {\n    async onMiddlewaresError(context: CommandContext, error: string) {\n        await context.editOrReply({\n// @log: El usuario no es un desarrollador\n            content: error\n        });\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Registering Commands with Seyfert (TypeScript)\nDESCRIPTION: This code snippet shows how to register commands with Discord using the Seyfert framework. It creates a new `Client` instance and calls the `start` and `uploadCommands` methods to register the commands defined in the `commands` directory. The `cachePath` option specifies the path to a JSON file used to cache the command definitions and prevent unnecessary uploads. It requires the `seyfert` package.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/getting-started/first-command.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Client } from 'seyfert';\n\nconst client = new Client();\n\nclient.start()\n  .then(() => client.uploadCommands({ cachePath: './commands.json' }));\n```\n\n----------------------------------------\n\nTITLE: Handling onStop Event in Seyfert Collector\nDESCRIPTION: This code demonstrates handling the `onStop` event of a Seyfert component collector. It configures an idle timeout for the collector and refreshes the collector when it stops due to the timeout.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/components/collectors.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  Button,\n  ActionRow,\n  Command,\n  Declare,\n  type CommandContext,\n} from 'seyfert';\n\nimport { ButtonStyle } from 'seyfert/lib/types';\n\n@Declare({\n  name: 'hello',\n  description: 'I will send you a hello world message',\n})\nexport default class HelloWorldCommand extends Command {\n  async run(ctx: CommandContext) {\n    const button = new Button()\n      .setCustomId('hello')\n      .setLabel('Hello')\n      .setStyle(ButtonStyle.Primary);\n\n    const row = new ActionRow<Button>().setComponents([button]);\n\n    const message = await ctx.write(\n      {\n        content: 'Do you want a hello world? Click the button below.',\n        components: [row],\n      },\n      true\n    );\n\n    const collector = message.createComponentCollector({\n      filter: (i) => i.user.id === ctx.author.id && i.isButton(),\n      onStop(reason, refresh) {\n        //this will refresh the collector everytime it stops by timeout\n        if (reason === 'idle') return refresh();\n      },\n      idle: 1e3, //1000ms\n    });\n\n    collector.run('hello', async (i) => {\n      return i.write({ content: 'Hello World 👋' });\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Extending Seyfert Locations (TypeScript)\nDESCRIPTION: This snippet demonstrates extending the folder locations object using `ExtendedRCLocations`. It declares an `ExtendedRCLocations` interface within the `seyfert` module, allowing customization and extension of the folder locations configuration.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/getting-started/declare-module.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport 'seyfert';\n//---cut---\ndeclare module 'seyfert' {\n    interface ExtendedRCLocations {\n        models: string;\n        // more properties here...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Cooldown Property to Seyfert Client (TypeScript)\nDESCRIPTION: This TypeScript code snippet extends the Seyfert client with a `cooldown` property using declaration merging. It initializes a `CooldownManager` and assigns it to the `client.cooldown` property.  This enables the use of cooldown functionality within the Seyfert application.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/cooldown.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Client, type UsingClient } from \"seyfert\";\nimport { CooldownManager } from \"@slipher/cooldown\";\n\nconst client = new Client() as UsingClient & Client;\n\nclient.start().then(() => {\n\tclient.cooldown = new CooldownManager(client);\n})\n\ndeclare module \"seyfert\" {\n\tinterface UsingClient {\n\t\tcooldown: CooldownManager;\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Data Deletion Methods in Seyfert Adapter in TypeScript\nDESCRIPTION: This snippet describes the implementation of `remove`, `bulkRemove`, and `flush` methods for a Seyfert adapter. The `remove` method deletes a single key, `bulkRemove` deletes multiple keys iteratively, and `flush` deletes both values and relationships associated with the adapter.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/cache.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\ninterface SeyfertDotDev {\n    remove(key: string): Promise<void>;\n    flush(): Promise<void>;\n    setFlush(): Promise<void>;\n}\n// @noErrors\n// ---cut---\nimport { Adapter } from 'seyfert';\n\nclass MyAdapter implements Adapter {\n    // ---cut-start---\n    storage: SeyfertDotDev;\n    // ---cut-end---\n    async remove(key: string) {\n        await this.storage.remove(key);\n    }\n\n    async bulkRemove(keys: string[]) {\n        for (const key of keys) {\n            await this.remove(key);\n        }\n    }\n\n    async flush() {\n        await this.storage.flush(); // Delete values\n        await this.storage.setFlush(); // Delete relationships\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using @GroupsT Decorator in Seyfert\nDESCRIPTION: Illustrates the structure of the `@GroupsT` decorator. This decorator links a command group's name and default description with localized names. It's necessary for group translations, mapping the group name to its default description and optionally a localized name.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/i18n/usage.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n@GroupsT({\n    // Este es el nombre del grupo... Creado en el comando padre\n    groupName: {\n        // ¡Es obligatorio! Es el nombre por defecto del grupo.\n        defaultDescription,\n        // ¡Es opcional! Es el nombre localizado del grupo.\n        name,\n    }\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Event Locations in seyfert.config.mjs (TypeScript)\nDESCRIPTION: This snippet demonstrates how to update the seyfert.config.mjs file to specify the location of event files for Seyfert to load. It defines the 'events' property within the 'locations' object to point to the 'events' directory in the 'src' folder. This configuration is essential for Seyfert to discover and load event handlers.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/getting-started/listening-events.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { config } from 'seyfert';\n\nexport default config.bot({\n    token: process.env.BOT_TOKEN ?? '',\n    intents: ['Guilds'],\n    locations: {\n        base: 'dist',\n        commands: 'commands',\n        events: 'events' // - src/events será nuestra carpeta para los eventos\n    }\n});\n```\n\n----------------------------------------\n\nTITLE: Recommended TypeScript Configuration\nDESCRIPTION: This code snippet provides a more complete `tsconfig.json` configuration suitable for Seyfert development, including module settings, target ECMAScript version, and strict compiler options for enhanced type safety and code quality.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/getting-started/setup-project.mdx#_snippet_1\n\nLANGUAGE: JSON\nCODE:\n```\n{\n    \"compilerOptions\": {\n        \"module\": \"CommonJS\",\n        \"target\": \"ESNext\",\n        \"moduleResolution\": \"node\",\n        \"strict\": true,\n        \"esModuleInterop\": true,\n        \"experimentalDecorators\": true,\n        \"emitDecoratorMetadata\": true,\n        \"preserveConstEnums\": true,\n        \"noImplicitAny\": true,\n        \"strictNullChecks\": true,\n        \"strictFunctionTypes\": true,\n        \"noImplicitThis\": true,\n        \"noUnusedLocals\": true,\n        \"noUnusedParameters\": true,\n        \"noImplicitReturns\": true,\n        \"skipLibCheck\": true,\n        \"noErrorTruncation\": true,\n        \"outDir\": \"./dist\",\n        \"rootDir\": \"./src\",\n        \"baseUrl\": \".\",\n        \"stripInternal\": true\n    },\n    \"exclude\": [\"node_modules\"],\n    \"include\": [\"src/**/*\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Crosspost Command with Options in Seyfert (TS)\nDESCRIPTION: This example demonstrates how to create a prefix command with options using Seyfert. It defines a string option 'id' for specifying the message ID to republish.  The `@Options` decorator is used to associate the options with the command.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/commands/prefix-commands.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n    Command,\n    CommandContext,\n    Declare,\n    Options,\n    createStringOption\n} from 'seyfert';\n\nconst options = {\n    id: createStringOption({\n        description: 'El id del mensaje que vamos a republicar',\n        required: true\n    })\n};\n\n@Declare({\n    name: 'crosspost',\n    description: 'Republicar un mensaje de anuncio.'\n})\n@Options(options)\nexport default class CrosspostCommand extends Command {\n    async run(ctx: CommandContext<typeof options>){\n        await ctx.client.messages.crosspost(ctx.options.id, ctx.channelId);\n        return ctx.write({ content: 'He republicado tu anuncio.'});\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Handling Middleware Errors in Seyfert (TypeScript)\nDESCRIPTION: This snippet demonstrates how to handle errors caused by middleware stopping a Seyfert command. It uses the `@Middlewares` decorator to apply a middleware named \"OnlyDev\". The `onMiddlewaresError` method is overridden to display the middleware's error message to the user. Dependencies include `Command`, `Middlewares`, and `CommandContext` from \"seyfert\".\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/commands/command-class.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Command, Middlewares, type CommandContext } from \"seyfert\";\n\n@Middlewares([\"OnlyDev\"])\nexport class HandlingErrors extends Command {\n  async onMiddlewaresError(context: CommandContext, error: Error) {\n    await context.editOrReply({\n\t\t\t//El usuario no es desarrollador\n      content: error.message\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Communicating with Specific Workers Using tellWorker\nDESCRIPTION: This code shows how to send a message to a specific worker in Seyfert using the `tellWorker` method. It specifies the worker ID, a function to execute on the target worker, and any variables to pass to that function. This allows for inter-worker communication and execution of actions on specific workers within the sharded environment.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/sharding.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { WorkerClient } from 'seyfert';\nconst client = new WorkerClient();\n//---cut---\nclient.tellWorker(\n\t1,\n\t(worker, vars) => console.log(`Hola worker #${worker.workerId} desde ${vars.workerId}`),\n\t{ workerId: client.workerId }\n);\n```\n\n----------------------------------------\n\nTITLE: Extending Seyfert Internal Options (TypeScript)\nDESCRIPTION: This snippet explains how to add types for different Seyfert operation modes using `InternalOptions`. An interface called `InternalOptions` is declared within the `seyfert` module. This interface allows adding properties that transform Seyfert types into a more comprehensive form, accommodating different implementation requirements such as prefix handling and cache behavior.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/getting-started/declare-module.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport 'seyfert';\n//---cut---\ndeclare module 'seyfert' {\n    interface InternalOptions {\n        withPrefix: true; // or false\n        asyncCache: false; // or true\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementando grupos de subcomandos en Seyfert (TypeScript)\nDESCRIPTION: This code snippet illustrates how to create subcommand groups in Seyfert. It involves using the `@Group` and `@Groups` decorators to structure subcommands within groups.  The example shows a parent command and a subcommand belonging to a specific group named `mi-grupo`.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/commands/intro.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// @noErrors\nimport { Command, Declare, Options, Groups } from 'seyfert';\nimport MiSubComando from './sub';\n\n@Declare({\n    name: 'padre',\n    description: 'Mi comando principal',\n})\n@Options([MiSubComando])\n@Groups({\n    'mi-grupo': {\n        defaultDescription: 'Un grupo de subcomandos',\n    }\n})\nexport default class PadreCommand extends Command { }\n\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { SubCommand, Declare, CommandContext, Group } from 'seyfert';\n\n@Declare({\n    name: 'subcomando',\n    description: 'Uno de mi subcomandos dentro del grupo mi-grupo',\n})\n@Group('mi-grupo')\nexport default class GrupoMiSubCommand extends SubCommand {\n    run(ctx: CommandContext) {\n        return ctx.write({\n            content: '¡Hola desde el subcomando!',\n        });\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic ActionRow in Seyfert\nDESCRIPTION: This snippet demonstrates how to create a basic ActionRow using the Seyfert library.  It initializes a new ActionRow and provides placeholders for setting and adding components. It requires the 'seyfert' package.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/components/building-components.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ActionRow } from 'seyfert';\n\nconst row = new ActionRow()\n\n  .setComponents([])\n\n  .addComponents();\n\n```\n\n----------------------------------------\n\nTITLE: Installing @slipher/cooldown\nDESCRIPTION: This command installs the `@slipher/cooldown` package as a project dependency using npm. This package provides the necessary functionality for managing command cooldowns.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/cooldown.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm add @slipher/cooldown\n```\n\n----------------------------------------\n\nTITLE: Using a Middleware in a Seyfert Command (TypeScript)\nDESCRIPTION: This code snippet shows how to use a registered middleware in a Seyfert command.  It imports necessary modules from Seyfert, uses the `@Declare` decorator to define the command, and the `@Middlewares` decorator to specify which middlewares to apply.  The middleware is referenced by the name defined during registration.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/commands/middlewares.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Middlewares, Declare, Command, type CommandContext } from \"seyfert\";\n\n@Declare({\n\tname: \"ping\",\n\tdescription: \"Haz ping al bot\"\n})\n// Nota que estamos usando el nombre \"logger\" para referenciar al middleware\n@Middlewares([\"logger\"])\nexport default class PingCommand extends Command {\n    async run(ctx: CommandContext) {\n        await ctx.reply(\"Pong!\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Entitlement Update Event with Seyfert\nDESCRIPTION: This code snippet demonstrates how to handle the `entitlementUpdate` event using the Seyfert library. It creates an event that triggers when an entitlement is updated (e.g., when a subscription is renewed), fetching the user's information and logging the renewal to a specified channel.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/monetization.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent } from 'seyfert';\n//---cut---\nexport default createEvent({\n    data: { name: 'entitlementUpdate' },\n    run: async (entitlement, client) => {\n        if (!entitlement.userId) return;\n        const subscribedUser = await client.users.fetch(entitlement.userId);\n        client.messages.write('LOG_CHANNEL_ID', {\n            content: `Suscripción (${entitlement.skuId}) renovada por ${subscribedUser.globalName}`,\n        });\n    },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Button and ActionRow with Seyfert (TypeScript)\nDESCRIPTION: This snippet demonstrates how to create a Button component and add it to an ActionRow using Seyfert. It imports the necessary modules, creates a button with a custom ID, style, and label, and then adds the button to an ActionRow. This code shows a basic example of how to create a button component and set it within an ActionRow to be sent.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/components/building-components.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ActionRow, Button } from 'seyfert';\nimport { ButtonStyle } from 'seyfert/lib/types';\n\nconst button = new Button()\n  .setCustomId('primer-boton')\n  .setStyle(ButtonStyle.Primary)\n  .setLabel('Primer Botón');\n\nconst row = new ActionRow<Button>().setComponents([button]);\n```\n\n----------------------------------------\n\nTITLE: Creating a Seyfert Event for Adding Votes\nDESCRIPTION: This code snippet demonstrates how to create an event in Seyfert that listens for `messagePollVoteAdd` events. When a user adds a vote to a poll, this event is triggered, and the provided example logs the user ID and message ID to the console. It showcases the basic structure for handling poll vote addition events.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/components/polls.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent } from 'seyfert';\n\nexport default createEvent({\n    data: { name: 'messagePollVoteAdd' },\n    run: (data) => {\n        // You can do whatever you want with the data\n        console.log(`The user: ${data.userId} added a vote to the poll: ${data.messageId}`);\n    },\n});\n```\n\n----------------------------------------\n\nTITLE: Listening to the guildDelete Event (TypeScript)\nDESCRIPTION: This code defines an event handler for the 'guildDelete' event in Seyfert. This event is triggered when the bot is removed from a guild or when the guild is deleted. The `run` function checks if the guild is unavailable and logs a message to the console with the guild's ID if it's available.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/getting-started/listening-events.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent } from 'seyfert';\n\nexport default createEvent({\n  data: { name: 'guildDelete' },\n  run(unguild, client) {\n    // unguild es el servidor del que se expulsó o se eliminó.\n    // También es posible que el servidor haya sido eliminado.\n    if (unguild.unavailable) return;\n\n    client.logger.info(`Me han expulsado de: ${unguild.id}`);\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Using @LocalesT Decorator in Seyfert\nDESCRIPTION: This code snippet demonstrates how to automatically translate the entire content of a command using the `@LocalesT` decorator in Seyfert.  It requires defining a `DefaultLocale` interface extending `ParseLocales` to map translation keys. The decorator takes the keys for the name and description from the localization file.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/i18n/usage.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { ParseLocales } from 'seyfert';\nconst lang = {\n    'my-command': {\n        name: '',\n        description: '',\n    },\n};\ndeclare module 'seyfert' {\n    interface DefaultLocale extends ParseLocales<typeof lang> {}\n}\n// ---cut---\nimport { Command, LocalesT } from 'seyfert';\n\n@LocalesT('my-command.name', 'my-command.description')\n//                   ^|\nclass MyCommand extends Command {}\n```\n\n----------------------------------------\n\nTITLE: Stopping Middleware Execution with an Error (TypeScript)\nDESCRIPTION: This snippet illustrates how to stop the execution of a Seyfert command's middleware chain by returning a `stop` result. This allows certain conditions to halt a command's execution early, preventing it from running if unmet. The `stop` function takes a string argument which represents the error message.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/commands/handling-errors.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst Devs = [''];\n// ---cut---\nimport { createMiddleware } from \"seyfert\";\n\nexport default createMiddleware<void>(({ context, next, stop, pass }) => {\n    if (!Devs.includes(context.author.id)) {\n        return stop(\"El usuario no es un desarrollador\");\n    }\n    next();\n});\n```\n\n----------------------------------------\n\nTITLE: Seyfert HTTP Bot Configuration\nDESCRIPTION: This code shows how to configure a Seyfert HTTP bot using `seyfert.config.mjs`. It sets the bot token, application ID, public key, command locations, and port for the HTTP server to listen on.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/getting-started/setup-project.mdx#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Esto no se muestra, previene errores.\nprocess.env.BOT_APP_ID = '';\nprocess.env.BOT_PUBLIC_KEY = '';\nprocess.env.BOT_TOKEN = '';\n// ---cut---\nimport { config } from \"seyfert\";\n\nconst  {\n    BOT_TOKEN, BOT_APP_ID, BOT_PUBLIC_KEY\n} = process.env;\n\nexport default config.http({\n    token: BOT_TOKEN,\n    locations: {\n        base: \"dist\", // reemplazar por \"src\" en caso de usar bun\n        commands: \"commands\"\n    },\n    applicationId: BOT_APP_ID,\n    port: 3000, // por defecto es 8080\n    publicKey: BOT_PUBLIC_KEY\n});\n```\n\n----------------------------------------\n\nTITLE: Filtering Component Interactions\nDESCRIPTION: This code snippet demonstrates how to filter component interactions based on the custom ID of the component. The `filter` method is overridden to check if the `customId` of the interaction matches 'hello-world'.  This ensures that the handler only processes interactions from the specified button.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/components/handling-components.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ComponentCommand, type ComponentContext } from 'seyfert';\n\nexport default class HelloWorldButton extends ComponentCommand {\n  componentType = 'Button' as const;\n\n  filter(ctx: ComponentContext<typeof this.componentType>) {\n    //we are checking if the customId of the interaction is the same that the one set in my button\n\n    return ctx.customId === 'hello-world';\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Centralized Cache with WorkerAdapter\nDESCRIPTION: This code demonstrates how to implement centralized cache management in Seyfert using the `WorkerAdapter`. It initializes a `WorkerClient`, sets up the cache service with the `WorkerAdapter`, passing the client's worker data for consistent data access across shards. This ensures that the cache is centralized in the main process.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/sharding.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { WorkerClient, WorkerAdapter } from 'seyfert';\n\nconst client = new WorkerClient();\n\nclient.setServices({\n\tcache: {\n\t\tadapter: new WorkerAdapter(client.workerData)\n\t}\n});\n\nawait client.start();\n```\n\n----------------------------------------\n\nTITLE: Configuring Language File Location in Seyfert\nDESCRIPTION: This code snippet demonstrates how to update the `seyfert.config.mjs` file to specify the location where the language files will be stored. The `langs` property within the `locations` object is updated to point to the 'languages' directory.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/i18n/languages.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// @ts-check\nimport { config } from \"seyfert\";\n\nexport default config.bot({\n  token: process.env.BOT_TOKEN ?? \"\",\n  intents: [\"Guilds\"],\n  locations: {\n    base: \"dist\",\n    commands: \"commands\",\n    events: \"events\",\n    langs: \"languages\" // - src/languages will be our languages directory\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Declaring Seyfert Module for Prefix Command Context\nDESCRIPTION: This code snippet shows how to declare the Seyfert module to enable the `message` property within the `CommandContext` for prefix commands. By setting the `withPrefix` property inside `InternalOptions` to `true`, the `CommandContext` will include the `message` property, allowing you to access the message that triggered the command.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/commands/prefix-commands.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare module 'seyfert' {\n    interface InternalOptions {\n        withPrefix: true;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Entitlement Deletion Event with Seyfert\nDESCRIPTION: This code snippet shows how to handle the `entitlementDelete` event using the Seyfert library. It creates an event that triggers when an entitlement is deleted (e.g., due to a refund), logging the event details to a specified channel.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/monetization.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent } from 'seyfert';\n//---cut---\nexport default createEvent({\n    data: { name: 'entitlementDelete' },\n    run(entitlement, client) {\n        client.messages.write('LOG_CHANNEL_ID', {\n            content: `Reembolso o suscripción eliminada (${entitlement.skuId}) [${entitlement.type}]`,\n        });\n    },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Boolean Options with Seyfert\nDESCRIPTION: This snippet shows how to create a boolean option for a Discord command using the Seyfert library. It demonstrates the use of `createBooleanOption` to define a boolean option with a description and set as required. The `@Options` decorator associates the option with the `Ping` command class.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/commands/options.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// @exactOptionalPropertyTypes: false\nimport { Options, createBooleanOption, Command } from 'seyfert';\n\n@Options({\n    bool: createBooleanOption({\n        description: 'This is a boolean option',\n        required: true\n    })\n})\nclass Ping extends Command {}\n```\n\n----------------------------------------\n\nTITLE: Initializing WorkerManager for Sharding in Seyfert (threads)\nDESCRIPTION: This code snippet demonstrates how to initialize the WorkerManager in Seyfert to manage shards using threads. It sets the mode to \"threads\" and specifies the path to the client file. The `manager.start()` method initiates the worker processes.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/sharding.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { WorkerManager } from 'seyfert';\n\nconst manager = new WorkerManager({\n\tmode: \"threads\",\n\t// ./src/client.ts for bun and deno (?\n\tpath: \"./dist/client.js\",\n\t// you can override a lot of options, like number of workers, shards per worker...\n});\n\nmanager.start();\n```\n\n----------------------------------------\n\nTITLE: Initializing Gateway Client in src/index.ts\nDESCRIPTION: This code snippet demonstrates how to initialize and start a Seyfert Gateway client in the `src/index.ts` file.  It creates a new `Client` instance and calls the `start()` method to connect to the Discord gateway and load commands, events, components, and language files.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/getting-started/setup-project.mdx#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Client } from \"seyfert\";\n\nconst client = new Client();\n\n// Esto iniciará la conexión con la gateway de Discord y cargará comandos, eventos, componentes e idioma (i18n)\nclient.start();\n```\n\n----------------------------------------\n\nTITLE: Building a Button and Adding to ActionRow in Seyfert\nDESCRIPTION: This snippet demonstrates how to create a button component, customize its style and label, and add it to an ActionRow using the Seyfert library. It requires the 'seyfert' package and ButtonStyle enum from 'seyfert/lib/types'.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/components/building-components.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ActionRow, Button } from 'seyfert';\nimport { ButtonStyle } from 'seyfert/lib/types';\n\nconst button = new Button()\n  .setCustomId('first-button')\n  .setStyle(ButtonStyle.Primary)\n  .setLabel('First Button');\n\nconst row = new ActionRow<Button>().setComponents([button]);\n\n```\n\n----------------------------------------\n\nTITLE: Registering Middlewares in Seyfert (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to register a middleware for use in Seyfert commands.  It imports the `loggerMiddleware` and exports an object where the keys are the middleware names and the values are the middleware functions. This allows the middleware to be referenced by name in the command definitions.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/commands/middlewares.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { loggerMiddleware } from \"./path/to/logger.middleware\";\n\nexport const middlewares = {\n    // La clave es el nombre del middleware que se usará para referenciarlo en el comando\n    logger: loggerMiddleware\n}\n```\n\n----------------------------------------\n\nTITLE: Sending a Message to a Channel without Responding (TypeScript)\nDESCRIPTION: This snippet demonstrates sending a message directly to a specific channel using the `BaseClient.messages.write()` function, without replying to a command. It accesses the client's `messages` property and calls the `write` function with the channel ID (`ctx.channelId`) and the message content.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/sending-messages.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Command, type CommandContext } from 'seyfert';\n\nexport default class HelloWorldCommand extends Command {\n  async run(ctx: CommandContext) {\n    return ctx.client.messages.write(ctx.channelId, { content: 'Hello world 👋' });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting HandleCommand Service TypeScript\nDESCRIPTION: This code snippet demonstrates how to set the `handleCommand` service within a Seyfert client. It shows how to extend the `HandleCommand` class to implement custom argument parsing logic.  This allows developers to use their own parsers within Seyfert's command handling system.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/changelog.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { HandleCommand } from 'seyfert'\n\nclient.setServices({ handleCommand: class extends HandleCommand { argsParser = yourParser() } })\n```\n\n----------------------------------------\n\nTITLE: Accessing Extended Location\nDESCRIPTION: Shows how to access the newly added 'music' location from the Seyfert runtime configuration. It retrieves the configuration using `client.getRC()` and then logs the value of the `locations.music` property. This assumes the Seyfert client has been initialized.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/extending-config.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst rc = await client.getRC();\n\nconsole.log(rc.locations.music);\n```\n\n----------------------------------------\n\nTITLE: Declaring Custom Events in Seyfert Module (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to declare a custom event within the Seyfert module using TypeScript's module augmentation feature. It defines the `ourEvent` with a string parameter, allowing Seyfert to recognize and use the custom event.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/custom-events.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare module \"seyfert\" {\n\tinterface CustomEvents {\n\t\tourEvent: (text: string) => void;\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Seyfert Adapter (TypeScript)\nDESCRIPTION: This snippet shows how to test a Seyfert adapter using the `testAdapter` method. It initializes a Seyfert `Client`, sets the adapter to be tested, and then executes the `testAdapter` method. This verifies the adapter's compatibility with the Seyfert framework.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/cache.md#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Client } from 'seyfert';\n\nconst client = new Client();\n\nclient.setServices({\n    cache: {\n        adapter: new MiAdaptador()\n    }\n})\n\nawait client.cache.testAdapter();\n```\n\n----------------------------------------\n\nTITLE: WorkerClient Payload Sending Configuration TypeScript\nDESCRIPTION: This code snippet shows how to configure a `WorkerClient` to send payloads to its parent (WorkerManager). By default, this functionality is disabled. Enabling it requires setting the `sendPayloadToParent` option to `true` during `WorkerClient` instantiation.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/changelog.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nnew WorkerClient({\n    sendPayloadToParent: true\n});\n```\n\n----------------------------------------\n\nTITLE: Verifying Missing Property Error\nDESCRIPTION: This code snippet shows the error message that appears when a custom property like 'prefix' is missing from the Seyfert configuration. This validates that the type extension is working as expected. The error message indicates that the 'prefix' property is missing from the type.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/recipes/extending-config.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nProperty 'prefix' is missing in type '{ locations: ...\n\n```\n\n----------------------------------------\n\nTITLE: Declare Module for Client Types\nDESCRIPTION: This code shows how to augment the 'seyfert' module to declare the client type. This allows you to extend the client with custom properties and methods.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/getting-started/setup-project.mdx#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { ParseClient, Client, HttpClient, WorkerClient } from 'seyfert';\n\ndeclare module 'seyfert' {\n\n    interface UsingClient extends ParseClient<Client<true>> { }\n  \n  \n    interface UsingClient extends ParseClient<HttpClient> { }\n  \n  \n    interface UsingClient extends ParseClient<WorkerClient<true>> { }\n}\n```\n\n----------------------------------------\n\nTITLE: Extending RC Locations Interface\nDESCRIPTION: This code extends the `ExtendedRCLocations` interface in the `seyfert` module to include a custom `music` location property. This extends the available location configurations for the Seyfert bot.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/extending-config.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare module 'seyfert' {\n    interface ExtendedRCLocations {\n        music: string;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Extended Configuration Property\nDESCRIPTION: This code shows how to access the extended `prefix` property from the configuration object obtained using `client.getRC()`.  It demonstrates how to retrieve and use a custom configuration property.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/extending-config.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst rc = await client.getRC();\n\nconsole.log(rc.prefix);\n```\n\n----------------------------------------\n\nTITLE: Accessing Extended Location Property\nDESCRIPTION: This code demonstrates how to access the extended `music` location property from the configuration object. It assumes that the `music` property has been added to the `ExtendedRCLocations` interface.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/extending-config.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst rc = await client.getRC();\n\nconsole.log(rc.locations.music);\n```\n\n----------------------------------------\n\nTITLE: Installing @slipher/cooldown using npm\nDESCRIPTION: This command installs the @slipher/cooldown package as a dependency for your project using npm. This package provides utilities for managing cooldowns within your application.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/cooldown.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm add @slipher/cooldown\n```\n\n----------------------------------------\n\nTITLE: Missing Prefix Property Error\nDESCRIPTION: This code illustrates the error that appears when the `prefix` property is missing in the configuration. This demonstrates the type checking feature after extending the configuration interface.\nSOURCE: https://github.com/tiramisulabs/seyfert-docs/blob/main/src/content/docs/es/recipes/extending-config.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nProperty 'prefix' is missing in type '{ locations: ...\n}\n```"
  }
]