[
  {
    "owner": "dry-rb",
    "repo": "dry-types",
    "content": "TITLE: Basic Usage of dry-types with dry-struct for Creating Type-Safe Objects in Ruby\nDESCRIPTION: This example demonstrates how to create a basic User struct with type definitions for name and age attributes using dry-types and dry-struct. It shows the fundamental pattern of including the Types module and defining a struct with typed attributes.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/index.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nrequire 'dry-types'\nrequire 'dry-struct'\n\nmodule Types\n  include Dry.Types()\nend\n\nUser = Dry.Struct(name: Types::String, age: Types::Integer)\n\nUser.new(name: 'Bob', age: 35)\n# => #<User name=\"Bob\" age=35>\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Hash Schema in Ruby with dry-types\nDESCRIPTION: Demonstrates how to create a hash schema with string and coercible integer types for name and age. Shows successful coercion and error handling for invalid input.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/hash-schemas.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\n# using simple kernel coercions\nuser_hash = Types::Hash.schema(name: Types::String, age: Types::Coercible::Integer)\n\nuser_hash[name: 'Jane', age: '21']\n# => { name: 'Jane', age: 21 }\n# :name left untouched and :age was coerced to Integer\n```\n\nLANGUAGE: ruby\nCODE:\n```\nuser_hash[name: :Jane, age: '21']\n# => Dry::Types::SchemaError: :Jane (Symbol) has invalid type\n#    for :name violates constraints (type?(String, :Jane) failed)\n```\n\nLANGUAGE: ruby\nCODE:\n```\nuser_hash[name: 'Jane']\n# => Dry::Types::MissingKeyError: :age is missing in Hash input\n```\n\nLANGUAGE: ruby\nCODE:\n```\nuser_hash[name: 'Jane', age: '21', city: 'London']\n# => { name: 'Jane', age: 21 }\n```\n\n----------------------------------------\n\nTITLE: Initializing Dry::Types Namespace in Ruby\nDESCRIPTION: Creates a Types namespace that includes Dry::Types, making it available throughout the application. This is typically done in a separate file or initializer.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/getting-started.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nmodule Types\n include Dry.Types()\nend\n```\n\n----------------------------------------\n\nTITLE: Using Strict Integer Type in dry-types\nDESCRIPTION: Demonstrates how to use the Strict::Integer type for type checking. The first example shows successful type validation, while the second shows how the type constraint raises an error when a string is provided instead of an integer.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/built-in-types.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nTypes::Strict::Integer[1] # => 1\nTypes::Strict::Integer['1'] # => raises Dry::Types::ConstraintError\n```\n\n----------------------------------------\n\nTITLE: Using Strict Types for Runtime Type Checking in Ruby with dry-types\nDESCRIPTION: This example shows how to use Strict types to enforce type constraints at runtime. It defines a User struct with strict string and integer types that will raise errors if values of incorrect types are provided.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/index.html.md#2025-04-12_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nclass User < Dry::Struct\n  attribute :name, Types::Strict::String\n  attribute :age,  Types::Strict::Integer\nend\n\nUser.new(name: 'Bob', age: '18')\n# => Dry::Struct::Error: [User.new] \"18\" (String) has invalid type for :age\n```\n\n----------------------------------------\n\nTITLE: Building Hash Schema Types in Ruby\nDESCRIPTION: Creates type definitions for hash structures with defined key types. The example shows creating a schema for a hash with string name and coercible integer age.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/custom-types.html.md#2025-04-12_snippet_5\n\nLANGUAGE: ruby\nCODE:\n```\n# In the full form\nTypes::Hash.schema(name: Types::String, age: Types::Coercible::Integer)\n\n# Using Types.Hash()\nTypes.Hash(name: Types::String, age: Types::Coercible::Integer)\n```\n\n----------------------------------------\n\nTITLE: Composing Hash Schemas with Type Transforms and Key Transforms in Ruby\nDESCRIPTION: Demonstrates how to compose hash schemas using type transforms to make all keys optional and key transforms to symbolize keys. The resulting schemas are flexible and reusable.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/CHANGELOG.md#2025-04-12_snippet_19\n\nLANGUAGE: ruby\nCODE:\n```\nTOLERANT = Types::Hash.with_type_transform { |t| t.meta(omittable: true) }.freeze\nuser = TOLERANT.schema(name: 'strict.string', age: 'strict.int')\nuser.(name: \"Jane\") # => {name: \"Jane\"}\n\nTOLERANT_SYMBOLIZED = TOLERANT.with_key_transform(&:to_sym)\nuser_sym = TOLERANT_SYMBOLIZED.schema(name: 'strict.string', age: 'strict.int')\nuser_sym.(\"name\" => \"Jane\") # => {name: \"Jane\"}\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Dry::Struct with String Attribute in Ruby\nDESCRIPTION: Shows how to create a simple Dry::Struct class with a single string attribute. This example demonstrates the basic usage of Dry::Types within a struct definition.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/getting-started.html.md#2025-04-12_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\nclass User < Dry::Struct\n  attribute :name, Types::String\nend\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Types and Complex Dry::Struct in Ruby\nDESCRIPTION: Illustrates how to define custom types with constraints and use them in a Dry::Struct. This example includes custom email and age types with specific validation rules.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/getting-started.html.md#2025-04-12_snippet_3\n\nLANGUAGE: ruby\nCODE:\n```\nmodule Types\n  include Dry.Types()\n\n  Email = String.constrained(format: /\\A[\\w+\\-.]+@[a-z\\d\\-]+(\\.[a-z]+)*\\.[a-z]+\\z/i)\n  Age = Integer.constrained(gt: 18)\nend\nclass User < Dry::Struct\n  attribute :name, Types::String\n  attribute :email, Types::Email\n  attribute :age, Types::Age\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Default Values in Hash Schemas with dry-types\nDESCRIPTION: Shows how to set default values for hash schema keys and handle nil inputs using constructors.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/hash-schemas.html.md#2025-04-12_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nuser_hash = Types::Hash.schema(\n  name: Types::String,\n  age: Types::Integer.default(18)\n)\nuser_hash[name: 'Jane']\n# => { name: 'Jane', age: 18 }\n\n# nil violates the constraint\nuser_hash[name: 'Jane', age: nil]\n# => Dry::Types::SchemaError: nil (NilClass) has invalid type\n#    for :age violates constraints (type?(Integer, nil) failed)\n```\n\nLANGUAGE: ruby\nCODE:\n```\nuser_hash = Types::Hash.schema(\n  name: Types::String,\n  age: Types::Integer.\n         default(18).\n         constructor { |value|\n           value.nil? ? Dry::Types::Undefined : value\n         }\n)\n\nuser_hash[name: 'Jane', age: nil]\n# => { name: 'Jane', age: 18 }\n```\n\n----------------------------------------\n\nTITLE: Defining Optional Keys in Hash Schemas with dry-types\nDESCRIPTION: Demonstrates how to mark keys as optional in a hash schema by adding a question mark to the key name.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/hash-schemas.html.md#2025-04-12_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\nuser_hash = Types::Hash.schema(name: Types::String, age?: Types::Integer)\n\nuser_hash[name: 'Jane']\n# => { name: 'Jane' }\n```\n\n----------------------------------------\n\nTITLE: Adding Value Constraints in Ruby with dry-types\nDESCRIPTION: This example demonstrates how to apply additional constraints to types beyond their basic class. It shows how to enforce that an age value must be greater than or equal to 18 using the constrained method.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/index.html.md#2025-04-12_snippet_4\n\nLANGUAGE: ruby\nCODE:\n```\nclass User < Dry::Struct\n  attribute :name, Types::Strict::String\n  attribute :age,  Types::Strict::Integer.constrained(gteq: 18)\nend\n\nUser.new(name: 'Bob', age: 17)\n# => Dry::Struct::Error: [User.new] 17 (Fixnum) has invalid type for :age\n```\n\n----------------------------------------\n\nTITLE: Defining a Hash Schema with Optional Keys Using ?-Ending Symbols\nDESCRIPTION: Shows how to create a hash schema with optional keys by using symbols that end with a question mark. This is a convenient shorthand for making certain keys optional in a schema.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/CHANGELOG.md#2025-04-12_snippet_12\n\nLANGUAGE: ruby\nCODE:\n```\nDry::Types['hash'].schema(name: 'string', age?: 'integer')\n```\n\n----------------------------------------\n\nTITLE: Creating and Using a Nil or String Sum Type in dry-types\nDESCRIPTION: This example demonstrates how to define a sum type that accepts either nil or a string value using the | operator. It shows how to use the type to validate both valid and invalid inputs.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/combining-types/sum.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nnil_or_string = Types::Nil | Types::String\n\nnil_or_string[nil] # => nil\nnil_or_string[\"hello\"] # => \"hello\"\n\nnil_or_string[123] # raises Dry::Types::ConstraintError\n```\n\n----------------------------------------\n\nTITLE: Applying String Constraints in dry-types\nDESCRIPTION: Demonstrates creating and using constrained types in dry-types. The example shows string length constraints and regular expression pattern matching for email validation, with error handling when inputs violate the constraints.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/constraints.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nstring = Types::String.constrained(min_size: 3)\n\nstring['foo']\n# => \"foo\"\n\nstring['fo']\n# => Dry::Types::ConstraintError: \"fo\" violates constraints\n\nemail = Types::String.constrained(\n  format: /\\A[\\w+\\-.]+@[a-z\\d\\-]+(\\.\\[a-z]+)*\\.[a-z]+\\z/i\n)\n\nemail[\"jane@doe.org\"]\n# => \"jane@doe.org\"\n\nemail[\"jane\"]\n# => Dry::Types::ConstraintError: \"jane\" violates constraints\n```\n\n----------------------------------------\n\nTITLE: Using Dry Types with Monads Do Notation\nDESCRIPTION: Shows how to combine dry-types with dry-monads do notation to create a clean way of handling type conversions and computations with proper error handling.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/extensions/monads.html.md#2025-04-12_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\nrequire 'dry/types'\nrequire 'dry/monads'\nTypes = Dry.Types()\nDry::Types.load_extensions(:monads)\n\nclass AddTen\n  include Dry::Monads[:result, :do]\n\n  def call(input)\n    integer = yield Types::Coercible::Integer.try(input)\n\n    Success(integer + 10)\n  end\nend\n\nadd_ten = AddTen.new\n\nadd_ten.call(10)\n# => Success(20)\n\nadd_ten.call('integer')\n# => Failure([#<Dry::Types::CoercionError: invalid value for Integer(): \"integer\">, \"integer\"])\n```\n\n----------------------------------------\n\nTITLE: Creating Constructor Types in Ruby with Types.Constructor\nDESCRIPTION: Creates a new constructor type for a given class. By default, it uses the new method, but custom constructor methods or blocks can be provided.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/custom-types.html.md#2025-04-12_snippet_3\n\nLANGUAGE: ruby\nCODE:\n```\nclass User\n  def initialize(attributes)\n    @attributes = attributes\n  end\n\n  def name = @attributes.fetch(:name)\nend\n\nuser_type = Types.Constructor(User)\n\n# It is equivalent to User.new(name: 'John')\nuser_type[name: 'John']\n\n# Using a method User.build\nuser_type = Types.Constructor(User, User.method(:build))\n\n# Using a block\nuser_type = Types.Constructor(User) { |values| User.new(values) }\n```\n\n----------------------------------------\n\nTITLE: Implementing Type Coercion in Ruby with dry-types Coercible Types\nDESCRIPTION: This example demonstrates automatic type coercion using Coercible types. It shows how string values can be automatically converted to integers when appropriate, and how non-coercible values result in errors.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/index.html.md#2025-04-12_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\nclass User < Dry::Struct\n  attribute :name, Types::Coercible::String\n  attribute :age,  Types::Coercible::Integer\nend\n\nUser.new(name: 'Bob', age: '18')\n# => #<User name=\"Bob\" age=18>\nUser.new(name: 'Bob', age: 'not coercible')\n# => ArgumentError: invalid value for Integer(): \"not coercible\"\n```\n\n----------------------------------------\n\nTITLE: Using Maybe with dry-types in Ruby\nDESCRIPTION: This snippet demonstrates how to use the .maybe method with various dry-types to return Maybe objects. It shows examples with Integer, String, and Float types, including both successful and error cases.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/extensions/maybe.html.md#2025-04-12_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nTypes::Strict::Integer.maybe[nil]     # => None\nTypes::Strict::Integer.maybe[123]     # => Some(123)\n\nTypes::Coercible::String.maybe[nil]   # => None\nTypes::Coercible::String.maybe[123]   # => Some(\"123\")\n\nTypes::Coercible::Float.maybe[nil]    # => None\nTypes::Coercible::Float.maybe['12.3'] # => Some(12.3)\n\nTypes::Strict::String.maybe[123]      # => raises Dry::Types::ConstraintError\nTypes::Strict::Integer.maybe[\"foo\"]   # => raises Dry::Types::ConstraintError\n```\n\n----------------------------------------\n\nTITLE: Transforming All Keys in a Schema to be Optional\nDESCRIPTION: Shows how to use with_type_transform to make all keys in a schema optional. This is useful for creating schemas where all fields are optional by default.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/CHANGELOG.md#2025-04-12_snippet_14\n\nLANGUAGE: ruby\nCODE:\n```\n# defining a base schema with optional keys\nlax_hash = Dry::Types['hash'].with_type_transform { |key| key.required(false) }\n# same as\nlax_hash = Dry::Types['hash'].with_type_transform(&:omittable)\n\n# keys in user_schema are not required\nuser_schema = lax_hash.schema(name: 'string', age: 'integer')\n```\n\n----------------------------------------\n\nTITLE: Defining and Using String Enum Types in Ruby with dry-types\nDESCRIPTION: This example demonstrates how to define a string enum type for post statuses using dry-types, and then use it within a Dry::Struct class. It shows how to access enum values and the validation behavior when invalid values are provided.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/enum.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nrequire 'dry-types'\nrequire 'dry-struct'\n\nmodule Types\n  include Dry.Types()\nend\n\nclass Post < Dry::Struct\n  Statuses = Types::String.enum('draft', 'published', 'archived')\n\n  attribute :title, Types::String\n  attribute :body, Types::String\n  attribute :status, Statuses\nend\n\n# enum values are frozen, let's be paranoid, doesn't hurt and have potential to\n# eliminate silly bugs\nPost::Statuses.values.frozen? # => true\nPost::Statuses.values.all?(&:frozen?) # => true\n\nPost::Statuses['draft'] # => \"draft\"\n\n# it'll raise if something silly was passed in\nPost::Statuses['something silly']\n# => Dry::Types::ConstraintError: \"something silly\" violates constraints\n\n# nil is considered as something silly too\nPost::Statuses[nil]\n# => Dry::Types::ConstraintError: nil violates constraints\n```\n\n----------------------------------------\n\nTITLE: Creating Tolerant Hash Schemas with Omittable Keys in Ruby\nDESCRIPTION: Shows how to define hash schemas that allow omitting keys by default. Compares intolerant and tolerant schemas, and demonstrates setting default values for omitted keys.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/CHANGELOG.md#2025-04-12_snippet_18\n\nLANGUAGE: ruby\nCODE:\n```\nintolerant = Types::Hash.schema(name: Types::Strict::String)\nintolerant[{}] # => Dry::Types::MissingKeyError\ntolerant = Types::Hash.schema(name: Types::Strict::String.meta(omittable: true))\ntolerant[{}] # => {}\ntolerant_with_default = Types::Hash.schema(name: Types::Strict::String.meta(omittable: true).default(\"John\"))\ntolerant[{}] # => {name: \"John\"}\n```\n\n----------------------------------------\n\nTITLE: Basic String Type with Default Value in Ruby\nDESCRIPTION: Creates a String type with a default value of 'draft' that is returned when the input is not defined. When a value is provided, it's returned if valid, or raises a ConstraintError if invalid.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/default-values.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nPostStatus = Types::String.default('draft')\n\nPostStatus[] # \"draft\"\nPostStatus[\"published\"] # \"published\"\nPostStatus[true] # raises ConstraintError\n```\n\n----------------------------------------\n\nTITLE: Creating Enum Types with Mappings in Ruby\nDESCRIPTION: Shows how to create an enum type with mappings between string values and their corresponding integer codes. The enum supports lookups by both string and integer values.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/CHANGELOG.md#2025-04-12_snippet_22\n\nLANGUAGE: ruby\nCODE:\n```\ndict = Types::Strict::String.enum('draft' => 0, 'published' => 10, 'archived' => 20)\ndict['published'] # => 'published'\ndict[10] # => 'published'\n```\n\n----------------------------------------\n\nTITLE: Using Optional Type Modifier with Strict String\nDESCRIPTION: Shows how to use the .optional modifier to allow nil values while maintaining string type checking for non-nil values. Demonstrates both successful cases with nil and string values, and error case with invalid type.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/optional-values.html.md#2025-04-12_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\noptional_string = Types::Strict::String.optional\n\noptional_string[nil]\n# => nil\noptional_string['something']\n# => \"something\"\noptional_string[123]\n# raises Dry::Types::ConstraintError\n```\n\n----------------------------------------\n\nTITLE: Handling Optional Values in Ruby with dry-types\nDESCRIPTION: This example shows how to use the .optional method to allow nil values for specific attributes while maintaining type safety for non-nil values. It demonstrates both valid and invalid usage patterns.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/index.html.md#2025-04-12_snippet_3\n\nLANGUAGE: ruby\nCODE:\n```\nclass User < Dry::Struct\n  attribute :name, Types::String\n  attribute :age,  Types::Integer.optional\nend\n\nUser.new(name: 'Bob', age: nil)\n# => #<User name=\"Bob\" age=nil>\n# name is not optional:\nUser.new(name: nil, age: 18)\n# => Dry::Struct::Error: [User.new] nil (NilClass) has invalid type for :name\n# keys must still be present:\nUser.new(name: 'Bob')\n# => Dry::Struct::Error: [User.new] :age is missing in Hash input\n```\n\n----------------------------------------\n\nTITLE: Using Dry::Struct as a Type in Another Struct in Ruby\nDESCRIPTION: Demonstrates how to use a previously defined Dry::Struct (User) as a type within another Dry::Struct (Message). This showcases the composability of Dry::Types and Dry::Struct.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/getting-started.html.md#2025-04-12_snippet_4\n\nLANGUAGE: ruby\nCODE:\n```\nclass Message < Dry::Struct\n  attribute :body, Types::String\n  attribute :to, User\nend\n```\n\n----------------------------------------\n\nTITLE: Using Maybe Namespaced Types in Ruby\nDESCRIPTION: This snippet shows an alternative way to use Maybe types in dry-types by using the Maybe:: namespaced types. It provides examples equivalent to the previous snippet but using a different syntax.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/extensions/maybe.html.md#2025-04-12_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\nTypes::Maybe::Strict::Integer[nil]     # => None\nTypes::Maybe::Strict::Integer[123]     # => Some(123)\n\nTypes::Maybe::Coercible::String[nil]   # => None\nTypes::Maybe::Coercible::String[123]   # => Some(\"123\")\n\nTypes::Maybe::Coercible::Float[nil]    # => None\nTypes::Maybe::Coercible::Float['12.3'] # => Some(12.3)\n\nTypes::Maybe::Strict::String[123]      # => raises Dry::Types::ConstraintError\nTypes::Maybe::Strict::Integer[\"foo\"]   # => raises Dry::Types::ConstraintError\n```\n\n----------------------------------------\n\nTITLE: Direct Value Validation with dry-types in Ruby\nDESCRIPTION: This example demonstrates how to use dry-types to validate and coerce values directly without creating struct objects. It shows successful string validation, coercion, and a constraint violation example.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/index.html.md#2025-04-12_snippet_6\n\nLANGUAGE: ruby\nCODE:\n```\nTypes::Strict::String[\"foo\"]\n# => \"foo\"\nTypes::Strict::String[\"10000\"]\n# => \"10000\"\nTypes::Coercible::String[10000]\n# => \"10000\"\nTypes::Strict::String[10000]\n# Dry::Types::ConstraintError: 1000 violates constraints\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Map Type in dry-types Ruby Gem\nDESCRIPTION: This snippet demonstrates how to define a hashmap with constrained key and value types using dry-types, specifically a hashmap that only accepts Integer keys and Float values. It shows successful usage and the error that occurs when providing invalid keys.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/map.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nint_float_hash = Types::Hash.map(Types::Integer, Types::Float)\nint_float_hash[100 => 300.0, 42 => 70.0]\n# => {100=>300.0, 42=>70.0}\n\n# Only accepts mappings of integers to floats\nint_float_hash[name: 'Jane']\n# => Dry::Types::MapError: input key :name is invalid: type?(Integer, :name)\n```\n\n----------------------------------------\n\nTITLE: Inheriting and Merging Hash Schemas in dry-types\nDESCRIPTION: Shows how to inherit from existing hash schemas and merge multiple schemas together, preserving key transformations and strictness.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/hash-schemas.html.md#2025-04-12_snippet_5\n\nLANGUAGE: ruby\nCODE:\n```\n# Building an empty base schema\nStrictSymbolizingHash = Types::Hash.schema({}).strict.with_key_transform(&:to_sym)\n\nuser_hash = StrictSymbolizingHash.schema(\n  name: Types::String\n)\n\nuser_hash['name' => 'Jane']\n# => { name: 'Jane' }\n\nuser_hash['name' => 'Jane', 'city' => 'London']\n# => Dry::Types::UnknownKeysError: unexpected keys [:city] in Hash input\n```\n\nLANGUAGE: ruby\nCODE:\n```\nuser_hash = Types::Hash.schema(\n  name: Types::String\n)\n\naddress_hash = Types::Hash.schema(\n  address: Types::String\n)\n\nuser_with_address_schema = user_hash.merge(address_hash)\n\nuser_with_address_schema['name' => 'Jane', 'address' => 'C/ Foo']\n# => { name: 'Jane', address: 'C/ Foo' }\n```\n\n----------------------------------------\n\nTITLE: Partial Schema Application for Updating Validated Hashes\nDESCRIPTION: Shows how to use partial schema application to validate and update only specific keys in a hash. This is useful for updating values in an already-validated hash structure.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/CHANGELOG.md#2025-04-12_snippet_16\n\nLANGUAGE: ruby\nCODE:\n```\nschema = Dry::Types['hash'].schema(name: 'string', age: 'integer')\nvalue = schema.(name: 'John', age: 20)\nupdate = schema.apply({ age: 21 }, skip_missing: true)\nvalue.merge(update)\n```\n\n----------------------------------------\n\nTITLE: Implementing Strict Hash Schemas with dry-types\nDESCRIPTION: Shows how to create a strict hash schema that raises an error for unexpected keys in the input.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/hash-schemas.html.md#2025-04-12_snippet_3\n\nLANGUAGE: ruby\nCODE:\n```\nuser_hash = Types::Hash.schema(name: Types::String).strict\nuser_hash[name: 'Jane', age: 21]\n# => Dry::Types::UnknownKeysError: unexpected keys [:age] in Hash input\n```\n\n----------------------------------------\n\nTITLE: Creating Array with Coercible String Members using dry-types in Ruby\nDESCRIPTION: This snippet demonstrates how to define an array type where all members are coercible to strings. It uses the Types::Array.of method to specify the member type as Types::Coercible::String. The example shows how symbols in the input array are coerced to strings.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/array-with-member.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nPostStatuses = Types::Array.of(Types::Coercible::String)\n\nPostStatuses[[:foo, :bar]] # [\"foo\", \"bar\"]\n```\n\n----------------------------------------\n\nTITLE: Transforming Input Keys in Hash Schemas with dry-types\nDESCRIPTION: Demonstrates how to add a key transformation to a hash schema for converting string keys to symbols.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/hash-schemas.html.md#2025-04-12_snippet_4\n\nLANGUAGE: ruby\nCODE:\n```\nuser_hash = Types::Hash.schema(name: Types::String).with_key_transform(&:to_sym)\nuser_hash['name' => 'Jane']\n\n# => { name: 'Jane' }\n```\n\n----------------------------------------\n\nTITLE: Defining Enum Types with Default Values in Ruby with dry-types\nDESCRIPTION: This snippet shows the correct and incorrect ways to define an enum type with a default value in dry-types. The default method must be called before the enum method for proper functionality.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/enum.html.md#2025-04-12_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\n# this is the correct usage:\nDry::Types::String.default('red').enum('blue', 'green', 'red')\n\n# this will raise an error:\nDry::Types::String.enum('blue', 'green', 'red').default('red')\n```\n\n----------------------------------------\n\nTITLE: Creating Mapped Enum Types with Integer Values in Ruby with dry-types\nDESCRIPTION: This example shows how to create enum mappings between human-readable strings and integer values. It demonstrates defining a Cell struct with a state attribute that maps strings like 'locked' and 'open' to integers 0 and 1, supporting input of either form.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/enum.html.md#2025-04-12_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\nclass Cell < Dry::Struct\n  attribute :state, Types::String.enum('locked' => 0, 'open' => 1)\nend\n\n\nCell.new(state: 'locked')\n# => #<Cell state=\"locked\">\n\n# Integers are accepted too\nCell.new(state: 0)\n# => #<Cell state=\"locked\">\nCell.new(state: 1)\n# => #<Cell state=\"open\">\n```\n\n----------------------------------------\n\nTITLE: Using Types.Value for Equality-Based Type Checking in Ruby\nDESCRIPTION: Creates a type that validates a value by equality (using ==). The example shows creating a validator that only accepts the string 'valid'.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/custom-types.html.md#2025-04-12_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nvalid = Types.Value('valid')\nvalid['valid'] # => 'valid'\nvalid['invalid']\n# => Dry::Types::ConstraintError: \"invalid\" violates constraints (eql?(\"valid\", \"invalid\") failed)\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Type Builders in Ruby with dry-types\nDESCRIPTION: Illustrates how to define custom type builders similar to .default, .constructor, or .optional in dry-types.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/CHANGELOG.md#2025-04-12_snippet_2\n\nLANGUAGE: Ruby\nCODE:\n```\n# Making an alias for `.fallback`\nDry::Types.define_builder(:or) { |type, v| type.fallback(v) }\n\n# Using new builder\ntype = Dry::Types['integer'].or(-273)\ntype.(:invalid) # => -273\n```\n\n----------------------------------------\n\nTITLE: DateTime Type with Callable Default Value in Ruby\nDESCRIPTION: Creates a DateTime type with a dynamic default value generated by a callable block. Each time the default is used, the current DateTime is returned, demonstrating how callable defaults work.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/default-values.html.md#2025-04-12_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nCallableDateTime = Types::DateTime.default { DateTime.now }\n\nCallableDateTime[]\n# => #<DateTime: 2017-05-06T00:43:06+03:00 ((2457879j,78186s,649279000n),+10800s,2299161j)>\nCallableDateTime[]\n# => #<DateTime: 2017-05-06T00:43:07+03:00 ((2457879j,78187s,635494000n),+10800s,2299161j)>\n```\n\n----------------------------------------\n\nTITLE: Transforming Types in Hash Schemas with dry-types\nDESCRIPTION: Demonstrates how to apply transformations to types within a hash schema, such as making all keys optional or adding custom constructors based on key names.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/hash-schemas.html.md#2025-04-12_snippet_6\n\nLANGUAGE: ruby\nCODE:\n```\nuser_hash = Types::Hash.with_type_transform { |type| type.required(false) }.schema(\n  name: Types::String,\n  age: Types::Integer\n)\n\nuser_hash[name: 'Jane']\n# => { name: 'Jane' }\nuser_hash[{}]\n# => {}\n```\n\nLANGUAGE: ruby\nCODE:\n```\nSymbolizeAndOptionalSchema = Types::Hash\n  .schema({})\n  .with_key_transform(&:to_sym)\n  .with_type_transform { |type| type.required(false) }\n\nuser_hash = SymbolizeAndOptionalSchema.schema(\n  name: Types::String,\n  age: Types::Integer\n)\n\nuser_hash['name' => 'Jane']\n```\n\nLANGUAGE: ruby\nCODE:\n```\nTypes::Hash.with_type_transform do |key|\n  if key.name.to_s.end_with?('_at')\n    key.constructor { |v| Time.iso8601(v) }\n  else\n    key\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Merging Hash Schemas in Ruby using dry-types\nDESCRIPTION: Demonstrates how to merge two hash schemas using the Schema#merge method in dry-types.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/CHANGELOG.md#2025-04-12_snippet_3\n\nLANGUAGE: Ruby\nCODE:\n```\n# Example not provided in the changelog\n```\n\n----------------------------------------\n\nTITLE: Basic Fallback Values in dry-types Ruby\nDESCRIPTION: Demonstrates how to set a static fallback value that will be returned when invalid input is provided to a type. When valid input is given, it's processed normally, but invalid input returns the fallback value.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/fallbacks.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\ntype = Dry::Types['integer'].fallback(100)\n\ntype.(99) # => 99\ntype.('99') # => 100\ntype.(:invalid) # => 100\n```\n\n----------------------------------------\n\nTITLE: Type Constructor with Default Value Receiving the Type in Ruby\nDESCRIPTION: Creates a DateTime type with a constructor and default block that receives the type itself as an argument. This allows using the type's constructor within the default value generator.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/default-values.html.md#2025-04-12_snippet_3\n\nLANGUAGE: ruby\nCODE:\n```\nCallableDateTime = Types::DateTime.constructor(&:to_datetime).default { |type| type[Time.now] }\n\nCallableDateTime[Time.now]\n# => #<DateTime: 2017-05-06T01:13:06+03:00 ((2457879j,79986s,63464000n),+10800s,2299161j)>\nCallableDateTime[Date.today]\n# => #<DateTime: 2017-05-06T00:00:00+00:00 ((2457880j,0s,0n),+0s,2299161j)>\nCallableDateTime[]\n# => #<DateTime: 2017-05-06T01:13:06+03:00 ((2457879j,79986s,63503000n),+10800s,2299161j)>\n```\n\n----------------------------------------\n\nTITLE: Implementing Fallbacks in Ruby using dry-types\nDESCRIPTION: Shows how to use the fallback feature in dry-types to provide a default value when coercion fails.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/CHANGELOG.md#2025-04-12_snippet_1\n\nLANGUAGE: Ruby\nCODE:\n```\nage = Dry::Types['coercible.ineger'].fallback(18)\nage.('10') # => 10\nage.('20') # => 20\nage.('abc') # => 18\n```\n\n----------------------------------------\n\nTITLE: Dynamic Fallbacks with Blocks in dry-types Ruby\nDESCRIPTION: Shows how to use a block for dynamic fallback values. The block is executed each time an invalid input is provided, allowing for more complex fallback behavior like incremental counters.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/fallbacks.html.md#2025-04-12_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\ncnt = 0\ntype = Dry::Types['integer'].fallback { cnt += 1 }\n\ntype.(99) # => 99\ntype.('99') # => 1\ntype.(:invalid) # => 2\n```\n\n----------------------------------------\n\nTITLE: Constructing New Types Based on Existing Types in Ruby\nDESCRIPTION: Shows the idiomatic approach to building types in dry-types by chaining methods like constructor and constrained on an existing type. Creates a constrained integer type that must be greater than or equal to 18.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/custom-type-builders.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nsource_type = Dry::Types['integer']\nconstructor_type = source_type.constructor(Kernel.method(:Integer))\nconstrained_type = constructor_type.constrained(gteq: 18)\n```\n\n----------------------------------------\n\nTITLE: Using Freeze to Protect Default Values in Ruby\nDESCRIPTION: Demonstrates a solution to the mutability problem by freezing the default value. This prevents unwanted mutations and provides guidelines for when mutation is actually needed.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/default-values.html.md#2025-04-12_snippet_5\n\nLANGUAGE: ruby\nCODE:\n```\nPostStatus = Types::Params::String.default('draft'.freeze)\ndefault = PostStatus.()\ndefault << 'attempt to mutate default'\n# => RuntimeError: can't modify frozen string\n\n# If you really want to mutate it, call `dup` on it first:\ndefault = default.dup\ndefault << \"this time it'll work\"\n```\n\n----------------------------------------\n\nTITLE: Combining Fallbacks with Default Values in dry-types Ruby\nDESCRIPTION: Demonstrates how fallbacks can be combined with default values. While defaults handle missing input, fallbacks handle invalid input, providing comprehensive input handling in schemas.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/fallbacks.html.md#2025-04-12_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\nschema = Dry::Types['hash'].schema(\n  size: Dry::Types['integer'].fallback(50).default(100)\n)\nschema.({}) # => { size: 100 }\nschema.({ size: 'invalid' }) # => { size: 50 }\n```\n\n----------------------------------------\n\nTITLE: Creating Optional Params Types in Ruby with dry-types\nDESCRIPTION: Shows how to use Optional::Params types that coerce empty strings to nil in dry-types.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/CHANGELOG.md#2025-04-12_snippet_4\n\nLANGUAGE: Ruby\nCODE:\n```\nDry::Types['optional.params.integer'].('') # => nil\nDry::Types['optional.params.integer'].('140') # => 140\nDry::Types['optional.params.integer'].('asd') # => exception!\n```\n\n----------------------------------------\n\nTITLE: Creating Interface Types for Method Presence Checking in Ruby\nDESCRIPTION: Creates types that validate whether a value responds to specific methods. The examples show creating types for callable objects and contact information.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/custom-types.html.md#2025-04-12_snippet_7\n\nLANGUAGE: ruby\nCODE:\n```\nCallable = Types.Interface(:call)\nContact = Types.Interface(:name, :phone)\n```\n\n----------------------------------------\n\nTITLE: Using Types.Instance for Class Type Checking in Ruby\nDESCRIPTION: Creates a type that validates if a value is an instance of the specified class. This example demonstrates creating a Range type validator.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/custom-types.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nrange_type = Types.Instance(Range)\nrange_type[1..2] # => 1..2\n```\n\n----------------------------------------\n\nTITLE: Defining Wrapping Constructor in Ruby using dry-types\nDESCRIPTION: Demonstrates how to create a wrapping constructor type that allows control over type application, including running it multiple times.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/CHANGELOG.md#2025-04-12_snippet_0\n\nLANGUAGE: Ruby\nCODE:\n```\nage_from_year = Dry::Types['coercible.integer'].constructor do |input, type|\n  Date.today.year - type.(input)\nend\nage_from_year.('2000') # => 21\n\ninc = Dry::Types['integer'].constructor(&:succ)\ninc2x = inc.constructor { _2.(_2.(_2.(_1))) }\ninc2x.(10) # => 13\n```\n\n----------------------------------------\n\nTITLE: Passing Undefined Explicitly to a Type with Default in Ruby\nDESCRIPTION: Demonstrates explicitly passing Dry::Types::Undefined to a type with a default value. The type returns the default value when given an undefined input.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/default-values.html.md#2025-04-12_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\nPostStatus = Types::String.default('draft')\n\nPostStatus[Dry::Types::Undefined] # \"draft\"\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Type Wrappers with Types.Nominal in Ruby\nDESCRIPTION: Wraps a given class with a simple type definition without any validation behavior. The example shows a nominal Integer type that doesn't perform validation.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/custom-types.html.md#2025-04-12_snippet_4\n\nLANGUAGE: ruby\nCODE:\n```\nint = Types.Nominal(Integer)\nint[1] # => 1\n\n# The type doesn't have any checks\nint['one'] # => 'one'\n```\n\n----------------------------------------\n\nTITLE: Filtering Empty Values in Array Types with Constructors in Ruby\nDESCRIPTION: Shows how to create an array type that filters out empty string values using a constructor type as its member. The constructor returns Undefined for empty strings, which are then filtered out.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/CHANGELOG.md#2025-04-12_snippet_20\n\nLANGUAGE: ruby\nCODE:\n```\nfilter_empty_strings = Types::Strict::Array.of(\n  Types::Strict::String.constructor { |input|\n    input.to_s.yield_self { |s| s.empty? ? Dry::Types::Undefined : s }\n  }\n)\nfilter_empty_strings.([\"John\", nil, \"\", \"Jane\"]) # => [\"John\", \"Jane\"]\n```\n\n----------------------------------------\n\nTITLE: Handling Strict String Type with nil Value\nDESCRIPTION: Demonstrates how strict string types handle nil values by default, which raises a constraint error.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/optional-values.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nTypes::Strict::String[nil]\n# => raises Dry::Types::ConstraintError\n```\n\n----------------------------------------\n\nTITLE: Creating Array Types with Element Constraints in Ruby\nDESCRIPTION: A shortcut for creating array types with constrained element types. The example creates a type for arrays that only contain string elements.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/custom-types.html.md#2025-04-12_snippet_6\n\nLANGUAGE: ruby\nCODE:\n```\nListOfStrings = Types.Array(Types::String)\n```\n\n----------------------------------------\n\nTITLE: Loading Extensions for dry-types in Ruby\nDESCRIPTION: This code snippet demonstrates how to load extensions for the dry-types gem. It uses the Dry::Types.load_extensions method to load the desired extensions.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/extensions.html.md#2025-04-12_snippet_0\n\nLANGUAGE: Ruby\nCODE:\n```\nDry::Types.load_extensions\n```\n\n----------------------------------------\n\nTITLE: Creating Interface Types in Ruby using dry-types\nDESCRIPTION: Shows how to construct a type which accepts objects that respond to given methods using the Interface builder method.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/CHANGELOG.md#2025-04-12_snippet_8\n\nLANGUAGE: Ruby\nCODE:\n```\nTypes = Dry.Types()\nTypes::Callable = Types.Interface(:call)\nTypes::Callable.valid?(Object.new) # => false\nTypes::Callable.valid?(proc {})    # => true\n```\n\n----------------------------------------\n\nTITLE: Using Constructor#append and Constructor#prepend for Function Chaining\nDESCRIPTION: Demonstrates how to chain functions with append and prepend operations. Append executes functions in order while prepend chains them in reverse order.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/CHANGELOG.md#2025-04-12_snippet_15\n\nLANGUAGE: ruby\nCODE:\n```\nto_int = Types::Coercible::Integer\ninc = to_int.append { |x| x + 2 }\ninc.(\"1\") # => \"1\" -> 1 -> 3\n\ninc = to_int.prepend { |x| x + \"2\" }\ninc.(\"1\") # => \"1\" -> \"12\" -> 12\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Metadata to Types in Ruby with dry-types\nDESCRIPTION: This example shows how to attach custom metadata to type definitions using the meta method. This metadata can be retrieved later via the schema for documentation or validation purposes.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/index.html.md#2025-04-12_snippet_5\n\nLANGUAGE: ruby\nCODE:\n```\nclass User < Dry::Struct\n  attribute :name, Types::String\n  attribute :age,  Types::Integer.meta(info: 'extra info about age')\nend\n\nUser.schema.key(:age).meta\n# => {:info=>\"extra info about age\"}\n```\n\n----------------------------------------\n\nTITLE: Creating Homogeneous Hash Types with Map in Ruby\nDESCRIPTION: Demonstrates how to use Types::Map to create a type for homogeneous hashes where only the types of keys and values are known in advance, not specific key names.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/CHANGELOG.md#2025-04-12_snippet_21\n\nLANGUAGE: ruby\nCODE:\n```\nint_to_string = Types::Hash.map('strict.integer', 'strict.string')\nint_to_string[0 => 'foo'] # => { 0 => \"foo\" }\nint_to_string[0 => 1] # Dry::Types::MapError: input value 1 for key 0 is invalid: type?(String, 1)\n```\n\n----------------------------------------\n\nTITLE: Converting Types to Procs for Use as Blocks\nDESCRIPTION: Demonstrates how types can be converted to procs and used as blocks in Ruby methods like map. This example shows converting strings to integers using the coercible integer type.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/CHANGELOG.md#2025-04-12_snippet_11\n\nLANGUAGE: ruby\nCODE:\n```\n%w(1 2 3).map(&Types::Coercible::Integer)\n# => [1, 2, 3]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Mutability Issues with Default Values in Ruby\nDESCRIPTION: Shows the potential problem with default values being the same instance each time, leading to unexpected mutations. Object identity is verified by comparing object_ids.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/default-values.html.md#2025-04-12_snippet_4\n\nLANGUAGE: ruby\nCODE:\n```\ndefault_0 = PostStatus.()\n# => \"draft\"\ndefault_1 = PostStatus.()\n# => \"draft\"\n\n# Both variables point to the same string:\ndefault_0.object_id == default_1.object_id\n# => true\n\n# Mutating the string will change the default value of type:\ndefault_0 << '_mutated'\nPostStatus.(nil)\n# => \"draft_mutated\" # not \"draft\"\n```\n\n----------------------------------------\n\nTITLE: Extending Type API with define_builder in Ruby\nDESCRIPTION: Demonstrates how to extend the dry-types API with a custom builder method using Dry::Types.define_builder. Creates an 'or' builder that provides fallback values for invalid inputs.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/custom-type-builders.html.md#2025-04-12_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nDry::Types.define_builder(:or) { |type, value| type.fallback(value) }\n\nsource_type = Dry::Types['integer']\ntype = source_type.or(0)\ntype.(10) # => 10\ntype.(:invalid) # => 0\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom Constructor Type with Block-Based Error Handling\nDESCRIPTION: Shows how to create a custom constructor type with proper error handling. The implementation handles both String and non-String inputs and uses the block parameter for failure cases.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/CHANGELOG.md#2025-04-12_snippet_10\n\nLANGUAGE: ruby\nCODE:\n```\nproc do |input, &block|\n  if input.is_a? String\n    Integer(input, 10)\n  else\n    Integer(input)\n  end\nrescue ArgumentError, TypeError => error\n  if block\n    block.call\n  else\n    raise Dry::Types::CoercionError.new(\n      error.message,\n      backtrace: error.backtrace\n    )\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Using Constructor Block with Failure Handling in Dry-Types\nDESCRIPTION: Example of using the constructor block feature that can pass a different value in case of failure. The block can handle the case when a string is empty after stripping.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/CHANGELOG.md#2025-04-12_snippet_9\n\nLANGUAGE: ruby\nCODE:\n```\nnot_empty_string = Types::String.constructor do |value, &failure|\n  value.strip.empty? ? failure.(nil) : value.strip\nend\nnot_empty_string.('   ') { |v| v } # => nil\nnot_empty_string.lax.('     ')     # => nil\nnot_empty_string.lax.(' foo  ')    # => \"foo\"\n```\n\n----------------------------------------\n\nTITLE: Mapping Methods on Maybe Objects in Ruby\nDESCRIPTION: This snippet demonstrates how to use #fmap and #value_or methods on Maybe objects returned by dry-types. It shows examples of applying methods to Some values and handling None cases.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/extensions/maybe.html.md#2025-04-12_snippet_3\n\nLANGUAGE: ruby\nCODE:\n```\nmaybe_string = Types::Strict::String.maybe\nmaybe_string[nil]                 # => None\nmaybe_string[nil].fmap(&:upcase)  # => None\nmaybe_string['something']                                    # => Some('something')\nmaybe_string['something'].fmap(&:upcase)                     # => Some('SOMETHING')\nmaybe_string['something'].fmap(&:upcase).value_or('NOTHING') # => \"SOMETHING\"\n```\n\n----------------------------------------\n\nTITLE: Warning About Constraints with Default Values in Ruby\nDESCRIPTION: Illustrates a potential pitfall when using default values with constrained types. Default values bypass the type constructor and constraints, which can lead to defaults that don't match the type's constraints.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/default-values.html.md#2025-04-12_snippet_6\n\nLANGUAGE: ruby\nCODE:\n```\nCallableDateTime = Types::DateTime.constructor(&:to_datetime).default { Time.now }\n\nCallableDateTime[Time.now]\n# => #<DateTime: 2017-05-06T00:50:09+03:00 ((2457879j,78609s,839588000n),+10800s,2299161j)>\nCallableDateTime[Date.today]\n# => #<DateTime: 2017-05-06T00:00:00+00:00 ((2457880j,0s,0n),+0s,2299161j)>\nCallableDateTime[]\n# => 2017-05-06 00:50:15 +0300\n```\n\n----------------------------------------\n\nTITLE: Verifying Dry::Types Setup in Ruby Console\nDESCRIPTION: Demonstrates how to check if Dry::Types is correctly set up by accessing a predefined type in the Ruby console. This helps confirm that the Types namespace is working as expected.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/getting-started.html.md#2025-04-12_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nTypes::Coercible::String\n# => #<Dry::Types::Constructor type=#<Dry::Types::Definition primitive=String options={}>>\n```\n\n----------------------------------------\n\nTITLE: Using to_monad Method with Dry Types Results\nDESCRIPTION: Demonstrates how to use the to_monad method to convert Dry::Types::Result objects into Dry::Monads::Result objects, showing both success and failure cases with various operations.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/extensions/monads.html.md#2025-04-12_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nresult = Types::String.try('Jane')\nresult.class            # => Dry::Types::Result::Success\nmonad = result.to_monad # => Success(\"Jane\")\nmonad.class             # => Dry::Monads::Result::Success\nmonad.value!            # => 'Jane'\n\nresult = Types::String.try(nil)\nresult.class            # => Dry::Types::Result::Failure\nmonad = result.to_monad # => Failure([...])\nmonad.class             # => Dry::Monads::Result::Failure\nmonad.failure           # => [#<Dry::Types::ConstraintError: ...>, nil]\nmonad\n  .fmap { |result| puts \"passed: #{result.inspect}\" }\n  .or   { |error, input| puts \"input '#{input.inspect}' failed with error: #{error.to_s}\" }\n```\n\n----------------------------------------\n\nTITLE: Defining Optional Hash Schema with Type Transforms in Ruby\nDESCRIPTION: Demonstrates how to create a hash schema where all keys are optional using type transforms. The resulting schema allows omitting keys without raising errors.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/CHANGELOG.md#2025-04-12_snippet_17\n\nLANGUAGE: ruby\nCODE:\n```\noptional_keys = Types::Hash.with_type_transform { |t, _key| t.optional }\nschema = optional_keys.schema(name: 'strict.string', age: 'strict.int')\nschema.(name: \"Jane\", age: nil) # => {name: \"Jane\", age: nil}\n```\n\n----------------------------------------\n\nTITLE: Using Types.Constant for Identity-Based Type Checking in Ruby\nDESCRIPTION: Creates a type that validates a value by identity (using equal?). This example demonstrates a type that only accepts the symbol :valid.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/custom-types.html.md#2025-04-12_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\nvalid = Types.Constant(:valid)\nvalid[:valid] # => :valid\nvalid[:invalid]\n# => Dry::Types::ConstraintError: :invalid violates constraints (is?(:valid, :invalid) failed)\n```\n\n----------------------------------------\n\nTITLE: Using Monads Extension in Ruby with dry-types\nDESCRIPTION: Demonstrates how to use the monads extension to add Dry::Types::Result#to_monad compatibility with do notation from dry-monads.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/CHANGELOG.md#2025-04-12_snippet_7\n\nLANGUAGE: Ruby\nCODE:\n```\nTypes = Dry.Types\nDry::Types.load_extensions(:monads)\n\nclass AddTen\n  include Dry::Monads[:result, :do]\n\n  def call(input)\n    integer = yield Types::Coercible::Integer.try(input)\n\n    Success(integer + 10)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Making Schema Keys Optional with meta(required: false)\nDESCRIPTION: Demonstrates how to use the meta attribute to make keys optional in a schema. This approach stores the required status in the type's metadata.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/CHANGELOG.md#2025-04-12_snippet_13\n\nLANGUAGE: ruby\nCODE:\n```\nDry::Types['hash'].schema(\n  name: Dry::Types['string'],\n  age: Dry::Types['integer'].meta(required: false)\n)\n```\n\n----------------------------------------\n\nTITLE: Defining YAML Front Matter for Combining Types Documentation\nDESCRIPTION: YAML front matter specifying the title, layout, gem name, and sections for the documentation page on combining types in dry-types.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/combining-types.html.md#2025-04-12_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\ntitle: Combining Types\nlayout: gem-single\nname: dry-types\nsections:\n  - intersection\n  - sum\n---\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Intersection Types in Ruby with dry-types\nDESCRIPTION: This code snippet demonstrates how to create and use intersection types in Ruby using the dry-types gem. It shows the creation of a Hash type that requires an 'id' key of Integer type, combined with a general Hash type. The resulting type enforces the presence of 'id' while allowing additional keys.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/combining-types/intersection.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nId = Types::Hash.schema(id: Types::Integer)\nHashWithId = Id & Types::Hash\n\nId[{id: 1}]                             # => {:id=>1}\nId[{id: 1, message: 'foo'}]             # => {:id=>1}\nId[{message: 'foo'}]                    # => Dry::Types::MissingKeyError: :id is missing in Hash input\n\nHashWithId[{ message: 'hello' }]        # => Dry::Types::MissingKeyError: :id is missing in Hash input\nHashWithId[{ id: 1, message: 'hello' }] # => {:id=>1, :message=>\"hello\"}\n```\n\n----------------------------------------\n\nTITLE: Using Predicate Inferrer in Ruby with dry-types\nDESCRIPTION: Demonstrates how to use the Predicate Inferrer to infer predicates from types in dry-types.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/CHANGELOG.md#2025-04-12_snippet_5\n\nLANGUAGE: Ruby\nCODE:\n```\nrequire 'dry/types/predicate_inferrer'\nDry::Types::PredicateInferrer.new[Types::String]\n# => [:str?]\nDry::Types::PredicateInferrer.new[Types::String | Types::Integer]\n# => [[[:str?], [:int?]]]\n```\n\n----------------------------------------\n\nTITLE: Using Primitive Inferrer in Ruby with dry-types\nDESCRIPTION: Shows how to use the Primitive Inferrer to infer primitives from types in dry-types.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/CHANGELOG.md#2025-04-12_snippet_6\n\nLANGUAGE: Ruby\nCODE:\n```\nrequire 'dry/types/primitive_inferrer'\nDry::Types::PrimitiveInferrer.new[Types::String]\n# => [String]\nDry::Types::PrimitiveInferrer.new[Types::String | Types::Integer]\n# => [String, Integer]\nDry::Types::PrimitiveInferrer.new[Types::String.optional]\n# => [NilClass, String]\n```\n\n----------------------------------------\n\nTITLE: Loading dry-monads and dry-types Maybe Extension in Ruby\nDESCRIPTION: This snippet shows how to load the dry-monads gem with Maybe and the dry-types :maybe extension in a Ruby application. It sets up the necessary requirements and includes the Dry::Monads[:maybe] module.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/extensions/maybe.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nrequire 'dry-monads'\ninclude Dry::Monads[:maybe] # This should be inside your class\nrequire 'dry-types'\n\nDry::Types.load_extensions(:maybe)\nTypes = Dry.Types()\n```\n\n----------------------------------------\n\nTITLE: Initializing Dry Types with Monads Extension\nDESCRIPTION: Shows how to load the :monads extension for dry-types and initialize the Types constant.\nSOURCE: https://github.com/dry-rb/dry-types/blob/main/docsite/source/extensions/monads.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nrequire 'dry/types'\nDry::Types.load_extensions(:monads)\nTypes = Dry.Types()\n```"
  }
]