[
  {
    "owner": "topjohnwu",
    "repo": "magisk",
    "content": "TITLE: MagiskSU Applet for Root Access Management\nDESCRIPTION: This section describes the su applet, which manages root privilege elevation within Magisk. It supports command execution, user and group specification, SELinux context changes, namespace handling, and environment preservation, facilitating controlled root access with customizable options.\nSOURCE: https://github.com/topjohnwu/magisk/blob/master/docs/tools.md#_snippet_16\n\nLANGUAGE: Shell\nCODE:\n```\nUsage: su [options] [-] [user [argument...]]\n\nOptions:\n  -c, --command COMMAND         Pass COMMAND to the invoked shell\n  -g, --group GROUP             Specify the primary group\n  -G, --supp-group GROUP        Specify a supplementary group.\n                                The first specified supplementary group is also used\n                                as a primary group if the option -g is not specified.\n  -Z, --context CONTEXT         Change SELinux context\n  -t, --target PID              PID to take mount namespace from\n  -h, --help                    Display this help message and exit\n  -, -l, --login                Pretend the shell to be a login shell\n  -m, -p,\n  --preserve-environment        Preserve the entire environment\n  -s, --shell SHELL             Use SHELL instead of the default /system/bin/sh\n  -v, --version                 Display version number and exit\n  -V                            Display version code and exit\n  -mm, -M,\n  --mount-master                Force run in the global mount namespace\n```\n\n----------------------------------------\n\nTITLE: Notes on Magisk Module Development and Boot Scripts\nDESCRIPTION: Provides important guidelines and constraints for module development, including handling of update-binary, naming restrictions, and cleanup procedures. Also explains the execution modes of boot scripts (`post-fs-data` and `late_start service`) and the context in which they operate, emphasizing best practices and potential pitfalls.\nSOURCE: https://github.com/topjohnwu/magisk/blob/master/docs/guides.md#_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\n- Do not modify `update-binary`, it is replaced with `module_installer.sh` during download.\n- Avoid adding an `install.sh` file in your module zip.\n- Do not call `exit` at the end of `customize.sh` to ensure cleanup.\n\n# Boot script modes:\n# - post-fs-data: blocking, runs before mounting, caution with `setprop` (use `resetprop` instead)\n# - late_start: non-blocking, recommended for most scripts\n\n# Script placement:\n# - General scripts in `/data/adb/post-fs-data.d` (post-fs-data mode) and `/data/adb/service.d` (late_start mode)\n# - Module scripts in module folder, executed when enabled (`post-fs-data.sh`, `service.sh`)\n\n# All scripts run in BusyBox 'ash' shell with Standalone Mode.\n\n```\n\n----------------------------------------\n\nTITLE: Repacking Boot Image with magiskboot\nDESCRIPTION: The `repack` action of `magiskboot` repacks boot image components, using files from the current directory into an output image.  It takes the original boot image as a dependency to preserve the original headers, and uses the original compression formats by default. The '-n' flag disables compression, and the environment variable `PATCHVBMETAFLAG` can modify the vbmeta header.\nSOURCE: https://github.com/topjohnwu/magisk/blob/master/docs/tools.md#_snippet_2\n\nLANGUAGE: Bash\nCODE:\n```\n  repack [-n] <origbootimg> [outbootimg]\n    Repack boot image components using files from the current directory\n    to [outbootimg], or 'new-boot.img' if not specified. Current directory\n    should only contain required files for [outbootimg], or incorrect\n    [outbootimg] may be produced.\n    <origbootimg> is the original boot image used to unpack the components.\n    By default, each component will be automatically compressed using its\n    corresponding format detected in <origbootimg>. If a component file\n    in the current directory is already compressed, then no addition\n    compression will be performed for that specific component.\n    If '-n' is provided, all compression operations will be skipped.\n    If env variable PATCHVBMETAFLAG is set to true, all disable flags in\n    the boot image's vbmeta header will be set.\n```\n\n----------------------------------------\n\nTITLE: Magisk Module Structure Example\nDESCRIPTION: This code block illustrates the directory structure of a Magisk module. It shows key components such as the module's ID folder, module.prop, the system folder for injected files, zygisk for native libraries, status flags like skip_mount, and optional scripts and files.\nSOURCE: https://github.com/topjohnwu/magisk/blob/master/docs/guides.md#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n/data/adb/modules\n├── .\n├── .\n│\n├── $MODID                  <--- The folder is named with the ID of the module\n│   │\n│   │      *** Module Identity ***\n│   │\n│   ├── module.prop         <--- This file stores the metadata of the module\n│   │\n│   │      *** Main Contents ***\n│   │\n│   ├── system              <--- This folder will be mounted if skip_mount does not exist\n│   │   ├── ...\n│   │   ├── ...\n│   │   └── ...\n│   │\n│   ├── zygisk              <--- This folder contains the module's Zygisk native libraries\n│   │   ├── arm64-v8a.so\n│   │   ├── armeabi-v7a.so\n│   │   ├── riscv64.so\n│   │   ├── x86.so\n│   │   ├── x86_64.so\n│   │   └── unloaded        <--- If exists, the native libraries are incompatible\n│   │\n│   │      *** Status Flags ***\n│   │\n│   ├── skip_mount          <--- If exists, Magisk will NOT mount your system folder\n│   ├── disable             <--- If exists, the module will be disabled\n│   ├── remove              <--- If exists, the module will be removed next reboot\n│   │\n│   │      *** Optional Files ***\n│   │\n│   ├── post-fs-data.sh     <--- This script will be executed in post-fs-data\n│   ├── service.sh          <--- This script will be executed in late_start service\n|   ├── uninstall.sh        <--- This script will be executed when Magisk removes your module\n|   ├── action.sh           <--- This script will be executed when user click the action button in Magisk app\n│   ├── system.prop         <--- Properties in this file will be loaded as system properties by resetprop\n│   ├── sepolicy.rule       <--- Additional custom sepolicy rules\n│   │\n│   │      *** Auto Generated, DO NOT MANUALLY CREATE OR MODIFY ***\n│   │\n│   ├── vendor              <--- A symlink to $MODID/system/vendor\n│   ├── product             <--- A symlink to $MODID/system/product\n│   ├── system_ext          <--- A symlink to $MODID/system/system_ext\n│   │\n│   │      *** Any additional files / folders are allowed ***\n│   │\n│   ├── ...\n│   └── ...\n|\n├── another_module\n│   ├── .\n│   └── .\n├── .\n├── .\n```\n\n----------------------------------------\n\nTITLE: SELinux Policies Patch for Magisk\nDESCRIPTION: Provides an overview of modifications to the stock SELinux policies, creating a permissive `magisk` domain, permitting root and Magisk operations, and defining new file types and transition rules to maintain sandbox integrity.\nSOURCE: https://github.com/topjohnwu/magisk/blob/master/docs/details.md#_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\nN/A  // Only conceptual description provided, not raw code.\n```\n\n----------------------------------------\n\nTITLE: DTB Operations with magiskboot\nDESCRIPTION: The `dtb` action of `magiskboot` performs operations on device tree blobs (DTBs), including printing and patching. The patch action removes verity/avb and is controlled by the KEEPVERITY environment variable.  Modifications are done directly to the file in-place.\nSOURCE: https://github.com/topjohnwu/magisk/blob/master/docs/tools.md#_snippet_8\n\nLANGUAGE: Bash\nCODE:\n```\n  dtb <file> <action> [args...]\n    Do dtb related actions to <file>\n    Supported actions:\n      print [-f]\n        Print all contents of dtb for debugging\n        Specify [-f] to only print fstab nodes\n      patch\n        Search for fstab and remove verity/avb\n        Modifications are done directly to the file in-place\n        Configure with env variables: KEEPVERITY\n      test\n        Test the fstab's status\n        Return values:\n        0:valid    1:error\n```\n\n----------------------------------------\n\nTITLE: Verifying Boot Image Signature with magiskboot\nDESCRIPTION: The `verify` action in `magiskboot` checks if the boot image has an AVB 1.0 signature. Optionally, it allows verification against a provided X.509 certificate.\nSOURCE: https://github.com/topjohnwu/magisk/blob/master/docs/tools.md#_snippet_3\n\nLANGUAGE: Bash\nCODE:\n```\n  verify <bootimg> [x509.pem]\n    Check whether the boot image is signed with AVB 1.0 signature.\n    Optionally provide a certificate to verify whether the image is\n    signed by the public key certificate.\n    Return value:\n    0:valid    1:error\n```\n\n----------------------------------------\n\nTITLE: Magisk Post-FS-Data Boot Phase\nDESCRIPTION: Describes actions after `/data` is decrypted and mounted, such as launching `magiskd`, executing post-fs-data scripts, and mounting modules for runtime enhancements.\nSOURCE: https://github.com/topjohnwu/magisk/blob/master/docs/details.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nN/A  // No specific code snippet provided, only phases described in text.\n```\n\n----------------------------------------\n\nTITLE: Regex for Module ID validation\nDESCRIPTION: This snippet defines the regular expression used to validate the `id` field within the `module.prop` file. It enforces the naming rules for module identifiers, ensuring they are unique and follow a specific format for compatibility.\nSOURCE: https://github.com/topjohnwu/magisk/blob/master/docs/guides.md#_snippet_3\n\nLANGUAGE: regex\nCODE:\n```\n^[a-zA-Z][a-zA-Z0-9._-]+$\n```\n\n----------------------------------------\n\nTITLE: Listing Magisk Binaries and Symlinks\nDESCRIPTION: This snippet lists the Magisk binaries and their associated symlinks. It serves as an overview of the available tools within the Magisk environment. This information is used in the initial setup and command handling of the Magisk installation.\nSOURCE: https://github.com/topjohnwu/magisk/blob/master/docs/tools.md#_snippet_0\n\nLANGUAGE: Bash\nCODE:\n```\nmagiskboot                 /* binary */\nmagiskinit                 /* binary */\nmagiskpolicy               /* binary */\nsupolicy -> magiskpolicy\nmagisk                     /* binary */\nresetprop -> magisk\nsu -> magisk\n```\n\n----------------------------------------\n\nTITLE: Resetprop Utility for System Property Management\nDESCRIPTION: This section explains resetprop, an advanced utility for reading, setting, deleting, and loading system properties on Android. It supports verbose output, bypassing property_service, and persistent storage options to facilitate system customization and debugging.\nSOURCE: https://github.com/topjohnwu/magisk/blob/master/docs/tools.md#_snippet_17\n\nLANGUAGE: Shell\nCODE:\n```\nUsage: resetprop [flags] [options...]\n\nOptions:\n   -h, --help        show this message\n   (no arguments)    print all properties\n   NAME              get property\n   NAME VALUE        set property entry NAME with VALUE\n   --file FILE       load props from FILE\n   --delete NAME     delete property\n\nFlags:\n   -v      print verbose output to stderr\n   -n      set props without going through property_service\n           (this flag only affects setprop)\n   -p      read/write props from/to persistent storage\n           (this flag only affects getprop and delprop)\n```\n\n----------------------------------------\n\nTITLE: Root Directory Overlay System and File Management\nDESCRIPTION: Explains how the overlay system allows modifications to the read-only root filesystem by injecting or replacing files via `overlay.d`. Describes the rules for placing `*.rc` scripts, `*.sbin` files, and other assets, including the handling of `${MAGISKTMP}` for Android 11+ compatibility. Provides an example directory structure and sample `custom.rc` script for injecting commands.\nSOURCE: https://github.com/topjohnwu/magisk/blob/master/docs/guides.md#_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\n# Overlay files are placed in `overlay.d` directory in boot ramdisk:\n# - `*.rc` files are read and concatenated or replaced in init.rc\n# - Files with the same relative path replace existing files\n# - Non-existent files are ignored\n\n# `sbin` folder contents are directly copied to Magisk's internal tmpfs or `/debug_ramdisk` on Android 11+\n\n# `${MAGISKTMP}` is a placeholder for the Magisk tmpfs directory, replaced during init.\n\n# Example `custom.rc`:\n#\n# on early-init\n#     setprop sys.example.foo bar\n#     insmod ${MAGISKTMP}/libfoo.ko\n#     start myservice\n#\n# service myservice ${MAGISKTMP}/myscript.sh\n#     oneshot\n```\n\n----------------------------------------\n\nTITLE: Signing Boot Image with magiskboot\nDESCRIPTION: The `sign` action of `magiskboot` signs a boot image with an AVB 1.0 signature.  It can use a provided certificate/private key pair, or use the AOSP verity key if none are provided.\nSOURCE: https://github.com/topjohnwu/magisk/blob/master/docs/tools.md#_snippet_4\n\nLANGUAGE: Bash\nCODE:\n```\n  sign <bootimg> [name] [x509.pem pk8]\n    Sign <bootimg> with AVB 1.0 signature.\n    Optionally provide the name of the image (default: '/boot').\n    Optionally provide the certificate/private key pair for signing.\n    If the certificate/private key pair is not provided, the AOSP\n    verity key bundled in the executable will be used.\n```\n\n----------------------------------------\n\nTITLE: CPIO Operations with magiskboot\nDESCRIPTION: The `cpio` action of `magiskboot` enables various operations on cpio archives, including add, remove, extract, and test.  It modifies the archive in-place and is configured with environment variables for ramdisk patching and backup/restore.\nSOURCE: https://github.com/topjohnwu/magisk/blob/master/docs/tools.md#_snippet_7\n\nLANGUAGE: Bash\nCODE:\n```\n  cpio <incpio> [commands...]\n    Do cpio commands to <incpio> (modifications are done in-place)\n    Each command is a single argument, add quotes for each command.\n    Supported commands:\n      exists ENTRY\n        Return 0 if ENTRY exists, else return 1\n      rm [-r] ENTRY\n        Remove ENTRY, specify [-r] to remove recursively\n      mkdir MODE ENTRY\n        Create directory ENTRY in permissions MODE\n      ln TARGET ENTRY\n        Create a symlink to TARGET with the name ENTRY\n      mv SOURCE DEST\n        Move SOURCE to DEST\n      add MODE ENTRY INFILE\n        Add INFILE as ENTRY in permissions MODE; replaces ENTRY if exists\n      extract [ENTRY OUT]\n        Extract ENTRY to OUT, or extract all entries to current directory\n      test\n        Test the cpio's status\n        Return value is 0 or bitwise or-ed of following values:\n        0x1:Magisk    0x2:unsupported\n      patch\n        Apply ramdisk patches\n        Configure with env variables: KEEPVERITY KEEPFORCEENCRYPT\n      backup ORIG\n        Create ramdisk backups from ORIG\n      restore\n        Restore ramdisk from ramdisk backup stored within incpio\n```\n\n----------------------------------------\n\nTITLE: Magisk Late Start Service Mode\nDESCRIPTION: Details the late_start phase triggering Magisk service mode, executing service scripts to initialize background and long-running processes during boot.\nSOURCE: https://github.com/topjohnwu/magisk/blob/master/docs/details.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\nN/A  // No specific code snippet provided, only phases described in text.\n```\n\n----------------------------------------\n\nTITLE: Extracting Partition from Payload with magiskboot\nDESCRIPTION: The `extract` action of `magiskboot` extracts a specific partition from a `payload.bin` file.  If the output file is not specified, the tool defaults to '[partition].img'. If no partition is specified, the tool attempts to extract either 'init_boot' or 'boot' partitions.\nSOURCE: https://github.com/topjohnwu/magisk/blob/master/docs/tools.md#_snippet_5\n\nLANGUAGE: Bash\nCODE:\n```\n  extract <payload.bin> [partition] [outfile]\n    Extract [partition] from <payload.bin> to [outfile].\n    If [outfile] is not specified, then output to '[partition].img'.\n    If [partition] is not specified, then attempt to extract either\n    'init_boot' or 'boot'. Which partition was chosen can be determined\n    by whichever 'init_boot.img' or 'boot.img' exists.\n    <payload.bin> can be '-' to be STDIN.\n```\n\n----------------------------------------\n\nTITLE: Magisk Tmpfs Directory Path Variables Initialization\nDESCRIPTION: Defines variables to determine the base directory for Magisk's temporary files, supporting conditional paths for devices with or without `/sbin` directory, and sets internal directory paths for configuration and modules.\nSOURCE: https://github.com/topjohnwu/magisk/blob/master/docs/details.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# In order to get the current base folder Magisk is using,\n# use the command `magisk --path`.\n# Binaries like magisk, magiskinit, and all symlinks to\n# applets are directly stored in this path. This means when\n# this is /sbin, these binaries will be directly in PATH.\nMAGISKTMP=$(magisk --path)\n\n# Magisk internal stuffs\nINTERNALDIR=$MAGISKTMP/.magisk\n```\n\n----------------------------------------\n\nTITLE: Decompressing Files with magiskboot\nDESCRIPTION: The `decompress` action of `magiskboot` decompresses a file, automatically detecting the format.  If no output file is specified, the original file is replaced after removing the archive format's extension.\nSOURCE: https://github.com/topjohnwu/magisk/blob/master/docs/tools.md#_snippet_13\n\nLANGUAGE: Bash\nCODE:\n```\n  decompress <infile> [outfile]\n    Detect format and decompress <infile> to [outfile].\n    <infile>/[outfile] can be '-' to be STDIN/STDOUT.\n    If [outfile] is not specified, then <infile> will be replaced\n    with another file removing its archive format file extension.\n    Supported formats: gzip zopfli xz lzma bzip2 lz4 lz4_legacy lz4_lg\n```\n\n----------------------------------------\n\nTITLE: Variable Definitions for Magisk Module Installation\nDESCRIPTION: Defines key environment variables used during Magisk module installation and configuration, including version info, paths, architecture, and API level. These variables facilitate dynamic setup and compatibility checks within installation scripts.\nSOURCE: https://github.com/topjohnwu/magisk/blob/master/docs/guides.md#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\n- `MAGISK_VER`: version string of installed Magisk (e.g., `v20.0`)\n- `MAGISK_VER_CODE`: numeric version code (e.g., `20000`)\n- `BOOTMODE`: boolean indicating installation mode\n- `MODPATH`: path where module files are installed\n- `TMPDIR`: temporary storage directory\n- `ZIPFILE`: path to the module's zip file\n- `ARCH`: CPU architecture (`arm`, `arm64`, `x86`, `x64`, `riscv64`)\n- `IS64BIT`: boolean for 64-bit architecture\n- `API`: Android API level number\n```\n\n----------------------------------------\n\nTITLE: Description of magiskpolicy SELinux Policy Modification Tool\nDESCRIPTION: This section explains the magiskpolicy command-line tool used for modifying SELinux policies on Android. It supports operations such as loading, compiling, applying rules, and applying specific policy statements, with dependencies on the SELinux binary and appropriate system permissions.\nSOURCE: https://github.com/topjohnwu/magisk/blob/master/docs/tools.md#_snippet_14\n\nLANGUAGE: Shell\nCODE:\n```\nThis tool could be used for advanced developers to modify SELinux policies. In common scenarios like Linux server admins, they would directly modify the SELinux policy sources (\"*.te\") and recompile the sepolicy binary, but here on Android we directly patch the binary file (or runtime policies).\n\nAll processes spawned from the Magisk daemon, including root shells and all its forks, are running in the context \"u:r:magisk:s0\". The rule used on all Magisk installed systems can be viewed as stock sepolicy with these patches: \"magiskpolicy --magisk 'allow magisk * * *'\".\n\nUsage: ./magiskpolicy [--options...] [policy statements...]\nOptions:\n   --help            show help message for policy statements\n   --load FILE       load monolithic sepolicy from FILE\n   --load-split      load from precompiled sepolicy or compile split cil policies\n   --compile-split   compile split cil policies\n   --save FILE       dump monolithic sepolicy to FILE\n   --live            immediately load sepolicy into the kernel\n   --magisk          apply built-in Magisk sepolicy rules\n   --apply FILE      apply rules from FILE, read and parsed line by line as policy statements\n                     (multiple --apply are allowed)\n\nStatements have a format of \"<rule_name> [args...]\".\nArguments labeled with (^) can accept one or more entries. Multiple entries consist of a space separated list enclosed in braces ({}).\nArguments labeled with (*) are the same as (^), but additionally support the match-all operator (*).\n\nSupported policy statements:\n\"allow *source_type *target_type *class *perm_set\"\n\"deny *source_type *target_type *class *perm_set\"\n\"auditallow *source_type *target_type *class *perm_set\"\n\"dontaudit *source_type *target_type *class *perm_set\"\n\n\"allowxperm *source_type *target_type *class operation xperm_set\"\n\"auditallowxperm *source_type *target_type *class operation xperm_set\"\n\"dontauditxperm *source_type *target_type *class operation xperm_set\"\n- The only supported operation is 'ioctl'\n- xperm_set format is either 'low-high', 'value', or '*'.\n  '*' will be treated as '0x0000-0xFFFF'.\n  All values should be written in hexadecimal.\n\n\"permissive ^type\"\n\"enforce ^type\"\n\n\"typeattribute ^type ^attribute\"\n\n\"type type_name ^(attribute)\"\n- Argument 'attribute' is optional, default to 'domain'\n\n\"attribute attribute_name\"\n\n\"type_transition source_type target_type class default_type (object_name)\"\n- Argument 'object_name' is optional\n\n\"type_change source_type target_type class default_type\"\n\"type_member source_type target_type class default_type\"\n\n\"genfscon fs_name partial_path fs_context\"\n```\n\n----------------------------------------\n\nTITLE: Calculating SHA1 Checksum with magiskboot\nDESCRIPTION: The `sha1` action of `magiskboot` computes and prints the SHA1 checksum for a given file.  This allows users to verify the integrity of files.\nSOURCE: https://github.com/topjohnwu/magisk/blob/master/docs/tools.md#_snippet_10\n\nLANGUAGE: Bash\nCODE:\n```\n  sha1 <file>\n    Print the SHA1 checksum for <file>\n```\n\n----------------------------------------\n\nTITLE: Standalone Mode Enablement Options\nDESCRIPTION: This snippet demonstrates two methods for enabling BusyBox's standalone mode outside of Magisk's context. This mode ensures that shell commands use BusyBox applets, regardless of the system's PATH variable.\nSOURCE: https://github.com/topjohnwu/magisk/blob/master/docs/guides.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nASH_STANDALONE=1 /data/adb/magisk/busybox sh <script>\n/data/adb/magisk/busybox sh -o standalone <script>\n```\n\n----------------------------------------\n\nTITLE: Cleaning up with magiskboot\nDESCRIPTION: The `cleanup` action of `magiskboot` clears the current working directory, making it easier to prepare files for the next operation.\nSOURCE: https://github.com/topjohnwu/magisk/blob/master/docs/tools.md#_snippet_11\n\nLANGUAGE: Bash\nCODE:\n```\n  cleanup\n    Cleanup the current working directory\n```\n\n----------------------------------------\n\nTITLE: Magisk module.prop example\nDESCRIPTION: This code describes the required and optional fields within the module.prop file used to define a Magisk Module. This file provides the modules metadata. It dictates how the module is identified and how it interacts with Magisk.\nSOURCE: https://github.com/topjohnwu/magisk/blob/master/docs/guides.md#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nid=<string>\nname=<string>\nversion=<string>\nversionCode=<int>\nauthor=<string>\ndescription=<string>\nupdateJson=<url> (optional)\n```\n\n----------------------------------------\n\nTITLE: Magisk Update JSON Example\nDESCRIPTION: This example presents the JSON format that is downloaded from the updateJson URL specified in `module.prop`. This allows the Magisk app to update modules dynamically with the latest information.\nSOURCE: https://github.com/topjohnwu/magisk/blob/master/docs/guides.md#_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"version\": string,\n    \"versionCode\": int,\n    \"zipUrl\": url,\n    \"changelog\": url\n}\n```\n\n----------------------------------------\n\nTITLE: Core Functions for Magisk Module Installation Scripts\nDESCRIPTION: Provides essential functions to communicate with the user, handle errors, and set file permissions during module installation. These functions abstract common shell commands to streamline installation scripts and ensure proper permission handling.\nSOURCE: https://github.com/topjohnwu/magisk/blob/master/docs/guides.md#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\nui_print <msg>\n    # Prints a message to the console, avoiding 'echo' for visibility in recovery\n\nabort <msg>\n    # Prints an error message and terminates the installation, replacing 'exit'\n\nset_perm <target> <owner> <group> <permission> [context]\n    # Sets ownership, permissions, and security context of a target file/directory\n    # Defaults context to \"u:object_r:system_file:s0\" if not specified\n\nset_perm_recursive <directory> <owner> <group> <dirpermission> <filepermission> [context]\n    # Recursively sets permissions for directories and files within a specified directory, with optional security context\n\n```\n\n----------------------------------------\n\nTITLE: Magisk Booting Pre-Init Phase\nDESCRIPTION: Outlines the initial boot sequence with magiskinit replacing init, including partition mounting, service injection, sepolicy handling, and executing the original init to continue boot.\nSOURCE: https://github.com/topjohnwu/magisk/blob/master/docs/details.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nN/A  // No specific code snippet provided, only phases described in text.\n```\n\n----------------------------------------\n\nTITLE: Compressing Files with magiskboot\nDESCRIPTION: The `compress` action of `magiskboot` compresses a file using the specified format (gzip, zopfli, xz, lzma, bzip2, lz4, lz4_legacy, lz4_lg).  If no format is specified, gzip is used, and if no output file is provided, the original file will be replaced with the compressed version.\nSOURCE: https://github.com/topjohnwu/magisk/blob/master/docs/tools.md#_snippet_12\n\nLANGUAGE: Bash\nCODE:\n```\n  compress[=format] <infile> [outfile]\n    Compress <infile> with [format] to [outfile].\n    <infile>/[outfile] can be '-' to be STDIN/STDOUT.\n    If [format] is not specified, then gzip will be used.\n    If [outfile] is not specified, then <infile> will be replaced\n    with another file suffixed with a matching file extension.\n    Supported formats: gzip zopfli xz lzma bzip2 lz4 lz4_legacy lz4_lg\n```\n\n----------------------------------------\n\nTITLE: Flash Patched Boot Image via Fastboot\nDESCRIPTION: This command flashes the patched boot image to the device using Fastboot. It's essential to replace `/path/to/magisk_patched_[random_strings].img` with the actual path to the patched image on your computer. The device must be in fastboot mode for this command to work. Bootloader must be unlocked.\nSOURCE: https://github.com/topjohnwu/magisk/blob/master/docs/install.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nfastboot flash boot /path/to/magisk_patched_[random_strings].img\n```\n\n----------------------------------------\n\nTITLE: Flash Patched Init_Boot Image via Fastboot\nDESCRIPTION: This command flashes the patched init_boot image to the device using Fastboot. It's essential to replace `/path/to/magisk_patched_[random_strings].img` with the actual path to the patched image on your computer. The device must be in fastboot mode for this command to work. Bootloader must be unlocked. This command is used when the device has an init_boot partition instead of a boot partition.\nSOURCE: https://github.com/topjohnwu/magisk/blob/master/docs/install.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nfastboot flash init_boot /path/to/magisk_patched_[random_strings].img\n```\n\n----------------------------------------\n\nTITLE: Linking and Setting Default Rust Toolchain Using Rustup - Bash\nDESCRIPTION: This snippet links the ONDK (Magisk NDK) bundled Rust toolchain with a custom name ('magisk') via the rustup toolchain manager for per-project Rust compilation, and then sets it as the default for the current user session or shell. Required dependencies are rustup (installed via the official Rust site) and the ONDK toolkit (installed using ./build.py ndk). The key parameters are the toolchain name (magisk) and the path to the ONDK Rust toolchain, provided via the ANDROID_HOME environment variable. Upon execution, all rustup-based Rust commands (cargo, rustc, etc.) will use the magisk toolchain by default.\nSOURCE: https://github.com/topjohnwu/magisk/blob/master/docs/build.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Link the ONDK toolchain with the name \"magisk\"\nrustup toolchain link magisk \"$ANDROID_HOME/ndk/magisk/toolchains/rust\"\n# Set magisk as default\nrustup default magisk\n```\n\n----------------------------------------\n\nTITLE: Using resetprop with wait flag in Shell\nDESCRIPTION: Introduces and demonstrates the new `-w` (wait) flag for the `resetprop` command in Magisk v27.0. This flag causes the command to block execution until a specified system property becomes available or changes, enabling scripting scenarios that depend on property state.\nSOURCE: https://github.com/topjohnwu/magisk/blob/master/docs/releases/27000.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nresetprop -w\n```\n\n----------------------------------------\n\nTITLE: Flash Patched Recovery Image via Fastboot\nDESCRIPTION: This command flashes the patched recovery image to the device using Fastboot. Replace `/path/to/magisk_patched_[random_strings].img` with the actual path. The device must be in fastboot mode.  This is used when installing Magisk on devices without a ramdisk in the boot partition. Bootloader must be unlocked.\nSOURCE: https://github.com/topjohnwu/magisk/blob/master/docs/install.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nfastboot flash recovery /path/to/magisk_patched_[random_strings].img\n```\n\n----------------------------------------\n\nTITLE: Splitting Images with magiskboot\nDESCRIPTION: The `split` action of `magiskboot` splits an image.*-dtb file into kernel and kernel_dtb components. This is useful for extracting specific image components.\nSOURCE: https://github.com/topjohnwu/magisk/blob/master/docs/tools.md#_snippet_9\n\nLANGUAGE: Bash\nCODE:\n```\n  split <file>\n    Split image.*-dtb into kernel + kernel_dtb\n```\n\n----------------------------------------\n\nTITLE: Flash VBMeta Partition via Fastboot\nDESCRIPTION: This command disables verity and verification on the vbmeta partition using Fastboot. This step is optional and may result in data loss. The device must be in fastboot mode, and the vbmeta.img file needs to be present in the current directory. Bootloader must be unlocked.\nSOURCE: https://github.com/topjohnwu/magisk/blob/master/docs/install.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nfastboot flash vbmeta --disable-verity --disable-verification vbmeta.img\n```\n\n----------------------------------------\n\nTITLE: Getting Magisk tmpfs Path (Shell)\nDESCRIPTION: This command is used to retrieve the current dynamic path of Magisk's internal tmpfs directory on Android 11 and later, where the traditional /sbin location may no longer be used. It is primarily useful for developers needing to interact with Magisk's internal files.\nSOURCE: https://github.com/topjohnwu/magisk/blob/master/docs/releases/21000.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nmagisk --path\n```\n\n----------------------------------------\n\nTITLE: Creating a Cargo Wrapper Directory for Rustup Integration - Bash\nDESCRIPTION: This snippet generates a wrapper directory for the cargo binary to overcome rustup toolchain path limitations when configuring IDEs like Jetbrains Rustrover. It calls the Magisk project’s build script with the 'rustup' argument and a specified directory path (e.g., ~/.cargo/wrapper). The only prerequisite is a working Python environment and Magisk's build.py script. The primary parameter is the destination directory for the wrapper, which the IDE should reference in Rust toolchain configuration. This enables proper toolchain discovery and usage in supported IDEs.\nSOURCE: https://github.com/topjohnwu/magisk/blob/master/docs/build.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# We choose ~/.cargo/wrapper here as an example (and a good recommendation)\n# Pick any path you like, you just need to use this path in the next step\n./build.py rustup ~/.cargo/wrapper\n```\n\n----------------------------------------\n\nTITLE: ADB Command to Remove Magisk Modules\nDESCRIPTION: This ADB command is used to remove all installed Magisk modules and automatically reboot the device. It requires USB debugging to be enabled on the Android device and the device to be accessible via ADB.\nSOURCE: https://github.com/topjohnwu/magisk/blob/master/docs/faq.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nmagisk --remove-modules\n```\n\n----------------------------------------\n\nTITLE: Magisk Utility Main Command-Line Interface\nDESCRIPTION: This section describes the primary magisk command-line utility used to manage the Magisk framework, including version info, service control, module management, and internal APIs. It allows users to perform actions like listing applets, removing modules, and executing internal commands for system modifications.\nSOURCE: https://github.com/topjohnwu/magisk/blob/master/docs/tools.md#_snippet_15\n\nLANGUAGE: Shell\nCODE:\n```\nWhen the magisk binary is called with the name \"magisk\", it works as a utility tool with many helper functions and the entry points for several Magisk services.\n\nUsage: magisk [applet [arguments]...]\n   or: magisk [options]...\nOptions:\n   -c                        print current binary version\n   -v                        print running daemon version\n   -V                        print running daemon version code\n   --list                    list all available applets\n   --remove-modules [-n]     remove all modules, reboot if -n is not provided\n   --install-module ZIP      install a module zip file\n\nAdvanced Options (Internal APIs):\n   --daemon                  manually start magisk daemon\n   --stop                    remove all magisk changes and stop daemon\n   --[init trigger]          callback on init triggers. Valid triggers:\n                             post-fs-data, service, boot-complete, zygote-restart\n   --unlock-blocks           set BLKROSET flag to OFF for all block devices\n   --restorecon              restore selinux context on Magisk files\n   --clone-attr SRC DEST     clone permission, owner, and selinux context\n   --clone SRC DEST          clone SRC to DEST\n   --sqlite SQL              exec SQL commands to Magisk database\n   --path                    print Magisk tmpfs mount path\n   --denylist ARGS           denylist config CLI\n   --preinit-device          resolve a device to store preinit files\n\nAvailable applets:\n    su, resetprop\n\nUsage: magisk --denylist [action [arguments...] ]\nActions:\n   status          Return the enforcement status\n   enable          Enable denylist enforcement\n   disable         Disable denylist enforcement\n   add PKG [PROC]  Add a new target to the denylist\n   rm PKG [PROC]   Remove target(s) from the denylist\n   ls              Print the current denylist\n   exec CMDs...    Execute commands in isolated mount\n                   namespace and do all unmounts\n```\n\n----------------------------------------\n\nTITLE: Installing Rust Nightly Toolchain and Components for IDE Integration - Bash\nDESCRIPTION: This snippet installs the official Rust nightly toolchain and adds essential components ('rust-src', 'clippy') needed for IDE features such as code completion and external linting. Dependencies include rustup and internet connectivity. Parameters include specifying the nightly toolchain with '+nightly'. This setup is primarily for IDE compatibility (not active build usage), particularly for Jetbrains IDEs integrating with Rust analyzer tools. The outcome is an IDE-aware Rust development environment mirroring Magisk’s build context.\nSOURCE: https://github.com/topjohnwu/magisk/blob/master/docs/build.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nrustup toolchain install nightly\n# Add some components that is also included in ONDK\nrustup +nightly component add rust-src clippy\n```\n\n----------------------------------------\n\nTITLE: Installing Magisk on Emulator Using Build Script\nDESCRIPTION: This Python script, `build.py`, is used to temporarily install Magisk on an Android emulator. The script takes the emulator flag and the path to the Magisk APK as arguments. The installation is not persistent across reboots.\nSOURCE: https://github.com/topjohnwu/magisk/blob/master/docs/faq.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\n./build.py emulator <path to Magisk APK>\n```\n\n----------------------------------------\n\nTITLE: Pull Patched Tar via ADB (Samsung)\nDESCRIPTION: This command pulls the patched AP tar file (for Samsung devices) from the device to the host computer using ADB.  The file is located in /sdcard/Download/magisk_patched_[random_strings].tar. It is recommended to use ADB instead of MTP to avoid file corruption.\nSOURCE: https://github.com/topjohnwu/magisk/blob/master/docs/install.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\nadb pull /sdcard/Download/magisk_patched_[random_strings].tar\n```\n\n----------------------------------------\n\nTITLE: Magisk Module Installer example\nDESCRIPTION: This code block illustrates the structure of a Magisk module installer packaged as a zip file, including the META-INF directory with the update-binary and updater-script, and an optional customize.sh script for module-specific customization.\nSOURCE: https://github.com/topjohnwu/magisk/blob/master/docs/guides.md#_snippet_5\n\nLANGUAGE: text\nCODE:\n```\nmodule.zip\n│\n├── META-INF                           <--- Only needed for flashing in recovery\n│   └── com\n│       └── google\n│           └── android\n│               ├── update-binary      <--- The module_installer.sh you downloaded\n│               └── updater-script     <--- Should only contain the string \"#MAGISK\"\n│\n├── customize.sh                       <--- (Optional, more details later)\n│                                           This script will be sourced by update-binary\n├── ...\n├── ...  /* The rest of module's files */\n│\n```\n\n----------------------------------------\n\nTITLE: Device Data Storage and Security in /data/adb\nDESCRIPTION: Defines environment variables and paths for secure, undetectable storage of Magisk-related data in `/data/adb`, ensuring permissions, security context, and compatibility with encrypted storage.\nSOURCE: https://github.com/topjohnwu/magisk/blob/master/docs/details.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nSECURE_DIR=/data/adb\n\n# Folder storing general post-fs-data scripts\n$SECURE_DIR/post-fs-data.d\n\n# Folder storing general late_start service scripts\n$SECURE_DIR/service.d\n\n# Magisk modules\n$SECURE_DIR/modules\n\n# Magisk modules that are pending for upgrade\n# Module files are not safe to be modified when mounted\n# Modules installed through the Magisk app will be stored here\n# and will be merged into $SECURE_DIR/modules in the next reboot\n$SECURE_DIR/modules_update\n\n# Database storing settings and root permissions\nMAGISKDB=$SECURE_DIR/magisk.db\n\n# All magisk related binaries, including busybox,\n# scripts, and magisk binaries. Used in supporting\n# module installation, addon.d, the Magisk app etc.\nDATABIN=$SECURE_DIR/magisk\n```\n\n----------------------------------------\n\nTITLE: Pull Patched Image via ADB\nDESCRIPTION: This command retrieves the patched Magisk image from the device's storage to the host computer using ADB (Android Debug Bridge).  The patched image is located in the /sdcard/Download directory and named magisk_patched_[random_strings].img. ADB is required and the device must be connected and authorized.\nSOURCE: https://github.com/topjohnwu/magisk/blob/master/docs/install.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nadb pull /sdcard/Download/magisk_patched_[random_strings].img\n```\n\n----------------------------------------\n\nTITLE: Unpacking Boot Image with magiskboot\nDESCRIPTION: The `unpack` action of `magiskboot` extracts the components of a boot image.  It supports extracting kernel, kernel_dtb, ramdisk.cpio, second, dtb, extra, and recovery_dtbo. The '-n' flag disables decompression, and '-h' outputs header information.\nSOURCE: https://github.com/topjohnwu/magisk/blob/master/docs/tools.md#_snippet_1\n\nLANGUAGE: Bash\nCODE:\n```\nUsage: ./magiskboot <action> [args...]\n\nSupported actions:\n  unpack [-n] [-h] <bootimg>\n    Unpack <bootimg> to its individual components, each component to\n    a file with its corresponding file name in the current directory.\n    Supported components: kernel, kernel_dtb, ramdisk.cpio, second,\n    dtb, extra, and recovery_dtbo.\n    By default, each component will be automatically decompressed\n    on-the-fly before writing to the output file.\n    If '-n' is provided, all decompression operations will be skipped;\n    each component will remain untouched, dumped in its original format.\n    If '-h' is provided, the boot image header information will be\n    dumped to the file 'header', which can be used to modify header\n    configurations during repacking.\n    Return values:\n    0:valid    1:error    2:chromeos\n```\n\n----------------------------------------\n\nTITLE: Magisk Internal Directory Paths for Modules and Configurations\nDESCRIPTION: Sets up internal directory paths within Magisk's tmpfs for storing modules, configuration, partition mirrors, and root directory patches, accounting for devices with different filesystem layouts.\nSOURCE: https://github.com/topjohnwu/magisk/blob/master/docs/details.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# /data/adb/modules will be bind mounted here.\n# The original folder is not used due to nosuid mount flag.\n$INTERNALDIR/modules\n\n# The current Magisk installation config\n$INTERNALDIR/config\n\n# Partition mirrors\n# Each directory in this path will be mounted with the\n# partition of its directory name.\n# e.g. system, system_ext, vendor, data ...\n$INTERNALDIR/mirror\n\n# Root directory patch files\n# On system-as-root devices, / is not writable.\n# All pre-init patched files are stored here and bind mounted.\n$INTERNALDIR/rootdir\n```\n\n----------------------------------------\n\nTITLE: Configuration Variables for Overlay and Removal in Modules\nDESCRIPTION: Specifies lists of folders (`REPLACE`) and files (`REMOVE`) that should be replaced or removed during module installation. The installer creates `.replace` files or dummy devices accordingly to facilitate customization and cleanup.\nSOURCE: https://github.com/topjohnwu/magisk/blob/master/docs/guides.md#_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\nREPLACE=\"/system/app/YouTube\n/system/app/Bloatware\"\n# Creates .replace files in specified directories to enable overlay replacements\n\nREMOVE=\"/system/app/YouTube\n/system/fonts/Roboto.ttf\"\n# Creates dummy devices for specified files and directories for cleanup\n```\n\n----------------------------------------\n\nTITLE: resetprop System Property Modification Tool\nDESCRIPTION: Implements a modified `setprop` utility that bypasses the normal property service restrictions, allowing root users to change read-only system properties and manage persistent properties with optional flags.\nSOURCE: https://github.com/topjohnwu/magisk/blob/master/docs/details.md#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\nN/A  // The actual source code for resetprop is not included, only its functional description.\n```\n\n----------------------------------------\n\nTITLE: Hex Patching Binaries with magiskboot\nDESCRIPTION: The `hexpatch` action of `magiskboot` performs a hex-based search and replace operation on a given file, useful for modifying binary contents.\nSOURCE: https://github.com/topjohnwu/magisk/blob/master/docs/tools.md#_snippet_6\n\nLANGUAGE: Bash\nCODE:\n```\n  hexpatch <file> <hexpattern1> <hexpattern2>\n    Search <hexpattern1> in <file>, and replace it with <hexpattern2>\n```"
  }
]