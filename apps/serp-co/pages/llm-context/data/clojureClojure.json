[
  {
    "owner": "clojure",
    "repo": "clojure",
    "content": "TITLE: Defining Record and Accessing Field in Clojure\nDESCRIPTION: This snippet shows how to define a record type using `defrecord` and how to access its property using the dot special form (`.-`). This aligns Clojure field lookup syntax with ClojureScript's.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_40\n\nLANGUAGE: Clojure\nCODE:\n```\n(defrecord Foo [x]) ;=> user.Foo\n(.-x (Foo. 10)) ;=> 10\n```\n\n----------------------------------------\n\nTITLE: Basic Pretty Printing Usage in Clojure\nDESCRIPTION: This snippet demonstrates how to use the `pprint` function to pretty print a Clojure data structure. It requires the `clojure.pprint` namespace to be loaded. The output will be formatted according to the default `*simple-dispatch*` table.\nSOURCE: https://github.com/clojure/clojure/blob/master/doc/clojure/pprint/PrettyPrinting.markdown#_snippet_0\n\nLANGUAGE: Clojure\nCODE:\n```\n(use 'clojure.pprint)\n(pprint (for [x (range 10)] (range x)))\n```\n\n----------------------------------------\n\nTITLE: Using reduce-kv in Clojure\nDESCRIPTION: This snippet demonstrates `reduce-kv`, a function that reduces an associative collection by applying a function to an initial value, a key, and a value. It shows its usage with both maps and vectors, highlighting how keys are the ordinals in the case of vectors.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_39\n\nLANGUAGE: Clojure\nCODE:\n```\n(reduce-kv str \"Hello \" {:w \\o :r \\l :d \\!})\n;=> \"Hello :rl:d!:wo\"\n(reduce-kv str \"Hello \" [\\w \\o \\r \\l \\d \\!])\n;=> \"Hello 0w1o2r3l4d5!\"\n```\n\n----------------------------------------\n\nTITLE: Accessing Clojure Functions from Java\nDESCRIPTION: This Java code snippet demonstrates how to access and call Clojure functions from Java using the `clojure.java.api.Clojure` class. It retrieves a Clojure var (function) by its namespace and name and then invokes it with arguments. It shows how to access the '+' function from the 'clojure.core' namespace and invokes it with the arguments 1 and 2.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_19\n\nLANGUAGE: Java\nCODE:\n```\nIFn plus = Clojure.var(\"clojure.core\", \"+\");\nplus.invoke(1, 2);\n```\n\n----------------------------------------\n\nTITLE: Message Bearing Assert in Clojure\nDESCRIPTION: The `assert` macro can take an optional second argument which serves as a message that will be printed when the assertion fails. This provides more context about the failure.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_51\n\nLANGUAGE: Clojure\nCODE:\n```\n(assert (= 1 2) \"1 is not equal to 2\")\n```\n\n----------------------------------------\n\nTITLE: Clojure data/diff example\nDESCRIPTION: The `clojure.data/diff` function recursively compares two data structures (a and b) and returns a tuple containing elements unique to a, elements unique to b, and elements present in both.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_42\n\nLANGUAGE: Clojure\nCODE:\n```\n(diff {:a 1 :b 2} {:a 1 :b 22 :c 3})\n=> ({:b 2} {:c 3, :b 22} {:a 1})\n```\n\n----------------------------------------\n\nTITLE: Starting a Socket Server with REPL - Clojure\nDESCRIPTION: This example demonstrates how to start a socket server with a REPL listener in Clojure using a JVM system property.  The property defines the port and the function to invoke upon socket acceptance, which in this case is the `clojure.core.server/repl` function. This allows external REPL clients to connect to the running Clojure program.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_9\n\nLANGUAGE: Clojure\nCODE:\n```\n-Dclojure.server.repl=\"{:port 5555 :accept clojure.core.server/repl}\"\n```\n\n----------------------------------------\n\nTITLE: Using filterv in Clojure\nDESCRIPTION: This snippet demonstrates `filterv`, a function that takes a predicate and a collection, returning a vector of items for which the predicate returns true. It illustrates how to filter elements based on a condition.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_37\n\nLANGUAGE: Clojure\nCODE:\n```\n(= [] (filterv even? [1 3 5]))\n;=> true\n\n(= [2 4] (filterv even? [1 2 3 4 5]))\n;=> true\n```\n\n----------------------------------------\n\nTITLE: every-pred example in Clojure\nDESCRIPTION: This demonstrates the use of `every-pred`, which takes a set of predicate functions and returns a function that checks if all predicates return true for the given arguments.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_43\n\nLANGUAGE: Clojure\nCODE:\n```\n((every-pred even?) 2 4 6)\n=> true\n\n((every-pred even?) 2 4 5)\n=>false\n```\n\n----------------------------------------\n\nTITLE: Printing a Table with Column-Aware Streams\nDESCRIPTION: This function takes a nested list and prints it as a table, returning the result as a string. It creates a StringWriter and wraps it with a pretty-writer using get-pretty-writer to track column positions. Inside a binding to *out*, it iterates over rows and columns, formatting each column with ~4D~7,vT for right-justified integers and spacing based on column-width.\nSOURCE: https://github.com/clojure/clojure/blob/master/doc/clojure/pprint/CommonLispFormat.markdown#_snippet_4\n\nLANGUAGE: Clojure\nCODE:\n```\n(defn list-to-table [aseq column-width]\n  (let [string-writer (java.io.StringWriter.)\n        stream (get-pretty-writer string-writer)]\n    (binding [*out* stream]\n      (doseq [row aseq]\n        (doseq [col row]\n          (cl-format true \"~4D~7,vT\" col column-width))\n        (prn)))\n    (.flush stream)\n    (.toString string-writer)))\n```\n\n----------------------------------------\n\nTITLE: Interoperating with Java Streams using Clojure\nDESCRIPTION: Presents the functions provided by Clojure to interoperate with Java Streams in an idiomatic manner. These functions include `stream-seq!`, `stream-reduce!`, `stream-transduce!`, and `stream-into!`.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_6\n\nLANGUAGE: Clojure\nCODE:\n```\n`(stream-seq! stream) => seq`\n```\n\nLANGUAGE: Clojure\nCODE:\n```\n`(stream-reduce! f [init-val] stream) => val`\n```\n\nLANGUAGE: Clojure\nCODE:\n```\n`(stream-transduce! xf f [init-val] stream) => val`\n```\n\nLANGUAGE: Clojure\nCODE:\n```\n`(stream-into! to-coll [xf] stream) => to-coll`\n```\n\n----------------------------------------\n\nTITLE: Type Hinting on Argument Vectors in Clojure\nDESCRIPTION: This snippet shows how to apply type hints to argument vectors in Clojure function definitions. Different arities of the function can be hinted separately.  This is preferred over hinting the function name, as the latter may be deprecated in the future.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_58\n\nLANGUAGE: Clojure\nCODE:\n```\n(defn hinted\n  (^String [])\n  (^Integer [a])\n  (^java.util.List [a & args]))\n```\n\n----------------------------------------\n\nTITLE: deref with timeout in Clojure\nDESCRIPTION: The `deref` function now supports a timeout option. When used with a blocking reference (like a promise), it will return the specified timeout-val if the value is not available within the given timeout period (in milliseconds).\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_53\n\nLANGUAGE: Clojure\nCODE:\n```\n(deref (promise) 10 :ethel)\n```\n\n----------------------------------------\n\nTITLE: Using update function in Clojure\nDESCRIPTION: This example demonstrates the use of the `update` function in Clojure to modify a value associated with a key in a map. The function takes a map, a key, and a function to apply to the value associated with the key. If the key is not present, nil is returned.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_15\n\nLANGUAGE: Clojure\nCODE:\n```\n(update {:a 1} :a inc)\n(update {:a 1} :a + 2)\n(update {} :a identity)\n```\n\n----------------------------------------\n\nTITLE: Using Code Dispatch for Pretty Printing in Clojure\nDESCRIPTION: This snippet demonstrates how to use the `with-pprint-dispatch` function to temporarily set the dispatch table to `*code-dispatch*` for pretty printing. It shows how code structures like `defn` are formatted with special indentation.\nSOURCE: https://github.com/clojure/clojure/blob/master/doc/clojure/pprint/PrettyPrinting.markdown#_snippet_3\n\nLANGUAGE: Clojure\nCODE:\n```\n(def code '(defn cl-format \n    \"An implementation of a Common Lisp compatible format function\"\n    [stream format-in & args] (let [compiled-format (if (string? format-in) \n    (compile-format format-in) format-in) navigator (init-navigator args)] \n    (execute-format stream compiled-format navigator))))\n(with-pprint-dispatch *code-dispatch* (pprint code))\n```\n\n----------------------------------------\n\nTITLE: Pretty Printing the Last Output Value in REPL - Clojure\nDESCRIPTION: This example illustrates how to use the `pp` macro in the Clojure REPL to pretty print the last output value (bound to the `*1` variable). This is a convenient way to format complex data structures for better readability.\nSOURCE: https://github.com/clojure/clojure/blob/master/doc/clojure/pprint/PrettyPrinting.markdown#_snippet_2\n\nLANGUAGE: Clojure\nCODE:\n```\n(pp)\n```\n\n----------------------------------------\n\nTITLE: Dynamic Binding Conveyance in Clojure\nDESCRIPTION: This snippet illustrates that Clojure APIs that pass work to other threads (e.g., `send`, `send-off`, `pmap`, `future`) now convey the dynamic bindings of the calling thread.  This ensures that the correct dynamic variables are available in the new thread's context.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_59\n\nLANGUAGE: Clojure\nCODE:\n```\n(def ^:dynamic *num* 1)\n(binding [*num* 2] (future (println *num*)))\n```\n\n----------------------------------------\n\nTITLE: Using the run! function in Clojure\nDESCRIPTION: This snippet demonstrates the usage of the new `run!` function in Clojure 1.6. `run!` applies a side-effect reducing function to each item in a collection. In this example, `println` is used to print each number in the range from 1 to 9.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_18\n\nLANGUAGE: Clojure\nCODE:\n```\n(run! println (range 10))\n```\n\n----------------------------------------\n\nTITLE: Printing a Sequence with cl-format\nDESCRIPTION: This snippet uses cl-format to print the elements of a sequence separated by commas. The ~{~a~^, ~} directive iterates through the sequence (aseq) and prints each element (~a), adding a comma and space between elements (~^, ~). The true argument specifies that the output should be written to *out*.\nSOURCE: https://github.com/clojure/clojure/blob/master/doc/clojure/pprint/CommonLispFormat.markdown#_snippet_3\n\nLANGUAGE: Clojure\nCODE:\n```\n(cl-format true \"~{~a~^, ~}\" aseq)\n```\n\n----------------------------------------\n\nTITLE: with-redefs example in Clojure\nDESCRIPTION: The `with-redefs` macro temporarily redefines Vars within a specific scope. In this example, `nil?` is temporarily redefined to `:temp` within the `println` call.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_46\n\nLANGUAGE: Clojure\nCODE:\n```\n(with-redefs [nil? :temp] (println nil?))\n=> :temp\n```\n\n----------------------------------------\n\nTITLE: Using mapv in Clojure\nDESCRIPTION: This snippet showcases the use of `mapv`, which applies a function to elements from one or more collections and returns the results as a vector. It demonstrates `mapv` with one and two collections, showing how it iterates until the shortest collection is exhausted.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_36\n\nLANGUAGE: Clojure\nCODE:\n```\n(= [1 2 3] (mapv + [1 2 3]))\n;=> true\n\n(= [2 3 4] (mapv + [1 2 3] (repeat 1)))\n;=> true\n```\n\n----------------------------------------\n\nTITLE: Transforming to a Set using Reducers in Clojure\nDESCRIPTION: This snippet demonstrates transforming a collection into a set using filtering and mapping operations from the clojure.core.reducers library.  The filtered and mapped sequence is transformed into a set containing only the even incremented values.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_31\n\nLANGUAGE: Clojure\nCODE:\n```\n\tuser=> (into #{} (r/filter even? (r/map inc [1 1 1 2])))\n```\n\n----------------------------------------\n\nTITLE: Passing Clojure Functions to Higher-Order Functions in Java\nDESCRIPTION: This Java code snippet demonstrates how to pass Clojure functions to other Clojure higher-order functions using the `clojure.java.api.Clojure` class. It retrieves the `map` and `inc` functions and then invokes `map` with `inc` as an argument, along with a collection read from a string. This showcases the interoperability between Java and Clojure's functional programming features.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_21\n\nLANGUAGE: Java\nCODE:\n```\nIFn map = Clojure.var(\"clojure.core\", \"map\");\nIFn inc = Clojure.var(\"clojure.core\", \"inc\");\nmap.invoke(inc, Clojure.read(\"[1 2 3]\"));\n```\n\n----------------------------------------\n\nTITLE: Defining Constants with ^:const in Clojure\nDESCRIPTION: The `^:const` metadata allows you to define constants that are resolved at compile time, resulting in faster access.  The overhead of the map lookup for `:e` and `:pi` occurs during compilation.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_50\n\nLANGUAGE: Clojure\nCODE:\n```\n(def constants\n {:pi 3.14\n  :e 2.71})\n\n(def ^:const pi (:pi constants))\n(def ^:const e (:e constants))\n```\n\n----------------------------------------\n\nTITLE: Requiring Reducers Namespace in Clojure\nDESCRIPTION: This snippet demonstrates how to require the clojure.core.reducers namespace and use it in a simple example. It shows how to filter even numbers and increment them using the reducers library and then reduce the result by summing them.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_28\n\nLANGUAGE: Clojure\nCODE:\n```\n\tuser=> (require '[clojure.core.reducers :as r])\n```\n\n----------------------------------------\n\nTITLE: Filtering and Mapping with Reducers in Clojure\nDESCRIPTION: This snippet showcases filtering even numbers and mapping to increment them using the clojure.core.reducers library. The filtered and mapped sequence is then reduced by summing the elements.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_29\n\nLANGUAGE: Clojure\nCODE:\n```\n\tuser=> (reduce + (r/filter even? (r/map inc [1 1 1 2])))\n```\n\n----------------------------------------\n\nTITLE: Map Destructuring with Auto-Resolved Keywords in Clojure\nDESCRIPTION: This Clojure code snippet showcases map destructuring with auto-resolved keywords using `:keys`. It allows using keywords directly in the `:keys` form, providing support for auto-resolved keywords.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_25\n\nLANGUAGE: Clojure\nCODE:\n```\n(let [m {:x/a 1, :y/b 2}\n      {:keys [:x/a :y/b]} m]\n  (+ a b))\n```\n\n----------------------------------------\n\nTITLE: Map Destructuring with Namespaced Keys in Clojure\nDESCRIPTION: This Clojure code snippet showcases the extended map destructuring feature to support namespaced keys using `:keys`. It defines a map with namespaced keys and then uses destructuring to bind the values associated with those keys to local variables.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_23\n\nLANGUAGE: Clojure\nCODE:\n```\n(let [m {:x/a 1, :y/b 2}\n      {:keys [x/a y/b]} m]\n  (+ a b))\n```\n\n----------------------------------------\n\nTITLE: Map Destructuring with Namespaced Symbols in Clojure\nDESCRIPTION: This Clojure code snippet demonstrates map destructuring with namespaced keys using `:syms`. It defines a map with namespaced keys and uses destructuring to bind the values associated with those keys to local variables represented as symbols.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_24\n\nLANGUAGE: Clojure\nCODE:\n```\n(let [m {'x/a 1, 'y/b 2}\n      {:syms [x/a y/b]} m]\n  (+ a b))\n```\n\n----------------------------------------\n\nTITLE: Writing to a Stream with Pretty Printing in Clojure\nDESCRIPTION: This snippet shows how to use the `write` function with the `:pretty` and `:stream` options to write a Clojure object to a specified stream using pretty printing. It assumes that `foo` is a valid stream object.\nSOURCE: https://github.com/clojure/clojure/blob/master/doc/clojure/pprint/PrettyPrinting.markdown#_snippet_1\n\nLANGUAGE: Clojure\nCODE:\n```\n(write obj :pretty true :stream foo)\n```\n\n----------------------------------------\n\nTITLE: Binding *print-length* for Limited Length Printing in Clojure\nDESCRIPTION: This snippet demonstrates binding the `*print-length*` variable to control the maximum number of items printed at each level of a structure. If a level contains more items than specified, ellipses (...) are used to indicate the remaining items.\nSOURCE: https://github.com/clojure/clojure/blob/master/doc/clojure/pprint/PrettyPrinting.markdown#_snippet_5\n\nLANGUAGE: Clojure\nCODE:\n```\n(defn foo [x] (for [i (range x) ] (range 1 (- x (dec i)))))\n(binding [*print-length* 6] (pprint (foo 10)))\n```\n\n----------------------------------------\n\nTITLE: Map Namespace Syntax in Clojure\nDESCRIPTION: Introduces the map namespace syntax for specifying the default namespace context for keys (or symbols) within a map, simplifying the use of qualified keys. This feature allows for a more concise and readable representation of maps with namespaced keys by declaring the namespace only once.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_8\n\nLANGUAGE: Clojure\nCODE:\n```\n#:car{:make \"Jeep\" :model \"Wrangler\"}\n```\n\n----------------------------------------\n\nTITLE: Defining Instant Literal in Clojure\nDESCRIPTION: This snippet demonstrates how to define an instant literal in Clojure using the `#inst` tag. It shows how Clojure parses these literals as `java.util.Date` objects by default and how to read them as `java.util.Calendar` or `java.util.Timestamp` objects by binding `*data-readers*`.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_35\n\nLANGUAGE: Clojure\nCODE:\n```\n(def instant \"#inst \\\"@2010-11-12T13:14:15.666\\\"\")\n\n; Instants are read as java.util.Date by default\n(= java.util.Date (class (read-string instant)))\n;=> true\n\n; Instants can be read as java.util.Calendar or java.util.Timestamp\n\n(binding [*data-readers* {'inst read-instant-calendar}]\n  (= java.util.Calendar (class (read-string instant))))\n;=> true\n\n(binding [*data-readers* {'inst read-instant-timestamp}]\n  (= java.util.Timestamp (class (read-string instant))))\n;=> true\n```\n\n----------------------------------------\n\nTITLE: pst usage example in Clojure REPL\nDESCRIPTION: The `pst` function, located in the `clojure.repl` namespace, prints a stack trace of an exception. This is helpful for debugging Clojure code in the REPL.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_48\n\nLANGUAGE: Clojure\nCODE:\n```\n(pst (IllegalArgumentException.))\n```\n\n----------------------------------------\n\nTITLE: realized? usage example in Clojure\nDESCRIPTION: This snippet shows how to use the `realized?` function to check if a value has been produced for a lazy sequence. The output demonstrates that the sequence is not realized until `first` is called on it.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_45\n\nLANGUAGE: Clojure\nCODE:\n```\n(let [x (range 5)]\n  (println (realized? x))\n  (first x)\n  (println (realized? x)))\n=> false\n=> true\n```\n\n----------------------------------------\n\nTITLE: Coercing Clojure functions to Functional Interfaces\nDESCRIPTION: Illustrates how to explicitly coerce a Clojure function to a Java functional interface by providing a type hint in a `let` binding. This avoids repeated adapter construction in loops.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_5\n\nLANGUAGE: Clojure\nCODE:\n```\n`(let [^java.util.function.Predicate p even?] ...)`\n```\n\n----------------------------------------\n\nTITLE: Setting Warn on Boxed Math in Clojure\nDESCRIPTION: This example demonstrates how to enable warnings for boxed math operations in Clojure. The *unchecked-math* dynamic var is set to :warn-on-boxed to trigger warnings when arithmetic is performed on boxed numbers. Type hints can be used to avoid boxing.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_13\n\nLANGUAGE: Clojure\nCODE:\n```\n(set! *unchecked-math* :warn-on-boxed)\n```\n\n----------------------------------------\n\nTITLE: Binding *print-level* for Limited Depth Printing - Clojure\nDESCRIPTION: This snippet shows how to bind the `*print-level*` variable to limit the depth of nested structures that are printed. Any structure deeper than the specified level will be represented by a hash sign (#).\nSOURCE: https://github.com/clojure/clojure/blob/master/doc/clojure/pprint/PrettyPrinting.markdown#_snippet_4\n\nLANGUAGE: Clojure\nCODE:\n```\n(binding [*print-level* 2] (pprint '(a b (c d) ((e) ((f d) g)))))\n```\n\n----------------------------------------\n\nTITLE: Dumping Java System Properties with cl-format\nDESCRIPTION: This function uses cl-format to display Java system properties in a columnized table. It retrieves the properties, sorts them by key, and formats them using ~30A~A~%~{~20,,,'-A~10A~}~%~{~30A~S~%~}. This format string creates a header and then prints the properties in two columns, with some properties formatted using ~20,,,'-A.\nSOURCE: https://github.com/clojure/clojure/blob/master/doc/clojure/pprint/CommonLispFormat.markdown#_snippet_5\n\nLANGUAGE: Clojure\nCODE:\n```\n(defn show-props [stream]\n  (let [p (mapcat \n\t       #(vector (key %) (val %)) \n\t       (sort-by key (System/getProperties)))]\n    (cl-format stream \"~30A~A~%~{~20,,,'-A~10A~}~%~{~30A~S~%~}\" \n\t           \"Property\" \"Value\" [\"\" \"\" \"\" \"\"] p)))\n```\n\n----------------------------------------\n\nTITLE: Add docstring to def in Clojure\nDESCRIPTION: A `def` form can now include a docstring between the name of the var and its value.  This enhances the documentation capabilities for variables.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_56\n\nLANGUAGE: Clojure\nCODE:\n```\n(def foo \"a foo\" :foo)\n```\n\n----------------------------------------\n\nTITLE: some-fn example in Clojure\nDESCRIPTION: This example illustrates the `some-fn` combinator. It takes a set of predicates and returns a function that returns the first logical true value returned by one of its composing predicates against any of its arguments, else it returns logical false.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_44\n\nLANGUAGE: Clojure\nCODE:\n```\n((some-fn even?) 2 4 5)\n=> true\n((some-fn odd?) 2 4 6)\n=> false\n```\n\n----------------------------------------\n\nTITLE: Qualifying Instance Method Calls in Clojure\nDESCRIPTION: This shows how to call an instance method on a Java object from Clojure using the `Classname/.method` syntax. The resulting value is a Clojure function that invokes the instance method on a suitable object.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_1\n\nLANGUAGE: Clojure\nCODE:\n```\n`Classname/.method`\n```\n\n----------------------------------------\n\nTITLE: vector-of with Multiple Arguments in Clojure\nDESCRIPTION: The `vector-of` function can now take multiple arguments, which are used to populate the array.  The type is specified as the first argument, and subsequent arguments are the values for the array.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_52\n\nLANGUAGE: Clojure\nCODE:\n```\n(vector-of :int 1 2 3)\n```\n\n----------------------------------------\n\nTITLE: print-table example in Clojure\nDESCRIPTION: The `print-table` function, located in `clojure.pprint`, prints a collection of maps in a textual table format. The first argument is a sequence of keys to display as columns, and the second argument is the collection of maps.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_49\n\nLANGUAGE: Clojure\nCODE:\n```\n(print-table [:fred :barney]\n             [{:fred \"ethel\"}\n              {:fred \"wilma\" :barney \"betty\"}])\n```\n\n----------------------------------------\n\nTITLE: Disabling XML External Entity Processing in clojure.xml/parse (Clojure)\nDESCRIPTION: This snippet demonstrates how to explicitly use `startparse-sax` when calling `clojure.xml/parse` to maintain previous behavior with external entities enabled. It is used to prevent XML external entity (XXE) attacks, which can disclose local files.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_7\n\nLANGUAGE: Clojure\nCODE:\n```\n(clojure.xml/parse the-string clojure.xml/startparse-sax)\n```\n\n----------------------------------------\n\nTITLE: Qualifying Static Method Calls in Clojure\nDESCRIPTION: This demonstrates how to call a static Java method from Clojure using the `Classname/method` syntax. It creates a Clojure function that, when invoked, executes the static method.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_0\n\nLANGUAGE: Clojure\nCODE:\n```\n`Classname/method`\n```\n\n----------------------------------------\n\nTITLE: Aliasing cl-format to format in Clojure\nDESCRIPTION: This snippet demonstrates how to alias the cl-format function to format, which is helpful when porting code from Common Lisp where format is a common function name.  It excludes the standard Clojure format function and then defines format as an alias for cl-format. It requires clojure.pprint to be in your project's classpath.\nSOURCE: https://github.com/clojure/clojure/blob/master/doc/clojure/pprint/CommonLispFormat.markdown#_snippet_1\n\nLANGUAGE: Clojure\nCODE:\n```\n(ns your-namespace-here\n  (:refer-clojure :exclude [format])\n  (:use clojure.pprint))\n\n(def format cl-format)\n```\n\n----------------------------------------\n\nTITLE: Invoking Java Constructors in Clojure\nDESCRIPTION: This example illustrates using the `Classname/new` syntax to call a Java constructor from Clojure. The return value is a Clojure function that instantiates new Java objects.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_2\n\nLANGUAGE: Clojure\nCODE:\n```\n`Classname/new`\n```\n\n----------------------------------------\n\nTITLE: Using cl-format in a Clojure Namespace\nDESCRIPTION: This snippet demonstrates how to include the cl-format function from the clojure.pprint namespace in your Clojure code.  It imports only the cl-format function, preventing naming conflicts with other functions named format.  This approach requires clojure.pprint to be in your project's classpath.\nSOURCE: https://github.com/clojure/clojure/blob/master/doc/clojure/pprint/CommonLispFormat.markdown#_snippet_0\n\nLANGUAGE: Clojure\nCODE:\n```\n(ns your-namespace-here\n  (:use [clojure.pprint :only (cl-format)]))\n```\n\n----------------------------------------\n\nTITLE: Using cl-format from the Clojure REPL\nDESCRIPTION: This snippet demonstrates how to include the cl-format function from the clojure.pprint namespace in your Clojure REPL session. This makes the cl-format function available for use in the REPL. It requires clojure.pprint to be in your project's classpath.\nSOURCE: https://github.com/clojure/clojure/blob/master/doc/clojure/pprint/CommonLispFormat.markdown#_snippet_2\n\nLANGUAGE: Clojure\nCODE:\n```\n(use 'clojure.pprint)\n```\n\n----------------------------------------\n\nTITLE: Using ex-info and ex-data in Clojure\nDESCRIPTION: This snippet illustrates the use of `ex-info` to create exceptions with associated data, and `ex-data` to retrieve that data. `ex-info` creates an instance of `ExceptionInfo`, which extends `RuntimeException` and takes a message and a data map. `ex-data` retrieves this map from an `ExceptionInfo` instance.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_38\n\nLANGUAGE: Clojure\nCODE:\n```\n(ex-info \"Invalid use of robots\" {:robots false})\n;=> #<ExceptionInfo clojure.lang.ExceptionInfo: Invalid use of robots {:robots false}>\n\n(ex-data (ex-info \"Invalid use of robots\" {:robots false}))\n;=> {:robots false}\n```\n\n----------------------------------------\n\nTITLE: Deprecated Dynamic Vars Warning in Clojure\nDESCRIPTION: This code snippet demonstrates the warning issued when an earmuffed var (e.g., *fred*) is defined without being explicitly declared dynamic using ^:dynamic. This warning indicates that the var might be intended for dynamic rebinding, and the user should either declare it as dynamic or rename it.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_41\n\nLANGUAGE: Clojure\nCODE:\n```\n(def *fred*)\n```\n\n----------------------------------------\n\nTITLE: find-keyword example in Clojure\nDESCRIPTION: This example shows the usage of `find-keyword`, which returns a Keyword with the given namespace and name if one already exists. If not, it returns nil.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_47\n\nLANGUAGE: Clojure\nCODE:\n```\n(find-keyword \"def\")\n=> :def\n(find-keyword \"fred\")\n=> nil\n```\n\n----------------------------------------\n\nTITLE: Reader Conditionals Example in Clojure\nDESCRIPTION: This example demonstrates the use of reader conditionals in Clojure to define platform-specific code. The code uses the #? reader macro to select different expressions based on the target platform (:clj for Clojure, :cljs for ClojureScript) and provides a default value if no platform matches.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_11\n\nLANGUAGE: Clojure\nCODE:\n```\n#?(:clj     Double/NaN\n   :cljs    js/NaN\n   :default nil)\n```\n\n----------------------------------------\n\nTITLE: string.join Enhanced to Work with Sets in Clojure\nDESCRIPTION: The `string.join` function now works with sets, similar to how it works with other collections. It joins the elements of the set using the specified separator string.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_55\n\nLANGUAGE: Clojure\nCODE:\n```\n(join \" and \" #{:fred :ethel :lucy})\n```\n\n----------------------------------------\n\nTITLE: Walk Support for sorted-by Collections in Clojure\nDESCRIPTION: The `walk` function has been modified to work with `sorted-by` collections.  The `walk` function applies transformations to a data structure.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_54\n\nLANGUAGE: Clojure\nCODE:\n```\nlet [x (sorted-set-by > 1 2 3)] (walk inc reverse x))\n```\n\n----------------------------------------\n\nTITLE: Reader Conditionals Splicing Example in Clojure\nDESCRIPTION: This example demonstrates the use of reader conditional splicing in Clojure to conditionally insert elements into a collection.  The #?@ reader macro splices a sequence of values based on the platform. If no platform matches, nothing is spliced.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_12\n\nLANGUAGE: Clojure\nCODE:\n```\n[1 2 #?@(:clj [3 4] :cljs [5 6])]\n```\n\n----------------------------------------\n\nTITLE: Connecting to Socket REPL with Telnet - Shell\nDESCRIPTION: This shell command demonstrates how to connect to a socket REPL server using telnet. It connects to the specified host (127.0.0.1) and port (5555). After connecting, you can execute Clojure code directly within the telnet session, interacting with the running Clojure program.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_10\n\nLANGUAGE: Shell\nCODE:\n```\n$ telnet 127.0.0.1 5555\nTrying 127.0.0.1...\nConnected to localhost.\nEscape character is '^]'.\nuser=> (println \"hello\")\nhello\n```\n\n----------------------------------------\n\nTITLE: Comp Function Identity Check in Clojure\nDESCRIPTION: This snippet demonstrates that the `comp` function, when called with zero arity, returns the identity function. This is a functional programming concept indicating that composing no functions results in the identity function.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_57\n\nLANGUAGE: Clojure\nCODE:\n```\n(= (comp) identity)\n```\n\n----------------------------------------\n\nTITLE: StackOverflowError Fix in Clojure Metadata Printing\nDESCRIPTION: This snippet illustrates a bug fix where a `StackOverflowError` was thrown when printing meta with a `:type` key. The patch resolves this issue, allowing metadata with type information to be printed without error.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_61\n\nLANGUAGE: Clojure\nCODE:\n```\n(with-meta {:value 2} {:type Object})\n```\n\n----------------------------------------\n\nTITLE: Map Destructuring with Auto-Resolved Keywords (shorthand) in Clojure\nDESCRIPTION: This Clojure code snippet demonstrates map destructuring with auto-resolved keywords using the shorthand notation `::x`.  It accesses a value associated with an auto-resolved keyword.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_26\n\nLANGUAGE: Clojure\nCODE:\n```\n(let [m {::x 1}\n      {:keys [::x]} m]\n  x)\n```\n\n----------------------------------------\n\nTITLE: Recur across try block throws CompilerException in Clojure\nDESCRIPTION: This snippet demonstrates that the Clojure compiler correctly rejects attempts to recur across a `try` block, resulting in a `CompilerException`.  This restriction is in place to maintain the integrity of the recursion process.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_60\n\nLANGUAGE: Clojure\nCODE:\n```\n(fn [x] (try (recur 1)))\n```\n\n----------------------------------------\n\nTITLE: Printing Thrown Exceptions in Clojure\nDESCRIPTION: This example shows how thrown exceptions are printed to a stream in Clojure 1.6. The output is a tagged literal data form providing detailed information about the exception, including the cause, type, message, and stack trace.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_17\n\nLANGUAGE: Clojure\nCODE:\n```\nuser=> (/ 1 0)\nArithmeticException Divide by zero  clojure.lang.Numbers.divide (Numbers.java:158)\nuser=> (println *e)\n#error {\n :cause Divide by zero\n :via\n [{:type java.lang.ArithmeticException\n   :message Divide by zero\n   :at [clojure.lang.Numbers divide Numbers.java 158]}]\n :trace\n [[clojure.lang.Numbers divide Numbers.java 158]\n  [clojure.lang.Numbers divide Numbers.java 3808]\n  ;; ... elided frames\n  ]}\n```\n\n----------------------------------------\n\nTITLE: Using param-tags metadata in Clojure\nDESCRIPTION: This explains how to use `:param-tags` metadata to resolve overloaded Java methods when using qualified methods in Clojure. It is a vector of tags indicating the parameter types of the desired method signature.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_3\n\nLANGUAGE: Clojure\nCODE:\n```\n`^[tag ...]`\n```\n\n----------------------------------------\n\nTITLE: Printing Unhandled Objects in Clojure\nDESCRIPTION: This snippet demonstrates how unhandled objects are printed in the REPL in Clojure 1.6. It includes the class, hash code, and toString representation of the object, enclosed in a tagged literal data form.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_16\n\nLANGUAGE: Clojure\nCODE:\n```\nuser=> *ns*\n#object[clojure.lang.Namespace 0x55aa628 \"user\"]\n```\n\n----------------------------------------\n\nTITLE: NullPointerException fix for empty string in cl-format in Clojure\nDESCRIPTION: This snippet demonstrates a bug fix where `cl-format` throws a `NullPointerException` when called with a nil format and an empty string. The patch fixes this issue, allowing the code to execute without error.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_62\n\nLANGUAGE: Clojure\nCODE:\n```\n(cl-format nil \"~:(~a~)\" \"\")\n```\n\n----------------------------------------\n\nTITLE: Unsigned Bit Shift Right in Clojure\nDESCRIPTION: This Clojure code demonstrates the use of the `unsigned-bit-shift-right` function, which performs an unsigned bitwise right shift operation.  The example shows the function being used to shift the binary number 2r100 (4 in decimal) by different amounts.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_27\n\nLANGUAGE: Clojure\nCODE:\n```\n(unsigned-bit-shift-right 2r100 1) ;; 2r010\n(unsigned-bit-shift-right 2r100 2) ;; 2r001\n(unsigned-bit-shift-right 2r100 3) ;; 2r000\n```\n\n----------------------------------------\n\nTITLE: Building Clojure with Maven\nDESCRIPTION: These Maven commands are used for building the Clojure project. They demonstrate building, skipping tests, installing to the local Maven repository, creating a standalone JAR, and running the standalone JAR.\nSOURCE: https://github.com/clojure/clojure/blob/master/readme.txt#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n  To build (output JARs in target/):\n    mvn package\n\n  To build without testing:\n    mvn package -Dmaven.test.skip=true\n\n  To build and install in local Maven repository:\n    mvn install\n\n  To build a standalone jar with dependencies included:\n    mvn -Plocal -Dmaven.test.skip=true package\n\n  To run with the standalone jar:\n    java -jar clojure.jar\n```\n\n----------------------------------------\n\nTITLE: Building Clojure with Ant\nDESCRIPTION: These commands detail how to build the Clojure project using Ant. The `antsetup.sh` script configures the environment, `ant local` builds the project, and `java -jar clojure.jar` runs the compiled JAR file.\nSOURCE: https://github.com/clojure/clojure/blob/master/readme.txt#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n   One-time setup:    ./antsetup.sh\n   To build:          ant local\n   To run:            java -jar clojure.jar\n```\n\n----------------------------------------\n\nTITLE: Defining data reader map\nDESCRIPTION: This Clojure snippet shows an example of a `data_readers.clj` file used for defining reader literals. The file contains a map where keys are reader tags and values are fully-qualified names of Vars that will be invoked by the reader to parse the form following the tag.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_34\n\nLANGUAGE: Clojure\nCODE:\n```\n{foo/bar my.project.foo/bar\n foo/baz my.project/baz}\n```\n\n----------------------------------------\n\nTITLE: Reducer Composition in Clojure\nDESCRIPTION: This snippet defines a reducer red by composing filter and map operations from the clojure.core.reducers library.  It then applies the reducer to a collection and sums the result.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_30\n\nLANGUAGE: Clojure\nCODE:\n```\n\tuser=> (def red (comp (r/filter even?) (r/map inc)))\n\tuser=> (reduce + (red [1 1 1 2]))\n```\n\n----------------------------------------\n\nTITLE: Defining plus-2 function with boxed math warning in Clojure\nDESCRIPTION: This code defines a function `plus-2` that adds 2 to its argument. Initially, it results in boxed math. After setting `*unchecked-math*` to `:warn-on-boxed`, a warning is emitted. A type hint is then added to avoid boxing.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_14\n\nLANGUAGE: Clojure\nCODE:\n```\n(defn plus-2 [x] (+ x 2))\n(set! *unchecked-math* :warn-on-boxed)\n(defn plus-2 [x] (+ x 2))\n(defn plus-2 [^long x] (+ x 2))\n```\n\n----------------------------------------\n\nTITLE: Referencing Array Classes in Clojure\nDESCRIPTION: Demonstrates referencing array classes using the `ComponentClass/#dimensions` syntax. This syntax allows developers to refer to array classes as both type hints and values.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_4\n\nLANGUAGE: Clojure\nCODE:\n```\n`String/1`\n```\n\nLANGUAGE: Clojure\nCODE:\n```\n`java.lang.String/1`\n```\n\nLANGUAGE: Clojure\nCODE:\n```\n`long/2`\n```\n\n----------------------------------------\n\nTITLE: Defining a record with a field starting with a dash\nDESCRIPTION: This Clojure snippet defines a record named `Bar` with a field `-a`. In Clojure 1.3, this field could be accessed using dot syntax, but in 1.4, this results in an `IllegalArgumentException`. However, the field may still be accessed using a keyword.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_32\n\nLANGUAGE: Clojure\nCODE:\n```\n(defrecord Bar [-a]) ;=> user.Bar\n(.-a (Bar. 10)) ;=> 10\n```\n\n----------------------------------------\n\nTITLE: Accessing record field with keyword\nDESCRIPTION: This Clojure code demonstrates the correct way to access a record field that starts with a dash in Clojure 1.4, using the keyword syntax. This approach avoids the `IllegalArgumentException` that occurs when using dot syntax.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_33\n\nLANGUAGE: Clojure\nCODE:\n```\n(:-a (Bar. 10)) ;=> 10\n```\n\n----------------------------------------\n\nTITLE: Loading Clojure Namespaces from Java\nDESCRIPTION: This Java code snippet demonstrates how to load a Clojure namespace from Java using the `clojure.java.api.Clojure` class and the `require` function.  It first retrieves the `require` function and then invokes it with the namespace to be loaded. This allows access to functions and vars within the required namespace.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_20\n\nLANGUAGE: Java\nCODE:\n```\nIFn require = Clojure.var(\"clojure.core\", \"require\");\nrequire.invoke(Clojure.read(\"clojure.set\"));\n```\n\n----------------------------------------\n\nTITLE: Accessing Clojure Data Values from Java\nDESCRIPTION: This Java code snippet demonstrates how to access non-function data values in Clojure from Java using the `clojure.java.api.Clojure` class. It retrieves the `*print-length*` var and then uses `deref` to get its value, instead of `invoke`. This is useful for accessing Clojure's special variables.\nSOURCE: https://github.com/clojure/clojure/blob/master/changes.md#_snippet_22\n\nLANGUAGE: Java\nCODE:\n```\nIFn printLength = Clojure.var(\"clojure.core\", \"*print-length*\");\nClojure.var(\"clojure.core\", \"deref\").invoke(printLength);\n```"
  }
]