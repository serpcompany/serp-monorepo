[
  {
    "owner": "sycamore-rs",
    "repo": "sycamore",
    "content": "TITLE: Implementing a Todo Application with Sycamore in Rust\nDESCRIPTION: A complete implementation of a Todo application using the Sycamore framework with localStorage persistence. The code includes components for displaying individual todo items, managing a list of todos, and adding new todos. It demonstrates reactive state management through signals and component composition.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/todo-app.md#2025-04-18_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\nuse serde::{Deserialize, Serialize};\nuse sycamore::prelude::*;\nuse web_sys::KeyboardEvent;\n\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\nstruct Todo {\n    task: Signal<String>,\n    completed: Signal<bool>,\n    id: u32,\n}\n\n#[component(inline_props)]\nfn TodoItem<F>(todo: Todo, remove_todo: F) -> View\nwhere\n    F: Fn(u32) + Copy + 'static,\n{\n    on_cleanup(move || {\n        todo.task.dispose();\n        todo.completed.dispose();\n    });\n\n    // We are using inline styles here which is generally not considered best practice.\n    // In real app, you would probably use an external CSS file.\n    let style = move || {\n        if todo.completed.get() {\n            \"text-decoration: line-through;\"\n        } else {\n            \"\"\n        }\n    };\n    let toggle_completed = move |_| todo.completed.set(!todo.completed.get());\n    let remove_todo = move |_| remove_todo(todo.id);\n\n    let is_editing = create_signal(false);\n    let start_editing = move |_| is_editing.set(true);\n\n    let on_keydown = move |ev: KeyboardEvent| {\n        if ev.key() == \"Enter\" && !todo.task.with(String::is_empty) {\n            is_editing.set(false);\n        }\n    };\n\n    view! {\n        li {\n            span(style=style, on:click=toggle_completed) {\n                (if is_editing.get() {\n                    view! { input(bind:value=todo.task, on:keydown=on_keydown) }\n                } else {\n                    view! { (todo.task) }\n                })\n            }\n            button(on:click=start_editing, disabled=is_editing.get()) { \"Edit Task\" }\n            button(on:click=remove_todo) { \"Remove\" }\n        }\n    }\n}\n\n#[component(inline_props)]\nfn TodoList<F>(#[prop(setter(into))] todos: MaybeDyn<Vec<Todo>>, remove_todo: F) -> View\nwhere\n    F: Fn(u32) + Copy + 'static,\n{\n    view! {\n        ul {\n            Keyed(\n                list=todos,\n                view=move |todo| view! { TodoItem(todo=todo, remove_todo=remove_todo) },\n                key=|todo| todo.id,\n            )\n        }\n    }\n}\n\n#[component(inline_props)]\nfn TodoInput<F>(add_todo: F) -> View\nwhere\n    F: Fn(String) + 'static,\n{\n    let input = create_signal(String::new());\n\n    let on_keydown = move |ev: KeyboardEvent| {\n        if ev.key() == \"Enter\" && !input.with(String::is_empty) {\n            add_todo(input.get_clone());\n            input.set(String::new());\n        }\n    };\n\n    view! {\n        div {\n            \"New Todo: \"\n            input(bind:value=input, on:keydown=on_keydown)\n        }\n    }\n}\n\n#[component]\nfn App() -> View {\n    // Initialize application state from localStorage.\n    let local_storage = window()\n        .local_storage()\n        .unwrap()\n        .expect(\"user has not enabled localStorage\");\n\n    let todos: Signal<Vec<Todo>> = if let Ok(Some(app_state)) = local_storage.get_item(\"todos\") {\n        serde_json::from_str(&app_state).unwrap_or_default()\n    } else {\n        Default::default()\n    };\n\n    // Set up an effect that runs whenever app_state.todos changes to save the todos to\n    // localStorage.\n    create_effect(move || {\n        todos.with(|todos| {\n            // Also track all nested signals.\n            for todo in todos {\n                todo.task.track();\n                todo.completed.track();\n            }\n            local_storage\n                .set_item(\"todos\", &serde_json::to_string(todos).unwrap())\n                .unwrap();\n        });\n    });\n\n    let next_id = create_signal(0);\n    // `replace(...)` is the same as `set(...)` but returns the previous value.\n    let get_next_id = move || next_id.replace(next_id.get() + 1);\n\n    let add_todo = move |task| {\n        todos.update(|todos| {\n            todos.push(Todo {\n                task: create_signal(task),\n                completed: create_signal(false),\n                id: get_next_id(),\n            })\n        })\n    };\n\n    let remove_todo = move |id| todos.update(|todos| todos.retain(|todo| todo.id != id));\n\n    view! {\n        TodoInput(add_todo=add_todo)\n        TodoList(todos=todos, remove_todo=remove_todo)\n    }\n}\n\nfn main() {\n    sycamore::render(App);\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Sycamore Counter Component in Rust\nDESCRIPTION: A simple counter component example showing Sycamore's core features including signals, components, and the view macro. It demonstrates creating a reactive counter that increments when a button is clicked.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/posts/announcing-v0-9-0.md#2025-04-18_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[component]\nfn Counter(initial: i32) -> View {\n    let mut value = create_signal(initial);\n\n    view! {\n        button(on:click=move |_| value += 1) {\n            \"Count: \" (value)\n        }\n    }\n\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Event Handlers to Update State\nDESCRIPTION: Shows how to add a click event handler to a button that updates a signal's value, causing the UI to reactively update.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/adding-state.md#2025-04-18_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nview! {\n    button(on:click=move |_| counter.set(counter.get() + 1)) { \"Increment\" }\n    p { \"Count: \" (counter) }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TodoList Component with Keyed Rendering\nDESCRIPTION: Creates a component for displaying the list of todos. Uses the Keyed component to efficiently render and update the list based on todo IDs, which ensures proper DOM reconciliation.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/todo-app.md#2025-04-18_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n#[component(inline_props)]\nfn TodoList(#[prop(setter(into))] todos: MaybeDyn<Vec<Todo>>) -> View {\n    view! {\n        ul {\n            Keyed(\n                list=todos,\n                view=|todo| view! { TodoItem(todo=todo) },\n                key=|todo| todo.id,\n            )\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Components with Props in Sycamore\nDESCRIPTION: Implementing components that accept properties (props) in Sycamore, allowing for customized component behavior based on passed parameters.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/your-first-app.md#2025-04-18_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Props)]\nstruct HelloProps {\n    name: String,\n}\n\n#[component]\nfn Hello(props: HelloProps) -> View {\n    view! {\n        p { \"Hello, \" (props.name) \"!\" }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating TodoItem Component for Individual Todos\nDESCRIPTION: Defines a component for rendering a single todo item, including cleanup logic for signals when the todo is removed. It uses inline styles to show strikethrough text for completed todos.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/todo-app.md#2025-04-18_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n#[component(inline_props)]\nfn TodoItem(todo: Todo) -> View {\n    // Dispose of nested signals when the todo is removed.\n    on_cleanup(move || {\n        todo.task.dispose();\n        todo.completed.dispose();\n    });\n\n    // We are using inline styles here which is generally not considered best practice.\n    // In real app, you would probably use an external CSS file.\n    let style = move || {\n        if todo.completed.get() {\n            \"text-decoration: line-through;\"\n        } else {\n            \"\"\n        }\n    };\n\n    view! {\n        li {\n            span(style=style) { (todo.task) }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Keyed Lists in Sycamore for Efficient List Reordering\nDESCRIPTION: Demonstrates how to use Sycamore's Keyed component for lists where items might be reordered. By providing a unique key for each item, Sycamore can correctly track item identity across list updates, enabling efficient DOM updates.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/rendering-lists.md#2025-04-18_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Clone, PartialEq, Eq)]\nstruct Todo {\n    task: String,\n    // An unique id associated with each todo.\n    // This must be unique, otherwise unexpected things can happen (but not UB).\n    id: u32,\n}\n\nlet todos = create_signal(vec![...]);\n\nview! {\n    ul {\n        Keyed(\n            list=todos,\n            view=|todo| view! {\n                li { (todo.task) }\n            },\n            key=|todo| todo.id,\n        )\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Counter Component Example\nDESCRIPTION: A complete example of a counter component with increment button, displaying both the current count and its doubled value.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/adding-state.md#2025-04-18_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nuse sycamore::prelude::*;\n\n#[component]\nfn App() -> View {\n    let mut counter = create_signal(1);\n    let doubled = create_memo(move || counter.get() * 2);\n    let increment = move |_| counter += 1;\n\n    view! {\n        button(on:click=increment) { \"Increment\" }\n        p { \"Count:\" (counter) }\n        p { \"Doubled: \" (doubled) }\n    }\n}\n\nfn main() {\n    sycamore::render(App);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Client-Side Router Component in Sycamore\nDESCRIPTION: Creating a router component that renders different views based on the current route. Uses HistoryIntegration to manage browser history and handles anchor tag clicks.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/router.md#2025-04-18_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nview! {\n    Router(\n        integration=HistoryIntegration::new(),\n        view=|route: ReadSignal<AppRoutes>| {\n            view! {\n                div(class=\"app\") {\n                    (match route.get_clone() {\n                        AppRoutes::Index => view! {\n                            \"This is the index page\"\n                        },\n                        AppRoutes::About => view! {\n                            \"About this website\"\n                        },\n                        AppRoutes::NotFound => view! {\n                            \"404 Not Found\"\n                        },\n                    })\n                }\n            }\n        }\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Using Memos for Efficient Derived State\nDESCRIPTION: Demonstrates how to use create_memo for caching expensive computations that depend on signals, recomputing only when dependencies change.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/adding-state.md#2025-04-18_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nlet signal = create_signal(1);\nlet derived = create_memo(move || expensive_computation(signal.get()));\n\n// The memo will only call the closure once so long as `signal` hasn't changed.\nlet foo = derived.get();\nlet bar = derived.get();\n\n// This triggers `derived` to recompute its value.\nsignal.set(2);\n```\n\n----------------------------------------\n\nTITLE: Defining a Context Type in Rust with Sycamore\nDESCRIPTION: Creates a DarkMode context type using the new type idiom, wrapping a Signal<bool> and providing helper methods for reading and toggling the dark mode state. This demonstrates how to properly encapsulate reactive state in a Sycamore context.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/guide/contexts.md#2025-04-18_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Clone, Copy, PartialEq, Eq)]\nstruct DarkMode(Signal<bool>);\n\nimpl DarkMode {\n    fn is_enabled(self) -> bool {\n        self.0.get()\n    }\n\n    fn toggle(self) {\n        self.0.set(!self.0.get());\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Todo Editing Functionality\nDESCRIPTION: Adds the ability to edit existing todos by implementing an edit mode toggle and input field. The component uses signals to track the editing state and handles keyboard events to save changes.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/todo-app.md#2025-04-18_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\nlet is_editing = create_signal(false);\nlet start_editing = move |_| is_editing.set(true);\n\nlet on_keydown = move |ev: KeyboardEvent| {\n    if ev.key() == \"Enter\" && !todo.task.with(String::is_empty) {\n        is_editing.set(false);\n    }\n};\n\nview! {\n    li {\n        span(style=style, on:click=toggle_completed) {\n            (if is_editing.get() {\n                view! { input(bind:value=todo.task, on:keydown=on_keydown) }\n            } else {\n                view! { (todo.task) }\n            })\n        }\n        button(on:click=start_editing, disabled=is_editing.get()) { \"Edit Task\" }\n        button(on:click=remove_todo) { \"Remove\" }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Building TodoInput Component with Two-Way Data Binding\nDESCRIPTION: Creates an input component for adding new todos that uses data binding to sync the input value with a signal. It handles keyboard events to add a todo when Enter is pressed.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/todo-app.md#2025-04-18_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n#[component(inline_props)]\nfn TodoInput<F>(add_todo: F) -> View\nwhere\n    F: Fn(String) + 'static,\n{\n    let input = create_signal(String::new());\n\n    let on_keydown = move |ev: KeyboardEvent| {\n        if ev.key() == \"Enter\" && !input.with(String::is_empty) {\n            add_todo(input.get_clone());\n            // Reset the input.\n            input.set(String::new());\n        }\n    };\n\n    view! {\n        div {\n            \"New Todo: \"\n            input(bind:value=input, on:keydown=on_keydown)\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Resource with Dependencies in Sycamore\nDESCRIPTION: Illustrates how to create a resource with dependencies using the on() utility function. This example creates a resource that depends on an id signal and fetches user data based on that id.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/guide/resources-and-suspense.md#2025-04-18_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nlet id = create_signal(12345);\nlet resource = create_client_resource(on(id, move || async move {\n    fetch_user(id.get()).await\n}));\n```\n\n----------------------------------------\n\nTITLE: Composing Components in Sycamore\nDESCRIPTION: Example of creating and composing multiple components in Sycamore, showing both top-level and nested component usage.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/your-first-app.md#2025-04-18_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\n#[component]\nfn HelloWorld() -> View {\n    view! {\n        p { \"Hello, world!\" }\n    }\n}\n\n#[component]\nfn App() -> View {\n    view! {\n        // Components can be at the top-level of a view.\n        HelloWorld()\n\n        // Or they can be nested.\n        div {\n            HelloWorld()\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Binding Signal to Input Value in Sycamore\nDESCRIPTION: This example demonstrates how to bind a Signal to an input element's value property. It creates a new string signal and binds it to an input element using the bind:value directive, allowing two-way data binding.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/guide/data-binding.md#2025-04-18_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse sycamore::prelude::*;\n\nlet value = create_signal(String::new());\n\nview! {\n    input(bind:value=value)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Resources in Sycamore v0.9\nDESCRIPTION: Demonstrates how to create a resource that depends on a reactive signal and use it within a Suspense component. The resource fetches user data asynchronously based on an ID signal.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/posts/announcing-v0-9-0.md#2025-04-18_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nlet id = create_signal(...);\nlet resource = create_resource(on(id, move || async move {\n    fetch_user(id.get()).await\n}));\n```\n\nLANGUAGE: rust\nCODE:\n```\nview! {\n    Suspense(fallback=move || view! { \"Loading...\" }) {\n        (if let Some(data) = resource.get_clone() {\n            view! {\n                ...\n            }\n        } else {\n            // This will never get shown.\n            view! {}\n        })\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Derived State in Views\nDESCRIPTION: Demonstrates how to display both a signal and a memo (derived state) in a view template.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/adding-state.md#2025-04-18_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nlet counter = create_signal(1);\nlet doubled = create_memo(move || counter.get() * 2);\n\nview! {\n    p { \"Count: \" (counter) }\n    p { \"Doubled: \" (doubled) }\n}\n```\n\n----------------------------------------\n\nTITLE: Updating TodoItem Component to Support Todo Removal\nDESCRIPTION: Modifies the TodoItem component to accept a callback for removing todos. This function signature allows passing the remove_todo function from the App component down to the TodoItem.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/todo-app.md#2025-04-18_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n#[component(inline_props)]\nfn TodoItem<F>(todo: Todo, remove_todo: F) -> View\nwhere\n    F: Fn(u32) + Copy + 'static,\n{ ... }\n```\n\n----------------------------------------\n\nTITLE: Creating Effects for Reactive Dependency Tracking\nDESCRIPTION: Demonstrates how to use create_effect to automatically run code when signals change. Effects automatically track dependencies when signals are accessed within them.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/adding-state.md#2025-04-18_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nlet signal = create_signal(123);\ncreate_effect(move || {\n    // Using `.get(...)` automatically tracks this signal as a dependency.\n    let value = signal.get();\n    console_log!(\"{value}\");\n\n    // Or we can use the shorter: `console_log!(\"{signal}\");`\n});\nsignal.set(456);\nsignal.set(789);\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Signals in Sycamore\nDESCRIPTION: Demonstrates how to create a signal, read its value, and update it. Signals are the basic building blocks of reactive state in Sycamore.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/adding-state.md#2025-04-18_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet signal = create_signal(123);\n```\n\n----------------------------------------\n\nTITLE: Creating Components with Children in Sycamore\nDESCRIPTION: Implementation of a component that accepts child elements using the special 'children' prop, allowing for component composition.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/your-first-app.md#2025-04-18_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Props)]\nstruct WrapperProps {\n    children: Children,\n}\n\n#[component]\nfn Wrapper(props: WrapperProps) -> View {\n    view! {\n        div {\n            (props.children)\n        }\n    }\n}\n\n#[component]\nfn App() -> View {\n    view! {\n        Wrapper {\n            p { \"Nested children\" }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Toggle Functionality to TodoItem\nDESCRIPTION: Adds a click event handler to toggle the completed status of a todo item when clicked. This updates the signal and automatically reflects in the UI through the reactive style.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/todo-app.md#2025-04-18_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nlet toggle_completed = move |_| todo.completed.set(!todo.completed.get());\nview! {\n    li {\n        span(style=style, on:click=toggle_completed) { (todo.task) }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Hello World in Sycamore\nDESCRIPTION: A minimal Sycamore application that renders \"Hello, world!\" text to the DOM. This demonstrates the core rendering functionality.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/your-first-app.md#2025-04-18_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse sycamore::prelude::*;\n\nfn main() {\n    sycamore::render(|| \"Hello, world!\".into());\n}\n```\n\n----------------------------------------\n\nTITLE: Component Definition with View Backend v2\nDESCRIPTION: Comparison of component definition syntax between old and new versions. The new syntax removes generic parameters and lifetime annotations, simplifying code with automatic backend selection based on compile target.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/migration/0-8-to-0-9.md#2025-04-18_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n// Old\n#[component(inline_props)]\nfn Component<'a, G: Html'(cx: Scope<'a>, value: &'a ReadSignal<i32>) -> View<G> {\n    ...\n}\n\n// New\n#[component(inline_props)]\nfn Component(value: ReadSignal<i32>) -> View {\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Attribute Passthrough in Sycamore Components\nDESCRIPTION: Demonstrates how to create a Button component that accepts custom attributes via the special `attributes` prop and spreads them onto the HTML button element. The `#[prop(attributes(html, button))]` tag specifies what kind of element these attributes are expected to be applied on.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/guide/attribute-passthrough.md#2025-04-18_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[component(inline_props)]\nfn Button(\n    // `html` means that we are spreading onto an HTML element.\n    // The other possible value is `svg`.\n    //\n    // `button` means that we are spreading onto a `<button>` element.\n    #[prop(attributes(html, button))]\n    attributes: Attributes,\n    // We can still accept children.\n    children: Children,\n    // We can still accept other props besides `attributes`.\n    other_prop: i32,\n) -> View {\n    view! {\n        // The spread (`..xyz`) syntax applies all the attributes onto the element.\n        button(..attributes)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Nested Reactivity with Signals in Sycamore Todo Items\nDESCRIPTION: Shows how to implement nested reactivity by embedding signals inside a Todo struct. This pattern allows for granular updates to individual todo properties without re-rendering the entire list.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/rendering-lists.md#2025-04-18_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Clone, PartialEq, Eq)]\nstruct Todo {\n    task: Signal<String>,\n    id: u32,\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Todo Data Structure in Rust\nDESCRIPTION: Creates a Todo struct that holds the task name, completion status, and a unique identifier. Each field that needs reactivity is wrapped in a Signal.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/todo-app.md#2025-04-18_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Debug, Clone, PartialEq, Eq)]\nstruct Todo {\n    task: Signal<String>,\n    completed: Signal<bool>,\n    id: u32,\n}\n```\n\n----------------------------------------\n\nTITLE: Reactivity v3 Example with Simplified API\nDESCRIPTION: An example showing the new Reactivity v3 approach which eliminates the context parameter and simplifies the API. This demonstrates how signals and effects can now be created without threading `cx` everywhere.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/posts/announcing-v0-9-0.md#2025-04-18_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nlet signal = create_signal(123);\ncreate_effect(move || {\n    let nested = create_signal(456);\n    println!(\"{signal}, {nested}\");\n});\n```\n\n----------------------------------------\n\nTITLE: Displaying Resource Data in Sycamore View\nDESCRIPTION: Shows how to use a resource in a Sycamore view, checking if the data is available and rendering it accordingly. This snippet demonstrates handling both loaded and loading states of the resource.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/guide/resources-and-suspense.md#2025-04-18_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nview! {\n    (if let Some(data) = resource.get_clone() {\n        view! {\n            ...\n        }\n    } else {\n        view! {}\n    })\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Todo State from localStorage\nDESCRIPTION: Implements persistence by loading todo items from browser localStorage on app initialization. Uses serde for serialization/deserialization and web-sys to access the browser's Storage API.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/todo-app.md#2025-04-18_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\n// Initialize application state from localStorage.\nlet local_storage = window()\n    .local_storage()\n    .unwrap()\n    .expect(\"user has not enabled localStorage\");\n\nlet todos: Signal<Vec<Todo>> = if let Ok(Some(app_state)) = local_storage.get_item(\"todos\") {\n    serde_json::from_str(&app_state).unwrap_or_default()\n} else {\n    Default::default()\n};\n```\n\n----------------------------------------\n\nTITLE: Adding Remove Button to TodoItem Component\nDESCRIPTION: Implements a remove button in the TodoItem component that calls the remove_todo callback with the todo's ID when clicked. This completes the todo removal functionality.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/todo-app.md#2025-04-18_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\nlet remove_todo = move |_| remove_todo(todo.id);\n\nview! {\n    li {\n        span(style=style, on:click=toggle_completed) {\n            (todo.task)\n        }\n        button(on:click=remove_todo) { \"Remove\" }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Using a Tweened Signal in Rust with Sycamore\nDESCRIPTION: This snippet demonstrates how to create a tweened signal that smoothly interpolates from 0 to 100 over 250 milliseconds using a quadratic easing function. Tweened signals are useful for creating animations by updating values gradually over time.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/guide/tweened.md#2025-04-18_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::time::Duration;\n\nuse sycamore::easing;\nuse sycamore::motion::create_tweened_signal;\n\nlet tweened = create_tweened_signal(0.0f32, Duration::from_millis(250), easing::quad_out);\n\ntweened.set(100.0);\n```\n\n----------------------------------------\n\nTITLE: Creating an Isomorphic Resource in Rust with Sycamore\nDESCRIPTION: Demonstrates how to create an isomorphic resource for fetching data asynchronously using Sycamore's create_isomorphic_resource function. It defines a Data struct and a fetch_data function to retrieve the data.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/guide/resources-and-suspense.md#2025-04-18_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse sycamore::prelude::*;\nuse sycamore::web::create_isomorphic_resource;\n\nstruct Data {\n    // Define the data format here.\n}\n\nasync fn fetch_data() -> Data {\n    // Perform, for instance, an HTTP request to an API endpoint.\n}\n\nlet resource = create_isomorphic_resource(fetch_data);\n```\n\n----------------------------------------\n\nTITLE: Saving Todo State to localStorage with Reactive Effect\nDESCRIPTION: Creates a reactive effect that runs whenever the todos state changes, serializing the current state and saving it to localStorage. This ensures persistence across page refreshes.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/todo-app.md#2025-04-18_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\n// Set up an effect that runs whenever app_state.todos changes to save the todos to\n// localStorage.\ncreate_effect(move || {\n    todos.with(|todos| {\n        // Also track all nested signals.\n        for todo in todos {\n            todo.task.track();\n            todo.completed.track();\n        }\n        local_storage\n            .set_item(\"todos\", &serde_json::to_string(todos).unwrap())\n            .unwrap();\n    });\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Unique ID Generator for Todos\nDESCRIPTION: Implements a simple counter-based ID generator using a signal that increments each time a new ID is requested. The replace method updates the signal and returns the previous value.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/todo-app.md#2025-04-18_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nlet next_id = create_signal(0);\n// `replace(...)` is the same as `set(...)` but returns the previous value.\nlet get_next_id = move || next_id.replace(next_id.get() + 1);\n```\n\n----------------------------------------\n\nTITLE: Rendering Todo App Components in App View\nDESCRIPTION: Composes the TodoInput and TodoList components together in the App component's view. This renders the complete todo application UI.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/todo-app.md#2025-04-18_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nview! {\n    TodoInput(add_todo=add_todo)\n    TodoList(todos=todos)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Router with sycamore-router in Rust\nDESCRIPTION: An example showing how to define routes using the sycamore-router crate. The code demonstrates creating a routing enum with Route derive macro, defining paths with the #[to] attribute, and handling not-found routes.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/posts/announcing-v0-5-0.md#2025-04-18_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse sycamore_router::Route;\n\n#[derive(Route)]\nenum MyRoutes {\n    #[to(\"/\")]\n    Index,\n    #[to(\"/about\")]\n    About,\n    #[not_found]\n    NotFound,\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Attributes in Sycamore Views\nDESCRIPTION: Demonstrates how to set various HTML attributes including classes, IDs, and custom attributes in Sycamore views\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/guide/view-dsl.md#2025-04-18_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nview! {\n    p(class=\"my-class\", id=\"my-paragraph\", aria-label=\"My paragraph\", \"custom_attribute\"=\"foo\")\n    button(disabled=true) {\n       \"My button\"\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Conditional Views\nDESCRIPTION: Shows how to conditionally render parts of the UI based on reactive state using if expressions in view templates.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/adding-state.md#2025-04-18_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\n// Create a new bool signal representing whether we show this part of the UI or not.\nlet show = create_signal(true);\n\nview! {\n    (if show.get() {\n        view! {\n            p { \"Now you see me\" }\n        }\n    } else {\n        view! {\n            p { \"Now you don't\" }\n        }\n    })\n}\n```\n\n----------------------------------------\n\nTITLE: Using Indexed Lists for Dynamic Data in Sycamore\nDESCRIPTION: Shows how to use Sycamore's Indexed component to efficiently update a dynamic list. The Indexed component automatically diffs the previous list with the new list to determine which items need to be updated, avoiding complete re-renders.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/rendering-lists.md#2025-04-18_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Clone, PartialEq, Eq)]\nstruct Todo {\n    task: String\n}\n\nlet todos = create_signal(vec![...]);\n\nview! {\n    ul {\n        Indexed(\n            list=todos,\n            view=|todo| view! {\n                li { (todo.task) }\n            },\n        )\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Static Lists in Sycamore with Rust\nDESCRIPTION: Demonstrates how to render a static list of Todo items by mapping a Vec<Todo> to a Vec<View> and embedding it in a view template. This approach works well for static data but is inefficient for dynamic data that changes frequently.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/rendering-lists.md#2025-04-18_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Todo {\n    task: String,\n}\n\nlet todos = vec![\n    Todo { task: \"Learn Rust\".to_string() },\n    Todo { task: \"Learn Sycamore\".to_string() },\n];\n\nlet todos_view = todos.into_iter().map(|todo| view! {\n    li { (todo.task) }\n}).collect::<Vec<View>>();\n\nview! {\n    ul {\n        (todos_view)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Components with the Builder API in Sycamore\nDESCRIPTION: Shows how to use components within the builder API by calling them directly and building props.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/guide/view-builder.md#2025-04-18_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\n// The component macro automatically generates the `Button_Props` type\n// if we are using inline props.\n#[component(inline_props)]\nfn Button(class: String) -> View { ... }\n\ndiv()\n    .children(Button(\n        Button_Props::builder().class(\"my-button\".to_string()).build()\n    ))\n```\n\n----------------------------------------\n\nTITLE: Creating Dynamic Views with Signals and Functions\nDESCRIPTION: Demonstrates how to add dynamic content to views using signals and functions.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/guide/view-builder.md#2025-04-18_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nlet state = create_signal(0);\n\np().children((\n    \"value = \",\n    state,\n    \", doubled = \",\n    move || state.get() * 2,\n))\n```\n\n----------------------------------------\n\nTITLE: Using Context in Sycamore Child Components\nDESCRIPTION: Shows how to access a provided context within a child component using the use_context function. This pattern allows components to access shared state without passing props through intermediate components.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/guide/contexts.md#2025-04-18_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[component]\nfn ChildComponent() -> View {\n    let dark_mode = use_context::<DarkMode>();\n    // ...\n}\n\nprovide_context::<DarkMode>(...);\nview! {\n    ChildComponent {}\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Nested Routes in Sycamore\nDESCRIPTION: Creating hierarchical routing structures with nested route enums. This enables organizing routes in a tree-like structure for more complex applications.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/router.md#2025-04-18_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Route, Clone)]\nenum Nested {\n    #[to(\"/nested\")]\n    Nested,\n    #[not_found]\n    NotFound,\n}\n\n#[derive(Route, Clone)]\nenum Admin {\n    #[to(\"/console\")]\n    Console,\n    #[not_found]\n    NotFound,\n}\n\n#[derive(Route, Clone)]\nenum Routes {\n    #[to(\"/\")]\n    Home,\n    #[to(\"/route/<_..>\")]\n    NestedRoute(Nested),\n    #[to(\"/admin/<_..>\")]\n    AdminRoute(Admin),\n    #[not_found]\n    NotFound,\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Dynamic Parameter Routes in Sycamore\nDESCRIPTION: Defining a route with a dynamic parameter using angle brackets syntax. This captures a variable from the URL path into a struct field.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/router.md#2025-04-18_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[to(\"/hello/<name>\")]\nHello {\n    name: String,\n}\n```\n\n----------------------------------------\n\nTITLE: Preventing Memory Leaks with on_cleanup in Sycamore Keyed Lists\nDESCRIPTION: Shows how to prevent memory leaks when removing items from a list with nested signals. By using on_cleanup inside the Keyed component's view function, signals are properly disposed when items are removed from the list.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/rendering-lists.md#2025-04-18_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nview! {\n    ul {\n        Keyed(\n            list=todos,\n            view=|todo| {\n                // Dispose of the signal when this item is removed.\n                on_cleanup(move || todo.task.dispose());\n                view! { ... }\n            },\n            key=|todo| todo.id,\n        )\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Components with Attribute Passthrough in Sycamore\nDESCRIPTION: Shows how downstream users can use a component with attribute passthrough to set custom HTML attributes, events, and props. This example demonstrates passing an ID, class, click event handler, and a custom prop to a Button component.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/guide/attribute-passthrough.md#2025-04-18_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nview! {\n    Button(\n        // Pass as many HTML attributes/events as you want.\n        id=\"my-button\",\n        class=\"btn btn-primary\",\n        on:click=|_| {}\n        // You can still pass in regular props as well.\n        other_prop=123,\n    ) {\n        // Children still gets passed into the `children` prop.\n        \"Click me\"\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Sycamore Builder API Example\nDESCRIPTION: Demonstrates the new builder API alternative to the view! macro for creating UI components. Shows signal binding and dynamic content rendering.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/posts/announcing-v0-7-0.md#2025-04-18_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nlet name = Signal::new(String::new());\n\ndiv()\n    .child(\n        h1().text(\"Hello \")\n            .dyn_child(cloned!((name) => move || {\n                if *create_selector(cloned!(name => move || !name.get().is_empty())).get() {\n                    span()\n                        .dyn_text(cloned!(name => move || name.get().to_string()))\n                        .build()\n                } else {\n                    span().text(\"World\").build()\n                }\n            }))\n            .text(\"!\")\n            .build(),\n    )\n    .child(input().bind_value(name).build())\n    .build()\n```\n\n----------------------------------------\n\nTITLE: Direct Children Interpolation in Views\nDESCRIPTION: Example demonstrating how children can be directly interpolated inside the view! macro in Sycamore v0.9, allowing for cleaner component composition.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/migration/0-8-to-0-9.md#2025-04-18_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nview! {\n    div {\n        (children)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting up Streaming Mode SSR in Sycamore\nDESCRIPTION: Streaming SSR mode that immediately sends HTML with fallback shell and updates as data loads. Implemented using render_to_string_stream method.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/server-side-rendering/streaming.md#2025-04-18_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nrender_to_string_stream\n```\n\n----------------------------------------\n\nTITLE: Using Suspense Component for Async Data Loading in Sycamore\nDESCRIPTION: Demonstrates the usage of the Suspense component to handle loading states for async data. It shows how to set a fallback view (LoadingSpinner) while the resource is being loaded.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/guide/resources-and-suspense.md#2025-04-18_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nview! {\n    Suspense(fallback=move || view! { LoadingSpinner {} }) {\n        (if let Some(data) = resource.get_clone() {\n            view! {\n                ...\n            }\n        } else {\n            view! {}\n        })\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Derived State with Closures\nDESCRIPTION: Shows how to create derived state using closures, where the derived value automatically updates when its dependencies change.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/adding-state.md#2025-04-18_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nlet signal = create_signal(1);\nlet derived = move || signal.get() * 2;\n\ncreate_effect(move || {\n    let value = signal.get();\n    let doubled = derived();\n    console_log!(\"signal = {signal}, doubled = {doubled}\");\n})\n```\n\n----------------------------------------\n\nTITLE: Setting Attributes and Custom Attributes on Elements\nDESCRIPTION: Shows how to set standard HTML attributes and custom attributes on elements.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/guide/view-builder.md#2025-04-18_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\np().class(\"my-class\").id(\"my-paragraph\").attr(\"aria-label\", \"My paragraph\")\n```\n\n----------------------------------------\n\nTITLE: Rendering Sycamore Components to String in Rust\nDESCRIPTION: Demonstrates how to use `render_to_string` to convert a Sycamore view into an HTML string for server-side rendering. This function returns a string that can be sent to the browser using any web server.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/server-side-rendering.md#2025-04-18_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet html = render_to_string(|| view! {\n    div(class=\"my-class\") {\n        button { \"Click me\" }\n    }\n});\n\n// Respond to the client with the rendered html.\n```\n\n----------------------------------------\n\nTITLE: Attribute Passthrough Component Example\nDESCRIPTION: Example demonstrating the new attribute passthrough feature in Sycamore v0.9. This shows how to create a Button component that can accept and forward HTML attributes to the underlying button element.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/posts/announcing-v0-9-0.md#2025-04-18_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n#[component(inline_props)]\nfn Button(\n    #[prop(attributes(html, button))]\n    attributes: Attributes,\n    children: Children,\n    accent: StringAttribute,\n) -> View {\n    view! {\n        // Spread the attributes onto the wrapped element.\n        button(..attributes) {\n            (children)\n        }\n    }\n}\n\n// Now use your component just as if it were a normal HTML element.\nview! {\n    Button(\n        class=\"btn btn-red\",\n        id=\"login-button\",\n        on:click=move |_| login(),\n        // `accent` is passed as a prop, not as an attribute.\n        accent=\"primary\",\n    ) {\n        \"Login\"\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Passing Reactive State to Components\nDESCRIPTION: Demonstrates how to pass reactive state to child components using ReadSignal as a prop type.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/adding-state.md#2025-04-18_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\n#[component(inline_props)]\nfn CounterDisplay(value: ReadSignal<i32>) -> View {\n    view! {\n        div {\n            p { \"Counter value: \" (value) }\n        }\n    }\n}\n\nlet counter = create_signal(1);\n\nview! {\n    CounterDisplay(value=*counter)\n}\n```\n\n----------------------------------------\n\nTITLE: Updating TodoList Component to Support Todo Removal\nDESCRIPTION: Modifies the TodoList component to accept and pass down the remove_todo callback to each TodoItem. This enables prop passing through the component hierarchy.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/todo-app.md#2025-04-18_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n#[component(inline_props)]\nfn TodoList<F>(#[prop(setter(into))] todos: MaybeDyn<Vec<Todo>>, remove_todo: F) -> View\nwhere\n    F: Fn(u32) + Copy + 'static,\n{\n    view! {\n        ul {\n            Keyed(\n                list=todos,\n                view=move |todo| view! { TodoItem(todo=todo, remove_todo=remove_todo) },\n                key=|todo| todo.id,\n            )\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Reading and Writing Signal Values in Sycamore\nDESCRIPTION: Shows how to read a signal's value with get(), update it with set(), and use the Display implementation for signals.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/adding-state.md#2025-04-18_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet signal = create_signal(123);\n// Should print `123`.\nconsole_log!(\"{}\", signal.get());\n\n// Update the signal with a new value.\nsignal.set(456);\n\n// Should print `456`.\nconsole_log!(\"{}\", signal.get());\n// `Signal<T>` also implements `Display` so this is the same as the above.\nconsole_log!(\"{signal}\");\n```\n\n----------------------------------------\n\nTITLE: Providing Context in Sycamore Components\nDESCRIPTION: Demonstrates how to create and provide a context value in Sycamore using the provide_context function. This example creates a DarkMode context with an initial value of false and makes it available to child components.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/guide/contexts.md#2025-04-18_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet dark_mode = DarkMode(create_signal(false));\nprovide_context(dark_mode);\n```\n\n----------------------------------------\n\nTITLE: Attaching Node References in Sycamore\nDESCRIPTION: Shows how to attach node references to elements using the r#ref method.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/guide/view-builder.md#2025-04-18_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nlet node = create_node_ref();\nbutton().r#ref(node)\n```\n\n----------------------------------------\n\nTITLE: Using MaybeDyn for Flexible Reactive Props\nDESCRIPTION: Shows how to use MaybeDyn to accept various forms of reactive data (signals, memos, or derived closures) as component props.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/adding-state.md#2025-04-18_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\n// `#[prop(setter(into))]` let's us use anything that implements `Into<MaybeDyn<T>>`.\n// This includes both `Signal` and `ReadSignal` as well as functions.\n#[component(inline_props)]\nfn CounterDisplay(#[prop(setter(into))] value: MaybeDyn<i32>) -> View { ... }\n```\n\n----------------------------------------\n\nTITLE: Implementing Component Children in Sycamore v0.8 (Rust)\nDESCRIPTION: This code snippet shows how to implement and use component children in Sycamore v0.8. It defines a component that accepts children and demonstrates how to use it in a view.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/posts/announcing-v0-8-0.md#2025-04-18_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Prop)]\nstruct MyProps<'a, G: Html> {\n    children: Children<'a, G>\n}\n\n#[component]\nfn MyComponent<'a, G: Html>(cx: Scope<'a>, props: MyProps<'a, G>) -> View<G> { ... }\n\nview! { cx,\n    MyComponent {\n        p { \"Children\" }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Sycamore Component\nDESCRIPTION: Example of defining and using a simple App component in Sycamore using the #[component] attribute, demonstrating component-based architecture.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/your-first-app.md#2025-04-18_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\n#[component]\nfn App() -> View {\n    view! {\n        div {\n            h1 { \"Hello, world!\" }\n            p { \"This is my first Sycamore app\" }\n        }\n    }\n}\n\nfn main() {\n    sycamore::render(App);\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating Component Arguments and Children in Sycamore v0.8\nDESCRIPTION: Demonstrates the new way to pass arguments and children to components in Sycamore v0.8, which now uses the same syntax as elements instead of the struct-based approach from v0.7.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/migration/0-7-to-0-8.md#2025-04-18_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// Old v0.7 syntax.\nview! {\n    MyComponent(MyProps {\n        foo: true,\n        bar: \"abc\",\n        children: view! { ... }\n    })\n}\n\n// New v0.8 syntax.\nview! { cx,\n    MyComponent(foo=true, bar=\"abc\") {\n        ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Component Usage in Sycamore Views\nDESCRIPTION: Demonstrates how to define and use components within Sycamore views\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/guide/view-dsl.md#2025-04-18_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n#[component(inline_props)]\nfn Button(class: String) -> View { ... }\n\nview! {\n    div {\n        Button(class=\"my-button\".to_string())\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Value Interpolation in Sycamore Views\nDESCRIPTION: Demonstrates how to interpolate values including signals and expressions into Sycamore views\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/guide/view-dsl.md#2025-04-18_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nlet value = 123;\nlet signal = create_signal(456);\n\nview! {\n    p {\n        \"Value: \" (value)\n    }\n    p {\n        // Equivalent of (move || signal.get() + 1)\n        (signal.get() + 1)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Components with Props in Sycamore\nDESCRIPTION: Example of using a component with props in Sycamore, passing a string value to a custom Hello component.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/your-first-app.md#2025-04-18_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\nview! {\n    Hello(name=\"Sycamore\".into())\n}\n```\n\n----------------------------------------\n\nTITLE: Using #[derive(Props)] Macro in Sycamore Rust Framework\nDESCRIPTION: This is a placeholder for documentation about the #[derive(Props)] macro in Sycamore. The macro is used for creating component props in the Sycamore framework but the full documentation of configuration options is not yet available.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/reference/derive-props.md#2025-04-18_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Props)]\n```\n\n----------------------------------------\n\nTITLE: Adding Event Handlers in Sycamore Views\nDESCRIPTION: Demonstrates how to attach event handlers to elements using the on:* directive\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/guide/view-dsl.md#2025-04-18_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nview! {\n    button(on:click=|_| { /* do something interesting */ }) {\n        \"Click me\"\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: View Interpolation in Sycamore\nDESCRIPTION: Shows how to interpolate nested views within other views using Sycamore's view! macro\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/guide/view-dsl.md#2025-04-18_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nlet details = view! {\n    div { \"Details\" }\n};\n\nlet outer_view = view! {\n    h1 { \"Why is Rust the best language\" }\n    (details)\n};\n```\n\n----------------------------------------\n\nTITLE: Creating a Simple Component in Sycamore with Rust\nDESCRIPTION: This snippet demonstrates the basic syntax for creating a component in Sycamore. It defines a 'Hello' component function that returns a View containing a paragraph with 'Hello World!' text. The #[component] attribute marks this function as a Sycamore component.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/README.md#2025-04-18_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[component]\nfn Hello() -> View {\n    view! {\n        p { \"Hello World!\" }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Passing Remove Callback to TodoList from App Component\nDESCRIPTION: Updates the App component's view to pass the remove_todo function to the TodoList component, enabling the removal functionality throughout the component tree.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/todo-app.md#2025-04-18_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nview! {\n    TodoList(todos=todos, remove_todo=remove_todo)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Component Props with Default and Optional Values in Sycamore v0.8 (Rust)\nDESCRIPTION: This snippet demonstrates how to define component props in Sycamore v0.8 using the #[derive(Prop)] macro. It shows how to set default values and create optional props using attributes.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/posts/announcing-v0-8-0.md#2025-04-18_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Prop)]\nstruct MyProps {\n    #[builder(default)]\n    count: i64,\n}\n\n#[derive(Prop)]\nstruct MyProps {\n    #[builder(default, setter(strip_option))]\n    email: Option<String>,\n}\n```\n\n----------------------------------------\n\nTITLE: New Builder API Example in Sycamore v0.9\nDESCRIPTION: Demonstration of the new builder API in Sycamore v0.9, showing how to create nested DOM elements with attributes and children. This showcases the first-class builder API which the view macro now uses under the hood.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/posts/announcing-v0-9-0.md#2025-04-18_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\ndiv().class(\"hello-world\").children((\n    span().style(\"color: red\").children(\"Hello \"),\n    em().children(\"World!\"),\n))\n```\n\n----------------------------------------\n\nTITLE: Enabling wasm-opt with Trunk\nDESCRIPTION: Adding a data-trunk attribute to enable wasm-opt optimization in the HTML file. This instructs Trunk to apply additional WASM-specific optimizations during the build process.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/cookbook/optimize-wasm-size.md#2025-04-18_snippet_2\n\nLANGUAGE: html\nCODE:\n```\n<link data-trunk rel=\"rust\" data-wasm-opt=\"s\" />\n```\n\n----------------------------------------\n\nTITLE: Adding New Items with Nested Signals in Sycamore\nDESCRIPTION: Demonstrates how to add new items to a reactive list when using nested signals. The example shows updating a signal containing a vector of Todo items by pushing a new Todo with its own reactive task property.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/rendering-lists.md#2025-04-18_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nlet todos = create_signal(vec![...]);\n\nlet new_task = \"Cook Dinner\".to_string();\n// Signal::update is similar to Signal::set but gives you a &mut.\n// This allows us to avoid cloning the entire Vec.\ntodos.update(|todos| todos.push(Todo {\n    task: create_signal(new_task),\n    // Generate a unique key by using an incrementing counter or using UUIDs.\n    id: get_unique_id(),\n}));\n```\n\n----------------------------------------\n\nTITLE: Implementing Todo Add and Remove Functions\nDESCRIPTION: Creates closures for adding and removing todos. The add_todo function creates a new Todo with the given task and a unique ID, while remove_todo filters out the todo with the specified ID.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/todo-app.md#2025-04-18_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nlet add_todo = move |task| {\n    todos.update(|todos| {\n        todos.push(Todo {\n            task: create_signal(task),\n            completed: create_signal(false),\n            id: get_next_id(),\n        })\n    })\n};\n\nlet remove_todo = move |id| todos.update(|todos| todos.retain(|todo| todo.id != id));\n```\n\n----------------------------------------\n\nTITLE: Builder Syntax Comparison in Sycamore v0.9\nDESCRIPTION: Comparison of the old and new builder API syntax. The new API provides better type checking for attributes and introduces a more structured approach to defining children with the children() method instead of c() and t().\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/migration/0-8-to-0-9.md#2025-04-18_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n// Old\ndiv()\n    .c(h1()\n        .t(\"Hello \")\n        .dyn_if(\n            move || !name.with(String::is_empty),\n            move || span().dyn_t(move || name.get_clone()),\n            move || span().t(\"World\"),\n        )\n        .t(\"!\"))\n    .c(input().bind_value(name))\n    .view();\n\n// New\ndiv()\n    .children((\n        h1().children((\n            \"Hello \",\n            move || {\n                if !name.with(String::is_empty) {\n                    span().children(move || name.get_clone())\n                } else {\n                    span().children(\"World\")\n                }\n            },\n            \"!\",\n        )),\n        input().bind(bind::value, name),\n    ))\n    .into();\n```\n\n----------------------------------------\n\nTITLE: Template Fragment Example in Rust\nDESCRIPTION: Example showing document fragments usage in the template! macro, allowing multiple top-level elements.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/CHANGELOG.md#2025-04-18_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\ntemplate! {\n    p { \"First\" }\n    p { \"Second\" }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Assigning a NodeRef in Sycamore\nDESCRIPTION: This snippet demonstrates how to create a NodeRef with create_node_ref() and assign it to a paragraph element using the r#ref property in a view macro.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/guide/node-ref.md#2025-04-18_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet node_ref = create_node_ref();\n\nview! {\n    p(r#ref=node_ref) { \"Hello World!\" }\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing the DOM Node from a NodeRef in Sycamore\nDESCRIPTION: This snippet shows how to access the underlying DOM node from a NodeRef using the .get() method. This should be done within on_mount or event handlers to avoid panics on the server.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/guide/node-ref.md#2025-04-18_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet node = node_ref.get();\n```\n\n----------------------------------------\n\nTITLE: Creating an External Link in Sycamore Template\nDESCRIPTION: Example of creating an anchor tag with rel=\"external\" to opt out of Sycamore's router and use default browser navigation.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/CHANGELOG.md#2025-04-18_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\ntemplate! {\n    a(href=\"path\", rel=\"external\") { \"Link\" }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding HTML Attributes in Sycamore Views\nDESCRIPTION: Demonstration of adding HTML attributes to elements in Sycamore views, showing how to set an ID on a heading element.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/your-first-app.md#2025-04-18_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nview! {\n    h1(id=\"hello-world\") { \"Hello, world!\" }\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Reactive State in Views\nDESCRIPTION: Shows how to include reactive state in a view template using interpolation, where the UI automatically updates when the state changes.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/adding-state.md#2025-04-18_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nlet counter = create_signal(1);\n\nview! {\n    p { \"Count: \" (counter) }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Element Properties in Sycamore\nDESCRIPTION: Demonstrates how to set properties on elements using the .prop() method.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/guide/view-builder.md#2025-04-18_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\ninput().r#type(\"checkbox\").prop(\"indeterminate\", true)\n```\n\n----------------------------------------\n\nTITLE: Refactoring Event Handlers for Cleaner Views\nDESCRIPTION: Demonstrates how to extract event handler logic to a local variable for cleaner view templates and using Signal's AddAssign implementation.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/adding-state.md#2025-04-18_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nlet increment = move |_| counter.set(counter.get() + 1);\nview! {\n    button(on:click=increment) { \"Increment\" }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Routes with Rust Enums\nDESCRIPTION: Creating a basic route structure using Rust enums with the Route derive macro. Includes index, about, and not_found routes with their corresponding URL paths.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/router.md#2025-04-18_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Route, Clone)]\nenum AppRoutes {\n    #[to(\"/\")]\n    Index,\n    #[to(\"/about\")]\n    About,\n    #[not_found]\n    NotFound,\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Event Listeners in Sycamore\nDESCRIPTION: Shows how to attach event listeners to elements using the .on() method.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/guide/view-builder.md#2025-04-18_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nbutton().on(ev::click, |_| console_log!(\"clicked!\")).children(\"Click me!\")\n```\n\n----------------------------------------\n\nTITLE: Dynamic Path Segments with Variadic Capture\nDESCRIPTION: Implementing a route that captures multiple path segments using the variadic syntax. This allows matching arbitrary depth URL paths.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/router.md#2025-04-18_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n#[to(\"/page/<path..>\")]\nPage {\n    path: Vec<String>,\n}\n```\n\n----------------------------------------\n\nTITLE: Creating an Async Component with Data Fetching in Sycamore v0.8 (Rust)\nDESCRIPTION: This snippet demonstrates how to create an async component in Sycamore v0.8. It includes an async function for data fetching and shows how to use await within the component.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/posts/announcing-v0-8-0.md#2025-04-18_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nasync fn fetch_data() -> Data { ... }\n\n#[component]\nasync fn DataDisplayer<G: Html>(cx: Scope) -> View<G> {\n    let data = fetch_data().await;\n    view! { cx, ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Properties in Sycamore Views\nDESCRIPTION: Shows how to set element properties using the prop:* directive in Sycamore views\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/guide/view-dsl.md#2025-04-18_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nview! {\n    input(r#type=\"checkbox\", prop:indeterminate=true)\n}\n```\n\n----------------------------------------\n\nTITLE: Using Unit Variants for Simple Routes\nDESCRIPTION: Defining routes with tuple variants instead of struct variants for simpler route parameters. This provides a more concise syntax for single-parameter routes.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/router.md#2025-04-18_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n#[to(\"/hello/<name>\")]\nHello(String)\n```\n\n----------------------------------------\n\nTITLE: Using Suspense for Async Components in Sycamore v0.8 (Rust)\nDESCRIPTION: This code snippet shows how to use the Suspense component in Sycamore v0.8 to display a loading indicator while an async component is working.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/posts/announcing-v0-8-0.md#2025-04-18_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nview! { cx,\n    Suspense(fallback=view! { cx, \"Loading...\" }) {\n        DataDisplayer {}\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Optional Attributes in Sycamore Views\nDESCRIPTION: Shows how to use Optional values for attributes that may or may not be present\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/guide/view-dsl.md#2025-04-18_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nlet attr = create_signal(None::<String>);\nview! {\n    div(data-attr=attr)\n    // Will render <div></div> instead of <div data-attr></div> if attr is None.\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Elements to Views in Sycamore Components\nDESCRIPTION: Shows how to convert specific element types into Views using .into() when composing a component.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/guide/view-builder.md#2025-04-18_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[component]\nfn Button() -> View {\n    button().into()\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Children to Elements in Sycamore\nDESCRIPTION: Demonstrates how to add child nodes to an element using the .children() method.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/guide/view-builder.md#2025-04-18_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\ndiv().children(\n    p().children(\"Hello World!\")\n)\n```\n\n----------------------------------------\n\nTITLE: Intercepting and Modifying Attributes in Sycamore Components\nDESCRIPTION: Demonstrates how to intercept specific attributes in a component to modify them before they're applied. This example shows intercepting the 'class' attribute to add additional classes while preserving the original ones from attribute passthrough.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/guide/attribute-passthrough.md#2025-04-18_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse sycamore::web::StringAttribute;\n\n#[component(inline_props)]\nfn Button(\n    #[prop(attributes(html, button))]\n    attributes: Attributes,\n    // StringAttribute is a type alias for MaybeDyn containing a string.\n    class: StringAttribute,\n) -> View {\n    // We still want the attribute to be reactive.\n    let class = move || format!(\"{class} custom-button\");\n    view! {\n        button(class=class, ..attributes)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating HTML Elements in Sycamore's Builder API\nDESCRIPTION: Demonstrates how to create HTML elements by calling the corresponding functions for each HTML tag.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/guide/view-builder.md#2025-04-18_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\na()\nbutton()\ndiv()\n// etc...\n```\n\n----------------------------------------\n\nTITLE: Migrating Component Syntax from v0.7 to v0.8 in Rust Sycamore\nDESCRIPTION: Shows the changes in the component macro syntax from Sycamore v0.7 to v0.8. The new syntax no longer requires the component name as a parameter and encourages using PascalCase for component function names. Generic type parameters now need explicit trait bounds.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/migration/0-7-to-0-8.md#2025-04-18_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// Old v0.7 syntax.\n#[component(MyComponent<G>)]\nfn my_component(props: MyProps) -> View<G> { ... }\n\n// New v0.8 syntax.\n#[component]\nfn MyComponent<G: Html>(props: MyProps) -> View<G> { ... }\n```\n\n----------------------------------------\n\nTITLE: Implementing Server-Side Rendering with Sycamore in Rust\nDESCRIPTION: A simple example demonstrating how to use Sycamore's server-side rendering capability with render_to_string. This function converts a template into HTML markup which can be served directly from a server.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/posts/announcing-v0-5-0.md#2025-04-18_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse sycamore::prelude::*;\n\nfn main() {\n    let string = sycamore::render_to_string(|| template! {\n        p { \"Hello, world!\" }\n    });\n    println!(\"{}\", string); // Prints <p>Hello, world!</p>\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Sycamore as a Dependency in Cargo.toml\nDESCRIPTION: Manual approach to add Sycamore as a dependency by editing the Cargo.toml file directly with the specific version.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/your-first-app.md#2025-04-18_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\nsycamore = \"0.9.1\"\n```\n\n----------------------------------------\n\nTITLE: Direct Signal Interpolation in Views\nDESCRIPTION: Example showing the simplified syntax for interpolating signals in views in v0.9. Signals can now be directly interpolated without the need to call get() explicitly, creating a more concise and readable syntax.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/migration/0-8-to-0-9.md#2025-04-18_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n// Old\nview! {\n    (signal.get())\n}\n\n// New\nview! {\n    (signal)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Nested Elements in Sycamore View DSL\nDESCRIPTION: Shows how to create nested elements and text nodes using Sycamore's view! macro syntax\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/guide/view-dsl.md#2025-04-18_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nview! {\n    // An empty div\n    div {}\n    // A div with a paragraph\n    div {\n        p { \"Hello, world!\" }\n    }\n    // Custom elements also work\n    my-custom-element {}\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Server-Side StaticRouter in Sycamore\nDESCRIPTION: Creating a StaticRouter component for server-side rendering (SSR). Unlike the client-side Router, this requires providing the initial route during initialization.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/router.md#2025-04-18_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nlet route = AppRoutes::match_path(path);\n\nview! {\n    StaticRouter(\n        route=route,\n        view=|route: ReadSignal<AppRoutes>| {\n            view! {\n                div(class=\"app\") {\n                    (match route.get_clone() {\n                        AppRoutes::Index => view! {\n                            \"This is the index page\"\n                        },\n                        AppRoutes::About => view! {\n                            \"About this website\"\n                        },\n                        AppRoutes::NotFound => view! {\n                            \"404 Not Found\"\n                        },\n                    })\n                }\n            }\n        }\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Indexed Component Syntax Update\nDESCRIPTION: Example showing how the property name for iterables has changed from 'iterable' to 'list' in Indexed and Keyed components, and demonstrating that static vectors can now be used directly without creating a signal.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/migration/0-8-to-0-9.md#2025-04-18_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n// Old\nview! {\n    Indexed(\n        iterable=...,\n        view=...,\n    )\n}\n// New\nview! {\n    Indexed(\n        list=...,\n        view=...,\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Using Signal's AddAssign Implementation\nDESCRIPTION: Shows how to use Signal's implementation of AddAssign trait for more concise state updates.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/adding-state.md#2025-04-18_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n// Notice the `mut` here. This is required because of the `AddAssign` trait.\nlet mut counter = create_signal(1);\nlet increment = move |_| counter += 1;\n```\n\n----------------------------------------\n\nTITLE: Dynamic Path Segments with End Capture\nDESCRIPTION: Creating a route that captures variable segments in the middle with a specific final segment. The dynamic part will capture segments lazily.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/router.md#2025-04-18_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n#[to(\"/start/<path..>/<end>\")]\nPath {\n    path: Vec<String>,\n    end: String,\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Trunk Build Tool\nDESCRIPTION: Various commands for installing Trunk, the recommended build tool for Sycamore applications, using different package managers or direct download methods.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/your-first-app.md#2025-04-18_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Install via homebrew on Mac, Linux or Windows (WSL).\nbrew install trunk\n\n# Install a release binary (great for CI).\n# You will need to specify a value for ${VERSION}.\nwget -qO- https://github.com/thedodd/trunk/releases/download/${VERSION}/trunk-x86_64-unknown-linux-gnu.tar.gz | tar -xzf-\n\n# Install via cargo.\ncargo install --locked trunk\n```\n\n----------------------------------------\n\nTITLE: Static Lists in Indexed/Keyed Components\nDESCRIPTION: Example demonstrating how v0.9 allows passing static Vec directly to Indexed/Keyed components without needing to wrap it in a signal, simplifying the code for cases where the list doesn't need to be reactive.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/migration/0-8-to-0-9.md#2025-04-18_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n// Old\nview! {\n    Indexed(\n        list=*create_signal(vec![...]),\n        view=...,\n    )\n}\n// New\nview! {\n    Indexed(\n        list=vec![...],\n        view=...,\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Using NodeRef in Sycamore Views\nDESCRIPTION: Demonstrates how to use the r#ref attribute to set NodeRef references to elements\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/guide/view-dsl.md#2025-04-18_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nlet node = create_node_ref();\nview! {\n    button(r#ref=node)\n}\n```\n\n----------------------------------------\n\nTITLE: Type-Safe Route Parameters with TryFromParam\nDESCRIPTION: Using non-String types for route parameters that implement TryFromParam. Routes will only match if the parameter can be parsed into the specified type.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/router.md#2025-04-18_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n#[to(\"/account/<id>\")]\nAccount { id: u32 }\n```\n\n----------------------------------------\n\nTITLE: Creating a New Rust Project for Sycamore\nDESCRIPTION: Commands to create a new Rust project directory structure and navigate into it, preparing for Sycamore application development.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/your-first-app.md#2025-04-18_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncargo new hello-sycamore\ncd hello-sycamore\n```\n\n----------------------------------------\n\nTITLE: Optimizing Cargo.toml Configuration for WASM Size\nDESCRIPTION: Configuration settings for the release profile in Cargo.toml to minimize WASM binary size. These settings disable panic backtraces, reduce codegen units, optimize for size, and enable link-time optimization.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/cookbook/optimize-wasm-size.md#2025-04-18_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[profile.release]\n# Do not perform backtrace for panic on release builds.\npanic = 'abort'\n# Perform optimizations on all codegen units.\ncodegen-units = 1\n# Optimize for size.\nopt-level = 's' # or 'z' to optimize \"aggressively\" for size\n# Enable link time optimization.\nlto = true\n```\n\n----------------------------------------\n\nTITLE: Adding Multiple Children with Tuples in Sycamore\nDESCRIPTION: Shows how to add multiple children to an element in one call using tuples.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/guide/view-builder.md#2025-04-18_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\ndiv().children((\n    span().children(\"Hello \"),\n    span().children(\"World!\"),\n))\n```\n\n----------------------------------------\n\nTITLE: Initializing Empty Todo List in App Component\nDESCRIPTION: Sets up the App component with an empty vector of todos using create_signal, which makes the list reactive and will trigger re-renders when modified.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/todo-app.md#2025-04-18_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[component]\nfn App() -> View {\n    let todos = create_signal(Vec::new());\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Building WASM in Release Mode with Trunk\nDESCRIPTION: Using the --release flag with Trunk to build a production-ready, size-optimized WASM binary. This is the simplest way to significantly reduce the binary size compared to debug builds.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/cookbook/optimize-wasm-size.md#2025-04-18_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntrunk build --release\n```\n\n----------------------------------------\n\nTITLE: Multiple Dynamic Parameters in Sycamore Routes\nDESCRIPTION: Creating a route with multiple dynamic parameters that capture different parts of the URL path. Useful for resources that need multiple identifiers.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/router.md#2025-04-18_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[to(\"/repo/<org>/<name>\")]\nRepo {\n    org: String,\n    name: String,\n}\n```\n\n----------------------------------------\n\nTITLE: Using Signal with cloning in previous Sycamore versions\nDESCRIPTION: Shows how Signals needed to be cloned before being used in closures in previous versions of Sycamore. This approach was necessary because Signal was Clone but not Copy.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/posts/new-reactive-primitives.md#2025-04-18_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet data = Signal::new(...);\nlet callback = {\n    let data = data.clone();\n    move || {\n        // Do something useful with `data`\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Potential async component with Scope in Sycamore\nDESCRIPTION: Shows a potential future implementation of an async component in Sycamore, where the reactive scope (cx) remains accessible even after await suspension points.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/posts/new-reactive-primitives.md#2025-04-18_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n#[component]\nasync fn AsyncFetch<G: Html>(cx: Scope) -> View<G> {\n    let data = fetch_data().await;\n    let derived = create_memo(cx, || data);\n    //                        ^^ -> We can still access `cx`, even after the `.await` suspension point.\n    view! {\n        (derived)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Component Definition in Sycamore v0.9\nDESCRIPTION: Example of the simplified component definition in Sycamore v0.9 using View v2. This demonstrates how the new API removes lifetime annotations and generic parameters for a cleaner interface.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/posts/announcing-v0-9-0.md#2025-04-18_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n#[component(inline_props)]\nfn Component(value: ReadSignal<i32>) -> View {\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Signal ownership problem in view! macro\nDESCRIPTION: Illustrates the issue with Signals in the view! macro, where a Signal gets moved into the first closure that uses it, making it unavailable for subsequent uses within the same view.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/posts/new-reactive-primitives.md#2025-04-18_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nlet data = Signal::new(...);\nview! {\n    p { (data.get()) }\n    //   ^^^^ -> `data` is moved into a closure here\n    p { (data.get()) }\n    //   ^^^^ -> ERROR: `data` already moved\n}\n```\n\n----------------------------------------\n\nTITLE: Signal creation comparison between old and new Sycamore\nDESCRIPTION: Compares the syntax for creating a Signal in the old versus new Sycamore reactive system, showing how the new approach requires a reactive scope reference.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/posts/new-reactive-primitives.md#2025-04-18_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n// Before:\nlet data = Signal::new(...);\n// After:\nlet data = create_signal(cx, ...);\n```\n\n----------------------------------------\n\nTITLE: Accessing Signal Values with Explicit Clone in Reactivity v3\nDESCRIPTION: Example demonstrating how to access values from signals in the new reactivity system. For non-Copy types like String, the get_clone() method must be used explicitly instead of the previous automatic wrapping in Rc.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/migration/0-8-to-0-9.md#2025-04-18_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet number: Signal<i32> = create_signal(123);\nlet string: Signal<String> = create_signal(\"Hello, Sycamore!\".to_string());\n\n// `i32` implements `Copy`.\nlet _: i32 = number.get();\n// `String` does not implement `Copy` but implements `Clone`.\nlet _: String = string.get_clone();\n```\n\n----------------------------------------\n\nTITLE: Signal cloning workaround in view! macro\nDESCRIPTION: Shows the previous workaround for using a Signal multiple times in the view! macro by creating a clone with a different variable name before the macro call.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/posts/new-reactive-primitives.md#2025-04-18_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nlet data = Signal::new(...);\nlet data_cloned = data.clone();\nview! {\n    p { (data.get()) }\n    //   ^^^^ -> `data` is moved into a closure here\n    p { (data_cloned.get()) }\n    //   ^^^^ -> Ok. We are using `data_cloned`, not `data`.\n}\n```\n\n----------------------------------------\n\nTITLE: Component Definition in Sycamore v0.8\nDESCRIPTION: Example of how components were defined in Sycamore v0.8, showing the verbose syntax with generic parameters and lifetimes. This demonstrates the previous approach requiring `GenericNode` and `Html` traits.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/posts/announcing-v0-9-0.md#2025-04-18_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[component(inline_props)]\nfn Component<'a, G: Html>(cx: Scope<'a>, value: &'a ReadSignal<i32>) -> View<G> {\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Higher-Order Components in Rust with Sycamore\nDESCRIPTION: Demonstrates how to create generic components that can wrap other components, similar to React's higher-order components pattern. The component takes a generic type parameter and accepts a component with Props of type i32.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/posts/announcing-v0-6-0.md#2025-04-18_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[component(EnhancedComponent<G>)]\nfn enhanced_component<C: Component<G, Props = i32>>() -> Template<G> {\n    template! {\n        div(class=\"enhanced-container\") {\n            C(42)\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Signal lifetime limitations with Scope in Sycamore\nDESCRIPTION: Illustrates a limitation of the new Scope-based Signals: they cannot escape the Scope they were created in, as their lifetime is tied to the Scope.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/posts/new-reactive-primitives.md#2025-04-18_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nlet mut outer = None;\n// Crete a new reactive scope and allow access to it through `cx`.\ncreate_scope(|cx| {\n    let data = create_signal(cx, 0);\n    outer = Some(data);\n    //           ^^^^ -> ERROR: `data` cannot escape\n});\n```\n\n----------------------------------------\n\nTITLE: Type-Checked HTML Element Tags in Sycamore v0.8 (Rust)\nDESCRIPTION: This snippet demonstrates the type-checking of HTML element tags in Sycamore v0.8, showing a valid and an invalid tag usage.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/posts/announcing-v0-8-0.md#2025-04-18_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nview! { cx,\n    div {} // OK.\n    notvalid {} // Compile time error.\n}\n```\n\n----------------------------------------\n\nTITLE: Using Signals without cloning in new Sycamore\nDESCRIPTION: Demonstrates how the new Sycamore reactive system allows using Signals in multiple closures without cloning, due to Signals now being Copy when created with a scope.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/posts/new-reactive-primitives.md#2025-04-18_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nlet data = create_signal(cx, ...);\nlet callback = || data.get();\n//             ^^ -> Look ma, no clones!\nlet another_callback = || data.get();\ncreate_effect(cx, || {\n    log::info!(\"{data}\");\n});\n```\n\n----------------------------------------\n\nTITLE: Creating External Links in Sycamore Router\nDESCRIPTION: Creating anchor tags that bypass the router's interception using the rel=\"external\" attribute. This allows the browser to handle navigation for specific links.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/router.md#2025-04-18_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nview! {\n    a(href=\"path\", rel=\"external\") { \"Path\" }\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating Keyed and Indexed Props in Sycamore v0.8\nDESCRIPTION: Demonstrates how to update Keyed component usage from v0.7 to v0.8, including the rename of the 'template' prop to 'view' and changes to the general syntax structure.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/migration/0-7-to-0-8.md#2025-04-18_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n// Old v0.7 syntax.\nKeyed(KeyedProps {\n    iterable: count.handle(),\n    template: |x| view! {\n        li { (x) }\n    },\n    key: |x| *x,\n})\n\n// New 0.8 syntax.\nKeyed(\n    iterable=count,\n    view=|cx, x| view! { cx,\n        li { (x) }\n    },\n    key=|x| *x,\n)\n```\n\n----------------------------------------\n\nTITLE: Setting Inner HTML in Sycamore Views\nDESCRIPTION: Shows how to use the dangerously_set_inner_html attribute to set raw HTML content, with security warnings\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/guide/view-dsl.md#2025-04-18_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nview! {\n    div(dangerously_set_inner_html=\"<span>Inner HTML!</span>\")\n\n    // DO NOT DO THIS!!!\n    div(dangerously_set_inner_html=user_input)\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Signal Values with Nightly Feature in Sycamore\nDESCRIPTION: Example showing how the nightly feature enables a more concise syntax for accessing signal values by simply calling the signal as a function, compared to the standard get() method required on stable Rust.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/migration/0-8-to-0-9.md#2025-04-18_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// Stable\nlet value = signal.get();\n// Nightly only\nlet value = signal();\n```\n\n----------------------------------------\n\nTITLE: Importing HTML Tags for Builder API in Rust\nDESCRIPTION: Shows how to import all the builder HTML tags from Sycamore's web module to use with the builder API.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/guide/view-builder.md#2025-04-18_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse sycamore::web::tags::*;\n```\n\n----------------------------------------\n\nTITLE: Using Inline Props in Sycamore Components\nDESCRIPTION: Simplified approach to component props using the inline_props attribute, which automatically generates the props struct from function parameters.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/your-first-app.md#2025-04-18_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\n#[component(inline_props)]\nfn Wrapper(children: Children) -> View {\n    view! {\n        div {\n            (children)\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Sync Mode SSR in Sycamore\nDESCRIPTION: Default SSR mode accessed via render_to_string. Never fetches data on server side and always renders suspense fallback.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/server-side-rendering/streaming.md#2025-04-18_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nrender_to_string\n```\n\n----------------------------------------\n\nTITLE: Empty Template Example in Rust\nDESCRIPTION: Example showing empty template syntax in the template! macro.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/CHANGELOG.md#2025-04-18_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\ntemplate! {}\n```\n\n----------------------------------------\n\nTITLE: Setting Inner HTML Content in Sycamore\nDESCRIPTION: Demonstrates how to set inner HTML content using the dangerously_set_inner_html method.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/guide/view-builder.md#2025-04-18_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\ndiv().dangerously_set_inner_html(inner_html)\n```\n\n----------------------------------------\n\nTITLE: Implementing Blocking Mode SSR in Sycamore\nDESCRIPTION: Blocking SSR mode that waits for all suspense to resolve before sending HTML. Accessed via render_to_string_await_suspense method.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/server-side-rendering/streaming.md#2025-04-18_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nrender_to_string_await_suspense\n```\n\n----------------------------------------\n\nTITLE: Creating a Reducer in Rust with Sycamore\nDESCRIPTION: Example of using the create_reducer hook in Sycamore 0.6.0 to manage state with a reducer function.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/CHANGELOG.md#2025-04-18_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nenum Msg {\n    Increment,\n    Decrement,\n}\nlet (state, dispatch) = create_reducer(0, |state, msg: Msg| match msg {\n    Msg::Increment => *state + 1,\n    Msg::Decrement => *state - 1,\n});\n```\n\n----------------------------------------\n\nTITLE: Demonstrating New Reactivity Syntax in Sycamore v0.8 (Rust)\nDESCRIPTION: This snippet compares the old v0.7 syntax with the new v0.8 syntax for creating signals and effects in Sycamore. It showcases the explicit 'cx' parameter and removal of cloning.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/posts/announcing-v0-8-0.md#2025-04-18_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// Old v0.7 syntax.\nlet signal = Signal::new(123);\ncreate_effect({\n    let signal = signal.clone();\n    move || {\n        let _ = signal.get();\n    }\n});\nview! {\n    div {}\n}\n\n// New v0.8 syntax.\nlet signal = create_signal(cx, 123);\ncreate_effect(cx, || {\n    let _ = signal.get();\n});\nview! { cx,\n    div {}\n}\n```\n\n----------------------------------------\n\nTITLE: Boolean Attribute Usage Comparison in Sycamore Templates\nDESCRIPTION: Shows the improvement in handling boolean attributes in Sycamore v0.6.0, comparing the old verbose approach with the new simplified syntax for conditional attribute rendering.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/posts/announcing-v0-6-0.md#2025-04-18_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// Before\ntemplate! {\n    (if *my_signal.get() {\n        template! {\n            button(disabled=\"\") { ... }\n        }\n    } else {\n        template! {\n            button() { ... }\n        }\n    })\n}\n// After\ntemplate! {\n    button(disabled=*my_signal.get()) { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Markdown Frontmatter for Sycamore Reference Page\nDESCRIPTION: YAML frontmatter block defining the page title and subsection structure for the Sycamore reference documentation.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/reference.md#2025-04-18_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n---\ntitle: Reference\nsubsections:\n  - reactive-graph\n  - derive-props\n---\n\n# Reference\n\nThis section provides some in-depth details about core systems in Sycamore.\n```\n\n----------------------------------------\n\nTITLE: Reactivity v2 Example with Context Parameter\nDESCRIPTION: An example showing the older Reactivity v2 approach which required passing the context parameter (`cx`) and dealing with lifetimes. This demonstrates the previous way of creating signals and effects.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/posts/announcing-v0-9-0.md#2025-04-18_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet signal = create_signal(cx, 123);\ncreate_effect_scoped(cx, |cx| {\n    let nested = create_signal(cx, 456);\n    println!(\"{signal}, {nested}\");\n});\n```\n\n----------------------------------------\n\nTITLE: Updated Empty Element Syntax in Sycamore v0.8\nDESCRIPTION: Shows how empty elements must now be followed by an empty block in Sycamore v0.8, which is a change from the simpler syntax in v0.7.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/migration/0-7-to-0-8.md#2025-04-18_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n// Old v0.7 syntax.\nview! {\n    br\n}\n\n// New v0.8 syntax.\nview! { cx,\n    br {}\n}\n```\n\n----------------------------------------\n\nTITLE: Serving Sycamore App with Trunk\nDESCRIPTION: Command to build and serve a Sycamore application with Trunk, which enables hot-reloading during development.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/your-first-app.md#2025-04-18_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ntrunk serve\n```\n\n----------------------------------------\n\nTITLE: Setting Panic Hook for Browser Console Output in Rust\nDESCRIPTION: This snippet shows how to set up console error panic hook to display panic messages in the browser console when using wasm32-unknown-unknown target. It requires the console_error_panic_hook crate.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/troubleshooting.md#2025-04-18_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nconsole_error_panic_hook::set_once();\n```\n\n----------------------------------------\n\nTITLE: Setting Up Rust Nightly Toolchain\nDESCRIPTION: Commands to install and set the Rust nightly toolchain as the default for Sycamore development.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/contributing.md#2025-04-18_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nrustup toolchain add nightly\nrustup override set nightly\n```\n\n----------------------------------------\n\nTITLE: Installing WebAssembly Target in Rust\nDESCRIPTION: Command to add the WebAssembly target to Rust, which is required for compiling Rust code to WebAssembly for web applications.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/your-first-app.md#2025-04-18_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nrustup target add wasm32-unknown-unknown\n```\n\n----------------------------------------\n\nTITLE: Creating Empty Views in Rust using Sycamore\nDESCRIPTION: Demonstrates two equivalent ways to create an empty view in Sycamore - using the view! macro or View::default()\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/guide/view-dsl.md#2025-04-18_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nview! {}\n```\n\nLANGUAGE: rust\nCODE:\n```\nView::default()\n```\n\n----------------------------------------\n\nTITLE: HTML Boilerplate for Trunk\nDESCRIPTION: Minimal HTML template required by Trunk to build and serve the Sycamore application as WebAssembly.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/your-first-app.md#2025-04-18_snippet_6\n\nLANGUAGE: html\nCODE:\n```\n<!DOCTYPE html>\n<html>\n    <head></head>\n    <body></body>\n</html>\n```\n\n----------------------------------------\n\nTITLE: Building and Serving Sycamore-rs Example with Trunk\nDESCRIPTION: This snippet demonstrates how to use Trunk to build and serve a specific example (todomvc) from the sycamore-rs project locally. It requires changing to the example directory before running the trunk serve command.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/examples/README.md#2025-04-18_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncd examples/todomvc\ntrunk serve\n```\n\n----------------------------------------\n\nTITLE: Creating HTML Elements with Sycamore's view! Macro\nDESCRIPTION: Example of using Sycamore's view! macro to create more complex HTML structures with heading and paragraph elements.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/your-first-app.md#2025-04-18_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nsycamore::render(|| view! {\n    h1 { \"Hello, world!\" }\n    p { \"This is my first Sycamore app\" }\n});\n```\n\n----------------------------------------\n\nTITLE: Component Definition with Attribute Macro\nDESCRIPTION: Example showing the new component definition syntax using the #[component(_)] attribute macro, which generates a struct implementing the Component trait.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/CHANGELOG.md#2025-04-18_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n#[component(MyComponent<G>)]\nfn my_component() -> Template<G> {\n    todo!()\n}\n```\n\n----------------------------------------\n\nTITLE: Building and Serving a Sycamore Example Using Trunk\nDESCRIPTION: This bash command shows how to build and serve a Sycamore example locally using Trunk, a WASM web application bundler. The command navigates to the example directory and starts a development server that will compile the Rust code to WebAssembly.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/README.md#2025-04-18_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd examples/todomvc\ntrunk serve\n```\n\n----------------------------------------\n\nTITLE: Nesting HTML Elements in Sycamore\nDESCRIPTION: Example of nesting HTML elements within a container div using Sycamore's view! macro syntax.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/your-first-app.md#2025-04-18_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nview! {\n    div {\n        h1 { \"Hello, world!\" }\n        p { \"This is my first Sycamore app\" }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: HTML Attribute Syntax Example\nDESCRIPTION: Example demonstrating support for hyphenated attribute names in templates.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/CHANGELOG.md#2025-04-18_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\ntemplate! {\n    button(aria-hidden=\"true\")\n}\n```\n\n----------------------------------------\n\nTITLE: Running WASM Tests with wasm-pack\nDESCRIPTION: Commands for running WebAssembly tests using wasm-pack in Chrome.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/contributing.md#2025-04-18_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncd packages/sycamore\nwasm-pack test --chrome\n```\n\n----------------------------------------\n\nTITLE: Using Optional Attributes in Sycamore\nDESCRIPTION: Demonstrates how to set optional stringy attributes on elements using Option.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/guide/view-builder.md#2025-04-18_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nlet attr = create_signal(None::<String>);\ndiv().attr(\"data-attr\", attr)\n// Will render <div></div> instead of <div data-attr></div> if attr is None.\n```\n\n----------------------------------------\n\nTITLE: Cloning the Sycamore Repository\nDESCRIPTION: Commands to fork and clone the Sycamore repository to begin development.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/contributing.md#2025-04-18_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/<your account>/sycamore\ncd sycamore\n```\n\n----------------------------------------\n\nTITLE: Installing sycamore-router with TOML\nDESCRIPTION: Adding the sycamore-router dependency to a Cargo.toml file. The version should match the major version of sycamore being used in the project.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/router.md#2025-04-18_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\nsycamore-router = \"0.9.1\"\n```\n\n----------------------------------------\n\nTITLE: Displaying Supported Sycamore Versions in Markdown Table\nDESCRIPTION: This snippet shows a markdown table that lists the supported versions of Sycamore and their support status. It uses emoji to visually indicate support status.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/SECURITY.md#2025-04-18_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n| Version | Supported          |\n| ------- | ------------------ |\n| 0.9.x   | :white_check_mark: |\n| 0.8.x   | :white_check_mark: |\n| 0.7.x   | :x:                |\n```\n\n----------------------------------------\n\nTITLE: Using cloned! macro with Signal in Sycamore\nDESCRIPTION: Demonstrates the cloned! macro which was introduced as a workaround to reduce boilerplate when using Signals in closures, though it wasn't an ideal solution.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/posts/new-reactive-primitives.md#2025-04-18_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet data = Signal::new(...);\nlet callback = cloned!(data => move || {\n    // Do something useful with `data`\n})\n```\n\n----------------------------------------\n\nTITLE: Simplified Browser Detection in Rust\nDESCRIPTION: Demonstrates the new, cleaner way to check for browser execution using the IS_BROWSER flag.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/posts/announcing-v0-7-0.md#2025-04-18_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nif G::IS_BROWSER { ... }\n```\n\n----------------------------------------\n\nTITLE: Type-Based Browser Detection in Rust\nDESCRIPTION: Shows the old method of detecting browser execution using TypeId comparison, contrasted with the new IS_BROWSER flag.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/posts/announcing-v0-7-0.md#2025-04-18_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nif TypeId::of::<G>() == TypeId::of::<DomNode>() { ... }\n```\n\n----------------------------------------\n\nTITLE: Adding Sycamore as a Dependency via Command Line\nDESCRIPTION: Command to add the Sycamore crate as a dependency to the Rust project using Cargo's add command with a specific version.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/introduction/your-first-app.md#2025-04-18_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncargo add sycamore@0.9.1\n```\n\n----------------------------------------\n\nTITLE: Adding WebAssembly Target\nDESCRIPTION: Command to add the wasm32-unknown-unknown target to the Rust nightly toolchain for WebAssembly compilation.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/contributing.md#2025-04-18_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nrustup target add wasm32-unknown-unknown --toolchain nightly\n```\n\n----------------------------------------\n\nTITLE: Running Macro Diagnostics Tests\nDESCRIPTION: Command to run macro diagnostics snapshot tests with specific environment variables to enable tests and overwrite snapshots.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/contributing.md#2025-04-18_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nRUN_UI_TESTS=true TRYBUILD=overwrite cargo +1.81 test\n```\n\n----------------------------------------\n\nTITLE: Markdown Migration Guide Structure\nDESCRIPTION: Markdown structure defining the migration guide page with YAML frontmatter and content sections.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/migration.md#2025-04-18_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n---\ntitle: Migration\nsubsections:\n  - 0-8-to-0-9\n  - 0-7-to-0-8\n---\n\n# Migration Guides\n\nHere are some guides on how to upgrade your app from an older version of\nSycamore.\n\n- [v0.8 to v0.9](/book/migration/0-8-to-0-9)\n- [v0.7 to v0.8](/book/migration/0-7-to-0-8)\n```\n\n----------------------------------------\n\nTITLE: Running Micro-benchmarks with Cargo in Sycamore\nDESCRIPTION: Command to run the basic micro-benchmarks located in the packages/tools/bench directory using Cargo's benchmark functionality.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/contributing.md#2025-04-18_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncargo bench\n```\n\n----------------------------------------\n\nTITLE: Configuring Lints for Custom CFG in Cargo.toml\nDESCRIPTION: This configuration in Cargo.toml disables warnings for the custom cfg 'sycamore_force_ssr' used by Sycamore to force SSR mode. It sets the lint level to 'warn' and specifies the custom cfg to be checked.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/troubleshooting.md#2025-04-18_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[lints.rust]\nunexpected_cfgs = { level = \"warn\", check-cfg = [\"cfg(sycamore_force_ssr)\"] }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating cloned! macro usage in Sycamore\nDESCRIPTION: Comparison of the old and new syntax for the cloned! macro in Sycamore v0.7.0, showing how parentheses became optional when specifying variables to clone.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/CHANGELOG.md#2025-04-18_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// Before\ncloned!((my, variables, to, clone) => move || { ... })\n// After\ncloned!(my, variables, to, clone => move || { ... })\n```\n\n----------------------------------------\n\nTITLE: Markdown Guide Structure for Sycamore Documentation\nDESCRIPTION: Defines the structure and navigation sections for the Sycamore guide documentation using YAML frontmatter and markdown.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/docs/next/guide.md#2025-04-18_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n---\ntitle: Guide\nsubsections:\n  - view-dsl\n  - view-builder\n  - contexts\n  - data-binding\n  - node-ref\n  - attribute-passthrough\n  - tweened\n  - resources-and-suspense\n  - js-interop\n---\n\n# Guide\n\nThe guide offers more detailed explanations for various Sycamore concepts.\n```\n\n----------------------------------------\n\nTITLE: Setting Boolean Attributes in Sycamore Templates\nDESCRIPTION: Example of setting a boolean attribute (checked) on an input element in Sycamore 0.6.0.\nSOURCE: https://github.com/sycamore-rs/sycamore/blob/main/CHANGELOG.md#2025-04-18_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\ntemplate! {\n    input(type=\"checkbox\", checked=true) { \"Checkbox\" }\n}\n```"
  }
]