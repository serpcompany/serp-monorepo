[
  {
    "owner": "6p5ra",
    "repo": "svelte-dnd-action-docs",
    "content": "TITLE: Listening to consider and finalize Events in Svelte for List Reordering\nDESCRIPTION: This Svelte component enables a draggable task list using the dndzone action from svelte-dnd-action, showing how to respond to consider and finalize events to keep local task state updated. Requires the svelte-dnd-action and svelte/animate libraries. The code expects a tasks array of objects (each with an id and text). The event handler updates the tasks array in response to drag events, ensuring the UI reflects both intermediate and final changes. Limitations: only suitable for basic reordering (advanced customizations may need more event.detail fields).\nSOURCE: https://github.com/6p5ra/svelte-dnd-action-docs/blob/main/svelte-dnd-action.md#_snippet_4\n\nLANGUAGE: Svelte\nCODE:\n```\n<!-- DraggableList.svelte -->\n<script>\n  import { dndzone } from \"svelte-dnd-action\";\n  import { flip } from \"svelte/animate\";\n\n  let tasks = [\n    { id: 1, text: \"Buy milk\" },\n    { id: 2, text: \"Walk the dog\" },\n    { id: 3, text: \"Learn Svelte\" },\n  ];\n  const flipDurationMs = 200;\n\n  // The single function to handle updates from BOTH events\n  function handleDndUpdate(event) {\n    // 'event.detail' contains the info sent by dndzone\n    // 'event.detail.items' is the crucial part: the potentially updated list\n    console.log(`Received event: ${event.type}`); // Logs 'consider' or 'finalize'\n    tasks = event.detail.items; // Update our state!\n  }\n</script>\n\n<!-- Styles omitted -->\n\n<section\n  class=\"task-list\"\n  use:dndzone={{ items: tasks, flipDurationMs: flipDurationMs }}\n  on:consider={handleDndUpdate}\n  on:finalize={handleDndUpdate}\n>\n  {#each tasks as task (task.id)}\n    <div class=\"task-item\" animate:flip={{ duration: flipDurationMs }}>\n      {task.text}\n    </div>\n  {/each}\n</section>\n\n```\n\n----------------------------------------\n\nTITLE: Starting Drag Interactions with svelte-dnd-action (JavaScript)\nDESCRIPTION: This function, handleDragStart, initializes the drag-and-drop sequence when the movement threshold is met. It prepares the drag state (setting work-in-progress flags), captures the dragged item data, creates a visual clone via utility helpers, and inserts it into the DOM. The original element is hidden and drop zones are styled to visually signal their active state. An initial consider event is dispatched (typically adding a placeholder), and global mouse/touch listeners along with a drag observer are started.   Dependencies include the dzToConfig zone mapping, helper functions like createDraggedElementFrom, hideElement, styleActiveDropZones, and event dispatchers. Parameters and state updates revolve around identifying the original item, cloning it, and manipulating the DOM/UI accordingly. Inputs are user drag actions; outputs are DOM/state changes and initiated event listening. Requires that other parts of the drag system (like event dispatchers and observers) are present.\nSOURCE: https://github.com/6p5ra/svelte-dnd-action-docs/blob/main/svelte-dnd-action.md#_snippet_11\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Simplified from src/pointerAction.js\n\nlet draggedEl; // The visual clone element\nlet draggedElData; // Data of the item being dragged\nlet originDropZone; // The zone the item started in\n\nfunction handleDragStart() {\n  printDebug(() => \"drag start\");\n  isWorkingOnPreviousDrag = true; // Flag that a drag is in progress\n\n  // Find the item data and original zone\n  const currentIdx = /* ... find index of originalDragTarget ... */;\n  originDropZone = originalDragTarget.parentElement;\n  const { items, type } = dzToConfig.get(originDropZone); // Get zone config\n  draggedElData = { ...items[currentIdx] }; // Copy item data\n\n  // Create the visual clone element\n  draggedEl = createDraggedElementFrom(originalDragTarget, /* options */);\n  document.body.appendChild(draggedEl); // Add clone to the page\n\n  // Hide original element (simplified - actual logic is more complex)\n  hideElement(originalDragTarget);\n\n  // Style the drop zones to show they are active targets\n  styleActiveDropZones(/* ... */);\n\n  // Tell the origin zone (via 'consider') that the item is being dragged\n  // This might involve adding a placeholder shadow element\n  const itemsWithShadow = /* ... create new items array with placeholder ... */;\n  dispatchConsiderEvent(originDropZone, itemsWithShadow, /* info */);\n\n  // Start listening for GLOBAL mouse/touch move and release events\n  window.addEventListener(\"mousemove\", handleMouseMove, { passive: false });\n  // ... add touchmove, mouseup, touchend listeners for handleMouseMove & handleDrop ...\n\n  // Start the observer to track intersections\n  watchDraggedElement();\n}\n```\n\n----------------------------------------\n\nTITLE: Movement Threshold Detection in JavaScript\nDESCRIPTION: Implementation of the threshold detection logic that determines when a drag operation should officially begin. Requires the pointer to move a minimum distance before initiating the drag to prevent accidental drags.\nSOURCE: https://github.com/6p5ra/svelte-dnd-action-docs/blob/main/svelte-dnd-action.md#_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\n// Simplified from src/pointerAction.js\n\nconst MIN_MOVEMENT_BEFORE_DRAG_START_PX = 3; // Only need to move 3px\n\nfunction handleMouseMoveMaybeDragStart(e) {\n  e.preventDefault(); // Prevent scrolling on touch devices during check\n  const c = e.touches ? e.touches[0] : e;\n  currentMousePosition = { x: c.clientX, y: c.clientY };\n\n  // Calculate distance moved\n  const dx = Math.abs(currentMousePosition.x - dragStartMousePosition.x);\n  const dy = Math.abs(currentMousePosition.y - dragStartMousePosition.y);\n\n  // Has it moved enough?\n  if (dx >= MIN_MOVEMENT_BEFORE_DRAG_START_PX || dy >= MIN_MOVEMENT_BEFORE_DRAG_START_PX) {\n    // YES! It's a real drag.\n    removeMaybeListeners(); // Stop listening for \"maybe\" events\n    handleDragStart(); // Officially start the drag process\n  }\n  // NO? Do nothing, wait for more movement or release.\n}\n\n// Function to clean up the \"maybe\" listeners if drag starts or is cancelled\nfunction removeMaybeListeners() { /* Removes listeners added by addMaybeListeners */ }\n\n// Function to handle if pointer is released before threshold (it was just a click)\nfunction handleFalseAlarm(e) {\n  removeMaybeListeners(); // Clean up\n  // Reset state variables...\n  originalDragTarget = undefined;\n  dragStartMousePosition = undefined;\n  /* ... other cleanup ... */\n}\n```\n\n----------------------------------------\n\nTITLE: Tracking Pointer Movement During Drag (JavaScript)\nDESCRIPTION: The handleMouseMove function is responsible for updating the position of the visual clone as the pointer moves during an active drag. It captures the current pointer coordinates (supporting both mouse and touch events), calculates the offset from the drag start, and applies a CSS transform to the clone element for smooth, performant movement. This function must be registered as an event handler for global pointer move events, and assumes global variables for state tracking (e.g., currentMousePosition, dragStartMousePosition, and draggedEl). It requires that a drag session is active and that the visual clone has been generated. Inputs are pointer events; outputs are DOM style changes. This handler does not directly manipulate drag data beyond visuals.\nSOURCE: https://github.com/6p5ra/svelte-dnd-action-docs/blob/main/svelte-dnd-action.md#_snippet_12\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Simplified from src/pointerAction.js\n\nfunction handleMouseMove(e) {\n  e.preventDefault(); // Prevent text selection, etc.\n  const c = e.touches ? e.touches[0] : e;\n  currentMousePosition = { x: c.clientX, y: c.clientY };\n\n  // Calculate the offset from the drag start position\n  const deltaX = currentMousePosition.x - dragStartMousePosition.x;\n  const deltaY = currentMousePosition.y - dragStartMousePosition.y;\n\n  // Update the clone's position using CSS transform\n  draggedEl.style.transform = `translate3d(${deltaX}px, ${deltaY}px, 0)`;\n\n  // Note: The observer (`watchDraggedElement`) is running in the background\n  // and will automatically detect intersections and trigger 'consider' events\n  // based on the clone's new position.\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Mouse Down Events in JavaScript\nDESCRIPTION: Implementation of the handleMouseDown function that initiates the drag operation, tracking the initial mouse position and element being dragged. Includes setup of event listeners for mouse movement and release.\nSOURCE: https://github.com/6p5ra/svelte-dnd-action-docs/blob/main/svelte-dnd-action.md#_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\n// Simplified from src/pointerAction.js\n\n// Global variables to store drag state\nlet originalDragTarget;\nlet dragStartMousePosition;\nlet currentMousePosition;\nlet isWorkingOnPreviousDrag = false;\n\n// This function runs when you press mouse/touch down on an item\nfunction handleMouseDown(e) {\n  // Ignore right-clicks, etc.\n  if (e.button) return;\n  // Don't start a new drag if one is already happening\n  if (isWorkingOnPreviousDrag) return;\n\n  // Prevent default browser behavior (like text selection)\n  e.preventDefault();\n  e.stopPropagation();\n\n  // Record where the pointer started\n  const c = e.touches ? e.touches[0] : e;\n  dragStartMousePosition = { x: c.clientX, y: c.clientY };\n  currentMousePosition = { ...dragStartMousePosition };\n  originalDragTarget = e.currentTarget; // The item element clicked\n\n  // Start listening for MOVEMENT or RELEASE\n  addMaybeListeners();\n}\n\n// Helper to add temporary listeners\nfunction addMaybeListeners() {\n  window.addEventListener(\"mousemove\", handleMouseMoveMaybeDragStart, { passive: false });\n  window.addEventListener(\"touchmove\", handleMouseMoveMaybeDragStart, { passive: false });\n  // Listen for mouseup/touchend in case it was just a click (false alarm)\n  window.addEventListener(\"mouseup\", handleFalseAlarm, { passive: false });\n  window.addEventListener(\"touchend\", handleFalseAlarm, { passive: false });\n}\n```\n\n----------------------------------------\n\nTITLE: Styling the Dragged Clone with CSS for svelte-dnd-action\nDESCRIPTION: Defines CSS styles targeting the globally dragged element clone using its unique ID `DRAGGED_ELEMENT_ID` (`#svelte-dnd-action-dragged-el`) to appear semi-transparent with a subtle shadow for better visual feedback during drag operations. This requires no dependencies beyond standard CSS and is applied globally while dragging. It affects the clone element only, not the original item.\nSOURCE: https://github.com/6p5ra/svelte-dnd-action-docs/blob/main/svelte-dnd-action.md#_snippet_14\n\nLANGUAGE: CSS\nCODE:\n```\n/* Make the globally dragged element slightly transparent */\n#svelte-dnd-action-dragged-el { /* This is the value of DRAGGED_ELEMENT_ID */\n  opacity: 0.85;\n  /* Add a subtle shadow */\n  box-shadow: 0 4px 8px rgba(0,0,0,0.2);\n}\n```\n\n----------------------------------------\n\nTITLE: Highlighting Drop Zone by CSS Classes in Svelte (JavaScript + HTML + CSS)\nDESCRIPTION: Shows how to add CSS classes dynamically to the `dndzone` container when an item is dragged over it using the `dropTargetClasses` option. The example defines classes for background color and border, applies them on drag events, and updates the item array. This technique allows reusable, globally defined styles to visually highlight drop zones with flexible design options.\nSOURCE: https://github.com/6p5ra/svelte-dnd-action-docs/blob/main/svelte-dnd-action.md#_snippet_17\n\nLANGUAGE: HTML\nCODE:\n```\n<script>\n  let items = [{id: 1, name: 'A'}, {id: 2, name: 'B'}];\n  // Define the classes array\n  const highlightClasses = ['drop-active', 'fancy-border'];\n  function handleUpdate(e) { items = e.detail.items; }\n</script>\n<style>\n  /* Define the styles for your classes globally or in the component */\n  .drop-active { background-color: #e0ffe0; }\n  .fancy-border { border: 2px solid green; }\n</style>\n\n<section\n  use:dndzone={{ items, dropTargetClasses: highlightClasses }}\n  on:consider={handleUpdate}\n  on:finalize={handleUpdate}\n>\n  {#each items as item (item.id)}<div>{item.name}</div>{/each}\n</section>\n```\n\n----------------------------------------\n\nTITLE: Sequence Diagram of Drag and Drop Workflow in Svelte\nDESCRIPTION: A mermaid diagram illustrating the interaction flow between various components during a drag-and-drop operation, from drag start to final state update.\nSOURCE: https://github.com/6p5ra/svelte-dnd-action-docs/blob/main/svelte-dnd-action.md#_snippet_20\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    participant User\n    participant PointerHandler as \"Pointer Handler\"\n    participant Styler as \"Styler Helpers\"\n    participant Observer as \"Observer Logic\"\n    participant DropZone as \"Drop Zone Element\"\n    participant YourComponent as \"Your Svelte Component\"\n\n    User->>PointerHandler: Starts dragging Item A\n    PointerHandler->>Styler: createDraggedElementFrom(Item A element)\n    Styler-->>PointerHandler: Returns Clone Element\n    PointerHandler->>Styler: hideElement(Item A element)\n    PointerHandler->>Observer: Start tracking Clone\n    User->>Observer: Moves Clone over DropZone\n    Observer->>Styler: styleActiveDropZones(DropZone)\n    Observer->>YourComponent: Dispatches 'consider' (items with placeholder)\n    YourComponent->>YourComponent: Updates state (Svelte renders placeholder)\n    Observer->>Styler: morphDraggedElementToBeLike(Clone, Placeholder)\n    User->>PointerHandler: Drops Clone\n    PointerHandler->>Observer: Stop tracking\n    PointerHandler->>Styler: Start drop animation for Clone\n    Styler-->>PointerHandler: Animation finished (after timeout)\n    PointerHandler->>YourComponent: Dispatches 'finalize' (final items)\n    YourComponent->>YourComponent: Updates state (Svelte renders final list)\n    PointerHandler->>Styler: Cleanup (remove Clone, original element)\n```\n\n----------------------------------------\n\nTITLE: Controlling FLIP Animation Duration in svelte-dnd-action Using Svelte and JavaScript\nDESCRIPTION: Illustrates how to synchronize the FLIP animation duration for item list reordering by passing a duration option (`flipDurationMs`) both to the `dndzone` action and to the Svelte `animate:flip` directive. This ensures smooth and coordinated animations when the placeholder moves within the list. The example uses a variable flip speed for flexibility.\nSOURCE: https://github.com/6p5ra/svelte-dnd-action-docs/blob/main/svelte-dnd-action.md#_snippet_18\n\nLANGUAGE: HTML\nCODE:\n```\n<script> /* ... */ const flipSpeed = 250; </script>\n<section use:dndzone={{ items, flipDurationMs: flipSpeed }} on:consider={handleUpdate} on:finalize={handleUpdate}>\n  {#each items as item (item.id)}\n    <div animate:flip={{ duration: flipSpeed }}>{item.name}</div>\n  {/each}\n</section>\n```\n\n----------------------------------------\n\nTITLE: Styling Drop Zone Containers in JavaScript\nDESCRIPTION: Functions that apply and remove visual styles to drop zone containers during drag operations. styleActiveDropZones applies user-defined styles and classes to highlight active drop targets, while styleInactiveDropZones removes those styles.\nSOURCE: https://github.com/6p5ra/svelte-dnd-action-docs/blob/main/svelte-dnd-action.md#_snippet_23\n\nLANGUAGE: javascript\nCODE:\n```\n// Simplified from src/helpers/styler.js\n\nexport function styleActiveDropZones(dropZones, getStyles, getClasses) {\n    dropZones.forEach(dz => {\n        // Apply inline styles from the 'dropTargetStyle' option\n        const styles = getStyles(dz); // e.g., { outline: '2px solid blue' }\n        Object.keys(styles).forEach(style => {\n            dz.style[style] = styles[style];\n        });\n        // Add classes from the 'dropTargetClasses' option\n        getClasses(dz).forEach(c => dz.classList.add(c)); // e.g., 'drop-active'\n    });\n}\n\nexport function styleInactiveDropZones(dropZones, getStyles, getClasses) {\n    dropZones.forEach(dz => {\n        // Remove inline styles\n        const styles = getStyles(dz);\n        Object.keys(styles).forEach(style => {\n            dz.style[style] = \"\"; // Reset inline style\n        });\n        // Remove classes\n        getClasses(dz).forEach(c => dz.classList.remove(c));\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Auto-Scrolling Flow Sequence Diagram\nDESCRIPTION: Mermaid sequence diagram showing the interaction between user, pointer handler, observer loop, multi-scroller, and scrollable list element during auto-scrolling when a dragged item approaches a container edge.\nSOURCE: https://github.com/6p5ra/svelte-dnd-action-docs/blob/main/svelte-dnd-action.md#_snippet_31\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    participant User\n    participant PointerHandler as \"Pointer Handler\"\n    participant Observer as \"Observer Loop (observer.js)\"\n    participant MultiScroller as \"Multi Scroller (multiScroller.js)\"\n    participant ScrollableList as \"Scrollable List Element\"\n\n    User->>PointerHandler: Starts dragging item\n    PointerHandler->>MultiScroller: Initialize (find scrollable containers like ScrollableList)\n    PointerHandler->>Observer: Start observation loop\n    loop Periodic Check (~200ms)\n        Observer->>Observer: Get current pointer position\n        Observer->>MultiScroller: Call multiScrollIfNeeded()\n        MultiScroller->>MultiScroller: Check pointer vs. ScrollableList edges\n        alt Pointer near bottom edge?\n            MultiScroller->>ScrollableList: scrollBy(0, scrollAmount)\n            MultiScroller-->>Observer: Return true (scrolled)\n        else Pointer not near edge\n            MultiScroller-->>Observer: Return false (not scrolled)\n        end\n    end\n    User->>PointerHandler: Drops item\n    PointerHandler->>Observer: Stop observation loop\n    PointerHandler->>MultiScroller: Destroy (reset scrolling state)\n\n```\n\n----------------------------------------\n\nTITLE: Handling Key Presses for Drag and Drop in JavaScript\nDESCRIPTION: This JavaScript function `handleKeyDown` is responsible for handling key presses within a draggable item. It listens for 'Enter', 'Spacebar', and arrow keys to initiate drag operations, move items within a list, and drop items.  It uses `preventDefault` and `stopPropagation` to prevent default browser actions. The code utilizes helper functions `handleDrop`, `handleDragStart`, `swap`, and `dispatchFinalizeEvent`. It depends on the existence of `dzToConfig` and the `config` object for application state and settings.\nSOURCE: https://github.com/6p5ra/svelte-dnd-action-docs/blob/main/svelte-dnd-action.md#_snippet_24\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Simplified from src/keyboardAction.js\n\nfunction handleKeyDown(e) {\n    printDebug(() => [\"handling key down\", e.key]);\n    switch (e.key) {\n        case \"Enter\":\n        case \" \": {\n            // Ignore if focus is on an input inside the item, etc.\n            if (/* is input/button/link */) return;\n\n            e.preventDefault(); // Stop spacebar scrolling page\n            e.stopPropagation();\n            if (isDragging) {\n                handleDrop(); // Drop item if already dragging\n            } else {\n                handleDragStart(e); // Start dragging if not\n            }\n            break;\n        }\n        case \"ArrowDown\":\n        case \"ArrowRight\": {\n            if (!isDragging) return;\n            e.preventDefault(); // Stop arrows scrolling page\n            e.stopPropagation();\n            const {items} = dzToConfig.get(node); // Get current items\n            const idx = /* find current index of focused item */;\n            if (idx < items.length - 1) { // Can move down?\n                // Announce move BEFORE visually updating\n                if (!config.autoAriaDisabled) {\n                   alertToScreenReader(/* Announce move down */);\n                }\n                // Swap items in the array\n                swap(items, idx, idx + 1);\n                // Tell the component about the final new order\n                dispatchFinalizeEvent(node, items, /* event info */);\n            }\n            break;\n        }\n        case \"ArrowUp\":\n        case \"ArrowLeft\": {\n             if (!isDragging) return;\n             e.preventDefault();\n             e.stopPropagation();\n             const {items} = dzToConfig.get(node);\n             const idx = /* find current index of focused item */;\n             if (idx > 0) { // Can move up?\n                 if (!config.autoAriaDisabled) {\n                    alertToScreenReader(/* Announce move up */);\n                 }\n                 swap(items, idx, idx - 1);\n                 dispatchFinalizeEvent(node, items, /* event info */);\n             }\n             break;\n        }\n        // Note: 'Escape' is handled by a global listener (globalKeyDownHandler)\n    }\n}\n\n// Helper function to swap items in an array\nfunction swap(arr, i, j) {\n    // Simple array swap logic...\n}\n\n```\n\n----------------------------------------\n\nTITLE: Drag Handle Interaction Flow Mermaid Diagram\nDESCRIPTION: This Mermaid sequence diagram illustrates the step-by-step process and communication flow between the user, the drag handle element, internal shared state, the `dragHandleZone`, and the base `dndzone` logic when a drag operation is initiated via a handle.\nSOURCE: https://github.com/6p5ra/svelte-dnd-action-docs/blob/main/svelte-dnd-action.md#_snippet_38\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    participant User\n    participant HandleElement as \"Handle Element (<div use:dragHandle>)\"\n    participant SharedState as \"Shared State (isItemsDragDisabled)\"\n    participant HandleZone as \"dragHandleZone (on <section>)\"\n    participant BaseDndZone as \"Internal dndzone Logic\"\n\n    Note over HandleZone, BaseDndZone: Initially, dndzone is called with dragDisabled=true\n\n    User->>HandleElement: Clicks/Touches Handle\n    HandleElement->>SharedState: Set isItemsDragDisabled = false\n    SharedState->>HandleZone: Notifies state changed to false\n    HandleZone->>BaseDndZone: Calls update({ dragDisabled: false })\n    Note over BaseDndZone: Drag is now enabled!\n    BaseDndZone->>BaseDndZone: Initiates drag for Handle's parent item (clone, etc.)\n    User->>HandleElement: Drags and Drops\n    BaseDndZone->>HandleZone: Dispatches 'finalize' event\n    HandleZone->>SharedState: Set isItemsDragDisabled = true\n    SharedState->>HandleZone: Notifies state changed to true\n    HandleZone->>BaseDndZone: Calls update({ dragDisabled: true })\n    Note over BaseDndZone: Drag is disabled again.\n```\n\n----------------------------------------\n\nTITLE: Observer Integration with MultiScroller for Auto-Scrolling in JavaScript\nDESCRIPTION: This snippet demonstrates integration of the auto-scrolling logic into an observer pattern managing drag-and-drop state. The `observe` function initializes a `multiScroller` instance that tracks active drop zones and continuously checks whether scrolling is required based on the current pointer position. Inside the main observation loop (`andNow`), `multiScroller.multiScrollIfNeeded()` is invoked to perform scrolling; if scrolling occurs, expensive intersection recalculations are temporarily skipped to optimize performance. The `unobserve` function cleans up by destroying the `multiScroller` instance and resetting any caches, ensuring proper teardown when drag actions end.\nSOURCE: https://github.com/6p5ra/svelte-dnd-action-docs/blob/main/svelte-dnd-action.md#_snippet_35\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Simplified from src/helpers/observer.js\n\n// ... other observer code ...\nimport { createMultiScroller } from \"./multiScroller\";\n\nlet multiScroller;\n\nexport function observe(draggedEl, dropZones, intervalMs, initialPointerPos) {\n    // Create the multi-scroller instance when observation starts\n    multiScroller = createMultiScroller(\n        Array.from(dropZones), // Pass the dndzone elements\n        () => currentPointerPosition // Function to get the latest pointer position\n    );\n\n    // ... setup other variables ...\n    let currentPointerPosition = initialPointerPos;\n\n    function andNow() { // The main observer loop\n        // Update pointer position based on mouse/touch move events...\n        // currentPointerPosition = getLatestPosition();\n\n        // Call the scroller's check function!\n        const scrolled = multiScroller.multiScrollIfNeeded();\n\n        // If scrolled, maybe skip intersection checks for this tick? (Optimization)\n        if (scrolled) {\n            resetIndexesCache(); // Clear cached positions as scrolling changes layout\n            // Re-schedule the next check\n            next = window.setTimeout(andNow, intervalMs);\n            return;\n        }\n\n        // ... perform intersection checks (findWouldBeIndex) ...\n        // ... dispatch consider events ...\n\n        // Re-schedule the next check\n        next = window.setTimeout(andNow, intervalMs);\n    }\n    andNow(); // Start the loop\n}\n\nexport function unobserve() {\n    // ... stop timeout ...\n    // Clean up the scroller when observation stops\n    if (multiScroller) {\n        multiScroller.destroy();\n        multiScroller = undefined;\n    }\n    resetIndexesCache();\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Drag on Specific Handles in Svelte DND (JavaScript)\nDESCRIPTION: This code defines the 'dragHandle' action for attaching to a handle element within a draggable item to enable drag initiation only from that handle. It sets up accessibility attributes (role and tabIndex), event handlers for pointer and keyboard activation, and subscribes to the shared drag-disabled store to update handle focusability and cursor dynamically. The drag-enabled state is triggered only on mouse/touch or key press (Enter/Space) within the handle. It includes teardown logic for all event listeners and subscriptions to prevent leaks. This action assumes the presence of the externally defined shared store (isItemsDragDisabled).\nSOURCE: https://github.com/6p5ra/svelte-dnd-action-docs/blob/main/svelte-dnd-action.md#_snippet_40\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Simplified from src/wrappers/withDragHandles.js\n\nexport function dragHandle(handle) {\n    // Make the handle accessible\n    handle.setAttribute(\"role\", \"button\");\n\n    // Function to enable dragging via the shared store\n    function enableDragging() {\n        isItemsDragDisabled.set(false);\n    }\n\n    // Event handlers for the handle element\n    function handlePointerDown(e) {\n        e.preventDefault(); // Prevent text selection, touch delays\n        enableDragging();\n    }\n    function handleKeyDown(e) {\n        if (e.key === \"Enter\" || e.key === \" \") {\n            e.preventDefault(); // Prevent spacebar scroll\n            enableDragging();\n        }\n    }\n\n    // Set initial styles and focusability based on shared state\n    const unsubscribe = isItemsDragDisabled.subscribe(isDisabled => {\n        handle.tabIndex = isDisabled ? 0 : -1; // Focusable only when NOT dragging\n        handle.style.cursor = isDisabled ? \"grab\" : \"grabbing\";\n    });\n\n    // Add listeners to the handle\n    handle.addEventListener(\"mousedown\", handlePointerDown);\n    handle.addEventListener(\"touchstart\", handlePointerDown);\n    handle.addEventListener(\"keydown\", handleKeyDown);\n\n    return {\n        update: () => {}, // No options to update\n        destroy: () => {\n            // Clean up listeners and subscription\n            handle.removeEventListener(\"mousedown\", handlePointerDown);\n            handle.removeEventListener(\"touchstart\", handlePointerDown);\n            handle.removeEventListener(\"keydown\", handleKeyDown);\n            unsubscribe();\n        }\n    };\n}\n\n```\n\n----------------------------------------\n\nTITLE: Finding Scrollable Containers Helper in JavaScript\nDESCRIPTION: This snippet provides two functions to identify scrollable parent elements of given drop zones. The `findScrollableParents` function traverses the DOM tree upwards from a provided element, examining the CSS \"overflow\" property and comparing scroll dimensions to determine if a parent is scrollable. The `findRelevantScrollContainers` function aggregates all unique scrollable containers from multiple drop zones and always includes the main document scrolling element if it is scrollable. This ensures all potential scrolling parents are considered during drag operations.\nSOURCE: https://github.com/6p5ra/svelte-dnd-action-docs/blob/main/svelte-dnd-action.md#_snippet_33\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Simplified from src/helpers/multiScroller.js\n\nfunction findScrollableParents(element) {\n    const scrollableContainers = [];\n    let parent = element;\n    while (parent) {\n        // Check the CSS 'overflow' property\n        const { overflow } = window.getComputedStyle(parent);\n        if (overflow.split(\" \").some(o => o.includes(\"auto\") || o.includes(\"scroll\"))) {\n            // Check if it's actually scrollable (content bigger than view)\n            if (parent.scrollHeight > parent.clientHeight || parent.scrollWidth > parent.clientWidth) {\n                 scrollableContainers.push(parent);\n            }\n        }\n        parent = parent.parentElement;\n    }\n    return scrollableContainers;\n}\n\nfunction findRelevantScrollContainers(dropZones) {\n    const scrollingContainers = new Set(); // Use a Set to avoid duplicates\n    // Check parents of all active drop zones\n    for (let dz of dropZones) {\n        findScrollableParents(dz).forEach(container => scrollingContainers.add(container));\n    }\n    // Always consider the main document scrollbar\n    if (document.scrollingElement.scrollHeight > document.scrollingElement.clientHeight || /* width check */) {\n        scrollingContainers.add(document.scrollingElement);\n    }\n    return scrollingContainers;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Visually Hidden Alert Element for Screen Readers (JavaScript)\nDESCRIPTION: This JavaScript snippet from src/helpers/aria.js illustrates how the library creates a visually hidden div with role=\"alert\" to relay live announcements to screen readers. It only creates the element once per page, styles it for invisibility, and positions it at the DOM root. Dependencies: browser DOM API, invoked on client only. Parameters: none. No inputs required; output is a hidden ARIA alert node for later use. Limitation: not suitable for server-side contexts.\nSOURCE: https://github.com/6p5ra/svelte-dnd-action-docs/blob/main/svelte-dnd-action.md#_snippet_28\n\nLANGUAGE: javascript\nCODE:\n```\n// Simplified from src/helpers/aria.js\nlet alertsDiv; // Holds reference to the hidden div\n\nfunction initAriaOnBrowser() {\n    if (alertsDiv) return; // Already created\n    alertsDiv = document.createElement(\"div\");\n    alertsDiv.id = \"dnd-action-aria-alert\";\n    // Styles to hide it visually\n    alertsDiv.style.position = \"fixed\";\n    alertsDiv.style.opacity = \"0\";\n    /* ... other hiding styles ... */\n    // Crucial ARIA role\n    alertsDiv.setAttribute(\"role\", \"alert\");\n    document.body.prepend(alertsDiv); // Add to page\n}\n\n```\n\n----------------------------------------\n\nTITLE: Default dndzone Behavior HTML\nDESCRIPTION: This HTML snippet shows the default behavior when using the `dndzone` action on a container. The entire item element becomes draggable, which can interfere with actions like text selection within the item.\nSOURCE: https://github.com/6p5ra/svelte-dnd-action-docs/blob/main/svelte-dnd-action.md#_snippet_36\n\nLANGUAGE: html\nCODE:\n```\n<!-- Normal dndzone - Clicking anywhere starts a drag -->\n<section use:dndzone={{items: tasks}} ...>\n  {#each tasks as task (task.id)}\n    <div class=\"task-item\" aria-label={task.text}>\n      {task.text} <!-- Trying to select this text might start a drag -->\n    </div>\n  {/each}\n</section>\n```\n\n----------------------------------------\n\nTITLE: Managing Drag Start and Drop Events in JavaScript\nDESCRIPTION: These JavaScript functions, `handleDragStart` and `handleDrop`, manage the state of a draggable item when a drag operation begins and ends.  `handleDragStart` sets flags, styles drop zones, and announces the drag start to screen readers. `handleDrop` resets the state, removes styles, and optionally dispatches a 'consider' event. `globalKeyDownHandler` is used to cancel a drag operation using the 'Escape' key.  These functions rely on helper functions such as `alertToScreenReader`, `styleActiveDropZones`, `styleInactiveDropZones`, and `dispatchConsiderEvent`.\nSOURCE: https://github.com/6p5ra/svelte-dnd-action-docs/blob/main/svelte-dnd-action.md#_snippet_25\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Simplified from src/keyboardAction.js\nimport { alertToScreenReader } from \"./helpers/aria\";\nimport { styleActiveDropZones, styleInactiveDropZones } from \"./helpers/styler\";\nimport { dispatchConsiderEvent } from \"./helpers/dispatcher\";\n\nlet isDragging = false;\nlet focusedItemId = null;\nlet focusedItemLabel = \"\"; // For screen reader announcements\nlet focusedDz = null; // The zone being interacted with\n\nfunction handleDragStart(e) {\n    printDebug(() => \"drag start\");\n    focusedItem = e.currentTarget; // The list item element\n    focusedItemId = /* get ID of focusedItem from config.items */;\n    focusedItemLabel = focusedItem.getAttribute(\"aria-label\") || \"\";\n    focusedDz = node; // 'node' is the dndzone element\n    isDragging = true;\n\n    // Style potential drop zones\n    const dropTargets = /* Find compatible drop zones */;\n    styleActiveDropZones(dropTargets, /* style options */);\n\n    // Announce drag start\n    if (!config.autoAriaDisabled) {\n        let msg = `Started dragging item ${focusedItemLabel}. Use arrow keys...`;\n        // Add tab instructions if multiple zones exist\n        alertToScreenReader(msg);\n    }\n\n    // Notify component drag has started\n    dispatchConsiderEvent(node, config.items, {trigger: TRIGGERS.DRAG_STARTED, id: focusedItemId, source: SOURCES.KEYBOARD});\n    // Refresh all zones (updates their tabIndex, styling etc)\n    triggerAllDzsUpdate();\n}\n\nfunction handleDrop(dispatchConsider = true) {\n    printDebug(() => \"drop\");\n    if (!config.autoAriaDisabled) {\n        alertToScreenReader(`Stopped dragging item ${focusedItemLabel}`);\n    }\n\n    // Remove focus from the item if it's still focused\n    if (allDragTargets.has(document.activeElement)) {\n        document.activeElement.blur();\n    }\n\n    // Optionally dispatch a final 'consider' event\n    if (dispatchConsider) {\n        dispatchConsiderEvent(focusedDz, config.items, /* event info */);\n    }\n\n    // Reset styles and internal state\n    styleInactiveDropZones(/* ... */);\n    focusedItem = null;\n    focusedItemId = null;\n    focusedItemLabel = \"\";\n    focusedDz = null;\n    isDragging = false;\n\n    // Refresh all zones again\n    triggerAllDzsUpdate();\n}\n\n// Escape key handler (simplified - attached globally)\nfunction globalKeyDownHandler(e) {\n    if (!isDragging) return;\n    if (e.key === \"Escape\") {\n        // similar logic to handleDrop, but might need to revert item position\n        handleDrop(); // Simplified: just drop in place on Escape\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Screen Reader Announcements with ARIA in JavaScript\nDESCRIPTION: This JavaScript function `alertToScreenReader` provides accessibility feedback to screen reader users.  It manages a hidden `div` element with the `role=\"alert\"` attribute. Updating the text content of this `div` triggers screen readers to announce the new text. The `initAriaOnBrowser` function ensures the hidden div is created. The function checks if it's running on the server before proceeding, as it is browser-specific. It relies on browser's document object.\nSOURCE: https://github.com/6p5ra/svelte-dnd-action-docs/blob/main/svelte-dnd-action.md#_snippet_26\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Simplified from src/helpers/aria.js\n\nlet alertsDiv; // A hidden div on the page\n\n// Creates or finds the hidden div used for announcements\nfunction initAriaOnBrowser() {\n    if (alertsDiv) return; // Already exists\n    alertsDiv = document.createElement(\"div\");\n    alertsDiv.id = \"dnd-action-aria-alert\";\n    // Styles to make it visually hidden but readable by screen readers\n    alertsDiv.style.position = \"fixed\"; /* ... other hiding styles ... */\n    alertsDiv.setAttribute(\"role\", \"alert\"); // Important ARIA attribute\n    document.body.prepend(alertsDiv);\n}\n\n/**\n * Makes the screen reader announce the provided text.\n * @param {string} txt - The message to announce.\n */\nexport function alertToScreenReader(txt) {\n    if (isOnServer) return; // Cannot run on server\n    if (!alertsDiv) {\n        initAriaOnBrowser(); // Create the div if needed\n    }\n    // Updating the content of the 'alert' div makes screen readers read it\n    alertsDiv.textContent = txt;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Providing Accessible DnD with ARIA in Svelte Using svelte-dnd-action (HTML, Svelte)\nDESCRIPTION: This Svelte snippet demonstrates how to set up a draggable list using the svelte-dnd-action library with robust ARIA accessibility. It imports the dndzone action for drag-and-drop and uses aria-label attributes on both the dndzone container and each draggable item for precise screen reader feedback. The tasks array is re-ordered in response to drag events. Dependencies: svelte, svelte-dnd-action, and (optionally) svelte/animate. Parameters include list name (aria-label), task objects (item aria-labels), and flipDurationMs for animations. Inputs are the initial task list; outputs are visually and programmatically accessible DnD interactions. Limitation: custom accessibility behaviour can be provided by disabling auto ARIA handling.\nSOURCE: https://github.com/6p5ra/svelte-dnd-action-docs/blob/main/svelte-dnd-action.md#_snippet_27\n\nLANGUAGE: html\nCODE:\n```\n<!-- DraggableList.svelte -->\n<script>\n  import { dndzone } from \"svelte-dnd-action\";\n  import { flip } from \"svelte/animate\";\n\n  let listName = \"My Important Tasks\"; // Name for the whole list\n  let tasks = [\n    { id: 1, text: \"Buy milk\" },\n    { id: 2, text: \"Walk the dog\" },\n    { id: 3, text: \"Learn Svelte\" },\n  ];\n  const flipDurationMs = 200;\n\n  function handleDndUpdate(event) {\n    tasks = event.detail.items;\n  }\n</script>\n\n<!-- Styles omitted -->\n\n<h2>{listName}</h2>\n<!-- Add aria-label to the dndzone container -->\n<section\n  class=\"task-list\"\n  aria-label={listName}\n  use:dndzone={{ items: tasks, flipDurationMs: flipDurationMs }}\n  on:consider={handleDndUpdate}\n  on:finalize={handleDndUpdate}\n>\n  {#each tasks as task (task.id)}\n    <!-- Add aria-label to each draggable item -->\n    <div\n      class=\"task-item\"\n      aria-label={task.text}\n      animate:flip={{ duration: flipDurationMs }}\n    >\n      {task.text}\n    </div>\n  {/each}\n</section>\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Drag Handles Svelte Component\nDESCRIPTION: This Svelte component demonstrates how to use `dragHandleZone` on the container and `dragHandle` on a specific child element (`.handle-grabber`) within each item. This restricts dragging to only the handle element, allowing normal interaction with other parts of the item like text.\nSOURCE: https://github.com/6p5ra/svelte-dnd-action-docs/blob/main/svelte-dnd-action.md#_snippet_37\n\nLANGUAGE: svelte\nCODE:\n```\n<!-- DraggableListWithHandles.svelte -->\n<script>\n  // Import the handle actions instead of dndzone\n  import { dragHandleZone, dragHandle } from \"svelte-dnd-action\";\n  import { flip } from \"svelte/animate\";\n\n  let listName = \"My Handle Tasks\";\n  let tasks = [\n    { id: 1, text: \"Buy milk\" },\n    { id: 2, text: \"Walk the dog\" },\n    { id: 3, text: \"Learn Svelte\" },\n  ];\n  const flipDurationMs = 200;\n\n  // Event handling remains the same!\n  function handleDndUpdate(event) {\n    tasks = event.detail.items;\n  }\n</script>\n\n<style>\n  .task-list-handles {\n    padding: 10px;\n    border: 1px solid #ccc;\n    min-height: 100px;\n    width: 250px;\n  }\n  .task-item-handle-wrapper {\n    padding: 8px;\n    margin: 4px 0;\n    border: 1px solid #eee;\n    background-color: white;\n    /* Make space for the handle using relative/absolute positioning */\n    position: relative;\n  }\n  .handle-grabber {\n    position: absolute;\n    left: 5px; /* Position handle on the left */\n    top: 50%;\n    transform: translateY(-50%);\n    width: 10px;\n    height: 20px;\n    background-color: #ccc;\n    border: 1px solid #aaa;\n    cursor: grab; /* Indicate this part is the handle */\n  }\n  .task-text {\n    margin-left: 25px; /* Make space for handle */\n    /* Now you CAN select this text! */\n  }\n</style>\n\n<h2>{listName}</h2>\n\n<!-- Use dragHandleZone on the container -->\n<section\n  class=\"task-list-handles\"\n  aria-label={listName}\n  use:dragHandleZone={{ items: tasks, flipDurationMs: flipDurationMs }}\n  on:consider={handleDndUpdate}\n  on:finalize={handleDndUpdate}\n>\n  {#each tasks as task (task.id)}\n    <!-- The item element itself is NOT directly draggable -->\n    <div class=\"task-item-handle-wrapper\"\n         animate:flip={{ duration: flipDurationMs }}\n    >\n      <!-- Apply dragHandle to the handle element -->\n      <div\n        class=\"handle-grabber\"\n        use:dragHandle\n        aria-label={`Drag handle for ${task.text}`}\n      />\n      <!-- This text is now selectable -->\n      <span class=\"task-text\">{task.text}</span>\n    </div>\n  {/each}\n</section>\n```\n\n----------------------------------------\n\nTITLE: Starting Observation Loop in JavaScript\nDESCRIPTION: Initializes and starts the main observation loop for a drag operation. This function is called by the pointer handler when dragging begins. It resets the observer's state, prepares the list of potential drop zones (sorting them by depth), defines the core periodic check function (`andNow`), and schedules the first execution using `setTimeout`.\nSOURCE: https://github.com/6p5ra/svelte-dnd-action-docs/blob/main/svelte-dnd-action.md#_snippet_41\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Simplified from src/helpers/observer.js\nimport {findWouldBeIndex, resetIndexesCache} from \"./listUtil\";\nimport {findCenterOfElement, isElementOffDocument} from \"./intersection\";\n// Import internal event dispatchers (simplified names)\nimport {dispatchEntered, dispatchLeft, dispatchOverIndex} from \"./dispatcher\";\nimport {printDebug} from \"../constants\";\n\nconst INTERVAL_MS = 200; // How often to check (in milliseconds)\nlet nextTimeoutId; // Stores the ID for the scheduled check\n\n// Global state for the observer\nlet lastDropZoneFound;\nlet lastIndexFound;\n\n/**\n * Starts the observation loop.\n * @param {HTMLElement} draggedEl - The element being dragged (the clone).\n * @param {Set<HTMLElement>} dropZones - The set of potential drop zone elements.\n * @param {MultiScroller} multiScroller - The auto-scrolling helper.\n */\nexport function observe(draggedEl, dropZones, multiScroller) {\n    printDebug(() => \"Starting observation\");\n    // Reset state for this drag operation\n    lastDropZoneFound = undefined;\n    lastIndexFound = undefined;\n\n    // Sort zones by depth so nested zones are checked first (more specific)\n    const dropZonesFromDeepToShallow = Array.from(dropZones).sort(/* ... */);\n\n    // The function that runs on each interval\n    function andNow() {\n        // Get current position, check scroll, compare, dispatch... (see below)\n        runObservationCycle(draggedEl, dropZonesFromDeepToShallow, multiScroller);\n\n        // Schedule the next check\n        nextTimeoutId = window.setTimeout(andNow, INTERVAL_MS);\n    }\n\n    // Start the first cycle\n    andNow();\n}\n```\n\n----------------------------------------\n\nTITLE: Stopping the Observation Cycle in svelte-dnd-action (JavaScript)\nDESCRIPTION: The 'unobserve' function halts the periodic observation involved in tracking a drag operation in the svelte-dnd-action library. It cancels any scheduled observation cycle using clearTimeout on a stored timer ID and clears intersection/index caches to reset layout calculations. Dependencies include access to the nextTimeoutId variable, resetIndexesCache, and an optional debug logging function. It requires no inputs, has no outputs but side-effectually controls timers and memory, and ensures cleanup upon drag end. Limitations: assumes observation cycles are managed using timer-based scheduling and that invoked resources exist.\nSOURCE: https://github.com/6p5ra/svelte-dnd-action-docs/blob/main/svelte-dnd-action.md#_snippet_43\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Simplified from src/helpers/observer.js\n\nexport function unobserve() {\n    printDebug(() => \"Stopping observation\");\n    // Stop the scheduled next check\n    clearTimeout(nextTimeoutId);\n    // Clear cached intersection calculations\n    resetIndexesCache();\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Drag-Restricted dndzone Wrapper in Svelte (JavaScript)\nDESCRIPTION: This snippet defines the 'dragHandleZone' action for Svelte, which wraps the core dndzone action with logic to restrict drag capability according to a shared boolean store. It keeps list items initially non-draggable and only enables dragging when triggered by an associated handle. It dynamically updates drag-disabled state, sets tab indices for accessibility, listens for finalize/consider events, and provides update/destroy methods for managing the underlying dndzone and store subscription. Dependencies include the Svelte store utility, the original dndzone action, and project constants SOURCES and TRIGGERS.\nSOURCE: https://github.com/6p5ra/svelte-dnd-action-docs/blob/main/svelte-dnd-action.md#_snippet_39\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Simplified from src/wrappers/withDragHandles.js\nimport { dndzone } from \"../action\";\nimport { createStore } from \"./simpleStore\"; // A minimal store utility\nimport { SOURCES, TRIGGERS } from \"../constants\";\n\n// Create a shared store, initially true (items are disabled)\nconst isItemsDragDisabled = createStore(true);\n\n// Helper to get the options to pass to the underlying dndzone\nfunction getAddedOptions(isDisabled = true) {\n    return {\n        dragDisabled: isDisabled,\n        zoneItemTabIndex: -1 // Make items non-focusable by default\n    };\n}\n\nexport function dragHandleZone(node, options) {\n    let currentOptions = options;\n    // Apply the real dndzone action with initial disabled state\n    const zone = dndzone(node, {\n        ...currentOptions,\n        ...getAddedOptions(isItemsDragDisabled.get()) // Get initial state\n    });\n\n    // Callback function for when the shared state changes\n    function isItemDisabledCB(isDisabled) {\n        zone.update({ // Update the underlying dndzone\n            ...currentOptions,\n            ...getAddedOptions(isDisabled)\n        });\n    }\n    // Subscribe to changes in the shared state\n    const unsubscribe = isItemsDragDisabled.subscribe(isItemDisabledCB);\n\n    // Listen for finalize/consider events to reset the state after drop/cancel\n    function handlePointerDrop(e) {\n        if (e.detail.info.source === SOURCES.POINTER) {\n            isItemsDragDisabled.set(true); // Disable on pointer drop\n        }\n    }\n    function handleKeyboardStop(e) {\n        if (e.detail.info.source === SOURCES.KEYBOARD && e.detail.info.trigger === TRIGGERS.DRAG_STOPPED) {\n            isItemsDragDisabled.set(true); // Disable on keyboard cancel/drop\n        }\n    }\n    node.addEventListener(\"finalize\", handlePointerDrop);\n    node.addEventListener(\"consider\", handleKeyboardStop); // Keyboard stop uses 'consider'\n\n    return {\n        update: newOptions => {\n            currentOptions = newOptions;\n            // Update underlying dndzone with new options AND current disabled state\n            zone.update({\n                ...currentOptions,\n                ...getAddedOptions(isItemsDragDisabled.get())\n            });\n        },\n        destroy: () => {\n            node.removeEventListener(\"finalize\", handlePointerDrop);\n            node.removeEventListener(\"consider\", handleKeyboardStop);\n            unsubscribe(); // Clean up the store subscription\n            zone.destroy(); // Destroy the underlying dndzone\n        }\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Finalizing and Cleaning Up Drag Interactions (JavaScript)\nDESCRIPTION: The handleDrop function finalizes the drag operation by performing both logic and cleanup tasks. It removes all global event listeners (like those for pointer movement and release), stops the drag observer, determines the relevant final drop zone (via observation state), and updates data arrays by swapping placeholders with the actual dragged item. It then dispatches a finalize event to commit the change and optionally notifies both the old and new drop zones if they differ. cleanupPostDrop is subsequently called to handle DOM and memory cleanup: removing the clone, clearing temporary attributes and flags, and resetting global state. These functions require correct setup of drag/session state, event registration, and event dispatch utilities. Inputs are release events; outputs include dispatched events, DOM cleanup, and internal state reset. Should be used in coordination with the drag start/initiation logic for full, robust DnD handling.\nSOURCE: https://github.com/6p5ra/svelte-dnd-action-docs/blob/main/svelte-dnd-action.md#_snippet_13\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Simplified from src/pointerAction.js\n\nfunction handleDrop() {\n  printDebug(() => \"dropped\");\n  finalizingPreviousDrag = true; // Flag during cleanup\n\n  // --- Cleanup Phase 1: Stop listening ---\n  window.removeEventListener(\"mousemove\", handleMouseMove);\n  // ... remove touchmove, mouseup, touchend listeners ...\n  unWatchDraggedElement(); // Stop the observer\n\n  // --- Determine Final State ---\n  // The observer logic has likely updated `shadowElDropZone`\n  // based on the last 'consider' event.\n  const finalDropZone = shadowElDropZone || originDropZone; // Fallback to origin\n  const { items: itemsInFinalZone } = dzToConfig.get(finalDropZone);\n\n  // Replace placeholder/shadow data with the actual dragged item data\n  const finalItems = itemsInFinalZone.map(item =>\n    item[SHADOW_ITEM_MARKER_PROPERTY_NAME] ? draggedElData : item\n  );\n\n  // --- Dispatch Final Event ---\n  dispatchFinalizeEvent(finalDropZone, finalItems, /* info */);\n  // If dropped in a different zone, notify the origin zone too (optional)\n  if (finalDropZone !== originDropZone) {\n    dispatchFinalizeEvent(originDropZone, /* original zone items */, /* info */);\n  }\n\n  // --- Cleanup Phase 2: Visuals & State ---\n  // Optional: Animate the draggedEl smoothly into its final spot\n  // animateDraggedToFinalPosition(...)\n  cleanupPostDrop(); // Remove clone, reset styles, clear state vars\n}\n\nfunction cleanupPostDrop() {\n  if (draggedEl) draggedEl.remove(); // Remove the clone\n  // ... remove temporary attributes, reset global state variables ...\n  isWorkingOnPreviousDrag = false;\n  finalizingPreviousDrag = false;\n  // ... other resets ...\n}\n```\n\n----------------------------------------\n\nTITLE: Visualizing Drag and Drop Event Flow with Mermaid Diagram\nDESCRIPTION: A sequence diagram illustrating the complete flow of a drag operation, showing how user actions trigger internal svelte-dnd-action logic which dispatches events to update component state with visual feedback.\nSOURCE: https://github.com/6p5ra/svelte-dnd-action-docs/blob/main/svelte-dnd-action.md#_snippet_6\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    participant User\n    participant dndzoneLogic as \"dndzone Logic\"\n    participant YourComponent as \"Your Component (DraggableList.svelte)\"\n\n    User->>dndzoneLogic: Starts dragging item (id: 3)\n    User->>dndzoneLogic: Moves item over index 1\n    dndzoneLogic->>dndzoneLogic: Calculates potential order: [1, 3, 2]\n    dndzoneLogic->>YourComponent: Dispatches 'consider' event (items: [1, 3, 2])\n    YourComponent->>YourComponent: Updates 'tasks' state = [1, 3, 2] (UI updates visually)\n    User->>dndzoneLogic: Moves item over index 0\n    dndzoneLogic->>dndzoneLogic: Calculates potential order: [3, 1, 2]\n    dndzoneLogic->>YourComponent: Dispatches 'consider' event (items: [3, 1, 2])\n    YourComponent->>YourComponent: Updates 'tasks' state = [3, 1, 2] (UI updates visually)\n    User->>dndzoneLogic: Drops item at index 0\n    dndzoneLogic->>dndzoneLogic: Calculates final order: [3, 1, 2]\n    dndzoneLogic->>YourComponent: Dispatches 'finalize' event (items: [3, 1, 2])\n    YourComponent->>YourComponent: Updates 'tasks' state = [3, 1, 2] (Final state confirmed)\n```\n\n----------------------------------------\n\nTITLE: Making Live Announcements via Screen Reader Alert Region (JavaScript)\nDESCRIPTION: This JavaScript snippet from src/helpers/aria.js exports a function that, when invoked, updates the content of a hidden alert div to trigger a screen reader announcement. It checks for browser context, initializes the alert node if necessary, and sets its text content to the provided message. Dependencies: browser DOM API and prior initialization of the alert element. Parameter: txt (string, the message to announce). Input: textual message; output: real-time audible notification via assistive technology. Limitation: no effect on the server; requires a DOM environment.\nSOURCE: https://github.com/6p5ra/svelte-dnd-action-docs/blob/main/svelte-dnd-action.md#_snippet_29\n\nLANGUAGE: javascript\nCODE:\n```\n// Simplified from src/helpers/aria.js\n\n/**\n * Makes the screen reader announce the provided text.\n * @param {string} txt - The message to announce.\n */\nexport function alertToScreenReader(txt) {\n    if (isOnServer) return; // Doesn't work on server\n    if (!alertsDiv) {\n        initAriaOnBrowser(); // Create the div if it's the first time\n    }\n    // Simply changing the text content triggers the announcement!\n    alertsDiv.textContent = txt;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Running the Observation Cycle with Event Dispatching in svelte-dnd-action (JavaScript)\nDESCRIPTION: This function, 'runObservationCycle', implements the periodic observer logic responsible for determining the real-time zone and index of a dragged element in the svelte-dnd-action library. It checks for auto-scrolling, verifies whether the dragged element has left the document, iterates through all candidate drop zones to compute index placement, and compares the current zone/index to previously remembered values. Based on state transitions, it dispatches events such as 'entered', 'left', and 'overIndex', and updates its cache accordingly. Dependencies include helper functions like findCenterOfElement, multiScroller, findWouldBeIndex, and several event dispatchers; expected parameters are the DOM element being dragged, a list of possible drop zones, and a multi-scroller instance. Inputs are DOM elements and collections, while outputs are side-effect event dispatches and cache updates; assumes elements are well-formed and available during lifecycle.\nSOURCE: https://github.com/6p5ra/svelte-dnd-action-docs/blob/main/svelte-dnd-action.md#_snippet_42\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Simplified logic that would be inside the 'andNow' function above\n\nfunction runObservationCycle(draggedEl, dropZonesToCheck, multiScroller) {\n    const currentCenter = findCenterOfElement(draggedEl);\n\n    // 1. Check for scrolling first\n    const scrolled = multiScroller.multiScrollIfNeeded();\n    if (scrolled) {\n        resetIndexesCache(); // Layout changed, recalculate next time\n        return; // Skip intersection checks this cycle if scrolling happened\n    }\n\n    // 2. Check if element left the document (edge case)\n    if (isElementOffDocument(draggedEl)) {\n        // dispatch event indicating it left the document...\n        unobserve(); // Stop observing\n        return;\n    }\n\n    // 3. Find the current zone and index\n    let currentZone = undefined;\n    let currentIndex = undefined;\n    let indexObj = null;\n    for (const dz of dropZonesToCheck) {\n        indexObj = findWouldBeIndex(draggedEl, dz); // The core calculation!\n        if (indexObj !== null) {\n            // Found a zone the element is currently in!\n            currentZone = dz;\n            currentIndex = indexObj.index;\n            break; // Stop checking other zones (we found the most specific one)\n        }\n    }\n\n    // 4. Compare current state to previous state and dispatch events\n    if (currentZone) {\n        // We are inside a zone\n        if (currentZone !== lastDropZoneFound) {\n            // Entered a NEW zone\n            lastDropZoneFound && dispatchLeft(lastDropZoneFound, /* details */);\n            dispatchEntered(currentZone, indexObj);\n            lastDropZoneFound = currentZone;\n            lastIndexFound = currentIndex;\n        } else if (currentIndex !== lastIndexFound) {\n            // Moved WITHIN the same zone\n            dispatchOverIndex(currentZone, indexObj);\n            lastIndexFound = currentIndex;\n        }\n    } else {\n        // We are NOT inside any zone\n        if (lastDropZoneFound) {\n            // We just LEFT a zone\n            dispatchLeft(lastDropZoneFound, /* details */);\n            lastDropZoneFound = undefined;\n            lastIndexFound = undefined;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling Drop Animation for Instant Clone Removal in svelte-dnd-action\nDESCRIPTION: Shows how to disable the default drop animation where the dragged clone smoothly moves to the placeholder position by setting the `dropAnimationDisabled` option to true on the `dndzone` action. This causes the clone to disappear instantly on drop with no animation, and the item immediately appears in its final list position. Useful for users preferring immediate state updates.\nSOURCE: https://github.com/6p5ra/svelte-dnd-action-docs/blob/main/svelte-dnd-action.md#_snippet_19\n\nLANGUAGE: HTML\nCODE:\n```\n<section use:dndzone={{ items, dropAnimationDisabled: true }} on:consider={handleUpdate} on:finalize={handleUpdate}>\n  <!-- ... -->\n</section>\n```\n\n----------------------------------------\n\nTITLE: Calculating Drop Index in Svelte\nDESCRIPTION: This function, `findWouldBeIndex`, determines the index where a dragged element would be placed within a drop zone. It checks for direct intersection with child elements first, and then calculates the distance to find the nearest child if no direct hit is found.  It relies on helper functions from `intersection.js` for calculations.\nSOURCE: https://github.com/6p5ra/svelte-dnd-action-docs/blob/main/svelte-dnd-action.md#_snippet_44\n\nLANGUAGE: javascript\nCODE:\n```\n/**\n * Find the index for the dragged element in the list it is dragged over\n * @param {HTMLElement} floatingAboveEl - The visual clone being dragged\n * @param {HTMLElement} collectionBelowEl - The dndzone container element\n * @returns {{index: number, isProximityBased: boolean}|null}\n */\nexport function findWouldBeIndex(floatingAboveEl, collectionBelowEl) {\n  // 1. Is the center of the dragged element inside the zone container?\n  if (!isCenterOfAInsideB(floatingAboveEl, collectionBelowEl)) {\n    return null; // Not inside this zone\n  }\n\n  const children = collectionBelowEl.children;\n  if (children.length === 0) {\n    return { index: 0, isProximityBased: true }; // Empty zone, index is 0\n  }\n\n  // 2. Check for direct intersection with any child item\n  for (let i = 0; i < children.length; i++) {\n    // Note: Ignores placeholder/shadow element if present\n    if (children[i].hasAttribute(\"data-is-dnd-shadow-item-hint\")) continue;\n\n    if (isCenterOfAInsideB(floatingAboveEl, children[i])) {\n      // Direct hit!\n      return { index: i, isProximityBased: false };\n    }\n  }\n\n  // 3. No direct intersection, find the nearest child item\n  let minDistanceSoFar = Number.MAX_VALUE;\n  let indexOfMin = undefined;\n  for (let i = 0; i < children.length; i++) {\n    if (children[i].hasAttribute(\"data-is-dnd-shadow-item-hint\")) continue;\n\n    const distance = calcDistanceBetweenCenters(floatingAboveEl, children[i]);\n    if (distance < minDistanceSoFar) {\n      minDistanceSoFar = distance;\n      indexOfMin = i;\n    }\n  }\n\n  // Return the index of the closest item found\n  return { index: indexOfMin, isProximityBased: true };\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Element Clone in JavaScript for Drag Operations\nDESCRIPTION: The createDraggedElementFrom function creates a visual clone of an element for dragging, copying styles and setting positioning. It uses svelteNodeClone to handle Svelte-specific issues and applies CSS properties for proper visual appearance.\nSOURCE: https://github.com/6p5ra/svelte-dnd-action-docs/blob/main/svelte-dnd-action.md#_snippet_21\n\nLANGUAGE: javascript\nCODE:\n```\n// Simplified from src/helpers/styler.js\nimport { svelteNodeClone } from \"./svelteNodeClone\";\nimport { DRAGGED_ELEMENT_ID } from \"../constants\";\n\nconst TRANSITION_DURATION_SECONDS = 0.2;\nfunction trs(property) { /* generates transition string */ }\n\nexport function createDraggedElementFrom(originalElement, positionCenterOnXY) {\n    const rect = originalElement.getBoundingClientRect();\n    // Use svelteNodeClone to handle Svelte-specific issues\n    const draggedEl = svelteNodeClone(originalElement);\n\n    // Copy visual styles (background, padding, font, border, etc.)\n    copyStylesFromTo(originalElement, draggedEl); // Helper function\n\n    draggedEl.id = DRAGGED_ELEMENT_ID; // Assign the special ID\n    draggedEl.style.position = \"fixed\"; // Position relative to viewport\n    draggedEl.style.left = `${rect.left}px`;\n    draggedEl.style.top = `${rect.top}px`;\n    // ... (logic to center on cursor if positionCenterOnXY is provided) ...\n    draggedEl.style.margin = \"0\";\n    draggedEl.style.boxSizing = \"border-box\"; // Prevent padding/border issues\n    draggedEl.style.height = `${rect.height}px`; // Fixed size\n    draggedEl.style.width = `${rect.width}px`;\n    // Add CSS transitions for smooth movement/morphing\n    draggedEl.style.transition = `${trs(\"top\")}, ${trs(\"left\")}, ...`;\n    draggedEl.style.zIndex = \"9999\"; // Ensure it's on top\n    draggedEl.style.cursor = \"grabbing\"; // Visual cue\n\n    return draggedEl;\n}\n\nfunction copyStylesFromTo(copyFromEl, copyToEl) {\n    // Gets computed styles from copyFromEl and applies relevant ones\n    // (like background, padding, font, border, color, etc.) to copyToEl.\n    // ... implementation details ...\n}\n```\n\n----------------------------------------\n\nTITLE: Helper Functions for Intersection Calculations\nDESCRIPTION: This code provides geometric utility functions for calculating element positions and distances. `getElementRect` retrieves the bounding rectangle.  `findCenter` and `findCenterOfElement` determine the center of a rectangle or element. `isCenterOfAInsideB` checks for intersection, and `calcDistanceBetweenCenters` determines the center-to-center distance between two elements. These functions are crucial for detecting the drag and drop position.\nSOURCE: https://github.com/6p5ra/svelte-dnd-action-docs/blob/main/svelte-dnd-action.md#_snippet_45\n\nLANGUAGE: javascript\nCODE:\n```\n/**\n * Gets the element's bounding box relative to the viewport.\n * @param {HTMLElement} el\n * @returns {{top: number, left: number, bottom: number, right: number}}\n */\nfunction getElementRect(el) {\n  // The actual implementation handles transforms and scroll positions\n  // using el.getBoundingClientRect() and window.scrollX/Y\n  return el.getBoundingClientRect();\n  // Simplified Example Rect: { top: 100, left: 50, bottom: 150, right: 250 }\n}\n\n/**\n * Finds the center coordinates of a rectangle.\n * @param {Rect} rect - Bounding box object\n * @returns {{x: number, y: number}}\n */\nexport function findCenter(rect) {\n  return {\n    x: (rect.left + rect.right) / 2, // Avg of left & right edges\n    y: (rect.top + rect.bottom) / 2, // Avg of top & bottom edges\n  };\n}\n\n/**\n * Finds the center coordinates of an HTML element.\n * @param {HTMLElement} el\n * @returns {{x: number, y: number}}\n */\nexport function findCenterOfElement(el) {\n  return findCenter(getElementRect(el));\n}\n\n/**\n * Checks if the center point of element A is inside the bounding box of element B.\n * @param {HTMLElement} elA\n * @param {HTMLElement} elB\n * @returns {boolean}\n */\nexport function isCenterOfAInsideB(elA, elB) {\n  const centerOfA = findCenterOfElement(elA);\n  const rectOfB = getElementRect(elB);\n  // Check if center point coordinates fall within rect limits\n  return (\n    centerOfA.y <= rectOfB.bottom &&\n    centerOfA.y >= rectOfB.top &&\n    centerOfA.x >= rectOfB.left &&\n    centerOfA.x <= rectOfB.right\n  );\n}\n\n/**\n * Calculates the distance between two points.\n * @param {{x: number, y: number}} pointA\n * @param {{x: number, y: number}} pointB\n * @returns {number} - The distance (Pythagorean theorem)\n */\nfunction calcDistance(pointA, pointB) {\n  const dx = pointA.x - pointB.x;\n  const dy = pointA.y - pointB.y;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\n/**\n * Calculates the distance between the center points of two elements.\n * @param {HTMLElement} elA\n * @param {HTMLElement} elB\n * @returns {number}\n */\nexport function calcDistanceBetweenCenters(elA, elB) {\n  const centerOfA = findCenterOfElement(elA);\n  const centerOfB = findCenterOfElement(elB);\n  return calcDistance(centerOfA, centerOfB);\n}\n```\n\n----------------------------------------\n\nTITLE: Structure of event.detail for Consider and Finalize Events in JavaScript\nDESCRIPTION: This JavaScript object outlines the structure of event.detail received from consider and finalize events dispatched by svelte-dnd-action. Key fields include items (the reordered array) and info (metadata about the source and action). Intended for Svelte event-driven handlers that wish to distinguish between triggers or input sources. Inputs are generated by the drag-and-drop logic; output is an event.detail object. Limitations: content of info may vary based on interaction and configuration.\nSOURCE: https://github.com/6p5ra/svelte-dnd-action-docs/blob/main/svelte-dnd-action.md#_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Example structure of event.detail\nevent.detail = {\n  items: [/* the updated array */],\n  info: {\n    trigger: \"draggedOverIndex\", // What caused this event? (e.g., DROPPED_INTO_ZONE)\n    id: 3, // The ID of the item being dragged\n    source: \"pointer\" // Was it mouse/touch (\"pointer\") or keyboard?\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Highlighting Drop Zone by Inline Styles in Svelte (JavaScript + HTML)\nDESCRIPTION: Demonstrates how to apply inline styles dynamically to the `dndzone` container element while dragging over it, using the `dropTargetStyle` option. A style object with dashed outline and light blue background is provided and passed as an option. The example handles updating the items array on `consider` and `finalize` events. This customization improves usability by visually highlighting valid drop zones.\nSOURCE: https://github.com/6p5ra/svelte-dnd-action-docs/blob/main/svelte-dnd-action.md#_snippet_16\n\nLANGUAGE: HTML\nCODE:\n```\n<script>\n  let items = [{id: 1, name: 'A'}, {id: 2, name: 'B'}];\n  // Define the style object\n  const highlightStyle = {\n    outline: '2px dashed dodgerblue',\n    'background-color': 'rgba(100, 149, 237, 0.1)'\n  };\n  function handleUpdate(e) { items = e.detail.items; }\n</script>\n\n<section\n  use:dndzone={{ items, dropTargetStyle: highlightStyle }}\n  on:consider={handleUpdate}\n  on:finalize={handleUpdate}\n>\n  {#each items as item (item.id)}<div>{item.name}</div>{/each}\n</section>\n```\n\n----------------------------------------\n\nTITLE: Edge Proximity Detection and Auto-Scrolling Logic in JavaScript\nDESCRIPTION: This code defines functions to calculate the distance of a pointer to the inner edges of a scrollable element and conditionally trigger scrolling if the pointer is near an edge. The `calcInnerDistancesBetweenPointAndSidesOfElement` function returns the distances from a pointer position to each side of the element's visible area, returning null if the pointer is outside. The `scrollIfNeeded` function uses these distances to detect if the pointer is within a defined threshold (`SCROLL_ZONE_PX`) near any scrollable edge, and triggers scrolling in the corresponding direction using `element.scrollBy`. It manages scrolling state to start and stop scrolling smoothly, making the drag-and-drop interaction responsive to pointer movements near container edges.\nSOURCE: https://github.com/6p5ra/svelte-dnd-action-docs/blob/main/svelte-dnd-action.md#_snippet_34\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Simplified from src/helpers/scroller.js\n\nconst SCROLL_ZONE_PX = 30; // How close to the edge triggers scrolling\nlet scrollingInfo = { directionObj: undefined, stepPx: 0 }; // Holds current scroll state\n\n// Calculates distance from point to edges *inside* the element's bounds\nfunction calcInnerDistancesBetweenPointAndSidesOfElement(point, el) {\n    // Get element's visible bounds (viewport for document)\n    const rect = (el === document.scrollingElement) ?\n        { top: 0, bottom: window.innerHeight, left: 0, right: window.innerWidth } :\n        el.getBoundingClientRect();\n\n    // Is the point even inside the element? (Basic check)\n    if (point.y < rect.top || point.y > rect.bottom || point.x < rect.left || point.x > rect.right) {\n        return null;\n    }\n\n    // Calculate distances\n    return {\n        top: point.y - rect.top,\n        bottom: rect.bottom - point.y,\n        left: point.x - rect.left,\n        right: rect.right - point.x\n    };\n}\n\nfunction scrollIfNeeded(pointer, elementToScroll) {\n    if (!elementToScroll) return false;\n\n    const distances = calcInnerDistancesBetweenPointAndSidesOfElement(pointer, elementToScroll);\n    const isAlreadyScrolling = !!scrollingInfo.directionObj;\n\n    if (distances === null) { // Pointer is outside the element\n        if (isAlreadyScrolling) scrollingInfo.directionObj = undefined; // Stop scrolling\n        return false;\n    }\n\n    let scrollDirection = { x: 0, y: 0 };\n    let needsToScroll = false;\n\n    // Check Vertical Edges\n    if (elementToScroll.scrollHeight > elementToScroll.clientHeight) {\n        if (distances.bottom < SCROLL_ZONE_PX) {\n            scrollDirection = { x: 0, y: 1 }; // Scroll Down\n            needsToScroll = true;\n        } else if (distances.top < SCROLL_ZONE_PX) {\n            scrollDirection = { x: 0, y: -1 }; // Scroll Up\n            needsToScroll = true;\n        }\n    }\n\n    // Check Horizontal Edges (if not already scrolling vertically)\n    if (!needsToScroll && elementToScroll.scrollWidth > elementToScroll.clientWidth) {\n        if (distances.right < SCROLL_ZONE_PX) {\n            scrollDirection = { x: 1, y: 0 }; // Scroll Right\n            needsToScroll = true;\n        } else if (distances.left < SCROLL_ZONE_PX) {\n            scrollDirection = { x: -1, y: 0 }; // Scroll Left\n            needsToScroll = true;\n        }\n    }\n\n    if (needsToScroll) {\n        if (!isAlreadyScrolling) { // Start the scroll loop\n            scrollingInfo.directionObj = scrollDirection;\n            // Actual scroll happens in a requestAnimationFrame loop (simplified here)\n            elementToScroll.scrollBy(scrollDirection.x * 5, scrollDirection.y * 5); // Simple scroll step\n            // In reality, scrollContainer() uses requestAnimationFrame for smooth scrolling\n        }\n        return true; // Indicate scrolling is happening/needed\n    } else {\n        // Pointer is inside but not near edge\n        if (isAlreadyScrolling) scrollingInfo.directionObj = undefined; // Stop scrolling\n        return false;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Drag-and-Drop Events to Update List Order\nDESCRIPTION: Defines a function to listen to 'consider' and 'finalize' events emitted by dndzone, updating the 'tasks' array with the new order provided in event.detail.items, thereby ensuring the visual list reflects the user's drag-and-drop actions.\nSOURCE: https://github.com/6p5ra/svelte-dnd-action-docs/blob/main/svelte-dnd-action.md#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nfunction handleDndUpdate(event) {\n  tasks = event.detail.items;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Event Dispatching in svelte-dnd-action\nDESCRIPTION: The core dispatcher code from svelte-dnd-action that creates and sends consider/finalize CustomEvents to communicate potential and final item ordering to Svelte components. The events carry the reordered items array and additional context information.\nSOURCE: https://github.com/6p5ra/svelte-dnd-action-docs/blob/main/svelte-dnd-action.md#_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\n// File: src/helpers/dispatcher.js (Simplified)\n\n// Define the names of our custom events\nconst FINALIZE_EVENT_NAME = \"finalize\";\nconst CONSIDER_EVENT_NAME = \"consider\";\n\n/**\n * Dispatches a finalize event with the final list and info\n * @param {Node} el - The dndzone HTML element.\n * @param {Array} items - The final array of items.\n * @param {Object} info - Extra context about the event.\n */\nexport function dispatchFinalizeEvent(el, items, info) {\n    // Create a standard CustomEvent\n    const event = new CustomEvent(FINALIZE_EVENT_NAME, {\n        // Attach our data (items, info) to the 'detail' property\n        detail: { items, info }\n    });\n    // Tell the HTML element to dispatch this event\n    el.dispatchEvent(event);\n}\n\n/**\n * Dispatches a consider event with the potential list and info\n * @param {Node} el - The dndzone HTML element.\n * @param {Array} items - The potential array of items.\n * @param {Object} info - Extra context about the event.\n */\nexport function dispatchConsiderEvent(el, items, info) {\n    const event = new CustomEvent(CONSIDER_EVENT_NAME, {\n        detail: { items, info }\n    });\n    el.dispatchEvent(event);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the dndzone Action with Pointer and Keyboard Logic in JavaScript\nDESCRIPTION: This JavaScript snippet defines the main dndzone Svelte action. It coordinates pointer and keyboard drag logic, validates the provided options (requiring an 'items' array where every item contains an ID), and returns update and destroy handlers expected by Svelte's action API. Required dependencies include pointerAction, keyboardAction, and a shared constants file. The main function expects a DOM node and options object. All items must have a unique id as defined by ITEM_ID_KEY. Throws errors for missing or invalid input to enforce correct usage.\nSOURCE: https://github.com/6p5ra/svelte-dnd-action-docs/blob/main/svelte-dnd-action.md#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\n// File: src/action.js (Simplified)\n\n// Import logic for pointer (mouse/touch) and keyboard\nimport { dndzone as pointerDndZone } from \"./pointerAction\";\nimport { dndzone as keyboardDndZone } from \"./keyboardAction\";\nimport { ITEM_ID_KEY } from \"./constants\";\n\n// The main action function Svelte calls\nexport function dndzone(node, options) {\n    // Basic checks on the options you provide\n    validateOptions(options);\n\n    // Create and manage the pointer-based drag-and-drop logic\n    const pointerZone = pointerDndZone(node, options);\n\n    // Create and manage the keyboard-based drag-and-drop logic\n    const keyboardZone = keyboardDndZone(node, options);\n\n    // Return methods Svelte uses to update or destroy the action\n    return {\n        update: newOptions => {\n            validateOptions(newOptions);\n            pointerZone.update(newOptions);\n            keyboardZone.update(newOptions);\n        },\n        destroy: () => {\n            pointerZone.destroy();\n            keyboardZone.destroy();\n        }\n    };\n}\n\n// Helper to check if required options are present\nfunction validateOptions(options) {\n    if (!options.items) {\n        throw new Error(\"no 'items' key provided to dndzone\");\n    }\n    const itemWithMissingId = options.items.find(item => !item.hasOwnProperty(ITEM_ID_KEY));\n    if (itemWithMissingId) {\n        // Remember: every item needs a unique id!\n        throw new Error(`missing '${ITEM_ID_KEY}' property for item...`);\n    }\n    // ... other checks\n}\n\n```\n\n----------------------------------------\n\nTITLE: Drag and Drop Sequence Visualization with Mermaid\nDESCRIPTION: A sequence diagram showing the flow of events between User, Task Item, Pointer Interaction Handler, Observer Logic, and dndzone Element during a drag and drop operation.\nSOURCE: https://github.com/6p5ra/svelte-dnd-action-docs/blob/main/svelte-dnd-action.md#_snippet_8\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    participant User\n    participant Task2Item as \"Task 2 Item\"\n    participant PointerHandler as \"Pointer Interaction Handler\"\n    participant Observer as \"Observer Logic\"\n    participant dndzone as \"dndzone Element\"\n\n    User->>Task2Item: Presses mouse down\n    Task2Item->>PointerHandler: Notifies: 'mousedown' event detected!\n    PointerHandler->>PointerHandler: Records start position, waits for movement.\n    User->>Task2Item: Moves mouse slightly (e.g., 5 pixels)\n    PointerHandler->>PointerHandler: Movement threshold passed! Initiate drag.\n    PointerHandler->>PointerHandler: Creates visual clone of Task 2\n    PointerHandler->>Observer: Start tracking clone's position relative to zones\n    User->>Task2Item: Moves mouse over Task 1's position\n    PointerHandler->>PointerHandler: Updates clone's position on screen\n    Observer->>PointerHandler: Reports: Clone is now over index 0 in the zone\n    PointerHandler->>dndzone: Dispatches 'consider' event (new potential order)\n    User->>Task2Item: Releases mouse button\n    PointerHandler->>Observer: Stop tracking clone's position\n    PointerHandler->>PointerHandler: Determines final drop index is 0\n    PointerHandler->>dndzone: Dispatches 'finalize' event (final order)\n    PointerHandler->>PointerHandler: Removes visual clone, cleans up styles\n```\n\n----------------------------------------\n\nTITLE: Styling the Placeholder (Shadow Item) Using Data Attributes in CSS\nDESCRIPTION: Applies custom CSS styling to the placeholder item that appears during dragging, identified by the data attribute `data-is-dnd-shadow-item-hint=\"true\"`. This placeholder visually marks the intended drop position with a distinct background, partial transparency, and dashed outline. Requires `dndzone` configuration to add this attribute. Styles help differentiate the placeholder from regular list items in the UI.\nSOURCE: https://github.com/6p5ra/svelte-dnd-action-docs/blob/main/svelte-dnd-action.md#_snippet_15\n\nLANGUAGE: CSS\nCODE:\n```\n/* Style the placeholder item differently */\n[data-is-dnd-shadow-item-hint=\"true\"] {\n  background-color: #f0f0f0;\n  opacity: 0.6;\n  outline: 1px dashed #ccc;\n}\n```\n\n----------------------------------------\n\nTITLE: Keyboard and Accessibility Integration Diagram\nDESCRIPTION: Mermaid sequence diagram showing how the Keyboard Handler interacts with the Aria helper to provide screen reader announcements during drag and drop operations.\nSOURCE: https://github.com/6p5ra/svelte-dnd-action-docs/blob/main/svelte-dnd-action.md#_snippet_32\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    participant User\n    participant KeyboardHandler as \"Keyboard Handler (keyboardAction.js)\"\n    participant AriaHelper as \"Aria Helper (aria.js)\"\n    participant ScreenReader as \"Screen Reader\"\n\n    User->>KeyboardHandler: Presses Spacebar to start drag\n    KeyboardHandler->>AriaHelper: Calls alertToScreenReader(\"Started dragging item X...\")\n    AriaHelper->>AriaHelper: Updates text in hidden div (role='alert')\n    AriaHelper-->>ScreenReader: Detects change in alert div\n    ScreenReader->>User: Announces \"Started dragging item X...\"\n    User->>KeyboardHandler: Presses ArrowUp to move item\n    KeyboardHandler->>AriaHelper: Calls alertToScreenReader(\"Moved item X to position Y...\")\n    AriaHelper->>AriaHelper: Updates text in hidden div\n    AriaHelper-->>ScreenReader: Detects change in alert div\n    ScreenReader->>User: Announces \"Moved item X to position Y...\"\n```\n\n----------------------------------------\n\nTITLE: Styling Placeholder Elements in JavaScript for Drag and Drop\nDESCRIPTION: Functions that manage the styling of placeholder elements during drag operations. decorateShadowEl adds styling to make the placeholder item invisible while maintaining its space, and unDecorateShadowElement cleans up those styles.\nSOURCE: https://github.com/6p5ra/svelte-dnd-action-docs/blob/main/svelte-dnd-action.md#_snippet_22\n\nLANGUAGE: javascript\nCODE:\n```\n// Simplified from src/helpers/styler.js\nimport { SHADOW_ELEMENT_ATTRIBUTE_NAME } from \"../constants\";\n\nexport function decorateShadowEl(shadowEl) {\n    // By default, the library just hides the placeholder visually,\n    // relying on its dimensions to create the gap.\n    shadowEl.style.visibility = \"hidden\";\n    // Add attribute for potential CSS targeting or internal checks\n    shadowEl.setAttribute(SHADOW_ELEMENT_ATTRIBUTE_NAME, \"true\");\n    // Note: If using data-is-dnd-shadow-item-hint, it's added elsewhere based on data\n}\n\nexport function unDecorateShadowElement(shadowEl) {\n    // Remove the styles when the placeholder is removed\n    shadowEl.style.visibility = \"\";\n    shadowEl.removeAttribute(SHADOW_ELEMENT_ATTRIBUTE_NAME);\n}\n```\n\n----------------------------------------\n\nTITLE: Applying svelte-dnd-action's dndzone in Svelte Component\nDESCRIPTION: This snippet demonstrates how to integrate the dndzone action into a Svelte component by adding use:dndzone to a container element, binding it to an array of items, and setting up event listeners for consider and finalize events to update the list order after drag-and-drop actions.\nSOURCE: https://github.com/6p5ra/svelte-dnd-action-docs/blob/main/svelte-dnd-action.md#_snippet_0\n\nLANGUAGE: HTML\nCODE:\n```\n<section\n  class=\"task-list\"\n  use:dndzone={{ items: tasks, flipDurationMs: 200 }}\n  on:consider={handleDndUpdate}\n  on:finalize={handleDndUpdate}\n>\n  {#each tasks as task (task.id)}\n    <div class=\"task-item\" animate:flip={{ duration: 200 }}>\n      {task.text}\n    </div>\n  {/each}\n</section>\n```\n\n----------------------------------------\n\nTITLE: Implementing a Scrollable Task List with svelte-dnd-action\nDESCRIPTION: Example of a scrollable task list component in Svelte that uses the dndzone action, demonstrating a case where auto-scrolling would be necessary for dragging items between distant positions in a long list.\nSOURCE: https://github.com/6p5ra/svelte-dnd-action-docs/blob/main/svelte-dnd-action.md#_snippet_30\n\nLANGUAGE: html\nCODE:\n```\n<!-- LongTaskList.svelte -->\n<script>\n  // ... setup with 50 tasks ...\n</script>\n<style>\n  .long-task-list {\n    height: 300px; /* Fixed height */\n    overflow-y: scroll; /* Make it scrollable vertically */\n    border: 1px solid #ccc;\n    padding: 10px;\n    width: 250px;\n  }\n  .task-item { /* ... styles ... */ }\n</style>\n\n<section class=\"long-task-list\" use:dndzone={{items: tasks}} ...>\n  {#each tasks as task (task.id)}\n    <div class=\"task-item\">{task.text}</div>\n  {/each}\n</section>\n```\n\n----------------------------------------\n\nTITLE: Initializing Tasks Array in Svelte for Drag-and-Drop List\nDESCRIPTION: Defines the initial list of task objects, each with a unique id and descriptive text, which serves as the data source managed by the dndzone application. The component updates this array upon drag events to reflect the reordered list.\nSOURCE: https://github.com/6p5ra/svelte-dnd-action-docs/blob/main/svelte-dnd-action.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nlet tasks = [\n  { id: 1, text: \"Buy milk\" },\n  { id: 2, text: \"Walk the dog\" },\n  { id: 3, text: \"Learn Svelte\" }\n];\n```"
  }
]